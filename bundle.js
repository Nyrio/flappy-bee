/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/excalibur/dist/excalibur.js":
/*!**************************************************!*\
  !*** ./node_modules/excalibur/dist/excalibur.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;/*! excalibur - v0.15.0 - 2018-02-17
* https://github.com/excaliburjs/Excalibur
* Copyright (c) 2018 Excalibur.js <https://github.com/excaliburjs/Excalibur/graphs/contributors>; Licensed BSD-2-Clause
* @preserve */
(function (root, factory) {
    if (true) {
        // AMD. Register as an anonymous module.
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function (b) {
            return (root.ex = factory(b));
        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function () {
    //almond, and your modules will be inlined here
/**
 * @license almond 0.3.3 Copyright jQuery Foundation and other contributors.
 * Released under MIT license, http://github.com/requirejs/almond/LICENSE
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice,
        jsSuffixRegExp = /\.js$/;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap, lastIndex,
            foundI, foundStarMap, starI, i, j, part, normalizedBaseParts,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name) {
            name = name.split('/');
            lastIndex = name.length - 1;

            // If wanting node ID compatibility, strip .js from end
            // of IDs. Have to do this here, and not in nameToUrl
            // because node allows either .js or non .js to map
            // to same file.
            if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
            }

            // Starts with a '.' so need the baseName
            if (name[0].charAt(0) === '.' && baseParts) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that 'directory' and not name of the baseName's
                //module. For instance, baseName of 'one/two/three', maps to
                //'one/two/three.js', but we want the directory, 'one/two' for
                //this normalization.
                normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                name = normalizedBaseParts.concat(name);
            }

            //start trimDots
            for (i = 0; i < name.length; i++) {
                part = name[i];
                if (part === '.') {
                    name.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    // If at the start, or previous value is still ..,
                    // keep them so that when converted to a path it may
                    // still work when converted to a path, even though
                    // as an ID it is less than ideal. In larger point
                    // releases, may be better to just kick out an error.
                    if (i === 0 || (i === 1 && name[2] === '..') || name[i - 1] === '..') {
                        continue;
                    } else if (i > 0) {
                        name.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
            //end trimDots

            name = name.join('/');
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            var args = aps.call(arguments, 0);

            //If first arg is not require('string'), and there is only
            //one arg, it is the array form without a callback. Insert
            //a null so that the following concat is correct.
            if (typeof args[0] !== 'string' && args.length === 1) {
                args.push(null);
            }
            return req.apply(undef, args.concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    //Creates a parts array for a relName where first part is plugin ID,
    //second part is resource ID. Assumes relName has already been normalized.
    function makeRelParts(relName) {
        return relName ? splitPrefix(relName) : [];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relParts) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0],
            relResourceName = relParts[1];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relResourceName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relResourceName));
            } else {
                name = normalize(name, relResourceName);
            }
        } else {
            name = normalize(name, relResourceName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i, relParts,
            args = [],
            callbackType = typeof callback,
            usingExports;

        //Use name if no relName
        relName = relName || name;
        relParts = makeRelParts(relName);

        //Call the callback to define the module, if necessary.
        if (callbackType === 'undefined' || callbackType === 'function') {
            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relParts);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback ? callback.apply(defined[name], args) : undefined;

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, makeRelParts(callback)).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (config.deps) {
                req(config.deps, config.callback);
            }
            if (!callback) {
                return;
            }

            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        return req(cfg);
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {
        if (typeof name !== 'string') {
            throw new Error('See almond README: incorrect module build, no module name');
        }

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());
/*! excalibur - v0.15.0 - 2018-02-17
* https://github.com/excaliburjs/Excalibur
* Copyright (c) 2018 Excalibur.js <https://github.com/excaliburjs/Excalibur/graphs/contributors>; Licensed BSD-2-Clause
* @preserve */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define("Actions/RotationType", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * An enum that describes the strategies that rotation actions can use
     */
    var RotationType;
    (function (RotationType) {
        /**
         * Rotation via `ShortestPath` will use the smallest angle
         * between the starting and ending points. This strategy is the default behavior.
         */
        RotationType[RotationType["ShortestPath"] = 0] = "ShortestPath";
        /**
         * Rotation via `LongestPath` will use the largest angle
         * between the starting and ending points.
         */
        RotationType[RotationType["LongestPath"] = 1] = "LongestPath";
        /**
         * Rotation via `Clockwise` will travel in a clockwise direction,
         * regardless of the starting and ending points.
         */
        RotationType[RotationType["Clockwise"] = 2] = "Clockwise";
        /**
         * Rotation via `CounterClockwise` will travel in a counterclockwise direction,
         * regardless of the starting and ending points.
         */
        RotationType[RotationType["CounterClockwise"] = 3] = "CounterClockwise";
    })(RotationType = exports.RotationType || (exports.RotationType = {}));
});
define("Algebra", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A 2D vector on a plane.
     */
    var Vector = (function () {
        /**
         * @param x  X component of the Vector
         * @param y  Y component of the Vector
         */
        function Vector(x, y) {
            this.x = x;
            this.y = y;
        }
        /**
         * Returns a vector of unit length in the direction of the specified angle in Radians.
         * @param angle The angle to generate the vector
         */
        Vector.fromAngle = function (angle) {
            return new Vector(Math.cos(angle), Math.sin(angle));
        };
        /**
         * Checks if vector is not null, undefined, or if any of its components are NaN or Infinity.
         */
        Vector.isValid = function (vec) {
            if (vec === null || vec === undefined) {
                return false;
            }
            if (isNaN(vec.x) || isNaN(vec.y)) {
                return false;
            }
            if (vec.x === Infinity ||
                vec.y === Infinity ||
                vec.x === -Infinity ||
                vec.y === Infinity) {
                return false;
            }
            return true;
        };
        /**
         * Calculates distance between two Vectors
         * @param vec1
         * @param vec2
         */
        Vector.distance = function (vec1, vec2) {
            return Math.sqrt(Math.pow(vec1.x - vec2.x, 2) + Math.pow(vec1.y - vec2.y, 2));
        };
        /**
         * Sets the x and y components at once
         */
        Vector.prototype.setTo = function (x, y) {
            this.x = x;
            this.y = y;
        };
        /**
         * Compares this point against another and tests for equality
         * @param point  The other point to compare to
         */
        Vector.prototype.equals = function (vector, tolerance) {
            if (tolerance === void 0) { tolerance = .001; }
            return Math.abs(this.x - vector.x) <= tolerance && Math.abs(this.y - vector.y) <= tolerance;
        };
        /**
         * The distance to another vector. If no other Vector is specified, this will return the [[magnitude]].
         * @param v  The other vector. Leave blank to use origin vector.
         */
        Vector.prototype.distance = function (v) {
            if (!v) {
                v = Vector.Zero;
            }
            return Math.sqrt(Math.pow(this.x - v.x, 2) + Math.pow(this.y - v.y, 2));
        };
        /**
         * The magnitude (size) of the Vector
         */
        Vector.prototype.magnitude = function () {
            return this.distance();
        };
        /**
         * Normalizes a vector to have a magnitude of 1.
         */
        Vector.prototype.normalize = function () {
            var d = this.distance();
            if (d > 0) {
                return new Vector(this.x / d, this.y / d);
            }
            else {
                return new Vector(0, 1);
            }
        };
        /**
         * Returns the average (midpoint) between the current point and the specified
         */
        Vector.prototype.average = function (vec) {
            return this.add(vec).scale(.5);
        };
        /**
         * Scales a vector's by a factor of size
         * @param size  The factor to scale the magnitude by
         */
        Vector.prototype.scale = function (size) {
            return new Vector(this.x * size, this.y * size);
        };
        /**
         * Adds one vector to another
         * @param v The vector to add
         */
        Vector.prototype.add = function (v) {
            return new Vector(this.x + v.x, this.y + v.y);
        };
        /**
         * Subtracts a vector from another, if you subract vector `B.sub(A)` the resulting vector points from A -> B
         * @param v The vector to subtract
         */
        Vector.prototype.sub = function (v) {
            return new Vector(this.x - v.x, this.y - v.y);
        };
        /**
         * Adds one vector to this one modifying the original
         * @param v The vector to add
         */
        Vector.prototype.addEqual = function (v) {
            this.x += v.x;
            this.y += v.y;
            return this;
        };
        /**
         * Subtracts a vector from this one modifying the original
         * @parallel v The vector to subtract
         */
        Vector.prototype.subEqual = function (v) {
            this.x -= v.x;
            this.y -= v.y;
            return this;
        };
        /**
         * Scales this vector by a factor of size and modifies the original
         */
        Vector.prototype.scaleEqual = function (size) {
            this.x *= size;
            this.y *= size;
            return this;
        };
        /**
         * Performs a dot product with another vector
         * @param v  The vector to dot
         */
        Vector.prototype.dot = function (v) {
            return this.x * v.x + this.y * v.y;
        };
        Vector.prototype.cross = function (v) {
            if (v instanceof Vector) {
                return this.x * v.y - this.y * v.x;
            }
            else if (typeof v === 'number') {
                return new Vector(v * this.y, -v * this.x);
            }
        };
        /**
         * Returns the perpendicular vector to this one
         */
        Vector.prototype.perpendicular = function () {
            return new Vector(this.y, -this.x);
        };
        /**
         * Returns the normal vector to this one, same as the perpendicular of length 1
         */
        Vector.prototype.normal = function () {
            return this.perpendicular().normalize();
        };
        /**
         * Negate the current vector
         */
        Vector.prototype.negate = function () {
            return this.scale(-1);
        };
        /**
         * Returns the angle of this vector.
         */
        Vector.prototype.toAngle = function () {
            return Math.atan2(this.y, this.x);
        };
        /**
         * Rotates the current vector around a point by a certain number of
         * degrees in radians
         */
        Vector.prototype.rotate = function (angle, anchor) {
            if (!anchor) {
                anchor = new Vector(0, 0);
            }
            var sinAngle = Math.sin(angle);
            var cosAngle = Math.cos(angle);
            var x = cosAngle * (this.x - anchor.x) - sinAngle * (this.y - anchor.y) + anchor.x;
            var y = sinAngle * (this.x - anchor.x) + cosAngle * (this.y - anchor.y) + anchor.y;
            return new Vector(x, y);
        };
        /**
         * Creates new vector that has the same values as the previous.
         */
        Vector.prototype.clone = function () {
            return new Vector(this.x, this.y);
        };
        /**
         * Returns a string repesentation of the vector.
         */
        Vector.prototype.toString = function () {
            return "(" + this.x + ", " + this.y + ")";
        };
        return Vector;
    }());
    /**
     * A (0, 0) vector
     */
    Vector.Zero = new Vector(0, 0);
    /**
     * A (1, 1) vector
     */
    Vector.One = new Vector(1, 1);
    /**
     * A (0.5, 0.5) vector
     */
    Vector.Half = new Vector(0.5, 0.5);
    /**
     * A unit vector pointing up (0, -1)
     */
    Vector.Up = new Vector(0, -1);
    /**
     * A unit vector pointing down (0, 1)
     */
    Vector.Down = new Vector(0, 1);
    /**
     * A unit vector pointing left (-1, 0)
     */
    Vector.Left = new Vector(-1, 0);
    /**
     * A unit vector pointing right (1, 0)
     */
    Vector.Right = new Vector(1, 0);
    exports.Vector = Vector;
    /**
     * A 2D ray that can be cast into the scene to do collision detection
     */
    var Ray = (function () {
        /**
         * @param pos The starting position for the ray
         * @param dir The vector indicating the direction of the ray
         */
        function Ray(pos, dir) {
            this.pos = pos;
            this.dir = dir.normalize();
        }
        /**
         * Tests a whether this ray intersects with a line segment. Returns a number greater than or equal to 0 on success.
         * This number indicates the mathematical intersection time.
         * @param line  The line to test
         */
        Ray.prototype.intersect = function (line) {
            var numerator = line.begin.sub(this.pos);
            // Test is line and ray are parallel and non intersecting
            if (this.dir.cross(line.getSlope()) === 0 && numerator.cross(this.dir) !== 0) {
                return -1;
            }
            // Lines are parallel
            var divisor = (this.dir.cross(line.getSlope()));
            if (divisor === 0) {
                return -1;
            }
            var t = numerator.cross(line.getSlope()) / divisor;
            if (t >= 0) {
                var u = (numerator.cross(this.dir) / divisor) / line.getLength();
                if (u >= 0 && u <= 1) {
                    return t;
                }
            }
            return -1;
        };
        /**
         * Returns the point of intersection given the intersection time
         */
        Ray.prototype.getPoint = function (time) {
            return this.pos.add(this.dir.scale(time));
        };
        return Ray;
    }());
    exports.Ray = Ray;
    /**
     * A 2D line segment
     */
    var Line = (function () {
        /**
         * @param begin  The starting point of the line segment
         * @param end  The ending point of the line segment
         */
        function Line(begin, end) {
            this.begin = begin;
            this.end = end;
        }
        Object.defineProperty(Line.prototype, "slope", {
            /**
             * Gets the raw slope (m) of the line. Will return (+/-)Infinity for vertical lines.
             */
            get: function () {
                return (this.end.y - this.begin.y) / (this.end.x - this.begin.x);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Line.prototype, "intercept", {
            /**
             * Gets the Y-intercept (b) of the line. Will return (+/-)Infinity if there is no intercept.
             */
            get: function () {
                return this.begin.y - (this.slope * this.begin.x);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Gets the normal of the line
         */
        Line.prototype.normal = function () {
            return this.end.sub(this.begin).normal();
        };
        /**
         * Returns the slope of the line in the form of a vector
         */
        Line.prototype.getSlope = function () {
            var begin = this.begin;
            var end = this.end;
            var distance = begin.distance(end);
            return end.sub(begin).scale(1 / distance);
        };
        /**
         * Returns the length of the line segment in pixels
         */
        Line.prototype.getLength = function () {
            var begin = this.begin;
            var end = this.end;
            var distance = begin.distance(end);
            return distance;
        };
        /**
         * Find the perpendicular distance from the line to a point
         * https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
         * @param point
         */
        Line.prototype.distanceToPoint = function (point) {
            var x0 = point.x;
            var y0 = point.y;
            var l = this.getLength();
            var dy = this.end.y - this.begin.y;
            var dx = this.end.x - this.begin.x;
            var distance = Math.abs(dy * x0 - dx * y0 + this.end.x * this.begin.y - this.end.y * this.begin.x) / l;
            return distance;
        };
        /**
         * Finds a point on the line given only an X or a Y value. Given an X value, the function returns
         * a new point with the calculated Y value and vice-versa.
         *
         * @param x The known X value of the target point
         * @param y The known Y value of the target point
         * @returns A new point with the other calculated axis value
         */
        Line.prototype.findPoint = function (x, y) {
            if (x === void 0) { x = null; }
            if (y === void 0) { y = null; }
            var m = this.slope;
            var b = this.intercept;
            if (x !== null) {
                return new Vector(x, (m * x) + b);
            }
            else if (y !== null) {
                return new Vector((y - b) / m, y);
            }
            else {
                throw new Error('You must provide an X or a Y value');
            }
        };
        /**
         * @see http://stackoverflow.com/a/11908158/109458
         */
        Line.prototype.hasPoint = function () {
            var currPoint;
            var threshold = 0;
            if (typeof arguments[0] === 'number' &&
                typeof arguments[1] === 'number') {
                currPoint = new Vector(arguments[0], arguments[1]);
                threshold = arguments[2] || 0;
            }
            else if (arguments[0] instanceof Vector) {
                currPoint = arguments[0];
                threshold = arguments[1] || 0;
            }
            else {
                throw 'Could not determine the arguments for Vector.hasPoint';
            }
            var dxc = currPoint.x - this.begin.x;
            var dyc = currPoint.y - this.begin.y;
            var dx1 = this.end.x - this.begin.x;
            var dy1 = this.end.y - this.begin.y;
            var cross = dxc * dy1 - dyc * dx1;
            // check whether point lines on the line
            if (Math.abs(cross) > threshold) {
                return false;
            }
            // check whether point lies in-between start and end
            if (Math.abs(dx1) >= Math.abs(dy1)) {
                return dx1 > 0
                    ? this.begin.x <= currPoint.x && currPoint.x <= this.end.x
                    : this.end.x <= currPoint.x && currPoint.x <= this.begin.x;
            }
            else {
                return dy1 > 0
                    ? this.begin.y <= currPoint.y && currPoint.y <= this.end.y
                    : this.end.y <= currPoint.y && currPoint.y <= this.begin.y;
            }
        };
        return Line;
    }());
    exports.Line = Line;
    /**
     * A 1 dimensional projection on an axis, used to test overlaps
     */
    var Projection = (function () {
        function Projection(min, max) {
            this.min = min;
            this.max = max;
        }
        Projection.prototype.overlaps = function (projection) {
            return this.max > projection.min && projection.max > this.min;
        };
        Projection.prototype.getOverlap = function (projection) {
            if (this.overlaps(projection)) {
                if (this.max > projection.max) {
                    return projection.max - this.min;
                }
                else {
                    return this.max - projection.min;
                }
            }
            return 0;
        };
        return Projection;
    }());
    exports.Projection = Projection;
});
define("Physics", ["require", "exports", "Algebra"], function (require, exports, Algebra_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Possible collision resolution strategies
     *
     * The default is [[CollisionResolutionStrategy.Box]] which performs simple axis aligned arcade style physics.
     *
     * More advanced rigid body physics are enabled by setting [[CollisionResolutionStrategy.RigidBody]] which allows for complicated
     * simulated physical interactions.
     */
    var CollisionResolutionStrategy;
    (function (CollisionResolutionStrategy) {
        CollisionResolutionStrategy[CollisionResolutionStrategy["Box"] = 0] = "Box";
        CollisionResolutionStrategy[CollisionResolutionStrategy["RigidBody"] = 1] = "RigidBody";
    })(CollisionResolutionStrategy = exports.CollisionResolutionStrategy || (exports.CollisionResolutionStrategy = {}));
    /**
     * Possible broadphase collision pair identification strategies
     *
     * The default strategy is [[BroadphaseStrategy.DynamicAABBTree]] which uses a binary tree of axis-aligned bounding boxes to identify
     * potential collision pairs which is O(nlog(n)) faster. The other possible strategy is the [[BroadphaseStrategy.Naive]] strategy
     * which loops over every object for every object in the scene to identify collision pairs which is O(n^2) slower.
     */
    var BroadphaseStrategy;
    (function (BroadphaseStrategy) {
        BroadphaseStrategy[BroadphaseStrategy["Naive"] = 0] = "Naive";
        BroadphaseStrategy[BroadphaseStrategy["DynamicAABBTree"] = 1] = "DynamicAABBTree";
    })(BroadphaseStrategy = exports.BroadphaseStrategy || (exports.BroadphaseStrategy = {}));
    /**
     * Possible numerical integrators for position and velocity
     */
    var Integrator;
    (function (Integrator) {
        Integrator[Integrator["Euler"] = 0] = "Euler";
    })(Integrator = exports.Integrator || (exports.Integrator = {}));
    /**
     * The [[Physics]] object is the global configuration object for all Excalibur physics.
     *
     * [[include:Physics.md]]
     */
    /* istanbul ignore next */
    var Physics = (function () {
        function Physics() {
        }
        /**
         * Configures Excalibur to use box physics. Box physics which performs simple axis aligned arcade style physics.
         */
        Physics.useBoxPhysics = function () {
            Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Box;
        };
        /**
         * Configures Excalibur to use rigid body physics. Rigid body physics allows for complicated
         * simulated physical interactions.
         */
        Physics.useRigidBodyPhysics = function () {
            Physics.collisionResolutionStrategy = CollisionResolutionStrategy.RigidBody;
        };
        return Physics;
    }());
    /**
     * Global acceleration that is applied to all vanilla actors (it wont effect [[Label|labels]], [[UIActor|ui actors]], or
     * [[Trigger|triggers]] in Excalibur that have an [[CollisionType.Active|active]] collision type).
     *
     *
     * This is a great way to globally simulate effects like gravity.
     */
    Physics.acc = new Algebra_1.Vector(0, 0);
    /**
     * Globally switches all Excalibur physics behavior on or off.
     */
    Physics.enabled = true;
    /**
     * Gets or sets the number of collision passes for Excalibur to perform on physics bodies.
     *
     * Reducing collision passes may cause things not to collide as expected in your game, but may increase performance.
     *
     * More passes can improve the visual quality of collisions when many objects are on the screen. This can reduce jitter, improve the
     * collision resolution of fast move objects, or the stability of large numbers of objects stacked together.
     *
     * Fewer passes will improve the performance of the game at the cost of collision quality, more passes will improve quality at the
     * cost of performance.
     *
     * The default is set to 5 passes which is a good start.
     */
    Physics.collisionPasses = 5;
    /**
     * Gets or sets the broadphase pair identification strategy.
     *
     * The default strategy is [[BroadphaseStrategy.DynamicAABBTree]] which uses a binary tree of axis-aligned bounding boxes to identify
     * potential collision pairs which is O(nlog(n)) faster. The other possible strategy is the [[BroadphaseStrategy.Naive]] strategy
     * which loops over every object for every object in the scene to identify collision pairs which is O(n^2) slower.
     */
    Physics.broadphaseStrategy = BroadphaseStrategy.DynamicAABBTree;
    /**
     * Globally switches the debug information for the broadphase strategy
     */
    Physics.broadphaseDebug = false;
    /**
     * Show the normals as a result of collision on the screen.
     */
    Physics.showCollisionNormals = false;
    /**
     * Show the position, velocity, and acceleration as graphical vectors.
     */
    Physics.showMotionVectors = false;
    /**
     * Show the axis-aligned bounding boxes of the collision bodies on the screen.
     */
    Physics.showBounds = false;
    /**
     * Show the bounding collision area shapes
     */
    Physics.showArea = false;
    /**
     * Show points of collision interpreted by excalibur as a result of collision.
     */
    Physics.showContacts = false;
    /**
     * Show the surface normals of the collision areas.
     */
    Physics.showNormals = false;
    /**
     * Gets or sets the global collision resolution strategy (narrowphase).
     *
     * The default is [[CollisionResolutionStrategy.Box]] which performs simple axis aligned arcade style physics.
     *
     * More advanced rigid body physics are enabled by setting [[CollisionResolutionStrategy.RigidBody]] which allows for complicated
     * simulated physical interactions.
     */
    Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Box;
    /**
     * The default mass to use if none is specified
     */
    Physics.defaultMass = 10;
    /**
     * Gets or sets the position and velocity positional integrator, currently only Euler is supported.
     */
    Physics.integrator = Integrator.Euler;
    /**
     * Number of steps to use in integration. A higher number improves the positional accuracy over time. This can be useful to increase
     * if you have fast moving objects in your simulation or you have a large number of objects and need to increase stability.
     */
    Physics.integrationSteps = 1;
    /**
     * Gets or sets whether rotation is allowed in a RigidBody collision resolution
     */
    Physics.allowRigidBodyRotation = true;
    /**
     * Small value to help collision passes settle themselves after the narrowphase.
     */
    Physics.collisionShift = .001;
    /**
     * Factor to add to the RigidBody BoundingBox, bounding box (dimensions += vel * dynamicTreeVelocityMultiplyer);
     */
    Physics.dynamicTreeVelocityMultiplyer = 2;
    /**
     * Pad RigidBody BoundingBox by a constant amount
     */
    Physics.boundsPadding = 5;
    /**
     * Surface epsilon is used to help deal with surface penatration
     */
    Physics.surfaceEpsilon = .1;
    /**
     * Enable fast moving body checking, this enables checking for collision pairs via raycast for fast moving objects to prevent
     * bodies from tunneling through one another.
     */
    Physics.checkForFastBodies = true;
    /**
     * Disable minimum fast moving body raycast, by default if ex.Physics.checkForFastBodies = true Excalibur will only check if the
     * body is moving at least half of its minimum diminension in an update. If ex.Physics.disableMinimumSpeedForFastBody is set to true,
     * Excalibur will always perform the fast body raycast regardless of speed.
     */
    Physics.disableMinimumSpeedForFastBody = false;
    exports.Physics = Physics;
});
define("Util/EasingFunctions", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Standard easing functions for motion in Excalibur, defined on a domain of [0, duration] and a range from [+startValue,+endValue]
     * Given a time, the function will return a value from positive startValue to positive endValue.
     *
     * ```js
     * function Linear (t) {
     *    return t * t;
     * }
     *
     * // accelerating from zero velocity
     * function EaseInQuad (t) {
     *    return t * t;
     * }
     *
     * // decelerating to zero velocity
     * function EaseOutQuad (t) {
     *    return t * (2 - t);
     * }
     *
     * // acceleration until halfway, then deceleration
     * function EaseInOutQuad (t) {
     *    return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
     * }
     *
     * // accelerating from zero velocity
     * function EaseInCubic (t) {
     *    return t * t * t;
     * }
     *
     * // decelerating to zero velocity
     * function EaseOutCubic (t) {
     *    return (--t) * t * t + 1;
     * }
     *
     * // acceleration until halfway, then deceleration
     * function EaseInOutCubic (t) {
     *    return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
     * }
     * ```
     */
    var EasingFunctions = (function () {
        function EasingFunctions() {
        }
        return EasingFunctions;
    }());
    EasingFunctions.Linear = function (currentTime, startValue, endValue, duration) {
        endValue = (endValue - startValue);
        return endValue * currentTime / duration + startValue;
    };
    EasingFunctions.EaseInQuad = function (currentTime, startValue, endValue, duration) {
        endValue = (endValue - startValue);
        currentTime /= duration;
        return endValue * currentTime * currentTime + startValue;
    };
    EasingFunctions.EaseOutQuad = function (currentTime, startValue, endValue, duration) {
        endValue = (endValue - startValue);
        currentTime /= duration;
        return -endValue * currentTime * (currentTime - 2) + startValue;
    };
    EasingFunctions.EaseInOutQuad = function (currentTime, startValue, endValue, duration) {
        endValue = (endValue - startValue);
        currentTime /= duration / 2;
        if (currentTime < 1) {
            return endValue / 2 * currentTime * currentTime + startValue;
        }
        currentTime--;
        return -endValue / 2 * (currentTime * (currentTime - 2) - 1) + startValue;
    };
    EasingFunctions.EaseInCubic = function (currentTime, startValue, endValue, duration) {
        endValue = (endValue - startValue);
        currentTime /= duration;
        return endValue * currentTime * currentTime * currentTime + startValue;
    };
    EasingFunctions.EaseOutCubic = function (currentTime, startValue, endValue, duration) {
        endValue = (endValue - startValue);
        currentTime /= duration;
        currentTime--;
        return endValue * (currentTime * currentTime * currentTime + 1) + startValue;
    };
    EasingFunctions.EaseInOutCubic = function (currentTime, startValue, endValue, duration) {
        endValue = (endValue - startValue);
        currentTime /= duration / 2;
        if (currentTime < 1) {
            return endValue / 2 * currentTime * currentTime * currentTime + startValue;
        }
        currentTime -= 2;
        return endValue / 2 * (currentTime * currentTime * currentTime + 2) + startValue;
    };
    exports.EasingFunctions = EasingFunctions;
});
// Promises/A+ Spec http://promises-aplus.github.io/promises-spec/
define("Promises", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Valid states for a promise to be in
     */
    var PromiseState;
    (function (PromiseState) {
        PromiseState[PromiseState["Resolved"] = 0] = "Resolved";
        PromiseState[PromiseState["Rejected"] = 1] = "Rejected";
        PromiseState[PromiseState["Pending"] = 2] = "Pending";
    })(PromiseState = exports.PromiseState || (exports.PromiseState = {}));
    /**
     * Promises are used to do asynchronous work and they are useful for
     * creating a chain of actions. In Excalibur they are used for loading,
     * sounds, animation, actions, and more.
     *
     * [[include:Promises.md]]
     */
    var Promise = (function () {
        function Promise() {
            this._state = PromiseState.Pending;
            this._successCallbacks = [];
            this._rejectCallback = function () { return; };
        }
        /**
         * Create and resolve a Promise with an optional value
         * @param value  An optional value to wrap in a resolved promise
         */
        Promise.resolve = function (value) {
            var promise = (new Promise()).resolve(value);
            return promise;
        };
        /**
         * Create and reject a Promise with an optional value
         * @param value  An optional value to wrap in a rejected promise
         */
        Promise.reject = function (value) {
            var promise = (new Promise()).reject(value);
            return promise;
        };
        Promise.join = function () {
            var promises = [];
            if (arguments.length > 0 && !Array.isArray(arguments[0])) {
                for (var _i = 0; _i < arguments.length; _i++) {
                    promises[_i - 0] = arguments[_i];
                }
            }
            else if (arguments.length === 1 && Array.isArray(arguments[0])) {
                promises = arguments[0];
            }
            var joinedPromise = new Promise();
            if (!promises || !promises.length) {
                return joinedPromise.resolve();
            }
            var total = promises.length;
            var successes = 0;
            var rejects = 0;
            var errors = [];
            promises.forEach(function (p) {
                p.then(function () {
                    successes += 1;
                    if (successes === total) {
                        joinedPromise.resolve();
                    }
                    else if (successes + rejects + errors.length === total) {
                        joinedPromise.reject(errors);
                    }
                }, function () {
                    rejects += 1;
                    if (successes + rejects + errors.length === total) {
                        joinedPromise.reject(errors);
                    }
                }).error(function (e) {
                    errors.push(e);
                    if ((errors.length + successes + rejects) === total) {
                        joinedPromise.reject(errors);
                    }
                });
            });
            return joinedPromise;
        };
        /**
         * Chain success and reject callbacks after the promise is resolved
         * @param successCallback  Call on resolution of promise
         * @param rejectCallback   Call on rejection of promise
         */
        Promise.prototype.then = function (successCallback, rejectCallback) {
            if (successCallback) {
                this._successCallbacks.push(successCallback);
                // If the promise is already resovled call immediately
                if (this.state() === PromiseState.Resolved) {
                    try {
                        successCallback.call(this, this._value);
                    }
                    catch (e) {
                        this._handleError(e);
                    }
                }
            }
            if (rejectCallback) {
                this._rejectCallback = rejectCallback;
                // If the promise is already rejected call immediately
                if (this.state() === PromiseState.Rejected) {
                    try {
                        rejectCallback.call(this, this._value);
                    }
                    catch (e) {
                        this._handleError(e);
                    }
                }
            }
            return this;
        };
        /**
         * Add an error callback to the promise
         * @param errorCallback  Call if there was an error in a callback
         */
        Promise.prototype.error = function (errorCallback) {
            if (errorCallback) {
                this._errorCallback = errorCallback;
            }
            return this;
        };
        /**
         * Resolve the promise and pass an option value to the success callbacks
         * @param value  Value to pass to the success callbacks
         */
        Promise.prototype.resolve = function (value) {
            var _this = this;
            if (this._state === PromiseState.Pending) {
                this._value = value;
                try {
                    this._state = PromiseState.Resolved;
                    this._successCallbacks.forEach(function (cb) {
                        cb.call(_this, _this._value);
                    });
                }
                catch (e) {
                    this._handleError(e);
                }
            }
            else {
                throw new Error('Cannot resolve a promise that is not in a pending state!');
            }
            return this;
        };
        /**
         * Reject the promise and pass an option value to the reject callbacks
         * @param value  Value to pass to the reject callbacks
         */
        Promise.prototype.reject = function (value) {
            if (this._state === PromiseState.Pending) {
                this._value = value;
                try {
                    this._state = PromiseState.Rejected;
                    this._rejectCallback.call(this, this._value);
                }
                catch (e) {
                    this._handleError(e);
                }
            }
            else {
                throw new Error('Cannot reject a promise that is not in a pending state!');
            }
            return this;
        };
        /**
         * Inspect the current state of a promise
         */
        Promise.prototype.state = function () {
            return this._state;
        };
        Promise.prototype._handleError = function (e) {
            if (this._errorCallback) {
                this._errorCallback.call(this, e);
            }
            else {
                // rethrow error
                throw e;
            }
        };
        return Promise;
    }());
    exports.Promise = Promise;
});
/**
 * Pseudo-Random Utility
 *
 * A pseudo-random utility to add seeded random support for help in
 * generating things like terrain or reproducible randomness. Uses the
 * [Mersenne Twister](https://en.wikipedia.org/wiki/Mersenne_Twister) algorithm.
 *
 * [[include:Random.md]]
 */
define("Math/Random", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * 32-bit mask
     */
    var BITMASK32 = 0xFFFFFFFF;
    /**
     * Pseudo-random number generator following the Mersenne_Twister algorithm. Given a seed this generator will produce the same sequence
     * of numbers each time it is called.
     * See https://en.wikipedia.org/wiki/Mersenne_Twister for more details.
     * Uses the MT19937-32 (2002) implementation documented here http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html
     *
     * Api inspired by http://chancejs.com/# https://github.com/chancejs/chancejs
     */
    var Random = (function () {
        /**
         * If no seed is specified, the Date.now() is used
         */
        function Random(seed) {
            this.seed = seed;
            // Separation point of one one word, the number of bits in the lower bitmask 0 <= r <= w-1
            this._lowerMask = 0x7FFFFFFF; // 31 bits same as _r
            this._upperMask = 0x80000000; // 34 high bits
            // Word size, 64 bits
            this._w = 32;
            // Degree of recurrance
            this._n = 624;
            // Middle word, an offset used in the recurrance defining the series x, 1<=m<n
            this._m = 397;
            // coefficients of teh rational normal form twist matrix
            this._a = 0x9908B0DF;
            // tempering bit shifts and masks
            this._u = 11;
            this._s = 7;
            this._b = 0x9d2c5680;
            this._t = 15;
            this._c = 0xefc60000;
            this._l = 18;
            this._f = 1812433253;
            this._mt = new Array(this._n);
            // need to mask to support higher bit machines
            this._mt[0] = (seed || Date.now()) >>> 0;
            for (var i = 1; i < this._n; i++) {
                var s = this._mt[i - 1] ^ (this._mt[i - 1] >>> (this._w - 2));
                // numbers are bigger than the JS max safe int, add in 16-bit chunks to prevent IEEE rounding errors on high bits         
                this._mt[i] = (((this._f * ((s & 0xFFFF0000) >>> 16)) << 16) + (this._f * (s & 0xFFFF)) + i) >>> 0;
            }
            this._index = this._n;
        }
        /**
         * Apply the twist
         */
        Random.prototype._twist = function () {
            var mag01 = [0x0, this._a];
            var y = 0;
            for (var i = 0; i < this._n - this._m; i++) {
                y = (this._mt[i] & this._upperMask) | (this._mt[i + 1] & this._lowerMask);
                this._mt[i] = this._mt[i + this._m] ^ (y >>> 1) ^ mag01[y & 0x1] & BITMASK32;
            }
            for (; i < this._n - 1; i++) {
                y = (this._mt[i] & this._upperMask) | (this._mt[i + 1] & this._lowerMask);
                this._mt[i] = this._mt[i + (this._m - this._n)] ^ (y >>> 1) ^ mag01[y & 0x1] & BITMASK32;
            }
            y = (this._mt[this._n - 1] & this._upperMask) | (this._mt[0] & this._lowerMask);
            this._mt[this._n - 1] = this._mt[this._m - 1] ^ (y >>> 1) ^ mag01[y & 0x1] & BITMASK32;
            this._index = 0;
        };
        /**
         * Return next 32 bit integer number in sequence
         */
        Random.prototype.nextInt = function () {
            if (this._index >= this._n) {
                this._twist();
            }
            var y = this._mt[this._index++];
            y ^= y >>> this._u;
            y ^= ((y << this._s) & this._b);
            y ^= ((y << this._t) & this._c);
            y ^= (y >>> this._l);
            return y >>> 0;
        };
        /**
         * Return a random floating point number between [0, 1)
         */
        Random.prototype.next = function () {
            return this.nextInt() * (1.0 / 4294967296.0); // divided by 2^32
        };
        /**
         * Return a random floating point in range [min, max) min is included, max is not included
         */
        Random.prototype.floating = function (min, max) {
            return (max - min) * this.next() + min;
        };
        /**
         * Return a random integer in range [min, max] min is included, max is included.
         * Implemented with rejection sampling, see https://medium.com/@betable/tifu-by-using-math-random-f1c308c4fd9d#.i13tdiu5a
         */
        Random.prototype.integer = function (min, max) {
            return Math.floor((max - min + 1) * this.next() + min);
        };
        /**
         * Returns true or false randomly with 50/50 odds by default.
         * By default the likelihood of returning a true is .5 (50%).
         * @param likelihood takes values between [0, 1]
         */
        Random.prototype.bool = function (likelihood) {
            if (likelihood === void 0) { likelihood = .5; }
            return this.next() <= likelihood;
        };
        /**
         * Returns one element from an array at random
         */
        Random.prototype.pickOne = function (array) {
            return array[this.integer(0, array.length - 1)];
        };
        /**
         * Returns a new array random picking elements from the original
         * @param array Original array to pick from
         * @param numPicks can be any positive number
         * @param allowDuplicates indicates whether the returned set is allowed duplicates (it does not mean there will always be duplicates
         * just that it is possible)
         */
        Random.prototype.pickSet = function (array, numPicks, allowDuplicates) {
            if (allowDuplicates === void 0) { allowDuplicates = false; }
            if (allowDuplicates) {
                return this._pickSetWithDuplicates(array, numPicks);
            }
            else {
                return this._pickSetWithoutDuplicates(array, numPicks);
            }
        };
        /**
         * Returns a new array randomly picking elements in the original (not reused)
         * @param numPicks must be less than or equal to the number of elements in the array.
         */
        Random.prototype._pickSetWithoutDuplicates = function (array, numPicks) {
            if (numPicks > array.length || numPicks < 0) {
                throw new Error('Invalid number of elements to pick, must pick a value 0 < n <= length');
            }
            if (numPicks === array.length) {
                return array;
            }
            var result = new Array(numPicks);
            var currentPick = 0;
            var tempArray = array.slice(0);
            while (currentPick < numPicks) {
                var index = this.integer(0, tempArray.length - 1);
                result[currentPick++] = tempArray[index];
                tempArray.splice(index, 1);
            }
            return result;
        };
        /**
         * Returns a new array random picking elements from the original allowing duplicates
         * @param numPicks can be any positive number
         */
        Random.prototype._pickSetWithDuplicates = function (array, numPicks) {
            // Typescript numbers are all floating point, so do we add check for int? (or floor the input?)
            if (numPicks < 0) {
                throw new Error('Invalid number of elements to pick, must pick a value 0 <= n < MAX_INT');
            }
            var result = new Array(numPicks);
            for (var i = 0; i < numPicks; i++) {
                result.push(this.pickOne(array));
            }
            return result;
        };
        /**
         * Returns a new array that has its elements shuffled. Using the Fisher/Yates method
         * https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
         */
        Random.prototype.shuffle = function (array) {
            var tempArray = array.slice(0);
            var swap = null;
            for (var i = 0; i < tempArray.length - 2; i++) {
                var randomIndex = this.integer(i, tempArray.length - 1);
                swap = tempArray[i];
                tempArray[i] = tempArray[randomIndex];
                tempArray[randomIndex] = swap;
            }
            return tempArray;
        };
        /**
         * Generate a list of random integer numbers
         * @param length the length of the final array
         * @param min the minimum integer number to generate inclusive
         * @param max the maximum integer number to generate inclusive
         */
        Random.prototype.range = function (length, min, max) {
            var result = new Array(length);
            for (var i = 0; i < length; i++) {
                result[i] = this.integer(min, max);
            }
            return result;
        };
        /**
         * Returns the result of a d4 dice roll
         */
        Random.prototype.d4 = function () {
            return this.integer(1, 4);
        };
        /**
         * Returns the result of a d6 dice roll
         */
        Random.prototype.d6 = function () {
            return this.integer(1, 6);
        };
        /**
         * Returns the result of a d8 dice roll
         */
        Random.prototype.d8 = function () {
            return this.integer(1, 8);
        };
        /**
         * Returns the result of a d10 dice roll
         */
        Random.prototype.d10 = function () {
            return this.integer(1, 10);
        };
        /**
         * Returns the result of a d12 dice roll
         */
        Random.prototype.d12 = function () {
            return this.integer(1, 12);
        };
        /**
         * Returns the result of a d20 dice roll
         */
        Random.prototype.d20 = function () {
            return this.integer(1, 20);
        };
        return Random;
    }());
    exports.Random = Random;
});
define("Collision/Side", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * An enum that describes the sides of an Actor for collision
     */
    var Side;
    (function (Side) {
        Side[Side["None"] = 0] = "None";
        Side[Side["Top"] = 1] = "Top";
        Side[Side["Bottom"] = 2] = "Bottom";
        Side[Side["Left"] = 3] = "Left";
        Side[Side["Right"] = 4] = "Right";
    })(Side = exports.Side || (exports.Side = {}));
});
define("Util/Util", ["require", "exports", "Algebra", "Math/Random", "Collision/Side"], function (require, exports, Algebra_2, Random_1, Side_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Two PI constant
     */
    exports.TwoPI = Math.PI * 2;
    /**
     * Merges one or more objects into a single target object
     *
     * @returns Merged object with properties from other objects
     * @credit https://gomakethings.com/vanilla-javascript-version-of-jquery-extend/
     */
    function extend() {
        var extended = {};
        var deep = false;
        var i = 0;
        var length = arguments.length;
        // Check if a deep merge
        if (Object.prototype.toString.call(arguments[0]) === '[object Boolean]') {
            deep = arguments[0];
            i++;
        }
        // Merge the object into the extended object
        var assignExists = typeof Object.assign === 'function';
        var merge = null;
        if (!assignExists) {
            merge = function (obj) {
                for (var prop in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, prop)) {
                        // If deep merge and property is an object, merge properties
                        if (deep && Object.prototype.toString.call(obj[prop]) === '[object Object]') {
                            extended[prop] = extend(true, extended[prop], obj[prop]);
                        }
                        else {
                            extended[prop] = obj[prop];
                        }
                    }
                }
            };
        }
        else {
            merge = Object.assign;
        }
        // Loop through each object and conduct a merge
        for (; i < length; i++) {
            var obj = arguments[i];
            if (!assignExists) {
                merge(obj);
            }
            else {
                merge(extended, obj);
            }
        }
        return extended;
    }
    exports.extend = extend;
    function base64Encode(inputStr) {
        var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
        var outputStr = '';
        var i = 0;
        while (i < inputStr.length) {
            //all three "& 0xff" added below are there to fix a known bug
            //with bytes returned by xhr.responseText
            var byte1 = inputStr.charCodeAt(i++) & 0xff;
            var byte2 = inputStr.charCodeAt(i++) & 0xff;
            var byte3 = inputStr.charCodeAt(i++) & 0xff;
            var enc1 = byte1 >> 2;
            var enc2 = ((byte1 & 3) << 4) | (byte2 >> 4);
            var enc3, enc4;
            if (isNaN(byte2)) {
                enc3 = enc4 = 64;
            }
            else {
                enc3 = ((byte2 & 15) << 2) | (byte3 >> 6);
                if (isNaN(byte3)) {
                    enc4 = 64;
                }
                else {
                    enc4 = byte3 & 63;
                }
            }
            outputStr += b64.charAt(enc1) + b64.charAt(enc2) + b64.charAt(enc3) + b64.charAt(enc4);
        }
        return outputStr;
    }
    exports.base64Encode = base64Encode;
    /**
     * Clamps a value between a min and max inclusive
     */
    function clamp(val, min, max) {
        return Math.min(Math.max(min, val), max);
    }
    exports.clamp = clamp;
    function randomInRange(min, max, random) {
        if (random === void 0) { random = new Random_1.Random(); }
        return random ? random.floating(min, max) : min + Math.random() * (max - min);
    }
    exports.randomInRange = randomInRange;
    function randomIntInRange(min, max, random) {
        if (random === void 0) { random = new Random_1.Random(); }
        return random ? random.integer(min, max) : Math.round(randomInRange(min, max));
    }
    exports.randomIntInRange = randomIntInRange;
    function canonicalizeAngle(angle) {
        var tmpAngle = angle;
        if (angle > exports.TwoPI) {
            while (tmpAngle > exports.TwoPI) {
                tmpAngle -= exports.TwoPI;
            }
        }
        if (angle < 0) {
            while (tmpAngle < 0) {
                tmpAngle += exports.TwoPI;
            }
        }
        return tmpAngle;
    }
    exports.canonicalizeAngle = canonicalizeAngle;
    function toDegrees(radians) {
        return 180 / Math.PI * radians;
    }
    exports.toDegrees = toDegrees;
    function toRadians(degrees) {
        return degrees / 180 * Math.PI;
    }
    exports.toRadians = toRadians;
    function getPosition(el) {
        var oLeft = 0, oTop = 0;
        var calcOffsetLeft = function (parent) {
            oLeft += parent.offsetLeft;
            if (parent.offsetParent) {
                calcOffsetLeft(parent.offsetParent);
            }
        };
        var calcOffsetTop = function (parent) {
            oTop += parent.offsetTop;
            if (parent.offsetParent) {
                calcOffsetTop(parent.offsetParent);
            }
        };
        calcOffsetLeft(el);
        calcOffsetTop(el);
        return new Algebra_2.Vector(oLeft, oTop);
    }
    exports.getPosition = getPosition;
    function addItemToArray(item, array) {
        if (array.indexOf(item) === -1) {
            array.push(item);
            return true;
        }
        return false;
    }
    exports.addItemToArray = addItemToArray;
    function removeItemFromArray(item, array) {
        var index = -1;
        if ((index = array.indexOf(item)) > -1) {
            array.splice(index, 1);
            return true;
        }
        return false;
    }
    exports.removeItemFromArray = removeItemFromArray;
    function contains(array, obj) {
        for (var i = 0; i < array.length; i++) {
            if (array[i] === obj) {
                return true;
            }
        }
        return false;
    }
    exports.contains = contains;
    function getOppositeSide(side) {
        if (side === Side_1.Side.Top) {
            return Side_1.Side.Bottom;
        }
        if (side === Side_1.Side.Bottom) {
            return Side_1.Side.Top;
        }
        if (side === Side_1.Side.Left) {
            return Side_1.Side.Right;
        }
        if (side === Side_1.Side.Right) {
            return Side_1.Side.Left;
        }
        return Side_1.Side.None;
    }
    exports.getOppositeSide = getOppositeSide;
    function getSideFromVector(direction) {
        var directions = [Algebra_2.Vector.Left, Algebra_2.Vector.Right, Algebra_2.Vector.Up, Algebra_2.Vector.Down];
        var directionEnum = [Side_1.Side.Left, Side_1.Side.Right, Side_1.Side.Top, Side_1.Side.Bottom];
        var max = -Number.MAX_VALUE;
        var maxIndex = -1;
        for (var i = 0; i < directions.length; i++) {
            if (directions[i].dot(direction) > max) {
                max = directions[i].dot(direction);
                maxIndex = i;
            }
        }
        return directionEnum[maxIndex];
    }
    exports.getSideFromVector = getSideFromVector;
    /**
     * Excalibur's dynamically resizing collection
     */
    var Collection = (function () {
        /**
         * @param initialSize  Initial size of the internal backing array
         */
        function Collection(initialSize) {
            if (initialSize === void 0) { initialSize = Collection.DefaultSize; }
            this._internalArray = null;
            this._endPointer = 0;
            this._internalArray = new Array(initialSize);
        }
        Collection.prototype._resize = function () {
            var newSize = this._internalArray.length * 2;
            var newArray = new Array(newSize);
            var count = this.count();
            for (var i = 0; i < count; i++) {
                newArray[i] = this._internalArray[i];
            }
            delete this._internalArray;
            this._internalArray = newArray;
        };
        /**
         * Push elements to the end of the collection
         */
        Collection.prototype.push = function (element) {
            if (this._endPointer === this._internalArray.length) {
                this._resize();
            }
            return this._internalArray[this._endPointer++] = element;
        };
        /**
         * Removes elements from the end of the collection
         */
        Collection.prototype.pop = function () {
            this._endPointer = this._endPointer - 1 < 0 ? 0 : this._endPointer - 1;
            return this._internalArray[this._endPointer];
        };
        /**
         * Returns the count of the collection
         */
        Collection.prototype.count = function () {
            return this._endPointer;
        };
        /**
         * Empties the collection
         */
        Collection.prototype.clear = function () {
            this._endPointer = 0;
        };
        /**
         * Returns the size of the internal backing array
         */
        Collection.prototype.internalSize = function () {
            return this._internalArray.length;
        };
        /**
         * Returns an element at a specific index
         * @param index  Index of element to retrieve
         */
        Collection.prototype.elementAt = function (index) {
            if (index >= this.count()) {
                //Logger.getInstance().error('Invalid parameter: ' + index);
                throw new Error('Invalid index ' + index);
            }
            return this._internalArray[index];
        };
        /**
         * Inserts an element at a specific index
         * @param index  Index to insert the element
         * @param value  Element to insert
         */
        Collection.prototype.insert = function (index, value) {
            if (index >= this.count()) {
                this._resize();
            }
            return this._internalArray[index] = value;
        };
        /**
         * Removes an element at a specific index
         * @param index  Index of element to remove
         */
        Collection.prototype.remove = function (index) {
            var count = this.count();
            if (count === 0) {
                //Logger.getInstance().error('Invalid parameter: ' + index);
                throw new Error('Invalid parameter ' + index);
            }
            // O(n) Shift
            var removed = this._internalArray[index];
            for (var i = index; i < count; i++) {
                this._internalArray[i] = this._internalArray[i + 1];
            }
            this._endPointer--;
            return removed;
        };
        /**
         * Removes an element by reference
         * @param element  Element to retrieve
         */
        Collection.prototype.removeElement = function (element) {
            var index = this._internalArray.indexOf(element);
            this.remove(index);
        };
        /**
         * Returns a array representing the collection
         */
        Collection.prototype.toArray = function () {
            return this._internalArray.slice(0, this._endPointer);
        };
        /**
         * Iterate over every element in the collection
         * @param func  Callback to call for each element passing a reference to the element and its index, returned values are ignored
         */
        Collection.prototype.forEach = function (func) {
            var i = 0, count = this.count();
            for (i; i < count; i++) {
                func.call(this, this._internalArray[i], i);
            }
        };
        /**
         * Mutate every element in the collection
         * @param func  Callback to call for each element passing a reference to the element and its index, any values returned mutate
         * the collection
         */
        Collection.prototype.map = function (func) {
            var count = this.count();
            for (var i = 0; i < count; i++) {
                this._internalArray[i] = func.call(this, this._internalArray[i], i);
            }
        };
        return Collection;
    }());
    /**
     * Default collection size
     */
    Collection.DefaultSize = 200;
    exports.Collection = Collection;
});
define("Camera", ["require", "exports", "Util/EasingFunctions", "Promises", "Algebra", "Util/Util"], function (require, exports, EasingFunctions_1, Promises_1, Algebra_3, Util_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Container to house convenience strategy methods
     * @internal
     */
    var StrategyContainer = (function () {
        function StrategyContainer(camera) {
            this.camera = camera;
        }
        /**
         * Creates and adds the [[LockCameraToActorStrategy]] on the current camera.
         * @param actor The actor to lock the camera to
         */
        StrategyContainer.prototype.lockToActor = function (actor) {
            this.camera.addStrategy(new LockCameraToActorStrategy(actor));
        };
        /**
         * Creates and adds the [[LockCameraToActorAxisStrategy]] on the current camera
         * @param actor The actor to lock the camera to
         * @param axis The axis to follow the actor on
         */
        StrategyContainer.prototype.lockToActorAxis = function (actor, axis) {
            this.camera.addStrategy(new LockCameraToActorAxisStrategy(actor, axis));
        };
        /**
         * Creates and adds the [[ElasticToActorStrategy]] on the current camera
         * If cameraElasticity < cameraFriction < 1.0, the behavior will be a dampened spring that will slowly end at the target without bouncing
         * If cameraFriction < cameraElasticity < 1.0, the behavior will be an oscillationg spring that will over
         * correct and bounce around the target
         *
         * @param target Target actor to elastically follow
         * @param cameraElasticity [0 - 1.0] The higher the elasticity the more force that will drive the camera towards the target
         * @param cameraFriction [0 - 1.0] The higher the friction the more that the camera will resist motion towards the target
         */
        StrategyContainer.prototype.elasticToActor = function (actor, cameraElasticity, cameraFriction) {
            this.camera.addStrategy(new ElasticToActorStrategy(actor, cameraElasticity, cameraFriction));
        };
        /**
         * Creates and adds the [[RadiusAroundActorStrategy]] on the current camera
         * @param target Target actor to follow when it is "radius" pixels away
         * @param radius Number of pixels away before the camera will follow
         */
        StrategyContainer.prototype.radiusAroundActor = function (actor, radius) {
            this.camera.addStrategy(new RadiusAroundActorStrategy(actor, radius));
        };
        return StrategyContainer;
    }());
    exports.StrategyContainer = StrategyContainer;
    /**
     * Camera axis enum
     */
    var Axis;
    (function (Axis) {
        Axis[Axis["X"] = 0] = "X";
        Axis[Axis["Y"] = 1] = "Y";
    })(Axis = exports.Axis || (exports.Axis = {}));
    /**
     * Lock a camera to the exact x/y postition of an actor.
     */
    var LockCameraToActorStrategy = (function () {
        function LockCameraToActorStrategy(target) {
            this.target = target;
            this.action = function (target, _cam, _eng, _delta) {
                var center = target.getCenter();
                return center;
            };
        }
        return LockCameraToActorStrategy;
    }());
    exports.LockCameraToActorStrategy = LockCameraToActorStrategy;
    /**
     * Lock a camera to a specific axis around an actor.
     */
    var LockCameraToActorAxisStrategy = (function () {
        function LockCameraToActorAxisStrategy(target, axis) {
            var _this = this;
            this.target = target;
            this.axis = axis;
            this.action = function (target, cam, _eng, _delta) {
                var center = target.getCenter();
                var currentFocus = cam.getFocus();
                if (_this.axis === Axis.X) {
                    return new Algebra_3.Vector(center.x, currentFocus.y);
                }
                else {
                    return new Algebra_3.Vector(currentFocus.x, center.y);
                }
            };
        }
        return LockCameraToActorAxisStrategy;
    }());
    exports.LockCameraToActorAxisStrategy = LockCameraToActorAxisStrategy;
    /**
     * Using [Hook's law](https://en.wikipedia.org/wiki/Hooke's_law), elastically move the camera towards the target actor.
     */
    var ElasticToActorStrategy = (function () {
        /**
         * If cameraElasticity < cameraFriction < 1.0, the behavior will be a dampened spring that will slowly end at the target without bouncing
         * If cameraFriction < cameraElasticity < 1.0, the behavior will be an oscillationg spring that will over
         * correct and bounce around the target
         *
         * @param target Target actor to elastically follow
         * @param cameraElasticity [0 - 1.0] The higher the elasticity the more force that will drive the camera towards the target
         * @param cameraFriction [0 - 1.0] The higher the friction the more that the camera will resist motion towards the target
         */
        function ElasticToActorStrategy(target, cameraElasticity, cameraFriction) {
            var _this = this;
            this.target = target;
            this.cameraElasticity = cameraElasticity;
            this.cameraFriction = cameraFriction;
            this.action = function (target, cam, _eng, _delta) {
                var position = target.getCenter();
                var focus = cam.getFocus();
                var cameraVel = new Algebra_3.Vector(cam.dx, cam.dy);
                // Calculate the strech vector, using the spring equation
                // F = kX
                // https://en.wikipedia.org/wiki/Hooke's_law
                // Apply to the current camera velocity
                var stretch = position.sub(focus).scale(_this.cameraElasticity); // stretch is X
                cameraVel = cameraVel.add(stretch);
                // Calculate the friction (-1 to apply a force in the opposition of motion)
                // Apply to the current camera velocity
                var friction = cameraVel.scale(-1).scale(_this.cameraFriction);
                cameraVel = cameraVel.add(friction);
                // Update position by velocity deltas
                focus = focus.add(cameraVel);
                return focus;
            };
        }
        return ElasticToActorStrategy;
    }());
    exports.ElasticToActorStrategy = ElasticToActorStrategy;
    var RadiusAroundActorStrategy = (function () {
        /**
         *
         * @param target Target actor to follow when it is "radius" pixels away
         * @param radius Number of pixels away before the camera will follow
         */
        function RadiusAroundActorStrategy(target, radius) {
            var _this = this;
            this.target = target;
            this.radius = radius;
            this.action = function (target, cam, _eng, _delta) {
                var position = target.getCenter();
                var focus = cam.getFocus();
                var direction = position.sub(focus);
                var distance = direction.magnitude();
                if (distance >= _this.radius) {
                    var offset = distance - _this.radius;
                    return focus.add(direction.normalize().scale(offset));
                }
                return focus;
            };
        }
        return RadiusAroundActorStrategy;
    }());
    exports.RadiusAroundActorStrategy = RadiusAroundActorStrategy;
    /**
     * Cameras
     *
     * [[BaseCamera]] is the base class for all Excalibur cameras. Cameras are used
     * to move around your game and set focus. They are used to determine
     * what is "off screen" and can be used to scale the game.
     *
     * [[include:Cameras.md]]
     */
    var BaseCamera = (function () {
        function BaseCamera() {
            this._cameraStrategies = [];
            this.strategy = new StrategyContainer(this);
            // camera physical quantities
            this.z = 1;
            this.dx = 0;
            this.dy = 0;
            this.dz = 0;
            this.ax = 0;
            this.ay = 0;
            this.az = 0;
            this.rotation = 0;
            this.rx = 0;
            this._x = 0;
            this._y = 0;
            this._cameraMoving = false;
            this._currentLerpTime = 0;
            this._lerpDuration = 1000; // 1 second   
            this._lerpStart = null;
            this._lerpEnd = null;
            //camera effects
            this._isShaking = false;
            this._shakeMagnitudeX = 0;
            this._shakeMagnitudeY = 0;
            this._shakeDuration = 0;
            this._elapsedShakeTime = 0;
            this._xShake = 0;
            this._yShake = 0;
            this._isZooming = false;
            this._maxZoomScale = 1;
            this._zoomIncrement = 0.01;
            this._easing = EasingFunctions_1.EasingFunctions.EaseInOutCubic;
        }
        Object.defineProperty(BaseCamera.prototype, "x", {
            /**
             * Get the camera's x position
             */
            get: function () {
                return this._x;
            },
            /**
             * Set the camera's x position (cannot be set when following an [[Actor]] or when moving)
             */
            set: function (value) {
                if (!this._follow && !this._cameraMoving) {
                    this._x = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseCamera.prototype, "y", {
            /**
             * Get the camera's y position
             */
            get: function () {
                return this._y;
            },
            /**
             * Set the camera's y position (cannot be set when following an [[Actor]] or when moving)
             */
            set: function (value) {
                if (!this._follow && !this._cameraMoving) {
                    this._y = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseCamera.prototype, "pos", {
            /**
             * Get the camera's position as a vector
             */
            get: function () {
                return new Algebra_3.Vector(this.x, this.y);
            },
            /**
             * Set the cameras position
             */
            set: function (value) {
                this.x = value.x;
                this.y = value.y;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseCamera.prototype, "vel", {
            /**
             * Get the camera's velocity as a vector
             */
            get: function () {
                return new Algebra_3.Vector(this.dx, this.dy);
            },
            /**
             * Set the camera's velocity
             */
            set: function (value) {
                this.dx = value.x;
                this.dy = value.y;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns the focal point of the camera, a new point giving the x and y position of the camera
         */
        BaseCamera.prototype.getFocus = function () {
            return new Algebra_3.Vector(this.x, this.y);
        };
        /**
         * This moves the camera focal point to the specified position using specified easing function. Cannot move when following an Actor.
         *
         * @param pos The target position to move to
         * @param duration The duration in milliseconds the move should last
         * @param [easingFn] An optional easing function ([[ex.EasingFunctions.EaseInOutCubic]] by default)
         * @returns A [[Promise]] that resolves when movement is finished, including if it's interrupted.
         *          The [[Promise]] value is the [[Vector]] of the target position. It will be rejected if a move cannot be made.
         */
        BaseCamera.prototype.move = function (pos, duration, easingFn) {
            if (easingFn === void 0) { easingFn = EasingFunctions_1.EasingFunctions.EaseInOutCubic; }
            if (typeof easingFn !== 'function') {
                throw 'Please specify an EasingFunction';
            }
            // cannot move when following an actor
            if (this._follow) {
                return new Promises_1.Promise().reject(pos);
            }
            // resolve existing promise, if any
            if (this._lerpPromise && this._lerpPromise.state() === Promises_1.PromiseState.Pending) {
                this._lerpPromise.resolve(pos);
            }
            this._lerpPromise = new Promises_1.Promise();
            this._lerpStart = this.getFocus().clone();
            this._lerpDuration = duration;
            this._lerpEnd = pos;
            this._currentLerpTime = 0;
            this._cameraMoving = true;
            this._easing = easingFn;
            return this._lerpPromise;
        };
        /**
         * Sets the camera to shake at the specified magnitudes for the specified duration
         * @param magnitudeX  The x magnitude of the shake
         * @param magnitudeY  The y magnitude of the shake
         * @param duration    The duration of the shake in milliseconds
         */
        BaseCamera.prototype.shake = function (magnitudeX, magnitudeY, duration) {
            this._isShaking = true;
            this._shakeMagnitudeX = magnitudeX;
            this._shakeMagnitudeY = magnitudeY;
            this._shakeDuration = duration;
        };
        /**
         * Zooms the camera in or out by the specified scale over the specified duration.
         * If no duration is specified, it take effect immediately.
         * @param scale    The scale of the zoom
         * @param duration The duration of the zoom in milliseconds
         */
        BaseCamera.prototype.zoom = function (scale, duration) {
            if (duration === void 0) { duration = 0; }
            this._zoomPromise = new Promises_1.Promise();
            if (duration) {
                this._isZooming = true;
                this._maxZoomScale = scale;
                this._zoomIncrement = (scale - this.z) / duration;
            }
            else {
                this._isZooming = false;
                this.z = scale;
                this._zoomPromise.resolve(true);
            }
            return this._zoomPromise;
        };
        /**
         * Gets the current zoom scale
         */
        BaseCamera.prototype.getZoom = function () {
            return this.z;
        };
        /**
         * Adds a new camera strategy to this camera
         * @param cameraStrategy Instance of an [[ICameraStrategy]]
         */
        BaseCamera.prototype.addStrategy = function (cameraStrategy) {
            this._cameraStrategies.push(cameraStrategy);
        };
        /**
         * Removes a camera strategy by reference
         * @param cameraStrategy Instance of an [[ICameraStrategy]]
         */
        BaseCamera.prototype.removeStrategy = function (cameraStrategy) {
            Util_1.removeItemFromArray(cameraStrategy, this._cameraStrategies);
        };
        /**
         * Clears all camera strategies from the camera
         */
        BaseCamera.prototype.clearAllStrategies = function () {
            this._cameraStrategies.length = 0;
        };
        BaseCamera.prototype.update = function (_engine, delta) {
            // Update placements based on linear algebra
            this._x += this.dx * delta / 1000;
            this._y += this.dy * delta / 1000;
            this.z += this.dz * delta / 1000;
            this.dx += this.ax * delta / 1000;
            this.dy += this.ay * delta / 1000;
            this.dz += this.az * delta / 1000;
            this.rotation += this.rx * delta / 1000;
            if (this._isZooming) {
                var newZoom = this.z + this._zoomIncrement * delta;
                this.z = newZoom;
                if (this._zoomIncrement > 0) {
                    if (newZoom >= this._maxZoomScale) {
                        this._isZooming = false;
                        this.z = this._maxZoomScale;
                        this._zoomPromise.resolve(true);
                    }
                }
                else {
                    if (newZoom <= this._maxZoomScale) {
                        this._isZooming = false;
                        this.z = this._maxZoomScale;
                        this._zoomPromise.resolve(true);
                    }
                }
            }
            if (this._cameraMoving) {
                if (this._currentLerpTime < this._lerpDuration) {
                    if (this._lerpEnd.x < this._lerpStart.x) {
                        this._x = this._lerpStart.x - (this._easing(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x);
                    }
                    else {
                        this._x = this._easing(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration);
                    }
                    if (this._lerpEnd.y < this._lerpStart.y) {
                        this._y = this._lerpStart.y - (this._easing(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y);
                    }
                    else {
                        this._y = this._easing(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);
                    }
                    this._currentLerpTime += delta;
                }
                else {
                    this._x = this._lerpEnd.x;
                    this._y = this._lerpEnd.y;
                    this._lerpPromise.resolve(this._lerpEnd);
                    this._lerpStart = null;
                    this._lerpEnd = null;
                    this._currentLerpTime = 0;
                    this._cameraMoving = false;
                }
            }
            if (this._isDoneShaking()) {
                this._isShaking = false;
                this._elapsedShakeTime = 0;
                this._shakeMagnitudeX = 0;
                this._shakeMagnitudeY = 0;
                this._shakeDuration = 0;
                this._xShake = 0;
                this._yShake = 0;
            }
            else {
                this._elapsedShakeTime += delta;
                this._xShake = (Math.random() * this._shakeMagnitudeX | 0) + 1;
                this._yShake = (Math.random() * this._shakeMagnitudeY | 0) + 1;
            }
            for (var _i = 0, _a = this._cameraStrategies; _i < _a.length; _i++) {
                var s = _a[_i];
                this.pos = s.action.call(s, s.target, this, _engine, delta);
            }
        };
        /**
         * Applies the relevant transformations to the game canvas to "move" or apply effects to the Camera
         * @param ctx    Canvas context to apply transformations
         * @param delta  The number of milliseconds since the last update
         */
        BaseCamera.prototype.draw = function (ctx) {
            var focus = this.getFocus();
            var canvasWidth = ctx.canvas.width;
            var canvasHeight = ctx.canvas.height;
            var pixelRatio = window.devicePixelRatio;
            var zoom = this.getZoom();
            var newCanvasWidth = (canvasWidth / zoom) / pixelRatio;
            var newCanvasHeight = (canvasHeight / zoom) / pixelRatio;
            ctx.scale(zoom, zoom);
            ctx.translate(-focus.x + newCanvasWidth / 2 + this._xShake, -focus.y + newCanvasHeight / 2 + this._yShake);
        };
        BaseCamera.prototype.debugDraw = function (ctx) {
            var focus = this.getFocus();
            ctx.fillStyle = 'red';
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(focus.x, focus.y, 15, 0, Math.PI * 2);
            ctx.closePath();
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(focus.x, focus.y, 5, 0, Math.PI * 2);
            ctx.closePath();
            ctx.stroke();
        };
        BaseCamera.prototype._isDoneShaking = function () {
            return !(this._isShaking) || (this._elapsedShakeTime >= this._shakeDuration);
        };
        return BaseCamera;
    }());
    exports.BaseCamera = BaseCamera;
});
define("Configurable", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function Configurable(base) {
        return (function (_super) {
            __extends(class_1, _super);
            function class_1() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var _this = _super.apply(this, args) || this;
                //get the number of arguments that aren't undefined. TS passes a value to all parameters
                //of whatever ctor is the implementation, so args.length doesn't work here.
                var size = args.filter(function (value) { return value !== undefined; }).length;
                if (size === 1 && args[0] && typeof args[0] === 'object' && !(args[0] instanceof Array)) {
                    _this.assign(args[0]);
                }
                return _this;
            }
            class_1.prototype.assign = function (props) {
                //set the value of every property that was passed in,
                //if the constructor previously set this value, it will be overridden here
                for (var k in props) {
                    if (typeof this[k] !== 'function') {
                        this[k] = props[k];
                    }
                }
            };
            return class_1;
        }(base));
    }
    exports.Configurable = Configurable;
});
define("DebugFlags", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Drawing/Color", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Provides standard colors (e.g. [[Color.Black]])
     * but you can also create custom colors using RGB, HSL, or Hex. Also provides
     * useful color operations like [[Color.lighten]], [[Color.darken]], and more.
     *
     * [[include:Colors.md]]
     */
    var Color = (function () {
        /**
         * Creates a new instance of Color from an r, g, b, a
         *
         * @param r  The red component of color (0-255)
         * @param g  The green component of color (0-255)
         * @param b  The blue component of color (0-255)
         * @param a  The alpha component of color (0-1.0)
         */
        function Color(r, g, b, a) {
            this.r = r;
            this.g = g;
            this.b = b;
            this.a = (a != null ? a : 1);
        }
        /**
         * Creates a new instance of Color from an r, g, b, a
         *
         * @param r  The red component of color (0-255)
         * @param g  The green component of color (0-255)
         * @param b  The blue component of color (0-255)
         * @param a  The alpha component of color (0-1.0)
         */
        Color.fromRGB = function (r, g, b, a) {
            return new Color(r, g, b, a);
        };
        /**
         * Creates a new inscance of Color from a hex string
         *
         * @param hex  CSS color string of the form #ffffff, the alpha component is optional
         */
        Color.fromHex = function (hex) {
            var hexRegEx = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i;
            var match = null;
            if (match = hex.match(hexRegEx)) {
                var r = parseInt(match[1], 16);
                var g = parseInt(match[2], 16);
                var b = parseInt(match[3], 16);
                var a = 1;
                if (match[4]) {
                    a = parseInt(match[4], 16) / 255;
                }
                return new Color(r, g, b, a);
            }
            else {
                throw new Error('Invalid hex string: ' + hex);
            }
        };
        /**
         * Creats a new instance of Color from hsla values
         *
         * @param h  Hue is represented [0-1]
         * @param s  Saturation is represented [0-1]
         * @param l  Luminance is represented [0-1]
         * @param a  Alpha is represented [0-1]
         */
        Color.fromHSL = function (h, s, l, a) {
            if (a === void 0) { a = 1.0; }
            var temp = new HSLColor(h, s, l, a);
            return temp.toRGBA();
        };
        /**
         * Lightens the current color by a specified amount
         *
         * @param factor  The amount to lighten by [0-1]
         */
        Color.prototype.lighten = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            var temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
            temp.l += (temp.l * factor);
            return temp.toRGBA();
        };
        /**
         * Darkens the current color by a specified amount
         *
         * @param factor  The amount to darken by [0-1]
         */
        Color.prototype.darken = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            var temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
            temp.l -= (temp.l * factor);
            return temp.toRGBA();
        };
        /**
         * Saturates the current color by a specified amount
         *
         * @param factor  The amount to saturate by [0-1]
         */
        Color.prototype.saturate = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            var temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
            temp.s += (temp.s * factor);
            return temp.toRGBA();
        };
        /**
         * Desaturates the current color by a specified amount
         *
         * @param factor  The amount to desaturate by [0-1]
         */
        Color.prototype.desaturate = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            var temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
            temp.s -= (temp.s * factor);
            return temp.toRGBA();
        };
        /**
         * Multiplies a color by another, results in a darker color
         *
         * @param color  The other color
         */
        Color.prototype.mulitiply = function (color) {
            var newR = ((color.r / 255 * this.r / 255) * 255);
            var newG = ((color.g / 255 * this.g / 255) * 255);
            var newB = ((color.b / 255 * this.b / 255) * 255);
            var newA = (color.a * this.a);
            return new Color(newR, newG, newB, newA);
        };
        /**
         * Screens a color by another, results in a lighter color
         *
         * @param color  The other color
         */
        Color.prototype.screen = function (color) {
            var color1 = color.invert();
            var color2 = color.invert();
            return color1.mulitiply(color2).invert();
        };
        /**
         * Inverts the current color
         */
        Color.prototype.invert = function () {
            return new Color(255 - this.r, 255 - this.g, 255 - this.b, 1.0 - this.a);
        };
        /**
         * Averages the current color with another
         *
         * @param color  The other color
         */
        Color.prototype.average = function (color) {
            var newR = (color.r + this.r) / 2;
            var newG = (color.g + this.g) / 2;
            var newB = (color.b + this.b) / 2;
            var newA = (color.a + this.a) / 2;
            return new Color(newR, newG, newB, newA);
        };
        /**
         * Returns a CSS string representation of a color.
         *
         * @param format Color representation, accepts: rgb, hsl, or hex
         */
        Color.prototype.toString = function (format) {
            if (format === void 0) { format = 'rgb'; }
            switch (format) {
                case 'rgb':
                    return this.toRGBA();
                case 'hsl':
                    return this.toHSLA();
                case 'hex':
                    return this.toHex();
                default:
                    throw new Error('Invalid Color format');
            }
        };
        /**
         * Returns Hex Value of a color component
         * @param c color component
         * @see https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
         */
        Color.prototype._componentToHex = function (c) {
            var hex = c.toString(16);
            return hex.length === 1 ? '0' + hex : hex;
        };
        /**
         * Return Hex representation of a color.
         */
        Color.prototype.toHex = function () {
            return '#' + this._componentToHex(this.r) + this._componentToHex(this.g) + this._componentToHex(this.b);
        };
        /**
         * Return RGBA representation of a color.
         */
        Color.prototype.toRGBA = function () {
            var result = String(this.r.toFixed(0)) + ', ' + String(this.g.toFixed(0)) + ', ' + String(this.b.toFixed(0));
            if (this.a !== undefined || this.a !== null) {
                return 'rgba(' + result + ', ' + String(this.a) + ')';
            }
            return 'rgb(' + result + ')';
        };
        /**
         * Return HSLA representation of a color.
         */
        Color.prototype.toHSLA = function () {
            return HSLColor.fromRGBA(this.r, this.g, this.b, this.a).toString();
        };
        /**
         * Returns a CSS string representation of a color.
         */
        Color.prototype.fillStyle = function () {
            return this.toString();
        };
        /**
         * Returns a clone of the current color.
         */
        Color.prototype.clone = function () {
            return new Color(this.r, this.g, this.b, this.a);
        };
        return Color;
    }());
    /**
     * Black (#000000)
     */
    Color.Black = Color.fromHex('#000000');
    /**
     * White (#FFFFFF)
     */
    Color.White = Color.fromHex('#FFFFFF');
    /**
     * Gray (#808080)
     */
    Color.Gray = Color.fromHex('#808080');
    /**
     * Light gray (#D3D3D3)
     */
    Color.LightGray = Color.fromHex('#D3D3D3');
    /**
     * Dark gray (#A9A9A9)
     */
    Color.DarkGray = Color.fromHex('#A9A9A9');
    /**
     * Yellow (#FFFF00)
     */
    Color.Yellow = Color.fromHex('#FFFF00');
    /**
     * Orange (#FFA500)
     */
    Color.Orange = Color.fromHex('#FFA500');
    /**
     * Red (#FF0000)
     */
    Color.Red = Color.fromHex('#FF0000');
    /**
     * Vermillion (#FF5B31)
     */
    Color.Vermillion = Color.fromHex('#FF5B31');
    /**
     * Rose (#FF007F)
     */
    Color.Rose = Color.fromHex('#FF007F');
    /**
     * Magenta (#FF00FF)
     */
    Color.Magenta = Color.fromHex('#FF00FF');
    /**
     * Violet (#7F00FF)
     */
    Color.Violet = Color.fromHex('#7F00FF');
    /**
     * Blue (#0000FF)
     */
    Color.Blue = Color.fromHex('#0000FF');
    /**
     * Azure (#007FFF)
     */
    Color.Azure = Color.fromHex('#007FFF');
    /**
     * Cyan (#00FFFF)
     */
    Color.Cyan = Color.fromHex('#00FFFF');
    /**
     * Viridian (#59978F)
     */
    Color.Viridian = Color.fromHex('#59978F');
    /**
     * Green (#00FF00)
     */
    Color.Green = Color.fromHex('#00FF00');
    /**
     * Chartreuse (#7FFF00)
     */
    Color.Chartreuse = Color.fromHex('#7FFF00');
    /**
     * Transparent (#FFFFFF00)
     */
    Color.Transparent = Color.fromHex('#FFFFFF00');
    exports.Color = Color;
    /**
     * Internal HSL Color representation
     *
     * http://en.wikipedia.org/wiki/HSL_and_HSV
     * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
     */
    var HSLColor = (function () {
        function HSLColor(h, s, l, a) {
            this.h = h;
            this.s = s;
            this.l = l;
            this.a = a;
        }
        HSLColor.hue2rgb = function (p, q, t) {
            if (t < 0) {
                t += 1;
            }
            if (t > 1) {
                t -= 1;
            }
            if (t < 1 / 6) {
                return p + (q - p) * 6 * t;
            }
            if (t < 1 / 2) {
                return q;
            }
            if (t < 2 / 3) {
                return p + (q - p) * (2 / 3 - t) * 6;
            }
            return p;
        };
        HSLColor.fromRGBA = function (r, g, b, a) {
            r /= 255;
            g /= 255;
            b /= 255;
            var max = Math.max(r, g, b), min = Math.min(r, g, b);
            var h, s, l = (max + min) / 2;
            if (max === min) {
                h = s = 0; // achromatic
            }
            else {
                var d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r:
                        h = (g - b) / d + (g < b ? 6 : 0);
                        break;
                    case g:
                        h = (b - r) / d + 2;
                        break;
                    case b:
                        h = (r - g) / d + 4;
                        break;
                }
                h /= 6;
            }
            return new HSLColor(h, s, l, a);
        };
        HSLColor.prototype.toRGBA = function () {
            var r, g, b;
            if (this.s === 0) {
                r = g = b = this.l; // achromatic
            }
            else {
                var q = this.l < 0.5 ? this.l * (1 + this.s) : this.l + this.s - this.l * this.s;
                var p = 2 * this.l - q;
                r = HSLColor.hue2rgb(p, q, this.h + 1 / 3);
                g = HSLColor.hue2rgb(p, q, this.h);
                b = HSLColor.hue2rgb(p, q, this.h - 1 / 3);
            }
            return new Color(r * 255, g * 255, b * 255, this.a);
        };
        HSLColor.prototype.toString = function () {
            var h = this.h.toFixed(0), s = this.s.toFixed(0), l = this.l.toFixed(0), a = this.a.toFixed(0);
            return "hsla(" + h + ", " + s + ", " + l + ", " + a + ")";
        };
        return HSLColor;
    }());
});
define("Collision/CollisionContact", ["require", "exports", "Actor", "Algebra", "Physics", "Events", "Util/Util"], function (require, exports, Actor_1, Algebra_4, Physics_1, Events_1, Util) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Collision contacts are used internally by Excalibur to resolve collision between actors. This
     * Pair prevents collisions from being evaluated more than one time
     */
    var CollisionContact = (function () {
        function CollisionContact(bodyA, bodyB, mtv, point, normal) {
            this.bodyA = bodyA;
            this.bodyB = bodyB;
            this.mtv = mtv;
            this.point = point;
            this.normal = normal;
        }
        CollisionContact.prototype.resolve = function (strategy) {
            if (strategy === Physics_1.CollisionResolutionStrategy.RigidBody) {
                this._resolveRigidBodyCollision();
            }
            else if (strategy === Physics_1.CollisionResolutionStrategy.Box) {
                this._resolveBoxCollision();
            }
            else {
                throw new Error('Unknown collision resolution strategy');
            }
        };
        CollisionContact.prototype._applyBoxImpulse = function (bodyA, bodyB, mtv) {
            if (bodyA.collisionType === Actor_1.CollisionType.Active &&
                bodyB.collisionType !== Actor_1.CollisionType.Passive) {
                // Resolve overlaps
                if (bodyA.collisionType === Actor_1.CollisionType.Active &&
                    bodyB.collisionType === Actor_1.CollisionType.Active) {
                    // split overlaps if both are Active
                    mtv = mtv.scale(.5);
                }
                // Apply mtv
                bodyA.pos.y += mtv.y;
                bodyA.pos.x += mtv.x;
                // non-zero intersection on the y axis
                if (this.mtv.x !== 0) {
                    var velX = 0;
                    // both bodies are traveling in the same direction (negative or positive)
                    if (bodyA.vel.x < 0 && bodyB.vel.x < 0) {
                        velX = Math.min(bodyA.vel.x, bodyB.vel.x);
                    }
                    else if (bodyA.vel.x > 0 && bodyB.vel.x > 0) {
                        velX = Math.max(bodyA.vel.x, bodyB.vel.x);
                    }
                    else if (bodyB.collisionType === Actor_1.CollisionType.Fixed) {
                        // bodies are traveling in opposite directions
                        if (bodyA.pos.sub(bodyB.pos).dot(bodyA.vel) > 0) {
                            velX = bodyA.vel.x;
                        }
                        else {
                            // bodyA is heading towards b
                            velX = bodyB.vel.x;
                        }
                    }
                    bodyA.vel.x = velX;
                }
                if (this.mtv.y !== 0) {
                    var velY = 0;
                    // both bodies are traveling in the same direction (negative or positive)
                    if (bodyA.vel.y < 0 && bodyB.vel.y < 0) {
                        velY = Math.min(bodyA.vel.y, bodyB.vel.y);
                    }
                    else if (bodyA.vel.y > 0 && bodyB.vel.y > 0) {
                        velY = Math.max(bodyA.vel.y, bodyB.vel.y);
                    }
                    else if (bodyB.collisionType === Actor_1.CollisionType.Fixed) {
                        // bodies are traveling in opposite directions
                        if (bodyA.pos.sub(bodyB.pos).dot(bodyA.vel) > 0) {
                            velY = bodyA.vel.y;
                        }
                        else {
                            // bodyA is heading towards b
                            velY = bodyB.vel.y;
                        }
                    }
                    bodyA.vel.y = velY;
                }
                bodyA.emit('postcollision', new Events_1.PostCollisionEvent(bodyA, bodyB, Util.getSideFromVector(mtv), mtv));
            }
        };
        CollisionContact.prototype._resolveBoxCollision = function () {
            var bodyA = this.bodyA.body.actor;
            var bodyB = this.bodyB.body.actor;
            var side = Util.getSideFromVector(this.mtv);
            var mtv = this.mtv.negate();
            // Publish collision events on both participants
            bodyA.emit('precollision', new Events_1.PreCollisionEvent(bodyA, bodyB, side, mtv));
            bodyB.emit('precollision', new Events_1.PreCollisionEvent(bodyB, bodyA, Util.getOppositeSide(side), mtv.negate()));
            this._applyBoxImpulse(bodyA, bodyB, mtv);
            this._applyBoxImpulse(bodyB, bodyA, mtv.negate());
        };
        CollisionContact.prototype._resolveRigidBodyCollision = function () {
            // perform collison on bounding areas
            var bodyA = this.bodyA.body;
            var bodyB = this.bodyB.body;
            var mtv = this.mtv; // normal pointing away from bodyA
            var normal = this.normal; // normal pointing away from bodyA
            if (bodyA.actor === bodyB.actor) {
                return;
            }
            // Publish collision events on both participants
            var side = Util.getSideFromVector(this.mtv);
            bodyA.actor.emit('precollision', new Events_1.PreCollisionEvent(this.bodyA.body.actor, this.bodyB.body.actor, side, this.mtv));
            bodyB.actor.emit('precollision', new Events_1.PreCollisionEvent(this.bodyB.body.actor, this.bodyA.body.actor, Util.getOppositeSide(side), this.mtv.negate()));
            // If any of the participants are passive then short circuit
            if (bodyA.actor.collisionType === Actor_1.CollisionType.Passive ||
                bodyB.actor.collisionType === Actor_1.CollisionType.Passive) {
                return;
            }
            var invMassA = bodyA.actor.collisionType === Actor_1.CollisionType.Fixed ? 0 : 1 / bodyA.mass;
            var invMassB = bodyB.actor.collisionType === Actor_1.CollisionType.Fixed ? 0 : 1 / bodyB.mass;
            var invMoiA = bodyA.actor.collisionType === Actor_1.CollisionType.Fixed ? 0 : 1 / bodyA.moi;
            var invMoiB = bodyB.actor.collisionType === Actor_1.CollisionType.Fixed ? 0 : 1 / bodyB.moi;
            // average restitution more relistic
            var coefRestitution = Math.min(bodyA.restitution, bodyB.restitution);
            var coefFriction = Math.min(bodyA.friction, bodyB.friction);
            normal = normal.normalize();
            var tangent = normal.normal().normalize();
            var ra = this.point.sub(this.bodyA.getCenter()); // point relative to bodyA position
            var rb = this.point.sub(this.bodyB.getCenter()); /// point relative to bodyB
            // Relative velocity in linear terms
            // Angular to linear velocity formula -> omega = v/r
            var rv = bodyB.vel.add(rb.cross(-bodyB.rx)).sub(bodyA.vel.sub(ra.cross(bodyA.rx)));
            var rvNormal = rv.dot(normal);
            var rvTangent = rv.dot(tangent);
            var raTangent = ra.dot(tangent);
            var raNormal = ra.dot(normal);
            var rbTangent = rb.dot(tangent);
            var rbNormal = rb.dot(normal);
            // If objects are moving away ignore
            if (rvNormal > 0) {
                return;
            }
            // Collision impulse formula from Chris Hecker
            // https://en.wikipedia.org/wiki/Collision_response
            var impulse = -((1 + coefRestitution) * rvNormal) /
                ((invMassA + invMassB) + invMoiA * raTangent * raTangent + invMoiB * rbTangent * rbTangent);
            if (bodyA.actor.collisionType === Actor_1.CollisionType.Fixed) {
                bodyB.vel = bodyB.vel.add(normal.scale(impulse * invMassB));
                if (Physics_1.Physics.allowRigidBodyRotation) {
                    bodyB.rx -= impulse * invMoiB * -rb.cross(normal);
                }
                bodyB.addMtv(mtv);
            }
            else if (bodyB.actor.collisionType === Actor_1.CollisionType.Fixed) {
                bodyA.vel = bodyA.vel.sub(normal.scale(impulse * invMassA));
                if (Physics_1.Physics.allowRigidBodyRotation) {
                    bodyA.rx += impulse * invMoiA * -ra.cross(normal);
                }
                bodyA.addMtv(mtv.negate());
            }
            else {
                bodyB.vel = bodyB.vel.add(normal.scale(impulse * invMassB));
                bodyA.vel = bodyA.vel.sub(normal.scale(impulse * invMassA));
                if (Physics_1.Physics.allowRigidBodyRotation) {
                    bodyB.rx -= impulse * invMoiB * -rb.cross(normal);
                    bodyA.rx += impulse * invMoiA * -ra.cross(normal);
                }
                // Split the mtv in half for the two bodies, potentially we could do something smarter here
                bodyB.addMtv(mtv.scale(.5));
                bodyA.addMtv(mtv.scale(-.5));
            }
            // Friction portion of impulse
            if (coefFriction && rvTangent) {
                // Columb model of friction, formula for impulse due to friction from  
                // https://en.wikipedia.org/wiki/Collision_response
                // tangent force exerted by body on another in contact
                var t = rv.sub(normal.scale(rv.dot(normal))).normalize();
                // impulse in the direction of tangent force
                var jt = rv.dot(t) / (invMassA + invMassB + raNormal * raNormal * invMoiA + rbNormal * rbNormal * invMoiB);
                var frictionImpulse = new Algebra_4.Vector(0, 0);
                if (Math.abs(jt) <= impulse * coefFriction) {
                    frictionImpulse = t.scale(jt).negate();
                }
                else {
                    frictionImpulse = t.scale(-impulse * coefFriction);
                }
                if (bodyA.actor.collisionType === Actor_1.CollisionType.Fixed) {
                    // apply frictional impulse
                    bodyB.vel = bodyB.vel.add(frictionImpulse.scale(invMassB));
                    if (Physics_1.Physics.allowRigidBodyRotation) {
                        bodyB.rx += frictionImpulse.dot(t) * invMoiB * rb.cross(t);
                    }
                }
                else if (bodyB.actor.collisionType === Actor_1.CollisionType.Fixed) {
                    // apply frictional impulse
                    bodyA.vel = bodyA.vel.sub(frictionImpulse.scale(invMassA));
                    if (Physics_1.Physics.allowRigidBodyRotation) {
                        bodyA.rx -= frictionImpulse.dot(t) * invMoiA * ra.cross(t);
                    }
                }
                else {
                    // apply frictional impulse
                    bodyB.vel = bodyB.vel.add(frictionImpulse.scale(invMassB));
                    bodyA.vel = bodyA.vel.sub(frictionImpulse.scale(invMassA));
                    // apply frictional impulse
                    if (Physics_1.Physics.allowRigidBodyRotation) {
                        bodyB.rx += frictionImpulse.dot(t) * invMoiB * rb.cross(t);
                        bodyA.rx -= frictionImpulse.dot(t) * invMoiA * ra.cross(t);
                    }
                }
            }
            bodyA.actor.emit('postcollision', new Events_1.PostCollisionEvent(this.bodyA.body.actor, this.bodyB.body.actor, side, this.mtv));
            bodyB.actor.emit('postcollision', new Events_1.PostCollisionEvent(this.bodyB.body.actor, this.bodyA.body.actor, Util.getOppositeSide(side), this.mtv.negate()));
        };
        return CollisionContact;
    }());
    exports.CollisionContact = CollisionContact;
});
define("Collision/ICollisionArea", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Collision/CircleArea", ["require", "exports", "Collision/BoundingBox", "Collision/PolygonArea", "Collision/EdgeArea", "Collision/CollisionJumpTable", "Algebra", "Physics", "Drawing/Color"], function (require, exports, BoundingBox_1, PolygonArea_1, EdgeArea_1, CollisionJumpTable_1, Algebra_5, Physics_2, Color_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * This is a circle collision area for the excalibur rigid body physics simulation
     */
    var CircleArea = (function () {
        function CircleArea(options) {
            /**
             * This is the center position of the circle, relative to the body position
             */
            this.pos = Algebra_5.Vector.Zero.clone();
            this.pos = options.pos || Algebra_5.Vector.Zero.clone();
            this.radius = options.radius || 0;
            this.body = options.body || null;
        }
        /**
         * Get the center of the collision area in world coordinates
         */
        CircleArea.prototype.getCenter = function () {
            if (this.body) {
                return this.pos.add(this.body.pos);
            }
            return this.pos;
        };
        /**
         * Tests if a point is contained in this collision area
         */
        CircleArea.prototype.contains = function (point) {
            var distance = this.body.pos.distance(point);
            if (distance <= this.radius) {
                return true;
            }
            return false;
        };
        /**
         * Casts a ray at the CircleArea and returns the nearest point of collision
         * @param ray
         */
        CircleArea.prototype.rayCast = function (ray, max) {
            if (max === void 0) { max = Infinity; }
            //https://en.wikipedia.org/wiki/Line%E2%80%93sphere_intersection
            var c = this.getCenter();
            var dir = ray.dir;
            var orig = ray.pos;
            var discriminant = Math.sqrt(Math.pow(dir.dot(orig.sub(c)), 2) -
                Math.pow(orig.sub(c).distance(), 2) +
                Math.pow(this.radius, 2));
            if (discriminant < 0) {
                // no intersection
                return null;
            }
            else {
                var toi = 0;
                if (discriminant === 0) {
                    toi = -dir.dot(orig.sub(c));
                    if (toi > 0 && toi < max) {
                        return ray.getPoint(toi);
                    }
                    return null;
                }
                else {
                    var toi1 = -dir.dot(orig.sub(c)) + discriminant;
                    var toi2 = -dir.dot(orig.sub(c)) - discriminant;
                    var mintoi = Math.min(toi1, toi2);
                    if (mintoi <= max) {
                        return ray.getPoint(mintoi);
                    }
                    return null;
                }
            }
        };
        /**
         * @inheritdoc
         */
        CircleArea.prototype.collide = function (area) {
            if (area instanceof CircleArea) {
                return CollisionJumpTable_1.CollisionJumpTable.CollideCircleCircle(this, area);
            }
            else if (area instanceof PolygonArea_1.PolygonArea) {
                return CollisionJumpTable_1.CollisionJumpTable.CollideCirclePolygon(this, area);
            }
            else if (area instanceof EdgeArea_1.EdgeArea) {
                return CollisionJumpTable_1.CollisionJumpTable.CollideCircleEdge(this, area);
            }
            else {
                throw new Error("Circle could not collide with unknown ICollisionArea " + typeof area);
            }
        };
        /**
         * Find the point on the shape furthest in the direction specified
         */
        CircleArea.prototype.getFurthestPoint = function (direction) {
            return this.getCenter().add(direction.normalize().scale(this.radius));
        };
        /**
         * Get the axis aligned bounding box for the circle area
         */
        CircleArea.prototype.getBounds = function () {
            return new BoundingBox_1.BoundingBox(this.pos.x + this.body.pos.x - this.radius, this.pos.y + this.body.pos.y - this.radius, this.pos.x + this.body.pos.x + this.radius, this.pos.y + this.body.pos.y + this.radius);
        };
        /**
         * Get axis not implemented on circles, since there are infinite axis in a circle
         */
        CircleArea.prototype.getAxes = function () {
            return null;
        };
        /**
         * Returns the moment of inertia of a circle given it's mass
         * https://en.wikipedia.org/wiki/List_of_moments_of_inertia
         */
        CircleArea.prototype.getMomentOfInertia = function () {
            var mass = this.body ? this.body.mass : Physics_2.Physics.defaultMass;
            return (mass * this.radius * this.radius) / 2;
        };
        /**
         * Tests the separating axis theorem for circles against polygons
         */
        CircleArea.prototype.testSeparatingAxisTheorem = function (polygon) {
            var axes = polygon.getAxes();
            var pc = polygon.getCenter();
            // Special SAT with circles
            var closestPointOnPoly = polygon.getFurthestPoint(this.pos.sub(pc));
            axes.push(this.pos.sub(closestPointOnPoly).normalize());
            var minOverlap = Number.MAX_VALUE;
            var minAxis = null;
            var minIndex = -1;
            for (var i = 0; i < axes.length; i++) {
                var proj1 = polygon.project(axes[i]);
                var proj2 = this.project(axes[i]);
                var overlap = proj1.getOverlap(proj2);
                if (overlap <= 0) {
                    return null;
                }
                else {
                    if (overlap < minOverlap) {
                        minOverlap = overlap;
                        minAxis = axes[i];
                        minIndex = i;
                    }
                }
            }
            if (minIndex < 0) {
                return null;
            }
            return minAxis.normalize().scale(minOverlap);
        };
        /* istanbul ignore next */
        CircleArea.prototype.recalc = function () {
            // circles don't cache
        };
        /**
         * Project the circle along a specified axis
         */
        CircleArea.prototype.project = function (axis) {
            var scalars = [];
            var point = this.getCenter();
            var dotProduct = point.dot(axis);
            scalars.push(dotProduct);
            scalars.push(dotProduct + this.radius);
            scalars.push(dotProduct - this.radius);
            return new Algebra_5.Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));
        };
        /* istanbul ignore next */
        CircleArea.prototype.debugDraw = function (ctx, color) {
            if (color === void 0) { color = Color_1.Color.Green.clone(); }
            var pos = this.body ? this.body.pos.add(this.pos) : this.pos;
            var rotation = this.body ? this.body.rotation : 0;
            ctx.beginPath();
            ctx.strokeStyle = color.toString();
            ctx.arc(pos.x, pos.y, this.radius, 0, Math.PI * 2);
            ctx.closePath();
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(pos.x, pos.y);
            ctx.lineTo(Math.cos(rotation) * this.radius + pos.x, Math.sin(rotation) * this.radius + pos.y);
            ctx.closePath();
            ctx.stroke();
        };
        return CircleArea;
    }());
    exports.CircleArea = CircleArea;
});
define("Collision/CollisionJumpTable", ["require", "exports", "Collision/CollisionContact", "Collision/PolygonArea"], function (require, exports, CollisionContact_1, PolygonArea_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CollisionJumpTable = {
        CollideCircleCircle: function (circleA, circleB) {
            var radius = circleA.radius + circleB.radius;
            var circleAPos = circleA.body.pos.add(circleA.pos);
            var circleBPos = circleB.body.pos.add(circleB.pos);
            if (circleAPos.distance(circleBPos) > radius) {
                return null;
            }
            var axisOfCollision = circleBPos.sub(circleAPos).normalize();
            var mvt = axisOfCollision.scale(radius - circleBPos.distance(circleAPos));
            var pointOfCollision = circleA.getFurthestPoint(axisOfCollision);
            return new CollisionContact_1.CollisionContact(circleA, circleB, mvt, pointOfCollision, axisOfCollision);
        },
        CollideCirclePolygon: function (circle, polygon) {
            var minAxis = circle.testSeparatingAxisTheorem(polygon);
            if (!minAxis) {
                return null;
            }
            // make sure that the minAxis is pointing away from circle
            var samedir = minAxis.dot(polygon.getCenter().sub(circle.getCenter()));
            minAxis = samedir < 0 ? minAxis.negate() : minAxis;
            var verts = [];
            var point1 = polygon.getFurthestPoint(minAxis.negate());
            var point2 = circle.getFurthestPoint(minAxis); //.add(cc);
            if (circle.contains(point1)) {
                verts.push(point1);
            }
            if (polygon.contains(point2)) {
                verts.push(point2);
            }
            if (verts.length === 0) {
                return null;
            }
            return new CollisionContact_1.CollisionContact(circle, polygon, minAxis, verts.length === 2 ? verts[0].average(verts[1]) : verts[0], minAxis.normalize());
        },
        CollideCircleEdge: function (circle, edge) {
            // center of the circle
            var cc = circle.getCenter();
            // vector in the direction of the edge
            var e = edge.end.sub(edge.begin);
            // amount of overlap with the circle's center along the edge direction
            var u = e.dot(edge.end.sub(cc));
            var v = e.dot(cc.sub(edge.begin));
            // Potential region A collision (circle is on the left side of the edge, before the beginning)
            if (v <= 0) {
                var da = edge.begin.sub(cc);
                var dda = da.dot(da); // quick and dirty way of calc'n distance in r^2 terms saves some sqrts
                // save some sqrts
                if (dda > circle.radius * circle.radius) {
                    return null; // no collision
                }
                return new CollisionContact_1.CollisionContact(circle, edge, da.normalize().scale(circle.radius - Math.sqrt(dda)), edge.begin, da.normalize());
            }
            // Potential region B collision (circle is on the right side of the edge, after the end)
            if (u <= 0) {
                var db = edge.end.sub(cc);
                var ddb = db.dot(db);
                if (ddb > circle.radius * circle.radius) {
                    return null;
                }
                return new CollisionContact_1.CollisionContact(circle, edge, db.normalize().scale(circle.radius - Math.sqrt(ddb)), edge.end, db.normalize());
            }
            // Otherwise potential region AB collision (circle is in the middle of the edge between the beginning and end)
            var den = e.dot(e);
            var pointOnEdge = (edge.begin.scale(u).add(edge.end.scale(v))).scale(1 / den);
            var d = cc.sub(pointOnEdge);
            var dd = d.dot(d);
            if (dd > circle.radius * circle.radius) {
                return null; // no collision
            }
            var n = e.perpendicular();
            // flip correct direction
            if (n.dot(cc.sub(edge.begin)) < 0) {
                n.x = -n.x;
                n.y = -n.y;
            }
            n = n.normalize();
            var mvt = n.scale(Math.abs(circle.radius - Math.sqrt(dd)));
            return new CollisionContact_1.CollisionContact(circle, edge, mvt.negate(), pointOnEdge, n.negate());
        },
        CollideEdgeEdge: function () {
            // Edge-edge collision doesn't make sense
            return null;
        },
        CollidePolygonEdge: function (polygon, edge) {
            // 3 cases:
            // (1) Polygon lands on the full face
            // (2) Polygon lands on the right point
            // (3) Polygon lands on the left point
            var e = edge.end.sub(edge.begin);
            var edgeNormal = e.normal();
            if (polygon.contains(edge.begin)) {
                var _a = polygon.getClosestFace(edge.begin), mtv = _a.distance, face = _a.face;
                if (mtv) {
                    return new CollisionContact_1.CollisionContact(polygon, edge, mtv.negate(), edge.begin.add(mtv.negate()), face.normal().negate());
                }
            }
            if (polygon.contains(edge.end)) {
                var _b = polygon.getClosestFace(edge.end), mtv = _b.distance, face = _b.face;
                if (mtv) {
                    return new CollisionContact_1.CollisionContact(polygon, edge, mtv.negate(), edge.end.add(mtv.negate()), face.normal().negate());
                }
            }
            var pc = polygon.getCenter();
            var ec = edge.getCenter();
            var dir = ec.sub(pc).normalize();
            // build a temporary polygon from the edge to use SAT
            var linePoly = new PolygonArea_2.PolygonArea({
                points: [
                    edge.begin,
                    edge.end,
                    edge.end.add(dir.scale(30)),
                    edge.begin.add(dir.scale(30))
                ]
            });
            var minAxis = polygon.testSeparatingAxisTheorem(linePoly);
            // no minAxis, no overlap, no collision
            if (!minAxis) {
                return null;
            }
            // flip the normal and axis to always have positive collisions
            edgeNormal = edgeNormal.dot(dir) < 0 ? edgeNormal.negate() : edgeNormal;
            minAxis = minAxis.dot(dir) < 0 ? minAxis.negate() : minAxis;
            return new CollisionContact_1.CollisionContact(polygon, edge, minAxis, polygon.getFurthestPoint(edgeNormal), edgeNormal);
        },
        CollidePolygonPolygon: function (polyA, polyB) {
            // do a SAT test to find a min axis if it exists
            var minAxis = polyA.testSeparatingAxisTheorem(polyB);
            // no overlap, no collision return null
            if (!minAxis) {
                return null;
            }
            // make sure that minAxis is pointing from A -> B
            var sameDir = minAxis.dot(polyB.getCenter().sub(polyA.getCenter()));
            minAxis = sameDir < 0 ? minAxis.negate() : minAxis;
            // find rough point of collision
            // todo this could be better
            var verts = [];
            var pointA = polyA.getFurthestPoint(minAxis);
            var pointB = polyB.getFurthestPoint(minAxis.negate());
            if (polyB.contains(pointA)) {
                verts.push(pointA);
            }
            if (polyA.contains(pointB)) {
                verts.push(pointB);
            }
            // no candidates, pick something
            if (verts.length === 0) {
                verts.push(pointB);
            }
            var contact = verts.length === 2 ? verts[0].add(verts[1]).scale(.5) : verts[0];
            return new CollisionContact_1.CollisionContact(polyA, polyB, minAxis, contact, minAxis.normalize());
        }
    };
});
define("Collision/PolygonArea", ["require", "exports", "Drawing/Color", "Physics", "Collision/BoundingBox", "Collision/EdgeArea", "Collision/CollisionJumpTable", "Collision/CircleArea", "Algebra"], function (require, exports, Color_2, Physics_3, BoundingBox_2, EdgeArea_2, CollisionJumpTable_2, CircleArea_1, Algebra_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Polygon collision area for detecting collisions for actors, or independently
     */
    var PolygonArea = (function () {
        function PolygonArea(options) {
            this._transformedPoints = [];
            this._axes = [];
            this._sides = [];
            this.pos = options.pos || Algebra_6.Vector.Zero.clone();
            var winding = !!options.clockwiseWinding;
            this.points = (winding ? options.points.reverse() : options.points) || [];
            this.body = options.body || null;
            // calculate initial transformation
            this._calculateTransformation();
        }
        /**
         * Get the center of the collision area in world coordinates
         */
        PolygonArea.prototype.getCenter = function () {
            if (this.body) {
                return this.body.pos.add(this.pos);
            }
            return this.pos;
        };
        /**
         * Calculates the underlying transformation from the body relative space to world space
         */
        PolygonArea.prototype._calculateTransformation = function () {
            var pos = this.body ? this.body.pos.add(this.pos) : this.pos;
            var angle = this.body ? this.body.rotation : 0;
            var len = this.points.length;
            this._transformedPoints.length = 0; // clear out old transform
            for (var i = 0; i < len; i++) {
                this._transformedPoints[i] = this.points[i].rotate(angle).add(pos);
            }
        };
        /**
         * Gets the points that make up the polygon in world space, from actor relative space (if specified)
         */
        PolygonArea.prototype.getTransformedPoints = function () {
            if (!this._transformedPoints.length) {
                this._calculateTransformation();
            }
            ;
            return this._transformedPoints;
        };
        /**
         * Gets the sides of the polygon in world space
         */
        PolygonArea.prototype.getSides = function () {
            if (this._sides.length) {
                return this._sides;
            }
            var lines = [];
            var points = this.getTransformedPoints();
            var len = points.length;
            for (var i = 0; i < len; i++) {
                lines.push(new Algebra_6.Line(points[i], points[(i - 1 + len) % len]));
            }
            this._sides = lines;
            return this._sides;
        };
        PolygonArea.prototype.recalc = function () {
            this._sides.length = 0;
            this._axes.length = 0;
            this._transformedPoints.length = 0;
            this.getTransformedPoints();
            this.getAxes();
            this.getSides();
        };
        /**
         * Tests if a point is contained in this collision area in world space
         */
        PolygonArea.prototype.contains = function (point) {
            // Always cast to the right, as long as we cast in a consitent fixed direction we
            // will be fine
            var testRay = new Algebra_6.Ray(point, new Algebra_6.Vector(1, 0));
            var intersectCount = this.getSides().reduce(function (accum, side) {
                if (testRay.intersect(side) >= 0) {
                    return accum + 1;
                }
                return accum;
            }, 0);
            if (intersectCount % 2 === 0) {
                return false;
            }
            return true;
        };
        /**
         * Returns a collision contact if the 2 collision areas collide, otherwise collide will
         * return null.
         * @param area
         */
        PolygonArea.prototype.collide = function (area) {
            if (area instanceof CircleArea_1.CircleArea) {
                return CollisionJumpTable_2.CollisionJumpTable.CollideCirclePolygon(area, this);
            }
            else if (area instanceof PolygonArea) {
                return CollisionJumpTable_2.CollisionJumpTable.CollidePolygonPolygon(this, area);
            }
            else if (area instanceof EdgeArea_2.EdgeArea) {
                return CollisionJumpTable_2.CollisionJumpTable.CollidePolygonEdge(this, area);
            }
            else {
                throw new Error("Polygon could not collide with unknown ICollisionArea " + typeof area);
            }
        };
        /**
         * Find the point on the shape furthest in the direction specified
         */
        PolygonArea.prototype.getFurthestPoint = function (direction) {
            var pts = this.getTransformedPoints();
            var furthestPoint = null;
            var maxDistance = -Number.MAX_VALUE;
            for (var i = 0; i < pts.length; i++) {
                var distance = direction.dot(pts[i]);
                if (distance > maxDistance) {
                    maxDistance = distance;
                    furthestPoint = pts[i];
                }
            }
            return furthestPoint;
        };
        /**
         * Finds the closes face to the point using perpendicular distance
         * @param point point to test against polygon
         */
        PolygonArea.prototype.getClosestFace = function (point) {
            var sides = this.getSides();
            var min = Number.POSITIVE_INFINITY;
            var faceIndex = -1;
            var distance = -1;
            for (var i = 0; i < sides.length; i++) {
                var dist = sides[i].distanceToPoint(point);
                if (dist < min) {
                    min = dist;
                    faceIndex = i;
                    distance = dist;
                }
            }
            if (faceIndex !== -1) {
                return {
                    distance: sides[faceIndex].normal().scale(distance),
                    face: sides[faceIndex]
                };
            }
            return null;
        };
        /**
         * Get the axis aligned bounding box for the polygon area
         */
        PolygonArea.prototype.getBounds = function () {
            // todo there is a faster way to do this
            var points = this.getTransformedPoints();
            var minX = points.reduce(function (prev, curr) {
                return Math.min(prev, curr.x);
            }, 999999999);
            var maxX = points.reduce(function (prev, curr) {
                return Math.max(prev, curr.x);
            }, -99999999);
            var minY = points.reduce(function (prev, curr) {
                return Math.min(prev, curr.y);
            }, 9999999999);
            var maxY = points.reduce(function (prev, curr) {
                return Math.max(prev, curr.y);
            }, -9999999999);
            return new BoundingBox_2.BoundingBox(minX, minY, maxX, maxY);
        };
        /**
         * Get the moment of inertia for an arbitrary polygon
         * https://en.wikipedia.org/wiki/List_of_moments_of_inertia
         */
        PolygonArea.prototype.getMomentOfInertia = function () {
            var mass = this.body ? this.body.mass : Physics_3.Physics.defaultMass;
            var numerator = 0;
            var denominator = 0;
            for (var i = 0; i < this.points.length; i++) {
                var iplusone = (i + 1) % this.points.length;
                var crossTerm = this.points[iplusone].cross(this.points[i]);
                numerator += crossTerm * (this.points[i].dot(this.points[i]) +
                    this.points[i].dot(this.points[iplusone]) +
                    this.points[iplusone].dot(this.points[iplusone]));
                denominator += crossTerm;
            }
            return (mass / 6) * (numerator / denominator);
        };
        /**
         * Casts a ray into the polygon and returns a vector representing the point of contact (in world space) or null if no collision.
         */
        PolygonArea.prototype.rayCast = function (ray, max) {
            if (max === void 0) { max = Infinity; }
            // find the minimum contact time greater than 0
            // contact times less than 0 are behind the ray and we don't want those
            var sides = this.getSides();
            var len = sides.length;
            var minContactTime = Number.MAX_VALUE;
            var contactIndex = -1;
            for (var i = 0; i < len; i++) {
                var contactTime = ray.intersect(sides[i]);
                if (contactTime >= 0 && contactTime < minContactTime && contactTime <= max) {
                    minContactTime = contactTime;
                    contactIndex = i;
                }
            }
            // contact was found
            if (contactIndex >= 0) {
                return ray.getPoint(minContactTime);
            }
            // no contact found
            return null;
        };
        /**
         * Get the axis associated with the edge
         */
        PolygonArea.prototype.getAxes = function () {
            if (this._axes.length) {
                return this._axes;
            }
            var axes = [];
            var points = this.getTransformedPoints();
            var len = points.length;
            for (var i = 0; i < len; i++) {
                axes.push(points[i].sub(points[(i + 1) % len]).normal());
            }
            this._axes = axes;
            return this._axes;
        };
        /**
         * Perform Separating Axis test against another polygon, returns null if no overlap in polys
         * Reference http://www.dyn4j.org/2010/01/sat/
         */
        PolygonArea.prototype.testSeparatingAxisTheorem = function (other) {
            var poly1 = this;
            var poly2 = other;
            var axes = poly1.getAxes().concat(poly2.getAxes());
            var minOverlap = Number.MAX_VALUE;
            var minAxis = null;
            var minIndex = -1;
            for (var i = 0; i < axes.length; i++) {
                var proj1 = poly1.project(axes[i]);
                var proj2 = poly2.project(axes[i]);
                var overlap = proj1.getOverlap(proj2);
                if (overlap <= 0) {
                    return null;
                }
                else {
                    if (overlap < minOverlap) {
                        minOverlap = overlap;
                        minAxis = axes[i];
                        minIndex = i;
                    }
                }
            }
            // Sanity check
            if (minIndex === -1) {
                return null;
            }
            return minAxis.normalize().scale(minOverlap);
        };
        /**
         * Project the edges of the polygon along a specified axis
         */
        PolygonArea.prototype.project = function (axis) {
            var points = this.getTransformedPoints();
            var len = points.length;
            var min = Number.MAX_VALUE;
            var max = -Number.MAX_VALUE;
            for (var i = 0; i < len; i++) {
                var scalar = points[i].dot(axis);
                min = Math.min(min, scalar);
                max = Math.max(max, scalar);
            }
            return new Algebra_6.Projection(min, max);
        };
        /* istanbul ignore next */
        PolygonArea.prototype.debugDraw = function (ctx, color) {
            if (color === void 0) { color = Color_2.Color.Red.clone(); }
            ctx.beginPath();
            ctx.strokeStyle = color.toString();
            // Iterate through the supplied points and construct a 'polygon'
            var firstPoint = this.getTransformedPoints()[0];
            ctx.moveTo(firstPoint.x, firstPoint.y);
            this.getTransformedPoints().forEach(function (point) {
                ctx.lineTo(point.x, point.y);
            });
            ctx.lineTo(firstPoint.x, firstPoint.y);
            ctx.closePath();
            ctx.stroke();
        };
        return PolygonArea;
    }());
    exports.PolygonArea = PolygonArea;
});
define("Collision/BoundingBox", ["require", "exports", "Collision/PolygonArea", "Algebra", "Drawing/Color"], function (require, exports, PolygonArea_3, Algebra_7, Color_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Axis Aligned collision primitive for Excalibur.
     */
    var BoundingBox = (function () {
        /**
         * @param left    x coordinate of the left edge
         * @param top     y coordinate of the top edge
         * @param right   x coordinate of the right edge
         * @param bottom  y coordinate of the bottom edge
         */
        function BoundingBox(left, top, right, bottom) {
            if (left === void 0) { left = 0; }
            if (top === void 0) { top = 0; }
            if (right === void 0) { right = 0; }
            if (bottom === void 0) { bottom = 0; }
            this.left = left;
            this.top = top;
            this.right = right;
            this.bottom = bottom;
        }
        BoundingBox.fromPoints = function (points) {
            var minX = Infinity;
            var minY = Infinity;
            var maxX = -Infinity;
            var maxY = -Infinity;
            for (var i = 0; i < points.length; i++) {
                if (points[i].x < minX) {
                    minX = points[i].x;
                }
                if (points[i].x > maxX) {
                    maxX = points[i].x;
                }
                if (points[i].y < minY) {
                    minY = points[i].y;
                }
                if (points[i].y > maxY) {
                    maxY = points[i].y;
                }
            }
            return new BoundingBox(minX, minY, maxX, maxY);
        };
        /**
         * Returns the calculated width of the bounding box
         */
        BoundingBox.prototype.getWidth = function () {
            return this.right - this.left;
        };
        /**
         * Returns the calculated height of the bounding box
         */
        BoundingBox.prototype.getHeight = function () {
            return this.bottom - this.top;
        };
        /**
         * Rotates a bounding box by and angle and around a point, if no point is specified (0, 0) is used by default
         */
        BoundingBox.prototype.rotate = function (angle, point) {
            if (point === void 0) { point = Algebra_7.Vector.Zero.clone(); }
            var points = this.getPoints().map(function (p) { return p.rotate(angle, point); });
            return BoundingBox.fromPoints(points);
        };
        /**
         * Returns the perimeter of the bounding box
         */
        BoundingBox.prototype.getPerimeter = function () {
            var wx = this.getWidth();
            var wy = this.getHeight();
            return 2 * (wx + wy);
        };
        BoundingBox.prototype.getPoints = function () {
            var results = [];
            results.push(new Algebra_7.Vector(this.left, this.top));
            results.push(new Algebra_7.Vector(this.right, this.top));
            results.push(new Algebra_7.Vector(this.right, this.bottom));
            results.push(new Algebra_7.Vector(this.left, this.bottom));
            return results;
        };
        /**
         * Creates a Polygon collision area from the points of the bounding box
         */
        BoundingBox.prototype.toPolygon = function (actor) {
            return new PolygonArea_3.PolygonArea({
                body: actor ? actor.body : null,
                points: this.getPoints(),
                pos: Algebra_7.Vector.Zero.clone()
            });
        };
        /**
         * Determines whether a ray intersects with a bounding box
         */
        BoundingBox.prototype.rayCast = function (ray, farClipDistance) {
            if (farClipDistance === void 0) { farClipDistance = Infinity; }
            // algorithm from https://tavianator.com/fast-branchless-raybounding-box-intersections/ 
            var tmin = -Infinity;
            var tmax = +Infinity;
            var xinv = ray.dir.x === 0 ? Number.MAX_VALUE : (1 / ray.dir.x);
            var yinv = ray.dir.y === 0 ? Number.MAX_VALUE : (1 / ray.dir.y);
            var tx1 = (this.left - ray.pos.x) * xinv;
            var tx2 = (this.right - ray.pos.x) * xinv;
            tmin = Math.min(tx1, tx2);
            tmax = Math.max(tx1, tx2);
            var ty1 = (this.top - ray.pos.y) * yinv;
            var ty2 = (this.bottom - ray.pos.y) * yinv;
            tmin = Math.max(tmin, Math.min(ty1, ty2));
            tmax = Math.min(tmax, Math.max(ty1, ty2));
            return tmax >= Math.max(0, tmin) && tmin < farClipDistance;
        };
        BoundingBox.prototype.rayCastTime = function (ray, farClipDistance) {
            if (farClipDistance === void 0) { farClipDistance = Infinity; }
            // algorithm from https://tavianator.com/fast-branchless-raybounding-box-intersections/ 
            var tmin = -Infinity;
            var tmax = +Infinity;
            var xinv = ray.dir.x === 0 ? Number.MAX_VALUE : (1 / ray.dir.x);
            var yinv = ray.dir.y === 0 ? Number.MAX_VALUE : (1 / ray.dir.y);
            var tx1 = (this.left - ray.pos.x) * xinv;
            var tx2 = (this.right - ray.pos.x) * xinv;
            tmin = Math.min(tx1, tx2);
            tmax = Math.max(tx1, tx2);
            var ty1 = (this.top - ray.pos.y) * yinv;
            var ty2 = (this.bottom - ray.pos.y) * yinv;
            tmin = Math.max(tmin, Math.min(ty1, ty2));
            tmax = Math.min(tmax, Math.max(ty1, ty2));
            if (tmax >= Math.max(0, tmin) && tmin < farClipDistance) {
                return tmin;
            }
            return -1;
        };
        BoundingBox.prototype.contains = function (val) {
            if (val instanceof Algebra_7.Vector) {
                return (this.left <= val.x && this.top <= val.y && this.bottom >= val.y && this.right >= val.x);
            }
            else if (val instanceof BoundingBox) {
                if (this.left < val.left &&
                    this.top < val.top &&
                    val.bottom < this.bottom &&
                    val.right < this.right) {
                    return true;
                }
                return false;
            }
            return false;
        };
        /**
         * Combines this bounding box and another together returning a new bounding box
         * @param other  The bounding box to combine
         */
        BoundingBox.prototype.combine = function (other) {
            var compositeBB = new BoundingBox(Math.min(this.left, other.left), Math.min(this.top, other.top), Math.max(this.right, other.right), Math.max(this.bottom, other.bottom));
            return compositeBB;
        };
        /**
         * Test wether this bounding box collides with another returning,
         * the intersection vector that can be used to resolve the collision. If there
         * is no collision null is returned.
         * @param collidable  Other collidable to test
         */
        BoundingBox.prototype.collides = function (collidable) {
            if (collidable instanceof BoundingBox) {
                var other = collidable;
                var totalBoundingBox = this.combine(other);
                // If the total bounding box is less than the sum of the 2 bounds then there is collision
                if (totalBoundingBox.getWidth() < other.getWidth() + this.getWidth() &&
                    totalBoundingBox.getHeight() < other.getHeight() + this.getHeight()) {
                    // collision
                    var overlapX = 0;
                    if (this.right >= other.left && this.right <= other.right) {
                        overlapX = other.left - this.right;
                    }
                    else {
                        overlapX = other.right - this.left;
                    }
                    var overlapY = 0;
                    if (this.top <= other.bottom && this.top >= other.top) {
                        overlapY = other.bottom - this.top;
                    }
                    else {
                        overlapY = other.top - this.bottom;
                    }
                    if (Math.abs(overlapX) < Math.abs(overlapY)) {
                        return new Algebra_7.Vector(overlapX, 0);
                    }
                    else {
                        return new Algebra_7.Vector(0, overlapY);
                    }
                }
                else {
                    return null;
                }
            }
            return null;
        };
        /* istanbul ignore next */
        BoundingBox.prototype.debugDraw = function (ctx, color) {
            if (color === void 0) { color = Color_3.Color.Yellow; }
            ctx.strokeStyle = color.toString();
            ctx.strokeRect(this.left, this.top, this.getWidth(), this.getHeight());
        };
        return BoundingBox;
    }());
    exports.BoundingBox = BoundingBox;
});
define("Collision/EdgeArea", ["require", "exports", "Collision/BoundingBox", "Collision/CollisionJumpTable", "Collision/CircleArea", "Collision/PolygonArea", "Algebra", "Physics", "Drawing/Color"], function (require, exports, BoundingBox_3, CollisionJumpTable_3, CircleArea_2, PolygonArea_4, Algebra_8, Physics_4, Color_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var EdgeArea = (function () {
        function EdgeArea(options) {
            this.begin = options.begin || Algebra_8.Vector.Zero.clone();
            this.end = options.end || Algebra_8.Vector.Zero.clone();
            this.body = options.body || null;
            this.pos = this.getCenter();
        }
        /**
         * Get the center of the collision area in world coordinates
         */
        EdgeArea.prototype.getCenter = function () {
            var pos = this.begin.average(this.end).add(this._getBodyPos());
            return pos;
        };
        EdgeArea.prototype._getBodyPos = function () {
            var bodyPos = Algebra_8.Vector.Zero.clone();
            if (this.body.pos) {
                bodyPos = this.body.pos;
            }
            return bodyPos;
        };
        EdgeArea.prototype._getTransformedBegin = function () {
            var angle = this.body ? this.body.rotation : 0;
            return this.begin.rotate(angle).add(this._getBodyPos());
        };
        EdgeArea.prototype._getTransformedEnd = function () {
            var angle = this.body ? this.body.rotation : 0;
            return this.end.rotate(angle).add(this._getBodyPos());
        };
        /**
         * Returns the slope of the line in the form of a vector
         */
        EdgeArea.prototype.getSlope = function () {
            var begin = this._getTransformedBegin();
            var end = this._getTransformedEnd();
            var distance = begin.distance(end);
            return end.sub(begin).scale(1 / distance);
        };
        /**
         * Returns the length of the line segment in pixels
         */
        EdgeArea.prototype.getLength = function () {
            var begin = this._getTransformedBegin();
            var end = this._getTransformedEnd();
            var distance = begin.distance(end);
            return distance;
        };
        /**
         * Tests if a point is contained in this collision area
         */
        EdgeArea.prototype.contains = function () {
            return false;
        };
        /**
         * @inheritdoc
         */
        EdgeArea.prototype.rayCast = function (ray, max) {
            if (max === void 0) { max = Infinity; }
            var numerator = this._getTransformedBegin().sub(ray.pos);
            // Test is line and ray are parallel and non intersecting
            if (ray.dir.cross(this.getSlope()) === 0 && numerator.cross(ray.dir) !== 0) {
                return null;
            }
            // Lines are parallel
            var divisor = (ray.dir.cross(this.getSlope()));
            if (divisor === 0) {
                return null;
            }
            var t = numerator.cross(this.getSlope()) / divisor;
            if (t >= 0 && t <= max) {
                var u = (numerator.cross(ray.dir) / divisor) / this.getLength();
                if (u >= 0 && u <= 1) {
                    return ray.getPoint(t);
                }
            }
            return null;
        };
        /**
         * @inheritdoc
         */
        EdgeArea.prototype.collide = function (area) {
            if (area instanceof CircleArea_2.CircleArea) {
                return CollisionJumpTable_3.CollisionJumpTable.CollideCircleEdge(area, this);
            }
            else if (area instanceof PolygonArea_4.PolygonArea) {
                return CollisionJumpTable_3.CollisionJumpTable.CollidePolygonEdge(area, this);
            }
            else if (area instanceof EdgeArea) {
                return CollisionJumpTable_3.CollisionJumpTable.CollideEdgeEdge();
            }
            else {
                throw new Error("Edge could not collide with unknown ICollisionArea " + typeof area);
            }
        };
        /**
         * Find the point on the shape furthest in the direction specified
         */
        EdgeArea.prototype.getFurthestPoint = function (direction) {
            var transformedBegin = this._getTransformedBegin();
            var transformedEnd = this._getTransformedEnd();
            if (direction.dot(transformedBegin) > 0) {
                return transformedBegin;
            }
            else {
                return transformedEnd;
            }
        };
        /**
         * Get the axis aligned bounding box for the circle area
         */
        EdgeArea.prototype.getBounds = function () {
            var transformedBegin = this._getTransformedBegin();
            var transformedEnd = this._getTransformedEnd();
            return new BoundingBox_3.BoundingBox(Math.min(transformedBegin.x, transformedEnd.x), Math.min(transformedBegin.y, transformedEnd.y), Math.max(transformedBegin.x, transformedEnd.x), Math.max(transformedBegin.y, transformedEnd.y));
        };
        /**
         * Get the axis associated with the edge
         */
        EdgeArea.prototype.getAxes = function () {
            var e = this._getTransformedEnd().sub(this._getTransformedBegin());
            var edgeNormal = e.normal();
            var axes = [];
            axes.push(edgeNormal);
            axes.push(edgeNormal.negate());
            axes.push(edgeNormal.normal());
            axes.push(edgeNormal.normal().negate());
            return axes;
        };
        /**
         * Get the moment of inertia for an edge
         * https://en.wikipedia.org/wiki/List_of_moments_of_inertia
         */
        EdgeArea.prototype.getMomentOfInertia = function () {
            var mass = this.body ? this.body.mass : Physics_4.Physics.defaultMass;
            var length = this.end.sub(this.begin).distance() / 2;
            return mass * length * length;
        };
        /**
         * @inheritdoc
         */
        EdgeArea.prototype.recalc = function () {
            // edges don't have any cached data
        };
        /**
         * Project the edge along a specified axis
         */
        EdgeArea.prototype.project = function (axis) {
            var scalars = [];
            var points = [this._getTransformedBegin(), this._getTransformedEnd()];
            var len = points.length;
            for (var i = 0; i < len; i++) {
                scalars.push(points[i].dot(axis));
            }
            return new Algebra_8.Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));
        };
        /* istanbul ignore next */
        EdgeArea.prototype.debugDraw = function (ctx, color) {
            if (color === void 0) { color = Color_4.Color.Red.clone(); }
            ctx.strokeStyle = color.toString();
            ctx.beginPath();
            ctx.moveTo(this.begin.x, this.begin.y);
            ctx.lineTo(this.end.x, this.end.y);
            ctx.closePath();
            ctx.stroke();
        };
        return EdgeArea;
    }());
    exports.EdgeArea = EdgeArea;
});
define("Util/DrawUtil", ["require", "exports", "Drawing/Color"], function (require, exports, Color_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Draw a line on canvas context
     *
     * @param ctx The canvas context
     * @param color The color of the line
     * @param x1 The start x coordinate
     * @param y1 The start y coordinate
     * @param x2 The ending x coordinate
     * @param y2 The ending y coordinate
     * @param thickness The line thickness
     * @param cap The [[LineCapStyle]] (butt, round, or square)
     */
    /* istanbul ignore next */
    function line(ctx, color, x1, y1, x2, y2, thickness, cap) {
        if (color === void 0) { color = Color_5.Color.Red.clone(); }
        if (thickness === void 0) { thickness = 1; }
        if (cap === void 0) { cap = 'butt'; }
        ctx.beginPath();
        ctx.lineWidth = thickness;
        ctx.lineCap = cap;
        ctx.strokeStyle = color.toString();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.closePath();
        ctx.stroke();
    }
    exports.line = line;
    /**
     * Draw the vector as a point onto the canvas.
     */
    /* istanbul ignore next */
    function point(ctx, color, point) {
        if (color === void 0) { color = Color_5.Color.Red.clone(); }
        ctx.beginPath();
        ctx.strokeStyle = color.toString();
        ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
        ctx.closePath();
        ctx.stroke();
    }
    exports.point = point;
    /**
     * Draw the vector as a line onto the canvas starting a origin point.
     */
    /* istanbul ignore next */
    function vector(ctx, color, origin, vector, scale) {
        if (scale === void 0) { scale = 1.0; }
        var c = color ? color.toString() : 'blue';
        var v = vector.scale(scale);
        ctx.beginPath();
        ctx.strokeStyle = c;
        ctx.moveTo(origin.x, origin.y);
        ctx.lineTo(origin.x + v.x, origin.y + v.y);
        ctx.closePath();
        ctx.stroke();
    }
    exports.vector = vector;
    /**
     * Draw a round rectangle on a canvas context
     *
     * @param ctx The canvas context
     * @param x The top-left x coordinate
     * @param y The top-left y coordinate
     * @param width The width of the rectangle
     * @param height The height of the rectangle
     * @param radius The border radius of the rectangle
     * @param fill The [[Color]] to fill rectangle with
     * @param stroke The [[Color]] to stroke rectangle with
     */
    function roundRect(ctx, x, y, width, height, radius, stroke, fill) {
        if (radius === void 0) { radius = 5; }
        if (stroke === void 0) { stroke = Color_5.Color.White; }
        if (fill === void 0) { fill = null; }
        var br;
        if (typeof radius === 'number') {
            br = { tl: radius, tr: radius, br: radius, bl: radius };
        }
        else {
            var defaultRadius = { tl: 0, tr: 0, br: 0, bl: 0 };
            for (var prop in defaultRadius) {
                if (defaultRadius.hasOwnProperty(prop)) {
                    var side = prop;
                    br[side] = radius[side] || defaultRadius[side];
                }
            }
        }
        ctx.beginPath();
        ctx.moveTo(x + br.tl, y);
        ctx.lineTo(x + width - br.tr, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + br.tr);
        ctx.lineTo(x + width, y + height - br.br);
        ctx.quadraticCurveTo(x + width, y + height, x + width - br.br, y + height);
        ctx.lineTo(x + br.bl, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - br.bl);
        ctx.lineTo(x, y + br.tl);
        ctx.quadraticCurveTo(x, y, x + br.tl, y);
        ctx.closePath();
        if (fill) {
            ctx.fillStyle = fill.toString();
            ctx.fill();
        }
        if (stroke) {
            ctx.strokeStyle = stroke.toString();
            ctx.stroke();
        }
    }
    exports.roundRect = roundRect;
    function circle(ctx, x, y, radius, stroke, fill) {
        if (stroke === void 0) { stroke = Color_5.Color.White; }
        if (fill === void 0) { fill = null; }
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.closePath();
        if (fill) {
            ctx.fillStyle = fill.toString();
            ctx.fill();
        }
        if (stroke) {
            ctx.strokeStyle = stroke.toString();
            ctx.stroke();
        }
    }
    exports.circle = circle;
});
define("Collision/Body", ["require", "exports", "Physics", "Collision/EdgeArea", "Collision/CircleArea", "Collision/PolygonArea", "Collision/Pair", "Algebra", "Drawing/Color", "Util/DrawUtil"], function (require, exports, Physics_5, EdgeArea_3, CircleArea_3, PolygonArea_5, Pair_1, Algebra_9, Color_6, DrawUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Body = (function () {
        /**
         * Constructs a new physics body associated with an actor
         */
        function Body(actor) {
            this.actor = actor;
            /**
             * [[ICollisionArea|Collision area]] of this physics body, defines the shape for rigid body collision
             */
            this.collisionArea = null;
            /**
             * The (x, y) position of the actor this will be in the middle of the actor if the
             * [[Actor.anchor]] is set to (0.5, 0.5) which is default.
             * If you want the (x, y) position to be the top left of the actor specify an anchor of (0, 0).
             */
            this.pos = new Algebra_9.Vector(0, 0);
            /**
             * The position of the actor last frame (x, y) in pixels
             */
            this.oldPos = new Algebra_9.Vector(0, 0);
            /**
             * The current velocity vector (vx, vy) of the actor in pixels/second
             */
            this.vel = new Algebra_9.Vector(0, 0);
            /**
             * The velocity of the actor last frame (vx, vy) in pixels/second
             */
            this.oldVel = new Algebra_9.Vector(0, 0);
            /**
             * The curret acceleration vector (ax, ay) of the actor in pixels/second/second. An acceleration pointing down such as (0, 100) may
             * be useful to simulate a gravitational effect.
             */
            this.acc = new Algebra_9.Vector(0, 0);
            /**
             * The current torque applied to the actor
             */
            this.torque = 0;
            /**
             * The current mass of the actor, mass can be thought of as the resistance to acceleration.
             */
            this.mass = 1.0;
            /**
             * The current moment of inertia, moi can be thought of as the resistance to rotation.
             */
            this.moi = 1000;
            /**
             * The current "motion" of the actor, used to calculated sleep in the physics simulation
             */
            this.motion = 10;
            /**
             * The coefficient of friction on this actor
             */
            this.friction = .99;
            /**
             * The coefficient of restitution of this actor, represents the amount of energy preserved after collision
             */
            this.restitution = .2;
            /**
             * The rotation of the actor in radians
             */
            this.rotation = 0; // radians
            /**
             * The rotational velocity of the actor in radians/second
             */
            this.rx = 0; //radians/sec
            this._totalMtv = Algebra_9.Vector.Zero.clone();
        }
        /**
         * Add minimum translation vectors accumulated during the current frame to resolve collisions.
         */
        Body.prototype.addMtv = function (mtv) {
            this._totalMtv.addEqual(mtv);
        };
        /**
         * Applies the accumulated translation vectors to the actors position
         */
        Body.prototype.applyMtv = function () {
            this.pos.addEqual(this._totalMtv);
            this._totalMtv.setTo(0, 0);
        };
        /**
         * Returns the body's [[BoundingBox]] calculated for this instant in world space.
         */
        Body.prototype.getBounds = function () {
            if (Physics_5.Physics.collisionResolutionStrategy === Physics_5.CollisionResolutionStrategy.Box) {
                return this.actor.getBounds();
            }
            else {
                return this.collisionArea.getBounds();
            }
        };
        /**
         * Returns the actor's [[BoundingBox]] relative to the actors position.
         */
        Body.prototype.getRelativeBounds = function () {
            if (Physics_5.Physics.collisionResolutionStrategy === Physics_5.CollisionResolutionStrategy.Box) {
                return this.actor.getRelativeBounds();
            }
            else {
                return this.actor.getRelativeBounds();
            }
        };
        /**
         * Updates the collision area geometry and internal caches
         */
        Body.prototype.update = function () {
            if (this.collisionArea) {
                this.collisionArea.recalc();
            }
        };
        /**
         * Sets up a box collision area based on the current bounds of the associated actor of this physics body.
         *
         * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
         */
        Body.prototype.useBoxCollision = function (center) {
            if (center === void 0) { center = Algebra_9.Vector.Zero.clone(); }
            this.collisionArea = new PolygonArea_5.PolygonArea({
                body: this,
                points: this.actor.getRelativeBounds().getPoints(),
                pos: center // position relative to actor
            });
            // in case of a nan moi, coalesce to a safe default
            this.moi = this.collisionArea.getMomentOfInertia() || this.moi;
        };
        /**
         * Sets up a polygon collision area based on a list of of points relative to the anchor of the associated actor of this physics body.
         *
         * Only [convex polygon](https://en.wikipedia.org/wiki/Convex_polygon) definitions are supported.
         *
         * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
         */
        Body.prototype.usePolygonCollision = function (points, center) {
            if (center === void 0) { center = Algebra_9.Vector.Zero.clone(); }
            this.collisionArea = new PolygonArea_5.PolygonArea({
                body: this,
                points: points,
                pos: center // position relative to actor
            });
            // in case of a nan moi, collesce to a safe default
            this.moi = this.collisionArea.getMomentOfInertia() || this.moi;
        };
        /**
         * Sets up a [[CircleArea|circle collision area]] with a specified radius in pixels.
         *
         * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
         */
        Body.prototype.useCircleCollision = function (radius, center) {
            if (center === void 0) { center = Algebra_9.Vector.Zero.clone(); }
            if (!radius) {
                radius = this.actor.getWidth() / 2;
            }
            this.collisionArea = new CircleArea_3.CircleArea({
                body: this,
                radius: radius,
                pos: center
            });
            this.moi = this.collisionArea.getMomentOfInertia() || this.moi;
        };
        /**
         * Sets up an [[EdgeArea|edge collision]] with a start point and an end point relative to the anchor of the associated actor
         * of this physics body.
         *
         * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
         */
        Body.prototype.useEdgeCollision = function (begin, end) {
            this.collisionArea = new EdgeArea_3.EdgeArea({
                begin: begin,
                end: end,
                body: this
            });
            this.moi = this.collisionArea.getMomentOfInertia() || this.moi;
        };
        /* istanbul ignore next */
        Body.prototype.debugDraw = function (ctx) {
            // Draw motion vectors
            if (Physics_5.Physics.showMotionVectors) {
                DrawUtil.vector(ctx, Color_6.Color.Yellow, this.pos, (this.acc.add(Physics_5.Physics.acc)));
                DrawUtil.vector(ctx, Color_6.Color.Red, this.pos, (this.vel));
                DrawUtil.point(ctx, Color_6.Color.Red, this.pos);
            }
            if (Physics_5.Physics.showBounds) {
                this.getBounds().debugDraw(ctx, Color_6.Color.Yellow);
            }
            if (Physics_5.Physics.showArea) {
                this.collisionArea.debugDraw(ctx, Color_6.Color.Green);
            }
        };
        /**
         * Returns a boolean indicating whether this body collided with
         * or was in stationary contact with
         * the body of the other [[Actor]]
         */
        Body.prototype.touching = function (other) {
            var pair = new Pair_1.Pair(this, other.body);
            pair.collide();
            if (pair.collision) {
                return true;
            }
            return false;
        };
        return Body;
    }());
    exports.Body = Body;
});
define("Collision/Pair", ["require", "exports", "Physics", "Drawing/Color", "Actor", "Util/DrawUtil"], function (require, exports, Physics_6, Color_7, Actor_2, DrawUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Models a potential collision between 2 bodies
     */
    var Pair = (function () {
        function Pair(bodyA, bodyB) {
            this.bodyA = bodyA;
            this.bodyB = bodyB;
            this.id = null;
            this.collision = null;
            this.id = Pair.calculatePairHash(bodyA, bodyB);
        }
        Object.defineProperty(Pair.prototype, "canCollide", {
            /**
             * Returns whether or not it is possible for the pairs to collide
             */
            get: function () {
                var actorA = this.bodyA.actor;
                var actorB = this.bodyB.actor;
                // if both are fixed short circuit
                if (actorA.collisionType === Actor_2.CollisionType.Fixed && actorB.collisionType === Actor_2.CollisionType.Fixed) {
                    return false;
                }
                // if the other is prevent collision or is dead short circuit
                if (actorB.collisionType === Actor_2.CollisionType.PreventCollision || actorB.isKilled()) {
                    return false;
                }
                return true;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Runs the collison intersection logic on the members of this pair
         */
        Pair.prototype.collide = function () {
            this.collision = this.bodyA.collisionArea.collide(this.bodyB.collisionArea);
        };
        /**
         * Resovles the collision body position and velocity if a collision occured
         */
        Pair.prototype.resolve = function (strategy) {
            if (this.collision) {
                this.collision.resolve(strategy);
            }
        };
        /**
         * Calculates the unique pair hash id for this collision pair
         */
        Pair.calculatePairHash = function (bodyA, bodyB) {
            if (bodyA.actor.id < bodyB.actor.id) {
                return "#" + bodyA.actor.id + "+" + bodyB.actor.id;
            }
            else {
                return "#" + bodyB.actor.id + "+" + bodyA.actor.id;
            }
        };
        /* istanbul ignore next */
        Pair.prototype.debugDraw = function (ctx) {
            if (this.collision) {
                if (Physics_6.Physics.showContacts) {
                    DrawUtil.point(ctx, Color_7.Color.Red, this.collision.point);
                }
                if (Physics_6.Physics.showCollisionNormals) {
                    DrawUtil.vector(ctx, Color_7.Color.Cyan, this.collision.point, this.collision.normal, 30);
                }
            }
        };
        return Pair;
    }());
    exports.Pair = Pair;
});
define("Debug", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Debug statistics and flags for Excalibur. If polling these values, it would be
     * best to do so on the `postupdate` event for [[Engine]], after all values have been
     * updated during a frame.
     */
    var Debug = (function () {
        function Debug() {
            /**
             * Performance statistics
             */
            this.stats = {
                /**
                 * Current frame statistics. Engine reuses this instance, use [[FrameStats.clone]] to copy frame stats.
                 * Best accessed on [[postframe]] event. See [[IFrameStats]]
                 */
                currFrame: new FrameStats(),
                /**
                 * Previous frame statistics. Engine reuses this instance, use [[FrameStats.clone]] to copy frame stats.
                 * Best accessed on [[preframe]] event. Best inspected on engine event `preframe`. See [[IFrameStats]]
                 */
                prevFrame: new FrameStats()
            };
        }
        return Debug;
    }());
    exports.Debug = Debug;
    /**
     * Implementation of a frame's stats. Meant to have values copied via [[FrameStats.reset]], avoid
     * creating instances of this every frame.
     */
    var FrameStats = (function () {
        function FrameStats() {
            this._id = 0;
            this._delta = 0;
            this._fps = 0;
            this._actorStats = {
                alive: 0,
                killed: 0,
                ui: 0,
                get remaining() {
                    return this.alive - this.killed;
                },
                get total() {
                    return this.remaining + this.ui;
                }
            };
            this._durationStats = {
                update: 0,
                draw: 0,
                get total() {
                    return this.update + this.draw;
                }
            };
            this._physicsStats = new PhysicsStats();
        }
        /**
         * Zero out values or clone other IFrameStat stats. Allows instance reuse.
         *
         * @param [otherStats] Optional stats to clone
         */
        FrameStats.prototype.reset = function (otherStats) {
            if (otherStats) {
                this.id = otherStats.id;
                this.delta = otherStats.delta;
                this.fps = otherStats.fps;
                this.actors.alive = otherStats.actors.alive;
                this.actors.killed = otherStats.actors.killed;
                this.actors.ui = otherStats.actors.ui;
                this.duration.update = otherStats.duration.update;
                this.duration.draw = otherStats.duration.draw;
                this._physicsStats.reset(otherStats.physics);
            }
            else {
                this.id = this.delta = this.fps = 0;
                this.actors.alive = this.actors.killed = this.actors.ui = 0;
                this.duration.update = this.duration.draw = 0;
                this._physicsStats.reset();
            }
        };
        /**
         * Provides a clone of this instance.
         */
        FrameStats.prototype.clone = function () {
            var fs = new FrameStats();
            fs.reset(this);
            return fs;
        };
        Object.defineProperty(FrameStats.prototype, "id", {
            /**
             * Gets the frame's id
             */
            get: function () {
                return this._id;
            },
            /**
             * Sets the frame's id
             */
            set: function (value) {
                this._id = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FrameStats.prototype, "delta", {
            /**
             * Gets the frame's delta (time since last frame)
             */
            get: function () {
                return this._delta;
            },
            /**
             * Sets the frame's delta (time since last frame). Internal use only.
             * @internal
             */
            set: function (value) {
                this._delta = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FrameStats.prototype, "fps", {
            /**
             * Gets the frame's frames-per-second (FPS)
             */
            get: function () {
                return this._fps;
            },
            /**
             * Sets the frame's frames-per-second (FPS). Internal use only.
             * @internal
             */
            set: function (value) {
                this._fps = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FrameStats.prototype, "actors", {
            /**
             * Gets the frame's actor statistics
             */
            get: function () {
                return this._actorStats;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FrameStats.prototype, "duration", {
            /**
             * Gets the frame's duration statistics
             */
            get: function () {
                return this._durationStats;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FrameStats.prototype, "physics", {
            /**
             * Gets the frame's physics statistics
             */
            get: function () {
                return this._physicsStats;
            },
            enumerable: true,
            configurable: true
        });
        return FrameStats;
    }());
    exports.FrameStats = FrameStats;
    var PhysicsStats = (function () {
        function PhysicsStats() {
            this._pairs = 0;
            this._collisions = 0;
            this._collidersHash = {};
            this._fastBodies = 0;
            this._fastBodyCollisions = 0;
            this._broadphase = 0;
            this._narrowphase = 0;
        }
        /**
         * Zero out values or clone other IPhysicsStats stats. Allows instance reuse.
         *
         * @param [otherStats] Optional stats to clone
         */
        PhysicsStats.prototype.reset = function (otherStats) {
            if (otherStats) {
                this.pairs = otherStats.pairs;
                this.collisions = otherStats.collisions;
                this.collidersHash = otherStats.collidersHash;
                this.fastBodies = otherStats.fastBodies;
                this.fastBodyCollisions = otherStats.fastBodyCollisions;
                this.broadphase = otherStats.broadphase;
                this.narrowphase = otherStats.narrowphase;
            }
            else {
                this.pairs = this.collisions = this.fastBodies = 0;
                this.fastBodyCollisions = this.broadphase = this.narrowphase = 0;
                this.collidersHash = {};
            }
        };
        /**
         * Provides a clone of this instance.
         */
        PhysicsStats.prototype.clone = function () {
            var ps = new PhysicsStats();
            ps.reset(this);
            return ps;
        };
        Object.defineProperty(PhysicsStats.prototype, "pairs", {
            get: function () {
                return this._pairs;
            },
            set: function (value) {
                this._pairs = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PhysicsStats.prototype, "collisions", {
            get: function () {
                return this._collisions;
            },
            set: function (value) {
                this._collisions = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PhysicsStats.prototype, "collidersHash", {
            get: function () {
                return this._collidersHash;
            },
            set: function (colliders) {
                this._collidersHash = colliders;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PhysicsStats.prototype, "fastBodies", {
            get: function () {
                return this._fastBodies;
            },
            set: function (value) {
                this._fastBodies = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PhysicsStats.prototype, "fastBodyCollisions", {
            get: function () {
                return this._fastBodyCollisions;
            },
            set: function (value) {
                this._fastBodyCollisions = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PhysicsStats.prototype, "broadphase", {
            get: function () {
                return this._broadphase;
            },
            set: function (value) {
                this._broadphase = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PhysicsStats.prototype, "narrowphase", {
            get: function () {
                return this._narrowphase;
            },
            set: function (value) {
                this._narrowphase = value;
            },
            enumerable: true,
            configurable: true
        });
        return PhysicsStats;
    }());
    exports.PhysicsStats = PhysicsStats;
});
define("Interfaces/IEvented", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("EventDispatcher", ["require", "exports", "Events"], function (require, exports, Events_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Excalibur's internal event dispatcher implementation.
     * Callbacks are fired immediately after an event is published.
     * Typically you will use [[Class.eventDispatcher]] since most classes in
     * Excalibur inherit from [[Class]]. You will rarely create an `EventDispatcher`
     * yourself.
     *
     * [[include:Events.md]]
     */
    var EventDispatcher = (function () {
        /**
         * @param target  The object that will be the recipient of events from this event dispatcher
         */
        function EventDispatcher(target) {
            this._handlers = {};
            this._wiredEventDispatchers = [];
            this._target = target;
        }
        /**
         * Emits an event for target
         * @param eventName  The name of the event to publish
         * @param event      Optionally pass an event data object to the handler
         */
        EventDispatcher.prototype.emit = function (eventName, event) {
            if (!eventName) {
                // key not mapped
                return;
            }
            eventName = eventName.toLowerCase();
            var target = this._target;
            if (!event) {
                event = new Events_2.GameEvent();
            }
            event.target = target;
            var i, len;
            if (this._handlers[eventName]) {
                i = 0;
                len = this._handlers[eventName].length;
                for (i; i < len; i++) {
                    this._handlers[eventName][i].call(target, event);
                }
            }
            i = 0;
            len = this._wiredEventDispatchers.length;
            for (i; i < len; i++) {
                this._wiredEventDispatchers[i].emit(eventName, event);
            }
        };
        /**
         * Subscribe an event handler to a particular event name, multiple handlers per event name are allowed.
         * @param eventName  The name of the event to subscribe to
         * @param handler    The handler callback to fire on this event
         */
        EventDispatcher.prototype.on = function (eventName, handler) {
            eventName = eventName.toLowerCase();
            if (!this._handlers[eventName]) {
                this._handlers[eventName] = [];
            }
            this._handlers[eventName].push(handler);
            // meta event handlers
            if (eventName !== 'unsubscribe' && eventName !== 'subscribe') {
                this.emit('subscribe', new Events_2.SubscribeEvent(eventName, handler));
            }
        };
        /**
         * Unsubscribe an event handler(s) from an event. If a specific handler
         * is specified for an event, only that handler will be unsubscribed.
         * Otherwise all handlers will be unsubscribed for that event.
         *
         * @param eventName  The name of the event to unsubscribe
         * @param handler    Optionally the specific handler to unsubscribe
         *
         */
        EventDispatcher.prototype.off = function (eventName, handler) {
            eventName = eventName.toLowerCase();
            var eventHandlers = this._handlers[eventName];
            if (eventHandlers) {
                // if no explicit handler is give with the event name clear all handlers
                if (!handler) {
                    this._handlers[eventName].length = 0;
                }
                else {
                    var index = eventHandlers.indexOf(handler);
                    this._handlers[eventName].splice(index, 1);
                }
            }
            // meta event handlers
            if (eventName !== 'unsubscribe' && eventName !== 'subscribe') {
                this.emit('unsubscribe', new Events_2.UnsubscribeEvent(eventName, handler));
            }
        };
        /**
         * Once listens to an event one time, then unsubscribes from that event
         *
         * @param eventName The name of the event to subscribe to once
         * @param handler   The handler of the event that will be auto unsubscribed
         */
        EventDispatcher.prototype.once = function (eventName, handler) {
            var _this = this;
            var metaHandler = function (event) {
                var ev = event || new Events_2.GameEvent();
                ev.target = ev.target || _this._target;
                _this.off(eventName, handler);
                handler.call(ev.target, ev);
            };
            this.on(eventName, metaHandler);
        };
        /**
         * Wires this event dispatcher to also recieve events from another
         */
        EventDispatcher.prototype.wire = function (eventDispatcher) {
            eventDispatcher._wiredEventDispatchers.push(this);
        };
        /**
         * Unwires this event dispatcher from another
         */
        EventDispatcher.prototype.unwire = function (eventDispatcher) {
            var index = eventDispatcher._wiredEventDispatchers.indexOf(this);
            if (index > -1) {
                eventDispatcher._wiredEventDispatchers.splice(index, 1);
            }
        };
        return EventDispatcher;
    }());
    exports.EventDispatcher = EventDispatcher;
});
define("Actions/ActionContext", ["require", "exports", "Actions/Action", "Promises", "Util/EasingFunctions"], function (require, exports, Actions, Promises_2, EasingFunctions_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The fluent Action API allows you to perform "actions" on
     * [[Actor|Actors]] such as following, moving, rotating, and
     * more. You can implement your own actions by implementing
     * the [[IAction]] interface.
     *
     * [[include:Actions.md]]
     */
    var ActionContext = (function () {
        function ActionContext() {
            this._actors = [];
            this._queues = [];
            if (arguments !== null) {
                this._actors = Array.prototype.slice.call(arguments, 0);
                this._queues = this._actors.map(function (a) {
                    return a.actionQueue;
                });
            }
        }
        /**
         * Clears all queued actions from the Actor
         */
        ActionContext.prototype.clearActions = function () {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].clearActions();
            }
        };
        ActionContext.prototype.addActorToContext = function (actor) {
            this._actors.push(actor);
            // if we run into problems replace the line below with:
            this._queues.push(actor.actionQueue);
        };
        ActionContext.prototype.removeActorFromContext = function (actor) {
            var index = this._actors.indexOf(actor);
            if (index > -1) {
                this._actors.splice(index, 1);
                this._queues.splice(index, 1);
            }
        };
        /**
         * This method will move an actor to the specified `x` and `y` position over the
         * specified duration using a given [[EasingFunctions]] and return back the actor. This
         * method is part of the actor 'Action' fluent API allowing action chaining.
         * @param x         The x location to move the actor to
         * @param y         The y location to move the actor to
         * @param duration  The time it should take the actor to move to the new location in milliseconds
         * @param easingFcn Use [[EasingFunctions]] or a custom function to use to calculate position
         */
        ActionContext.prototype.easeTo = function (x, y, duration, easingFcn) {
            if (easingFcn === void 0) { easingFcn = EasingFunctions_2.EasingFunctions.Linear; }
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.EaseTo(this._actors[i], x, y, duration, easingFcn));
            }
            return this;
        };
        /**
         * This method will move an actor to the specified x and y position at the
         * speed specified (in pixels per second) and return back the actor. This
         * method is part of the actor 'Action' fluent API allowing action chaining.
         * @param x      The x location to move the actor to
         * @param y      The y location to move the actor to
         * @param speed  The speed in pixels per second to move
         */
        ActionContext.prototype.moveTo = function (x, y, speed) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.MoveTo(this._actors[i], x, y, speed));
            }
            return this;
        };
        /**
         * This method will move an actor to the specified x and y position by a
         * certain time (in milliseconds). This method is part of the actor
         * 'Action' fluent API allowing action chaining.
         * @param x     The x location to move the actor to
         * @param y     The y location to move the actor to
         * @param time  The time it should take the actor to move to the new location in milliseconds
         */
        ActionContext.prototype.moveBy = function (x, y, time) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.MoveBy(this._actors[i], x, y, time));
            }
            return this;
        };
        /**
         * This method will rotate an actor to the specified angle at the speed
         * specified (in radians per second) and return back the actor. This
         * method is part of the actor 'Action' fluent API allowing action chaining.
         * @param angleRadians  The angle to rotate to in radians
         * @param speed         The angular velocity of the rotation specified in radians per second
         * @param rotationType  The [[RotationType]] to use for this rotation
         */
        ActionContext.prototype.rotateTo = function (angleRadians, speed, rotationType) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.RotateTo(this._actors[i], angleRadians, speed, rotationType));
            }
            return this;
        };
        /**
         * This method will rotate an actor to the specified angle by a certain
         * time (in milliseconds) and return back the actor. This method is part
         * of the actor 'Action' fluent API allowing action chaining.
         * @param angleRadians  The angle to rotate to in radians
         * @param time          The time it should take the actor to complete the rotation in milliseconds
         * @param rotationType  The [[RotationType]] to use for this rotation
         */
        ActionContext.prototype.rotateBy = function (angleRadians, time, rotationType) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.RotateBy(this._actors[i], angleRadians, time, rotationType));
            }
            return this;
        };
        /**
         * This method will scale an actor to the specified size at the speed
         * specified (in magnitude increase per second) and return back the
         * actor. This method is part of the actor 'Action' fluent API allowing
         * action chaining.
         * @param sizeX   The scaling factor to apply on X axis
         * @param sizeY   The scaling factor to apply on Y axis
         * @param speedX  The speed of scaling specified in magnitude increase per second on X axis
         * @param speedY  The speed of scaling specified in magnitude increase per second on Y axis
         */
        ActionContext.prototype.scaleTo = function (sizeX, sizeY, speedX, speedY) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.ScaleTo(this._actors[i], sizeX, sizeY, speedX, speedY));
            }
            return this;
        };
        /**
         * This method will scale an actor to the specified size by a certain time
         * (in milliseconds) and return back the actor. This method is part of the
         * actor 'Action' fluent API allowing action chaining.
         * @param sizeX   The scaling factor to apply on X axis
         * @param sizeY   The scaling factor to apply on Y axis
         * @param time    The time it should take to complete the scaling in milliseconds
         */
        ActionContext.prototype.scaleBy = function (sizeX, sizeY, time) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.ScaleBy(this._actors[i], sizeX, sizeY, time));
            }
            return this;
        };
        /**
         * This method will cause an actor to blink (become visible and not
         * visible). Optionally, you may specify the number of blinks. Specify the amount of time
         * the actor should be visible per blink, and the amount of time not visible.
         * This method is part of the actor 'Action' fluent API allowing action chaining.
         * @param timeVisible     The amount of time to stay visible per blink in milliseconds
         * @param timeNotVisible  The amount of time to stay not visible per blink in milliseconds
         * @param numBlinks       The number of times to blink
         */
        ActionContext.prototype.blink = function (timeVisible, timeNotVisible, numBlinks) {
            if (numBlinks === void 0) { numBlinks = 1; }
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.Blink(this._actors[i], timeVisible, timeNotVisible, numBlinks));
            }
            return this;
        };
        /**
         * This method will cause an actor's opacity to change from its current value
         * to the provided value by a specified time (in milliseconds). This method is
         * part of the actor 'Action' fluent API allowing action chaining.
         * @param opacity  The ending opacity
         * @param time     The time it should take to fade the actor (in milliseconds)
         */
        ActionContext.prototype.fade = function (opacity, time) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.Fade(this._actors[i], opacity, time));
            }
            return this;
        };
        /**
         * This method will delay the next action from executing for a certain
         * amount of time (in milliseconds). This method is part of the actor
         * 'Action' fluent API allowing action chaining.
         * @param time  The amount of time to delay the next action in the queue from executing in milliseconds
         */
        ActionContext.prototype.delay = function (time) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.Delay(this._actors[i], time));
            }
            return this;
        };
        /**
         * This method will add an action to the queue that will remove the actor from the
         * scene once it has completed its previous actions. Any actions on the
         * action queue after this action will not be executed.
         */
        ActionContext.prototype.die = function () {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.Die(this._actors[i]));
            }
            return this;
        };
        /**
         * This method allows you to call an arbitrary method as the next action in the
         * action queue. This is useful if you want to execute code in after a specific
         * action, i.e An actor arrives at a destination after traversing a path
         */
        ActionContext.prototype.callMethod = function (method) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.CallMethod(this._actors[i], method));
            }
            return this;
        };
        /**
         * This method will cause the actor to repeat all of the previously
         * called actions a certain number of times. If the number of repeats
         * is not specified it will repeat forever. This method is part of
         * the actor 'Action' fluent API allowing action chaining
         * @param times  The number of times to repeat all the previous actions in the action queue. If nothing is specified the actions
         * will repeat forever
         */
        ActionContext.prototype.repeat = function (times) {
            if (!times) {
                this.repeatForever();
                return this;
            }
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.Repeat(this._actors[i], times, this._actors[i].actionQueue.getActions()));
            }
            return this;
        };
        /**
         * This method will cause the actor to repeat all of the previously
         * called actions forever. This method is part of the actor 'Action'
         * fluent API allowing action chaining.
         */
        ActionContext.prototype.repeatForever = function () {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.RepeatForever(this._actors[i], this._actors[i].actionQueue.getActions()));
            }
            return this;
        };
        /**
         * This method will cause the actor to follow another at a specified distance
         * @param actor           The actor to follow
         * @param followDistance  The distance to maintain when following, if not specified the actor will follow at the current distance.
         */
        ActionContext.prototype.follow = function (actor, followDistance) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                if (followDistance === undefined) {
                    this._queues[i].add(new Actions.Follow(this._actors[i], actor));
                }
                else {
                    this._queues[i].add(new Actions.Follow(this._actors[i], actor, followDistance));
                }
            }
            return this;
        };
        /**
         * This method will cause the actor to move towards another until they
         * collide "meet" at a specified speed.
         * @param actor  The actor to meet
         * @param speed  The speed in pixels per second to move, if not specified it will match the speed of the other actor
         */
        ActionContext.prototype.meet = function (actor, speed) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                if (speed === undefined) {
                    this._queues[i].add(new Actions.Meet(this._actors[i], actor));
                }
                else {
                    this._queues[i].add(new Actions.Meet(this._actors[i], actor, speed));
                }
            }
            return this;
        };
        /**
         * Returns a promise that resolves when the current action queue up to now
         * is finished.
         */
        ActionContext.prototype.asPromise = function () {
            var _this = this;
            var promises = this._queues.map(function (q, i) {
                var temp = new Promises_2.Promise();
                q.add(new Actions.CallMethod(_this._actors[i], function () {
                    temp.resolve();
                }));
                return temp;
            });
            return Promises_2.Promise.join.apply(this, promises);
        };
        return ActionContext;
    }());
    exports.ActionContext = ActionContext;
});
define("Util/Log", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Logging level that Excalibur will tag
     */
    var LogLevel;
    (function (LogLevel) {
        LogLevel[LogLevel["Debug"] = 0] = "Debug";
        LogLevel[LogLevel["Info"] = 1] = "Info";
        LogLevel[LogLevel["Warn"] = 2] = "Warn";
        LogLevel[LogLevel["Error"] = 3] = "Error";
        LogLevel[LogLevel["Fatal"] = 4] = "Fatal";
    })(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
    /**
     * Static singleton that represents the logging facility for Excalibur.
     * Excalibur comes built-in with a [[ConsoleAppender]] and [[ScreenAppender]].
     * Derive from [[IAppender]] to create your own logging appenders.
     *
     * [[include:Logger.md]]
     */
    var Logger = (function () {
        function Logger() {
            this._appenders = [];
            /**
             * Gets or sets the default logging level. Excalibur will only log
             * messages if equal to or above this level. Default: [[LogLevel.Info]]
             */
            this.defaultLevel = LogLevel.Info;
            if (Logger._instance) {
                throw new Error('Logger is a singleton');
            }
            Logger._instance = this;
            // Default console appender
            Logger._instance.addAppender(new ConsoleAppender());
            return Logger._instance;
        }
        /**
         * Gets the current static instance of Logger
         */
        Logger.getInstance = function () {
            if (Logger._instance == null) {
                Logger._instance = new Logger();
            }
            return Logger._instance;
        };
        /**
         * Adds a new [[IAppender]] to the list of appenders to write to
         */
        Logger.prototype.addAppender = function (appender) {
            this._appenders.push(appender);
        };
        /**
         * Clears all appenders from the logger
         */
        Logger.prototype.clearAppenders = function () {
            this._appenders.length = 0;
        };
        /**
         * Logs a message at a given LogLevel
         * @param level  The LogLevel`to log the message at
         * @param args   An array of arguments to write to an appender
         */
        Logger.prototype._log = function (level, args) {
            if (level == null) {
                level = this.defaultLevel;
            }
            var i = 0, len = this._appenders.length;
            for (i; i < len; i++) {
                if (level >= this.defaultLevel) {
                    this._appenders[i].log(level, args);
                }
            }
        };
        /**
         * Writes a log message at the [[LogLevel.Debug]] level
         * @param args  Accepts any number of arguments
         */
        Logger.prototype.debug = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            this._log(LogLevel.Debug, args);
        };
        /**
         * Writes a log message at the [[LogLevel.Info]] level
         * @param args  Accepts any number of arguments
         */
        Logger.prototype.info = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            this._log(LogLevel.Info, args);
        };
        /**
         * Writes a log message at the [[LogLevel.Warn]] level
         * @param args  Accepts any number of arguments
         */
        Logger.prototype.warn = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            this._log(LogLevel.Warn, args);
        };
        /**
         * Writes a log message at the [[LogLevel.Error]] level
         * @param args  Accepts any number of arguments
         */
        Logger.prototype.error = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            this._log(LogLevel.Error, args);
        };
        /**
         * Writes a log message at the [[LogLevel.Fatal]] level
         * @param args  Accepts any number of arguments
         */
        Logger.prototype.fatal = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            this._log(LogLevel.Fatal, args);
        };
        return Logger;
    }());
    Logger._instance = null;
    exports.Logger = Logger;
    /**
     * Console appender for browsers (i.e. `console.log`)
     */
    var ConsoleAppender = (function () {
        function ConsoleAppender() {
        }
        /**
         * Logs a message at the given [[LogLevel]]
         * @param level  Level to log at
         * @param args   Arguments to log
         */
        ConsoleAppender.prototype.log = function (level, args) {
            // Check for console support
            if (!console && !console.log && console.warn && console.error) {
                // todo maybe do something better than nothing
                return;
            }
            // Create a new console args array
            var consoleArgs = [];
            consoleArgs.unshift.apply(consoleArgs, args);
            consoleArgs.unshift('[' + LogLevel[level] + '] : ');
            if (level < LogLevel.Warn) {
                // Call .log for Debug/Info
                if (console.log.apply) {
                    // this is required on some older browsers that don't support apply on console.log :(
                    console.log.apply(console, consoleArgs);
                }
                else {
                    console.log(consoleArgs.join(' '));
                }
            }
            else if (level < LogLevel.Error) {
                // Call .warn for Warn
                if (console.warn.apply) {
                    console.warn.apply(console, consoleArgs);
                }
                else {
                    console.warn(consoleArgs.join(' '));
                }
            }
            else {
                // Call .error for Error/Fatal
                if (console.error.apply) {
                    console.error.apply(console, consoleArgs);
                }
                else {
                    console.error(consoleArgs.join(' '));
                }
            }
        };
        return ConsoleAppender;
    }());
    exports.ConsoleAppender = ConsoleAppender;
    /**
     * On-screen (canvas) appender
     */
    var ScreenAppender = (function () {
        /**
         * @param width   Width of the screen appender in pixels
         * @param height  Height of the screen appender in pixels
         */
        function ScreenAppender(width, height) {
            // @todo Clean this up
            this._messages = [];
            this._canvas = document.createElement('canvas');
            this._canvas.width = width || window.innerWidth;
            this._canvas.height = height || window.innerHeight;
            this._canvas.style.position = 'absolute';
            this._ctx = this._canvas.getContext('2d');
            document.body.appendChild(this._canvas);
        }
        /**
         * Logs a message at the given [[LogLevel]]
         * @param level  Level to log at
         * @param args   Arguments to log
         */
        ScreenAppender.prototype.log = function (level, args) {
            var message = args.join(',');
            this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
            this._messages.unshift('[' + LogLevel[level] + '] : ' + message);
            var pos = 10;
            var opacity = 1.0;
            for (var i = 0; i < this._messages.length; i++) {
                this._ctx.fillStyle = 'rgba(255,255,255,' + opacity.toFixed(2) + ')';
                this._ctx.fillText(this._messages[i], 200, pos);
                pos += 10;
                opacity = opacity > 0 ? opacity - .05 : 0;
            }
        };
        return ScreenAppender;
    }());
    exports.ScreenAppender = ScreenAppender;
});
define("Actions/IActionable", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Group", ["require", "exports", "Algebra", "Actions/ActionContext", "Actor", "Util/Log", "Class"], function (require, exports, Algebra_10, ActionContext_1, Actor_3, Log_1, Class_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Groups are used for logically grouping Actors so they can be acted upon
     * in bulk.
     *
     * [[include:Groups.md]]
     */
    var Group = (function (_super) {
        __extends(Group, _super);
        function Group(name, scene) {
            var _this = _super.call(this) || this;
            _this.name = name;
            _this.scene = scene;
            _this._logger = Log_1.Logger.getInstance();
            _this._members = [];
            _this.actions = new ActionContext_1.ActionContext();
            if (scene == null) {
                _this._logger.error('Invalid constructor arguments passed to Group: ', name, ', scene must not be null!');
            }
            else {
                var existingGroup = scene.groups[name];
                if (existingGroup) {
                    _this._logger.warn('Group with name', name, 'already exists. This new group will replace it.');
                }
                scene.groups[name] = _this;
            }
            return _this;
        }
        Group.prototype.add = function (actorOrActors) {
            if (actorOrActors instanceof Actor_3.Actor) {
                actorOrActors = [].concat(actorOrActors);
            }
            var i = 0, len = actorOrActors.length, groupIdx;
            for (i; i < len; i++) {
                groupIdx = this.getMembers().indexOf(actorOrActors[i]);
                if (groupIdx === -1) {
                    this._members.push(actorOrActors[i]);
                    this.scene.add(actorOrActors[i]);
                    this.actions.addActorToContext(actorOrActors[i]);
                    this.eventDispatcher.wire(actorOrActors[i].eventDispatcher);
                }
            }
        };
        Group.prototype.remove = function (actor) {
            var index = this._members.indexOf(actor);
            if (index > -1) {
                this._members.splice(index, 1);
                this.actions.removeActorFromContext(actor);
                this.eventDispatcher.unwire(actor.eventDispatcher);
            }
        };
        Group.prototype.move = function (args) {
            var i = 0, members = this.getMembers(), len = members.length;
            if (arguments.length === 1 && args instanceof Algebra_10.Vector) {
                for (i; i < len; i++) {
                    members[i].pos.x += args.x;
                    members[i].pos.y += args.y;
                }
            }
            else if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
                var x = arguments[0];
                var y = arguments[1];
                for (i; i < len; i++) {
                    members[i].pos.x += x;
                    members[i].pos.y += y;
                }
            }
            else {
                this._logger.error('Invalid arguments passed to group move', this.name, 'args:', arguments);
            }
        };
        Group.prototype.rotate = function (angle) {
            if (typeof angle !== 'number') {
                this._logger.error('Invalid arguments passed to group rotate', this.name, 'args:', arguments);
                return;
            }
            for (var _i = 0, _a = this.getMembers(); _i < _a.length; _i++) {
                var member = _a[_i];
                member.rotation += angle;
            }
        };
        Group.prototype.on = function (eventName, handler) {
            this.eventDispatcher.on(eventName, handler);
        };
        Group.prototype.off = function (eventName, handler) {
            this.eventDispatcher.off(eventName, handler);
        };
        Group.prototype.emit = function (topic, event) {
            this.eventDispatcher.emit(topic, event);
        };
        Group.prototype.contains = function (actor) {
            return this.getMembers().indexOf(actor) > -1;
        };
        Group.prototype.getMembers = function () {
            return this._members;
        };
        Group.prototype.getRandomMember = function () {
            return this._members[Math.floor(Math.random() * this._members.length)];
        };
        Group.prototype.getBounds = function () {
            return this.getMembers().map(function (a) { return a.getBounds(); }).reduce(function (prev, curr) {
                return prev.combine(curr);
            });
        };
        return Group;
    }(Class_1.Class));
    exports.Group = Group;
});
/**
 * These effects can be applied to any bitmap image but are mainly used
 * for [[Sprite]] effects or [[Animation]] effects.
 *
 * [[include:SpriteEffects.md]]
 */
define("Drawing/SpriteEffects", ["require", "exports", "Drawing/Color"], function (require, exports, Color_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Applies the "Grayscale" effect to a sprite, removing color information.
     */
    var Grayscale = (function () {
        function Grayscale() {
        }
        Grayscale.prototype.updatePixel = function (x, y, imageData) {
            var firstPixel = (x + y * imageData.width) * 4;
            var pixel = imageData.data;
            var avg = (pixel[firstPixel + 0] + pixel[firstPixel + 1] + pixel[firstPixel + 2]) / 3;
            pixel[firstPixel + 0] = avg;
            pixel[firstPixel + 1] = avg;
            pixel[firstPixel + 2] = avg;
        };
        return Grayscale;
    }());
    exports.Grayscale = Grayscale;
    /**
     * Applies the "Invert" effect to a sprite, inverting the pixel colors.
     */
    var Invert = (function () {
        function Invert() {
        }
        Invert.prototype.updatePixel = function (x, y, imageData) {
            var firstPixel = (x + y * imageData.width) * 4;
            var pixel = imageData.data;
            pixel[firstPixel + 0] = 255 - pixel[firstPixel + 0];
            pixel[firstPixel + 1] = 255 - pixel[firstPixel + 1];
            pixel[firstPixel + 2] = 255 - pixel[firstPixel + 2];
        };
        return Invert;
    }());
    exports.Invert = Invert;
    /**
     * Applies the "Opacity" effect to a sprite, setting the alpha of all pixels to a given value.
     */
    var Opacity = (function () {
        /**
         * @param opacity  The new opacity of the sprite from 0-1.0
         */
        function Opacity(opacity) {
            this.opacity = opacity;
        }
        Opacity.prototype.updatePixel = function (x, y, imageData) {
            var firstPixel = (x + y * imageData.width) * 4;
            var pixel = imageData.data;
            if (pixel[firstPixel + 3] !== 0) {
                pixel[firstPixel + 3] = Math.round(this.opacity * pixel[firstPixel + 3]);
            }
        };
        return Opacity;
    }());
    exports.Opacity = Opacity;
    /**
     * Applies the "Colorize" effect to a sprite, changing the color channels of all the pixels to an
     * average of the original color and the provided color
     */
    var Colorize = (function () {
        /**
         * @param color  The color to apply to the sprite
         */
        function Colorize(color) {
            this.color = color;
        }
        Colorize.prototype.updatePixel = function (x, y, imageData) {
            var firstPixel = (x + y * imageData.width) * 4;
            var pixel = imageData.data;
            if (pixel[firstPixel + 3] !== 0) {
                pixel[firstPixel + 0] = (pixel[firstPixel + 0] + this.color.r) / 2;
                pixel[firstPixel + 1] = (pixel[firstPixel + 1] + this.color.g) / 2;
                pixel[firstPixel + 2] = (pixel[firstPixel + 2] + this.color.b) / 2;
            }
        };
        return Colorize;
    }());
    exports.Colorize = Colorize;
    /**
     * Applies the "Lighten" effect to a sprite, changes the lightness of the color according to HSL
     */
    var Lighten = (function () {
        /**
         * @param factor  The factor of the effect between 0-1
         */
        function Lighten(factor) {
            if (factor === void 0) { factor = 0.1; }
            this.factor = factor;
        }
        Lighten.prototype.updatePixel = function (x, y, imageData) {
            var firstPixel = (x + y * imageData.width) * 4;
            var pixel = imageData.data;
            var color = Color_8.Color.fromRGB(pixel[firstPixel + 0], pixel[firstPixel + 1], pixel[firstPixel + 2], pixel[firstPixel + 3]).lighten(this.factor);
            pixel[firstPixel + 0] = color.r;
            pixel[firstPixel + 1] = color.g;
            pixel[firstPixel + 2] = color.b;
            pixel[firstPixel + 3] = color.a;
        };
        return Lighten;
    }());
    exports.Lighten = Lighten;
    /**
     * Applies the "Darken" effect to a sprite, changes the darkness of the color according to HSL
     */
    var Darken = (function () {
        /**
         * @param factor  The factor of the effect between 0-1
         */
        function Darken(factor) {
            if (factor === void 0) { factor = 0.1; }
            this.factor = factor;
        }
        Darken.prototype.updatePixel = function (x, y, imageData) {
            var firstPixel = (x + y * imageData.width) * 4;
            var pixel = imageData.data;
            var color = Color_8.Color.fromRGB(pixel[firstPixel + 0], pixel[firstPixel + 1], pixel[firstPixel + 2], pixel[firstPixel + 3]).darken(this.factor);
            pixel[firstPixel + 0] = color.r;
            pixel[firstPixel + 1] = color.g;
            pixel[firstPixel + 2] = color.b;
            pixel[firstPixel + 3] = color.a;
        };
        return Darken;
    }());
    exports.Darken = Darken;
    /**
     * Applies the "Saturate" effect to a sprite, saturates the color according to HSL
     */
    var Saturate = (function () {
        /**
         * @param factor  The factor of the effect between 0-1
         */
        function Saturate(factor) {
            if (factor === void 0) { factor = 0.1; }
            this.factor = factor;
        }
        Saturate.prototype.updatePixel = function (x, y, imageData) {
            var firstPixel = (x + y * imageData.width) * 4;
            var pixel = imageData.data;
            var color = Color_8.Color.fromRGB(pixel[firstPixel + 0], pixel[firstPixel + 1], pixel[firstPixel + 2], pixel[firstPixel + 3]).saturate(this.factor);
            pixel[firstPixel + 0] = color.r;
            pixel[firstPixel + 1] = color.g;
            pixel[firstPixel + 2] = color.b;
            pixel[firstPixel + 3] = color.a;
        };
        return Saturate;
    }());
    exports.Saturate = Saturate;
    /**
     * Applies the "Desaturate" effect to a sprite, desaturates the color according to HSL
     */
    var Desaturate = (function () {
        /**
         * @param factor  The factor of the effect between 0-1
         */
        function Desaturate(factor) {
            if (factor === void 0) { factor = 0.1; }
            this.factor = factor;
        }
        Desaturate.prototype.updatePixel = function (x, y, imageData) {
            var firstPixel = (x + y * imageData.width) * 4;
            var pixel = imageData.data;
            var color = Color_8.Color.fromRGB(pixel[firstPixel + 0], pixel[firstPixel + 1], pixel[firstPixel + 2], pixel[firstPixel + 3]).desaturate(this.factor);
            pixel[firstPixel + 0] = color.r;
            pixel[firstPixel + 1] = color.g;
            pixel[firstPixel + 2] = color.b;
            pixel[firstPixel + 3] = color.a;
        };
        return Desaturate;
    }());
    exports.Desaturate = Desaturate;
    /**
     * Applies the "Fill" effect to a sprite, changing the color channels of all non-transparent pixels to match
     * a given color
     */
    var Fill = (function () {
        /**
         * @param color  The color to apply to the sprite
         */
        function Fill(color) {
            this.color = color;
        }
        Fill.prototype.updatePixel = function (x, y, imageData) {
            var firstPixel = (x + y * imageData.width) * 4;
            var pixel = imageData.data;
            if (pixel[firstPixel + 3] !== 0) {
                pixel[firstPixel + 0] = this.color.r;
                pixel[firstPixel + 1] = this.color.g;
                pixel[firstPixel + 2] = this.color.b;
            }
        };
        return Fill;
    }());
    exports.Fill = Fill;
});
define("Interfaces/IDrawable", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Interfaces/ILoadable", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Resources/Resource", ["require", "exports", "Class", "Promises", "Util/Log"], function (require, exports, Class_2, Promises_3, Log_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The [[Resource]] type allows games built in Excalibur to load generic resources.
     * For any type of remote resource it is recommended to use [[Resource]] for preloading.
     *
     * [[include:Resources.md]]
     */
    var Resource = (function (_super) {
        __extends(Resource, _super);
        /**
         * @param path          Path to the remote resource
         * @param responseType  The type to expect as a response: "" | "arraybuffer" | "blob" | "document" | "json" | "text";
         * @param bustCache     Whether or not to cache-bust requests
         */
        function Resource(path, responseType, bustCache) {
            if (bustCache === void 0) { bustCache = true; }
            var _this = _super.call(this) || this;
            _this.path = path;
            _this.responseType = responseType;
            _this.bustCache = bustCache;
            _this.data = null;
            _this.logger = Log_2.Logger.getInstance();
            _this.onprogress = function () { return; };
            _this.oncomplete = function () { return; };
            _this.onerror = function () { return; };
            return _this;
        }
        /**
         * Returns true if the Resource is completely loaded and is ready
         * to be drawn.
         */
        Resource.prototype.isLoaded = function () {
            return this.data !== null;
        };
        Resource.prototype.wireEngine = function (_engine) {
            // override me
        };
        Resource.prototype._cacheBust = function (uri) {
            var query = /\?\w*=\w*/;
            if (query.test(uri)) {
                uri += ('&__=' + Date.now());
            }
            else {
                uri += ('?__=' + Date.now());
            }
            return uri;
        };
        Resource.prototype._start = function () {
            this.logger.debug('Started loading resource ' + this.path);
        };
        /**
         * Begin loading the resource and returns a promise to be resolved on completion
         */
        Resource.prototype.load = function () {
            var _this = this;
            var complete = new Promises_3.Promise();
            // Exit early if we already have data
            if (this.data !== null) {
                this.logger.debug('Already have data for resource', this.path);
                complete.resolve(this.data);
                this.oncomplete();
                return complete;
            }
            var request = new XMLHttpRequest();
            request.open('GET', this.bustCache ? this._cacheBust(this.path) : this.path, true);
            request.responseType = this.responseType;
            request.onloadstart = function () { _this._start(); };
            request.onprogress = this.onprogress;
            request.onerror = this.onerror;
            request.onload = function () {
                // XHR on file:// success status is 0, such as with PhantomJS
                if (request.status !== 0 && request.status !== 200) {
                    _this.logger.error('Failed to load resource ', _this.path, ' server responded with error code', request.status);
                    _this.onerror(request.response);
                    complete.resolve(request.response);
                    return;
                }
                _this.data = _this.processData(request.response);
                _this.oncomplete();
                _this.logger.debug('Completed loading resource', _this.path);
                complete.resolve(_this.data);
            };
            request.send();
            return complete;
        };
        /**
         * Returns the loaded data once the resource is loaded
         */
        Resource.prototype.getData = function () {
            return this.data;
        };
        /**
         * Sets the data for this resource directly
         */
        Resource.prototype.setData = function (data) {
            this.data = this.processData(data);
        };
        /**
         * This method is meant to be overriden to handle any additional
         * processing. Such as decoding downloaded audio bits.
         */
        Resource.prototype.processData = function (data) {
            // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseType
            // Blob requires an object url
            if (this.responseType === 'blob') {
                return URL.createObjectURL(data);
            }
            return data;
        };
        return Resource;
    }(Class_2.Class));
    exports.Resource = Resource;
});
define("Resources/Texture", ["require", "exports", "Resources/Resource", "Promises", "Drawing/Sprite"], function (require, exports, Resource_1, Promises_4, Sprite_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The [[Texture]] object allows games built in Excalibur to load image resources.
     * [[Texture]] is an [[ILoadable]] which means it can be passed to a [[Loader]]
     * to pre-load before starting a level or game.
     *
     * [[include:Textures.md]]
     */
    var Texture = (function (_super) {
        __extends(Texture, _super);
        /**
         * @param path       Path to the image resource
         * @param bustCache  Optionally load texture with cache busting
         */
        function Texture(path, bustCache) {
            if (bustCache === void 0) { bustCache = true; }
            var _this = _super.call(this, path, 'blob', bustCache) || this;
            _this.path = path;
            _this.bustCache = bustCache;
            /**
             * A [[Promise]] that resolves when the Texture is loaded.
             */
            _this.loaded = new Promises_4.Promise();
            _this._isLoaded = false;
            _this._sprite = null;
            _this._sprite = new Sprite_1.Sprite(_this, 0, 0, 0, 0);
            return _this;
        }
        /**
         * Returns true if the Texture is completely loaded and is ready
         * to be drawn.
         */
        Texture.prototype.isLoaded = function () {
            return this._isLoaded;
        };
        /**
         * Begins loading the texture and returns a promise to be resolved on completion
         */
        Texture.prototype.load = function () {
            var _this = this;
            var complete = new Promises_4.Promise();
            var loaded = _super.prototype.load.call(this);
            loaded.then(function () {
                _this.image = new Image();
                _this.image.addEventListener('load', function () {
                    _this._isLoaded = true;
                    _this.width = _this._sprite.swidth = _this._sprite.naturalWidth = _this._sprite.width = _this.image.naturalWidth;
                    _this.height = _this._sprite.sheight = _this._sprite.naturalHeight = _this._sprite.height = _this.image.naturalHeight;
                    _this.loaded.resolve(_this.image);
                    complete.resolve(_this.image);
                });
                _this.image.src = _super.prototype.getData.call(_this);
            }, function () {
                complete.reject('Error loading texture.');
            });
            return complete;
        };
        Texture.prototype.asSprite = function () {
            return this._sprite;
        };
        return Texture;
    }(Resource_1.Resource));
    exports.Texture = Texture;
});
define("Drawing/Sprite", ["require", "exports", "Drawing/SpriteEffects", "Drawing/Color", "Resources/Texture", "Algebra", "Util/Log", "Util/Util", "Configurable"], function (require, exports, Effects, Color_9, Texture_1, Algebra_11, Log_3, Util_2, Configurable_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @hidden
     */
    var SpriteImpl = (function () {
        /**
         * @param image   The backing image texture to build the Sprite
         * @param sx      The x position of the sprite
         * @param sy      The y position of the sprite
         * @param swidth  The width of the sprite in pixels
         * @param sheight The height of the sprite in pixels
         */
        function SpriteImpl(imageOrConfig, sx, sy, swidth, sheight) {
            var _this = this;
            this.rotation = 0.0;
            this.anchor = new Algebra_11.Vector(0.0, 0.0);
            this.scale = new Algebra_11.Vector(1, 1);
            this.logger = Log_3.Logger.getInstance();
            /**
             * Draws the sprite flipped vertically
             */
            this.flipVertical = false;
            /**
             * Draws the sprite flipped horizontally
             */
            this.flipHorizontal = false;
            this.width = 0;
            this.height = 0;
            this.effects = [];
            this.sx = 0;
            this.sy = 0;
            this.swidth = 0;
            this.sheight = 0;
            this.naturalWidth = 0;
            this.naturalHeight = 0;
            this._spriteCanvas = null;
            this._spriteCtx = null;
            this._pixelData = null;
            this._pixelsLoaded = false;
            this._dirtyEffect = false;
            if (sx < 0 || sy < 0 || swidth < 0 || sheight < 0) {
                this.logger.error('Sprite cannot have any negative dimensions x:', sx, 'y:', sy, 'width:', swidth, 'height:', sheight);
            }
            var image = imageOrConfig;
            if (imageOrConfig && !(imageOrConfig instanceof Texture_1.Texture)) {
                sx = imageOrConfig.sx;
                sy = imageOrConfig.sy;
                swidth = imageOrConfig.swidth;
                sheight = imageOrConfig.sheight;
                image = imageOrConfig.image;
            }
            this.sx = sx || 0;
            this.sy = sy || 0;
            this.swidth = swidth || 0;
            this.sheight = sheight || 0;
            this._texture = image;
            this._spriteCanvas = document.createElement('canvas');
            this._spriteCanvas.width = swidth;
            this._spriteCanvas.height = sheight;
            this._spriteCtx = this._spriteCanvas.getContext('2d');
            this._texture.loaded.then(function () {
                _this._spriteCanvas.width = _this._spriteCanvas.width || _this._texture.image.naturalWidth;
                _this._spriteCanvas.height = _this._spriteCanvas.height || _this._texture.image.naturalHeight;
                _this._loadPixels();
                _this._dirtyEffect = true;
            }).error(function (e) {
                _this.logger.error('Error loading texture ', _this._texture.path, e);
            });
            this.width = swidth;
            this.height = sheight;
            this.naturalWidth = swidth;
            this.naturalHeight = sheight;
        }
        SpriteImpl.prototype._loadPixels = function () {
            if (this._texture.isLoaded() && !this._pixelsLoaded) {
                var naturalWidth = this._texture.image.naturalWidth || 0;
                var naturalHeight = this._texture.image.naturalHeight || 0;
                if (this.swidth > naturalWidth) {
                    this.logger.warn('The sprite width', this.swidth, 'exceeds the width', naturalWidth, 'of the backing texture', this._texture.path);
                }
                if (this.sheight > naturalHeight) {
                    this.logger.warn('The sprite height', this.sheight, 'exceeds the height', naturalHeight, 'of the backing texture', this._texture.path);
                }
                this._spriteCtx.drawImage(this._texture.image, Util_2.clamp(this.sx, 0, naturalWidth), Util_2.clamp(this.sy, 0, naturalHeight), Util_2.clamp(this.swidth, 0, naturalWidth), Util_2.clamp(this.sheight, 0, naturalHeight), 0, 0, this.swidth, this.sheight);
                this._pixelsLoaded = true;
            }
        };
        /**
         * Applies the [[Opacity]] effect to a sprite, setting the alpha of all pixels to a given value
         */
        SpriteImpl.prototype.opacity = function (value) {
            this.addEffect(new Effects.Opacity(value));
        };
        /**
         * Applies the [[Grayscale]] effect to a sprite, removing color information.
         */
        SpriteImpl.prototype.grayscale = function () {
            this.addEffect(new Effects.Grayscale());
        };
        /**
         * Applies the [[Invert]] effect to a sprite, inverting the pixel colors.
         */
        SpriteImpl.prototype.invert = function () {
            this.addEffect(new Effects.Invert());
        };
        /**
         * Applies the [[Fill]] effect to a sprite, changing the color channels of all non-transparent pixels to match a given color
         */
        SpriteImpl.prototype.fill = function (color) {
            this.addEffect(new Effects.Fill(color));
        };
        /**
         * Applies the [[Colorize]] effect to a sprite, changing the color channels of all pixels to be the average of the original color
         * and the provided color.
         */
        SpriteImpl.prototype.colorize = function (color) {
            this.addEffect(new Effects.Colorize(color));
        };
        /**
         * Applies the [[Lighten]] effect to a sprite, changes the lightness of the color according to HSL
         */
        SpriteImpl.prototype.lighten = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            this.addEffect(new Effects.Lighten(factor));
        };
        /**
         * Applies the [[Darken]] effect to a sprite, changes the darkness of the color according to HSL
         */
        SpriteImpl.prototype.darken = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            this.addEffect(new Effects.Darken(factor));
        };
        /**
         * Applies the [[Saturate]] effect to a sprite, saturates the color according to HSL
         */
        SpriteImpl.prototype.saturate = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            this.addEffect(new Effects.Saturate(factor));
        };
        /**
         * Applies the [[Desaturate]] effect to a sprite, desaturates the color according to HSL
         */
        SpriteImpl.prototype.desaturate = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            this.addEffect(new Effects.Desaturate(factor));
        };
        /**
         * Adds a new [[ISpriteEffect]] to this drawing.
         * @param effect  Effect to add to the this drawing
         */
        SpriteImpl.prototype.addEffect = function (effect) {
            this.effects.push(effect);
            // We must check if the texture and the backing sprite pixels are loaded as well before 
            // an effect can be applied
            if (!this._texture.isLoaded() || !this._pixelsLoaded) {
                this._dirtyEffect = true;
            }
            else {
                this._applyEffects();
            }
        };
        SpriteImpl.prototype.removeEffect = function (param) {
            var indexToRemove = -1;
            if (typeof param === 'number') {
                indexToRemove = param;
            }
            else {
                indexToRemove = this.effects.indexOf(param);
            }
            // bounds check
            if (indexToRemove < 0 || indexToRemove >= this.effects.length) {
                return;
            }
            this.effects.splice(indexToRemove, 1);
            // We must check if the texture and the backing sprite pixels are loaded as well before 
            // an effect can be applied
            if (!this._texture.isLoaded() || !this._pixelsLoaded) {
                this._dirtyEffect = true;
            }
            else {
                this._applyEffects();
            }
        };
        SpriteImpl.prototype._applyEffects = function () {
            var naturalWidth = this._texture.image.naturalWidth || 0;
            var naturalHeight = this._texture.image.naturalHeight || 0;
            this._spriteCtx.clearRect(0, 0, this.swidth, this.sheight);
            this._spriteCtx.drawImage(this._texture.image, Util_2.clamp(this.sx, 0, naturalWidth), Util_2.clamp(this.sy, 0, naturalHeight), Util_2.clamp(this.swidth, 0, naturalWidth), Util_2.clamp(this.sheight, 0, naturalHeight), 0, 0, this.swidth, this.sheight);
            this._pixelData = this._spriteCtx.getImageData(0, 0, this.swidth, this.sheight);
            var i = 0, x = 0, y = 0, len = this.effects.length;
            for (i; i < len; i++) {
                y = 0;
                for (y; y < this.sheight; y++) {
                    x = 0;
                    for (x; x < this.swidth; x++) {
                        this.effects[i].updatePixel(x, y, this._pixelData);
                    }
                }
            }
            this._spriteCtx.clearRect(0, 0, this.swidth, this.sheight);
            this._spriteCtx.putImageData(this._pixelData, 0, 0);
            this._dirtyEffect = false;
        };
        /**
         * Clears all effects from the drawing and return it to its original state.
         */
        SpriteImpl.prototype.clearEffects = function () {
            this.effects.length = 0;
            this._applyEffects();
        };
        /**
         * Resets the internal state of the drawing (if any)
         */
        SpriteImpl.prototype.reset = function () {
            // do nothing
        };
        SpriteImpl.prototype.debugDraw = function (ctx, x, y) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(this.rotation);
            var scaledSWidth = this.width * this.scale.x;
            var scaledSHeight = this.height * this.scale.y;
            var xpoint = (scaledSWidth) * this.anchor.x;
            var ypoint = (scaledSHeight) * this.anchor.y;
            ctx.strokeStyle = Color_9.Color.Black.toString();
            ctx.strokeRect(-xpoint, -ypoint, scaledSWidth, scaledSHeight);
            ctx.restore();
        };
        /**
         * Draws the sprite appropriately to the 2D rendering context, at an x and y coordinate.
         * @param ctx  The 2D rendering context
         * @param x    The x coordinate of where to draw
         * @param y    The y coordinate of where to draw
         */
        SpriteImpl.prototype.draw = function (ctx, x, y) {
            if (this._dirtyEffect) {
                this._applyEffects();
            }
            // calculating current dimensions
            this.width = this.naturalWidth * this.scale.x;
            this.height = this.naturalHeight * this.scale.y;
            ctx.save();
            var xpoint = this.width * this.anchor.x;
            var ypoint = this.height * this.anchor.y;
            ctx.translate(x, y);
            ctx.rotate(this.rotation);
            var scaledSWidth = this.swidth * this.scale.x;
            var scaledSHeight = this.sheight * this.scale.y;
            // todo cache flipped sprites
            if (this.flipHorizontal) {
                ctx.translate(scaledSWidth, 0);
                ctx.scale(-1, 1);
            }
            if (this.flipVertical) {
                ctx.translate(0, scaledSHeight);
                ctx.scale(1, -1);
            }
            ctx.drawImage(this._spriteCanvas, 0, 0, this.swidth, this.sheight, -xpoint, -ypoint, scaledSWidth, scaledSHeight);
            ctx.restore();
        };
        /**
         * Produces a copy of the current sprite
         */
        SpriteImpl.prototype.clone = function () {
            var result = new Sprite(this._texture, this.sx, this.sy, this.swidth, this.sheight);
            result.scale = this.scale.clone();
            result.rotation = this.rotation;
            result.flipHorizontal = this.flipHorizontal;
            result.flipVertical = this.flipVertical;
            var i = 0, len = this.effects.length;
            for (i; i < len; i++) {
                result.addEffect(this.effects[i]);
            }
            return result;
        };
        return SpriteImpl;
    }());
    exports.SpriteImpl = SpriteImpl;
    /**
     * A [[Sprite]] is one of the main drawing primitives. It is responsible for drawing
     * images or parts of images from a [[Texture]] resource to the screen.
     *
     * [[include:Sprites.md]]
     */
    var Sprite = (function (_super) {
        __extends(Sprite, _super);
        function Sprite(imageOrConfig, sx, sy, swidth, sheight) {
            return _super.call(this, imageOrConfig, sx, sy, swidth, sheight) || this;
        }
        return Sprite;
    }(Configurable_1.Configurable(SpriteImpl)));
    exports.Sprite = Sprite;
});
define("Drawing/Animation", ["require", "exports", "Drawing/SpriteEffects", "Algebra", "Engine", "Util/Util", "Configurable"], function (require, exports, Effects, Algebra_12, Engine_1, Util, Configurable_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @hidden
     */
    var AnimationImpl = (function () {
        /**
         * Typically you will use a [[SpriteSheet]] to generate an [[Animation]].
         *
         * @param engine  Reference to the current game engine
         * @param images  An array of sprites to create the frames for the animation
         * @param speed   The number in milliseconds to display each frame in the animation
         * @param loop    Indicates whether the animation should loop after it is completed
         */
        function AnimationImpl(engineOrConfig, sprites, speed, loop) {
            /**
             * The sprite frames to play, in order. See [[SpriteSheet.getAnimationForAll]] to quickly
             * generate an [[Animation]].
             */
            this.sprites = [];
            /**
             * Current frame index being shown
             */
            this.currentFrame = 0;
            this._oldTime = Date.now();
            this.anchor = new Algebra_12.Vector(0.0, 0.0);
            this.rotation = 0.0;
            this.scale = new Algebra_12.Vector(1, 1);
            /**
             * Indicates whether the animation should loop after it is completed
             */
            this.loop = true;
            /**
             * Indicates the frame index the animation should freeze on for a non-looping
             * animation. By default it is the last frame.
             */
            this.freezeFrame = -1;
            /**
             * Flip each frame vertically. Sets [[Sprite.flipVertical]].
             */
            this.flipVertical = false;
            /**
             * Flip each frame horizontally. Sets [[Sprite.flipHorizontal]].
             */
            this.flipHorizontal = false;
            this.width = 0;
            this.height = 0;
            this.naturalWidth = 0;
            this.naturalHeight = 0;
            var engine = engineOrConfig;
            if (engineOrConfig && !(engineOrConfig instanceof Engine_1.Engine)) {
                var config = engineOrConfig;
                engine = config.engine;
                sprites = config.sprites;
                speed = config.speed;
                loop = config.loop;
            }
            this.sprites = sprites;
            this.speed = speed;
            this._engine = engine;
            if (loop != null) {
                this.loop = loop;
            }
            if (sprites && sprites[0]) {
                this.height = sprites[0] ? sprites[0].height : 0;
                this.width = sprites[0] ? sprites[0].width : 0;
                this.naturalWidth = sprites[0] ? sprites[0].naturalWidth : 0;
                this.naturalHeight = sprites[0] ? sprites[0].naturalHeight : 0;
                this.freezeFrame = sprites.length - 1;
            }
        }
        /**
         * Applies the opacity effect to a sprite, setting the alpha of all pixels to a given value
         */
        AnimationImpl.prototype.opacity = function (value) {
            this.addEffect(new Effects.Opacity(value));
        };
        /**
         * Applies the grayscale effect to a sprite, removing color information.
         */
        AnimationImpl.prototype.grayscale = function () {
            this.addEffect(new Effects.Grayscale());
        };
        /**
         * Applies the invert effect to a sprite, inverting the pixel colors.
         */
        AnimationImpl.prototype.invert = function () {
            this.addEffect(new Effects.Invert());
        };
        /**
         * Applies the fill effect to a sprite, changing the color channels of all non-transparent pixels to match a given color
         */
        AnimationImpl.prototype.fill = function (color) {
            this.addEffect(new Effects.Fill(color));
        };
        /**
         * Applies the colorize effect to a sprite, changing the color channels of all pixels to be the average of the original color and the
         * provided color.
         */
        AnimationImpl.prototype.colorize = function (color) {
            this.addEffect(new Effects.Colorize(color));
        };
        /**
         * Applies the lighten effect to a sprite, changes the lightness of the color according to hsl
         */
        AnimationImpl.prototype.lighten = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            this.addEffect(new Effects.Lighten(factor));
        };
        /**
         * Applies the darken effect to a sprite, changes the darkness of the color according to hsl
         */
        AnimationImpl.prototype.darken = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            this.addEffect(new Effects.Darken(factor));
        };
        /**
         * Applies the saturate effect to a sprite, saturates the color according to hsl
         */
        AnimationImpl.prototype.saturate = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            this.addEffect(new Effects.Saturate(factor));
        };
        /**
         * Applies the desaturate effect to a sprite, desaturates the color according to hsl
         */
        AnimationImpl.prototype.desaturate = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            this.addEffect(new Effects.Desaturate(factor));
        };
        /**
         * Add a [[ISpriteEffect]] manually
         */
        AnimationImpl.prototype.addEffect = function (effect) {
            for (var i in this.sprites) {
                this.sprites[i].addEffect(effect);
            }
        };
        AnimationImpl.prototype.removeEffect = function (param) {
            for (var i in this.sprites) {
                this.sprites[i].removeEffect(param);
            }
        };
        /**
         * Clear all sprite effects
         */
        AnimationImpl.prototype.clearEffects = function () {
            for (var i in this.sprites) {
                this.sprites[i].clearEffects();
            }
        };
        AnimationImpl.prototype._setAnchor = function (point) {
            //if (!this.anchor.equals(point)) {
            for (var i in this.sprites) {
                this.sprites[i].anchor.setTo(point.x, point.y);
            }
            //}
        };
        AnimationImpl.prototype._setRotation = function (radians) {
            //if (this.rotation !== radians) {
            for (var i in this.sprites) {
                this.sprites[i].rotation = radians;
            }
            //}
        };
        AnimationImpl.prototype._setScale = function (scale) {
            //if (!this.scale.equals(scale)) {
            for (var i in this.sprites) {
                this.sprites[i].scale = scale;
            }
            //}
        };
        /**
         * Resets the animation to first frame.
         */
        AnimationImpl.prototype.reset = function () {
            this.currentFrame = 0;
        };
        /**
         * Indicates whether the animation is complete, animations that loop are never complete.
         */
        AnimationImpl.prototype.isDone = function () {
            return (!this.loop && this.currentFrame >= this.sprites.length);
        };
        /**
         * Not meant to be called by game developers. Ticks the animation forward internally and
         * calculates whether to change to the frame.
         * @internal
         */
        AnimationImpl.prototype.tick = function () {
            var time = Date.now();
            if ((time - this._oldTime) > this.speed) {
                this.currentFrame = (this.loop ? (this.currentFrame + 1) % this.sprites.length : this.currentFrame + 1);
                this._oldTime = time;
            }
        };
        AnimationImpl.prototype._updateValues = function () {
            this._setAnchor(this.anchor);
            this._setRotation(this.rotation);
            this._setScale(this.scale);
        };
        /**
         * Skips ahead a specified number of frames in the animation
         * @param frames  Frames to skip ahead
         */
        AnimationImpl.prototype.skip = function (frames) {
            this.currentFrame = (this.currentFrame + frames) % this.sprites.length;
        };
        AnimationImpl.prototype.draw = function (ctx, x, y) {
            this.tick();
            this._updateValues();
            var currSprite;
            if (this.currentFrame < this.sprites.length) {
                currSprite = this.sprites[this.currentFrame];
                if (this.flipVertical) {
                    currSprite.flipVertical = this.flipVertical;
                }
                if (this.flipHorizontal) {
                    currSprite.flipHorizontal = this.flipHorizontal;
                }
                currSprite.draw(ctx, x, y);
            }
            if (this.freezeFrame !== -1 && this.currentFrame >= this.sprites.length) {
                currSprite = this.sprites[Util.clamp(this.freezeFrame, 0, this.sprites.length - 1)];
                currSprite.draw(ctx, x, y);
            }
            // add the calculated width
            if (currSprite) {
                this.width = currSprite.width;
                this.height = currSprite.height;
            }
        };
        /**
         * Plays an animation at an arbitrary location in the game.
         * @param x  The x position in the game to play
         * @param y  The y position in the game to play
         */
        AnimationImpl.prototype.play = function (x, y) {
            this.reset();
            this._engine.playAnimation(this, x, y);
        };
        return AnimationImpl;
    }());
    exports.AnimationImpl = AnimationImpl;
    /**
     * Animations allow you to display a series of images one after another,
     * creating the illusion of change. Generally these images will come from a [[SpriteSheet]] source.
     *
     * [[include:Animations.md]]
     */
    var Animation = (function (_super) {
        __extends(Animation, _super);
        function Animation(engineOrConfig, images, speed, loop) {
            return _super.call(this, engineOrConfig, images, speed, loop) || this;
        }
        return Animation;
    }(Configurable_2.Configurable(AnimationImpl)));
    exports.Animation = Animation;
});
define("Drawing/SpriteSheet", ["require", "exports", "Drawing/Sprite", "Drawing/Animation", "Drawing/Color", "Drawing/SpriteEffects", "Resources/Texture", "Util/Log", "Label", "Configurable"], function (require, exports, Sprite_2, Animation_1, Color_10, Effects, Texture_2, Log_4, Label_1, Configurable_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @hidden
     */
    var SpriteSheetImpl = (function () {
        /**
         * @param image     The backing image texture to build the SpriteSheet
         * @param columns   The number of columns in the image texture
         * @param rows      The number of rows in the image texture
         * @param spWidth   The width of each individual sprite in pixels
         * @param spHeight  The height of each individual sprite in pixels
         */
        function SpriteSheetImpl(imageOrConfigOrSprites, columns, rows, spWidth, spHeight) {
            this.sprites = [];
            this.image = null;
            this.columns = 0;
            this.rows = 0;
            var loadFromImage = false;
            if (imageOrConfigOrSprites instanceof Array) {
                this.sprites = imageOrConfigOrSprites;
            }
            else {
                if (imageOrConfigOrSprites && !(imageOrConfigOrSprites instanceof Texture_2.Texture)) {
                    this.columns = imageOrConfigOrSprites.columns;
                    this.rows = imageOrConfigOrSprites.rows;
                    this.spWidth = imageOrConfigOrSprites.spWidth;
                    this.spHeight = imageOrConfigOrSprites.spHeight;
                    this.image = imageOrConfigOrSprites.image;
                }
                else {
                    this.image = imageOrConfigOrSprites;
                    this.columns = columns;
                    this.rows = rows;
                    this.spWidth = spWidth;
                    this.spHeight = spHeight;
                }
                this.sprites = new Array(this.columns * this.rows);
                loadFromImage = true;
            }
            // TODO: Inspect actual image dimensions with preloading
            /*if(spWidth * columns > this.internalImage.naturalWidth){
               throw new Error("SpriteSheet specified is wider than image width");
            }
      
            if(spHeight * rows > this.internalImage.naturalHeight){
               throw new Error("SpriteSheet specified is higher than image height");
            }*/
            if (loadFromImage) {
                var i = 0;
                var j = 0;
                for (i = 0; i < this.rows; i++) {
                    for (j = 0; j < this.columns; j++) {
                        this.sprites[j + i * this.columns] = new Sprite_2.Sprite(this.image, j * this.spWidth, i * this.spHeight, this.spWidth, this.spHeight);
                    }
                }
            }
        }
        /**
         * Create an animation from the this SpriteSheet by listing out the
         * sprite indices. Sprites are organized in row major order in the SpriteSheet.
         * @param engine   Reference to the current game [[Engine]]
         * @param indices  An array of sprite indices to use in the animation
         * @param speed    The number in milliseconds to display each frame in the animation
         */
        SpriteSheetImpl.prototype.getAnimationByIndices = function (engine, indices, speed) {
            var _this = this;
            var images = indices.map(function (index) {
                return _this.sprites[index];
            });
            images = images.map(function (i) {
                return i.clone();
            });
            return new Animation_1.Animation(engine, images, speed);
        };
        /**
         * Create an animation from the this SpriteSheet by specifing the range of
         * images with the beginning (inclusive) and ending (exclusive) index
         * For example `getAnimationBetween(engine, 0, 5, 200)` returns an animation with 5 frames.
         * @param engine      Reference to the current game Engine
         * @param beginIndex  The index to start taking frames (inclusive)
         * @param endIndex    The index to stop taking frames (exclusive)
         * @param speed       The number in milliseconds to display each frame in the animation
         */
        SpriteSheetImpl.prototype.getAnimationBetween = function (engine, beginIndex, endIndex, speed) {
            var images = this.sprites.slice(beginIndex, endIndex);
            images = images.map(function (i) {
                return i.clone();
            });
            return new Animation_1.Animation(engine, images, speed);
        };
        /**
         * Treat the entire SpriteSheet as one animation, organizing the frames in
         * row major order.
         * @param engine  Reference to the current game [[Engine]]
         * @param speed   The number in milliseconds to display each frame the animation
         */
        SpriteSheetImpl.prototype.getAnimationForAll = function (engine, speed) {
            var sprites = this.sprites.map(function (i) {
                return i.clone();
            });
            return new Animation_1.Animation(engine, sprites, speed);
        };
        /**
         * Retreive a specific sprite from the SpriteSheet by its index. Sprites are organized
         * in row major order in the SpriteSheet.
         * @param index  The index of the sprite
         */
        SpriteSheetImpl.prototype.getSprite = function (index) {
            if (index >= 0 && index < this.sprites.length) {
                return this.sprites[index];
            }
            else {
                throw new Error('Invalid index: ' + index);
            }
        };
        return SpriteSheetImpl;
    }());
    exports.SpriteSheetImpl = SpriteSheetImpl;
    /**
     * Sprite sheets are a useful mechanism for slicing up image resources into
     * separate sprites or for generating in game animations. [[Sprite|Sprites]] are organized
     * in row major order in the [[SpriteSheet]].
     *
     * [[include:SpriteSheets.md]]
     */
    var SpriteSheet = (function (_super) {
        __extends(SpriteSheet, _super);
        function SpriteSheet(imageOrConfigOrSprites, columns, rows, spWidth, spHeight) {
            return _super.call(this, imageOrConfigOrSprites, columns, rows, spWidth, spHeight) || this;
        }
        return SpriteSheet;
    }(Configurable_3.Configurable(SpriteSheetImpl)));
    exports.SpriteSheet = SpriteSheet;
    var SpriteFontImpl = (function (_super) {
        __extends(SpriteFontImpl, _super);
        /**
         * @param image           The backing image texture to build the SpriteFont
         * @param alphabet        A string representing all the characters in the image, in row major order.
         * @param caseInsensitive  Indicate whether this font takes case into account
         * @param columns         The number of columns of characters in the image
         * @param rows            The number of rows of characters in the image
         * @param spWidth         The width of each character in pixels
         * @param spHeight        The height of each character in pixels
         */
        function SpriteFontImpl(imageOrConfig, alphabet, caseInsensitive, columns, rows, spWidth, spHeight) {
            var _this = _super.call(this, imageOrConfig instanceof Texture_2.Texture ? { image: imageOrConfig, spWidth: spWidth,
                spHeight: spHeight, rows: rows, columns: columns } : imageOrConfig) || this;
            _this._currentColor = Color_10.Color.Black.clone();
            _this._currentOpacity = 1.0;
            _this._sprites = {};
            // text shadow
            _this._textShadowOn = false;
            _this._textShadowDirty = true;
            _this._textShadowColor = Color_10.Color.Black.clone();
            _this._textShadowSprites = {};
            _this._shadowOffsetX = 5;
            _this._shadowOffsetY = 5;
            if (imageOrConfig && !(imageOrConfig instanceof Texture_2.Texture)) {
                alphabet = imageOrConfig.alphabet;
                caseInsensitive = imageOrConfig.caseInsensitive;
            }
            _this._alphabet = alphabet;
            _this._caseInsensitive = caseInsensitive;
            _this._sprites = _this.getTextSprites();
            return _this;
        }
        /**
         * Returns a dictionary that maps each character in the alphabet to the appropriate [[Sprite]].
         */
        SpriteFontImpl.prototype.getTextSprites = function () {
            var lookup = {};
            for (var i = 0; i < this._alphabet.length; i++) {
                var char = this._alphabet[i];
                if (this._caseInsensitive) {
                    char = char.toLowerCase();
                }
                lookup[char] = this.sprites[i].clone();
            }
            return lookup;
        };
        /**
         * Sets the text shadow for sprite fonts
         * @param offsetX      The x offset in pixels to place the shadow
         * @param offsetY      The y offset in pixels to place the shadow
         * @param shadowColor  The color of the text shadow
         */
        SpriteFontImpl.prototype.setTextShadow = function (offsetX, offsetY, shadowColor) {
            this._textShadowOn = true;
            this._shadowOffsetX = offsetX;
            this._shadowOffsetY = offsetY;
            this._textShadowColor = shadowColor.clone();
            this._textShadowDirty = true;
            for (var character in this._sprites) {
                this._textShadowSprites[character] = this._sprites[character].clone();
            }
        };
        /**
         * Toggles text shadows on or off
         */
        SpriteFontImpl.prototype.useTextShadow = function (on) {
            this._textShadowOn = on;
            if (on) {
                this.setTextShadow(5, 5, this._textShadowColor);
            }
        };
        /**
         * Draws the current sprite font
         */
        SpriteFontImpl.prototype.draw = function (ctx, text, x, y, options) {
            options = this._parseOptions(options);
            if (this._currentColor.toString() !== options.color.toString() || this._currentOpacity !== options.opacity) {
                this._currentOpacity = options.opacity;
                this._currentColor = options.color;
                for (var char in this._sprites) {
                    this._sprites[char].clearEffects();
                    this._sprites[char].fill(options.color);
                    this._sprites[char].opacity(options.opacity);
                }
            }
            if (this._textShadowOn && this._textShadowDirty && this._textShadowColor) {
                for (var characterShadow in this._textShadowSprites) {
                    this._textShadowSprites[characterShadow].clearEffects();
                    this._textShadowSprites[characterShadow].addEffect(new Effects.Fill(this._textShadowColor.clone()));
                }
                this._textShadowDirty = false;
            }
            // find the current length of text in pixels
            var sprite = this.sprites[0];
            // find the current height fo the text in pixels
            var height = sprite.sheight;
            // calculate appropriate scale for font size
            var scale = options.fontSize / height;
            var length = (text.length * sprite.swidth * scale) + (text.length * options.letterSpacing);
            var currX = x;
            if (options.textAlign === Label_1.TextAlign.Left || options.textAlign === Label_1.TextAlign.Start) {
                currX = x;
            }
            else if (options.textAlign === Label_1.TextAlign.Right || options.textAlign === Label_1.TextAlign.End) {
                currX = x - length;
            }
            else if (options.textAlign === Label_1.TextAlign.Center) {
                currX = x - length / 2;
            }
            var currY = y - height * scale;
            if (options.baseAlign === Label_1.BaseAlign.Top || options.baseAlign === Label_1.BaseAlign.Hanging) {
                currY = y;
            }
            else if (options.baseAlign === Label_1.BaseAlign.Ideographic ||
                options.baseAlign === Label_1.BaseAlign.Bottom ||
                options.baseAlign === Label_1.BaseAlign.Alphabetic) {
                currY = y - height * scale;
            }
            else if (options.baseAlign === Label_1.BaseAlign.Middle) {
                currY = y - (height * scale) / 2;
            }
            for (var i = 0; i < text.length; i++) {
                var character = text[i];
                if (this._caseInsensitive) {
                    character = character.toLowerCase();
                }
                try {
                    // if text shadow
                    if (this._textShadowOn) {
                        this._textShadowSprites[character].scale.x = scale;
                        this._textShadowSprites[character].scale.y = scale;
                        this._textShadowSprites[character].draw(ctx, currX + this._shadowOffsetX, currY + this._shadowOffsetY);
                    }
                    var charSprite = this._sprites[character];
                    charSprite.scale.x = scale;
                    charSprite.scale.y = scale;
                    charSprite.draw(ctx, currX, currY);
                    currX += (charSprite.width + options.letterSpacing);
                }
                catch (e) {
                    Log_4.Logger.getInstance().error("SpriteFont Error drawing char " + character);
                }
            }
        };
        SpriteFontImpl.prototype._parseOptions = function (options) {
            return {
                fontSize: options.fontSize || 10,
                letterSpacing: options.letterSpacing || 0,
                color: options.color || Color_10.Color.Black.clone(),
                textAlign: typeof options.textAlign === undefined ? Label_1.TextAlign.Left : options.textAlign,
                baseAlign: typeof options.baseAlign === undefined ? Label_1.BaseAlign.Bottom : options.baseAlign,
                maxWidth: options.maxWidth || -1,
                opacity: options.opacity || 0
            };
        };
        return SpriteFontImpl;
    }(SpriteSheet));
    exports.SpriteFontImpl = SpriteFontImpl;
    /**
     * Sprite fonts are a used in conjunction with a [[Label]] to specify
     * a particular bitmap as a font. Note that some font features are not
     * supported by Sprite fonts.
     *
     * [[include:SpriteFonts.md]]
     */
    var SpriteFont = (function (_super) {
        __extends(SpriteFont, _super);
        function SpriteFont(imageOrConfig, alphabet, caseInsensitive, columns, rows, spWidth, spHeight) {
            return _super.call(this, imageOrConfig, alphabet, caseInsensitive, columns, rows, spWidth, spHeight) || this;
        }
        return SpriteFont;
    }(Configurable_3.Configurable(SpriteFontImpl)));
    exports.SpriteFont = SpriteFont;
});
define("Label", ["require", "exports", "Drawing/Color", "Actor", "Configurable"], function (require, exports, Color_11, Actor_4, Configurable_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Enum representing the different font size units
     * https://developer.mozilla.org/en-US/docs/Web/CSS/font-size
     */
    var FontUnit;
    (function (FontUnit) {
        /**
         * Em is a scalable unit, 1 em is equal to the current font size of the current element, parent elements can effect em values
         */
        FontUnit[FontUnit["Em"] = 0] = "Em";
        /**
         * Rem is similar to the Em, it is a scalable unit. 1 rem is eqaul to the font size of the root element
         */
        FontUnit[FontUnit["Rem"] = 1] = "Rem";
        /**
         * Pixel is a unit of length in screen pixels
         */
        FontUnit[FontUnit["Px"] = 2] = "Px";
        /**
         * Point is a physical unit length (1/72 of an inch)
         */
        FontUnit[FontUnit["Pt"] = 3] = "Pt";
        /**
         * Percent is a scalable unit similar to Em, the only difference is the Em units scale faster when Text-Size stuff
         */
        FontUnit[FontUnit["Percent"] = 4] = "Percent";
    })(FontUnit = exports.FontUnit || (exports.FontUnit = {}));
    /**
     * Enum representing the different horizontal text alignments
     */
    var TextAlign;
    (function (TextAlign) {
        /**
         * The text is left-aligned.
         */
        TextAlign[TextAlign["Left"] = 0] = "Left";
        /**
         * The text is right-aligned.
         */
        TextAlign[TextAlign["Right"] = 1] = "Right";
        /**
         * The text is centered.
         */
        TextAlign[TextAlign["Center"] = 2] = "Center";
        /**
         * The text is aligned at the normal start of the line (left-aligned for left-to-right locales,
         * right-aligned for right-to-left locales).
         */
        TextAlign[TextAlign["Start"] = 3] = "Start";
        /**
         * The text is aligned at the normal end of the line (right-aligned for left-to-right locales,
         * left-aligned for right-to-left locales).
         */
        TextAlign[TextAlign["End"] = 4] = "End";
    })(TextAlign = exports.TextAlign || (exports.TextAlign = {}));
    /**
     * Enum representing the different baseline text alignments
     */
    var BaseAlign;
    (function (BaseAlign) {
        /**
         * The text baseline is the top of the em square.
         */
        BaseAlign[BaseAlign["Top"] = 0] = "Top";
        /**
         * The text baseline is the hanging baseline.  Currently unsupported; this will act like
         * alphabetic.
         */
        BaseAlign[BaseAlign["Hanging"] = 1] = "Hanging";
        /**
         * The text baseline is the middle of the em square.
         */
        BaseAlign[BaseAlign["Middle"] = 2] = "Middle";
        /**
         * The text baseline is the normal alphabetic baseline.
         */
        BaseAlign[BaseAlign["Alphabetic"] = 3] = "Alphabetic";
        /**
         * The text baseline is the ideographic baseline; this is the bottom of
         * the body of the characters, if the main body of characters protrudes
         * beneath the alphabetic baseline.  Currently unsupported; this will
         * act like alphabetic.
         */
        BaseAlign[BaseAlign["Ideographic"] = 4] = "Ideographic";
        /**
         * The text baseline is the bottom of the bounding box.  This differs
         * from the ideographic baseline in that the ideographic baseline
         * doesn't consider descenders.
         */
        BaseAlign[BaseAlign["Bottom"] = 5] = "Bottom";
    })(BaseAlign = exports.BaseAlign || (exports.BaseAlign = {}));
    /**
     * Enum representing the different possible font styles
     */
    var FontStyle;
    (function (FontStyle) {
        FontStyle[FontStyle["Normal"] = 0] = "Normal";
        FontStyle[FontStyle["Italic"] = 1] = "Italic";
        FontStyle[FontStyle["Oblique"] = 2] = "Oblique";
    })(FontStyle = exports.FontStyle || (exports.FontStyle = {}));
    /**
     * @hidden
     */
    var LabelImpl = (function (_super) {
        __extends(LabelImpl, _super);
        /**
         * @param text        The text of the label
         * @param x           The x position of the label
         * @param y           The y position of the label
         * @param fontFamily  Use any valid CSS font string for the label's font. Web fonts are supported. Default is `10px sans-serif`.
         * @param spriteFont  Use an Excalibur sprite font for the label's font, if a SpriteFont is provided it will take precedence
         * over a css font.
         */
        function LabelImpl(textOrConfig, x, y, fontFamily, spriteFont) {
            var _this = _super.call(this, textOrConfig && typeof textOrConfig === 'object' ? {
                x: textOrConfig.x,
                y: textOrConfig.y
            } : { x: x, y: y }) || this;
            /**
             * Sets or gets the bold property of the label's text, by default it's false
             */
            _this.bold = false;
            /**
             * The font size in the selected units, default is 10 (default units is pixel)
             */
            _this.fontSize = 10;
            /**
             * The font style for this label, the default is [[FontStyle.Normal]]
             */
            _this.fontStyle = FontStyle.Normal;
            /**
             * The css units for a font size such as px, pt, em (SpriteFont only support px), by default is 'px';
             */
            _this.fontUnit = FontUnit.Px;
            /**
             * Gets or sets the horizontal text alignment property for the label.
             */
            _this.textAlign = TextAlign.Left;
            /**
             * Gets or sets the baseline alignment property for the label.
             */
            _this.baseAlign = BaseAlign.Bottom;
            /**
             * Gets or sets the letter spacing on a Label. Only supported with Sprite Fonts.
             */
            _this.letterSpacing = 0; //px
            /**
             * Whether or not the [[SpriteFont]] will be case-sensitive when matching characters.
             */
            _this.caseInsensitive = true;
            var text = '';
            if (textOrConfig && typeof textOrConfig === 'object') {
                fontFamily = textOrConfig.fontFamily;
                spriteFont = textOrConfig.spriteFont;
                text = textOrConfig.text;
            }
            else {
                text = textOrConfig;
            }
            _this.text = text || '';
            _this.color = Color_11.Color.Black.clone();
            _this.spriteFont = spriteFont;
            _this.collisionType = Actor_4.CollisionType.PreventCollision;
            _this.fontFamily = fontFamily || 'sans-serif'; // coalesce to default canvas font
            _this._textShadowOn = false;
            _this._shadowOffsetX = 0;
            _this._shadowOffsetY = 0;
            if (spriteFont) {
                //this._textSprites = spriteFont.getTextSprites();
            }
            return _this;
        }
        /**
         * Returns the width of the text in the label (in pixels);
         * @param ctx  Rendering context to measure the string with
         */
        LabelImpl.prototype.getTextWidth = function (ctx) {
            var oldFont = ctx.font;
            ctx.font = this._fontString;
            var width = ctx.measureText(this.text).width;
            ctx.font = oldFont;
            return width;
        };
        // TypeScript doesn't support string enums :(
        LabelImpl.prototype._lookupFontUnit = function (fontUnit) {
            switch (fontUnit) {
                case FontUnit.Em:
                    return 'em';
                case FontUnit.Rem:
                    return 'rem';
                case FontUnit.Pt:
                    return 'pt';
                case FontUnit.Px:
                    return 'px';
                case FontUnit.Percent:
                    return '%';
                default:
                    return 'px';
            }
        };
        LabelImpl.prototype._lookupTextAlign = function (textAlign) {
            switch (textAlign) {
                case TextAlign.Left:
                    return 'left';
                case TextAlign.Right:
                    return 'right';
                case TextAlign.Center:
                    return 'center';
                case TextAlign.End:
                    return 'end';
                case TextAlign.Start:
                    return 'start';
                default:
                    return 'start';
            }
        };
        LabelImpl.prototype._lookupBaseAlign = function (baseAlign) {
            switch (baseAlign) {
                case BaseAlign.Alphabetic:
                    return 'alphabetic';
                case BaseAlign.Bottom:
                    return 'bottom';
                case BaseAlign.Hanging:
                    return 'hangin';
                case BaseAlign.Ideographic:
                    return 'ideographic';
                case BaseAlign.Middle:
                    return 'middle';
                case BaseAlign.Top:
                    return 'top';
                default:
                    return 'alphabetic';
            }
        };
        LabelImpl.prototype._lookupFontStyle = function (fontStyle) {
            var boldstring = this.bold ? ' bold' : '';
            switch (fontStyle) {
                case FontStyle.Italic:
                    return 'italic' + boldstring;
                case FontStyle.Normal:
                    return 'normal' + boldstring;
                case FontStyle.Oblique:
                    return 'oblique' + boldstring;
                default:
                    return 'normal' + boldstring;
            }
        };
        /**
         * Sets the text shadow for sprite fonts
         * @param offsetX      The x offset in pixels to place the shadow
         * @param offsetY      The y offset in pixels to place the shadow
         * @param shadowColor  The color of the text shadow
         */
        LabelImpl.prototype.setTextShadow = function (offsetX, offsetY, shadowColor) {
            this.spriteFont.setTextShadow(offsetX, offsetY, shadowColor);
        };
        /**
         * Toggles text shadows on or off, only applies when using sprite fonts
         */
        LabelImpl.prototype.useTextShadow = function (on) {
            this.spriteFont.useTextShadow(on);
        };
        /**
         * Clears the current text shadow
         */
        LabelImpl.prototype.clearTextShadow = function () {
            this._textShadowOn = false;
            this._shadowOffsetX = 0;
            this._shadowOffsetY = 0;
        };
        LabelImpl.prototype.update = function (engine, delta) {
            _super.prototype.update.call(this, engine, delta);
        };
        LabelImpl.prototype.draw = function (ctx, delta) {
            ctx.save();
            ctx.translate(this.pos.x, this.pos.y);
            ctx.scale(this.scale.x, this.scale.y);
            ctx.rotate(this.rotation);
            if (this._textShadowOn) {
                ctx.save();
                ctx.translate(this._shadowOffsetX, this._shadowOffsetY);
                this._fontDraw(ctx);
                ctx.restore();
            }
            this._fontDraw(ctx);
            _super.prototype.draw.call(this, ctx, delta);
            ctx.restore();
        };
        LabelImpl.prototype._fontDraw = function (ctx) {
            if (this.spriteFont) {
                this.spriteFont.draw(ctx, this.text, 0, 0, {
                    color: this.color.clone(),
                    baseAlign: this.baseAlign,
                    textAlign: this.textAlign,
                    fontSize: this.fontSize,
                    letterSpacing: this.letterSpacing,
                    opacity: this.opacity
                });
            }
            else {
                var oldAlign = ctx.textAlign;
                var oldTextBaseline = ctx.textBaseline;
                ctx.textAlign = this._lookupTextAlign(this.textAlign);
                ctx.textBaseline = this._lookupBaseAlign(this.baseAlign);
                if (this.color) {
                    this.color.a = this.opacity;
                }
                ctx.fillStyle = this.color.toString();
                ctx.font = this._fontString;
                if (this.maxWidth) {
                    ctx.fillText(this.text, 0, 0, this.maxWidth);
                }
                else {
                    ctx.fillText(this.text, 0, 0);
                }
                ctx.textAlign = oldAlign;
                ctx.textBaseline = oldTextBaseline;
            }
        };
        Object.defineProperty(LabelImpl.prototype, "_fontString", {
            get: function () {
                return this._lookupFontStyle(this.fontStyle) + " " + this.fontSize + this._lookupFontUnit(this.fontUnit) + " " + this.fontFamily;
            },
            enumerable: true,
            configurable: true
        });
        LabelImpl.prototype.debugDraw = function (ctx) {
            _super.prototype.debugDraw.call(this, ctx);
        };
        return LabelImpl;
    }(Actor_4.Actor));
    exports.LabelImpl = LabelImpl;
    /**
     * Labels are the way to draw small amounts of text to the screen. They are
     * actors and inherit all of the benefits and capabilities.
     *
     * [[include:Labels.md]]
     */
    var Label = (function (_super) {
        __extends(Label, _super);
        function Label(textOrConfig, x, y, fontFamily, spriteFont) {
            return _super.call(this, textOrConfig, x, y, fontFamily, spriteFont) || this;
        }
        return Label;
    }(Configurable_4.Configurable(LabelImpl)));
    exports.Label = Label;
});
define("Interfaces/IAudio", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Interfaces/IAudioImplementation", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Resources/Sound", ["require", "exports", "Util/Log", "Util/Util", "Promises"], function (require, exports, Log_5, Util, Promises_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // set up audio context reference
    // when we introduce multi-tracking, we may need to move this to a factory method
    if (window.AudioContext) {
        var audioContext = new window.AudioContext();
    }
    /**
     * An audio implementation for HTML5 audio.
     */
    var AudioTag = (function () {
        function AudioTag() {
            this.responseType = 'blob';
        }
        /**
         * Transforms raw Blob data into a object URL for use in audio tag
         */
        AudioTag.prototype.processData = function (data) {
            var url = URL.createObjectURL(data);
            return Promises_5.Promise.resolve(url);
        };
        /**
         * Creates a new instance of an audio tag referencing the provided audio URL
         */
        AudioTag.prototype.createInstance = function (url) {
            return new AudioTagInstance(url);
        };
        return AudioTag;
    }());
    exports.AudioTag = AudioTag;
    /**
     * An audio implementation for Web Audio API.
     */
    var WebAudio = (function () {
        function WebAudio() {
            this._logger = Log_5.Logger.getInstance();
            this.responseType = 'arraybuffer';
        }
        /**
         * Processes raw arraybuffer data and decodes into WebAudio buffer (async).
         */
        WebAudio.prototype.processData = function (data) {
            var _this = this;
            var complete = new Promises_5.Promise();
            audioContext.decodeAudioData(data, function (buffer) {
                complete.resolve(buffer);
            }, function () {
                _this._logger.error('Unable to decode ' +
                    ' this browser may not fully support this format, or the file may be corrupt, ' +
                    'if this is an mp3 try removing id3 tags and album art from the file.');
                complete.resolve(undefined);
            });
            return complete;
        };
        /**
         * Creates a new WebAudio AudioBufferSourceNode to play a sound instance
         */
        WebAudio.prototype.createInstance = function (buffer) {
            return new WebAudioInstance(buffer);
        };
        /**
         * Play an empty sound to unlock Safari WebAudio context. Call this function
         * right after a user interaction event. Typically used by [[PauseAfterLoader]]
         * @source https://paulbakaus.com/tutorials/html5/web-audio-on-ios/
         */
        WebAudio.unlock = function () {
            if (WebAudio._unlocked || !audioContext) {
                return;
            }
            // create empty buffer and play it
            var buffer = audioContext.createBuffer(1, 1, 22050);
            var source = audioContext.createBufferSource();
            var ended = false;
            source.buffer = buffer;
            source.connect(audioContext.destination);
            source.onended = function () { return ended = true; };
            if (source.noteOn) {
                // deprecated
                source.noteOn(0);
            }
            else {
                source.start(0);
            }
            // by checking the play state after some time, we know if we're really unlocked
            setTimeout(function () {
                if (source.playbackState) {
                    var legacySource = source;
                    if (legacySource.playbackState === legacySource.PLAYING_STATE ||
                        legacySource.playbackState === legacySource.FINISHED_STATE) {
                        WebAudio._unlocked = true;
                    }
                }
                else {
                    if (audioContext.currentTime > 0 || ended) {
                        WebAudio._unlocked = true;
                    }
                }
            }, 0);
        };
        WebAudio.isUnlocked = function () {
            return this._unlocked;
        };
        return WebAudio;
    }());
    WebAudio._unlocked = false;
    exports.WebAudio = WebAudio;
    /**
     * Factory method that gets the audio implementation to use
     */
    function getAudioImplementation() {
        if (window.AudioContext) {
            return new WebAudio();
        }
        else {
            return new AudioTag();
        }
    }
    exports.getAudioImplementation = getAudioImplementation;
    ;
    /**
     * The [[Sound]] object allows games built in Excalibur to load audio
     * components, from soundtracks to sound effects. [[Sound]] is an [[ILoadable]]
     * which means it can be passed to a [[Loader]] to pre-load before a game or level.
     *
     * [[include:Sounds.md]]
     */
    var Sound = (function () {
        /**
         * @param paths A list of audio sources (clip.wav, clip.mp3, clip.ogg) for this audio clip. This is done for browser compatibility.
         */
        function Sound() {
            var paths = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                paths[_i] = arguments[_i];
            }
            this._logger = Log_5.Logger.getInstance();
            this._data = null;
            this._tracks = [];
            this._isLoaded = false;
            this._isPaused = false;
            this._loop = false;
            this._volume = 1.0;
            this.onprogress = function () { return; };
            this.oncomplete = function () { return; };
            this.onerror = function () { return; };
            this._wasPlayingOnHidden = false;
            /* Chrome : MP3, WAV, Ogg
               * Firefox : WAV, Ogg,
               * IE : MP3, WAV coming soon
               * Safari MP3, WAV, Ogg
               */
            this.path = '';
            for (var _a = 0, paths_1 = paths; _a < paths_1.length; _a++) {
                var path = paths_1[_a];
                if (Sound.canPlayFile(path)) {
                    this.path = path;
                    break;
                }
            }
            if (!this.path) {
                this._logger.warn('This browser does not support any of the audio files specified:', paths.join(', '));
                this._logger.warn('Attempting to use', paths[0]);
                this.path = paths[0]; // select the first specified
            }
            this.sound = getAudioImplementation();
        }
        /**
         * Whether or not the browser can play this file as HTML5 Audio
         */
        Sound.canPlayFile = function (file) {
            try {
                var a = new Audio();
                var filetype = /.*\.([A-Za-z0-9]+)$/;
                var type = file.match(filetype)[1];
                if (a.canPlayType('audio/' + type)) {
                    return true;
                }
                else {
                    return false;
                }
            }
            catch (e) {
                Log_5.Logger.getInstance().warn('Cannot determine audio support, assuming no support for the Audio Tag', e);
                return false;
            }
        };
        Sound.prototype.wireEngine = function (engine) {
            var _this = this;
            if (engine) {
                this._engine = engine;
                this._engine.on('hidden', function () {
                    if (engine.pauseAudioWhenHidden && _this.isPlaying()) {
                        _this._wasPlayingOnHidden = true;
                        _this.pause();
                    }
                });
                this._engine.on('visible', function () {
                    if (engine.pauseAudioWhenHidden && _this._wasPlayingOnHidden) {
                        _this.play();
                        _this._wasPlayingOnHidden = false;
                    }
                });
            }
        };
        /**
         * Returns how many instances of the sound are currently playing
         */
        Sound.prototype.instanceCount = function () {
            return this._tracks.length;
        };
        /**
         * Sets the volume of the sound clip
         * @param volume  A volume value between 0-1.0
         */
        Sound.prototype.setVolume = function (volume) {
            this._volume = volume;
            for (var _i = 0, _a = this._tracks; _i < _a.length; _i++) {
                var track = _a[_i];
                track.setVolume(volume);
            }
            this._logger.debug('Set volume for all instances of sound', this.path, 'to', volume);
        };
        /**
         * Indicates whether the clip should loop when complete
         * @param loop  Set the looping flag
         */
        Sound.prototype.setLoop = function (loop) {
            this._loop = loop;
            for (var _i = 0, _a = this._tracks; _i < _a.length; _i++) {
                var track = _a[_i];
                track.setLoop(loop);
            }
            this._logger.debug('Set loop for all instances of sound', this.path, 'to', loop);
        };
        /**
         * Whether or not the sound is playing right now
         */
        Sound.prototype.isPlaying = function () {
            return this._tracks.some(function (t) { return t.isPlaying(); });
        };
        /**
         * Play the sound, returns a promise that resolves when the sound is done playing
         * An optional volume argument can be passed in to play the sound. Max volume is 1.0
         */
        Sound.prototype.play = function (volume) {
            var _this = this;
            if (this._isLoaded) {
                var resumed = [];
                // ensure we resume *current* tracks (if paused)
                for (var _i = 0, _a = this._tracks; _i < _a.length; _i++) {
                    var track = _a[_i];
                    resumed.push(track.play());
                }
                // when paused, don't start playing new track
                if (this._isPaused) {
                    this._isPaused = false;
                    this._logger.debug('Resuming paused instances for sound', this.path, this._tracks);
                    // resolve when resumed tracks are done
                    return Promises_5.Promise.join(resumed);
                }
                // push a new track
                var newTrack = this.sound.createInstance(this._data);
                newTrack.setLoop(this._loop);
                if (volume) {
                    newTrack.setVolume(Util.clamp(volume, 0.0, 1.0));
                }
                else {
                    newTrack.setVolume(this._volume);
                }
                this._tracks.push(newTrack);
                this._logger.debug('Playing new instance for sound', this.path);
                return newTrack.play().then(function () {
                    // when done, remove track
                    _this._tracks.splice(_this._tracks.indexOf(newTrack), 1);
                    return true;
                });
            }
            else {
                return Promises_5.Promise.resolve(true);
            }
        };
        /**
         * Stop the sound, and do not rewind
         */
        Sound.prototype.pause = function () {
            for (var _i = 0, _a = this._tracks; _i < _a.length; _i++) {
                var track = _a[_i];
                track.pause();
            }
            this._isPaused = true;
            this._logger.debug('Paused all instances of sound', this.path);
        };
        /**
         * Stop the sound and rewind
         */
        Sound.prototype.stop = function () {
            this._isPaused = false;
            var tracks = this._tracks.concat([]);
            for (var _i = 0, tracks_1 = tracks; _i < tracks_1.length; _i++) {
                var track = tracks_1[_i];
                track.stop();
            }
            this._logger.debug('Stopped all instances of sound', this.path);
        };
        /**
         * Returns true if the sound is loaded
         */
        Sound.prototype.isLoaded = function () {
            return this._isLoaded;
        };
        /**
         * Begins loading the sound and returns a promise to be resolved on completion
         */
        Sound.prototype.load = function () {
            var _this = this;
            var complete = new Promises_5.Promise();
            if (!!this.getData()) {
                this._logger.debug('Already have data for audio resource', this.path);
                complete.resolve(this.sound);
                this.oncomplete();
                return complete;
            }
            this._logger.debug('Started loading sound', this.path);
            try {
                this._fetchResource(function (request) {
                    if (request.status !== 200) {
                        _this._logger.error('Failed to load audio resource ', _this.path, ' server responded with error code', request.status);
                        _this.onerror(request.response);
                        complete.resolve(null);
                        return;
                    }
                    // load sound
                    _this.setData(request.response).then(function () {
                        _this.oncomplete();
                        _this._logger.debug('Completed loading sound', _this.path);
                        complete.resolve(_this.sound);
                    }, function (e) { return complete.resolve(e); });
                });
            }
            catch (e) {
                this._logger.error('Error loading sound! If this is a cross origin error, \
            you must host your sound with your html and javascript.');
                this.onerror(e);
                complete.resolve(e);
            }
            return complete;
        };
        /* istanbul ignore next */
        Sound.prototype._fetchResource = function (onload) {
            var request = new XMLHttpRequest();
            request.open('GET', this.path, true);
            request.responseType = this.sound.responseType;
            request.onprogress = this.onprogress;
            request.onerror = this.onerror;
            request.onload = function () { return onload(request); };
            request.send();
        };
        /**
         * Gets the raw sound data (e.g. blob URL or AudioBuffer)
         */
        Sound.prototype.getData = function () {
            return this._data;
        };
        /**
         * Sets raw sound data and returns a Promise that is resolved when sound data is processed
         *
         * @param data The XHR data for the sound implementation to process (Blob or ArrayBuffer)
         */
        Sound.prototype.setData = function (data) {
            var _this = this;
            return this.sound.processData(data).then(function (data) {
                _this._isLoaded = true;
                _this._data = _this.processData(data);
                return data;
            });
        };
        /**
         * Set the raw sound data (e.g. blob URL or AudioBuffer)
         */
        Sound.prototype.processData = function (data) {
            return data;
        };
        return Sound;
    }());
    exports.Sound = Sound;
    /**
     * Internal class representing a HTML5 audio instance
     */
    /* istanbul ignore next */
    var AudioTagInstance = (function () {
        function AudioTagInstance(src) {
            this._isPlaying = false;
            this._isPaused = false;
            this._loop = false;
            this._audioElement = new Audio(src);
        }
        AudioTagInstance.prototype.isPlaying = function () {
            return this._isPlaying;
        };
        Object.defineProperty(AudioTagInstance.prototype, "loop", {
            get: function () {
                return this._loop;
            },
            enumerable: true,
            configurable: true
        });
        AudioTagInstance.prototype.setLoop = function (value) {
            this._loop = value;
            this._audioElement.loop = value;
            this._wireUpOnEnded();
        };
        AudioTagInstance.prototype.setVolume = function (value) {
            this._audioElement.volume = Util.clamp(value, 0, 1.0);
        };
        AudioTagInstance.prototype.play = function () {
            if (this._isPaused) {
                this._resume();
            }
            else if (!this._isPlaying) {
                this._start();
            }
            return this._playingPromise;
        };
        AudioTagInstance.prototype._start = function () {
            this._audioElement.load();
            this._audioElement.loop = this._loop;
            this._audioElement.play();
            this._isPlaying = true;
            this._isPaused = false;
            this._playingPromise = new Promises_5.Promise();
            this._wireUpOnEnded();
        };
        AudioTagInstance.prototype._resume = function () {
            if (!this._isPaused) {
                return;
            }
            this._audioElement.play();
            this._isPaused = false;
            this._isPlaying = true;
            this._wireUpOnEnded();
        };
        AudioTagInstance.prototype.pause = function () {
            if (!this._isPlaying) {
                return;
            }
            this._audioElement.pause();
            this._isPaused = true;
            this._isPlaying = false;
        };
        AudioTagInstance.prototype.stop = function () {
            if (!this._isPlaying) {
                return;
            }
            this._audioElement.pause();
            this._audioElement.currentTime = 0;
            this._handleOnEnded();
        };
        AudioTagInstance.prototype._wireUpOnEnded = function () {
            var _this = this;
            if (!this._loop) {
                this._audioElement.onended = function () { return _this._handleOnEnded(); };
            }
        };
        AudioTagInstance.prototype._handleOnEnded = function () {
            this._isPlaying = false;
            this._isPaused = false;
            this._playingPromise.resolve(true);
        };
        return AudioTagInstance;
    }());
    /**
     * Internal class representing a Web Audio AudioBufferSourceNode instance
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API
     */
    /* istanbul ignore next */
    var WebAudioInstance = (function () {
        function WebAudioInstance(_buffer) {
            this._buffer = _buffer;
            this._volumeNode = audioContext.createGain();
            this._isPlaying = false;
            this._isPaused = false;
            this._loop = false;
            /**
             * Current playback offset (in seconds)
             */
            this._currentOffset = 0;
        }
        WebAudioInstance.prototype.isPlaying = function () {
            return this._isPlaying;
        };
        WebAudioInstance.prototype.setVolume = function (value) {
            if (this._volumeNode.gain.setTargetAtTime) {
                this._volumeNode.gain.setTargetAtTime(Util.clamp(value, 0, 1.0), audioContext.currentTime, 0);
            }
            else {
                this._volumeNode.gain.value = Util.clamp(value, 0, 1.0);
            }
        };
        WebAudioInstance.prototype.setLoop = function (value) {
            this._loop = value;
            if (this._bufferSource) {
                this._bufferSource.loop = value;
                this._wireUpOnEnded();
            }
        };
        WebAudioInstance.prototype.play = function () {
            if (this._isPaused) {
                this._resume();
            }
            else if (!this._isPlaying) {
                this._start();
            }
            return this._playingPromise;
        };
        WebAudioInstance.prototype._start = function () {
            this._volumeNode.connect(audioContext.destination);
            this._createBufferSource();
            this._bufferSource.start(0, 0);
            this._startTime = new Date().getTime();
            this._currentOffset = 0;
            this._isPlaying = true;
            this._isPaused = false;
            this._playingPromise = new Promises_5.Promise();
            this._wireUpOnEnded();
        };
        WebAudioInstance.prototype._resume = function () {
            if (!this._isPaused) {
                return;
            }
            // a buffer source can only be started once
            // so we need to dispose of the previous instance before
            // "resuming" the next one
            this._bufferSource.onended = null; // dispose of any previous event handler
            this._createBufferSource();
            var duration = (1 / this._bufferSource.playbackRate.value) * this._buffer.duration;
            this._bufferSource.start(0, this._currentOffset % duration);
            this._isPaused = false;
            this._isPlaying = true;
            this._wireUpOnEnded();
        };
        WebAudioInstance.prototype._createBufferSource = function () {
            this._bufferSource = audioContext.createBufferSource();
            this._bufferSource.buffer = this._buffer;
            this._bufferSource.loop = this._loop;
            this._bufferSource.playbackRate.value = 1.0;
            this._bufferSource.connect(this._volumeNode);
        };
        WebAudioInstance.prototype.pause = function () {
            if (!this._isPlaying) {
                return;
            }
            this._bufferSource.stop(0);
            // Playback rate will be a scale factor of how fast/slow the audio is being played
            // default is 1.0
            // we need to invert it to get the time scale
            var pbRate = 1 / (this._bufferSource.playbackRate.value || 1.0);
            this._currentOffset = ((new Date().getTime() - this._startTime) * pbRate) / 1000; // in seconds
            this._isPaused = true;
            this._isPlaying = false;
        };
        WebAudioInstance.prototype.stop = function () {
            if (!this._isPlaying) {
                return;
            }
            this._bufferSource.stop(0);
            // handler will not be wired up if we were looping
            if (!this._bufferSource.onended) {
                this._handleOnEnded();
            }
            this._currentOffset = 0;
            this._isPlaying = false;
            this._isPaused = false;
        };
        WebAudioInstance.prototype._wireUpOnEnded = function () {
            var _this = this;
            if (!this._loop) {
                this._bufferSource.onended = function () { return _this._handleOnEnded(); };
            }
        };
        WebAudioInstance.prototype._handleOnEnded = function () {
            // pausing calls stop(0) which triggers onended event
            // so we don't "resolve" yet (when we resume we'll try again)
            if (!this._isPaused) {
                this._isPlaying = false;
                this._playingPromise.resolve(true);
            }
        };
        return WebAudioInstance;
    }());
});
define("Interfaces/ILoader", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Loader", ["require", "exports", "Drawing/Color", "Resources/Sound", "Util/Log", "Promises", "Class", "Util/DrawUtil"], function (require, exports, Color_12, Sound_1, Log_6, Promises_6, Class_3, DrawUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Pre-loading assets
     *
     * The loader provides a mechanism to preload multiple resources at
     * one time. The loader must be passed to the engine in order to
     * trigger the loading progress bar.
     *
     * The [[Loader]] itself implements [[ILoadable]] so you can load loaders.
     *
     * ## Example: Pre-loading resources for a game
     *
     * ```js
     * // create a loader
     * var loader = new ex.Loader();
     *
     * // create a resource dictionary (best practice is to keep a separate file)
     * var resources = {
     *   TextureGround: new ex.Texture("/images/textures/ground.png"),
     *   SoundDeath: new ex.Sound("/sound/death.wav", "/sound/death.mp3")
     * };
     *
     * // loop through dictionary and add to loader
     * for (var loadable in resources) {
     *   if (resources.hasOwnProperty(loadable)) {
     *     loader.addResource(resources[loadable]);
     *   }
     * }
     *
     * // start game
     * game.start(loader).then(function () {
     *   console.log("Game started!");
     * });
     * ```
     */
    var Loader = (function (_super) {
        __extends(Loader, _super);
        /**
         * @param loadables  Optionally provide the list of resources you want to load at constructor time
         */
        function Loader(loadables) {
            var _this = _super.call(this) || this;
            _this._resourceList = [];
            _this._index = 0;
            _this._resourceCount = 0;
            _this._numLoaded = 0;
            _this._progressCounts = {};
            _this._totalCounts = {};
            // logo drawing stuff
            /* tslint:disable:max-line-length */
            // base64 string encoding of the excalibur logo (logo-white.png)
            _this.logo = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAdQAAAB2CAYAAABxhGI9AAAACXBIWXMAAAsSAAALEgHS3X78AAAKnUlEQVR42u3dP2wjSx0H8N8hJIonIRmJjsq0SBR+BQ1dcqKhe0lD77SvSwpKkJKGPulpktfRIMUdEqKIqV57rpAokM4dbSiyq7ONPTP7x39ifz7SFbnEnp3xer47O7uzH15fXwMA6OYHmgAABCoACFQAEKgAgEAFAIEKAAIVAAQqACBQAUCgAoBABQCBCgAIVAAQqAAgUAFAoAIAAhUABCoACFQAEKgAgECFLbmOiNeFf2PbAyz68Pr6qhUgbRwR92v+/zwiJrYHMEKFMmcN///UtgcQqFBk1PD/97U9Qx8VCFSgu4EmAIEKAAIVAAQqACBQ4Z25jojP8eX+0WtNAgIVaOY+Im5j+eKh24h41jQgUIEyZ7F5NaPU7wCBCiwYd/w9cOB+qAlgJ3KLLow0EV198803RWvJfvfddx+0lhEqHKu5JgAjVCBvlhmFzjQRXUekHz9+TP79y8uLRjNChXfvoePvAYEKxNtj1e42/O5JoIJABcrdRMRVLM+X3kTEpaaB988cKuzWg9EobTWdMx0Oly8uN4dqhAoARqgnaN3arHfqu7OyH8ItKLVB/P+CEfMTHyGPY3npx1m8zWGDEeoBfUk/xdti57dr/r1Wv2+6EPow3tZ5rRdS72s1neuF97xvWd+XTH0/V+UMttDWqbI/r2nrxfp+jv2uSjSO7S+OXy/A/3lN+9xX5T5HxEUPZZ0tfB71+w57eJ/HFu+z+jkv1u92YX9fbI/HhX3JA9rp5MPr66tWaG9UfUGbrHIzi7cLUyYFf/tpTady03EEeL8mUJ6i7MKYNvWNqr4Pe2jradXO60LrvPAz2PQ5RPX684ah8dxD+2zantnCgVipSVV+m/tgB9W2DDq2Sx/vM95wcHhZhWVJm8yrv58cSgfTdc70+++/X/r522+/tUKSEepBqo+om4ZLPerMjUwuNnQCtx1GWJtee1FwdD5uWd86xLs8UaVt2aNEO1/saZ/Z5rYMW4zq6v34rGV9Bg3q2eZ9SkeNm9qwyUh30OPIHYFKx5FG03C7znSOqYBq+qW/zpQ3anH037TNHluG6f0WPsPhHvab4QFty7ogOeuxDYcNy2/zu2214WNYWxmBurNO8bGn97pNBOO8xy/9uCorZZ4I2r4C7aJgO7ZV9iE49Dm6NvOWx+pWE9CUq3zbdTp9doz38TbXtzqH9RT5CyWe422OaZoZGeZCabrhPQY9HjwsjpTvCg4YtlE2+Ta/j2bzn8fqrDqgm+6yUHOmAvWUjAtGhbNYvsBknDnqH1Qhc7VmxHgeb/NbudA5j/UXlYwif2p6luhAc9teu1npiHKnDs8if6tCm7JLX3NKpgttXe9ruc9mHMd7a83iwdxF5vt8tutARaCeklRnNK9C8WnNF7geJQ4T4XG3JhSnVdilQrG+yOnrlVHfsEGYzhNBn7Lu6tS7+HJafJQ4EMiNlNqWXZ9WPvVgnVYHG5M1ByDXkT6leX2EgTqJtyt45yv7S2qO3sEZjZhDLXeR+YKdJ0Zdk8QocvH9N732KrNtq+FZ/zzIHABcJrYpd+Xv14lOd5ap76SgrduW/VTQ1qcQpqnbgu4ifZvUMNpd9XuoZmvCtPaQ2Y/BCHVLgbrJTeRPDdVf6pfMKDU2fOkHmVFFfXr3MsouLsnNvV5kRoe5+s431PeuoKPqWnaurY/ZPBEeqwceN4l96iwO6H7Mjq4y7VGPVNe10VaZMzVCPVWpI/Z6FZbcv5fMqGCU+dLfFGzj58jP8+bCdJCo7yzKTwdOF0bu9Ug7V4c+yz7FJfYeGoysUss0HssIdVZwYLDujMqlESoCdTtGsZtbHnJBeNdDSJSs0jTKdMJN1HNX54Wv7bvsU9NkVJVa13dX+/wuArV0X/l5RHyo/lnfF4G6p6DrS0kHdtXhy35TGErDPYZUn2WfWqDOo/lVqdMD2O/hKJhD7S/odukymq9s02QN4EEPR/zbaOumZc+r15zK1Zqznl9jsfiemTM1QmV3HUuTkedlg9HIQzRbUD93dfC+2tpj2fIHEH2+RqCCQH13gZq7hWXTNpVu19OB1fc9nQ0AKOKUb5lU0P1kDyOneoWk0lOZ9cIP0x7qu8+2BhCoR2wYu1+e7DmaXzBSsu5vaX1ne2zrpmUPTmxf7PM1Dm4y/vC7ny7Nif7+z/9ZmtM0Z3panPLtPmra9f16bcK0Dpbnwk43Vd/RHtu6zfNQTy1QBy3aqG2g9nVmxml+BOoJyT3NpWmn9xhfFnu4bvDa+44BXhqqfdf3uUF9+yz77AT31Yue2mjecYQ62NLfgkA9ghHqLNEhNem4H1c6vdyDxhf/bpz5m4coW/c39wi6VH2bPtHlcaV9cvXts+zxCe6rTeqc2ndL7uGd93QwM9bFcAzMoZZ7SgTBbWx+asui61h/iq1+RmjqdbnQXQ3T1DNQ63V/U9ucqm/pMzPb1rePsk/1iTOjgvatR4W3Lc8ULB78pELyrnAfeTcj1NU509/86mfJ33/8+Mf00a05UyPUEw7UVCeWG/WNEiExyHRMt5ltW30izUPk18ytt7lNfc8i//DvtvXto+ySA5BjljsLUF8lPkqMPEtW1JomDsiGBZ9Byb4NAvUITSN9GuwsIj6t6UTOqk7jJREkmzqli8xIs96udSO20sX0H1vW92IL9e1a9rgqVyf91gbPsTy9UD9n9lOkT8k+RfkFR5PMNqxOcdSf32PBvg3vilO+zdxE+okx9Wm0ph36XYsRZCpMF993GOk5qvqB3Dct6jvssb67KvuUNJ3frw92bhr8/STSF0JdRPMLpUCgnsgo9S76PZ246ZFk1wWvK5m3vVoYvW1Sz7nN91jfXbQ1ZQc7TW6HeaoOalypG/8/p/rP1aNAc6ZHzSnfdqPUPhdy2PQw6Nz9gSVhuhiqueUHR3uu7y7K3rdDX4u46ZrPbUa0IFBZ0seKQ3XQTRt2vm3W/a2DbNKys++rvm3ep6+y1x2UdP3bWU9lzra47U1GmlctX/sQ23t+aOlByLTh/4NAPaCRxtcdO5HLSJ/6vNtCwGx67VPmPbvWd1q9frKHtp4kAqRJ2HR9j762JfX3bZ//elPtj13PPDx1+D5tqk/Xi6NO8SHz7MmH19dXrdBNfVFP6T2PT1UHNit87/t4m5+aRH+nQBdvqyhZDKJLfZs8h7XPsqdV2ZOV+tanKB8aln0dyxdAXbV4j4gvt4oMOrbP6vbU73NW7TMlbdTnPrWpfqXfh9HKZ9vke7KuTeZRNtXRSe6+1FV//ce/ln5eXfsXgcqXzr6+9261M3moOoa7E6nvTZTfy7iNsmfb7kjfgXGsvxe0vihsEts9HTquPpt1q1vtahu2TqAiUAEEKj0zhwoARqgAu/OnX/442WH+9xc/Wvr58re/Tr7f41/+ZsRqhAoACFQAEKgAcHjMoQJskJsz/eqrr5Z+vvr7v5fmQFevAl5lztQIFQAQqAAgUAHgIJlDBdhgdQ41N2eKESoAIFABQKACwFEwhwoARqgAIFABQKACAAIVAAQqAAhUABCoAIBABQCBCgACFQAEKgAgUAFAoAKAQAUAgQoACFQAEKgAIFABQKACAAIVAAQqAAhUABCoAIBABQCBCgACFQAQqAAgUAFAoAKAQAUAlvwPcFDns1DsH4sAAAAASUVORK5CYII=';
            /* tslint:enable:max-line-length */
            _this.logoWidth = 468;
            _this.logoHeight = 118;
            _this.backgroundColor = '#176BAA';
            _this.getData = function () { return; };
            _this.setData = function () { return; };
            _this.processData = function () { return; };
            _this.onprogress = function (e) {
                Log_6.Logger.getInstance().debug('[ex.Loader] Loading ' + (100 * e.loaded / e.total).toFixed(0));
                return;
            };
            _this.oncomplete = function () { return; };
            _this.onerror = function () { return; };
            if (loadables) {
                _this.addResources(loadables);
            }
            return _this;
        }
        Object.defineProperty(Loader.prototype, "_image", {
            get: function () {
                if (!this._imageElement) {
                    this._imageElement = new Image();
                    this._imageElement.src = this.logo;
                }
                return this._imageElement;
            },
            enumerable: true,
            configurable: true
        });
        ;
        Loader.prototype.wireEngine = function (engine) {
            this._engine = engine;
        };
        /**
         * Add a resource to the loader to load
         * @param loadable  Resource to add
         */
        Loader.prototype.addResource = function (loadable) {
            var key = this._index++;
            this._resourceList.push(loadable);
            this._progressCounts[key] = 0;
            this._totalCounts[key] = 1;
            this._resourceCount++;
        };
        /**
         * Add a list of resources to the loader to load
         * @param loadables  The list of resources to load
         */
        Loader.prototype.addResources = function (loadables) {
            var i = 0, len = loadables.length;
            for (i; i < len; i++) {
                this.addResource(loadables[i]);
            }
        };
        /**
         * Returns true if the loader has completely loaded all resources
         */
        Loader.prototype.isLoaded = function () {
            return this._numLoaded === this._resourceCount;
        };
        /**
         * Begin loading all of the supplied resources, returning a promise
         * that resolves when loading of all is complete
         */
        Loader.prototype.load = function () {
            var _this = this;
            var complete = new Promises_6.Promise();
            var me = this;
            if (this._resourceList.length === 0) {
                me.oncomplete.call(me);
                return complete.resolve();
            }
            var progressArray = new Array(this._resourceList.length);
            var progressChunks = this._resourceList.length;
            this._resourceList.forEach(function (r, i) {
                if (_this._engine) {
                    r.wireEngine(_this._engine);
                }
                r.onprogress = function (e) {
                    var total = e.total;
                    var loaded = e.loaded;
                    progressArray[i] = { loaded: ((loaded / total) * (100 / progressChunks)), total: 100 };
                    var progressResult = progressArray.reduce(function (accum, next) {
                        return { loaded: (accum.loaded + next.loaded), total: 100 };
                    }, { loaded: 0, total: 100 });
                    me.onprogress.call(me, progressResult);
                };
                r.oncomplete = r.onerror = function () {
                    me._numLoaded++;
                    if (me._numLoaded === me._resourceCount) {
                        me.oncomplete.call(me);
                        complete.resolve();
                    }
                };
            });
            function loadNext(list, index) {
                if (!list[index]) {
                    return;
                }
                list[index].load().then(function () {
                    loadNext(list, index + 1);
                });
            }
            loadNext(this._resourceList, 0);
            return complete;
        };
        /**
         * Loader draw function. Draws the default Excalibur loading screen.
         * Override `logo`, `logoWidth`, `logoHeight` and `backgroundColor` properties
         * to customize the drawing, or just override entire method.
         */
        Loader.prototype.draw = function (ctx) {
            var canvasHeight = this._engine.canvasHeight / window.devicePixelRatio;
            var canvasWidth = this._engine.canvasWidth / window.devicePixelRatio;
            ctx.fillStyle = this.backgroundColor;
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            var y = canvasHeight / 2;
            var width = Math.min(this.logoWidth, canvasWidth * 0.75);
            var x = (canvasWidth / 2) - (width / 2);
            var imageHeight = Math.floor(width * (this.logoHeight / this.logoWidth)); // OG height/width factor
            var oldAntialias = this._engine.getAntialiasing();
            this._engine.setAntialiasing(true);
            ctx.drawImage(this._image, 0, 0, this.logoWidth, this.logoHeight, x, y - imageHeight - 20, width, imageHeight);
            // loading box
            ctx.lineWidth = 2;
            DrawUtil.roundRect(ctx, x, y, width, 20, 10);
            var progress = width * (this._numLoaded / this._resourceCount);
            var margin = 5;
            var progressWidth = progress - margin * 2;
            var height = 20 - margin * 2;
            DrawUtil.roundRect(ctx, x + margin, y + margin, progressWidth > 0 ? progressWidth : 0, height, 5, null, Color_12.Color.White);
            this._engine.setAntialiasing(oldAntialias);
        };
        /**
         * Perform any calculations or logic in the `update` method. The default `Loader` does not
         * do anything in this method so it is safe to override.
         */
        Loader.prototype.update = function (_engine, _delta) {
            // overridable update
        };
        return Loader;
    }(Class_3.Class));
    exports.Loader = Loader;
    /**
     * A [[Loader]] that pauses after loading to allow user
     * to proceed to play the game. Typically you will
     * want to use this loader for iOS to allow sounds
     * to play after loading (Apple Safari requires user
     * interaction to allow sounds, even for games)
     *
     * **Note:** Because Loader is not part of a Scene, you must
     * call `update` and `draw` manually on "child" objects.
     *
     * ## Implementing a Trigger
     *
     * The `PauseAfterLoader` requires an element to act as the trigger button
     * to start the game.
     *
     * For example, let's create an `<a>` tag to be our trigger and call it `tap-to-play`.
     *
     * ```html
     * <div id="wrapper">
     *    <canvas id="game"></canvas>
     *    <a id="tap-to-play" href='javascript:void(0);'>Tap to Play</a>
     * </div>
     * ```
     *
     * We've put it inside a wrapper to position it properly over the game canvas.
     *
     * Now let's add some CSS to style it (insert into `<head>`):
     *
     * ```html
     * <style>
     *     #wrapper {
     *         position: relative;
     *         width: 500px;
     *         height: 500px;
     *     }
     *     #tap-to-play {
     *         display: none;
     *         font-size: 24px;
     *         font-family: sans-serif;
     *         text-align: center;
     *         border: 3px solid white;
     *         position: absolute;
     *         color: white;
     *         width: 200px;
     *         height: 50px;
     *         line-height: 50px;
     *         text-decoration: none;
     *         left: 147px;
     *         top: 80%;
     *     }
     * </style>
     * ```
     *
     * Now we can create a `PauseAfterLoader` with a reference to our trigger button:
     *
     * ```ts
     * var loader = new ex.PauseAfterLoader('tap-to-play', [...]);
     * ```
     *
     * ## Use PauseAfterLoader for iOS
     *
     * The primary use case for pausing before starting the game is to
     * pass Apple's requirement of user interaction. The Web Audio context
     * in Safari is disabled by default until user interaction.
     *
     * Therefore, you can use this snippet to only use PauseAfterLoader when
     * iOS is detected (see [this thread](http://stackoverflow.com/questions/9038625/detect-if-device-is-ios)
     * for more techniques).
     *
     * ```ts
     * var iOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !(<any>window).MSStream;
     * var loader: ex.Loader = iOS ? new ex.PauseAfterLoader('tap-to-play') : new ex.Loader();
     *
     * loader.addResource(...);
     * ```
     */
    var PauseAfterLoader = (function (_super) {
        __extends(PauseAfterLoader, _super);
        function PauseAfterLoader(triggerElementId, loadables) {
            var _this = _super.call(this, loadables) || this;
            _this._handleOnTrigger = function () {
                if (_this._waitPromise.state() !== Promises_6.PromiseState.Pending) {
                    return false;
                }
                // unlock Safari WebAudio context
                Sound_1.WebAudio.unlock();
                // continue to play game
                _this._waitPromise.resolve(_this._loadedValue);
                // hide DOM element
                _this._playTrigger.style.display = 'none';
                return false;
            };
            _this._playTrigger = document.getElementById(triggerElementId);
            _this._playTrigger.addEventListener('click', _this._handleOnTrigger);
            return _this;
        }
        PauseAfterLoader.prototype.load = function () {
            var _this = this;
            this._waitPromise = new Promises_6.Promise();
            // wait until user indicates to proceed before finishing load
            _super.prototype.load.call(this).then(function (value) {
                _this._loadedValue = value;
                // show element
                _this._playTrigger.style.display = 'block';
            }, function (value) {
                _this._waitPromise.reject(value);
            });
            return this._waitPromise;
        };
        return PauseAfterLoader;
    }(Loader));
    exports.PauseAfterLoader = PauseAfterLoader;
});
define("Interfaces/IActorTrait", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Traits/CapturePointer", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Propogates pointer events to the actor
     */
    var CapturePointer = (function () {
        function CapturePointer() {
        }
        CapturePointer.prototype.update = function (actor, engine) {
            if (!actor.enableCapturePointer) {
                return;
            }
            if (actor.isKilled()) {
                return;
            }
            engine.input.pointers.propogate(actor);
        };
        return CapturePointer;
    }());
    exports.CapturePointer = CapturePointer;
});
define("Traits/EulerMovement", ["require", "exports", "Physics", "Actor"], function (require, exports, Physics_7, Actor_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var EulerMovement = (function () {
        function EulerMovement() {
        }
        EulerMovement.prototype.update = function (actor, _engine, delta) {
            // Update placements based on linear algebra
            var seconds = delta / 1000;
            var totalAcc = actor.acc.clone();
            // Only active vanilla actors are affected by global acceleration
            if (actor.collisionType === Actor_5.CollisionType.Active) {
                totalAcc.addEqual(Physics_7.Physics.acc);
            }
            actor.oldVel = actor.vel;
            actor.vel.addEqual(totalAcc.scale(seconds));
            actor.pos.addEqual(actor.vel.scale(seconds)).addEqual(totalAcc.scale(0.5 * seconds * seconds));
            actor.rx += actor.torque * (1.0 / actor.moi) * seconds;
            actor.rotation += actor.rx * seconds;
            actor.scale.x += actor.sx * delta / 1000;
            actor.scale.y += actor.sy * delta / 1000;
        };
        return EulerMovement;
    }());
    exports.EulerMovement = EulerMovement;
});
define("Util/CullingBox", ["require", "exports", "Algebra", "Drawing/Color"], function (require, exports, Algebra_13, Color_13) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CullingBox = (function () {
        function CullingBox() {
            this._topLeft = new Algebra_13.Vector(0, 0);
            this._topRight = new Algebra_13.Vector(0, 0);
            this._bottomLeft = new Algebra_13.Vector(0, 0);
            this._bottomRight = new Algebra_13.Vector(0, 0);
        }
        CullingBox.prototype.isSpriteOffScreen = function (actor, engine) {
            var drawingWidth = actor.currentDrawing.width;
            var drawingHeight = actor.currentDrawing.height;
            var rotation = actor.rotation;
            var anchor = actor.getCenter();
            var worldPos = actor.getWorldPos();
            this._topLeft.x = worldPos.x - (drawingWidth / 2);
            this._topLeft.y = worldPos.y - (drawingHeight / 2);
            this._topLeft = this._topLeft.rotate(rotation, anchor);
            this._topRight.x = worldPos.x + (drawingWidth / 2);
            this._topRight.y = worldPos.y - (drawingHeight / 2);
            this._topRight = this._topRight.rotate(rotation, anchor);
            this._bottomLeft.x = worldPos.x - (drawingWidth / 2);
            this._bottomLeft.y = worldPos.y + (drawingHeight / 2);
            this._bottomLeft = this._bottomLeft.rotate(rotation, anchor);
            this._bottomRight.x = worldPos.x + (drawingWidth / 2);
            this._bottomRight.y = worldPos.y + (drawingHeight / 2);
            this._bottomRight = this._bottomRight.rotate(rotation, anchor);
            ///
            var topLeftScreen = engine.worldToScreenCoordinates(this._topLeft);
            var topRightScreen = engine.worldToScreenCoordinates(this._topRight);
            var bottomLeftScreen = engine.worldToScreenCoordinates(this._bottomLeft);
            var bottomRightScreen = engine.worldToScreenCoordinates(this._bottomRight);
            this._xCoords = [];
            this._yCoords = [];
            this._xCoords.push(topLeftScreen.x, topRightScreen.x, bottomLeftScreen.x, bottomRightScreen.x);
            this._yCoords.push(topLeftScreen.y, topRightScreen.y, bottomLeftScreen.y, bottomRightScreen.y);
            this._xMin = Math.min.apply(null, this._xCoords);
            this._yMin = Math.min.apply(null, this._yCoords);
            this._xMax = Math.max.apply(null, this._xCoords);
            this._yMax = Math.max.apply(null, this._yCoords);
            var minWorld = engine.screenToWorldCoordinates(new Algebra_13.Vector(this._xMin, this._yMin));
            var maxWorld = engine.screenToWorldCoordinates(new Algebra_13.Vector(this._xMax, this._yMax));
            this._xMinWorld = minWorld.x;
            this._yMinWorld = minWorld.y;
            this._xMaxWorld = maxWorld.x;
            this._yMaxWorld = maxWorld.y;
            var boundingPoints = [
                new Algebra_13.Vector(this._xMin, this._yMin),
                new Algebra_13.Vector(this._xMax, this._yMin),
                new Algebra_13.Vector(this._xMin, this._yMax),
                new Algebra_13.Vector(this._xMax, this._yMax)
            ]; // bottomright
            // sprite can be wider than canvas screen (and still visible within canvas)
            // top or bottom of sprite must be within canvas
            if (boundingPoints[0].x < 0 && boundingPoints[1].x > engine.canvas.clientWidth &&
                (boundingPoints[0].y > 0 || boundingPoints[2].y < engine.canvas.clientHeight)) {
                return false;
            }
            // sprite can be taller than canvas screen (and still visible within canvas)
            // left or right of sprite must be within canvas
            if (boundingPoints[0].y < 0 && boundingPoints[2].y > engine.canvas.clientHeight &&
                (boundingPoints[1].x > 0 || boundingPoints[0].x < engine.canvas.clientWidth)) {
                return false;
            }
            // otherwise if any corner is visible, we're not offscreen
            for (var i = 0; i < boundingPoints.length; i++) {
                if (boundingPoints[i].x > 0 &&
                    boundingPoints[i].y > 0 &&
                    boundingPoints[i].x < engine.canvas.clientWidth &&
                    boundingPoints[i].y < engine.canvas.clientHeight) {
                    return false;
                }
            }
            return true;
        };
        CullingBox.prototype.debugDraw = function (ctx) {
            // bounding rectangle
            ctx.beginPath();
            ctx.strokeStyle = Color_13.Color.White.toString();
            ctx.rect(this._xMinWorld, this._yMinWorld, this._xMaxWorld - this._xMinWorld, this._yMaxWorld - this._yMinWorld);
            ctx.stroke();
            ctx.fillStyle = Color_13.Color.Red.toString();
            ctx.beginPath();
            ctx.arc(this._topLeft.x, this._topLeft.y, 5, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = Color_13.Color.Green.toString();
            ctx.beginPath();
            ctx.arc(this._topRight.x, this._topRight.y, 5, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = Color_13.Color.Blue.toString();
            ctx.beginPath();
            ctx.arc(this._bottomLeft.x, this._bottomLeft.y, 5, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = Color_13.Color.Magenta.toString();
            ctx.beginPath();
            ctx.arc(this._bottomRight.x, this._bottomRight.y, 5, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fill();
        };
        return CullingBox;
    }());
    exports.CullingBox = CullingBox;
});
define("Traits/OffscreenCulling", ["require", "exports", "Util/CullingBox", "Algebra", "Events"], function (require, exports, CullingBox_1, Algebra_14, Events_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var OffscreenCulling = (function () {
        function OffscreenCulling() {
            this.cullingBox = new CullingBox_1.CullingBox();
        }
        OffscreenCulling.prototype.update = function (actor, engine) {
            var eventDispatcher = actor.eventDispatcher;
            var anchor = actor.anchor;
            var globalScale = actor.getGlobalScale();
            var width = globalScale.x * actor.getWidth() / actor.scale.x;
            var height = globalScale.y * actor.getHeight() / actor.scale.y;
            var worldPos = actor.getWorldPos();
            var actorScreenCoords = engine.worldToScreenCoordinates(new Algebra_14.Vector(worldPos.x - anchor.x * width, worldPos.y - anchor.y * height));
            var zoom = 1.0;
            if (actor.scene && actor.scene.camera) {
                zoom = Math.abs(actor.scene.camera.getZoom());
            }
            var isSpriteOffScreen = true;
            if (actor.currentDrawing != null) {
                isSpriteOffScreen = this.cullingBox.isSpriteOffScreen(actor, engine);
            }
            if (!actor.isOffScreen) {
                if ((actorScreenCoords.x + width * zoom < 0 ||
                    actorScreenCoords.y + height * zoom < 0 ||
                    actorScreenCoords.x > engine.canvasWidth ||
                    actorScreenCoords.y > engine.canvasHeight) &&
                    isSpriteOffScreen) {
                    eventDispatcher.emit('exitviewport', new Events_3.ExitViewPortEvent(actor));
                    actor.isOffScreen = true;
                }
            }
            else {
                if ((actorScreenCoords.x + width * zoom > 0 &&
                    actorScreenCoords.y + height * zoom > 0 &&
                    actorScreenCoords.x < engine.canvasWidth &&
                    actorScreenCoords.y < engine.canvasHeight) ||
                    !isSpriteOffScreen) {
                    eventDispatcher.emit('enterviewport', new Events_3.EnterViewPortEvent(actor));
                    actor.isOffScreen = false;
                }
            }
        };
        return OffscreenCulling;
    }());
    exports.OffscreenCulling = OffscreenCulling;
});
define("Traits/TileMapCollisionDetection", ["require", "exports", "Actor", "Collision/Side", "Events"], function (require, exports, Actor_6, Side_2, Events_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TileMapCollisionDetection = (function () {
        function TileMapCollisionDetection() {
        }
        TileMapCollisionDetection.prototype.update = function (actor, engine) {
            var eventDispatcher = actor.eventDispatcher;
            if (actor.collisionType !== Actor_6.CollisionType.PreventCollision && engine.currentScene && engine.currentScene.tileMaps) {
                for (var j = 0; j < engine.currentScene.tileMaps.length; j++) {
                    var map = engine.currentScene.tileMaps[j];
                    var intersectMap;
                    var side = Side_2.Side.None;
                    var max = 2;
                    while (intersectMap = map.collides(actor)) {
                        if (max-- < 0) {
                            break;
                        }
                        side = actor.getSideFromIntersect(intersectMap);
                        eventDispatcher.emit('precollision', new Events_4.PreCollisionEvent(actor, null, side, intersectMap));
                        if (actor.collisionType === Actor_6.CollisionType.Active) {
                            actor.pos.y += intersectMap.y;
                            actor.pos.x += intersectMap.x;
                            eventDispatcher.emit('postcollision', new Events_4.PostCollisionEvent(actor, null, side, intersectMap));
                        }
                    }
                }
            }
        };
        return TileMapCollisionDetection;
    }());
    exports.TileMapCollisionDetection = TileMapCollisionDetection;
});
define("Traits/Index", ["require", "exports", "Traits/CapturePointer", "Traits/EulerMovement", "Traits/OffscreenCulling", "Traits/TileMapCollisionDetection"], function (require, exports, CapturePointer_1, EulerMovement_1, OffscreenCulling_1, TileMapCollisionDetection_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(CapturePointer_1);
    __export(EulerMovement_1);
    __export(OffscreenCulling_1);
    __export(TileMapCollisionDetection_1);
});
define("Particles", ["require", "exports", "Actor", "Drawing/Color", "Algebra", "Util/Util", "Util/DrawUtil", "Traits/Index", "Configurable", "Math/Random"], function (require, exports, Actor_7, Color_14, Algebra_15, Util, DrawUtil, Traits, Configurable_5, Random_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * An enum that represents the types of emitter nozzles
     */
    var EmitterType;
    (function (EmitterType) {
        /**
         * Constant for the circular emitter type
         */
        EmitterType[EmitterType["Circle"] = 0] = "Circle";
        /**
         * Constant for the rectangular emitter type
         */
        EmitterType[EmitterType["Rectangle"] = 1] = "Rectangle";
    })(EmitterType = exports.EmitterType || (exports.EmitterType = {}));
    /**
     * @hidden
     */
    var ParticleImpl = (function () {
        function ParticleImpl(emitterOrConfig, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize) {
            this.position = new Algebra_15.Vector(0, 0);
            this.velocity = new Algebra_15.Vector(0, 0);
            this.acceleration = new Algebra_15.Vector(0, 0);
            this.particleRotationalVelocity = 0;
            this.currentRotation = 0;
            this.focus = null;
            this.focusAccel = 0;
            this.opacity = 1;
            this.beginColor = Color_14.Color.White.clone();
            this.endColor = Color_14.Color.White.clone();
            // Life is counted in ms
            this.life = 300;
            this.fadeFlag = false;
            // Color transitions
            this._rRate = 1;
            this._gRate = 1;
            this._bRate = 1;
            this._aRate = 0;
            this._currentColor = Color_14.Color.White.clone();
            this.emitter = null;
            this.particleSize = 5;
            this.particleSprite = null;
            this.sizeRate = 0;
            this.elapsedMultiplier = 0;
            var emitter = emitterOrConfig;
            if (emitter && !(emitterOrConfig instanceof ParticleEmitter)) {
                var config = emitterOrConfig;
                emitter = config.emitter;
                life = config.life;
                opacity = config.opacity;
                endColor = config.endColor;
                beginColor = config.beginColor;
                position = config.position;
                velocity = config.velocity;
                acceleration = config.acceleration;
                startSize = config.startSize;
                endSize = config.endSize;
            }
            this.emitter = emitter;
            this.life = life || this.life;
            this.opacity = opacity || this.opacity;
            this.endColor = endColor || this.endColor.clone();
            this.beginColor = beginColor || this.beginColor.clone();
            this._currentColor = this.beginColor.clone();
            this.position = position || this.position;
            this.velocity = velocity || this.velocity;
            this.acceleration = acceleration || this.acceleration;
            this._rRate = (this.endColor.r - this.beginColor.r) / this.life;
            this._gRate = (this.endColor.g - this.beginColor.g) / this.life;
            this._bRate = (this.endColor.b - this.beginColor.b) / this.life;
            this._aRate = this.opacity / this.life;
            this.startSize = startSize || 0;
            this.endSize = endSize || 0;
            if ((this.endSize > 0) && (this.startSize > 0)) {
                this.sizeRate = (this.endSize - this.startSize) / this.life;
                this.particleSize = this.startSize;
            }
        }
        ParticleImpl.prototype.kill = function () {
            this.emitter.removeParticle(this);
        };
        ParticleImpl.prototype.update = function (delta) {
            this.life = this.life - delta;
            this.elapsedMultiplier = this.elapsedMultiplier + delta;
            if (this.life < 0) {
                this.kill();
            }
            if (this.fadeFlag) {
                this.opacity = Util.clamp(this._aRate * this.life, 0.0001, 1);
            }
            if ((this.startSize > 0) && (this.endSize > 0)) {
                this.particleSize = Util.clamp(this.sizeRate * delta + this.particleSize, Math.min(this.startSize, this.endSize), Math.max(this.startSize, this.endSize));
            }
            this._currentColor.r = Util.clamp(this._currentColor.r + this._rRate * delta, 0, 255);
            this._currentColor.g = Util.clamp(this._currentColor.g + this._gRate * delta, 0, 255);
            this._currentColor.b = Util.clamp(this._currentColor.b + this._bRate * delta, 0, 255);
            this._currentColor.a = Util.clamp(this.opacity, 0.0001, 1);
            if (this.focus) {
                var accel = this.focus.sub(this.position).normalize().scale(this.focusAccel).scale(delta / 1000);
                this.velocity = this.velocity.add(accel);
            }
            else {
                this.velocity = this.velocity.add(this.acceleration.scale(delta / 1000));
            }
            this.position = this.position.add(this.velocity.scale(delta / 1000));
            if (this.particleRotationalVelocity) {
                this.currentRotation = (this.currentRotation + this.particleRotationalVelocity * delta / 1000) % (2 * Math.PI);
            }
        };
        ParticleImpl.prototype.draw = function (ctx) {
            if (this.particleSprite) {
                this.particleSprite.rotation = this.currentRotation;
                this.particleSprite.scale.setTo(this.particleSize, this.particleSize);
                this.particleSprite.draw(ctx, this.position.x, this.position.y);
                return;
            }
            this._currentColor.a = Util.clamp(this.opacity, 0.0001, 1);
            ctx.fillStyle = this._currentColor.toString();
            ctx.beginPath();
            ctx.arc(this.position.x, this.position.y, this.particleSize, 0, Math.PI * 2);
            ctx.fill();
            ctx.closePath();
        };
        return ParticleImpl;
    }());
    exports.ParticleImpl = ParticleImpl;
    /**
     * Particle is used in a [[ParticleEmitter]]
     */
    var Particle = (function (_super) {
        __extends(Particle, _super);
        function Particle(emitterOrConfig, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize) {
            return _super.call(this, emitterOrConfig, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize) || this;
        }
        return Particle;
    }(Configurable_5.Configurable(ParticleImpl)));
    exports.Particle = Particle;
    /**
     * @hidden
     */
    var ParticleEmitterImpl = (function (_super) {
        __extends(ParticleEmitterImpl, _super);
        /**
         * @param x       The x position of the emitter
         * @param y       The y position of the emitter
         * @param width   The width of the emitter
         * @param height  The height of the emitter
         */
        function ParticleEmitterImpl(xOrConfig, y, width, height) {
            var _this = _super.call(this, typeof xOrConfig === 'number' ? { x: xOrConfig, y: y, width: width, height: height } : xOrConfig) || this;
            _this.numParticles = 0;
            /**
             * Gets or sets the isEmitting flag
             */
            _this.isEmitting = true;
            /**
             * Gets or sets the backing particle collection
             */
            _this.particles = null;
            /**
             * Gets or sets the backing deadParticle collection
             */
            _this.deadParticles = null;
            /**
             * Gets or sets the minimum particle velocity
             */
            _this.minVel = 0;
            /**
             * Gets or sets the maximum particle velocity
             */
            _this.maxVel = 0;
            /**
             * Gets or sets the acceleration vector for all particles
             */
            _this.acceleration = new Algebra_15.Vector(0, 0);
            /**
             * Gets or sets the minimum angle in radians
             */
            _this.minAngle = 0;
            /**
             * Gets or sets the maximum angle in radians
             */
            _this.maxAngle = 0;
            /**
             * Gets or sets the emission rate for particles (particles/sec)
             */
            _this.emitRate = 1; //particles/sec
            /**
             * Gets or sets the life of each particle in milliseconds
             */
            _this.particleLife = 2000;
            /**
             * Gets or sets the opacity of each particle from 0 to 1.0
             */
            _this.opacity = 1;
            /**
             * Gets or sets the fade flag which causes particles to gradually fade out over the course of their life.
             */
            _this.fadeFlag = false;
            /**
             * Gets or sets the optional focus where all particles should accelerate towards
             */
            _this.focus = null;
            /**
             * Gets or sets the acceleration for focusing particles if a focus has been specified
             */
            _this.focusAccel = 1;
            /*
             * Gets or sets the optional starting size for the particles
             */
            _this.startSize = null;
            /*
             * Gets or sets the optional ending size for the particles
             */
            _this.endSize = null;
            /**
             * Gets or sets the minimum size of all particles
             */
            _this.minSize = 5;
            /**
             * Gets or sets the maximum size of all particles
             */
            _this.maxSize = 5;
            /**
             * Gets or sets the beginning color of all particles
             */
            _this.beginColor = Color_14.Color.White.clone();
            /**
             * Gets or sets the ending color of all particles
             */
            _this.endColor = Color_14.Color.White.clone();
            /**
             * Gets or sets the sprite that a particle should use
             * @warning Performance intensive
             */
            _this.particleSprite = null;
            /**
             * Gets or sets the emitter type for the particle emitter
             */
            _this.emitterType = EmitterType.Rectangle;
            /**
             * Gets or sets the emitter radius, only takes effect when the [[emitterType]] is [[EmitterType.Circle]]
             */
            _this.radius = 0;
            /**
             * Gets or sets the particle rotational speed velocity
             */
            _this.particleRotationalVelocity = 0;
            /**
             * Indicates whether particles should start with a random rotation
             */
            _this.randomRotation = false;
            _this._particlesToEmit = 0;
            _this.collisionType = Actor_7.CollisionType.PreventCollision;
            _this.particles = new Util.Collection();
            _this.deadParticles = new Util.Collection();
            _this.random = new Random_2.Random();
            // Remove offscreen culling from particle emitters
            for (var i = 0; i < _this.traits.length; i++) {
                if (_this.traits[i] instanceof Traits.OffscreenCulling) {
                    _this.traits.splice(i, 1);
                }
            }
            return _this;
        }
        ParticleEmitterImpl.prototype.removeParticle = function (particle) {
            this.deadParticles.push(particle);
        };
        /**
         * Causes the emitter to emit particles
         * @param particleCount  Number of particles to emit right now
         */
        ParticleEmitterImpl.prototype.emitParticles = function (particleCount) {
            for (var i = 0; i < particleCount; i++) {
                this.particles.push(this._createParticle());
            }
        };
        ParticleEmitterImpl.prototype.clearParticles = function () {
            this.particles.clear();
        };
        // Creates a new particle given the constraints of the emitter
        ParticleEmitterImpl.prototype._createParticle = function () {
            // todo implement emitter constraints;
            var ranX = 0;
            var ranY = 0;
            var angle = Util.randomInRange(this.minAngle, this.maxAngle, this.random);
            var vel = Util.randomInRange(this.minVel, this.maxVel, this.random);
            var size = this.startSize || Util.randomInRange(this.minSize, this.maxSize, this.random);
            var dx = vel * Math.cos(angle);
            var dy = vel * Math.sin(angle);
            if (this.emitterType === EmitterType.Rectangle) {
                ranX = Util.randomInRange(this.pos.x, this.pos.x + this.getWidth(), this.random);
                ranY = Util.randomInRange(this.pos.y, this.pos.y + this.getHeight(), this.random);
            }
            else if (this.emitterType === EmitterType.Circle) {
                var radius = Util.randomInRange(0, this.radius, this.random);
                ranX = radius * Math.cos(angle) + this.pos.x;
                ranY = radius * Math.sin(angle) + this.pos.y;
            }
            var p = new Particle(this, this.particleLife, this.opacity, this.beginColor, this.endColor, new Algebra_15.Vector(ranX, ranY), new Algebra_15.Vector(dx, dy), this.acceleration, this.startSize, this.endSize);
            p.fadeFlag = this.fadeFlag;
            p.particleSize = size;
            if (this.particleSprite) {
                p.particleSprite = this.particleSprite;
            }
            p.particleRotationalVelocity = this.particleRotationalVelocity;
            if (this.randomRotation) {
                p.currentRotation = Util.randomInRange(0, Math.PI * 2, this.random);
            }
            if (this.focus) {
                p.focus = this.focus.add(new Algebra_15.Vector(this.pos.x, this.pos.y));
                p.focusAccel = this.focusAccel;
            }
            return p;
        };
        ParticleEmitterImpl.prototype.update = function (engine, delta) {
            var _this = this;
            _super.prototype.update.call(this, engine, delta);
            if (this.isEmitting) {
                this._particlesToEmit += this.emitRate * (delta / 1000);
                //var numParticles = Math.ceil(this.emitRate * delta / 1000);
                if (this._particlesToEmit > 1.0) {
                    this.emitParticles(Math.floor(this._particlesToEmit));
                    this._particlesToEmit = this._particlesToEmit - Math.floor(this._particlesToEmit);
                }
            }
            this.particles.forEach(function (p) { return p.update(delta); });
            this.deadParticles.forEach(function (p) { return _this.particles.removeElement(p); });
            this.deadParticles.clear();
        };
        ParticleEmitterImpl.prototype.draw = function (ctx) {
            // todo is there a more efficient to draw 
            // possibly use a webgl offscreen canvas and shaders to do particles?
            this.particles.forEach(function (p) { return p.draw(ctx); });
        };
        ParticleEmitterImpl.prototype.debugDraw = function (ctx) {
            _super.prototype.debugDraw.call(this, ctx);
            ctx.fillStyle = Color_14.Color.Black.toString();
            ctx.fillText('Particles: ' + this.particles.count(), this.pos.x, this.pos.y + 20);
            if (this.focus) {
                ctx.fillRect(this.focus.x + this.pos.x, this.focus.y + this.pos.y, 3, 3);
                DrawUtil.line(ctx, Color_14.Color.Yellow, this.focus.x + this.pos.x, this.focus.y + this.pos.y, _super.prototype.getCenter.call(this).x, _super.prototype.getCenter.call(this).y);
                ctx.fillText('Focus', this.focus.x + this.pos.x, this.focus.y + this.pos.y);
            }
        };
        return ParticleEmitterImpl;
    }(Actor_7.Actor));
    exports.ParticleEmitterImpl = ParticleEmitterImpl;
    /**
     * Using a particle emitter is a great way to create interesting effects
     * in your game, like smoke, fire, water, explosions, etc. `ParticleEmitter`
     * extend [[Actor]] allowing you to use all of the features that come with.
     *
     * [[include:Particles.md]]
     */
    var ParticleEmitter = (function (_super) {
        __extends(ParticleEmitter, _super);
        function ParticleEmitter(xOrConfig, y, width, height) {
            return _super.call(this, xOrConfig, y, width, height) || this;
        }
        return ParticleEmitter;
    }(Configurable_5.Configurable(ParticleEmitterImpl)));
    exports.ParticleEmitter = ParticleEmitter;
});
define("TileMap", ["require", "exports", "Collision/BoundingBox", "Drawing/Color", "Class", "Algebra", "Util/Log", "Events", "Configurable"], function (require, exports, BoundingBox_4, Color_15, Class_4, Algebra_16, Log_7, Events, Configurable_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @hidden
     */
    var TileMapImpl = (function (_super) {
        __extends(TileMapImpl, _super);
        /**
         * @param x             The x coordinate to anchor the TileMap's upper left corner (should not be changed once set)
         * @param y             The y coordinate to anchor the TileMap's upper left corner (should not be changed once set)
         * @param cellWidth     The individual width of each cell (in pixels) (should not be changed once set)
         * @param cellHeight    The individual height of each cell (in pixels) (should not be changed once set)
         * @param rows          The number of rows in the TileMap (should not be changed once set)
         * @param cols          The number of cols in the TileMap (should not be changed once set)
         */
        function TileMapImpl(xOrConfig, y, cellWidth, cellHeight, rows, cols) {
            var _this = _super.call(this) || this;
            _this._collidingX = -1;
            _this._collidingY = -1;
            _this._onScreenXStart = 0;
            _this._onScreenXEnd = 9999;
            _this._onScreenYStart = 0;
            _this._onScreenYEnd = 9999;
            _this._spriteSheets = {};
            _this.logger = Log_7.Logger.getInstance();
            _this.data = [];
            if (xOrConfig && typeof xOrConfig === 'object') {
                var config = xOrConfig;
                xOrConfig = config.x;
                y = config.y;
                cellWidth = config.cellWidth;
                cellHeight = config.cellHeight;
                rows = config.rows;
                cols = config.cols;
            }
            _this.data = new Array(rows * cols);
            for (var i = 0; i < cols; i++) {
                for (var j = 0; j < rows; j++) {
                    (function () {
                        var cd = new Cell(i * cellWidth + xOrConfig, j * cellHeight + y, cellWidth, cellHeight, i + j * cols);
                        _this.data[i + j * cols] = cd;
                    })();
                }
            }
            return _this;
        }
        TileMapImpl.prototype.on = function (eventName, handler) {
            _super.prototype.on.call(this, eventName, handler);
        };
        TileMapImpl.prototype.registerSpriteSheet = function (key, spriteSheet) {
            this._spriteSheets[key] = spriteSheet;
        };
        /**
         * Returns the intersection vector that can be used to resolve collisions with actors. If there
         * is no collision null is returned.
         */
        TileMapImpl.prototype.collides = function (actor) {
            var width = actor.pos.x + actor.getWidth();
            var height = actor.pos.y + actor.getHeight();
            var actorBounds = actor.getBounds();
            var overlaps = [];
            // trace points for overlap
            for (var x = actorBounds.left; x <= width; x += Math.min(actor.getWidth() / 2, this.cellWidth / 2)) {
                for (var y = actorBounds.top; y <= height; y += Math.min(actor.getHeight() / 2, this.cellHeight / 2)) {
                    var cell = this.getCellByPoint(x, y);
                    if (cell && cell.solid) {
                        var overlap = actorBounds.collides(cell.getBounds());
                        var dir = actor.getCenter().sub(cell.getCenter());
                        if (overlap && overlap.dot(dir) > 0) {
                            overlaps.push(overlap);
                        }
                    }
                }
            }
            if (overlaps.length === 0) {
                return null;
            }
            // Return the smallest change other than zero
            var result = overlaps.reduce(function (accum, next) {
                var x = accum.x;
                var y = accum.y;
                if (Math.abs(accum.x) < Math.abs(next.x)) {
                    x = next.x;
                }
                if (Math.abs(accum.y) < Math.abs(next.y)) {
                    y = next.y;
                }
                return new Algebra_16.Vector(x, y);
            });
            return result;
        };
        /**
         * Returns the [[Cell]] by index (row major order)
         */
        TileMapImpl.prototype.getCellByIndex = function (index) {
            return this.data[index];
        };
        /**
         * Returns the [[Cell]] by its x and y coordinates
         */
        TileMapImpl.prototype.getCell = function (x, y) {
            if (x < 0 || y < 0 || x >= this.cols || y >= this.rows) {
                return null;
            }
            return this.data[x + y * this.cols];
        };
        /**
         * Returns the [[Cell]] by testing a point in global coordinates,
         * returns `null` if no cell was found.
         */
        TileMapImpl.prototype.getCellByPoint = function (x, y) {
            x = Math.floor((x - this.x) / this.cellWidth);
            y = Math.floor((y - this.y) / this.cellHeight);
            var cell = this.getCell(x, y);
            if (x >= 0 && y >= 0 && x < this.cols && y < this.rows && cell) {
                return cell;
            }
            return null;
        };
        TileMapImpl.prototype.update = function (engine, delta) {
            this.emit('preupdate', new Events.PreUpdateEvent(engine, delta, this));
            var worldCoordsUpperLeft = engine.screenToWorldCoordinates(new Algebra_16.Vector(0, 0));
            var worldCoordsLowerRight = engine.screenToWorldCoordinates(new Algebra_16.Vector(engine.canvas.clientWidth, engine.canvas.clientHeight));
            this._onScreenXStart = Math.max(Math.floor(worldCoordsUpperLeft.x / this.cellWidth) - 2, 0);
            this._onScreenYStart = Math.max(Math.floor((worldCoordsUpperLeft.y - this.y) / this.cellHeight) - 2, 0);
            this._onScreenXEnd = Math.max(Math.floor(worldCoordsLowerRight.x / this.cellWidth) + 2, 0);
            this._onScreenYEnd = Math.max(Math.floor((worldCoordsLowerRight.y - this.y) / this.cellHeight) + 2, 0);
            this.emit('postupdate', new Events.PostUpdateEvent(engine, delta, this));
        };
        /**
         * Draws the tile map to the screen. Called by the [[Scene]].
         * @param ctx    The current rendering context
         * @param delta  The number of milliseconds since the last draw
         */
        TileMapImpl.prototype.draw = function (ctx, delta) {
            this.emit('predraw', new Events.PreDrawEvent(ctx, delta, this));
            ctx.save();
            ctx.translate(this.x, this.y);
            var x = this._onScreenXStart, xEnd = Math.min(this._onScreenXEnd, this.cols);
            var y = this._onScreenYStart, yEnd = Math.min(this._onScreenYEnd, this.rows);
            var cs, csi, cslen;
            for (x; x < xEnd; x++) {
                for (y; y < yEnd; y++) {
                    // get non-negative tile sprites
                    cs = this.getCell(x, y).sprites.filter(function (s) {
                        return s.spriteId > -1;
                    });
                    for (csi = 0, cslen = cs.length; csi < cslen; csi++) {
                        var ss = this._spriteSheets[cs[csi].spriteSheetKey];
                        // draw sprite, warning if sprite doesn't exist
                        if (ss) {
                            var sprite = ss.getSprite(cs[csi].spriteId);
                            if (sprite) {
                                sprite.draw(ctx, x * this.cellWidth, y * this.cellHeight);
                            }
                            else {
                                this.logger.warn('Sprite does not exist for id', cs[csi].spriteId, 'in sprite sheet', cs[csi].spriteSheetKey, sprite, ss);
                            }
                        }
                        else {
                            this.logger.warn('Sprite sheet', cs[csi].spriteSheetKey, 'does not exist', ss);
                        }
                    }
                }
                y = this._onScreenYStart;
            }
            ctx.restore();
            this.emit('postdraw', new Events.PostDrawEvent(ctx, delta, this));
        };
        /**
         * Draws all the tile map's debug info. Called by the [[Scene]].
         * @param ctx  The current rendering context
         */
        TileMapImpl.prototype.debugDraw = function (ctx) {
            var width = this.cols * this.cellWidth;
            var height = this.rows * this.cellHeight;
            ctx.save();
            ctx.strokeStyle = Color_15.Color.Red.toString();
            for (var x = 0; x < this.cols + 1; x++) {
                ctx.beginPath();
                ctx.moveTo(this.x + x * this.cellWidth, this.y);
                ctx.lineTo(this.x + x * this.cellWidth, this.y + height);
                ctx.stroke();
            }
            for (var y = 0; y < this.rows + 1; y++) {
                ctx.beginPath();
                ctx.moveTo(this.x, this.y + y * this.cellHeight);
                ctx.lineTo(this.x + width, this.y + y * this.cellHeight);
                ctx.stroke();
            }
            var solid = Color_15.Color.Red.clone();
            solid.a = .3;
            this.data.filter(function (cell) {
                return cell.solid;
            }).forEach(function (cell) {
                ctx.fillStyle = solid.toString();
                ctx.fillRect(cell.x, cell.y, cell.width, cell.height);
            });
            if (this._collidingY > -1 && this._collidingX > -1) {
                ctx.fillStyle = Color_15.Color.Cyan.toString();
                ctx.fillRect(this.x + this._collidingX * this.cellWidth, this.y + this._collidingY * this.cellHeight, this.cellWidth, this.cellHeight);
            }
            ctx.restore();
        };
        return TileMapImpl;
    }(Class_4.Class));
    exports.TileMapImpl = TileMapImpl;
    /**
     * The [[TileMap]] class provides a lightweight way to do large complex scenes with collision
     * without the overhead of actors.
     *
     * [[include:TileMaps.md]]
     */
    var TileMap = (function (_super) {
        __extends(TileMap, _super);
        function TileMap(xOrConfig, y, cellWidth, cellHeight, rows, cols) {
            return _super.call(this, xOrConfig, y, cellWidth, cellHeight, rows, cols) || this;
        }
        return TileMap;
    }(Configurable_6.Configurable(TileMapImpl)));
    exports.TileMap = TileMap;
    /**
     * Tile sprites are used to render a specific sprite from a [[TileMap]]'s spritesheet(s)
     */
    var TileSprite = (function () {
        /**
         * @param spriteSheetKey  The key of the spritesheet to use
         * @param spriteId        The index of the sprite in the [[SpriteSheet]]
         */
        function TileSprite(spriteSheetKey, spriteId) {
            this.spriteSheetKey = spriteSheetKey;
            this.spriteId = spriteId;
        }
        return TileSprite;
    }());
    exports.TileSprite = TileSprite;
    /**
     * @hidden
     */
    var CellImpl = (function () {
        /**
         * @param x       Gets or sets x coordinate of the cell in world coordinates
         * @param y       Gets or sets y coordinate of the cell in world coordinates
         * @param width   Gets or sets the width of the cell
         * @param height  Gets or sets the height of the cell
         * @param index   The index of the cell in row major order
         * @param solid   Gets or sets whether this cell is solid
         * @param sprites The list of tile sprites to use to draw in this cell (in order)
         */
        function CellImpl(xOrConfig, y, width, height, index, solid, sprites) {
            if (solid === void 0) { solid = false; }
            if (sprites === void 0) { sprites = []; }
            this.solid = false;
            this.sprites = [];
            if (xOrConfig && typeof xOrConfig === 'object') {
                var config = xOrConfig;
                xOrConfig = config.x;
                y = config.y;
                width = config.width;
                height = config.height;
                index = config.index;
                solid = config.solid;
                sprites = config.sprites;
            }
            this.x = xOrConfig;
            this.y = y;
            this.width = width;
            this.height = height;
            this.index = index;
            this.solid = solid;
            this.sprites = sprites;
            this._bounds = new BoundingBox_4.BoundingBox(this.x, this.y, this.x + this.width, this.y + this.height);
        }
        /**
         * Returns the bounding box for this cell
         */
        CellImpl.prototype.getBounds = function () {
            return this._bounds;
        };
        /**
         * Gets the center coordinate of this cell
         */
        CellImpl.prototype.getCenter = function () {
            return new Algebra_16.Vector(this.x + this.width / 2, this.y + this.height / 2);
        };
        /**
         * Add another [[TileSprite]] to this cell
         */
        CellImpl.prototype.pushSprite = function (tileSprite) {
            this.sprites.push(tileSprite);
        };
        /**
         * Remove an instance of [[TileSprite]] from this cell
         */
        CellImpl.prototype.removeSprite = function (tileSprite) {
            var index = -1;
            if ((index = this.sprites.indexOf(tileSprite)) > -1) {
                this.sprites.splice(index, 1);
            }
        };
        /**
         * Clear all sprites from this cell
         */
        CellImpl.prototype.clearSprites = function () {
            this.sprites.length = 0;
        };
        return CellImpl;
    }());
    exports.CellImpl = CellImpl;
    /**
     * TileMap Cell
     *
     * A light-weight object that occupies a space in a collision map. Generally
     * created by a [[TileMap]].
     *
     * Cells can draw multiple sprites. Note that the order of drawing is the order
     * of the sprites in the array so the last one will be drawn on top. You can
     * use transparency to create layers this way.
     */
    var Cell = (function (_super) {
        __extends(Cell, _super);
        function Cell(xOrConfig, y, width, height, index, solid, sprites) {
            return _super.call(this, xOrConfig, y, width, height, index, solid, sprites) || this;
        }
        return Cell;
    }(Configurable_6.Configurable(CellImpl)));
    exports.Cell = Cell;
});
define("Timer", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The Excalibur timer hooks into the internal timer and fires callbacks,
     * after a certain interval, optionally repeating.
     */
    var Timer = (function () {
        /**
         * @param fcn        The callback to be fired after the interval is complete.
         * @param interval   Interval length
         * @param repeats    Indicates whether this call back should be fired only once, or repeat after every interval as completed.
         */
        function Timer(fcn, interval, repeats) {
            this.id = 0;
            this.interval = 10;
            this.fcn = function () { return; };
            this.repeats = false;
            this._elapsedTime = 0;
            this._totalTimeAlive = 0;
            this._paused = false;
            this.complete = false;
            this.scene = null;
            this.id = Timer.id++;
            this.interval = interval || this.interval;
            this.fcn = fcn || this.fcn;
            this.repeats = repeats || this.repeats;
        }
        /**
         * Updates the timer after a certain number of milliseconds have elapsed. This is used internally by the engine.
         * @param delta  Number of elapsed milliseconds since the last update.
         */
        Timer.prototype.update = function (delta) {
            if (!this._paused) {
                this._totalTimeAlive += delta;
                this._elapsedTime += delta;
                if (!this.complete && this._elapsedTime >= this.interval) {
                    this.fcn.call(this);
                    if (this.repeats) {
                        this._elapsedTime = 0;
                    }
                    else {
                        this.complete = true;
                    }
                }
            }
        };
        /**
         * Resets the timer so that it can be reused, and optionally reconfigure the timers interval.
         * @param newInterval If specified, sets a new non-negative interval in milliseconds to refire the callback
         */
        Timer.prototype.reset = function (newInterval) {
            if (!!newInterval && newInterval >= 0) {
                this.interval = newInterval;
            }
            this.complete = false;
            this._elapsedTime = 0;
        };
        Timer.prototype.getTimeRunning = function () {
            return this._totalTimeAlive;
        };
        /**
         * Pauses the timer so that no more time will be incremented towards the next call
         */
        Timer.prototype.pause = function () {
            this._paused = true;
        };
        /**
         * Unpauses the timer. Time will now increment towards the next call
         */
        Timer.prototype.unpause = function () {
            this._paused = false;
        };
        /**
         * Cancels the timer, preventing any further executions.
         */
        Timer.prototype.cancel = function () {
            if (this.scene) {
                this.scene.cancelTimer(this);
            }
        };
        return Timer;
    }());
    Timer.id = 0;
    exports.Timer = Timer;
});
define("Trigger", ["require", "exports", "Drawing/Color", "Actions/Action", "EventDispatcher", "Actor", "Algebra", "Events", "Util/Util"], function (require, exports, Color_16, Action_1, EventDispatcher_1, Actor_8, Algebra_17, Events_5, Util) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var triggerDefaults = {
        pos: Algebra_17.Vector.Zero.clone(),
        width: 10,
        height: 10,
        visible: false,
        action: function () { return; },
        filter: function () { return true; },
        repeat: -1
    };
    /**
     * Triggers are a method of firing arbitrary code on collision. These are useful
     * as 'buttons', 'switches', or to trigger effects in a game. By default triggers
     * are invisible, and can only be seen when [[Trigger.visible]] is set to `true`.
     *
     * [[include:Triggers.md]]
     */
    var Trigger = (function (_super) {
        __extends(Trigger, _super);
        /**
         *
         * @param opts Trigger options
         */
        function Trigger(opts) {
            var _this = _super.call(this, opts.pos.x, opts.pos.y, opts.width, opts.height) || this;
            /**
             * Action to fire when triggered by collision
             */
            _this.action = function () { return; };
            /**
             * Filter to add additional granularity to action dispatch, if a filter is specified the action will only fire when
             * filter return true for the collided actor.
             */
            _this.filter = function () { return true; };
            /**
             * Number of times to repeat before killing the trigger,
             */
            _this.repeat = -1;
            opts = Util.extend({}, triggerDefaults, opts);
            _this.filter = opts.filter || _this.filter;
            _this.repeat = opts.repeat || _this.repeat;
            _this.action = opts.action || _this.action;
            if (opts.target) {
                _this.target = opts.target;
            }
            _this.visible = opts.visible;
            _this.collisionType = Actor_8.CollisionType.Passive;
            _this.eventDispatcher = new EventDispatcher_1.EventDispatcher(_this);
            _this.actionQueue = new Action_1.ActionQueue(_this);
            _this.on('collisionstart', function (evt) {
                if (_this.filter(evt.other)) {
                    _this.emit('enter', new Events_5.EnterTriggerEvent(_this, evt.other));
                    _this._dispatchAction();
                    // remove trigger if its done, -1 repeat forever
                    if (_this.repeat === 0) {
                        _this.kill();
                    }
                }
            });
            _this.on('collisionend', function (evt) {
                if (_this.filter(evt.other)) {
                    _this.emit('exit', new Events_5.ExitTriggerEvent(_this, evt.other));
                }
            });
            return _this;
        }
        Object.defineProperty(Trigger.prototype, "target", {
            get: function () {
                return this._target;
            },
            set: function (target) {
                this._target = target;
                this.filter = function (actor) { return actor === target; };
            },
            enumerable: true,
            configurable: true
        });
        Trigger.prototype._initialize = function (engine) {
            _super.prototype._initialize.call(this, engine);
        };
        Trigger.prototype._dispatchAction = function () {
            this.action.call(this);
            this.repeat--;
        };
        /* istanbul ignore next */
        Trigger.prototype.debugDraw = function (ctx) {
            _super.prototype.debugDraw.call(this, ctx);
            // Meant to draw debug information about actors
            ctx.save();
            ctx.translate(this.pos.x, this.pos.y);
            var bb = this.getBounds();
            var wp = this.getWorldPos();
            bb.left = bb.left - wp.x;
            bb.right = bb.right - wp.x;
            bb.top = bb.top - wp.y;
            bb.bottom = bb.bottom - wp.y;
            // Currently collision primitives cannot rotate 
            // ctx.rotate(this.rotation);
            ctx.fillStyle = Color_16.Color.Violet.toString();
            ctx.strokeStyle = Color_16.Color.Violet.toString();
            ctx.fillText('Trigger', 10, 10);
            bb.debugDraw(ctx);
            ctx.restore();
        };
        return Trigger;
    }(Actor_8.Actor));
    exports.Trigger = Trigger;
});
define("Actions/Index", ["require", "exports", "Actions/ActionContext", "Actions/RotationType", "Actions/Action"], function (require, exports, ActionContext_2, RotationType_1, actions) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(ActionContext_2);
    __export(RotationType_1);
    exports.Actions = actions;
    // legacy Internal.Actions namespace support
    exports.Internal = { Actions: actions };
});
define("Collision/DynamicTree", ["require", "exports", "Physics", "Collision/BoundingBox", "Util/Log"], function (require, exports, Physics_8, BoundingBox_5, Log_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Dynamic Tree Node used for tracking bounds within the tree
     */
    var TreeNode = (function () {
        function TreeNode(parent) {
            this.parent = parent;
            this.parent = parent || null;
            this.body = null;
            this.bounds = new BoundingBox_5.BoundingBox();
            this.left = null;
            this.right = null;
            this.height = 0;
        }
        TreeNode.prototype.isLeaf = function () {
            return (!this.left && !this.right);
        };
        return TreeNode;
    }());
    exports.TreeNode = TreeNode;
    /**
     * The DynamicTrees provides a spatial partiioning data structure for quickly querying for overlapping bounding boxes for
     * all tracked bodies. The worst case performance of this is O(n*log(n)) where n is the number of bodies in the tree.
     *
     * Internally the bounding boxes are organized as a balanced binary tree of bounding boxes, where the leaf nodes are tracked bodies.
     * Every non-leaf node is a bounding box that contains child bounding boxes.
     */
    var DynamicTree = (function () {
        function DynamicTree(worldBounds) {
            if (worldBounds === void 0) { worldBounds = new BoundingBox_5.BoundingBox(-Number.MAX_VALUE, -Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE); }
            this.worldBounds = worldBounds;
            this.root = null;
            this.nodes = {};
        }
        /**
         * Inserts a node into the dynamic tree
         */
        DynamicTree.prototype._insert = function (leaf) {
            // If there are no nodes in the tree, make this the root leaf
            if (this.root === null) {
                this.root = leaf;
                this.root.parent = null;
                return;
            }
            // Search the tree for a node that is not a leaf and find the best place to insert
            var leafAABB = leaf.bounds;
            var currentRoot = this.root;
            while (!currentRoot.isLeaf()) {
                var left = currentRoot.left;
                var right = currentRoot.right;
                var area = currentRoot.bounds.getPerimeter();
                var combinedAABB = currentRoot.bounds.combine(leafAABB);
                var combinedArea = combinedAABB.getPerimeter();
                // Calculate cost heuristic for creating a new parent and leaf
                var cost = 2 * combinedArea;
                // Minimum cost of pushing the leaf down the tree
                var inheritanceCost = 2 * (combinedArea - area);
                // Cost of descending
                var leftCost = 0;
                var leftCombined = leafAABB.combine(left.bounds);
                var newArea;
                var oldArea;
                if (left.isLeaf()) {
                    leftCost = leftCombined.getPerimeter() + inheritanceCost;
                }
                else {
                    oldArea = left.bounds.getPerimeter();
                    newArea = leftCombined.getPerimeter();
                    leftCost = (newArea - oldArea) + inheritanceCost;
                }
                var rightCost = 0;
                var rightCombined = leafAABB.combine(right.bounds);
                if (right.isLeaf()) {
                    rightCost = rightCombined.getPerimeter() + inheritanceCost;
                }
                else {
                    oldArea = right.bounds.getPerimeter();
                    newArea = rightCombined.getPerimeter();
                    rightCost = (newArea - oldArea) + inheritanceCost;
                }
                // cost is acceptable
                if (cost < leftCost && cost < rightCost) {
                    break;
                }
                // Descend to the depths
                if (leftCost < rightCost) {
                    currentRoot = left;
                }
                else {
                    currentRoot = right;
                }
            }
            // Create the new parent node and insert into the tree
            var oldParent = currentRoot.parent;
            var newParent = new TreeNode(oldParent);
            newParent.bounds = leafAABB.combine(currentRoot.bounds);
            newParent.height = currentRoot.height + 1;
            if (oldParent !== null) {
                // The sibling node was not the root
                if (oldParent.left === currentRoot) {
                    oldParent.left = newParent;
                }
                else {
                    oldParent.right = newParent;
                }
                newParent.left = currentRoot;
                newParent.right = leaf;
                currentRoot.parent = newParent;
                leaf.parent = newParent;
            }
            else {
                // The sibling node was the root
                newParent.left = currentRoot;
                newParent.right = leaf;
                currentRoot.parent = newParent;
                leaf.parent = newParent;
                this.root = newParent;
            }
            // Walk up the tree fixing heights and AABBs
            var currentNode = leaf.parent;
            while (currentNode) {
                currentNode = this._balance(currentNode);
                if (!currentNode.left) {
                    throw new Error('Parent of current leaf cannot have a null left child' + currentNode);
                }
                if (!currentNode.right) {
                    throw new Error('Parent of current leaf cannot have a null right child' + currentNode);
                }
                currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);
                currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);
                currentNode = currentNode.parent;
            }
        };
        /**
         * Removes a node from the dynamic tree
         */
        DynamicTree.prototype._remove = function (leaf) {
            if (leaf === this.root) {
                this.root = null;
                return;
            }
            var parent = leaf.parent;
            var grandParent = parent.parent;
            var sibling;
            if (parent.left === leaf) {
                sibling = parent.right;
            }
            else {
                sibling = parent.left;
            }
            if (grandParent) {
                if (grandParent.left === parent) {
                    grandParent.left = sibling;
                }
                else {
                    grandParent.right = sibling;
                }
                sibling.parent = grandParent;
                var currentNode = grandParent;
                while (currentNode) {
                    currentNode = this._balance(currentNode);
                    currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);
                    currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);
                    currentNode = currentNode.parent;
                }
            }
            else {
                this.root = sibling;
                sibling.parent = null;
            }
        };
        /**
         * Tracks a body in the dynamic tree
         */
        DynamicTree.prototype.trackBody = function (body) {
            var node = new TreeNode();
            node.body = body;
            node.bounds = body.getBounds();
            node.bounds.left -= 2;
            node.bounds.top -= 2;
            node.bounds.right += 2;
            node.bounds.bottom += 2;
            this.nodes[body.actor.id] = node;
            this._insert(node);
        };
        /**
         * Updates the dynamic tree given the current bounds of each body being tracked
         */
        DynamicTree.prototype.updateBody = function (body) {
            var node = this.nodes[body.actor.id];
            if (!node) {
                return false;
            }
            var b = body.getBounds();
            // if the body is outside the world no longer update it
            if (!this.worldBounds.contains(b)) {
                Log_8.Logger.getInstance().warn('Actor with id ' + body.actor.id +
                    ' is outside the world bounds and will no longer be tracked for physics');
                this.untrackBody(body);
                return false;
            }
            if (node.bounds.contains(b)) {
                return false;
            }
            this._remove(node);
            b.left -= Physics_8.Physics.boundsPadding;
            b.top -= Physics_8.Physics.boundsPadding;
            b.right += Physics_8.Physics.boundsPadding;
            b.bottom += Physics_8.Physics.boundsPadding;
            var multdx = body.vel.x * Physics_8.Physics.dynamicTreeVelocityMultiplyer;
            var multdy = body.vel.y * Physics_8.Physics.dynamicTreeVelocityMultiplyer;
            if (multdx < 0) {
                b.left += multdx;
            }
            else {
                b.right += multdx;
            }
            if (multdy < 0) {
                b.top += multdy;
            }
            else {
                b.bottom += multdy;
            }
            node.bounds = b;
            this._insert(node);
            return true;
        };
        /**
         * Untracks a body from the dynamic tree
         */
        DynamicTree.prototype.untrackBody = function (body) {
            var node = this.nodes[body.actor.id];
            if (!node) {
                return;
            }
            this._remove(node);
            this.nodes[body.actor.id] = null;
            delete this.nodes[body.actor.id];
        };
        /**
         * Balances the tree about a node
         */
        DynamicTree.prototype._balance = function (node) {
            if (node === null) {
                throw new Error('Cannot balance at null node');
            }
            if (node.isLeaf() || node.height < 2) {
                return node;
            }
            var left = node.left;
            var right = node.right;
            var a = node;
            var b = left;
            var c = right;
            var d = left.left;
            var e = left.right;
            var f = right.left;
            var g = right.right;
            var balance = c.height - b.height;
            // Rotate c node up
            if (balance > 1) {
                // Swap the right node with it's parent
                c.left = a;
                c.parent = a.parent;
                a.parent = c;
                // The original node's old parent should point to the right node
                // this is mega confusing
                if (c.parent) {
                    if (c.parent.left === a) {
                        c.parent.left = c;
                    }
                    else {
                        c.parent.right = c;
                    }
                }
                else {
                    this.root = c;
                }
                // Rotate
                if (f.height > g.height) {
                    c.right = f;
                    a.right = g;
                    g.parent = a;
                    a.bounds = b.bounds.combine(g.bounds);
                    c.bounds = a.bounds.combine(f.bounds);
                    a.height = 1 + Math.max(b.height, g.height);
                    c.height = 1 + Math.max(a.height, f.height);
                }
                else {
                    c.right = g;
                    a.right = f;
                    f.parent = a;
                    a.bounds = b.bounds.combine(f.bounds);
                    c.bounds = a.bounds.combine(g.bounds);
                    a.height = 1 + Math.max(b.height, f.height);
                    c.height = 1 + Math.max(a.height, g.height);
                }
                return c;
            }
            // Rotate left node up
            if (balance < -1) {
                // swap
                b.left = a;
                b.parent = a.parent;
                a.parent = b;
                // node's old parent should point to b
                if (b.parent) {
                    if (b.parent.left === a) {
                        b.parent.left = b;
                    }
                    else {
                        if (b.parent.right !== a) {
                            throw 'Error rotating Dynamic Tree';
                        }
                        b.parent.right = b;
                    }
                }
                else {
                    this.root = b;
                }
                // rotate
                if (d.height > e.height) {
                    b.right = d;
                    a.left = e;
                    e.parent = a;
                    a.bounds = c.bounds.combine(e.bounds);
                    b.bounds = a.bounds.combine(d.bounds);
                    a.height = 1 + Math.max(c.height, e.height);
                    b.height = 1 + Math.max(a.height, d.height);
                }
                else {
                    b.right = e;
                    a.left = d;
                    d.parent = a;
                    a.bounds = c.bounds.combine(d.bounds);
                    b.bounds = a.bounds.combine(e.bounds);
                    a.height = 1 + Math.max(c.height, d.height);
                    b.height = 1 + Math.max(a.height, e.height);
                }
                return b;
            }
            return node;
        };
        /**
         * Returns the internal height of the tree, shorter trees are better. Performance drops as the tree grows
         */
        DynamicTree.prototype.getHeight = function () {
            if (this.root === null) {
                return 0;
            }
            return this.root.height;
        };
        /**
         * Queries the Dynamic Axis Aligned Tree for bodies that could be colliding with the provided body.
         *
         * In the query callback, it will be passed a potential collider. Returning true from this callback indicates
         * that you are complete with your query and you do not want to continue. Returning false will continue searching
         * the tree until all possible colliders have been returned.
         */
        DynamicTree.prototype.query = function (body, callback) {
            var bounds = body.getBounds();
            var helper = function (currentNode) {
                if (currentNode && currentNode.bounds.collides(bounds)) {
                    if (currentNode.isLeaf() && currentNode.body !== body) {
                        if (callback.call(body, currentNode.body)) {
                            return true;
                        }
                    }
                    else {
                        return helper(currentNode.left) || helper(currentNode.right);
                    }
                }
                return false;
            };
            helper(this.root);
        };
        /**
         * Queries the Dynamic Axis Aligned Tree for bodies that could be intersecting. By default the raycast query uses an infinitely
         * long ray to test the tree specified by `max`.
         *
         * In the query callback, it will be passed a potential body that intersects with the racast. Returning true from this
         * callback indicates that your are complete with your query and do not want to continue. Return false will continue searching
         * the tree until all possible bodies that would intersect with the ray have been returned.
         */
        DynamicTree.prototype.rayCastQuery = function (ray, max, callback) {
            if (max === void 0) { max = Infinity; }
            var helper = function (currentNode) {
                if (currentNode && currentNode.bounds.rayCast(ray, max)) {
                    if (currentNode.isLeaf()) {
                        if (callback.call(ray, currentNode.body)) {
                            // ray hit a leaf! return the body
                            return true;
                        }
                    }
                    else {
                        // ray hit but not at a leaf, recurse deeper
                        return helper(currentNode.left) || helper(currentNode.right);
                    }
                }
                return false; // ray missed         
            };
            helper(this.root);
        };
        DynamicTree.prototype.getNodes = function () {
            var helper = function (currentNode) {
                if (currentNode) {
                    return [currentNode].concat(helper(currentNode.left), helper(currentNode.right));
                }
                else {
                    return [];
                }
            };
            return helper(this.root);
        };
        DynamicTree.prototype.debugDraw = function (ctx) {
            // draw all the nodes in the Dynamic Tree
            var helper = function (currentNode) {
                if (currentNode) {
                    if (currentNode.isLeaf()) {
                        ctx.lineWidth = 1;
                        ctx.strokeStyle = 'green';
                    }
                    else {
                        ctx.lineWidth = 1;
                        ctx.strokeStyle = 'white';
                    }
                    currentNode.bounds.debugDraw(ctx);
                    if (currentNode.left) {
                        helper(currentNode.left);
                    }
                    if (currentNode.right) {
                        helper(currentNode.right);
                    }
                }
            };
            helper(this.root);
        };
        return DynamicTree;
    }());
    exports.DynamicTree = DynamicTree;
});
define("Collision/ICollisionResolver", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Collision/DynamicTreeCollisionBroadphase", ["require", "exports", "Physics", "Collision/DynamicTree", "Collision/Pair", "Algebra", "Actor", "Util/Log", "Events"], function (require, exports, Physics_9, DynamicTree_1, Pair_2, Algebra_18, Actor_9, Log_9, Events_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DynamicTreeCollisionBroadphase = (function () {
        function DynamicTreeCollisionBroadphase() {
            this._dynamicCollisionTree = new DynamicTree_1.DynamicTree();
            this._collisionHash = {};
            this._collisionPairCache = [];
            this._lastFramePairs = [];
            this._lastFramePairsHash = {};
        }
        /**
         * Tracks a physics body for collisions
         */
        DynamicTreeCollisionBroadphase.prototype.track = function (target) {
            if (!target) {
                Log_9.Logger.getInstance().warn('Cannot track null physics body');
                return;
            }
            this._dynamicCollisionTree.trackBody(target);
        };
        /**
         * Untracks a physics body
         */
        DynamicTreeCollisionBroadphase.prototype.untrack = function (target) {
            if (!target) {
                Log_9.Logger.getInstance().warn('Cannot untrack a null physics body');
                return;
            }
            this._dynamicCollisionTree.untrackBody(target);
        };
        DynamicTreeCollisionBroadphase.prototype._canCollide = function (actorA, actorB) {
            // if the collision pair has been calculated already short circuit
            var hash = Pair_2.Pair.calculatePairHash(actorA.body, actorB.body);
            if (this._collisionHash[hash]) {
                return false; // pair exists easy exit return false
            }
            // if both are fixed short circuit
            if (actorA.collisionType === Actor_9.CollisionType.Fixed && actorB.collisionType === Actor_9.CollisionType.Fixed) {
                return false;
            }
            // if the other is prevent collision or is dead short circuit
            if (actorB.collisionType === Actor_9.CollisionType.PreventCollision || actorB.isKilled()) {
                return false;
            }
            // they can collide
            return true;
        };
        /**
         * Detects potential collision pairs in a broadphase approach with the dynamic aabb tree strategy
         */
        DynamicTreeCollisionBroadphase.prototype.broadphase = function (targets, delta, stats) {
            var _this = this;
            var seconds = delta / 1000;
            // TODO optimization use only the actors that are moving to start 
            // Retrieve the list of potential colliders, exclude killed, prevented, and self
            var potentialColliders = targets.filter(function (other) {
                return !other.isKilled() && other.collisionType !== Actor_9.CollisionType.PreventCollision;
            });
            // clear old list of collision pairs
            this._collisionPairCache = [];
            this._collisionHash = {};
            // check for normal collision pairs
            var actor;
            for (var j = 0, l = potentialColliders.length; j < l; j++) {
                actor = potentialColliders[j];
                // Query the collision tree for potential colliders
                this._dynamicCollisionTree.query(actor.body, function (other) {
                    if (_this._canCollide(actor, other.actor)) {
                        var pair = new Pair_2.Pair(actor.body, other);
                        _this._collisionHash[pair.id] = true;
                        _this._collisionPairCache.push(pair);
                    }
                    // Always return false, to query whole tree. Returning true in the query method stops searching
                    return false;
                });
            }
            if (stats) {
                stats.physics.pairs = this._collisionPairCache.length;
            }
            // Check dynamic tree for fast moving objects
            // Fast moving objects are those moving at least there smallest bound per frame
            if (Physics_9.Physics.checkForFastBodies) {
                for (var _i = 0, potentialColliders_1 = potentialColliders; _i < potentialColliders_1.length; _i++) {
                    var actor = potentialColliders_1[_i];
                    // Skip non-active objects. Does not make sense on other collison types
                    if (actor.collisionType !== Actor_9.CollisionType.Active) {
                        continue;
                    }
                    ;
                    // Maximum travel distance next frame
                    var updateDistance = (actor.vel.magnitude() * seconds) +
                        (actor.acc.magnitude() * .5 * seconds * seconds); // acc term
                    // Find the minimum dimension
                    var minDimension = Math.min(actor.body.getBounds().getHeight(), actor.body.getBounds().getWidth());
                    if (Physics_9.Physics.disableMinimumSpeedForFastBody || updateDistance > (minDimension / 2)) {
                        if (stats) {
                            stats.physics.fastBodies++;
                        }
                        // start with the oldPos because the integration for actors has already happened
                        // objects resting on a surface may be slightly penatrating in the current position
                        var updateVec = actor.pos.sub(actor.oldPos);
                        var centerPoint = actor.body.collisionArea.getCenter();
                        var furthestPoint = actor.body.collisionArea.getFurthestPoint(actor.vel);
                        var origin = furthestPoint.sub(updateVec);
                        var ray = new Algebra_18.Ray(origin, actor.vel);
                        // back the ray up by -2x surfaceEpsilon to account for fast moving objects starting on the surface 
                        ray.pos = ray.pos.add(ray.dir.scale(-2 * Physics_9.Physics.surfaceEpsilon));
                        var minBody;
                        var minTranslate = new Algebra_18.Vector(Infinity, Infinity);
                        this._dynamicCollisionTree.rayCastQuery(ray, updateDistance + Physics_9.Physics.surfaceEpsilon * 2, function (other) {
                            if (actor.body !== other && other.collisionArea) {
                                var hitPoint = other.collisionArea.rayCast(ray, updateDistance + Physics_9.Physics.surfaceEpsilon * 10);
                                if (hitPoint) {
                                    var translate = hitPoint.sub(origin);
                                    if (translate.magnitude() < minTranslate.magnitude()) {
                                        minTranslate = translate;
                                        minBody = other;
                                    }
                                }
                            }
                            return false;
                        });
                        if (minBody && Algebra_18.Vector.isValid(minTranslate)) {
                            var pair = new Pair_2.Pair(actor.body, minBody);
                            if (!this._collisionHash[pair.id]) {
                                this._collisionHash[pair.id] = true;
                                this._collisionPairCache.push(pair);
                            }
                            // move the fast moving object to the other body
                            // need to push into the surface by ex.Physics.surfaceEpsilon
                            var shift = centerPoint.sub(furthestPoint);
                            actor.pos = origin.add(shift).add(minTranslate).add(ray.dir.scale(2 * Physics_9.Physics.surfaceEpsilon));
                            actor.body.collisionArea.recalc();
                            if (stats) {
                                stats.physics.fastBodyCollisions++;
                            }
                        }
                    }
                }
            }
            // return cache
            return this._collisionPairCache;
        };
        /**
         * Applies narrow phase on collision pairs to find actual area intersections
         * Adds actual colliding pairs to stats' Frame data
         */
        DynamicTreeCollisionBroadphase.prototype.narrowphase = function (pairs, stats) {
            for (var i = 0; i < pairs.length; i++) {
                pairs[i].collide();
                if (stats && pairs[i].collision) {
                    stats.physics.collisions++;
                    stats.physics.collidersHash[pairs[i].id] = pairs[i];
                }
            }
            return pairs.filter(function (p) { return p.collision; });
        };
        /**
         * Perform collision resolution given a strategy (rigid body or box) and move objects out of intersect.
         */
        DynamicTreeCollisionBroadphase.prototype.resolve = function (pairs, delta, strategy) {
            for (var _i = 0, pairs_1 = pairs; _i < pairs_1.length; _i++) {
                var pair = pairs_1[_i];
                pair.resolve(strategy);
                if (pair.collision) {
                    pair.bodyA.applyMtv();
                    pair.bodyB.applyMtv();
                    // todo still don't like this, this is a small integration step to resolve narrowphase collisions
                    pair.bodyA.actor.integrate(delta * Physics_9.Physics.collisionShift);
                    pair.bodyB.actor.integrate(delta * Physics_9.Physics.collisionShift);
                }
            }
            return pairs.filter(function (p) { return p.canCollide; });
        };
        DynamicTreeCollisionBroadphase.prototype.runCollisionStartEnd = function (pairs) {
            var currentFrameHash = {};
            for (var _i = 0, pairs_2 = pairs; _i < pairs_2.length; _i++) {
                var p = pairs_2[_i];
                // load currentFrameHash
                currentFrameHash[p.id] = p;
                // find all new collisions
                if (!this._lastFramePairsHash[p.id]) {
                    var actor1 = p.bodyA.actor;
                    var actor2 = p.bodyB.actor;
                    actor1.emit('collisionstart', new Events_6.CollisionStartEvent(actor1, actor2, p));
                    actor2.emit('collisionstart', new Events_6.CollisionStartEvent(actor2, actor1, p));
                }
            }
            // find all old collisions
            for (var _a = 0, _b = this._lastFramePairs; _a < _b.length; _a++) {
                var p = _b[_a];
                if (!currentFrameHash[p.id]) {
                    var actor1 = p.bodyA.actor;
                    var actor2 = p.bodyB.actor;
                    actor1.emit('collisionend', new Events_6.CollisionEndEvent(actor1, actor2));
                    actor2.emit('collisionend', new Events_6.CollisionEndEvent(actor2, actor1));
                }
            }
            // reset the last frame cache
            this._lastFramePairs = pairs;
            this._lastFramePairsHash = currentFrameHash;
        };
        /**
         * Update the dynamic tree positions
         */
        DynamicTreeCollisionBroadphase.prototype.update = function (targets) {
            var updated = 0, i = 0, len = targets.length;
            for (i; i < len; i++) {
                if (this._dynamicCollisionTree.updateBody(targets[i].body)) {
                    updated++;
                }
            }
            return updated;
        };
        /* istanbul ignore next */
        DynamicTreeCollisionBroadphase.prototype.debugDraw = function (ctx) {
            if (Physics_9.Physics.broadphaseDebug) {
                this._dynamicCollisionTree.debugDraw(ctx);
            }
            if (Physics_9.Physics.showContacts || Physics_9.Physics.showCollisionNormals) {
                for (var _i = 0, _a = this._collisionPairCache; _i < _a.length; _i++) {
                    var pair = _a[_i];
                    pair.debugDraw(ctx);
                }
            }
        };
        return DynamicTreeCollisionBroadphase;
    }());
    exports.DynamicTreeCollisionBroadphase = DynamicTreeCollisionBroadphase;
});
define("Collision/IPhysics", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Collision/NaiveCollisionBroadphase", ["require", "exports", "Physics", "Collision/CollisionContact", "Collision/Pair", "Actor", "Events"], function (require, exports, Physics_10, CollisionContact_2, Pair_3, Actor_10, Events_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var NaiveCollisionBroadphase = (function () {
        function NaiveCollisionBroadphase() {
            this._lastFramePairs = [];
            this._lastFramePairsHash = {};
        }
        NaiveCollisionBroadphase.prototype.track = function () {
            // pass
        };
        NaiveCollisionBroadphase.prototype.untrack = function () {
            // pass
        };
        /**
         * Detects potential collision pairs in a broadphase approach with the dynamic aabb tree strategy
         */
        NaiveCollisionBroadphase.prototype.broadphase = function (targets) {
            // Retrieve the list of potential colliders, exclude killed, prevented, and self
            var potentialColliders = targets.filter(function (other) {
                return !other.isKilled() && other.collisionType !== Actor_10.CollisionType.PreventCollision;
            });
            var actor1;
            var actor2;
            var collisionPairs = [];
            for (var j = 0, l = potentialColliders.length; j < l; j++) {
                actor1 = potentialColliders[j];
                for (var i = j + 1; i < l; i++) {
                    actor2 = potentialColliders[i];
                    var minimumTranslationVector;
                    if (minimumTranslationVector = actor1.collides(actor2)) {
                        var pair = new Pair_3.Pair(actor1.body, actor2.body);
                        pair.collision = new CollisionContact_2.CollisionContact(actor1.collisionArea, actor2.collisionArea, minimumTranslationVector, actor1.pos, minimumTranslationVector);
                        if (!collisionPairs.some(function (cp) {
                            return cp.id === pair.id;
                        })) {
                            collisionPairs.push(pair);
                        }
                    }
                }
            }
            return collisionPairs;
        };
        /**
         * Identify actual collisions from those pairs, and calculate collision impulse
         */
        NaiveCollisionBroadphase.prototype.narrowphase = function (pairs) {
            return pairs;
        };
        NaiveCollisionBroadphase.prototype.runCollisionStartEnd = function (pairs) {
            var currentFrameHash = {};
            for (var _i = 0, pairs_3 = pairs; _i < pairs_3.length; _i++) {
                var p = pairs_3[_i];
                // load currentFrameHash
                currentFrameHash[p.id] = p;
                // find all new collisions
                if (!this._lastFramePairsHash[p.id]) {
                    var actor1 = p.bodyA.actor;
                    var actor2 = p.bodyB.actor;
                    actor1.emit('collisionstart', new Events_7.CollisionStartEvent(actor1, actor2, p));
                    actor2.emit('collisionstart', new Events_7.CollisionStartEvent(actor2, actor1, p));
                }
            }
            // find all old collisions
            for (var _a = 0, _b = this._lastFramePairs; _a < _b.length; _a++) {
                var p = _b[_a];
                if (!currentFrameHash[p.id]) {
                    var actor1 = p.bodyA.actor;
                    var actor2 = p.bodyB.actor;
                    actor1.emit('collisionend', new Events_7.CollisionEndEvent(actor1, actor2));
                    actor2.emit('collisionend', new Events_7.CollisionEndEvent(actor2, actor1));
                }
            }
            // reset the last frame cache
            this._lastFramePairs = pairs;
            this._lastFramePairsHash = currentFrameHash;
        };
        /**
         * Resolve the position and velocity of the physics bodies
         */
        NaiveCollisionBroadphase.prototype.resolve = function (pairs) {
            for (var _i = 0, pairs_4 = pairs; _i < pairs_4.length; _i++) {
                var pair = pairs_4[_i];
                pair.resolve(Physics_10.Physics.collisionResolutionStrategy);
            }
            return pairs.filter(function (p) { return p.canCollide; });
        };
        NaiveCollisionBroadphase.prototype.update = function () {
            return 0;
        };
        NaiveCollisionBroadphase.prototype.debugDraw = function () {
            return;
        };
        return NaiveCollisionBroadphase;
    }());
    exports.NaiveCollisionBroadphase = NaiveCollisionBroadphase;
});
define("Collision/Index", ["require", "exports", "Collision/Body", "Collision/BoundingBox", "Collision/CircleArea", "Collision/CollisionContact", "Collision/CollisionJumpTable", "Collision/DynamicTree", "Collision/DynamicTreeCollisionBroadphase", "Collision/EdgeArea", "Collision/NaiveCollisionBroadphase", "Collision/Pair", "Collision/PolygonArea", "Collision/Side"], function (require, exports, Body_1, BoundingBox_6, CircleArea_4, CollisionContact_3, CollisionJumpTable_4, DynamicTree_2, DynamicTreeCollisionBroadphase_1, EdgeArea_4, NaiveCollisionBroadphase_1, Pair_4, PolygonArea_6, Side_3) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(Body_1);
    __export(BoundingBox_6);
    __export(CircleArea_4);
    __export(CollisionContact_3);
    __export(CollisionJumpTable_4);
    __export(DynamicTree_2);
    __export(DynamicTreeCollisionBroadphase_1);
    __export(EdgeArea_4);
    __export(NaiveCollisionBroadphase_1);
    __export(Pair_4);
    __export(PolygonArea_6);
    __export(Side_3);
});
define("Drawing/Polygon", ["require", "exports", "Algebra"], function (require, exports, Algebra_19) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Creates a closed polygon drawing given a list of [[Vector]]s.
     *
     * @warning Use sparingly as Polygons are performance intensive
     */
    var Polygon = (function () {
        /**
         * @param points  The vectors to use to build the polygon in order
         */
        function Polygon(points) {
            /**
             * The width of the lines of the polygon
             */
            this.lineWidth = 5;
            /**
             * Indicates whether the polygon is filled or not.
             */
            this.filled = false;
            this._points = [];
            this.anchor = new Algebra_19.Vector(0, 0);
            this.rotation = 0;
            this.scale = new Algebra_19.Vector(1, 1);
            this._points = points;
            var minX = this._points.reduce(function (prev, curr) {
                return Math.min(prev, curr.x);
            }, 0);
            var maxX = this._points.reduce(function (prev, curr) {
                return Math.max(prev, curr.x);
            }, 0);
            this.width = maxX - minX;
            var minY = this._points.reduce(function (prev, curr) {
                return Math.min(prev, curr.y);
            }, 0);
            var maxY = this._points.reduce(function (prev, curr) {
                return Math.max(prev, curr.y);
            }, 0);
            this.height = maxY - minY;
            this.naturalHeight = this.height;
            this.naturalWidth = this.width;
        }
        /**
         * @notimplemented Effects are not supported on `Polygon`
         */
        Polygon.prototype.addEffect = function () {
            // not supported on polygons
        };
        /**
         * @notimplemented Effects are not supported on `Polygon`
         */
        Polygon.prototype.removeEffect = function () {
            // not supported on polygons
        };
        /**
         * @notimplemented Effects are not supported on `Polygon`
         */
        Polygon.prototype.clearEffects = function () {
            // not supported on polygons
        };
        Polygon.prototype.reset = function () {
            //pass
        };
        Polygon.prototype.draw = function (ctx, x, y) {
            ctx.save();
            ctx.translate(x + this.anchor.x, y + this.anchor.y);
            ctx.scale(this.scale.x, this.scale.y);
            ctx.rotate(this.rotation);
            ctx.beginPath();
            ctx.lineWidth = this.lineWidth;
            // Iterate through the supplied points and construct a 'polygon'
            var firstPoint = this._points[0];
            ctx.moveTo(firstPoint.x, firstPoint.y);
            var i = 0, len = this._points.length;
            for (i; i < len; i++) {
                ctx.lineTo(this._points[i].x, this._points[i].y);
            }
            ctx.lineTo(firstPoint.x, firstPoint.y);
            ctx.closePath();
            if (this.filled) {
                ctx.fillStyle = this.fillColor.toString();
                ctx.fill();
            }
            ctx.strokeStyle = this.lineColor.toString();
            if (this.flipHorizontal) {
                ctx.translate(this.width, 0);
                ctx.scale(-1, 1);
            }
            if (this.flipVertical) {
                ctx.translate(0, this.height);
                ctx.scale(1, -1);
            }
            ctx.stroke();
            ctx.restore();
        };
        return Polygon;
    }());
    exports.Polygon = Polygon;
});
define("Drawing/Index", ["require", "exports", "Drawing/Animation", "Drawing/Color", "Drawing/Polygon", "Drawing/Sprite", "Drawing/SpriteSheet", "Drawing/SpriteEffects"], function (require, exports, Animation_2, Color_17, Polygon_1, Sprite_3, SpriteSheet_1, effects) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Animation = Animation_2.Animation;
    __export(Color_17);
    __export(Polygon_1);
    exports.Sprite = Sprite_3.Sprite;
    exports.SpriteSheet = SpriteSheet_1.SpriteSheet;
    exports.SpriteFont = SpriteSheet_1.SpriteFont;
    exports.Effects = effects;
});
define("Interfaces/Index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Math/PerlinNoise", ["require", "exports", "Math/Random", "Drawing/Color", "Util/Util"], function (require, exports, Random_3, Color_18, Util) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _lerp(time, a, b) {
        return a + time * (b - a);
    }
    function _fade(t) {
        return t * t * t * (t * (t * 6 - 15) + 10);
    }
    /**
     * Generates perlin noise based on the 2002 Siggraph paper http://mrl.nyu.edu/~perlin/noise/
     * Also https://flafla2.github.io/2014/08/09/perlinnoise.html
     */
    var PerlinGenerator = (function () {
        function PerlinGenerator(options) {
            this._perm = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225,
                140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26,
                197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136,
                171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60,
                211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80,
                73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198,
                173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206,
                59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70,
                221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178,
                185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81,
                51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115,
                121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195,
                78, 66, 215, 61, 156, 180];
            this._p = new Uint8Array(512);
            this._defaultPerlinOptions = {
                octaves: 1,
                frequency: 1,
                amplitude: 1,
                persistance: .5
            };
            options = Util.extend({}, this._defaultPerlinOptions, options);
            this.persistance = options.persistance;
            this.amplitude = options.amplitude;
            this.frequency = options.frequency;
            this.octaves = options.octaves;
            if (options.seed) {
                this._random = new Random_3.Random(options.seed);
            }
            else {
                this._random = new Random_3.Random();
            }
            this._perm = this._random.shuffle(this._perm);
            for (var i = 0; i < 512; i++) {
                this._p[i] = this._perm[i % 256] & 0xFF;
            }
        }
        PerlinGenerator.prototype.noise = function () {
            var amp = this.amplitude;
            var freq = this.frequency;
            var total = 0;
            var maxValue = 0;
            for (var i = 0; i < this.octaves; i++) {
                switch (arguments.length) {
                    case 1:
                        total += this._noise1d(arguments[0] * freq) * amp;
                        break;
                    case 2:
                        total += this._noise2d(arguments[0] * freq, arguments[1] * freq) * amp;
                        break;
                    case 3:
                        total += this._noise3d(arguments[0] * freq, arguments[1] * freq, arguments[2] * freq) * amp;
                        break;
                    /* istanbul ignore next */
                    default: throw new Error('Invalid arguments for perlin noise');
                }
                maxValue += amp;
                amp *= this.persistance;
                freq *= 2;
            }
            return total / maxValue;
        };
        /**
         * Generates a list starting at 0 and ending at 1 of contious perlin noise, by default the step is 1/length;
         *
         */
        PerlinGenerator.prototype.sequence = function (length, step) {
            if (!step) {
                step = 1 / length;
            }
            var array = new Array(length);
            for (var i = 0; i < length; i++) {
                array[i] = this.noise(i * step);
            }
            return array;
        };
        /**
         * Generates a 2D grid of perlin noise given a step value packed into a 1D array i = (x + y*width),
         * by default the step will 1/(min(dimension))
         */
        PerlinGenerator.prototype.grid = function (width, height, step) {
            if (!step) {
                step = 1 / (Math.min(width, height));
            }
            var array = new Array(width * height);
            for (var y = 0; y < height; y++) {
                for (var x = 0; x < width; x++) {
                    array[x + y * width] = this.noise(x * step, y * step);
                }
            }
            return array;
        };
        PerlinGenerator.prototype._gradient3d = function (hash, x, y, z) {
            var h = hash & 0xF;
            var u = h < 8 ? x : y;
            var v = h < 4 ? y : ((h === 12 || h === 14) ? x : z);
            return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
        };
        PerlinGenerator.prototype._gradient2d = function (hash, x, y) {
            var value = (hash & 1) === 0 ? x : y;
            return (hash & 2) === 0 ? -value : value;
        };
        PerlinGenerator.prototype._gradient1d = function (hash, x) {
            return (hash & 1) === 0 ? -x : x;
        };
        PerlinGenerator.prototype._noise1d = function (x) {
            var intX = Math.floor(x) & 0xFF; // force 0-255 integers to lookup in permutation
            x -= Math.floor(x);
            var fadeX = _fade(x);
            return (_lerp(fadeX, this._gradient1d(this._p[intX], x), this._gradient1d(this._p[intX + 1], x - 1)) + 1) / 2;
        };
        PerlinGenerator.prototype._noise2d = function (x, y) {
            var intX = Math.floor(x) & 0xFF;
            var intY = Math.floor(y) & 0xFF;
            x -= Math.floor(x);
            y -= Math.floor(y);
            var fadeX = _fade(x);
            var fadeY = _fade(y);
            var a = this._p[intX] + intY;
            var b = this._p[intX + 1] + intY;
            return (_lerp(fadeY, _lerp(fadeX, this._gradient2d(this._p[a], x, y), this._gradient2d(this._p[b], x - 1, y)), _lerp(fadeX, this._gradient2d(this._p[a + 1], x, y - 1), this._gradient2d(this._p[b + 1], x - 1, y - 1))) + 1) / 2;
        };
        PerlinGenerator.prototype._noise3d = function (x, y, z) {
            var intX = Math.floor(x) & 0xFF;
            var intY = Math.floor(y) & 0xFF;
            var intZ = Math.floor(z) & 0xFF;
            x -= Math.floor(x);
            y -= Math.floor(y);
            z -= Math.floor(z);
            var fadeX = _fade(x);
            var fadeY = _fade(y);
            var fadeZ = _fade(z);
            var a = this._p[intX] + intY;
            var b = this._p[intX + 1] + intY;
            var aa = this._p[a] + intZ;
            var ba = this._p[b] + intZ;
            var ab = this._p[a + 1] + intZ;
            var bb = this._p[b + 1] + intZ;
            return (_lerp(fadeZ, _lerp(fadeY, _lerp(fadeX, this._gradient3d(this._p[aa], x, y, z), this._gradient3d(this._p[ba], x - 1, y, z)), _lerp(fadeX, this._gradient3d(this._p[ab], x, y - 1, z), this._gradient3d(this._p[bb], x - 1, y - 1, z))), _lerp(fadeY, _lerp(fadeX, this._gradient3d(this._p[aa + 1], x, y, z - 1), this._gradient3d(this._p[ba + 1], x - 1, y, z - 1)), _lerp(fadeX, this._gradient3d(this._p[ab + 1], x, y - 1, z - 1), this._gradient3d(this._p[bb + 1], x - 1, y - 1, z - 1)))) + 1) / 2;
        };
        return PerlinGenerator;
    }());
    exports.PerlinGenerator = PerlinGenerator;
    /**
     * A helper to draw 2D perlin maps given a perlin generator and a function
     */
    var PerlinDrawer2D = (function () {
        /**
         * @param generator - An existing perlin generator
         * @param colorFcn - A color function that takes a value between [0, 255] derived from the perlin generator, and returns a color
         */
        function PerlinDrawer2D(generator, colorFcn) {
            this.generator = generator;
            this.colorFcn = colorFcn;
            if (!colorFcn) {
                this.colorFcn = function (val) { return val < 125 ? Color_18.Color.Black : Color_18.Color.White; };
            }
        }
        /**
         * Returns an image of 2D perlin noise
         */
        PerlinDrawer2D.prototype.image = function (width, height) {
            var image = document.createElement('img');
            var canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            var ctx = canvas.getContext('2d');
            this.draw(ctx, 0, 0, width, height);
            image.src = canvas.toDataURL();
            return image;
        };
        /**
         * This draws a 2D perlin grid on a canvas context, not recommended to be called every frame due to performance
         */
        PerlinDrawer2D.prototype.draw = function (ctx, x, y, width, height) {
            var grid = this.generator.grid(width, height);
            var imageData = ctx.getImageData(x, y, width, height);
            for (var j = 0; j < height; j++) {
                for (var i = 0; i < width; i++) {
                    var val = grid[i + width * j];
                    var c = Math.floor(val * 255) & 0xff;
                    var pixel = (i + j * imageData.width) * 4;
                    var color = this.colorFcn(c);
                    imageData.data[pixel] = color.r;
                    imageData.data[pixel + 1] = color.g;
                    imageData.data[pixel + 2] = color.b;
                    imageData.data[pixel + 3] = Math.floor(color.a * 255);
                }
            }
            ctx.putImageData(imageData, x, y);
        };
        return PerlinDrawer2D;
    }());
    exports.PerlinDrawer2D = PerlinDrawer2D;
});
define("Math/Index", ["require", "exports", "Math/PerlinNoise", "Math/Random"], function (require, exports, PerlinNoise_1, Random_4) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(PerlinNoise_1);
    __export(Random_4);
});
define("PostProcessing/IPostProcessor", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("PostProcessing/ColorBlindCorrector", ["require", "exports", "Util/Log"], function (require, exports, Log_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ColorBlindness;
    (function (ColorBlindness) {
        ColorBlindness[ColorBlindness["Protanope"] = 0] = "Protanope";
        ColorBlindness[ColorBlindness["Deuteranope"] = 1] = "Deuteranope";
        ColorBlindness[ColorBlindness["Tritanope"] = 2] = "Tritanope";
    })(ColorBlindness = exports.ColorBlindness || (exports.ColorBlindness = {}));
    /**
     * This post processor can correct colors and simulate color blindness.
     * It is possible to use this on every game, but the game's performance
     * will suffer measurably. It's better to use it as a helpful tool while developing your game.
     * Remember, the best practice is to design with color blindness in mind.
     *
     * [[include:ColorBlind.md]]
     */
    var ColorBlindCorrector = (function () {
        function ColorBlindCorrector(engine, simulate, colorMode) {
            if (simulate === void 0) { simulate = false; }
            if (colorMode === void 0) { colorMode = ColorBlindness.Protanope; }
            this.engine = engine;
            this.simulate = simulate;
            this.colorMode = colorMode;
            this._vertexShader = 'attribute vec2 a_position;' +
                'attribute vec2 a_texCoord;' +
                'uniform vec2 u_resolution;' +
                'varying vec2 v_texCoord;' +
                'void main() {' +
                // convert the rectangle from pixels to 0.0 to 1.0
                'vec2 zeroToOne = a_position / u_resolution;' +
                // convert from 0->1 to 0->2
                'vec2 zeroToTwo = zeroToOne * 2.0;' +
                // convert from 0->2 to -1->+1 (clipspace)
                'vec2 clipSpace = zeroToTwo - 1.0;' +
                'gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);' +
                // pass the texCoord to the fragment shader
                // The GPU will interpolate this value between points.
                'v_texCoord = a_texCoord;' +
                '}';
            this._fragmentShader = 'precision mediump float;' +
                // our texture
                'uniform sampler2D u_image;' +
                // the texCoords passed in from the vertex shader.
                'varying vec2 v_texCoord;' +
                // Color blind conversions
                /*'mat3 m[9] =' +
                '{' +
                   'mat3(1.0, 0.0, 0.0,  0.0, 1.0, 0.0,  0.0, 0.0, 1.0  ),' + // normal
                   'mat3(0.567, 0.433, 0.0,  0.558, 0.442, 0.0,  0.0, 0.242, 0.758),' + // protanopia
                   'mat3(0.817, 0.183, 0.0,  0.333, 0.667, 0.0,  0.0, 0.125,0.875),' + // protanomaly
                   'mat3(0.625, 0.375, 0.0,  0.7, 0.3, 0.0,  0.0, 0.3,0.7  ),' + // deuteranopia
                   'mat3(0.8, 0.2, 0.0,  0.258, 0.742, 0.0,  0.0, 0.142,0.858),' + // deuteranomaly
                   'mat3(0.95, 0.05, 0.0,  0.0, 0.433, 0.567,  0.0, 0.475,0.525),' + // tritanopia
                   'mat3(0.967, 0.033, 0.0,  0.0, 0.733, 0.267,  0.0, 0.183,0.817),' + // tritanomaly
                   'mat3(0.299, 0.587, 0.114,  0.299, 0.587, 0.114,  0.299, 0.587,0.114),' + // achromatopsia
                   'mat3(0.618, 0.320, 0.062,  0.163, 0.775, 0.062,  0.163, 0.320,0.516)' +  // achromatomaly
                '};' +*/
                'void main() {' +
                'vec4 o =  texture2D(u_image, v_texCoord);' +
                // RGB to LMS matrix conversion
                'float L = (17.8824 * o.r) + (43.5161 * o.g) + (4.11935 * o.b);' +
                'float M = (3.45565 * o.r) + (27.1554 * o.g) + (3.86714 * o.b);' +
                'float S = (0.0299566 * o.r) + (0.184309 * o.g) + (1.46709 * o.b);' +
                // Simulate color blindness
                '//MODE CODE//' +
                /* Deuteranope for testing
                'float l = 1.0 * L + 0.0 * M + 0.0 * S;' +
                      'float m = 0.494207 * L + 0.0 * M + 1.24827 * S;' +
                      'float s = 0.0 * L + 0.0 * M + 1.0 * S;' +*/
                // LMS to RGB matrix conversion
                'vec4 error;' +
                'error.r = (0.0809444479 * l) + (-0.130504409 * m) + (0.116721066 * s);' +
                'error.g = (-0.0102485335 * l) + (0.0540193266 * m) + (-0.113614708 * s);' +
                'error.b = (-0.000365296938 * l) + (-0.00412161469 * m) + (0.693511405 * s);' +
                'error.a = 1.0;' +
                'vec4 diff = o - error;' +
                'vec4 correction;' +
                'correction.r = 0.0;' +
                'correction.g =  (diff.r * 0.7) + (diff.g * 1.0);' +
                'correction.b =  (diff.r * 0.7) + (diff.b * 1.0);' +
                'correction = o + correction;' +
                'correction.a = o.a;' +
                '//SIMULATE//' +
                '}';
            this._internalCanvas = document.createElement('canvas');
            this._internalCanvas.width = engine.drawWidth;
            this._internalCanvas.height = engine.drawHeight;
            this._gl = this._internalCanvas.getContext('webgl', { preserveDrawingBuffer: true });
            this._program = this._gl.createProgram();
            var fragmentShader = this._getShader('Fragment', this._getFragmentShaderByMode(colorMode));
            var vertextShader = this._getShader('Vertex', this._vertexShader);
            this._gl.attachShader(this._program, vertextShader);
            this._gl.attachShader(this._program, fragmentShader);
            this._gl.linkProgram(this._program);
            if (!this._gl.getProgramParameter(this._program, this._gl.LINK_STATUS)) {
                Log_10.Logger.getInstance().error('Unable to link shader program!');
            }
            this._gl.useProgram(this._program);
        }
        ColorBlindCorrector.prototype._getFragmentShaderByMode = function (colorMode) {
            var code = '';
            if (colorMode === ColorBlindness.Protanope) {
                code =
                    'float l = 0.0 * L + 2.02344 * M + -2.52581 * S;' +
                        'float m = 0.0 * L + 1.0 * M + 0.0 * S;' +
                        'float s = 0.0 * L + 0.0 * M + 1.0 * S;';
            }
            else if (colorMode === ColorBlindness.Deuteranope) {
                code =
                    'float l = 1.0 * L + 0.0 * M + 0.0 * S;' +
                        'float m = 0.494207 * L + 0.0 * M + 1.24827 * S;' +
                        'float s = 0.0 * L + 0.0 * M + 1.0 * S;';
            }
            else if (colorMode === ColorBlindness.Tritanope) {
                code =
                    'float l = 1.0 * L + 0.0 * M + 0.0 * S;' +
                        'float m = 0.0 * L + 1.0 * M + 0.0 * S;' +
                        'float s = -0.395913 * L + 0.801109 * M + 0.0 * S;';
            }
            if (this.simulate) {
                this._fragmentShader = this._fragmentShader.replace('//SIMULATE//', 'gl_FragColor = error.rgba;');
            }
            else {
                this._fragmentShader = this._fragmentShader.replace('//SIMULATE//', 'gl_FragColor = correction.rgba;');
            }
            return this._fragmentShader.replace('//MODE CODE//', code);
        };
        ColorBlindCorrector.prototype._setRectangle = function (x, y, width, height) {
            var x1 = x;
            var x2 = x + width;
            var y1 = y;
            var y2 = y + height;
            this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array([
                x1, y1,
                x2, y1,
                x1, y2,
                x1, y2,
                x2, y1,
                x2, y2
            ]), this._gl.STATIC_DRAW);
        };
        ColorBlindCorrector.prototype._getShader = function (type, program) {
            var shader;
            if (type === 'Fragment') {
                shader = this._gl.createShader(this._gl.FRAGMENT_SHADER);
            }
            else if (type === 'Vertex') {
                shader = this._gl.createShader(this._gl.VERTEX_SHADER);
            }
            else {
                Log_10.Logger.getInstance().error('Error unknown shader type', type);
            }
            this._gl.shaderSource(shader, program);
            this._gl.compileShader(shader);
            if (!this._gl.getShaderParameter(shader, this._gl.COMPILE_STATUS)) {
                Log_10.Logger.getInstance().error('Unable to compile shader!', this._gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        };
        ColorBlindCorrector.prototype.process = function (image, out) {
            // look up where the vertex data needs to go.
            var positionLocation = this._gl.getAttribLocation(this._program, 'a_position');
            var texCoordLocation = this._gl.getAttribLocation(this._program, 'a_texCoord');
            var texCoordBuffer = this._gl.createBuffer();
            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, texCoordBuffer);
            this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array([
                0.0, 0.0,
                1.0, 0.0,
                0.0, 1.0,
                0.0, 1.0,
                1.0, 0.0,
                1.0, 1.0
            ]), this._gl.STATIC_DRAW);
            this._gl.enableVertexAttribArray(texCoordLocation);
            this._gl.vertexAttribPointer(texCoordLocation, 2, this._gl.FLOAT, false, 0, 0);
            // Create a texture.
            var texture = this._gl.createTexture();
            this._gl.bindTexture(this._gl.TEXTURE_2D, texture);
            // Set the parameters so we can render any size image.
            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE);
            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);
            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.NEAREST);
            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.NEAREST);
            // Flip the texture when unpacking into the gl context, gl reads textures in the opposite order as everything else :/
            this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, 1);
            // Upload the image into the texture.
            this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, image);
            // lookup uniforms
            var resolutionLocation = this._gl.getUniformLocation(this._program, 'u_resolution');
            // set the resolution
            this._gl.uniform2f(resolutionLocation, this._internalCanvas.width, this._internalCanvas.height);
            // Create a buffer for the position of the rectangle corners.
            var positionBuffer = this._gl.createBuffer();
            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, positionBuffer);
            this._gl.enableVertexAttribArray(positionLocation);
            this._gl.vertexAttribPointer(positionLocation, 2, this._gl.FLOAT, false, 0, 0);
            // Set a rectangle the same size as the image.
            this._setRectangle(0, 0, image.width, image.height);
            // Draw the rectangle.
            this._gl.drawArrays(this._gl.TRIANGLES, 0, 6);
            // Grab tranformed image from internal canvas
            var pixelData = new Uint8Array(image.width * image.height * 4);
            this._gl.readPixels(0, 0, image.width, image.height, this._gl.RGBA, this._gl.UNSIGNED_BYTE, pixelData);
            image.data.set(pixelData);
            out.putImageData(image, 0, 0);
        };
        return ColorBlindCorrector;
    }());
    exports.ColorBlindCorrector = ColorBlindCorrector;
});
define("PostProcessing/Index", ["require", "exports", "PostProcessing/ColorBlindCorrector"], function (require, exports, ColorBlindCorrector_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(ColorBlindCorrector_1);
});
define("Resources/Index", ["require", "exports", "Resources/Resource", "Resources/Sound", "Resources/Texture"], function (require, exports, Resource_2, Sound_2, Texture_3) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(Resource_2);
    __export(Sound_2);
    __export(Texture_3);
});
define("Input/Gamepad", ["require", "exports", "Class", "Events"], function (require, exports, Class_5, Events_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Excalibur leverages the HTML5 Gamepad API [where it is supported](http://caniuse.com/#feat=gamepad)
     * to provide controller support for your games.
     *
     * [[include:Gamepads.md]]
     */
    var Gamepads = (function (_super) {
        __extends(Gamepads, _super);
        function Gamepads() {
            var _this = _super.call(this) || this;
            /**
             * Whether or not to poll for Gamepad input (default: `false`)
             */
            _this.enabled = false;
            /**
             * Whether or not Gamepad API is supported
             */
            _this.supported = !!navigator.getGamepads;
            _this._gamePadTimeStamps = [0, 0, 0, 0];
            _this._oldPads = [];
            _this._pads = [];
            _this._initSuccess = false;
            _this._navigator = navigator;
            _this._minimumConfiguration = null;
            return _this;
        }
        Gamepads.prototype.init = function () {
            if (!this.supported) {
                return;
            }
            if (this._initSuccess) {
                return;
            }
            // In Chrome, this will return 4 undefined items until a button is pressed
            // In FF, this will not return any items until a button is pressed
            this._oldPads = this._clonePads(this._navigator.getGamepads());
            if (this._oldPads.length && this._oldPads[0]) {
                this._initSuccess = true;
            }
        };
        /**
         * Sets the minimum gamepad configuration, for example {axis: 4, buttons: 4} means
         * this game requires at minimum 4 axis inputs and 4 buttons, this is not restrictive
         * all other controllers with more axis or buttons are valid as well. If no minimum
         * configuration is set all pads are valid.
         */
        Gamepads.prototype.setMinimumGamepadConfiguration = function (config) {
            this._enableAndUpdate(); // if config is used, implicitly enable
            this._minimumConfiguration = config;
        };
        /**
         * When implicitly enabled, set the enabled flag and run an update so information is updated
         */
        Gamepads.prototype._enableAndUpdate = function () {
            if (!this.enabled) {
                this.enabled = true;
                this.update();
            }
        };
        /**
         * Checks a navigator gamepad against the minimum configuration if present.
         */
        Gamepads.prototype._isGamepadValid = function (pad) {
            if (!this._minimumConfiguration) {
                return true;
            }
            ;
            if (!pad) {
                return false;
            }
            ;
            var axesLength = pad.axes.filter(function (value) {
                return (typeof value !== undefined);
            }).length;
            var buttonLength = pad.buttons.filter(function (value) {
                return (typeof value !== undefined);
            }).length;
            return axesLength >= this._minimumConfiguration.axis &&
                buttonLength >= this._minimumConfiguration.buttons &&
                pad.connected;
        };
        Gamepads.prototype.on = function (eventName, handler) {
            this._enableAndUpdate(); // implicitly enable
            _super.prototype.on.call(this, eventName, handler);
        };
        Gamepads.prototype.off = function (eventName, handler) {
            this._enableAndUpdate(); // implicitly enable
            _super.prototype.off.call(this, eventName, handler);
        };
        /**
         * Updates Gamepad state and publishes Gamepad events
         */
        Gamepads.prototype.update = function () {
            if (!this.enabled || !this.supported) {
                return;
            }
            this.init();
            var gamepads = this._navigator.getGamepads();
            for (var i = 0; i < gamepads.length; i++) {
                if (!gamepads[i]) {
                    var gamepad = this.at(i);
                    // If was connected, but now isn't emit the disconnect event
                    if (gamepad.connected) {
                        this.eventDispatcher.emit('disconnect', new Events_8.GamepadDisconnectEvent(i, gamepad));
                    }
                    // Reset connection status
                    gamepad.connected = false;
                    continue;
                }
                else {
                    if (!this.at(i).connected && this._isGamepadValid(gamepads[i])) {
                        this.eventDispatcher.emit('connect', new Events_8.GamepadConnectEvent(i, this.at(i)));
                    }
                    // Set connection status
                    this.at(i).connected = true;
                }
                ;
                // Only supported in Chrome
                if (gamepads[i].timestamp && gamepads[i].timestamp === this._gamePadTimeStamps[i]) {
                    continue;
                }
                this._gamePadTimeStamps[i] = gamepads[i].timestamp;
                // Add reference to navigator gamepad
                this.at(i).navigatorGamepad = gamepads[i];
                // Buttons
                var b, bi, a, ai, value;
                for (b in Buttons) {
                    bi = Buttons[b];
                    if (typeof bi === 'number') {
                        if (gamepads[i].buttons[bi]) {
                            value = gamepads[i].buttons[bi].value;
                            if (value !== this._oldPads[i].getButton(bi)) {
                                if (gamepads[i].buttons[bi].pressed) {
                                    this.at(i).updateButton(bi, value);
                                    this.at(i).eventDispatcher.emit('button', new Events_8.GamepadButtonEvent(bi, value, this.at(i)));
                                }
                                else {
                                    this.at(i).updateButton(bi, 0);
                                }
                            }
                        }
                    }
                }
                // Axes
                for (a in Axes) {
                    ai = Axes[a];
                    if (typeof ai === 'number') {
                        value = gamepads[i].axes[ai];
                        if (value !== this._oldPads[i].getAxes(ai)) {
                            this.at(i).updateAxes(ai, value);
                            this.at(i).eventDispatcher.emit('axis', new Events_8.GamepadAxisEvent(ai, value, this.at(i)));
                        }
                    }
                }
                this._oldPads[i] = this._clonePad(gamepads[i]);
            }
        };
        /**
         * Safely retrieves a Gamepad at a specific index and creates one if it doesn't yet exist
         */
        Gamepads.prototype.at = function (index) {
            this._enableAndUpdate(); // implicitly enable gamepads when at() is called         
            if (index >= this._pads.length) {
                // Ensure there is a pad to retrieve
                for (var i = this._pads.length - 1, max = index; i < max; i++) {
                    this._pads.push(new Gamepad());
                    this._oldPads.push(new Gamepad());
                }
            }
            return this._pads[index];
        };
        /**
         * Returns a list of all valid gamepads that meet the minimum configuration requirement.
         */
        Gamepads.prototype.getValidGamepads = function () {
            this._enableAndUpdate();
            var result = [];
            for (var i = 0; i < this._pads.length; i++) {
                if (this._isGamepadValid(this.at(i).navigatorGamepad) && this.at(i).connected) {
                    result.push(this.at(i));
                }
            }
            return result;
        };
        /**
         * Gets the number of connected gamepads
         */
        Gamepads.prototype.count = function () {
            return this._pads.filter(function (p) { return p.connected; }).length;
        };
        Gamepads.prototype._clonePads = function (pads) {
            var arr = [];
            for (var i = 0, len = pads.length; i < len; i++) {
                arr.push(this._clonePad(pads[i]));
            }
            return arr;
        };
        /**
         * Fastest way to clone a known object is to do it yourself
         */
        Gamepads.prototype._clonePad = function (pad) {
            var i, len;
            var clonedPad = new Gamepad();
            if (!pad) {
                return clonedPad;
            }
            for (i = 0, len = pad.buttons.length; i < len; i++) {
                if (pad.buttons[i]) {
                    clonedPad.updateButton(i, pad.buttons[i].value);
                }
            }
            for (i = 0, len = pad.axes.length; i < len; i++) {
                clonedPad.updateAxes(i, pad.axes[i]);
            }
            return clonedPad;
        };
        return Gamepads;
    }(Class_5.Class));
    /**
     * The minimum value an axis has to move before considering it a change
     */
    Gamepads.MinAxisMoveThreshold = 0.05;
    exports.Gamepads = Gamepads;
    /**
     * Gamepad holds state information for a connected controller. See [[Gamepads]]
     * for more information on handling controller input.
     */
    var Gamepad = (function (_super) {
        __extends(Gamepad, _super);
        function Gamepad() {
            var _this = _super.call(this) || this;
            _this.connected = false;
            _this._buttons = new Array(16);
            _this._axes = new Array(4);
            var i;
            for (i = 0; i < _this._buttons.length; i++) {
                _this._buttons[i] = 0;
            }
            for (i = 0; i < _this._axes.length; i++) {
                _this._axes[i] = 0;
            }
            return _this;
        }
        /**
         * Whether or not the given button is pressed
         * @param button     The button to query
         * @param threshold  The threshold over which the button is considered to be pressed
         */
        Gamepad.prototype.isButtonPressed = function (button, threshold) {
            if (threshold === void 0) { threshold = 1; }
            return this._buttons[button] >= threshold;
        };
        /**
         * Gets the given button value between 0 and 1
         */
        Gamepad.prototype.getButton = function (button) {
            return this._buttons[button];
        };
        /**
         * Gets the given axis value between -1 and 1. Values below
         * [[MinAxisMoveThreshold]] are considered 0.
         */
        Gamepad.prototype.getAxes = function (axes) {
            var value = this._axes[axes];
            if (Math.abs(value) < Gamepads.MinAxisMoveThreshold) {
                return 0;
            }
            else {
                return value;
            }
        };
        Gamepad.prototype.updateButton = function (buttonIndex, value) {
            this._buttons[buttonIndex] = value;
        };
        Gamepad.prototype.updateAxes = function (axesIndex, value) {
            this._axes[axesIndex] = value;
        };
        return Gamepad;
    }(Class_5.Class));
    exports.Gamepad = Gamepad;
    /**
     * Gamepad Buttons enumeration
     */
    var Buttons;
    (function (Buttons) {
        /**
         * Face 1 button (e.g. A)
         */
        Buttons[Buttons["Face1"] = 0] = "Face1";
        /**
         * Face 2 button (e.g. B)
         */
        Buttons[Buttons["Face2"] = 1] = "Face2";
        /**
         * Face 3 button (e.g. X)
         */
        Buttons[Buttons["Face3"] = 2] = "Face3";
        /**
         * Face 4 button (e.g. Y)
         */
        Buttons[Buttons["Face4"] = 3] = "Face4";
        /**
         * Left bumper button
         */
        Buttons[Buttons["LeftBumper"] = 4] = "LeftBumper";
        /**
         * Right bumper button
         */
        Buttons[Buttons["RightBumper"] = 5] = "RightBumper";
        /**
         * Left trigger button
         */
        Buttons[Buttons["LeftTrigger"] = 6] = "LeftTrigger";
        /**
         * Right trigger button
         */
        Buttons[Buttons["RightTrigger"] = 7] = "RightTrigger";
        /**
         * Select button
         */
        Buttons[Buttons["Select"] = 8] = "Select";
        /**
         * Start button
         */
        Buttons[Buttons["Start"] = 9] = "Start";
        /**
         * Left analog stick press (e.g. L3)
         */
        Buttons[Buttons["LeftStick"] = 10] = "LeftStick";
        /**
         * Right analog stick press (e.g. R3)
         */
        Buttons[Buttons["RightStick"] = 11] = "RightStick";
        /**
         * D-pad up
         */
        Buttons[Buttons["DpadUp"] = 12] = "DpadUp";
        /**
         * D-pad down
         */
        Buttons[Buttons["DpadDown"] = 13] = "DpadDown";
        /**
         * D-pad left
         */
        Buttons[Buttons["DpadLeft"] = 14] = "DpadLeft";
        /**
         * D-pad right
         */
        Buttons[Buttons["DpadRight"] = 15] = "DpadRight";
    })(Buttons = exports.Buttons || (exports.Buttons = {}));
    /**
     * Gamepad Axes enumeration
     */
    var Axes;
    (function (Axes) {
        /**
         * Left analogue stick X direction
         */
        Axes[Axes["LeftStickX"] = 0] = "LeftStickX";
        /**
         * Left analogue stick Y direction
         */
        Axes[Axes["LeftStickY"] = 1] = "LeftStickY";
        /**
         * Right analogue stick X direction
         */
        Axes[Axes["RightStickX"] = 2] = "RightStickX";
        /**
         * Right analogue stick Y direction
         */
        Axes[Axes["RightStickY"] = 3] = "RightStickY";
    })(Axes = exports.Axes || (exports.Axes = {}));
});
define("Input/Pointer", ["require", "exports", "Engine", "Events", "UIActor", "Algebra", "Class", "Util/Util"], function (require, exports, Engine_2, Events_9, UIActor_1, Algebra_20, Class_6, Util) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The type of pointer for a [[PointerEvent]].
     */
    var PointerType;
    (function (PointerType) {
        PointerType[PointerType["Touch"] = 0] = "Touch";
        PointerType[PointerType["Mouse"] = 1] = "Mouse";
        PointerType[PointerType["Pen"] = 2] = "Pen";
        PointerType[PointerType["Unknown"] = 3] = "Unknown";
    })(PointerType = exports.PointerType || (exports.PointerType = {}));
    /**
     * The mouse button being pressed.
     */
    var PointerButton;
    (function (PointerButton) {
        PointerButton[PointerButton["Left"] = 0] = "Left";
        PointerButton[PointerButton["Middle"] = 1] = "Middle";
        PointerButton[PointerButton["Right"] = 2] = "Right";
        PointerButton[PointerButton["Unknown"] = 3] = "Unknown";
    })(PointerButton = exports.PointerButton || (exports.PointerButton = {}));
    var WheelDeltaMode;
    (function (WheelDeltaMode) {
        WheelDeltaMode[WheelDeltaMode["Pixel"] = 0] = "Pixel";
        WheelDeltaMode[WheelDeltaMode["Line"] = 1] = "Line";
        WheelDeltaMode[WheelDeltaMode["Page"] = 2] = "Page";
    })(WheelDeltaMode = exports.WheelDeltaMode || (exports.WheelDeltaMode = {}));
    /**
     * Determines the scope of handling mouse/touch events. See [[Pointers]] for more information.
     */
    var PointerScope;
    (function (PointerScope) {
        /**
         * Handle events on the `canvas` element only. Events originating outside the
         * `canvas` will not be handled.
         */
        PointerScope[PointerScope["Canvas"] = 0] = "Canvas";
        /**
         * Handles events on the entire document. All events will be handled by Excalibur.
         */
        PointerScope[PointerScope["Document"] = 1] = "Document";
    })(PointerScope = exports.PointerScope || (exports.PointerScope = {}));
    /**
     * A constant used to normalize wheel events across different browsers
     *
     * This normalization factor is pulled from https://developer.mozilla.org/en-US/docs/Web/Events/wheel#Listening_to_this_event_across_browser
     */
    var ScrollWheelNormalizationFactor = -1 / 40;
    /**
     * Pointer events
     *
     * Represents a mouse, touch, or stylus event. See [[Pointers]] for more information on
     * handling pointer input.
     *
     * For mouse-based events, you can inspect [[PointerEvent.button]] to see what button was pressed.
     */
    var PointerEvent = (function (_super) {
        __extends(PointerEvent, _super);
        /**
         * @param pageX        The `x` coordinate of the event (in document coordinates)
         * @param pageY        The `y` coordinate of the event (in document coordinates)
         * @param screenX      The `x` coordinate of the event (in screen coordinates)
         * @param screenY      The `y` coordinate of the event (in screen coordinates)
         * @param index        The index of the pointer (zero-based)
         * @param pointerType  The type of pointer
         * @param button       The button pressed (if [[PointerType.Mouse]])
         * @param ev           The raw DOM event being handled
         * @param pos          (Will be added to signature in 0.14.0 release) The position of the event (in world coordinates)
         */
        function PointerEvent(x, y, pageX, pageY, screenX, screenY, index, pointerType, button, ev) {
            var _this = _super.call(this) || this;
            _this.x = x;
            _this.y = y;
            _this.pageX = pageX;
            _this.pageY = pageY;
            _this.screenX = screenX;
            _this.screenY = screenY;
            _this.index = index;
            _this.pointerType = pointerType;
            _this.button = button;
            _this.ev = ev;
            return _this;
        }
        Object.defineProperty(PointerEvent.prototype, "pos", {
            get: function () {
                return new Algebra_20.Vector(this.x, this.y);
            },
            enumerable: true,
            configurable: true
        });
        return PointerEvent;
    }(Events_9.GameEvent));
    exports.PointerEvent = PointerEvent;
    ;
    /**
     * Wheel Events
     *
     * Represents a mouse wheel event. See [[Pointers]] for more information on
     * handling point input.
     */
    var WheelEvent = (function (_super) {
        __extends(WheelEvent, _super);
        /**
         * @param x            The `x` coordinate of the event (in world coordinates)
         * @param y            The `y` coordinate of the event (in world coordinates)
         * @param pageX        The `x` coordinate of the event (in document coordinates)
         * @param pageY        The `y` coordinate of the event (in document coordinates)
         * @param screenX      The `x` coordinate of the event (in screen coordinates)
         * @param screenY      The `y` coordinate of the event (in screen coordinates)
         * @param index        The index of the pointer (zero-based)
         * @param deltaX       The type of pointer
         * @param deltaY       The type of pointer
         * @param deltaZ       The type of pointer
         * @param deltaMode    The type of movement [[WheelDeltaMode]]
         * @param ev           The raw DOM event being handled
         */
        function WheelEvent(x, y, pageX, pageY, screenX, screenY, index, deltaX, deltaY, deltaZ, deltaMode, ev) {
            var _this = _super.call(this) || this;
            _this.x = x;
            _this.y = y;
            _this.pageX = pageX;
            _this.pageY = pageY;
            _this.screenX = screenX;
            _this.screenY = screenY;
            _this.index = index;
            _this.deltaX = deltaX;
            _this.deltaY = deltaY;
            _this.deltaZ = deltaZ;
            _this.deltaMode = deltaMode;
            _this.ev = ev;
            return _this;
        }
        return WheelEvent;
    }(Events_9.GameEvent));
    exports.WheelEvent = WheelEvent;
    ;
    /**
     * Handles pointer events (mouse, touch, stylus, etc.) and normalizes to
     * [W3C Pointer Events](http://www.w3.org/TR/pointerevents/).
     *
     * [[include:Pointers.md]]
     */
    var Pointers = (function (_super) {
        __extends(Pointers, _super);
        function Pointers(engine) {
            var _this = _super.call(this) || this;
            _this._pointerDown = [];
            _this._pointerUp = [];
            _this._pointerMove = [];
            _this._pointerCancel = [];
            _this._wheel = [];
            _this._pointers = [];
            _this._activePointers = [];
            _this._engine = engine;
            _this._pointers.push(new Pointer());
            _this._activePointers = [-1];
            _this.primary = _this._pointers[0];
            return _this;
        }
        Pointers.prototype.on = function (eventName, handler) {
            _super.prototype.on.call(this, eventName, handler);
        };
        /**
         * Initializes pointer event listeners
         */
        Pointers.prototype.init = function (target) {
            target = target || this._engine.canvas;
            // Touch Events
            target.addEventListener('touchstart', this._handleTouchEvent('down', this._pointerDown));
            target.addEventListener('touchend', this._handleTouchEvent('up', this._pointerUp));
            target.addEventListener('touchmove', this._handleTouchEvent('move', this._pointerMove));
            target.addEventListener('touchcancel', this._handleTouchEvent('cancel', this._pointerCancel));
            // W3C Pointer Events
            // Current: IE11, IE10
            if (window.PointerEvent) {
                // IE11
                this._engine.canvas.style.touchAction = 'none';
                target.addEventListener('pointerdown', this._handlePointerEvent('down', this._pointerDown));
                target.addEventListener('pointerup', this._handlePointerEvent('up', this._pointerUp));
                target.addEventListener('pointermove', this._handlePointerEvent('move', this._pointerMove));
                target.addEventListener('pointercancel', this._handlePointerEvent('cancel', this._pointerMove));
            }
            else if (window.MSPointerEvent) {
                // IE10
                this._engine.canvas.style.msTouchAction = 'none';
                target.addEventListener('MSPointerDown', this._handlePointerEvent('down', this._pointerDown));
                target.addEventListener('MSPointerUp', this._handlePointerEvent('up', this._pointerUp));
                target.addEventListener('MSPointerMove', this._handlePointerEvent('move', this._pointerMove));
                target.addEventListener('MSPointerCancel', this._handlePointerEvent('cancel', this._pointerMove));
            }
            else {
                // Mouse Events
                target.addEventListener('mousedown', this._handleMouseEvent('down', this._pointerDown));
                target.addEventListener('mouseup', this._handleMouseEvent('up', this._pointerUp));
                target.addEventListener('mousemove', this._handleMouseEvent('move', this._pointerMove));
            }
            // MDN MouseWheelEvent
            if ('onwheel' in document.createElement('div')) {
                // Modern Browsers
                target.addEventListener('wheel', this._handleWheelEvent('wheel', this._wheel));
            }
            else if (document.onmousewheel !== undefined) {
                // Webkit and IE
                target.addEventListener('mousewheel', this._handleWheelEvent('wheel', this._wheel));
            }
            else {
                // Remaining browser and older Firefox
                target.addEventListener('MozMousePixelScroll', this._handleWheelEvent('wheel', this._wheel));
            }
        };
        Pointers.prototype.update = function () {
            this._pointerUp.length = 0;
            this._pointerDown.length = 0;
            this._pointerMove.length = 0;
            this._pointerCancel.length = 0;
            this._wheel.length = 0;
        };
        /**
         * Safely gets a Pointer at a specific index and initializes one if it doesn't yet exist
         * @param index  The pointer index to retrieve
         */
        Pointers.prototype.at = function (index) {
            if (index >= this._pointers.length) {
                // Ensure there is a pointer to retrieve
                for (var i = this._pointers.length - 1, max = index; i < max; i++) {
                    this._pointers.push(new Pointer());
                    this._activePointers.push(-1);
                }
            }
            return this._pointers[index];
        };
        /**
         * Get number of pointers being watched
         */
        Pointers.prototype.count = function () {
            return this._pointers.length;
        };
        /**
         * Propogates events to actor if necessary
         */
        Pointers.prototype.propogate = function (actor) {
            var isUIActor = actor instanceof UIActor_1.UIActor;
            var i = 0, len = this._pointerUp.length;
            for (i; i < len; i++) {
                if (actor.contains(this._pointerUp[i].x, this._pointerUp[i].y, !isUIActor)) {
                    actor.eventDispatcher.emit('pointerup', this._pointerUp[i]);
                }
            }
            i = 0;
            len = this._pointerDown.length;
            for (i; i < len; i++) {
                if (actor.contains(this._pointerDown[i].x, this._pointerDown[i].y, !isUIActor)) {
                    actor.eventDispatcher.emit('pointerdown', this._pointerDown[i]);
                }
            }
            if (actor.capturePointer.captureMoveEvents) {
                i = 0;
                len = this._pointerMove.length;
                for (i; i < len; i++) {
                    if (actor.contains(this._pointerMove[i].x, this._pointerMove[i].y, !isUIActor)) {
                        actor.eventDispatcher.emit('pointermove', this._pointerMove[i]);
                    }
                }
            }
            i = 0;
            len = this._pointerCancel.length;
            for (i; i < len; i++) {
                if (actor.contains(this._pointerCancel[i].x, this._pointerCancel[i].y, !isUIActor)) {
                    actor.eventDispatcher.emit('pointercancel', this._pointerCancel[i]);
                }
            }
            i = 0;
            len = this._wheel.length;
            for (i; i < len; i++) {
                if (actor.contains(this._wheel[i].x, this._wheel[i].y, !isUIActor)) {
                    actor.eventDispatcher.emit('pointerwheel', this._wheel[i]);
                }
            }
        };
        Pointers.prototype._handleMouseEvent = function (eventName, eventArr) {
            var _this = this;
            return function (e) {
                e.preventDefault();
                var x = e.pageX - Util.getPosition(_this._engine.canvas).x;
                var y = e.pageY - Util.getPosition(_this._engine.canvas).y;
                var transformedPoint = _this._engine.screenToWorldCoordinates(new Algebra_20.Vector(x, y));
                var pe = new PointerEvent(transformedPoint.x, transformedPoint.y, e.pageX, e.pageY, x, y, 0, PointerType.Mouse, e.button, e);
                eventArr.push(pe);
                _this.at(0).eventDispatcher.emit(eventName, pe);
            };
        };
        Pointers.prototype._handleTouchEvent = function (eventName, eventArr) {
            var _this = this;
            return function (e) {
                e.preventDefault();
                for (var i = 0, len = e.changedTouches.length; i < len; i++) {
                    var index = _this._pointers.length > 1 ? _this._getPointerIndex(e.changedTouches[i].identifier) : 0;
                    if (index === -1) {
                        continue;
                    }
                    var x = e.changedTouches[i].pageX - Util.getPosition(_this._engine.canvas).x;
                    var y = e.changedTouches[i].pageY - Util.getPosition(_this._engine.canvas).y;
                    var transformedPoint = _this._engine.screenToWorldCoordinates(new Algebra_20.Vector(x, y));
                    var pe = new PointerEvent(transformedPoint.x, transformedPoint.y, e.changedTouches[i].pageX, e.changedTouches[i].pageY, x, y, index, PointerType.Touch, PointerButton.Unknown, e);
                    eventArr.push(pe);
                    _this.at(index).eventDispatcher.emit(eventName, pe);
                    // only with multi-pointer
                    if (_this._pointers.length > 1) {
                        if (eventName === 'up') {
                            // remove pointer ID from pool when pointer is lifted
                            _this._activePointers[index] = -1;
                        }
                        else if (eventName === 'down') {
                            // set pointer ID to given index
                            _this._activePointers[index] = e.changedTouches[i].identifier;
                        }
                    }
                }
            };
        };
        Pointers.prototype._handlePointerEvent = function (eventName, eventArr) {
            var _this = this;
            return function (e) {
                e.preventDefault();
                // get the index for this pointer ID if multi-pointer is asked for
                var index = _this._pointers.length > 1 ? _this._getPointerIndex(e.pointerId) : 0;
                if (index === -1) {
                    return;
                }
                var x = e.pageX - Util.getPosition(_this._engine.canvas).x;
                var y = e.pageY - Util.getPosition(_this._engine.canvas).y;
                var transformedPoint = _this._engine.screenToWorldCoordinates(new Algebra_20.Vector(x, y));
                var pe = new PointerEvent(transformedPoint.x, transformedPoint.y, e.pageX, e.pageY, x, y, index, _this._stringToPointerType(e.pointerType), e.button, e);
                eventArr.push(pe);
                _this.at(index).eventDispatcher.emit(eventName, pe);
                // only with multi-pointer
                if (_this._pointers.length > 1) {
                    if (eventName === 'up') {
                        // remove pointer ID from pool when pointer is lifted
                        _this._activePointers[index] = -1;
                    }
                    else if (eventName === 'down') {
                        // set pointer ID to given index
                        _this._activePointers[index] = e.pointerId;
                    }
                }
            };
        };
        Pointers.prototype._handleWheelEvent = function (eventName, eventArr) {
            var _this = this;
            return function (e) {
                // Should we prevent page scroll because of this event
                if (_this._engine.pageScrollPreventionMode === Engine_2.ScrollPreventionMode.All ||
                    (_this._engine.pageScrollPreventionMode === Engine_2.ScrollPreventionMode.Canvas && e.target === _this._engine.canvas)) {
                    e.preventDefault();
                }
                var x = e.pageX - Util.getPosition(_this._engine.canvas).x;
                var y = e.pageY - Util.getPosition(_this._engine.canvas).y;
                var transformedPoint = _this._engine.screenToWorldCoordinates(new Algebra_20.Vector(x, y));
                // deltaX, deltaY, and deltaZ are the standard modern properties
                // wheelDeltaX, wheelDeltaY, are legacy properties in webkit browsers and older IE
                // e.detail is only used in opera
                var deltaX = e.deltaX ||
                    (e.wheelDeltaX * ScrollWheelNormalizationFactor) ||
                    0;
                var deltaY = e.deltaY ||
                    (e.wheelDeltaY * ScrollWheelNormalizationFactor) ||
                    (e.wheelDelta * ScrollWheelNormalizationFactor) ||
                    e.detail ||
                    0;
                var deltaZ = e.deltaZ || 0;
                var deltaMode = WheelDeltaMode.Pixel;
                if (e.deltaMode) {
                    if (e.deltaMode === 1) {
                        deltaMode = WheelDeltaMode.Line;
                    }
                    else if (e.deltaMode === 2) {
                        deltaMode = WheelDeltaMode.Page;
                    }
                }
                var we = new WheelEvent(transformedPoint.x, transformedPoint.y, e.pageX, e.pageY, x, y, 0, deltaX, deltaY, deltaZ, deltaMode, e);
                eventArr.push(we);
                _this.at(0).eventDispatcher.emit(eventName, we);
            };
        };
        /**
         * Gets the index of the pointer specified for the given pointer ID or finds the next empty pointer slot available.
         * This is required because IE10/11 uses incrementing pointer IDs so we need to store a mapping of ID => idx
         */
        Pointers.prototype._getPointerIndex = function (pointerId) {
            var idx;
            if ((idx = this._activePointers.indexOf(pointerId)) > -1) {
                return idx;
            }
            for (var i = 0; i < this._activePointers.length; i++) {
                if (this._activePointers[i] === -1) {
                    return i;
                }
            }
            // ignore pointer because game isn't watching
            return -1;
        };
        Pointers.prototype._stringToPointerType = function (s) {
            switch (s) {
                case 'touch':
                    return PointerType.Touch;
                case 'mouse':
                    return PointerType.Mouse;
                case 'pen':
                    return PointerType.Pen;
                default:
                    return PointerType.Unknown;
            }
        };
        return Pointers;
    }(Class_6.Class));
    exports.Pointers = Pointers;
    /**
     * Captures and dispatches PointerEvents
     */
    var Pointer = (function (_super) {
        __extends(Pointer, _super);
        function Pointer() {
            var _this = _super.call(this) || this;
            /**
             * The last position on the document this pointer was at. Can be `null` if pointer was never active.
             */
            _this.lastPagePos = null;
            /**
             * The last position on the screen this pointer was at. Can be `null` if pointer was never active.
             */
            _this.lastScreenPos = null;
            /**
             * The last position in the game world coordinates this pointer was at. Can be `null` if pointer was never active.
             */
            _this.lastWorldPos = null;
            _this.on('move', _this._onPointerMove);
            return _this;
        }
        Pointer.prototype._onPointerMove = function (ev) {
            this.lastWorldPos = new Algebra_20.Vector(ev.x, ev.y);
            this.lastPagePos = new Algebra_20.Vector(ev.pageX, ev.pageY);
            this.lastScreenPos = new Algebra_20.Vector(ev.screenX, ev.screenY);
        };
        return Pointer;
    }(Class_6.Class));
    exports.Pointer = Pointer;
});
define("Input/Keyboard", ["require", "exports", "Class", "Events"], function (require, exports, Class_7, Events_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Enum representing input key codes
     */
    var Keys;
    (function (Keys) {
        Keys[Keys["Num1"] = 97] = "Num1";
        Keys[Keys["Num2"] = 98] = "Num2";
        Keys[Keys["Num3"] = 99] = "Num3";
        Keys[Keys["Num4"] = 100] = "Num4";
        Keys[Keys["Num5"] = 101] = "Num5";
        Keys[Keys["Num6"] = 102] = "Num6";
        Keys[Keys["Num7"] = 103] = "Num7";
        Keys[Keys["Num8"] = 104] = "Num8";
        Keys[Keys["Num9"] = 105] = "Num9";
        Keys[Keys["Num0"] = 96] = "Num0";
        Keys[Keys["Numlock"] = 144] = "Numlock";
        Keys[Keys["Semicolon"] = 186] = "Semicolon";
        Keys[Keys["A"] = 65] = "A";
        Keys[Keys["B"] = 66] = "B";
        Keys[Keys["C"] = 67] = "C";
        Keys[Keys["D"] = 68] = "D";
        Keys[Keys["E"] = 69] = "E";
        Keys[Keys["F"] = 70] = "F";
        Keys[Keys["G"] = 71] = "G";
        Keys[Keys["H"] = 72] = "H";
        Keys[Keys["I"] = 73] = "I";
        Keys[Keys["J"] = 74] = "J";
        Keys[Keys["K"] = 75] = "K";
        Keys[Keys["L"] = 76] = "L";
        Keys[Keys["M"] = 77] = "M";
        Keys[Keys["N"] = 78] = "N";
        Keys[Keys["O"] = 79] = "O";
        Keys[Keys["P"] = 80] = "P";
        Keys[Keys["Q"] = 81] = "Q";
        Keys[Keys["R"] = 82] = "R";
        Keys[Keys["S"] = 83] = "S";
        Keys[Keys["T"] = 84] = "T";
        Keys[Keys["U"] = 85] = "U";
        Keys[Keys["V"] = 86] = "V";
        Keys[Keys["W"] = 87] = "W";
        Keys[Keys["X"] = 88] = "X";
        Keys[Keys["Y"] = 89] = "Y";
        Keys[Keys["Z"] = 90] = "Z";
        Keys[Keys["Shift"] = 16] = "Shift";
        Keys[Keys["Alt"] = 18] = "Alt";
        Keys[Keys["Up"] = 38] = "Up";
        Keys[Keys["Down"] = 40] = "Down";
        Keys[Keys["Left"] = 37] = "Left";
        Keys[Keys["Right"] = 39] = "Right";
        Keys[Keys["Space"] = 32] = "Space";
        Keys[Keys["Esc"] = 27] = "Esc";
    })(Keys = exports.Keys || (exports.Keys = {}));
    ;
    /**
     * Event thrown on a game object for a key event
     */
    var KeyEvent = (function (_super) {
        __extends(KeyEvent, _super);
        /**
         * @param key  The key responsible for throwing the event
         */
        function KeyEvent(key) {
            var _this = _super.call(this) || this;
            _this.key = key;
            return _this;
        }
        return KeyEvent;
    }(Events_10.GameEvent));
    exports.KeyEvent = KeyEvent;
    /**
     * Provides keyboard support for Excalibur.
     *
     * [[include:Keyboard.md]]
     */
    var Keyboard = (function (_super) {
        __extends(Keyboard, _super);
        function Keyboard() {
            var _this = _super.call(this) || this;
            _this._keys = [];
            _this._keysUp = [];
            _this._keysDown = [];
            return _this;
        }
        Keyboard.prototype.on = function (eventName, handler) {
            _super.prototype.on.call(this, eventName, handler);
        };
        /**
         * Initialize Keyboard event listeners
         */
        Keyboard.prototype.init = function (global) {
            var _this = this;
            global = global || window;
            global.addEventListener('blur', function () {
                _this._keys.length = 0; // empties array efficiently
            });
            // key up is on window because canvas cannot have focus
            global.addEventListener('keyup', function (ev) {
                var code = _this._normalizeKeyCode(ev.keyCode);
                var key = _this._keys.indexOf(code);
                _this._keys.splice(key, 1);
                _this._keysUp.push(code);
                var keyEvent = new KeyEvent(code);
                // alias the old api, we may want to deprecate this in the future
                _this.eventDispatcher.emit('up', keyEvent);
                _this.eventDispatcher.emit('release', keyEvent);
            });
            // key down is on window because canvas cannot have focus
            global.addEventListener('keydown', function (ev) {
                var code = _this._normalizeKeyCode(ev.keyCode);
                if (_this._keys.indexOf(code) === -1) {
                    _this._keys.push(code);
                    _this._keysDown.push(code);
                    var keyEvent = new KeyEvent(code);
                    _this.eventDispatcher.emit('down', keyEvent);
                    _this.eventDispatcher.emit('press', keyEvent);
                }
            });
        };
        Keyboard.prototype.update = function () {
            // Reset keysDown and keysUp after update is complete
            this._keysDown.length = 0;
            this._keysUp.length = 0;
            // Emit synthetic "hold" event
            for (var i = 0; i < this._keys.length; i++) {
                this.eventDispatcher.emit('hold', new KeyEvent(this._keys[i]));
            }
        };
        /**
         * Gets list of keys being pressed down
         */
        Keyboard.prototype.getKeys = function () {
            return this._keys;
        };
        /**
         * Tests if a certain key was just pressed this frame. This is cleared at the end of the update frame.
         * @param key Test whether a key was just pressed
         */
        Keyboard.prototype.wasPressed = function (key) {
            return this._keysDown.indexOf(key) > -1;
        };
        /**
         * Tests if a certain key is held down. This is persisted between frames.
         * @param key  Test whether a key is held down
         */
        Keyboard.prototype.isHeld = function (key) {
            return this._keys.indexOf(key) > -1;
        };
        /**
         * Tests if a certain key was just released this frame. This is cleared at the end of the update frame.
         * @param key  Test whether a key was just released
         */
        Keyboard.prototype.wasReleased = function (key) {
            return this._keysUp.indexOf(key) > -1;
        };
        /**
         * Normalizes some browser event key codes to map to standard Excalibur key codes
         * @param code Event keyCode
         * @see http://unixpapa.com/js/key.html
         */
        Keyboard.prototype._normalizeKeyCode = function (code) {
            switch (code) {
                case 59:
                    return Keys.Semicolon;
                default:
                    return code;
            }
        };
        return Keyboard;
    }(Class_7.Class));
    exports.Keyboard = Keyboard;
});
define("Input/IEngineInput", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
/**
 * Provides support for mice, keyboards, and controllers.
 *
 * [[include:Input.md]]
 */
define("Input/Index", ["require", "exports", "Input/Gamepad", "Input/Pointer", "Input/Keyboard"], function (require, exports, Gamepad_1, Pointer_1, Keyboard_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @typedoc
     */
    __export(Gamepad_1);
    __export(Pointer_1);
    __export(Keyboard_1);
});
define("Util/Index", ["require", "exports", "Util/Util", "Util/DrawUtil"], function (require, exports, Util_3, drawUtil) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(Util_3);
    exports.DrawUtil = drawUtil;
});
define("Util/Decorators", ["require", "exports", "Util/Log", "Util/Util"], function (require, exports, Log_11, Util) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Obsolete decorator for marking Excalibur methods obsolete, you can optionally specify a custom message and/or alternate replacement
     * method do the deprecated one. Inspired by https://github.com/jayphelps/core-decorators.js
     */
    function obsolete(options) {
        options = Util.extend({}, { message: 'This method will be removed in future versions of Excalibur.', alternateMethod: null }, options);
        return function (target, property, descriptor) {
            if (!(typeof descriptor.value === 'function' ||
                typeof descriptor.get === 'function' ||
                typeof descriptor.set === 'function')) {
                throw new SyntaxError('Only functions/getters/setters can be marked as obsolete');
            }
            var methodSignature = "" + (target.name || '') + (target.name ? '.' : '') + property;
            var message = methodSignature + " is marked obsolete: " + options.message +
                (options.alternateMethod ? " Use " + options.alternateMethod + " instead" : '');
            var method = Util.extend({}, descriptor);
            if (descriptor.value) {
                method.value = function () {
                    Log_11.Logger.getInstance().warn(message);
                    return descriptor.value.apply(this, arguments);
                };
                return method;
            }
            if (descriptor.get) {
                method.get = function () {
                    Log_11.Logger.getInstance().warn(message);
                    return descriptor.get.apply(this, arguments);
                };
            }
            if (descriptor.set) {
                method.set = function () {
                    Log_11.Logger.getInstance().warn(message);
                    return descriptor.set.apply(this, arguments);
                };
            }
            return method;
        };
    }
    exports.obsolete = obsolete;
});
define("Util/Detector", ["require", "exports", "Util/Log"], function (require, exports, Log_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * This is the list of features that will be used to log the supported
     * features to the console when Detector.logBrowserFeatures() is called.
     */
    var REPORTED_FEATURES = {
        webgl: 'WebGL',
        webaudio: 'WebAudio',
        gamepadapi: 'Gamepad API'
    };
    /**
     * Excalibur internal feature detection helper class
     */
    var Detector = (function () {
        function Detector() {
            this._features = null;
            this.failedTests = [];
            // critical browser features required for ex to run
            this._criticalTests = {
                // Test canvas/2d context support
                canvasSupport: function () {
                    var elem = document.createElement('canvas');
                    return !!(elem.getContext && elem.getContext('2d'));
                },
                // Test array buffer support ex uses for downloading binary data
                arrayBufferSupport: function () {
                    var xhr = new XMLHttpRequest();
                    xhr.open('GET', '/');
                    try {
                        xhr.responseType = 'arraybuffer';
                    }
                    catch (e) {
                        return false;
                    }
                    return xhr.responseType === 'arraybuffer';
                },
                // Test data urls ex uses for sprites
                dataUrlSupport: function () {
                    var canvas = document.createElement('canvas');
                    return canvas.toDataURL('image/png').indexOf('data:image/png') === 0;
                },
                // Test object url support for loading
                objectUrlSupport: function () {
                    return ('URL' in window) && ('revokeObjectURL' in URL) && ('createObjectURL' in URL);
                },
                // RGBA support for colors
                rgbaSupport: function () {
                    var style = document.createElement('a').style;
                    style.cssText = 'background-color:rgba(150,255,150,.5)';
                    return ('' + style.backgroundColor).indexOf('rgba') > -1;
                }
            };
            // warnings excalibur performance will be degraded
            this._warningTest = {
                webAudioSupport: function () {
                    return !!(window.AudioContext ||
                        window.webkitAudioContext ||
                        window.mozAudioContext ||
                        window.msAudioContext ||
                        window.oAudioContext);
                },
                webglSupport: function () {
                    var elem = document.createElement('canvas');
                    return !!(elem.getContext && elem.getContext('webgl'));
                }
            };
            this._features = this._loadBrowserFeatures();
        }
        /**
         * Returns a map of currently supported browser features. This method
         * treats the features as a singleton and will only calculate feature
         * support if it has not previously been done.
         */
        Detector.prototype.getBrowserFeatures = function () {
            if (this._features === null) {
                this._features = this._loadBrowserFeatures();
            }
            return this._features;
        };
        /**
         * Report on non-critical browser support for debugging purposes.
         * Use native browser console colors for visibility.
         */
        Detector.prototype.logBrowserFeatures = function () {
            var msg = '%cSUPPORTED BROWSER FEATURES\n==========================%c\n';
            var args = [
                'font-weight: bold; color: navy',
                'font-weight: normal; color: inherit'
            ];
            var supported = this.getBrowserFeatures();
            for (var _i = 0, _a = Object.keys(REPORTED_FEATURES); _i < _a.length; _i++) {
                var feature = _a[_i];
                if (supported[feature]) {
                    msg += '(%c\u2713%c)'; // ()
                    args.push('font-weight: bold; color: green');
                    args.push('font-weight: normal; color: inherit');
                }
                else {
                    msg += '(%c\u2717%c)'; // ()
                    args.push('font-weight: bold; color: red');
                    args.push('font-weight: normal; color: inherit');
                }
                ;
                msg += ' ' + REPORTED_FEATURES[feature] + '\n';
            }
            args.unshift(msg);
            console.log.apply(console, args);
        };
        /**
         * Executes several IIFE's to get a constant reference to supported
         * features within the current execution context.
         */
        Detector.prototype._loadBrowserFeatures = function () {
            var _this = this;
            return {
                // IIFE to check canvas support
                canvas: (function () {
                    return _this._criticalTests.canvasSupport();
                })(),
                // IIFE to check arraybuffer support
                arraybuffer: (function () {
                    return _this._criticalTests.arrayBufferSupport();
                })(),
                // IIFE to check dataurl support
                dataurl: (function () {
                    return _this._criticalTests.dataUrlSupport();
                })(),
                // IIFE to check objecturl support
                objecturl: (function () {
                    return _this._criticalTests.objectUrlSupport();
                })(),
                // IIFE to check rgba support
                rgba: (function () {
                    return _this._criticalTests.rgbaSupport();
                })(),
                // IIFE to check webaudio support
                webaudio: (function () {
                    return _this._warningTest.webAudioSupport();
                })(),
                // IIFE to check webgl support
                webgl: (function () {
                    return _this._warningTest.webglSupport();
                })(),
                // IIFE to check gamepadapi support
                gamepadapi: (function () {
                    return !!navigator.getGamepads;
                })()
            };
        };
        Detector.prototype.test = function () {
            // Critical test will for ex not to run
            var failedCritical = false;
            for (var test in this._criticalTests) {
                if (!this._criticalTests[test].call(this)) {
                    this.failedTests.push(test);
                    Log_12.Logger.getInstance().error('Critical browser feature missing, Excalibur requires:', test);
                    failedCritical = true;
                }
            }
            if (failedCritical) {
                return false;
            }
            // Warning tests do not for ex to return false to compatibility
            for (var warning in this._warningTest) {
                if (!this._warningTest[warning]()) {
                    Log_12.Logger.getInstance().warn('Warning browser feature missing, Excalibur will have reduced performance:', warning);
                }
            }
            return true;
        };
        return Detector;
    }());
    exports.Detector = Detector;
});
define("Util/SortedList", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A sorted list implementation. NOTE: this implementation is not self-balancing
     */
    var SortedList = (function () {
        function SortedList(getComparable) {
            this._getComparable = getComparable;
        }
        SortedList.prototype.find = function (element) {
            return this._find(this._root, element);
        };
        SortedList.prototype._find = function (node, element) {
            if (node == null) {
                return false;
            }
            else if (this._getComparable.call(element) === node.getKey()) {
                if (node.getData().indexOf(element) > -1) {
                    return true;
                }
                else {
                    return false;
                }
            }
            else if (this._getComparable.call(element) < node.getKey()) {
                return this._find(node.getLeft(), element);
            }
            else {
                return this._find(node.getRight(), element);
            }
        };
        // returns the array of elements at a specific key value
        SortedList.prototype.get = function (key) {
            return this._get(this._root, key);
        };
        SortedList.prototype._get = function (node, key) {
            if (node == null) {
                return [];
            }
            else if (key === node.getKey()) {
                return node.getData();
            }
            else if (key < node.getKey()) {
                return this._get(node.getLeft(), key);
            }
            else {
                return this._get(node.getRight(), key);
            }
        };
        SortedList.prototype.add = function (element) {
            if (this._root == null) {
                this._root = new BinaryTreeNode(this._getComparable.call(element), [element], null, null);
                return true;
            }
            else {
                return this._insert(this._root, element);
            }
        };
        SortedList.prototype._insert = function (node, element) {
            if (node != null) {
                if (this._getComparable.call(element) === node.getKey()) {
                    if (node.getData().indexOf(element) > -1) {
                        return false; // the element we're trying to insert already exists
                    }
                    else {
                        node.getData().push(element);
                        return true;
                    }
                }
                else if (this._getComparable.call(element) < node.getKey()) {
                    if (node.getLeft() == null) {
                        node.setLeft(new BinaryTreeNode(this._getComparable.call(element), [element], null, null));
                        return true;
                    }
                    else {
                        return this._insert(node.getLeft(), element);
                    }
                }
                else {
                    if (node.getRight() == null) {
                        node.setRight(new BinaryTreeNode(this._getComparable.call(element), [element], null, null));
                        return true;
                    }
                    else {
                        return this._insert(node.getRight(), element);
                    }
                }
            }
            return false;
        };
        SortedList.prototype.removeByComparable = function (element) {
            this._root = this._remove(this._root, element);
        };
        SortedList.prototype._remove = function (node, element) {
            if (node == null) {
                return null;
            }
            else if (this._getComparable.call(element) === node.getKey()) {
                var elementIndex = node.getData().indexOf(element);
                // if the node contains the element, remove the element
                if (elementIndex > -1) {
                    node.getData().splice(elementIndex, 1);
                    // if we have removed the last element at this node, remove the node
                    if (node.getData().length === 0) {
                        // if the node is a leaf
                        if (node.getLeft() == null && node.getRight() == null) {
                            return null;
                        }
                        else if (node.getLeft() == null) {
                            return node.getRight();
                        }
                        else if (node.getRight() == null) {
                            return node.getLeft();
                        }
                        // if node has 2 children
                        var temp = this._findMinNode(node.getRight());
                        node.setKey(temp.getKey());
                        node.setData(temp.getData());
                        node.setRight(this._cleanup(node.getRight(), temp)); //"cleanup nodes" (move them up recursively)
                        return node;
                    }
                    else {
                        // this prevents the node from being removed since it still contains elements
                        return node;
                    }
                }
            }
            else if (this._getComparable.call(element) < node.getKey()) {
                node.setLeft(this._remove(node.getLeft(), element));
                return node;
            }
            else {
                node.setRight(this._remove(node.getRight(), element));
                return node;
            }
            return null;
        };
        // called once we have successfully removed the element we wanted, recursively corrects the part of the tree below the removed node
        SortedList.prototype._cleanup = function (node, element) {
            var comparable = element.getKey();
            if (node == null) {
                return null;
            }
            else if (comparable === node.getKey()) {
                // if the node is a leaf
                if (node.getLeft() == null && node.getRight() == null) {
                    return null;
                }
                else if (node.getLeft() == null) {
                    return node.getRight();
                }
                else if (node.getRight() == null) {
                    return node.getLeft();
                }
                // if node has 2 children
                var temp = this._findMinNode(node.getRight());
                node.setKey(temp.getKey());
                node.setData(temp.getData());
                node.setRight(this._cleanup(node.getRight(), temp));
                return node;
            }
            else if (this._getComparable.call(element) < node.getKey()) {
                node.setLeft(this._cleanup(node.getLeft(), element));
                return node;
            }
            else {
                node.setRight(this._cleanup(node.getRight(), element));
                return node;
            }
        };
        SortedList.prototype._findMinNode = function (node) {
            var current = node;
            while (current.getLeft() != null) {
                current = current.getLeft();
            }
            return current;
        };
        SortedList.prototype.list = function () {
            var results = new Array();
            this._list(this._root, results);
            return results;
        };
        SortedList.prototype._list = function (treeNode, results) {
            if (treeNode != null) {
                this._list(treeNode.getLeft(), results);
                treeNode.getData().forEach(function (element) {
                    results.push(element);
                });
                this._list(treeNode.getRight(), results);
            }
        };
        return SortedList;
    }());
    exports.SortedList = SortedList;
    /**
     * A tree node part of [[SortedList]]
     */
    var BinaryTreeNode = (function () {
        function BinaryTreeNode(key, data, left, right) {
            this._key = key;
            this._data = data;
            this._left = left;
            this._right = right;
        }
        BinaryTreeNode.prototype.getKey = function () {
            return this._key;
        };
        BinaryTreeNode.prototype.setKey = function (key) {
            this._key = key;
        };
        BinaryTreeNode.prototype.getData = function () {
            return this._data;
        };
        BinaryTreeNode.prototype.setData = function (data) {
            this._data = data;
        };
        BinaryTreeNode.prototype.getLeft = function () {
            return this._left;
        };
        BinaryTreeNode.prototype.setLeft = function (left) {
            this._left = left;
        };
        BinaryTreeNode.prototype.getRight = function () {
            return this._right;
        };
        BinaryTreeNode.prototype.setRight = function (right) {
            this._right = right;
        };
        return BinaryTreeNode;
    }());
    exports.BinaryTreeNode = BinaryTreeNode;
    /**
     * Mock element for testing
     *
     * @internal
     */
    var MockedElement = (function () {
        function MockedElement(key) {
            this._key = 0;
            this._key = key;
        }
        MockedElement.prototype.getTheKey = function () {
            return this._key;
        };
        MockedElement.prototype.setKey = function (key) {
            this._key = key;
        };
        return MockedElement;
    }());
    exports.MockedElement = MockedElement;
});
define("Index", ["require", "exports", "Actor", "Algebra", "Camera", "Class", "Configurable", "Debug", "Engine", "EventDispatcher", "Events", "Group", "Label", "Loader", "Particles", "Physics", "Promises", "Scene", "TileMap", "Timer", "Trigger", "UIActor", "Actions/Index", "Collision/Index", "Drawing/Index", "Math/Index", "PostProcessing/Index", "Resources/Index", "Events", "Input/Index", "Traits/Index", "Util/Index", "Util/Decorators", "Util/Detector", "Util/CullingBox", "Util/EasingFunctions", "Util/Log", "Util/SortedList"], function (require, exports, Actor_11, Algebra_21, Camera_1, Class_8, Configurable_7, Debug_1, Engine_3, EventDispatcher_2, Events_11, Group_1, Label_2, Loader_1, Particles_1, Physics_11, Promises_7, Scene_1, TileMap_1, Timer_1, Trigger_1, UIActor_2, Index_1, Index_2, Index_3, Index_4, Index_5, Index_6, events, input, traits, util, Decorators_1, Detector_1, CullingBox_2, EasingFunctions_3, Log_13, SortedList_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The current Excalibur version string
     */
    exports.EX_VERSION = '0.15.0';
    exports.Actor = Actor_11.Actor;
    exports.CollisionType = Actor_11.CollisionType;
    __export(Algebra_21);
    __export(Camera_1);
    __export(Class_8);
    __export(Configurable_7);
    __export(Debug_1);
    __export(Engine_3);
    __export(EventDispatcher_2);
    __export(Events_11);
    __export(Group_1);
    exports.Label = Label_2.Label;
    exports.FontStyle = Label_2.FontStyle;
    exports.FontUnit = Label_2.FontUnit;
    exports.TextAlign = Label_2.TextAlign;
    exports.BaseAlign = Label_2.BaseAlign;
    __export(Loader_1);
    exports.Particle = Particles_1.Particle;
    exports.ParticleEmitter = Particles_1.ParticleEmitter;
    exports.EmitterType = Particles_1.EmitterType;
    __export(Physics_11);
    __export(Promises_7);
    __export(Scene_1);
    exports.TileMap = TileMap_1.TileMap;
    exports.Cell = TileMap_1.Cell;
    exports.TileSprite = TileMap_1.TileSprite;
    __export(Timer_1);
    __export(Trigger_1);
    __export(UIActor_2);
    __export(Index_1);
    __export(Index_2);
    __export(Index_3);
    __export(Index_4);
    __export(Index_5);
    __export(Index_6);
    exports.Events = events;
    exports.Input = input;
    exports.Traits = traits;
    exports.Util = util;
    __export(Decorators_1);
    __export(Detector_1);
    __export(CullingBox_2);
    __export(EasingFunctions_3);
    __export(Log_13);
    __export(SortedList_1);
});
define("Engine", ["require", "exports", "Index", "Promises", "Algebra", "UIActor", "Actor", "Timer", "TileMap", "Loader", "Util/Detector", "Events", "Util/Log", "Drawing/Color", "Scene", "Debug", "Class", "Input/Index", "Util/Util", "Collision/BoundingBox"], function (require, exports, Index_7, Promises_8, Algebra_22, UIActor_3, Actor_12, Timer_2, TileMap_2, Loader_2, Detector_2, Events_12, Log_14, Color_19, Scene_2, Debug_2, Class_9, Input, Util, BoundingBox_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Enum representing the different display modes available to Excalibur
     */
    var DisplayMode;
    (function (DisplayMode) {
        /**
         * Show the game as full screen
         */
        DisplayMode[DisplayMode["FullScreen"] = 0] = "FullScreen";
        /**
         * Scale the game to the parent DOM container
         */
        DisplayMode[DisplayMode["Container"] = 1] = "Container";
        /**
         * Show the game as a fixed size
         */
        DisplayMode[DisplayMode["Fixed"] = 2] = "Fixed";
        /**
         * Allow the game to be positioned with the [[IEngineOptions.position]] option
         */
        DisplayMode[DisplayMode["Position"] = 3] = "Position";
    })(DisplayMode = exports.DisplayMode || (exports.DisplayMode = {}));
    /**
     * Enum representing the different mousewheel event bubble prevention
     */
    var ScrollPreventionMode;
    (function (ScrollPreventionMode) {
        /**
         * Do not prevent any page scrolling
         */
        ScrollPreventionMode[ScrollPreventionMode["None"] = 0] = "None";
        /**
         * Prevent page scroll if mouse is over the game canvas
         */
        ScrollPreventionMode[ScrollPreventionMode["Canvas"] = 1] = "Canvas";
        /**
         * Prevent all page scrolling via mouse wheel
         */
        ScrollPreventionMode[ScrollPreventionMode["All"] = 2] = "All";
    })(ScrollPreventionMode = exports.ScrollPreventionMode || (exports.ScrollPreventionMode = {}));
    /**
     * The Excalibur Engine
     *
     * The [[Engine]] is the main driver for a game. It is responsible for
     * starting/stopping the game, maintaining state, transmitting events,
     * loading resources, and managing the scene.
     *
     * [[include:Engine.md]]
     */
    var Engine = (function (_super) {
        __extends(Engine, _super);
        /**
         * Creates a new game using the given [[IEngineOptions]]. By default, if no options are provided,
         * the game will be rendered full screen (taking up all available browser window space).
         * You can customize the game rendering through [[IEngineOptions]].
         *
         * Example:
         *
         * ```js
         * var game = new ex.Engine({
         *   width: 0, // the width of the canvas
         *   height: 0, // the height of the canvas
         *   canvasElementId: '', // the DOM canvas element ID, if you are providing your own
         *   displayMode: ex.DisplayMode.FullScreen, // the display mode
         *   pointerScope: ex.Input.PointerScope.Document, // the scope of capturing pointer (mouse/touch) events
         *   backgroundColor: ex.Color.fromHex('#2185d0') // background color of the engine
         * });
         *
         * // call game.start, which is a Promise
         * game.start().then(function () {
         *   // ready, set, go!
         * });
         * ```
         */
        function Engine(options) {
            var _this = _super.call(this) || this;
            _this._hasStarted = false;
            /**
             * Access Excalibur debugging functionality.
             */
            _this.debug = new Debug_2.Debug();
            /**
             * Gets or sets the list of post processors to apply at the end of drawing a frame (such as [[ColorBlindCorrector]])
             */
            _this.postProcessors = [];
            /**
             * Contains all the scenes currently registered with Excalibur
             */
            _this.scenes = {};
            _this._animations = [];
            /**
             * Indicates whether the engine is set to fullscreen or not
             */
            _this.isFullscreen = false;
            /**
             * Indicates the current [[DisplayMode]] of the engine.
             */
            _this.displayMode = DisplayMode.FullScreen;
            /**
             * Indicates whether audio should be paused when the game is no longer visible.
             */
            _this.pauseAudioWhenHidden = true;
            /**
             * Indicates whether the engine should draw with debug information
             */
            _this.isDebug = false;
            _this.debugColor = new Color_19.Color(255, 255, 255);
            /**
             * The action to take when a fatal exception is thrown
             */
            _this.onFatalException = function (e) { Log_14.Logger.getInstance().fatal(e); };
            _this._isSmoothingEnabled = true;
            _this._timescale = 1.0;
            _this._isLoading = false;
            options = Util.extend({}, Engine._DefaultEngineOptions, options);
            // Check compatibility 
            var detector = new Detector_2.Detector();
            if (!options.suppressMinimumBrowserFeatureDetection && !(_this._compatible = detector.test())) {
                var message = document.createElement('div');
                message.innerText = 'Sorry, your browser does not support all the features needed for Excalibur';
                document.body.appendChild(message);
                detector.failedTests.forEach(function (test) {
                    var testMessage = document.createElement('div');
                    testMessage.innerText = 'Browser feature missing ' + test;
                    document.body.appendChild(testMessage);
                });
                if (options.canvasElementId) {
                    var canvas = document.getElementById(options.canvasElementId);
                    if (canvas) {
                        canvas.parentElement.removeChild(canvas);
                    }
                }
                return _this;
            }
            else {
                _this._compatible = true;
            }
            // Use native console API for color fun
            if (console.log && !options.suppressConsoleBootMessage) {
                console.log("%cPowered by Excalibur.js (v" + Index_7.EX_VERSION + ")", 'background: #176BAA; color: white; border-radius: 5px; padding: 15px; font-size: 1.5em; line-height: 80px;');
                console.log('\n\
      /| ________________\n\
O|===|* >________________>\n\
      \\|');
                console.log('Visit', 'http://excaliburjs.com', 'for more information');
            }
            _this._logger = Log_14.Logger.getInstance();
            // If debug is enabled, let's log browser features to the console.
            if (_this._logger.defaultLevel === Log_14.LogLevel.Debug) {
                detector.logBrowserFeatures();
            }
            _this._logger.debug('Building engine...');
            _this.canvasElementId = options.canvasElementId;
            if (options.canvasElementId) {
                _this._logger.debug('Using Canvas element specified: ' + options.canvasElementId);
                _this.canvas = document.getElementById(options.canvasElementId);
            }
            else {
                _this._logger.debug('Using generated canvas element');
                _this.canvas = document.createElement('canvas');
            }
            if (options.width && options.height) {
                if (options.displayMode === undefined) {
                    _this.displayMode = DisplayMode.Fixed;
                }
                _this._logger.debug('Engine viewport is size ' + options.width + ' x ' + options.height);
                _this.canvas.width = options.width;
                _this.canvas.height = options.height;
            }
            else if (!options.displayMode) {
                _this._logger.debug('Engine viewport is fullscreen');
                _this.displayMode = DisplayMode.FullScreen;
            }
            if (options.backgroundColor) {
                _this.backgroundColor = options.backgroundColor.clone();
            }
            _this._loader = new Loader_2.Loader();
            _this._initialize(options);
            _this.rootScene = _this.currentScene = new Scene_2.Scene(_this);
            _this.addScene('root', _this.rootScene);
            _this.goToScene('root');
            return _this;
        }
        Object.defineProperty(Engine.prototype, "canvasWidth", {
            /**
             * The width of the game canvas in pixels (physical width component of the
             * resolution of the canvas element)
             */
            get: function () {
                return this.canvas.width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "halfCanvasWidth", {
            /**
             * Returns half width of the game canvas in pixels (half physical width component)
             */
            get: function () {
                return this.canvas.width / 2;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "canvasHeight", {
            /**
             * The height of the game canvas in pixels, (physical height component of
             * the resolution of the canvas element)
             */
            get: function () {
                return this.canvas.height;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "halfCanvasHeight", {
            /**
             * Returns half height of the game canvas in pixels (half physical height component)
             */
            get: function () {
                return this.canvas.height / 2;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "drawWidth", {
            /**
             * Returns the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
             */
            get: function () {
                if (this.currentScene && this.currentScene.camera) {
                    return (this.canvasWidth / this.currentScene.camera.getZoom()) / this.pixelRatio;
                }
                return this.canvasWidth / this.pixelRatio;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "halfDrawWidth", {
            /**
             * Returns half the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
             */
            get: function () {
                return this.drawWidth / 2;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "drawHeight", {
            /**
             * Returns the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
             */
            get: function () {
                if (this.currentScene && this.currentScene.camera) {
                    return (this.canvasHeight / this.currentScene.camera.getZoom()) / this.pixelRatio;
                }
                return this.canvasHeight / this.pixelRatio;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "halfDrawHeight", {
            /**
             * Returns half the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
             */
            get: function () {
                return this.drawHeight / 2;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "isHiDpi", {
            /**
             * Returns whether excalibur detects the current screen to be HiDPI
             */
            get: function () {
                return this.pixelRatio !== 1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "stats", {
            /**
             * Access [[stats]] that holds frame statistics.
             */
            get: function () {
                return this.debug.stats;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "pixelRatio", {
            /**
             * Returns the calculated pixel ration for use in rendering
             */
            get: function () {
                var devicePixelRatio = window.devicePixelRatio || 1;
                var pixelRatio = devicePixelRatio;
                return pixelRatio;
            },
            enumerable: true,
            configurable: true
        });
        Engine.prototype.on = function (eventName, handler) {
            _super.prototype.on.call(this, eventName, handler);
        };
        /**
         * Returns a BoundingBox of the top left corner of the screen
         * and the bottom right corner of the screen.
         */
        Engine.prototype.getWorldBounds = function () {
            var left = this.screenToWorldCoordinates(Algebra_22.Vector.Zero).x;
            var top = this.screenToWorldCoordinates(Algebra_22.Vector.Zero).y;
            var right = left + this.drawWidth;
            var bottom = top + this.drawHeight;
            return new BoundingBox_7.BoundingBox(left, top, right, bottom);
        };
        Object.defineProperty(Engine.prototype, "timescale", {
            /**
             * Gets the current engine timescale factor (default is 1.0 which is 1:1 time)
             */
            get: function () {
                return this._timescale;
            },
            /**
             * Sets the current engine timescale factor. Useful for creating slow-motion effects or fast-forward effects
             * when using time-based movement.
             */
            set: function (value) {
                if (value <= 0) {
                    Log_14.Logger.getInstance().error('Cannot set engine.timescale to a value of 0 or less than 0.');
                    return;
                }
                this._timescale = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Plays a sprite animation on the screen at the specified `x` and `y`
         * (in game coordinates, not screen pixels). These animations play
         * independent of actors, and will be cleaned up internally as soon
         * as they are complete. Note animations that loop will never be
         * cleaned up.
         *
         * @param animation  Animation to play
         * @param x          x game coordinate to play the animation
         * @param y          y game coordinate to play the animation
         */
        Engine.prototype.playAnimation = function (animation, x, y) {
            this._animations.push(new AnimationNode(animation, x, y));
        };
        /**
         * Adds a [[TileMap]] to the [[currentScene]], once this is done the TileMap
         * will be drawn and updated.
         */
        Engine.prototype.addTileMap = function (tileMap) {
            this.currentScene.addTileMap(tileMap);
        };
        /**
         * Removes a [[TileMap]] from the [[currentScene]], it will no longer be drawn or updated.
         */
        Engine.prototype.removeTileMap = function (tileMap) {
            this.currentScene.removeTileMap(tileMap);
        };
        /**
         * Adds a [[Timer]] to the [[currentScene]].
         * @param timer  The timer to add to the [[currentScene]].
         */
        Engine.prototype.addTimer = function (timer) {
            return this.currentScene.addTimer(timer);
        };
        /**
         * Removes a [[Timer]] from the [[currentScene]].
         * @param timer  The timer to remove to the [[currentScene]].
         */
        Engine.prototype.removeTimer = function (timer) {
            return this.currentScene.removeTimer(timer);
        };
        /**
         * Adds a [[Scene]] to the engine, think of scenes in Excalibur as you
         * would levels or menus.
         *
         * @param key  The name of the scene, must be unique
         * @param scene The scene to add to the engine
         */
        Engine.prototype.addScene = function (key, scene) {
            if (this.scenes[key]) {
                this._logger.warn('Scene', key, 'already exists overwriting');
            }
            this.scenes[key] = scene;
            scene.engine = this;
        };
        /**
         * @internal
         */
        Engine.prototype.removeScene = function (entity) {
            if (entity instanceof Scene_2.Scene) {
                // remove scene
                for (var key in this.scenes) {
                    if (this.scenes.hasOwnProperty(key)) {
                        if (this.scenes[key] === entity) {
                            delete this.scenes[key];
                        }
                    }
                }
            }
            if (typeof entity === 'string') {
                // remove scene
                delete this.scenes[entity];
            }
        };
        Engine.prototype.add = function (entity) {
            if (entity instanceof UIActor_3.UIActor) {
                this.currentScene.addUIActor(entity);
                return;
            }
            if (entity instanceof Actor_12.Actor) {
                this._addChild(entity);
            }
            if (entity instanceof Timer_2.Timer) {
                this.addTimer(entity);
            }
            if (entity instanceof TileMap_2.TileMap) {
                this.addTileMap(entity);
            }
            if (arguments.length === 2) {
                this.addScene(arguments[0], arguments[1]);
            }
        };
        Engine.prototype.remove = function (entity) {
            if (entity instanceof UIActor_3.UIActor) {
                this.currentScene.removeUIActor(entity);
                return;
            }
            if (entity instanceof Actor_12.Actor) {
                this._removeChild(entity);
            }
            if (entity instanceof Timer_2.Timer) {
                this.removeTimer(entity);
            }
            if (entity instanceof TileMap_2.TileMap) {
                this.removeTileMap(entity);
            }
            if (entity instanceof Scene_2.Scene) {
                this.removeScene(entity);
            }
            if (typeof entity === 'string') {
                this.removeScene(entity);
            }
        };
        /**
         * Adds an actor to the [[currentScene]] of the game. This is synonymous
         * to calling `engine.currentScene.add(actor)`.
         *
         * Actors can only be drawn if they are a member of a scene, and only
         * the [[currentScene]] may be drawn or updated.
         *
         * @param actor  The actor to add to the [[currentScene]]
         */
        Engine.prototype._addChild = function (actor) {
            this.currentScene.add(actor);
        };
        /**
         * Removes an actor from the [[currentScene]] of the game. This is synonymous
         * to calling `engine.currentScene.remove(actor)`.
         * Actors that are removed from a scene will no longer be drawn or updated.
         *
         * @param actor  The actor to remove from the [[currentScene]].
         */
        Engine.prototype._removeChild = function (actor) {
            this.currentScene.remove(actor);
        };
        /**
         * Changes the currently updating and drawing scene to a different,
         * named scene. Calls the [[Scene]] lifecycle events.
         * @param key  The key of the scene to transition to.
         */
        Engine.prototype.goToScene = function (key) {
            if (this.scenes[key]) {
                var oldScene = this.currentScene;
                var newScene = this.scenes[key];
                this._logger.debug('Going to scene:', key);
                // only deactivate when initialized
                if (this.currentScene.isInitialized) {
                    this.currentScene.onDeactivate.call(this.currentScene);
                    this.currentScene.eventDispatcher.emit('deactivate', new Events_12.DeactivateEvent(newScene, this.currentScene));
                }
                // set current scene to new one
                this.currentScene = newScene;
                // initialize the current scene if has not been already
                this.currentScene._initialize(this);
                this.currentScene.onActivate.call(this.currentScene);
                this.currentScene.eventDispatcher.emit('activate', new Events_12.ActivateEvent(oldScene, this.currentScene));
            }
            else {
                this._logger.error('Scene', key, 'does not exist!');
            }
        };
        /**
         * Transforms the current x, y from screen coordinates to world coordinates
         * @param point  Screen coordinate to convert
         */
        Engine.prototype.screenToWorldCoordinates = function (point) {
            var newX = point.x;
            var newY = point.y;
            // transform back to world space
            newX = (newX / this.canvas.clientWidth) * this.drawWidth;
            newY = (newY / this.canvas.clientHeight) * this.drawHeight;
            // transform based on zoom
            newX = newX - this.halfDrawWidth;
            newY = newY - this.halfDrawHeight;
            // shift by focus
            if (this.currentScene && this.currentScene.camera) {
                var focus = this.currentScene.camera.getFocus();
                newX += focus.x;
                newY += focus.y;
            }
            return new Algebra_22.Vector(Math.floor(newX), Math.floor(newY));
        };
        /**
         * Transforms a world coordinate, to a screen coordinate
         * @param point  World coordinate to convert
         */
        Engine.prototype.worldToScreenCoordinates = function (point) {
            var screenX = point.x;
            var screenY = point.y;
            // shift by focus
            if (this.currentScene && this.currentScene.camera) {
                var focus = this.currentScene.camera.getFocus();
                screenX -= focus.x;
                screenY -= focus.y;
            }
            // transform back on zoom
            screenX = screenX + this.halfDrawWidth;
            screenY = screenY + this.halfDrawHeight;
            // transform back to screen space
            screenX = (screenX * this.canvas.clientWidth) / this.drawWidth;
            screenY = (screenY * this.canvas.clientHeight) / this.drawHeight;
            return new Algebra_22.Vector(Math.floor(screenX), Math.floor(screenY));
        };
        /**
         * Sets the internal canvas height based on the selected display mode.
         */
        Engine.prototype._setHeightByDisplayMode = function (parent) {
            if (this.displayMode === DisplayMode.Container) {
                this.canvas.width = parent.clientWidth;
                this.canvas.height = parent.clientHeight;
            }
            if (this.displayMode === DisplayMode.FullScreen) {
                document.body.style.margin = '0px';
                document.body.style.overflow = 'hidden';
                this.canvas.width = parent.innerWidth;
                this.canvas.height = parent.innerHeight;
            }
        };
        /**
         * Initializes the internal canvas, rendering context, displaymode, and native event listeners
         */
        Engine.prototype._initialize = function (options) {
            var _this = this;
            if (options.displayMode) {
                this.displayMode = options.displayMode;
            }
            if (this.displayMode === DisplayMode.FullScreen || this.displayMode === DisplayMode.Container) {
                var parent = (this.displayMode === DisplayMode.Container ?
                    (this.canvas.parentElement || document.body) : window);
                this._setHeightByDisplayMode(parent);
                window.addEventListener('resize', function () {
                    _this._logger.debug('View port resized');
                    _this._setHeightByDisplayMode(parent);
                    _this._logger.info('parent.clientHeight ' + parent.clientHeight);
                    _this.setAntialiasing(_this._isSmoothingEnabled);
                });
            }
            else if (this.displayMode === DisplayMode.Position) {
                this._intializeDisplayModePosition(options);
            }
            // initialize inputs
            this.input = {
                keyboard: new Input.Keyboard(),
                pointers: new Input.Pointers(this),
                gamepads: new Input.Gamepads()
            };
            this.input.keyboard.init();
            this.input.pointers.init(options && options.pointerScope === Input.PointerScope.Document ? document : this.canvas);
            this.input.gamepads.init();
            this.pageScrollPreventionMode = options.scrollPreventionMode;
            // Issue #385 make use of the visibility api
            // https://developer.mozilla.org/en-US/docs/Web/Guide/User_experience/Using_the_Page_Visibility_API
            var hidden, visibilityChange;
            if (typeof document.hidden !== 'undefined') {
                hidden = 'hidden';
                visibilityChange = 'visibilitychange';
            }
            else if ('msHidden' in document) {
                hidden = 'msHidden';
                visibilityChange = 'msvisibilitychange';
            }
            else if ('webkitHidden' in document) {
                hidden = 'webkitHidden';
                visibilityChange = 'webkitvisibilitychange';
            }
            document.addEventListener(visibilityChange, function () {
                if (document[hidden]) {
                    _this.eventDispatcher.emit('hidden', new Events_12.HiddenEvent(_this));
                    _this._logger.debug('Window hidden');
                }
                else {
                    _this.eventDispatcher.emit('visible', new Events_12.VisibleEvent(_this));
                    _this._logger.debug('Window visible');
                }
            });
            this.ctx = this.canvas.getContext('2d');
            if (!options.suppressHiDPIScaling) {
                this._initializeHiDpi();
            }
            if (!this.canvasElementId) {
                document.body.appendChild(this.canvas);
            }
        };
        Engine.prototype._intializeDisplayModePosition = function (options) {
            if (!options.position) {
                throw new Error('DisplayMode of Position was selected but no position option was given');
            }
            else {
                this.canvas.style.display = 'block';
                this.canvas.style.position = 'absolute';
                if (typeof options.position === 'string') {
                    var specifiedPosition = options.position.split(' ');
                    switch (specifiedPosition[0]) {
                        case 'top':
                            this.canvas.style.top = '0px';
                            break;
                        case 'bottom':
                            this.canvas.style.bottom = '0px';
                            break;
                        case 'middle':
                            this.canvas.style.top = '50%';
                            var offsetY = -this.halfDrawHeight;
                            this.canvas.style.marginTop = offsetY.toString();
                            break;
                        default:
                            throw new Error('Invalid Position Given');
                    }
                    if (specifiedPosition[1]) {
                        switch (specifiedPosition[1]) {
                            case 'left':
                                this.canvas.style.left = '0px';
                                break;
                            case 'right':
                                this.canvas.style.right = '0px';
                                break;
                            case 'center':
                                this.canvas.style.left = '50%';
                                var offsetX = -this.halfDrawWidth;
                                this.canvas.style.marginLeft = offsetX.toString();
                                break;
                            default:
                                throw new Error('Invalid Position Given');
                        }
                    }
                }
                else {
                    if (options.position.top) {
                        typeof options.position.top === 'number' ?
                            this.canvas.style.top = options.position.top.toString() + 'px' :
                            this.canvas.style.top = options.position.top;
                    }
                    if (options.position.right) {
                        typeof options.position.right === 'number' ?
                            this.canvas.style.right = options.position.right.toString() + 'px' :
                            this.canvas.style.right = options.position.right;
                    }
                    if (options.position.bottom) {
                        typeof options.position.bottom === 'number' ?
                            this.canvas.style.bottom = options.position.bottom.toString() + 'px' :
                            this.canvas.style.bottom = options.position.bottom;
                    }
                    if (options.position.left) {
                        typeof options.position.left === 'number' ?
                            this.canvas.style.left = options.position.left.toString() + 'px' :
                            this.canvas.style.left = options.position.left;
                    }
                }
            }
        };
        Engine.prototype._initializeHiDpi = function () {
            // Scale the canvas if needed
            if (this.isHiDpi) {
                var oldWidth = this.canvas.width;
                var oldHeight = this.canvas.height;
                this.canvas.width = oldWidth * this.pixelRatio;
                this.canvas.height = oldHeight * this.pixelRatio;
                this.canvas.style.width = oldWidth + 'px';
                this.canvas.style.height = oldHeight + 'px';
                this._logger.warn("Hi DPI screen detected, resetting canvas resolution from \n                           " + oldWidth + "x" + oldHeight + " to " + this.canvas.width + "x" + this.canvas.height + " \n                           css size will remain " + oldWidth + "x" + oldHeight);
                this.ctx.scale(this.pixelRatio, this.pixelRatio);
                this._logger.warn("Canvas drawing context was scaled by " + this.pixelRatio);
            }
        };
        /**
         * If supported by the browser, this will set the antialiasing flag on the
         * canvas. Set this to `false` if you want a 'jagged' pixel art look to your
         * image resources.
         * @param isSmooth  Set smoothing to true or false
         */
        Engine.prototype.setAntialiasing = function (isSmooth) {
            this._isSmoothingEnabled = isSmooth;
            var ctx = this.ctx;
            ctx.imageSmoothingEnabled = isSmooth;
            for (var _i = 0, _a = ['webkitImageSmoothingEnabled', 'mozImageSmoothingEnabled', 'msImageSmoothingEnabled']; _i < _a.length; _i++) {
                var smoothing = _a[_i];
                if (smoothing in ctx) {
                    ctx[smoothing] = isSmooth;
                }
            }
            ;
        };
        /**
         * Return the current smoothing status of the canvas
         */
        Engine.prototype.getAntialiasing = function () {
            return this.ctx.imageSmoothingEnabled ||
                this.ctx.webkitImageSmoothingEnabled ||
                this.ctx.mozImageSmoothingEnabled ||
                this.ctx.msImageSmoothingEnabled;
        };
        /**
         * Updates the entire state of the game
         * @param delta  Number of milliseconds elapsed since the last update.
         */
        Engine.prototype._update = function (delta) {
            if (this._isLoading) {
                // suspend updates untill loading is finished
                this._loader.update(this, delta);
                // Update input listeners
                this.input.keyboard.update();
                this.input.pointers.update();
                this.input.gamepads.update();
                return;
            }
            this.emit('preupdate', new Events_12.PreUpdateEvent(this, delta, this));
            // process engine level events
            this.currentScene.update(this, delta);
            // update animations
            this._animations = this._animations.filter(function (a) {
                return !a.animation.isDone();
            });
            // Update input listeners
            this.input.keyboard.update();
            this.input.pointers.update();
            this.input.gamepads.update();
            // Publish update event
            this.emit('postupdate', new Events_12.PostUpdateEvent(this, delta, this));
        };
        /**
         * Draws the entire game
         * @param delta  Number of milliseconds elapsed since the last draw.
         */
        Engine.prototype._draw = function (delta) {
            var ctx = this.ctx;
            this.emit('predraw', new Events_12.PreDrawEvent(ctx, delta, this));
            if (this._isLoading) {
                this._loader.draw(ctx, delta);
                // Drawing nothing else while loading
                return;
            }
            ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
            ctx.fillStyle = this.backgroundColor.toString();
            ctx.fillRect(0, 0, this.canvasWidth, this.canvasHeight);
            this.currentScene.draw(this.ctx, delta);
            // todo needs to be a better way of doing this
            var a = 0, len = this._animations.length;
            for (a; a < len; a++) {
                this._animations[a].animation.draw(ctx, this._animations[a].x, this._animations[a].y);
            }
            // Draw debug information
            if (this.isDebug) {
                this.ctx.font = 'Consolas';
                this.ctx.fillStyle = this.debugColor.toString();
                var keys = this.input.keyboard.getKeys();
                for (var j = 0; j < keys.length; j++) {
                    this.ctx.fillText(keys[j].toString() + ' : ' + (Input.Keys[keys[j]] ? Input.Keys[keys[j]] : 'Not Mapped'), 100, 10 * j + 10);
                }
                this.ctx.fillText('FPS:' + this.stats.currFrame.fps.toFixed(2).toString(), 10, 10);
            }
            // Post processing
            for (var i = 0; i < this.postProcessors.length; i++) {
                this.postProcessors[i].process(this.ctx.getImageData(0, 0, this.canvasWidth, this.canvasHeight), this.ctx);
            }
            this.emit('postdraw', new Events_12.PostDrawEvent(ctx, delta, this));
        };
        /**
         * Starts the internal game loop for Excalibur after loading
         * any provided assets.
         * @param loader  Optional [[ILoader]] to use to load resources. The default loader is [[Loader]], override to provide your own
         * custom loader.
         */
        Engine.prototype.start = function (loader) {
            var _this = this;
            if (!this._compatible) {
                var promise = new Promises_8.Promise();
                return promise.reject('Excalibur is incompatible with your browser');
            }
            var loadingComplete;
            if (loader) {
                this._loader = loader;
                this._loader.wireEngine(this);
                loadingComplete = this.load(this._loader);
            }
            else {
                loadingComplete = Promises_8.Promise.resolve();
            }
            loadingComplete.then(function () {
                _this.emit('start', new Events_12.GameStartEvent(_this));
            });
            if (!this._hasStarted) {
                this._hasStarted = true;
                this._logger.debug('Starting game...');
                Engine.createMainLoop(this, window.requestAnimationFrame, Date.now)();
                this._logger.debug('Game started');
            }
            else {
                // Game already started;
            }
            return loadingComplete;
        };
        Engine.createMainLoop = function (game, raf, nowFn) {
            var lastTime = nowFn();
            return function mainloop() {
                if (!game._hasStarted) {
                    return;
                }
                try {
                    game._requestId = raf(mainloop);
                    game.emit('preframe', new Events_12.PreFrameEvent(game, game.stats.prevFrame));
                    // Get the time to calculate time-elapsed
                    var now = nowFn();
                    var elapsed = Math.floor(now - lastTime) || 1;
                    // Resolves issue #138 if the game has been paused, or blurred for 
                    // more than a 200 milliseconds, reset elapsed time to 1. This improves reliability 
                    // and provides more expected behavior when the engine comes back
                    // into focus
                    if (elapsed > 200) {
                        elapsed = 1;
                    }
                    var delta = elapsed * game.timescale;
                    // reset frame stats (reuse existing instances)
                    var frameId = game.stats.prevFrame.id + 1;
                    game.stats.prevFrame.reset(game.stats.currFrame);
                    game.stats.currFrame.reset();
                    game.stats.currFrame.id = frameId;
                    game.stats.currFrame.delta = delta;
                    game.stats.currFrame.fps = 1.0 / (delta / 1000);
                    var beforeUpdate = nowFn();
                    game._update(delta);
                    var afterUpdate = nowFn();
                    game._draw(delta);
                    var afterDraw = nowFn();
                    game.stats.currFrame.duration.update = afterUpdate - beforeUpdate;
                    game.stats.currFrame.duration.draw = afterDraw - afterUpdate;
                    lastTime = now;
                    game.emit('postframe', new Events_12.PostFrameEvent(game, game.stats.currFrame));
                }
                catch (e) {
                    window.cancelAnimationFrame(game._requestId);
                    game.stop();
                    game.onFatalException(e);
                }
            };
        };
        /**
         * Stops Excalibur's main loop, useful for pausing the game.
         */
        Engine.prototype.stop = function () {
            if (this._hasStarted) {
                this.emit('stop', new Events_12.GameStopEvent(this));
                this._hasStarted = false;
                this._logger.debug('Game stopped');
            }
        };
        /**
         * Returns the Engine's Running status, Useful for checking whether engine is running or paused.
         */
        Engine.prototype.isPaused = function () {
            return !(this._hasStarted);
        };
        /**
         * Takes a screen shot of the current viewport and returns it as an
         * HTML Image Element.
         */
        Engine.prototype.screenshot = function () {
            var result = new Image();
            var raw = this.canvas.toDataURL('image/png');
            result.src = raw;
            return result;
        };
        /**
         * Another option available to you to load resources into the game.
         * Immediately after calling this the game will pause and the loading screen
         * will appear.
         * @param loader  Some [[ILoadable]] such as a [[Loader]] collection, [[Sound]], or [[Texture]].
         */
        Engine.prototype.load = function (loader) {
            var _this = this;
            var complete = new Promises_8.Promise();
            this._isLoading = true;
            loader.load().then(function () {
                setTimeout(function () {
                    _this._isLoading = false;
                    complete.resolve();
                }, 500);
            });
            return complete;
        };
        return Engine;
    }(Class_9.Class));
    /**
     * Default [[IEngineOptions]]
     */
    Engine._DefaultEngineOptions = {
        width: 0,
        height: 0,
        canvasElementId: '',
        pointerScope: Input.PointerScope.Document,
        suppressConsoleBootMessage: null,
        suppressMinimumBrowserFeatureDetection: null,
        suppressHiDPIScaling: null,
        scrollPreventionMode: ScrollPreventionMode.Canvas,
        backgroundColor: Color_19.Color.fromHex('#2185d0') // Excalibur blue
    };
    exports.Engine = Engine;
    /**
     * @internal
     */
    var AnimationNode = (function () {
        function AnimationNode(animation, x, y) {
            this.animation = animation;
            this.x = x;
            this.y = y;
        }
        return AnimationNode;
    }());
});
define("UIActor", ["require", "exports", "Algebra", "Actor", "Traits/Index"], function (require, exports, Algebra_23, Actor_13, Traits) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Helper [[Actor]] primitive for drawing UI's, optimized for UI drawing. Does
     * not participate in collisions. Drawn on top of all other actors.
     */
    var UIActor = (function (_super) {
        __extends(UIActor, _super);
        /**
         * @param x       The starting x coordinate of the actor
         * @param y       The starting y coordinate of the actor
         * @param width   The starting width of the actor
         * @param height  The starting height of the actor
         */
        function UIActor(xOrConfig, y, width, height) {
            var _this = this;
            if (typeof (xOrConfig !== 'object')) {
                _this = _super.call(this, xOrConfig, y, width, height) || this;
            }
            else {
                _this = _super.call(this, xOrConfig) || this;
            }
            _this.traits = [];
            _this.traits.push(new Traits.CapturePointer());
            _this.anchor.setTo(0, 0);
            _this.collisionType = Actor_13.CollisionType.PreventCollision;
            _this.enableCapturePointer = true;
            return _this;
        }
        UIActor.prototype.onInitialize = function (engine) {
            this._engine = engine;
        };
        UIActor.prototype.contains = function (x, y, useWorld) {
            if (useWorld === void 0) { useWorld = true; }
            if (useWorld) {
                return _super.prototype.contains.call(this, x, y);
            }
            var coords = this._engine.worldToScreenCoordinates(new Algebra_23.Vector(x, y));
            return _super.prototype.contains.call(this, coords.x, coords.y);
        };
        return UIActor;
    }(Actor_13.Actor));
    exports.UIActor = UIActor;
});
define("Util/Actors", ["require", "exports", "UIActor", "Label", "Trigger"], function (require, exports, UIActor_4, Label_3, Trigger_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isVanillaActor(actor) {
        return !(actor instanceof UIActor_4.UIActor) &&
            !(actor instanceof Trigger_2.Trigger) &&
            !(actor instanceof Label_3.Label);
    }
    exports.isVanillaActor = isVanillaActor;
    function isUIActor(actor) {
        return actor instanceof UIActor_4.UIActor;
    }
    exports.isUIActor = isUIActor;
});
define("Scene", ["require", "exports", "UIActor", "Physics", "Events", "Util/Log", "Timer", "Collision/DynamicTreeCollisionBroadphase", "Util/SortedList", "Group", "TileMap", "Camera", "Actor", "Class", "Util/Util", "Util/Actors", "Trigger"], function (require, exports, UIActor_5, Physics_12, Events_13, Log_15, Timer_3, DynamicTreeCollisionBroadphase_2, SortedList_2, Group_2, TileMap_3, Camera_2, Actor_14, Class_10, Util, ActorUtils, Trigger_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * [[Actor|Actors]] are composed together into groupings called Scenes in
     * Excalibur. The metaphor models the same idea behind real world
     * actors in a scene. Only actors in scenes will be updated and drawn.
     *
     * Typical usages of a scene include: levels, menus, loading screens, etc.
     *
     * [[include:Scenes.md]]
     */
    var Scene = (function (_super) {
        __extends(Scene, _super);
        function Scene(engine) {
            var _this = _super.call(this) || this;
            /**
             * The actors in the current scene
             */
            _this.actors = [];
            /**
             * The triggers in the current scene
             */
            _this.triggers = [];
            /**
             * The [[TileMap]]s in the scene, if any
             */
            _this.tileMaps = [];
            /**
             * The [[Group]]s in the scene, if any
             */
            _this.groups = {};
            /**
             * The [[UIActor]]s in a scene, if any; these are drawn last
             */
            _this.uiActors = [];
            _this._isInitialized = false;
            _this._sortedDrawingTree = new SortedList_2.SortedList(Actor_14.Actor.prototype.getZIndex);
            _this._broadphase = new DynamicTreeCollisionBroadphase_2.DynamicTreeCollisionBroadphase();
            _this._killQueue = [];
            _this._triggerKillQueue = [];
            _this._timers = [];
            _this._cancelQueue = [];
            _this._logger = Log_15.Logger.getInstance();
            _this.camera = new Camera_2.BaseCamera();
            if (engine) {
                _this.camera.x = engine.halfDrawWidth;
                _this.camera.y = engine.halfDrawHeight;
            }
            return _this;
        }
        Scene.prototype.on = function (eventName, handler) {
            _super.prototype.on.call(this, eventName, handler);
        };
        /**
         * This is called before the first update of the [[Scene]]. Initializes scene members like the camera. This method is meant to be
         * overridden. This is where initialization of child actors should take place.
         */
        Scene.prototype.onInitialize = function (engine) {
            // will be overridden
            if (this.camera) {
                this.camera.x = engine.halfDrawWidth;
                this.camera.y = engine.halfDrawHeight;
            }
            this._logger.debug('Scene.onInitialize', this, engine);
        };
        /**
         * This is called when the scene is made active and started. It is meant to be overriden,
         * this is where you should setup any DOM UI or event handlers needed for the scene.
         */
        Scene.prototype.onActivate = function () {
            // will be overridden
            this._logger.debug('Scene.onActivate', this);
        };
        /**
         * This is called when the scene is made transitioned away from and stopped. It is meant to be overriden,
         * this is where you should cleanup any DOM UI or event handlers needed for the scene.
         */
        Scene.prototype.onDeactivate = function () {
            // will be overridden
            this._logger.debug('Scene.onDeactivate', this);
        };
        /**
         * Initializes actors in the scene
         */
        Scene.prototype._initializeChildren = function () {
            for (var _i = 0, _a = this.actors; _i < _a.length; _i++) {
                var child = _a[_i];
                child._initialize(this.engine);
            }
        };
        Object.defineProperty(Scene.prototype, "isInitialized", {
            /**
             * Gets whether or not the [[Scene]] has been initialized
             */
            get: function () {
                return this._isInitialized;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Initializes the scene before the first update, meant to be called by engine not by users of
         * Excalibur
         * @internal
         */
        Scene.prototype._initialize = function (engine) {
            if (!this.isInitialized) {
                this.onInitialize.call(this, engine);
                this.eventDispatcher.emit('initialize', new Events_13.InitializeEvent(engine, this));
                this._initializeChildren();
                this._isInitialized = true;
            }
        };
        /**
         * Updates all the actors and timers in the scene. Called by the [[Engine]].
         * @param engine  Reference to the current Engine
         * @param delta   The number of milliseconds since the last update
         */
        Scene.prototype.update = function (engine, delta) {
            this.emit('preupdate', new Events_13.PreUpdateEvent(engine, delta, this));
            var i, len;
            // Remove timers in the cancel queue before updating them
            for (i = 0, len = this._cancelQueue.length; i < len; i++) {
                this.removeTimer(this._cancelQueue[i]);
            }
            this._cancelQueue.length = 0;
            // Cycle through timers updating timers
            for (var _i = 0, _a = this._timers; _i < _a.length; _i++) {
                var timer = _a[_i];
                timer.update(delta);
            }
            ;
            // Cycle through actors updating UI actors
            for (i = 0, len = this.uiActors.length; i < len; i++) {
                this.uiActors[i].update(engine, delta);
            }
            // Cycle through actors updating tile maps
            for (i = 0, len = this.tileMaps.length; i < len; i++) {
                this.tileMaps[i].update(engine, delta);
            }
            // Cycle through actors updating actors
            for (i = 0, len = this.actors.length; i < len; i++) {
                this.actors[i].update(engine, delta);
            }
            // Cycle through triggers updating
            for (i = 0, len = this.triggers.length; i < len; i++) {
                this.triggers[i].update(engine, delta);
            }
            this._collectActorStats(engine);
            // Run the broadphase and narrowphase
            if (this._broadphase && Physics_12.Physics.enabled) {
                var beforeBroadphase = Date.now();
                this._broadphase.update(this.actors, delta);
                var pairs = this._broadphase.broadphase(this.actors, delta, engine.stats.currFrame);
                var afterBroadphase = Date.now();
                var beforeNarrowphase = Date.now();
                var iter = Physics_12.Physics.collisionPasses;
                var collisionDelta = delta / iter;
                while (iter > 0) {
                    // Run the narrowphase
                    pairs = this._broadphase.narrowphase(pairs, engine.stats.currFrame);
                    // Run collision resolution strategy
                    pairs = this._broadphase.resolve(pairs, collisionDelta, Physics_12.Physics.collisionResolutionStrategy);
                    this._broadphase.runCollisionStartEnd(pairs);
                    iter--;
                }
                var afterNarrowphase = Date.now();
                engine.stats.currFrame.physics.broadphase = afterBroadphase - beforeBroadphase;
                engine.stats.currFrame.physics.narrowphase = afterNarrowphase - beforeNarrowphase;
            }
            engine.stats.currFrame.actors.killed = this._killQueue.length + this._triggerKillQueue.length;
            this._processKillQueue(this._killQueue, this.actors);
            this._processKillQueue(this._triggerKillQueue, this.triggers);
            if (this.camera) {
                this.camera.update(engine, delta);
            }
            this.emit('postupdate', new Events_13.PostUpdateEvent(engine, delta, this));
        };
        Scene.prototype._processKillQueue = function (killQueue, collection) {
            // Remove actors from scene graph after being killed
            var actorIndex;
            for (var _i = 0, killQueue_1 = killQueue; _i < killQueue_1.length; _i++) {
                var killed = killQueue_1[_i];
                actorIndex = collection.indexOf(killed);
                if (actorIndex > -1) {
                    this._sortedDrawingTree.removeByComparable(killed);
                    collection.splice(actorIndex, 1);
                }
            }
            killQueue.length = 0;
        };
        /**
         * Draws all the actors in the Scene. Called by the [[Engine]].
         * @param ctx    The current rendering context
         * @param delta  The number of milliseconds since the last draw
         */
        Scene.prototype.draw = function (ctx, delta) {
            this.emit('predraw', new Events_13.PreDrawEvent(ctx, delta, this));
            ctx.save();
            if (this.camera) {
                this.camera.draw(ctx);
            }
            var i, len;
            for (i = 0, len = this.tileMaps.length; i < len; i++) {
                this.tileMaps[i].draw(ctx, delta);
            }
            var sortedChildren = this._sortedDrawingTree.list();
            for (i = 0, len = sortedChildren.length; i < len; i++) {
                // only draw actors that are visible and on screen
                if (sortedChildren[i].visible && !sortedChildren[i].isOffScreen) {
                    sortedChildren[i].draw(ctx, delta);
                }
            }
            if (this.engine && this.engine.isDebug) {
                ctx.strokeStyle = 'yellow';
                this.debugDraw(ctx);
            }
            ctx.restore();
            for (i = 0, len = this.uiActors.length; i < len; i++) {
                // only draw ui actors that are visible and on screen
                if (this.uiActors[i].visible) {
                    this.uiActors[i].draw(ctx, delta);
                }
            }
            if (this.engine && this.engine.isDebug) {
                for (i = 0, len = this.uiActors.length; i < len; i++) {
                    this.uiActors[i].debugDraw(ctx);
                }
            }
            this.emit('postdraw', new Events_13.PostDrawEvent(ctx, delta, this));
        };
        /**
         * Draws all the actors' debug information in the Scene. Called by the [[Engine]].
         * @param ctx  The current rendering context
         */
        /* istanbul ignore next */
        Scene.prototype.debugDraw = function (ctx) {
            this.emit('predebugdraw', new Events_13.PreDebugDrawEvent(ctx, this));
            var i, len;
            for (i = 0, len = this.tileMaps.length; i < len; i++) {
                this.tileMaps[i].debugDraw(ctx);
            }
            for (i = 0, len = this.actors.length; i < len; i++) {
                this.actors[i].debugDraw(ctx);
            }
            for (i = 0, len = this.triggers.length; i < len; i++) {
                this.triggers[i].debugDraw(ctx);
            }
            this._broadphase.debugDraw(ctx, 20);
            this.camera.debugDraw(ctx);
            this.emit('postdebugdraw', new Events_13.PostDebugDrawEvent(ctx, this));
        };
        /**
         * Checks whether an actor is contained in this scene or not
         */
        Scene.prototype.contains = function (actor) {
            return this.actors.indexOf(actor) > -1;
        };
        Scene.prototype.add = function (entity) {
            if (entity instanceof Actor_14.Actor) {
                entity.unkill();
            }
            if (entity instanceof UIActor_5.UIActor) {
                if (!Util.contains(this.uiActors, entity)) {
                    this.addUIActor(entity);
                }
                return;
            }
            if (entity instanceof Actor_14.Actor) {
                if (!Util.contains(this.actors, entity)) {
                    this._addChild(entity);
                }
                return;
            }
            if (entity instanceof Timer_3.Timer) {
                if (!Util.contains(this._timers, entity)) {
                    this.addTimer(entity);
                }
                return;
            }
            if (entity instanceof TileMap_3.TileMap) {
                if (!Util.contains(this.tileMaps, entity)) {
                    this.addTileMap(entity);
                }
            }
        };
        Scene.prototype.remove = function (entity) {
            if (entity instanceof UIActor_5.UIActor) {
                this.removeUIActor(entity);
                return;
            }
            if (entity instanceof Actor_14.Actor) {
                this._broadphase.untrack(entity.body);
                this._removeChild(entity);
            }
            if (entity instanceof Timer_3.Timer) {
                this.removeTimer(entity);
            }
            if (entity instanceof TileMap_3.TileMap) {
                this.removeTileMap(entity);
            }
        };
        /**
         * Adds (any) actor to act as a piece of UI, meaning it is always positioned
         * in screen coordinates. UI actors do not participate in collisions.
         * @todo Should this be `UIActor` only?
         */
        Scene.prototype.addUIActor = function (actor) {
            this.uiActors.push(actor);
            actor.scene = this;
        };
        /**
         * Removes an actor as a piece of UI
         */
        Scene.prototype.removeUIActor = function (actor) {
            var index = this.uiActors.indexOf(actor);
            if (index > -1) {
                this.uiActors.splice(index, 1);
            }
        };
        /**
         * Adds an actor to the scene, once this is done the actor will be drawn and updated.
         */
        Scene.prototype._addChild = function (actor) {
            this._broadphase.track(actor.body);
            actor.scene = this;
            if (actor instanceof Trigger_3.Trigger) {
                this.triggers.push(actor);
            }
            else {
                this.actors.push(actor);
            }
            this._sortedDrawingTree.add(actor);
        };
        /**
         * Adds a [[TileMap]] to the scene, once this is done the TileMap will be drawn and updated.
         */
        Scene.prototype.addTileMap = function (tileMap) {
            this.tileMaps.push(tileMap);
        };
        /**
         * Removes a [[TileMap]] from the scene, it will no longer be drawn or updated.
         */
        Scene.prototype.removeTileMap = function (tileMap) {
            var index = this.tileMaps.indexOf(tileMap);
            if (index > -1) {
                this.tileMaps.splice(index, 1);
            }
        };
        /**
         * Removes an actor from the scene, it will no longer be drawn or updated.
         */
        Scene.prototype._removeChild = function (actor) {
            this._broadphase.untrack(actor.body);
            if (actor instanceof Trigger_3.Trigger) {
                this._triggerKillQueue.push(actor);
            }
            else {
                this._killQueue.push(actor);
            }
            actor.parent = null;
        };
        /**
         * Adds a [[Timer]] to the scene
         * @param timer  The timer to add
         */
        Scene.prototype.addTimer = function (timer) {
            this._timers.push(timer);
            timer.scene = this;
            return timer;
        };
        /**
         * Removes a [[Timer]] from the scene.
         * @warning Can be dangerous, use [[cancelTimer]] instead
         * @param timer  The timer to remove
         */
        Scene.prototype.removeTimer = function (timer) {
            var i = this._timers.indexOf(timer);
            if (i !== -1) {
                this._timers.splice(i, 1);
            }
            return timer;
        };
        /**
         * Cancels a [[Timer]], removing it from the scene nicely
         * @param timer  The timer to cancel
         */
        Scene.prototype.cancelTimer = function (timer) {
            this._cancelQueue.push(timer);
            return timer;
        };
        /**
         * Tests whether a [[Timer]] is active in the scene
         */
        Scene.prototype.isTimerActive = function (timer) {
            return (this._timers.indexOf(timer) > -1 && !timer.complete);
        };
        /**
         * Creates and adds a [[Group]] to the scene with a name
         */
        Scene.prototype.createGroup = function (name) {
            return new Group_2.Group(name, this);
        };
        /**
         * Returns a [[Group]] by name
         */
        Scene.prototype.getGroup = function (name) {
            return this.groups[name];
        };
        Scene.prototype.removeGroup = function (group) {
            if (typeof group === 'string') {
                delete this.groups[group];
            }
            else if (group instanceof Group_2.Group) {
                delete this.groups[group.name];
            }
            else {
                this._logger.error('Invalid arguments to removeGroup', group);
            }
        };
        /**
         * Removes the given actor from the sorted drawing tree
         */
        Scene.prototype.cleanupDrawTree = function (actor) {
            this._sortedDrawingTree.removeByComparable(actor);
        };
        /**
         * Updates the given actor's position in the sorted drawing tree
         */
        Scene.prototype.updateDrawTree = function (actor) {
            this._sortedDrawingTree.add(actor);
        };
        Scene.prototype._collectActorStats = function (engine) {
            for (var _i = 0, _a = this.uiActors; _i < _a.length; _i++) {
                var _ui = _a[_i];
                engine.stats.currFrame.actors.ui++;
            }
            for (var _b = 0, _c = this.actors; _b < _c.length; _b++) {
                var actor = _c[_b];
                engine.stats.currFrame.actors.alive++;
                for (var _d = 0, _e = actor.children; _d < _e.length; _d++) {
                    var child = _e[_d];
                    if (ActorUtils.isUIActor(child)) {
                        engine.stats.currFrame.actors.ui++;
                    }
                    else {
                        engine.stats.currFrame.actors.alive++;
                    }
                }
            }
        };
        return Scene;
    }(Class_10.Class));
    exports.Scene = Scene;
});
define("Events", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Base event type in Excalibur that all other event types derive from. Not all event types are thrown on all Excalibur game objects,
     * some events are unique to a type, others are not.
     *
     */
    var GameEvent = (function () {
        function GameEvent() {
        }
        return GameEvent;
    }());
    exports.GameEvent = GameEvent;
    /**
     * The 'kill' event is emitted on actors when it is killed. The target is the actor that was killed.
     */
    var KillEvent = (function (_super) {
        __extends(KillEvent, _super);
        function KillEvent(target) {
            var _this = _super.call(this) || this;
            _this.target = target;
            return _this;
        }
        return KillEvent;
    }(GameEvent));
    exports.KillEvent = KillEvent;
    /**
     * The 'start' event is emitted on engine when has started and is ready for interaction.
     */
    var GameStartEvent = (function (_super) {
        __extends(GameStartEvent, _super);
        function GameStartEvent(target) {
            var _this = _super.call(this) || this;
            _this.target = target;
            return _this;
        }
        return GameStartEvent;
    }(GameEvent));
    exports.GameStartEvent = GameStartEvent;
    /**
     * The 'stop' event is emitted on engine when has been stopped and will no longer take input, update or draw.
     */
    var GameStopEvent = (function (_super) {
        __extends(GameStopEvent, _super);
        function GameStopEvent(target) {
            var _this = _super.call(this) || this;
            _this.target = target;
            return _this;
        }
        return GameStopEvent;
    }(GameEvent));
    exports.GameStopEvent = GameStopEvent;
    /**
     * The 'predraw' event is emitted on actors, scenes, and engine before drawing starts. Actors' predraw happens inside their graphics
     * transform so that all drawing takes place with the actor as the origin.
     *
     */
    var PreDrawEvent = (function (_super) {
        __extends(PreDrawEvent, _super);
        function PreDrawEvent(ctx, delta, target) {
            var _this = _super.call(this) || this;
            _this.ctx = ctx;
            _this.delta = delta;
            _this.target = target;
            return _this;
        }
        return PreDrawEvent;
    }(GameEvent));
    exports.PreDrawEvent = PreDrawEvent;
    /**
     * The 'postdraw' event is emitted on actors, scenes, and engine after drawing finishes. Actors' postdraw happens inside their graphics
     * transform so that all drawing takes place with the actor as the origin.
     *
     */
    var PostDrawEvent = (function (_super) {
        __extends(PostDrawEvent, _super);
        function PostDrawEvent(ctx, delta, target) {
            var _this = _super.call(this) || this;
            _this.ctx = ctx;
            _this.delta = delta;
            _this.target = target;
            return _this;
        }
        return PostDrawEvent;
    }(GameEvent));
    exports.PostDrawEvent = PostDrawEvent;
    /**
     * The 'predebugdraw' event is emitted on actors, scenes, and engine before debug drawing starts.
     */
    var PreDebugDrawEvent = (function (_super) {
        __extends(PreDebugDrawEvent, _super);
        function PreDebugDrawEvent(ctx, target) {
            var _this = _super.call(this) || this;
            _this.ctx = ctx;
            _this.target = target;
            return _this;
        }
        return PreDebugDrawEvent;
    }(GameEvent));
    exports.PreDebugDrawEvent = PreDebugDrawEvent;
    /**
     * The 'postdebugdraw' event is emitted on actors, scenes, and engine after debug drawing starts.
     */
    var PostDebugDrawEvent = (function (_super) {
        __extends(PostDebugDrawEvent, _super);
        function PostDebugDrawEvent(ctx, target) {
            var _this = _super.call(this) || this;
            _this.ctx = ctx;
            _this.target = target;
            return _this;
        }
        return PostDebugDrawEvent;
    }(GameEvent));
    exports.PostDebugDrawEvent = PostDebugDrawEvent;
    /**
     * The 'preupdate' event is emitted on actors, scenes, and engine before the update starts.
     */
    var PreUpdateEvent = (function (_super) {
        __extends(PreUpdateEvent, _super);
        function PreUpdateEvent(engine, delta, target) {
            var _this = _super.call(this) || this;
            _this.engine = engine;
            _this.delta = delta;
            _this.target = target;
            return _this;
        }
        return PreUpdateEvent;
    }(GameEvent));
    exports.PreUpdateEvent = PreUpdateEvent;
    /**
     * The 'postupdate' event is emitted on actors, scenes, and engine after the update ends.
     */
    var PostUpdateEvent = (function (_super) {
        __extends(PostUpdateEvent, _super);
        function PostUpdateEvent(engine, delta, target) {
            var _this = _super.call(this) || this;
            _this.engine = engine;
            _this.delta = delta;
            _this.target = target;
            return _this;
        }
        return PostUpdateEvent;
    }(GameEvent));
    exports.PostUpdateEvent = PostUpdateEvent;
    /**
     * The 'preframe' event is emitted on the engine, before the frame begins.
     */
    var PreFrameEvent = (function (_super) {
        __extends(PreFrameEvent, _super);
        function PreFrameEvent(engine, prevStats) {
            var _this = _super.call(this) || this;
            _this.engine = engine;
            _this.prevStats = prevStats;
            _this.target = engine;
            return _this;
        }
        return PreFrameEvent;
    }(GameEvent));
    exports.PreFrameEvent = PreFrameEvent;
    /**
     * The 'postframe' event is emitted on the engine, after a frame ends.
     */
    var PostFrameEvent = (function (_super) {
        __extends(PostFrameEvent, _super);
        function PostFrameEvent(engine, stats) {
            var _this = _super.call(this) || this;
            _this.engine = engine;
            _this.stats = stats;
            _this.target = engine;
            return _this;
        }
        return PostFrameEvent;
    }(GameEvent));
    exports.PostFrameEvent = PostFrameEvent;
    /**
     * Event received when a gamepad is connected to Excalibur. [[Gamepads]] receives this event.
     */
    var GamepadConnectEvent = (function (_super) {
        __extends(GamepadConnectEvent, _super);
        function GamepadConnectEvent(index, gamepad) {
            var _this = _super.call(this) || this;
            _this.index = index;
            _this.gamepad = gamepad;
            _this.target = gamepad;
            return _this;
        }
        return GamepadConnectEvent;
    }(GameEvent));
    exports.GamepadConnectEvent = GamepadConnectEvent;
    /**
     * Event received when a gamepad is disconnected from Excalibur. [[Gamepads]] receives this event.
     */
    var GamepadDisconnectEvent = (function (_super) {
        __extends(GamepadDisconnectEvent, _super);
        function GamepadDisconnectEvent(index, gamepad) {
            var _this = _super.call(this) || this;
            _this.index = index;
            _this.gamepad = gamepad;
            _this.target = gamepad;
            return _this;
        }
        return GamepadDisconnectEvent;
    }(GameEvent));
    exports.GamepadDisconnectEvent = GamepadDisconnectEvent;
    /**
     * Gamepad button event. See [[Gamepads]] for information on responding to controller input. [[Gamepad]] instances receive this event;
     */
    var GamepadButtonEvent = (function (_super) {
        __extends(GamepadButtonEvent, _super);
        /**
         * @param button  The Gamepad button
         * @param value   A numeric value between 0 and 1
         */
        function GamepadButtonEvent(button, value, target) {
            var _this = _super.call(this) || this;
            _this.button = button;
            _this.value = value;
            _this.target = target;
            return _this;
        }
        return GamepadButtonEvent;
    }(GameEvent));
    exports.GamepadButtonEvent = GamepadButtonEvent;
    /**
     * Gamepad axis event. See [[Gamepads]] for information on responding to controller input. [[Gamepad]] instances receive this event;
     */
    var GamepadAxisEvent = (function (_super) {
        __extends(GamepadAxisEvent, _super);
        /**
         * @param axis  The Gamepad axis
         * @param value A numeric value between -1 and 1
         */
        function GamepadAxisEvent(axis, value, target) {
            var _this = _super.call(this) || this;
            _this.axis = axis;
            _this.value = value;
            _this.target = target;
            return _this;
        }
        return GamepadAxisEvent;
    }(GameEvent));
    exports.GamepadAxisEvent = GamepadAxisEvent;
    /**
     * Subscribe event thrown when handlers for events other than subscribe are added. Meta event that is received by
     * [[EventDispatcher|event dispatchers]].
     */
    var SubscribeEvent = (function (_super) {
        __extends(SubscribeEvent, _super);
        function SubscribeEvent(topic, handler) {
            var _this = _super.call(this) || this;
            _this.topic = topic;
            _this.handler = handler;
            return _this;
        }
        return SubscribeEvent;
    }(GameEvent));
    exports.SubscribeEvent = SubscribeEvent;
    /**
     * Unsubscribe event thrown when handlers for events other than unsubscribe are removed. Meta event that is received by
     * [[EventDispatcher|event dispatchers]].
     */
    var UnsubscribeEvent = (function (_super) {
        __extends(UnsubscribeEvent, _super);
        function UnsubscribeEvent(topic, handler) {
            var _this = _super.call(this) || this;
            _this.topic = topic;
            _this.handler = handler;
            return _this;
        }
        return UnsubscribeEvent;
    }(GameEvent));
    exports.UnsubscribeEvent = UnsubscribeEvent;
    /**
     * Event received by the [[Engine]] when the browser window is visible on a screen.
     */
    var VisibleEvent = (function (_super) {
        __extends(VisibleEvent, _super);
        function VisibleEvent(target) {
            var _this = _super.call(this) || this;
            _this.target = target;
            return _this;
        }
        return VisibleEvent;
    }(GameEvent));
    exports.VisibleEvent = VisibleEvent;
    /**
     * Event received by the [[Engine]] when the browser window is hidden from all screens.
     */
    var HiddenEvent = (function (_super) {
        __extends(HiddenEvent, _super);
        function HiddenEvent(target) {
            var _this = _super.call(this) || this;
            _this.target = target;
            return _this;
        }
        return HiddenEvent;
    }(GameEvent));
    exports.HiddenEvent = HiddenEvent;
    /**
     * Event thrown on an [[Actor|actor]] when a collision will occur this frame if it resolves
     */
    var PreCollisionEvent = (function (_super) {
        __extends(PreCollisionEvent, _super);
        /**
         * @param actor         The actor the event was thrown on
         * @param other         The actor that will collided with the current actor
         * @param side          The side that will be collided with the current actor
         * @param intersection  Intersection vector
         */
        function PreCollisionEvent(actor, other, side, intersection) {
            var _this = _super.call(this) || this;
            _this.actor = actor;
            _this.other = other;
            _this.side = side;
            _this.intersection = intersection;
            _this.target = actor;
            return _this;
        }
        return PreCollisionEvent;
    }(GameEvent));
    exports.PreCollisionEvent = PreCollisionEvent;
    /**
     * Event thrown on an [[Actor|actor]] when a collision has been resolved (body reacted) this frame
     */
    var PostCollisionEvent = (function (_super) {
        __extends(PostCollisionEvent, _super);
        /**
         * @param actor         The actor the event was thrown on
         * @param other         The actor that did collide with the current actor
         * @param side          The side that did collide with the current actor
         * @param intersection  Intersection vector
         */
        function PostCollisionEvent(actor, other, side, intersection) {
            var _this = _super.call(this) || this;
            _this.actor = actor;
            _this.other = other;
            _this.side = side;
            _this.intersection = intersection;
            _this.target = actor;
            return _this;
        }
        return PostCollisionEvent;
    }(GameEvent));
    exports.PostCollisionEvent = PostCollisionEvent;
    /**
     * Event thrown the first time an [[Actor|actor]] collides with another, after an actor is in contact normal collision events are fired.
     */
    var CollisionStartEvent = (function (_super) {
        __extends(CollisionStartEvent, _super);
        /**
         *
         */
        function CollisionStartEvent(actor, other, pair) {
            var _this = _super.call(this) || this;
            _this.actor = actor;
            _this.other = other;
            _this.pair = pair;
            _this.target = actor;
            return _this;
        }
        return CollisionStartEvent;
    }(GameEvent));
    exports.CollisionStartEvent = CollisionStartEvent;
    /**
     * Event thrown when the [[Actor|actor]] is no longer colliding with another
     */
    var CollisionEndEvent = (function (_super) {
        __extends(CollisionEndEvent, _super);
        /**
         *
         */
        function CollisionEndEvent(actor, other) {
            var _this = _super.call(this) || this;
            _this.actor = actor;
            _this.other = other;
            _this.target = actor;
            return _this;
        }
        return CollisionEndEvent;
    }(GameEvent));
    exports.CollisionEndEvent = CollisionEndEvent;
    /**
     * Event thrown on an [[Actor]] and a [[Scene]] only once before the first update call
     */
    var InitializeEvent = (function (_super) {
        __extends(InitializeEvent, _super);
        /**
         * @param engine  The reference to the current engine
         */
        function InitializeEvent(engine, target) {
            var _this = _super.call(this) || this;
            _this.engine = engine;
            _this.target = target;
            return _this;
        }
        return InitializeEvent;
    }(GameEvent));
    exports.InitializeEvent = InitializeEvent;
    /**
     * Event thrown on a [[Scene]] on activation
     */
    var ActivateEvent = (function (_super) {
        __extends(ActivateEvent, _super);
        /**
         * @param oldScene  The reference to the old scene
         */
        function ActivateEvent(oldScene, target) {
            var _this = _super.call(this) || this;
            _this.oldScene = oldScene;
            _this.target = target;
            return _this;
        }
        return ActivateEvent;
    }(GameEvent));
    exports.ActivateEvent = ActivateEvent;
    /**
     * Event thrown on a [[Scene]] on deactivation
     */
    var DeactivateEvent = (function (_super) {
        __extends(DeactivateEvent, _super);
        /**
         * @param newScene  The reference to the new scene
         */
        function DeactivateEvent(newScene, target) {
            var _this = _super.call(this) || this;
            _this.newScene = newScene;
            _this.target = target;
            return _this;
        }
        return DeactivateEvent;
    }(GameEvent));
    exports.DeactivateEvent = DeactivateEvent;
    /**
     * Event thrown on an [[Actor]] when it completely leaves the screen.
     */
    var ExitViewPortEvent = (function (_super) {
        __extends(ExitViewPortEvent, _super);
        function ExitViewPortEvent(target) {
            var _this = _super.call(this) || this;
            _this.target = target;
            return _this;
        }
        return ExitViewPortEvent;
    }(GameEvent));
    exports.ExitViewPortEvent = ExitViewPortEvent;
    /**
     * Event thrown on an [[Actor]] when it completely leaves the screen.
     */
    var EnterViewPortEvent = (function (_super) {
        __extends(EnterViewPortEvent, _super);
        function EnterViewPortEvent(target) {
            var _this = _super.call(this) || this;
            _this.target = target;
            return _this;
        }
        return EnterViewPortEvent;
    }(GameEvent));
    exports.EnterViewPortEvent = EnterViewPortEvent;
    var EnterTriggerEvent = (function (_super) {
        __extends(EnterTriggerEvent, _super);
        function EnterTriggerEvent(target, actor) {
            var _this = _super.call(this) || this;
            _this.target = target;
            _this.actor = actor;
            return _this;
        }
        return EnterTriggerEvent;
    }(GameEvent));
    exports.EnterTriggerEvent = EnterTriggerEvent;
    var ExitTriggerEvent = (function (_super) {
        __extends(ExitTriggerEvent, _super);
        function ExitTriggerEvent(target, actor) {
            var _this = _super.call(this) || this;
            _this.target = target;
            _this.actor = actor;
            return _this;
        }
        return ExitTriggerEvent;
    }(GameEvent));
    exports.ExitTriggerEvent = ExitTriggerEvent;
});
define("Class", ["require", "exports", "EventDispatcher"], function (require, exports, EventDispatcher_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Excalibur base class that provides basic functionality such as [[EventDispatcher]]
     * and extending abilities for vanilla Javascript projects
     */
    var Class = (function () {
        function Class() {
            this.eventDispatcher = new EventDispatcher_3.EventDispatcher(this);
        }
        /**
         * Alias for `addEventListener`. You can listen for a variety of
         * events off of the engine; see the events section below for a complete list.
         * @param eventName  Name of the event to listen for
         * @param handler    Event handler for the thrown event
         */
        Class.prototype.on = function (eventName, handler) {
            this.eventDispatcher.on(eventName, handler);
        };
        /**
         * Alias for `removeEventListener`. If only the eventName is specified
         * it will remove all handlers registered for that specific event. If the eventName
         * and the handler instance are specified only that handler will be removed.
         *
         * @param eventName  Name of the event to listen for
         * @param handler    Event handler for the thrown event
         */
        Class.prototype.off = function (eventName, handler) {
            this.eventDispatcher.off(eventName, handler);
        };
        /**
         * Emits a new event
         * @param eventName   Name of the event to emit
         * @param eventObject Data associated with this event
         */
        Class.prototype.emit = function (eventName, eventObject) {
            this.eventDispatcher.emit(eventName, eventObject);
        };
        /**
         * Once listens to an event one time, then unsubscribes from that event
         *
         * @param eventName The name of the event to subscribe to once
         * @param handler   The handler of the event that will be auto unsubscribed
         */
        Class.prototype.once = function (eventName, handler) {
            this.eventDispatcher.once(eventName, handler);
        };
        /**
         * You may wish to extend native Excalibur functionality in vanilla Javascript.
         * Any method on a class inheriting [[Class]] may be extended to support
         * additional functionality. In the example below we create a new type called `MyActor`.
         *
         *
         * ```js
         * var MyActor = Actor.extend({
         *
         *    constructor: function() {
         *       this.newprop = 'something';
         *       Actor.apply(this, arguments);
         *    },
         *
         *    update: function(engine, delta) {
         *       // Implement custom update
         *       // Call super constructor update
         *       Actor.prototype.update.call(this, engine, delta);
         *
         *       console.log("Something cool!");
         *    }
         * });
         *
         * var myActor = new MyActor(100, 100, 100, 100, Color.Azure);
         * ```
         *
         * In TypeScript, you only need to use the `extends` syntax, you do not need
         * to use this method of extension.
         *
         * @param methods A JSON object contain any methods/properties you want to extend
         */
        Class.extend = function (methods) {
            var parent = this;
            var child;
            if (methods && methods.hasOwnProperty('constructor')) {
                child = methods.constructor;
            }
            else {
                child = function () { return parent.apply(this, arguments); };
            }
            // Using constructor allows JS to lazily instantiate super classes
            var Super = function () { this.constructor = child; };
            Super.prototype = parent.prototype;
            child.prototype = new Super;
            if (methods) {
                for (var prop in methods) {
                    if (methods.hasOwnProperty(prop)) {
                        child.prototype[prop] = methods[prop];
                    }
                }
            }
            // Make subclasses extendable
            child.extend = Class.extend;
            return child;
        };
        return Class;
    }());
    exports.Class = Class;
});
define("Actor", ["require", "exports", "Physics", "Class", "Collision/BoundingBox", "Resources/Texture", "Events", "Drawing/Color", "Drawing/Sprite", "Util/Log", "Actions/ActionContext", "Actions/Action", "Algebra", "Collision/Body", "Collision/Side", "Configurable", "Traits/Index", "Drawing/SpriteEffects", "Util/Util"], function (require, exports, Physics_13, Class_11, BoundingBox_8, Texture_4, Events_14, Color_20, Sprite_4, Log_16, ActionContext_3, Action_2, Algebra_24, Body_2, Side_4, Configurable_8, Traits, Effects, Util) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @hidden
     */
    var ActorImpl = (function (_super) {
        __extends(ActorImpl, _super);
        /**
         * @param x       The starting x coordinate of the actor
         * @param y       The starting y coordinate of the actor
         * @param width   The starting width of the actor
         * @param height  The starting height of the actor
         * @param color   The starting color of the actor. Leave null to draw a transparent actor. The opacity of the color will be used as the
         * initial [[opacity]].
         */
        function ActorImpl(xOrConfig, y, width, height, color) {
            var _this = _super.call(this) || this;
            /**
             * The unique identifier for the actor
             */
            _this.id = ActorImpl.maxId++;
            /**
             * The physics body the is associated with this actor. The body is the container for all physical properties, like position, velocity,
             * acceleration, mass, inertia, etc.
             */
            _this.body = new Body_2.Body(_this);
            _this._height = 0;
            _this._width = 0;
            /**
             * The scale vector of the actor
             */
            _this.scale = new Algebra_24.Vector(1, 1);
            /**
             * The x scalar velocity of the actor in scale/second
             */
            _this.sx = 0; //scale/sec
            /**
             * The y scalar velocity of the actor in scale/second
             */
            _this.sy = 0; //scale/sec
            /**
             * Indicates whether the actor is physically in the viewport
             */
            _this.isOffScreen = false;
            /**
             * The visibility of an actor
             */
            _this.visible = true;
            /**
             * The opacity of an actor. Passing in a color in the [[constructor]] will use the
             * color's opacity.
             */
            _this.opacity = 1;
            _this.previousOpacity = 1;
            /**
             * Convenience reference to the global logger
             */
            _this.logger = Log_16.Logger.getInstance();
            /**
             * The scene that the actor is in
             */
            _this.scene = null;
            /**
             * The parent of this actor
             */
            _this.parent = null;
            // TODO: Replace this with the new actor collection once z-indexing is built
            /**
             * The children of this actor
             */
            _this.children = [];
            /**
             * Gets or sets the current collision type of this actor. By
             * default it is ([[CollisionType.PreventCollision]]).
             */
            _this.collisionType = CollisionType.PreventCollision;
            _this.collisionGroups = [];
            _this._collisionHandlers = {};
            _this._isInitialized = false;
            _this.frames = {};
            _this._effectsDirty = false;
            /**
             * Access to the current drawing for the actor, this can be
             * an [[Animation]], [[Sprite]], or [[Polygon]].
             * Set drawings with [[setDrawing]].
             */
            _this.currentDrawing = null;
            /**
             * Modify the current actor update pipeline.
             */
            _this.traits = [];
            /**
             * Whether or not to enable the [[CapturePointer]] trait that propagates
             * pointer events to this actor
             */
            _this.enableCapturePointer = false;
            /**
             * Configuration for [[CapturePointer]] trait
             */
            _this.capturePointer = {
                captureMoveEvents: false
            };
            _this._zIndex = 0;
            _this._isKilled = false;
            _this._opacityFx = new Effects.Opacity(_this.opacity);
            if (xOrConfig && typeof xOrConfig === 'object') {
                var config = xOrConfig;
                xOrConfig = config.pos ? config.pos.x : config.x;
                y = config.pos ? config.pos.y : config.y;
                width = config.width;
                height = config.height;
            }
            _this.pos.x = xOrConfig || 0;
            _this.pos.y = y || 0;
            _this._width = width || 0;
            _this._height = height || 0;
            if (color) {
                _this.color = color;
                // set default opacity of an actor to the color
                _this.opacity = color.a;
            }
            // Build default pipeline
            //this.traits.push(new ex.Traits.EulerMovement());
            // TODO: TileMaps should be converted to a collision area
            _this.traits.push(new Traits.TileMapCollisionDetection());
            _this.traits.push(new Traits.OffscreenCulling());
            _this.traits.push(new Traits.CapturePointer());
            // Build the action queue
            _this.actionQueue = new Action_2.ActionQueue(_this);
            _this.actions = new ActionContext_3.ActionContext(_this);
            // default anchor is in the middle
            _this.anchor = new Algebra_24.Vector(.5, .5);
            // Initialize default collision area to be box
            _this.body.useBoxCollision();
            return _this;
        }
        Object.defineProperty(ActorImpl.prototype, "collisionArea", {
            /**
             * Gets the collision area shape to use for collision possible options are [CircleArea|circles], [PolygonArea|polygons], and
             * [EdgeArea|edges].
             */
            get: function () {
                return this.body.collisionArea;
            },
            /**
             * Gets the collision area shape to use for collision possible options are [CircleArea|circles], [PolygonArea|polygons], and
             * [EdgeArea|edges].
             */
            set: function (area) {
                this.body.collisionArea = area;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "x", {
            /**
             * Gets the x position of the actor relative to it's parent (if any)
             */
            get: function () {
                return this.body.pos.x;
            },
            /**
             * Sets the x position of the actor relative to it's parent (if any)
             */
            set: function (theX) {
                this.body.pos.x = theX;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "y", {
            /**
             * Gets the y position of the actor relative to it's parent (if any)
             */
            get: function () {
                return this.body.pos.y;
            },
            /**
             * Sets the y position of the actor relative to it's parent (if any)
             */
            set: function (theY) {
                this.body.pos.y = theY;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "pos", {
            /**
             * Gets the position vector of the actor in pixels
             */
            get: function () {
                return this.body.pos;
            },
            /**
             * Sets the position vector of the actor in pixels
             */
            set: function (thePos) {
                this.body.pos.setTo(thePos.x, thePos.y);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "oldPos", {
            /**
             * Gets the position vector of the actor from the last frame
             */
            get: function () {
                return this.body.oldPos;
            },
            /**
             * Sets the position vector of the actor in the last frame
             */
            set: function (thePos) {
                this.body.oldPos.setTo(thePos.x, thePos.y);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "vel", {
            /**
             * Gets the velocity vector of the actor in pixels/sec
             */
            get: function () {
                return this.body.vel;
            },
            /**
             * Sets the velocity vector of the actor in pixels/sec
             */
            set: function (theVel) {
                this.body.vel.setTo(theVel.x, theVel.y);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "oldVel", {
            /**
             * Gets the velocity vector of the actor from the last frame
             */
            get: function () {
                return this.body.oldVel;
            },
            /**
             * Sets the velocity vector of the actor from the last frame
             */
            set: function (theVel) {
                this.body.oldVel.setTo(theVel.x, theVel.y);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "acc", {
            /**
             * Gets the acceleration vector of the actor in pixels/second/second. An acceleration pointing down such as (0, 100) may be
             * useful to simulate a gravitational effect.
             */
            get: function () {
                return this.body.acc;
            },
            /**
             * Sets the acceleration vector of teh actor in pixels/second/second
             */
            set: function (theAcc) {
                this.body.acc.setTo(theAcc.x, theAcc.y);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "rotation", {
            /**
             * Gets the rotation of the actor in radians. 1 radian = 180/PI Degrees.
             */
            get: function () {
                return this.body.rotation;
            },
            /**
             * Sets the rotation of the actor in radians. 1 radian = 180/PI Degrees.
             */
            set: function (theAngle) {
                this.body.rotation = theAngle;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "rx", {
            /**
             * Gets the rotational velocity of the actor in radians/second
             */
            get: function () {
                return this.body.rx;
            },
            /**
             * Sets the rotational velocity of the actor in radians/sec
             */
            set: function (angularVelocity) {
                this.body.rx = angularVelocity;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "torque", {
            /**
             * Gets the current torque applied to the actor. Torque can be thought of as rotational force
             */
            get: function () {
                return this.body.torque;
            },
            /**
             * Sets the current torque applied to the actor. Torque can be thought of as rotational force
             */
            set: function (theTorque) {
                this.body.torque = theTorque;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "mass", {
            /**
             * Get the current mass of the actor, mass can be thought of as the resistance to acceleration.
             */
            get: function () {
                return this.body.mass;
            },
            /**
             * Sets the mass of the actor, mass can be thought of as the resistance to acceleration.
             */
            set: function (theMass) {
                this.body.mass = theMass;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "moi", {
            /**
             * Gets the current moment of inertia, moi can be thought of as the resistance to rotation.
             */
            get: function () {
                return this.body.moi;
            },
            /**
             * Sets the current moment of inertia, moi can be thought of as the resistance to rotation.
             */
            set: function (theMoi) {
                this.body.moi = theMoi;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "friction", {
            /**
             * Gets the coefficient of friction on this actor, this can be thought of as how sticky or slippery an object is.
             */
            get: function () {
                return this.body.friction;
            },
            /**
             * Sets the coefficient of friction of this actor, this can ve thought of as how stick or slippery an object is.
             */
            set: function (theFriction) {
                this.body.friction = theFriction;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "restitution", {
            /**
             * Gets the coefficient of restitution of this actor, represents the amount of energy preserved after collision. Think of this
             * as bounciness.
             */
            get: function () {
                return this.body.restitution;
            },
            /**
             * Sets the coefficient of restitution of this actor, represents the amount of energy preserved after collision. Think of this
             * as bounciness.
             */
            set: function (theRestitution) {
                this.body.restitution = theRestitution;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "color", {
            /**
             * Sets the color of the actor. A rectangle of this color will be
             * drawn if no [[IDrawable]] is specified as the actors drawing.
             *
             * The default is `null` which prevents a rectangle from being drawn.
             */
            get: function () {
                return this._color;
            },
            set: function (v) {
                this._color = v.clone();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * This is called before the first update of the actor. This method is meant to be
         * overridden. This is where initialization of child actors should take place.
         */
        ActorImpl.prototype.onInitialize = function (_engine) {
            // Override me
        };
        Object.defineProperty(ActorImpl.prototype, "isInitialized", {
            /**
             * Gets wether the actor is Initialized
             */
            get: function () {
                return this._isInitialized;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Initializes this actor and all it's child actors, meant to be called by the Scene before first update not by users of Excalibur.
         * @internal
         */
        ActorImpl.prototype._initialize = function (engine) {
            if (!this.isInitialized) {
                this.onInitialize(engine);
                this.eventDispatcher.emit('initialize', new Events_14.InitializeEvent(engine, this));
                this._isInitialized = true;
            }
            for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
                var child = _a[_i];
                child._initialize(engine);
            }
        };
        ActorImpl.prototype._checkForPointerOptIn = function (eventName) {
            if (eventName) {
                var normalized = eventName.toLowerCase();
                if (normalized === 'pointerup' || normalized === 'pointerdown' || normalized === 'pointermove') {
                    this.enableCapturePointer = true;
                    if (normalized === 'pointermove') {
                        this.capturePointer.captureMoveEvents = true;
                    }
                }
            }
        };
        ActorImpl.prototype.on = function (eventName, handler) {
            this._checkForPointerOptIn(eventName);
            this.eventDispatcher.on(eventName, handler);
        };
        ActorImpl.prototype.once = function (eventName, handler) {
            this._checkForPointerOptIn(eventName);
            this.eventDispatcher.once(eventName, handler);
        };
        /**
         * If the current actor is a member of the scene, this will remove
         * it from the scene graph. It will no longer be drawn or updated.
         */
        ActorImpl.prototype.kill = function () {
            if (this.scene) {
                this.emit('kill', new Events_14.KillEvent(this));
                this.scene.remove(this);
                this._isKilled = true;
            }
            else {
                this.logger.warn('Cannot kill actor, it was never added to the Scene');
            }
        };
        /**
         * If the current actor is killed, it will now not be killed.
         */
        ActorImpl.prototype.unkill = function () {
            this._isKilled = false;
        };
        /**
         * Indicates wether the actor has been killed.
         */
        ActorImpl.prototype.isKilled = function () {
            return this._isKilled;
        };
        /**
         * Adds a child actor to this actor. All movement of the child actor will be
         * relative to the parent actor. Meaning if the parent moves the child will
         * move with it.
         * @param actor The child actor to add
         */
        ActorImpl.prototype.add = function (actor) {
            actor.collisionType = CollisionType.PreventCollision;
            if (Util.addItemToArray(actor, this.children)) {
                actor.parent = this;
            }
        };
        /**
         * Removes a child actor from this actor.
         * @param actor The child actor to remove
         */
        ActorImpl.prototype.remove = function (actor) {
            if (Util.removeItemFromArray(actor, this.children)) {
                actor.parent = null;
            }
        };
        ActorImpl.prototype.setDrawing = function (key) {
            key = key.toString();
            if (this.currentDrawing !== this.frames[key]) {
                if (this.frames[key] != null) {
                    this.frames[key].reset();
                    this.currentDrawing = this.frames[key];
                }
                else {
                    Log_16.Logger.getInstance().error('the specified drawing key \'' + key + '\' does not exist');
                }
            }
        };
        ActorImpl.prototype.addDrawing = function () {
            if (arguments.length === 2) {
                this.frames[arguments[0]] = arguments[1];
                if (!this.currentDrawing) {
                    this.currentDrawing = arguments[1];
                }
                this._effectsDirty = true;
            }
            else {
                if (arguments[0] instanceof Sprite_4.Sprite) {
                    this.addDrawing('default', arguments[0]);
                }
                if (arguments[0] instanceof Texture_4.Texture) {
                    this.addDrawing('default', arguments[0].asSprite());
                }
            }
        };
        Object.defineProperty(ActorImpl.prototype, "z", {
            get: function () {
                return this.getZIndex();
            },
            set: function (newZ) {
                this.setZIndex(newZ);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Gets the z-index of an actor. The z-index determines the relative order an actor is drawn in.
         * Actors with a higher z-index are drawn on top of actors with a lower z-index
         */
        ActorImpl.prototype.getZIndex = function () {
            return this._zIndex;
        };
        /**
         * Sets the z-index of an actor and updates it in the drawing list for the scene.
         * The z-index determines the relative order an actor is drawn in.
         * Actors with a higher z-index are drawn on top of actors with a lower z-index
         * @param newIndex new z-index to assign
         */
        ActorImpl.prototype.setZIndex = function (newIndex) {
            this.scene.cleanupDrawTree(this);
            this._zIndex = newIndex;
            this.scene.updateDrawTree(this);
        };
        /**
         * Adds an actor to a collision group. Actors with no named collision groups are
         * considered to be in every collision group.
         *
         * Once in a collision group(s) actors will only collide with other actors in
         * that group.
         *
         * @param name The name of the collision group
         */
        ActorImpl.prototype.addCollisionGroup = function (name) {
            this.collisionGroups.push(name);
        };
        /**
         * Removes an actor from a collision group.
         * @param name The name of the collision group
         */
        ActorImpl.prototype.removeCollisionGroup = function (name) {
            var index = this.collisionGroups.indexOf(name);
            if (index !== -1) {
                this.collisionGroups.splice(index, 1);
            }
        };
        /**
         * Get the center point of an actor
         */
        ActorImpl.prototype.getCenter = function () {
            return new Algebra_24.Vector(this.pos.x + this.getWidth() / 2 - this.anchor.x * this.getWidth(), this.pos.y + this.getHeight() / 2 - this.anchor.y * this.getHeight());
        };
        /**
         * Gets the calculated width of an actor, factoring in scale
         */
        ActorImpl.prototype.getWidth = function () {
            return this._width * this.getGlobalScale().x;
        };
        /**
         * Sets the width of an actor, factoring in the current scale
         */
        ActorImpl.prototype.setWidth = function (width) {
            this._width = width / this.scale.x;
        };
        /**
         * Gets the calculated height of an actor, factoring in scale
         */
        ActorImpl.prototype.getHeight = function () {
            return this._height * this.getGlobalScale().y;
        };
        /**
         * Sets the height of an actor, factoring in the current scale
         */
        ActorImpl.prototype.setHeight = function (height) {
            this._height = height / this.scale.y;
        };
        /**
         * Gets the left edge of the actor
         */
        ActorImpl.prototype.getLeft = function () {
            return this.getBounds().left;
        };
        /**
         * Gets the right edge of the actor
         */
        ActorImpl.prototype.getRight = function () {
            return this.getBounds().right;
        };
        /**
         * Gets the top edge of the actor
         */
        ActorImpl.prototype.getTop = function () {
            return this.getBounds().top;
        };
        /**
         * Gets the bottom edge of the actor
         */
        ActorImpl.prototype.getBottom = function () {
            return this.getBounds().bottom;
        };
        /**
         * Gets this actor's rotation taking into account any parent relationships
         *
         * @returns Rotation angle in radians
         */
        ActorImpl.prototype.getWorldRotation = function () {
            if (!this.parent) {
                return this.rotation;
            }
            return this.rotation + this.parent.getWorldRotation();
        };
        /**
         * Gets an actor's world position taking into account parent relationships, scaling, rotation, and translation
         *
         * @returns Position in world coordinates
         */
        ActorImpl.prototype.getWorldPos = function () {
            if (!this.parent) {
                return this.pos.clone();
            }
            // collect parents                  
            var parents = [];
            var root = this;
            parents.push(this);
            // find parents
            while (root.parent) {
                root = root.parent;
                parents.push(root);
            }
            // calculate position       
            var x = parents.reduceRight(function (px, p) {
                if (p.parent) {
                    return px + (p.pos.x * p.getGlobalScale().x);
                }
                return px + p.pos.x;
            }, 0);
            var y = parents.reduceRight(function (py, p) {
                if (p.parent) {
                    return py + (p.pos.y * p.getGlobalScale().y);
                }
                return py + p.pos.y;
            }, 0);
            // rotate around root anchor
            var ra = root.getWorldPos(); // 10, 10
            var r = this.getWorldRotation();
            return new Algebra_24.Vector(x, y).rotate(r, ra);
        };
        /**
         * Gets the global scale of the Actor
         */
        ActorImpl.prototype.getGlobalScale = function () {
            if (!this.parent) {
                return new Algebra_24.Vector(this.scale.x, this.scale.y);
            }
            var parentScale = this.parent.getGlobalScale();
            return new Algebra_24.Vector(this.scale.x * parentScale.x, this.scale.y * parentScale.y);
        };
        /**
         * Returns the actor's [[BoundingBox]] calculated for this instant in world space.
         */
        ActorImpl.prototype.getBounds = function () {
            // todo cache bounding box
            var anchor = this._getCalculatedAnchor();
            var pos = this.getWorldPos();
            return new BoundingBox_8.BoundingBox(pos.x - anchor.x, pos.y - anchor.y, pos.x + this.getWidth() - anchor.x, pos.y + this.getHeight() - anchor.y).rotate(this.rotation, pos);
        };
        /**
         * Returns the actor's [[BoundingBox]] relative to the actors position.
         */
        ActorImpl.prototype.getRelativeBounds = function () {
            // todo cache bounding box
            var anchor = this._getCalculatedAnchor();
            return new BoundingBox_8.BoundingBox(-anchor.x, -anchor.y, this.getWidth() - anchor.x, this.getHeight() - anchor.y).rotate(this.rotation);
        };
        /**
         * Tests whether the x/y specified are contained in the actor
         * @param x  X coordinate to test (in world coordinates)
         * @param y  Y coordinate to test (in world coordinates)
         * @param recurse checks whether the x/y are contained in any child actors (if they exist).
         */
        ActorImpl.prototype.contains = function (x, y, recurse) {
            if (recurse === void 0) { recurse = false; }
            var containment = this.getBounds().contains(new Algebra_24.Vector(x, y));
            if (recurse) {
                return containment || this.children.some(function (child) {
                    return child.contains(x, y, true);
                });
            }
            return containment;
        };
        /**
         * Returns the side of the collision based on the intersection
         * @param intersect The displacement vector returned by a collision
         */
        ActorImpl.prototype.getSideFromIntersect = function (intersect) {
            if (intersect) {
                if (Math.abs(intersect.x) > Math.abs(intersect.y)) {
                    if (intersect.x < 0) {
                        return Side_4.Side.Right;
                    }
                    return Side_4.Side.Left;
                }
                else {
                    if (intersect.y < 0) {
                        return Side_4.Side.Bottom;
                    }
                    return Side_4.Side.Top;
                }
            }
            return Side_4.Side.None;
        };
        /**
         * Test whether the actor has collided with another actor, returns the side of the current actor that collided.
         * @param actor The other actor to test
         */
        ActorImpl.prototype.collidesWithSide = function (actor) {
            var separationVector = this.collides(actor);
            if (!separationVector) {
                return Side_4.Side.None;
            }
            if (Math.abs(separationVector.x) > Math.abs(separationVector.y)) {
                if (this.pos.x < actor.pos.x) {
                    return Side_4.Side.Right;
                }
                else {
                    return Side_4.Side.Left;
                }
            }
            else {
                if (this.pos.y < actor.pos.y) {
                    return Side_4.Side.Bottom;
                }
                else {
                    return Side_4.Side.Top;
                }
            }
        };
        /**
         * Test whether the actor has collided with another actor, returns the intersection vector on collision. Returns
         * `null` when there is no collision;
         * @param actor The other actor to test
         */
        ActorImpl.prototype.collides = function (actor) {
            var bounds = this.getBounds();
            var otherBounds = actor.getBounds();
            var intersect = bounds.collides(otherBounds);
            return intersect;
        };
        /**
         * Register a handler to fire when this actor collides with another in a specified group
         * @param group The group name to listen for
         * @param func The callback to fire on collision with another actor from the group. The callback is passed the other actor.
         */
        ActorImpl.prototype.onCollidesWith = function (group, func) {
            if (!this._collisionHandlers[group]) {
                this._collisionHandlers[group] = [];
            }
            this._collisionHandlers[group].push(func);
        };
        ActorImpl.prototype.getCollisionHandlers = function () {
            return this._collisionHandlers;
        };
        /**
         * Removes all collision handlers for this group on this actor
         * @param group Group to remove all handlers for on this actor.
         */
        ActorImpl.prototype.removeCollidesWith = function (group) {
            this._collisionHandlers[group] = [];
        };
        /**
         * Returns true if the two actors are less than or equal to the distance specified from each other
         * @param actor     Actor to test
         * @param distance  Distance in pixels to test
         */
        ActorImpl.prototype.within = function (actor, distance) {
            return Math.sqrt(Math.pow(this.pos.x - actor.pos.x, 2) + Math.pow(this.pos.y - actor.pos.y, 2)) <= distance;
        };
        ActorImpl.prototype._getCalculatedAnchor = function () {
            return new Algebra_24.Vector(this.getWidth() * this.anchor.x, this.getHeight() * this.anchor.y);
        };
        ActorImpl.prototype._reapplyEffects = function (drawing) {
            drawing.removeEffect(this._opacityFx);
            drawing.addEffect(this._opacityFx);
        };
        /**
         * Perform euler integration at the specified time step
         */
        ActorImpl.prototype.integrate = function (delta) {
            // Update placements based on linear algebra
            var seconds = delta / 1000;
            var totalAcc = this.acc.clone();
            // Only active vanilla actors are affected by global acceleration
            if (this.collisionType === CollisionType.Active) {
                totalAcc.addEqual(Physics_13.Physics.acc);
            }
            this.vel.addEqual(totalAcc.scale(seconds));
            this.pos.addEqual(this.vel.scale(seconds)).addEqual(totalAcc.scale(0.5 * seconds * seconds));
            this.rx += this.torque * (1.0 / this.moi) * seconds;
            this.rotation += this.rx * seconds;
            this.scale.x += this.sx * delta / 1000;
            this.scale.y += this.sy * delta / 1000;
            // Update physics body
            this.body.update();
        };
        /**
         * Called by the Engine, updates the state of the actor
         * @param engine The reference to the current game engine
         * @param delta  The time elapsed since the last update in milliseconds
         */
        ActorImpl.prototype.update = function (engine, delta) {
            this._initialize(engine);
            this.emit('preupdate', new Events_14.PreUpdateEvent(engine, delta, this));
            // Update action queue
            this.actionQueue.update(delta);
            // Update color only opacity
            if (this.color) {
                this.color.a = this.opacity;
            }
            // calculate changing opacity
            if (this.previousOpacity !== this.opacity) {
                this.previousOpacity = this.opacity;
                this._opacityFx.opacity = this.opacity;
                this._effectsDirty = true;
            }
            // Capture old values before integration step updates them
            this.oldVel.setTo(this.vel.x, this.vel.y);
            this.oldPos.setTo(this.pos.x, this.pos.y);
            // Run Euler integration
            this.integrate(delta);
            // Update actor pipeline (movement, collision detection, event propagation, offscreen culling)
            for (var _i = 0, _a = this.traits; _i < _a.length; _i++) {
                var trait = _a[_i];
                trait.update(this, engine, delta);
            }
            // Update child actors
            for (var i = 0; i < this.children.length; i++) {
                this.children[i].update(engine, delta);
            }
            this.emit('postupdate', new Events_14.PostUpdateEvent(engine, delta, this));
        };
        /**
         * Called by the Engine, draws the actor to the screen
         * @param ctx   The rendering context
         * @param delta The time since the last draw in milliseconds
         */
        ActorImpl.prototype.draw = function (ctx, delta) {
            ctx.save();
            ctx.translate(this.pos.x, this.pos.y);
            ctx.rotate(this.rotation);
            ctx.scale(this.scale.x, this.scale.y);
            // translate canvas by anchor offset
            ctx.save();
            ctx.translate(-(this._width * this.anchor.x), -(this._height * this.anchor.y));
            this.emit('predraw', new Events_14.PreDrawEvent(ctx, delta, this));
            if (this.currentDrawing) {
                var drawing = this.currentDrawing;
                // See https://github.com/excaliburjs/Excalibur/pull/619 for discussion on this formula          
                var offsetX = (this._width - drawing.naturalWidth * drawing.scale.x) * this.anchor.x;
                var offsetY = (this._height - drawing.naturalHeight * drawing.scale.y) * this.anchor.y;
                if (this._effectsDirty) {
                    this._reapplyEffects(this.currentDrawing);
                    this._effectsDirty = false;
                }
                this.currentDrawing.draw(ctx, offsetX, offsetY);
            }
            else {
                if (this.color) {
                    ctx.fillStyle = this.color.toString();
                    ctx.fillRect(0, 0, this._width, this._height);
                }
            }
            ctx.restore();
            // Draw child actors
            for (var i = 0; i < this.children.length; i++) {
                if (this.children[i].visible) {
                    this.children[i].draw(ctx, delta);
                }
            }
            this.emit('postdraw', new Events_14.PostDrawEvent(ctx, delta, this));
            ctx.restore();
        };
        /**
         * Called by the Engine, draws the actors debugging to the screen
         * @param ctx The rendering context
         */
        /* istanbul ignore next */
        ActorImpl.prototype.debugDraw = function (ctx) {
            this.emit('predebugdraw', new Events_14.PreDebugDrawEvent(ctx, this));
            this.body.debugDraw(ctx);
            // Draw actor bounding box
            var bb = this.getBounds();
            bb.debugDraw(ctx);
            // Draw actor Id
            ctx.fillText('id: ' + this.id, bb.left + 3, bb.top + 10);
            // Draw actor anchor Vector
            ctx.fillStyle = Color_20.Color.Yellow.toString();
            ctx.beginPath();
            ctx.arc(this.getWorldPos().x, this.getWorldPos().y, 3, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fill();
            // Culling Box debug draw
            for (var j = 0; j < this.traits.length; j++) {
                if (this.traits[j] instanceof Traits.OffscreenCulling) {
                    this.traits[j].cullingBox.debugDraw(ctx);
                }
            }
            // Unit Circle debug draw
            ctx.strokeStyle = Color_20.Color.Yellow.toString();
            ctx.beginPath();
            var radius = Math.min(this.getWidth(), this.getHeight());
            ctx.arc(this.getWorldPos().x, this.getWorldPos().y, radius, 0, Math.PI * 2);
            ctx.closePath();
            ctx.stroke();
            var ticks = {
                '0 Pi': 0,
                'Pi/2': Math.PI / 2,
                'Pi': Math.PI,
                '3/2 Pi': 3 * Math.PI / 2
            };
            var oldFont = ctx.font;
            for (var tick in ticks) {
                ctx.fillStyle = Color_20.Color.Yellow.toString();
                ctx.font = '14px';
                ctx.textAlign = 'center';
                ctx.fillText(tick, this.getWorldPos().x + Math.cos(ticks[tick]) * (radius + 10), this.getWorldPos().y + Math.sin(ticks[tick]) * (radius + 10));
            }
            ctx.font = oldFont;
            // Draw child actors
            for (var i = 0; i < this.children.length; i++) {
                this.children[i].debugDraw(ctx);
            }
            this.emit('postdebugdraw', new Events_14.PostDebugDrawEvent(ctx, this));
        };
        return ActorImpl;
    }(Class_11.Class));
    /**
     * Indicates the next id to be set
     */
    ActorImpl.maxId = 0;
    exports.ActorImpl = ActorImpl;
    /**
     * The most important primitive in Excalibur is an `Actor`. Anything that
     * can move on the screen, collide with another `Actor`, respond to events,
     * or interact with the current scene, must be an actor. An `Actor` **must**
     * be part of a [[Scene]] for it to be drawn to the screen.
     *
     * [[include:Actors.md]]
     *
     *
     * [[include:Constructors.md]]
     *
     */
    var Actor = (function (_super) {
        __extends(Actor, _super);
        function Actor(xOrConfig, y, width, height, color) {
            return _super.call(this, xOrConfig, y, width, height, color) || this;
        }
        return Actor;
    }(Configurable_8.Configurable(ActorImpl)));
    exports.Actor = Actor;
    /**
     * An enum that describes the types of collisions actors can participate in
     */
    var CollisionType;
    (function (CollisionType) {
        /**
         * Actors with the `PreventCollision` setting do not participate in any
         * collisions and do not raise collision events.
         */
        CollisionType[CollisionType["PreventCollision"] = 0] = "PreventCollision";
        /**
         * Actors with the `Passive` setting only raise collision events, but are not
         * influenced or moved by other actors and do not influence or move other actors.
         */
        CollisionType[CollisionType["Passive"] = 1] = "Passive";
        /**
         * Actors with the `Active` setting raise collision events and participate
         * in collisions with other actors and will be push or moved by actors sharing
         * the `Active` or `Fixed` setting.
         */
        CollisionType[CollisionType["Active"] = 2] = "Active";
        /**
         * Actors with the `Fixed` setting raise collision events and participate in
         * collisions with other actors. Actors with the `Fixed` setting will not be
         * pushed or moved by other actors sharing the `Fixed`. Think of Fixed
         * actors as "immovable/onstoppable" objects. If two `Fixed` actors meet they will
         * not be pushed or moved by each other, they will not interact except to throw
         * collision events.
         */
        CollisionType[CollisionType["Fixed"] = 3] = "Fixed";
    })(CollisionType = exports.CollisionType || (exports.CollisionType = {}));
});
define("Actions/Action", ["require", "exports", "Actions/RotationType", "Algebra", "Util/Log", "Util/Util"], function (require, exports, RotationType_2, Algebra_25, Log_17, Util) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var EaseTo = (function () {
        function EaseTo(actor, x, y, duration, easingFcn) {
            this.actor = actor;
            this.easingFcn = easingFcn;
            this._currentLerpTime = 0;
            this._lerpDuration = 1 * 1000; // 1 second
            this._lerpStart = new Algebra_25.Vector(0, 0);
            this._lerpEnd = new Algebra_25.Vector(0, 0);
            this._initialized = false;
            this._stopped = false;
            this._distance = 0;
            this._lerpDuration = duration;
            this._lerpEnd = new Algebra_25.Vector(x, y);
        }
        EaseTo.prototype._initialize = function () {
            this._lerpStart = new Algebra_25.Vector(this.actor.pos.x, this.actor.pos.y);
            this._currentLerpTime = 0;
            this._distance = this._lerpStart.distance(this._lerpEnd);
        };
        EaseTo.prototype.update = function (delta) {
            if (!this._initialized) {
                this._initialize();
                this._initialized = true;
            }
            var newX = this.actor.pos.x;
            var newY = this.actor.pos.y;
            if (this._currentLerpTime < this._lerpDuration) {
                if (this._lerpEnd.x < this._lerpStart.x) {
                    newX = this._lerpStart.x - (this.easingFcn(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x);
                }
                else {
                    newX = this.easingFcn(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration);
                }
                if (this._lerpEnd.y < this._lerpStart.y) {
                    newY = this._lerpStart.y - (this.easingFcn(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y);
                }
                else {
                    newY = this.easingFcn(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);
                }
                this.actor.pos.x = newX;
                this.actor.pos.y = newY;
                this._currentLerpTime += delta;
            }
            else {
                this.actor.pos.x = this._lerpEnd.x;
                this.actor.pos.y = this._lerpEnd.y;
                //this._lerpStart = null;
                //this._lerpEnd = null;
                //this._currentLerpTime = 0;
            }
        };
        EaseTo.prototype.isComplete = function (actor) {
            return this._stopped || (new Algebra_25.Vector(actor.pos.x, actor.pos.y)).distance(this._lerpStart) >= this._distance;
        };
        EaseTo.prototype.reset = function () {
            this._initialized = false;
        };
        EaseTo.prototype.stop = function () {
            this._stopped = true;
        };
        return EaseTo;
    }());
    exports.EaseTo = EaseTo;
    var MoveTo = (function () {
        function MoveTo(actor, destx, desty, speed) {
            this._started = false;
            this._stopped = false;
            this._actor = actor;
            this._end = new Algebra_25.Vector(destx, desty);
            this._speed = speed;
        }
        MoveTo.prototype.update = function (_delta) {
            if (!this._started) {
                this._started = true;
                this._start = new Algebra_25.Vector(this._actor.pos.x, this._actor.pos.y);
                this._distance = this._start.distance(this._end);
                this._dir = this._end.sub(this._start).normalize();
            }
            var m = this._dir.scale(this._speed);
            this._actor.vel.x = m.x;
            this._actor.vel.y = m.y;
            if (this.isComplete(this._actor)) {
                this._actor.pos.x = this._end.x;
                this._actor.pos.y = this._end.y;
                this._actor.vel.y = 0;
                this._actor.vel.x = 0;
            }
        };
        MoveTo.prototype.isComplete = function (actor) {
            return this._stopped || (new Algebra_25.Vector(actor.pos.x, actor.pos.y)).distance(this._start) >= this._distance;
        };
        MoveTo.prototype.stop = function () {
            this._actor.vel.y = 0;
            this._actor.vel.x = 0;
            this._stopped = true;
        };
        MoveTo.prototype.reset = function () {
            this._started = false;
        };
        return MoveTo;
    }());
    exports.MoveTo = MoveTo;
    var MoveBy = (function () {
        function MoveBy(actor, destx, desty, time) {
            this._started = false;
            this._stopped = false;
            this._actor = actor;
            this._end = new Algebra_25.Vector(destx, desty);
            if (time <= 0) {
                Log_17.Logger.getInstance().error('Attempted to moveBy time less than or equal to zero : ' + time);
                throw new Error('Cannot move in time <= 0');
            }
            this._time = time;
        }
        MoveBy.prototype.update = function (_delta) {
            if (!this._started) {
                this._started = true;
                this._start = new Algebra_25.Vector(this._actor.pos.x, this._actor.pos.y);
                this._distance = this._start.distance(this._end);
                this._dir = this._end.sub(this._start).normalize();
                this._speed = this._distance / (this._time / 1000);
            }
            var m = this._dir.scale(this._speed);
            this._actor.vel.x = m.x;
            this._actor.vel.y = m.y;
            if (this.isComplete(this._actor)) {
                this._actor.pos.x = this._end.x;
                this._actor.pos.y = this._end.y;
                this._actor.vel.y = 0;
                this._actor.vel.x = 0;
            }
        };
        MoveBy.prototype.isComplete = function (actor) {
            return this._stopped || (new Algebra_25.Vector(actor.pos.x, actor.pos.y)).distance(this._start) >= this._distance;
        };
        MoveBy.prototype.stop = function () {
            this._actor.vel.y = 0;
            this._actor.vel.x = 0;
            this._stopped = true;
        };
        MoveBy.prototype.reset = function () {
            this._started = false;
        };
        return MoveBy;
    }());
    exports.MoveBy = MoveBy;
    var Follow = (function () {
        function Follow(actor, actorToFollow, followDistance) {
            this._started = false;
            this._stopped = false;
            this._actor = actor;
            this._actorToFollow = actorToFollow;
            this._current = new Algebra_25.Vector(this._actor.pos.x, this._actor.pos.y);
            this._end = new Algebra_25.Vector(actorToFollow.pos.x, actorToFollow.pos.y);
            this._maximumDistance = (followDistance !== undefined) ? followDistance : this._current.distance(this._end);
            this._speed = 0;
        }
        Follow.prototype.update = function (_delta) {
            if (!this._started) {
                this._started = true;
                this._distanceBetween = this._current.distance(this._end);
                this._dir = this._end.sub(this._current).normalize();
            }
            var actorToFollowSpeed = Math.sqrt(Math.pow(this._actorToFollow.vel.x, 2) + Math.pow(this._actorToFollow.vel.y, 2));
            if (actorToFollowSpeed !== 0) {
                this._speed = actorToFollowSpeed;
            }
            this._current.x = this._actor.pos.x;
            this._current.y = this._actor.pos.y;
            this._end.x = this._actorToFollow.pos.x;
            this._end.y = this._actorToFollow.pos.y;
            this._distanceBetween = this._current.distance(this._end);
            this._dir = this._end.sub(this._current).normalize();
            if (this._distanceBetween >= this._maximumDistance) {
                var m = this._dir.scale(this._speed);
                this._actor.vel.x = m.x;
                this._actor.vel.y = m.y;
            }
            else {
                this._actor.vel.x = 0;
                this._actor.vel.y = 0;
            }
            if (this.isComplete()) {
                // TODO this should never occur
                this._actor.pos.x = this._end.x;
                this._actor.pos.y = this._end.y;
                this._actor.vel.y = 0;
                this._actor.vel.x = 0;
            }
        };
        Follow.prototype.stop = function () {
            this._actor.vel.y = 0;
            this._actor.vel.x = 0;
            this._stopped = true;
        };
        Follow.prototype.isComplete = function () {
            // the actor following should never stop unless specified to do so
            return this._stopped;
        };
        Follow.prototype.reset = function () {
            this._started = false;
        };
        return Follow;
    }());
    exports.Follow = Follow;
    var Meet = (function () {
        function Meet(actor, actorToMeet, speed) {
            this._started = false;
            this._stopped = false;
            this._speedWasSpecified = false;
            this._actor = actor;
            this._actorToMeet = actorToMeet;
            this._current = new Algebra_25.Vector(this._actor.pos.x, this._actor.pos.y);
            this._end = new Algebra_25.Vector(actorToMeet.pos.x, actorToMeet.pos.y);
            this._speed = speed || 0;
            if (speed !== undefined) {
                this._speedWasSpecified = true;
            }
        }
        Meet.prototype.update = function (_delta) {
            if (!this._started) {
                this._started = true;
                this._distanceBetween = this._current.distance(this._end);
                this._dir = this._end.sub(this._current).normalize();
            }
            var actorToMeetSpeed = Math.sqrt(Math.pow(this._actorToMeet.vel.x, 2) + Math.pow(this._actorToMeet.vel.y, 2));
            if ((actorToMeetSpeed !== 0) && (!this._speedWasSpecified)) {
                this._speed = actorToMeetSpeed;
            }
            this._current.x = this._actor.pos.x;
            this._current.y = this._actor.pos.y;
            this._end.x = this._actorToMeet.pos.x;
            this._end.y = this._actorToMeet.pos.y;
            this._distanceBetween = this._current.distance(this._end);
            this._dir = this._end.sub(this._current).normalize();
            var m = this._dir.scale(this._speed);
            this._actor.vel.x = m.x;
            this._actor.vel.y = m.y;
            if (this.isComplete()) {
                this._actor.pos.x = this._end.x;
                this._actor.pos.y = this._end.y;
                this._actor.vel.y = 0;
                this._actor.vel.x = 0;
            }
        };
        Meet.prototype.isComplete = function () {
            return this._stopped || (this._distanceBetween <= 1);
        };
        Meet.prototype.stop = function () {
            this._actor.vel.y = 0;
            this._actor.vel.x = 0;
            this._stopped = true;
        };
        Meet.prototype.reset = function () {
            this._started = false;
        };
        return Meet;
    }());
    exports.Meet = Meet;
    var RotateTo = (function () {
        function RotateTo(actor, angleRadians, speed, rotationType) {
            this._started = false;
            this._stopped = false;
            this._actor = actor;
            this._end = angleRadians;
            this._speed = speed;
            this._rotationType = rotationType || RotationType_2.RotationType.ShortestPath;
        }
        RotateTo.prototype.update = function (_delta) {
            if (!this._started) {
                this._started = true;
                this._start = this._actor.rotation;
                var distance1 = Math.abs(this._end - this._start);
                var distance2 = Util.TwoPI - distance1;
                if (distance1 > distance2) {
                    this._shortDistance = distance2;
                    this._longDistance = distance1;
                }
                else {
                    this._shortDistance = distance1;
                    this._longDistance = distance2;
                }
                this._shortestPathIsPositive = (this._start - this._end + Util.TwoPI) % Util.TwoPI >= Math.PI;
                switch (this._rotationType) {
                    case RotationType_2.RotationType.ShortestPath:
                        this._distance = this._shortDistance;
                        if (this._shortestPathIsPositive) {
                            this._direction = 1;
                        }
                        else {
                            this._direction = -1;
                        }
                        break;
                    case RotationType_2.RotationType.LongestPath:
                        this._distance = this._longDistance;
                        if (this._shortestPathIsPositive) {
                            this._direction = -1;
                        }
                        else {
                            this._direction = 1;
                        }
                        break;
                    case RotationType_2.RotationType.Clockwise:
                        this._direction = 1;
                        if (this._shortestPathIsPositive) {
                            this._distance = this._shortDistance;
                        }
                        else {
                            this._distance = this._longDistance;
                        }
                        break;
                    case RotationType_2.RotationType.CounterClockwise:
                        this._direction = -1;
                        if (!this._shortestPathIsPositive) {
                            this._distance = this._shortDistance;
                        }
                        else {
                            this._distance = this._longDistance;
                        }
                        break;
                }
            }
            this._actor.rx = this._direction * this._speed;
            if (this.isComplete()) {
                this._actor.rotation = this._end;
                this._actor.rx = 0;
                this._stopped = true;
            }
        };
        RotateTo.prototype.isComplete = function () {
            var distanceTravelled = Math.abs(this._actor.rotation - this._start);
            return this._stopped || (distanceTravelled >= Math.abs(this._distance));
        };
        RotateTo.prototype.stop = function () {
            this._actor.rx = 0;
            this._stopped = true;
        };
        RotateTo.prototype.reset = function () {
            this._started = false;
        };
        return RotateTo;
    }());
    exports.RotateTo = RotateTo;
    var RotateBy = (function () {
        function RotateBy(actor, angleRadians, time, rotationType) {
            this._started = false;
            this._stopped = false;
            this._actor = actor;
            this._end = angleRadians;
            this._time = time;
            this._rotationType = rotationType || RotationType_2.RotationType.ShortestPath;
        }
        RotateBy.prototype.update = function (_delta) {
            if (!this._started) {
                this._started = true;
                this._start = this._actor.rotation;
                var distance1 = Math.abs(this._end - this._start);
                var distance2 = Util.TwoPI - distance1;
                if (distance1 > distance2) {
                    this._shortDistance = distance2;
                    this._longDistance = distance1;
                }
                else {
                    this._shortDistance = distance1;
                    this._longDistance = distance2;
                }
                this._shortestPathIsPositive = (this._start - this._end + Util.TwoPI) % Util.TwoPI >= Math.PI;
                switch (this._rotationType) {
                    case RotationType_2.RotationType.ShortestPath:
                        this._distance = this._shortDistance;
                        if (this._shortestPathIsPositive) {
                            this._direction = 1;
                        }
                        else {
                            this._direction = -1;
                        }
                        break;
                    case RotationType_2.RotationType.LongestPath:
                        this._distance = this._longDistance;
                        if (this._shortestPathIsPositive) {
                            this._direction = -1;
                        }
                        else {
                            this._direction = 1;
                        }
                        break;
                    case RotationType_2.RotationType.Clockwise:
                        this._direction = 1;
                        if (this._shortDistance >= 0) {
                            this._distance = this._shortDistance;
                        }
                        else {
                            this._distance = this._longDistance;
                        }
                        break;
                    case RotationType_2.RotationType.CounterClockwise:
                        this._direction = -1;
                        if (this._shortDistance <= 0) {
                            this._distance = this._shortDistance;
                        }
                        else {
                            this._distance = this._longDistance;
                        }
                        break;
                }
                this._speed = Math.abs(this._distance / this._time * 1000);
            }
            this._actor.rx = this._direction * this._speed;
            if (this.isComplete()) {
                this._actor.rotation = this._end;
                this._actor.rx = 0;
                this._stopped = true;
            }
        };
        RotateBy.prototype.isComplete = function () {
            var distanceTravelled = Math.abs(this._actor.rotation - this._start);
            return this._stopped || (distanceTravelled >= Math.abs(this._distance));
        };
        RotateBy.prototype.stop = function () {
            this._actor.rx = 0;
            this._stopped = true;
        };
        RotateBy.prototype.reset = function () {
            this._started = false;
        };
        return RotateBy;
    }());
    exports.RotateBy = RotateBy;
    var ScaleTo = (function () {
        function ScaleTo(actor, scaleX, scaleY, speedX, speedY) {
            this._started = false;
            this._stopped = false;
            this._actor = actor;
            this._endX = scaleX;
            this._endY = scaleY;
            this._speedX = speedX;
            this._speedY = speedY;
        }
        ScaleTo.prototype.update = function (_delta) {
            if (!this._started) {
                this._started = true;
                this._startX = this._actor.scale.x;
                this._startY = this._actor.scale.y;
                this._distanceX = Math.abs(this._endX - this._startX);
                this._distanceY = Math.abs(this._endY - this._startY);
            }
            if (!(Math.abs(this._actor.scale.x - this._startX) >= this._distanceX)) {
                var directionX = this._endY < this._startY ? -1 : 1;
                this._actor.sx = this._speedX * directionX;
            }
            else {
                this._actor.sx = 0;
            }
            if (!(Math.abs(this._actor.scale.y - this._startY) >= this._distanceY)) {
                var directionY = this._endY < this._startY ? -1 : 1;
                this._actor.sy = this._speedY * directionY;
            }
            else {
                this._actor.sy = 0;
            }
            if (this.isComplete()) {
                this._actor.scale.x = this._endX;
                this._actor.scale.y = this._endY;
                this._actor.sx = 0;
                this._actor.sy = 0;
            }
        };
        ScaleTo.prototype.isComplete = function () {
            return this._stopped || ((Math.abs(this._actor.scale.y - this._startX) >= this._distanceX) &&
                (Math.abs(this._actor.scale.y - this._startY) >= this._distanceY));
        };
        ScaleTo.prototype.stop = function () {
            this._actor.sx = 0;
            this._actor.sy = 0;
            this._stopped = true;
        };
        ScaleTo.prototype.reset = function () {
            this._started = false;
        };
        return ScaleTo;
    }());
    exports.ScaleTo = ScaleTo;
    var ScaleBy = (function () {
        function ScaleBy(actor, scaleX, scaleY, time) {
            this._started = false;
            this._stopped = false;
            this._actor = actor;
            this._endX = scaleX;
            this._endY = scaleY;
            this._speedX = (this._endX - this._actor.scale.x) / time * 1000;
            this._speedY = (this._endY - this._actor.scale.y) / time * 1000;
        }
        ScaleBy.prototype.update = function (_delta) {
            if (!this._started) {
                this._started = true;
                this._startX = this._actor.scale.x;
                this._startY = this._actor.scale.y;
                this._distanceX = Math.abs(this._endX - this._startX);
                this._distanceY = Math.abs(this._endY - this._startY);
            }
            var directionX = this._endX < this._startX ? -1 : 1;
            var directionY = this._endY < this._startY ? -1 : 1;
            this._actor.sx = this._speedX * directionX;
            this._actor.sy = this._speedY * directionY;
            if (this.isComplete()) {
                this._actor.scale.x = this._endX;
                this._actor.scale.y = this._endY;
                this._actor.sx = 0;
                this._actor.sy = 0;
            }
        };
        ScaleBy.prototype.isComplete = function () {
            return this._stopped || ((Math.abs(this._actor.scale.x - this._startX) >= this._distanceX) &&
                (Math.abs(this._actor.scale.y - this._startY) >= this._distanceY));
        };
        ScaleBy.prototype.stop = function () {
            this._actor.sx = 0;
            this._actor.sy = 0;
            this._stopped = true;
        };
        ScaleBy.prototype.reset = function () {
            this._started = false;
        };
        return ScaleBy;
    }());
    exports.ScaleBy = ScaleBy;
    var Delay = (function () {
        function Delay(actor, delay) {
            this._elapsedTime = 0;
            this._started = false;
            this._stopped = false;
            this._actor = actor;
            this._delay = delay;
        }
        Delay.prototype.update = function (delta) {
            if (!this._started) {
                this._started = true;
            }
            this.x = this._actor.pos.x;
            this.y = this._actor.pos.y;
            this._elapsedTime += delta;
        };
        Delay.prototype.isComplete = function () {
            return this._stopped || (this._elapsedTime >= this._delay);
        };
        Delay.prototype.stop = function () {
            this._stopped = true;
        };
        Delay.prototype.reset = function () {
            this._elapsedTime = 0;
            this._started = false;
        };
        return Delay;
    }());
    exports.Delay = Delay;
    var Blink = (function () {
        function Blink(actor, timeVisible, timeNotVisible, numBlinks) {
            if (numBlinks === void 0) { numBlinks = 1; }
            this._timeVisible = 0;
            this._timeNotVisible = 0;
            this._elapsedTime = 0;
            this._totalTime = 0;
            this._stopped = false;
            this._started = false;
            this._actor = actor;
            this._timeVisible = timeVisible;
            this._timeNotVisible = timeNotVisible;
            this._duration = (timeVisible + timeNotVisible) * numBlinks;
        }
        Blink.prototype.update = function (delta) {
            if (!this._started) {
                this._started = true;
            }
            this._elapsedTime += delta;
            this._totalTime += delta;
            if (this._actor.visible && this._elapsedTime >= this._timeVisible) {
                this._actor.visible = false;
                this._elapsedTime = 0;
            }
            if (!this._actor.visible && this._elapsedTime >= this._timeNotVisible) {
                this._actor.visible = true;
                this._elapsedTime = 0;
            }
            if (this.isComplete()) {
                this._actor.visible = true;
            }
        };
        Blink.prototype.isComplete = function () {
            return this._stopped || (this._totalTime >= this._duration);
        };
        Blink.prototype.stop = function () {
            this._actor.visible = true;
            this._stopped = true;
        };
        Blink.prototype.reset = function () {
            this._started = false;
            this._elapsedTime = 0;
            this._totalTime = 0;
        };
        return Blink;
    }());
    exports.Blink = Blink;
    var Fade = (function () {
        function Fade(actor, endOpacity, speed) {
            this._multiplier = 1;
            this._started = false;
            this._stopped = false;
            this._actor = actor;
            this._endOpacity = endOpacity;
            this._speed = speed;
        }
        Fade.prototype.update = function (delta) {
            if (!this._started) {
                this._started = true;
                // determine direction when we start
                if (this._endOpacity < this._actor.opacity) {
                    this._multiplier = -1;
                }
                else {
                    this._multiplier = 1;
                }
            }
            if (this._speed > 0) {
                this._actor.opacity += this._multiplier * (Math.abs(this._actor.opacity - this._endOpacity) * delta) / this._speed;
            }
            this._speed -= delta;
            if (this.isComplete()) {
                this._actor.opacity = this._endOpacity;
            }
            Log_17.Logger.getInstance().debug('[Action fade] Actor opacity:', this._actor.opacity);
        };
        Fade.prototype.isComplete = function () {
            return this._stopped || (Math.abs(this._actor.opacity - this._endOpacity) < 0.05);
        };
        Fade.prototype.stop = function () {
            this._stopped = true;
        };
        Fade.prototype.reset = function () {
            this._started = false;
        };
        return Fade;
    }());
    exports.Fade = Fade;
    var Die = (function () {
        function Die(actor) {
            this._stopped = false;
            this._actor = actor;
        }
        Die.prototype.update = function (_delta) {
            this._actor.actionQueue.clearActions();
            this._actor.kill();
            this._stopped = true;
        };
        Die.prototype.isComplete = function () {
            return this._stopped;
        };
        Die.prototype.stop = function () { return; };
        Die.prototype.reset = function () { return; };
        return Die;
    }());
    exports.Die = Die;
    var CallMethod = (function () {
        function CallMethod(actor, method) {
            this._method = null;
            this._actor = null;
            this._hasBeenCalled = false;
            this._actor = actor;
            this._method = method;
        }
        CallMethod.prototype.update = function (_delta) {
            this._method.call(this._actor);
            this._hasBeenCalled = true;
        };
        CallMethod.prototype.isComplete = function () {
            return this._hasBeenCalled;
        };
        CallMethod.prototype.reset = function () {
            this._hasBeenCalled = false;
        };
        CallMethod.prototype.stop = function () {
            this._hasBeenCalled = true;
        };
        return CallMethod;
    }());
    exports.CallMethod = CallMethod;
    var Repeat = (function () {
        function Repeat(actor, repeat, actions) {
            this._stopped = false;
            this._actor = actor;
            this._actionQueue = new ActionQueue(actor);
            this._repeat = repeat;
            this._originalRepeat = repeat;
            var i = 0, len = actions.length;
            for (i; i < len; i++) {
                actions[i].reset();
                this._actionQueue.add(actions[i]);
            }
            ;
        }
        Repeat.prototype.update = function (delta) {
            this.x = this._actor.pos.x;
            this.y = this._actor.pos.y;
            if (!this._actionQueue.hasNext()) {
                this._actionQueue.reset();
                this._repeat--;
            }
            this._actionQueue.update(delta);
        };
        Repeat.prototype.isComplete = function () {
            return this._stopped || (this._repeat <= 0);
        };
        Repeat.prototype.stop = function () {
            this._stopped = true;
        };
        Repeat.prototype.reset = function () {
            this._repeat = this._originalRepeat;
        };
        return Repeat;
    }());
    exports.Repeat = Repeat;
    var RepeatForever = (function () {
        function RepeatForever(actor, actions) {
            this._stopped = false;
            this._actor = actor;
            this._actionQueue = new ActionQueue(actor);
            var i = 0, len = actions.length;
            for (i; i < len; i++) {
                actions[i].reset();
                this._actionQueue.add(actions[i]);
            }
            ;
        }
        RepeatForever.prototype.update = function (delta) {
            this.x = this._actor.pos.x;
            this.y = this._actor.pos.y;
            if (this._stopped) {
                return;
            }
            if (!this._actionQueue.hasNext()) {
                this._actionQueue.reset();
            }
            this._actionQueue.update(delta);
        };
        RepeatForever.prototype.isComplete = function () {
            return this._stopped;
        };
        RepeatForever.prototype.stop = function () {
            this._stopped = true;
            this._actionQueue.clearActions();
        };
        RepeatForever.prototype.reset = function () { return; };
        return RepeatForever;
    }());
    exports.RepeatForever = RepeatForever;
    /**
     * Action Queues
     *
     * Action queues are part of the [[ActionContext|Action API]] and
     * store the list of actions to be executed for an [[Actor]].
     *
     * Actors implement [[Actor.actions]] which can be manipulated by
     * advanced users to adjust the actions currently being executed in the
     * queue.
     */
    var ActionQueue = (function () {
        function ActionQueue(actor) {
            this._actions = [];
            this._completedActions = [];
            this._actor = actor;
        }
        ActionQueue.prototype.add = function (action) {
            this._actions.push(action);
        };
        ActionQueue.prototype.remove = function (action) {
            var index = this._actions.indexOf(action);
            this._actions.splice(index, 1);
        };
        ActionQueue.prototype.clearActions = function () {
            this._actions.length = 0;
            this._completedActions.length = 0;
            if (this._currentAction) {
                this._currentAction.stop();
            }
        };
        ActionQueue.prototype.getActions = function () {
            return this._actions.concat(this._completedActions);
        };
        ActionQueue.prototype.hasNext = function () {
            return this._actions.length > 0;
        };
        ActionQueue.prototype.reset = function () {
            this._actions = this.getActions();
            var i = 0, len = this._actions.length;
            for (i; i < len; i++) {
                this._actions[i].reset();
            }
            this._completedActions = [];
        };
        ActionQueue.prototype.update = function (delta) {
            if (this._actions.length > 0) {
                this._currentAction = this._actions[0];
                this._currentAction.update(delta);
                if (this._currentAction.isComplete(this._actor)) {
                    this._completedActions.push(this._actions.shift());
                }
            }
        };
        return ActionQueue;
    }());
    exports.ActionQueue = ActionQueue;
});
/* istanbul ignore next */
if (typeof window === 'undefined') {
    window = { audioContext: function () { return; } };
}
/* istanbul ignore next */
if (typeof window !== 'undefined' && !window.requestAnimationFrame) {
    window.requestAnimationFrame =
        window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            function (callback) { window.setInterval(callback, 1000 / 60); };
}
/* istanbul ignore next */
if (typeof window !== 'undefined' && !window.cancelAnimationFrame) {
    window.cancelAnimationFrame =
        window.webkitCancelAnimationFrame ||
            window.mozCancelAnimationFrame ||
            function () { return; };
}
/* istanbul ignore next */
if (typeof window !== 'undefined' && !window.AudioContext) {
    window.AudioContext = window.AudioContext ||
        window.webkitAudioContext ||
        window.mozAudioContext ||
        window.msAudioContext ||
        window.oAudioContext;
}
if (typeof window !== 'undefined' && !window.devicePixelRatio) {
    window.devicePixelRatio = window.devicePixelRatio || 1;
}
// Polyfill from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
// Production steps of ECMA-262, Edition 5, 15.4.4.18
// Reference: http://es5.github.io/#x15.4.4.18
/* istanbul ignore next */
if (!Array.prototype.forEach) {
    Array.prototype.forEach = function (callback, thisArg) {
        var T, k;
        if (this == null) {
            throw new TypeError('this is null or not defined');
        }
        // 1. Let O be the result of calling ToObject passing the |this| value as the argument. 
        var O = Object(this);
        // 2. Let lenValue be the result of calling the Get internal method of O with the argument "length".
        // 3. Let len be ToUint32(lenValue).
        var len = O.length >>> 0;
        // 4. If IsCallable(callback) is false, throw a TypeError exception.
        // See: http://es5.github.com/#x9.11
        if (typeof callback !== 'function') {
            throw new TypeError(callback + ' is not a function');
        }
        // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
        if (arguments.length > 1) {
            T = thisArg;
        }
        // 6. Let k be 0
        k = 0;
        // 7. Repeat, while k < len
        while (k < len) {
            var kValue;
            // a. Let Pk be ToString(k).
            //   This is implicit for LHS operands of the in operator
            // b. Let kPresent be the result of calling the HasProperty internal method of O with argument Pk.
            //   This step can be combined with c
            // c. If kPresent is true, then
            if (k in O) {
                // i. Let kValue be the result of calling the Get internal method of O with argument Pk.
                kValue = O[k];
                // ii. Call the Call internal method of callback with T as the this value and
                // argument list containing kValue, k, and O.
                callback.call(T, kValue, k, O);
            }
            // d. Increase k by 1.
            k++;
        }
        // 8. return undefined
    };
}
// Polyfill from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some
/* istanbul ignore next */
if (!Array.prototype.some) {
    Array.prototype.some = function (fun /*, thisArg */) {
        'use strict';
        if (this === void 0 || this === null) {
            throw new TypeError();
        }
        var t = Object(this);
        var len = t.length >>> 0;
        if (typeof fun !== 'function') {
            throw new TypeError();
        }
        var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
        for (var i = 0; i < len; i++) {
            if (i in t && fun.call(thisArg, t[i], i, t)) {
                return true;
            }
        }
        return false;
    };
}
// Polyfill from  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Polyfill
/* istanbul ignore next */
if (!Function.prototype.bind) {
    Function.prototype.bind = function (oThis) {
        if (typeof this !== 'function') {
            // closest thing possible to the ECMAScript 5
            // internal IsCallable function
            throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
        }
        var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function () { return; }, fBound = function () {
            return fToBind.apply(this instanceof fNOP && oThis
                ? this
                : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));
        };
        fNOP.prototype = this.prototype;
        fBound.prototype = new fNOP();
        return fBound;
    };
}
    //The modules for your project will be inlined above
    //this snippet. Ask almond to synchronously require the
    //module value for 'main' here and return it as the
    //value to use for the public API for the built file.
    return require('Index');
}));
//# sourceMappingURL=excalibur.js.map

/***/ }),

/***/ "./src/actors/decor/backgroundObject.ts":
/*!**********************************************!*\
  !*** ./src/actors/decor/backgroundObject.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ex = __webpack_require__(/*! excalibur */ "./node_modules/excalibur/dist/excalibur.js");
var resource_1 = __webpack_require__(/*! ../../resource */ "./src/resource.ts");
var gamesettings_1 = __webpack_require__(/*! ../../gamesettings */ "./src/gamesettings.ts");
var objSprites = [resource_1.Resource.ChemicalPlant, resource_1.Resource.RadioTower];
var BackgroundObject = /** @class */ (function (_super) {
    __extends(BackgroundObject, _super);
    function BackgroundObject(scene) {
        var _this = _super.call(this) || this;
        _this.x = 1.1 * gamesettings_1.GameSettings.WIDTH + Math.floor(Math.random() * gamesettings_1.GameSettings.BG_VARIABILITY);
        _this.y = gamesettings_1.GameSettings.HEIGHT - gamesettings_1.GameSettings.GROUND_HEIGHT;
        var randi = Math.floor(Math.random() * objSprites.length);
        _this.anchor.setTo(0, 0);
        var sprite = objSprites[randi].asSprite();
        sprite.anchor.setTo(0, 1);
        _this.addDrawing(sprite);
        _this.setHeight(sprite.height);
        _this.setWidth(sprite.width);
        _this.gameScene = scene;
        return _this;
    }
    BackgroundObject.prototype.onInitialize = function (engine) {
        // do stuff
    };
    BackgroundObject.prototype.update = function (engine, delta) {
        _super.prototype.update.call(this, engine, delta); // call base update logic
        if (this.gameScene.gameOver || !this.gameScene.gameStarted)
            return;
        this.x -= gamesettings_1.GameSettings.BG_HSPEED * delta / 1000;
        if (this.x < -gamesettings_1.GameSettings.WIDTH / 2) {
            this.kill();
        }
    };
    return BackgroundObject;
}(ex.Actor));
exports.BackgroundObject = BackgroundObject;


/***/ }),

/***/ "./src/actors/obstacles/pesticide.ts":
/*!*******************************************!*\
  !*** ./src/actors/obstacles/pesticide.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ex = __webpack_require__(/*! excalibur */ "./node_modules/excalibur/dist/excalibur.js");
var resource_1 = __webpack_require__(/*! ../../resource */ "./src/resource.ts");
var gamesettings_1 = __webpack_require__(/*! ../../gamesettings */ "./src/gamesettings.ts");
var pestSprites = [resource_1.Resource.Rndp, resource_1.Resource.Smrtx, resource_1.Resource.InsctWasp, resource_1.Resource.Chogo];
var Pesticide = /** @class */ (function (_super) {
    __extends(Pesticide, _super);
    function Pesticide(xi, yi, ySpace, scene) {
        var _this = _super.call(this) || this;
        _this.x = xi;
        _this.setWidth(0.8 * gamesettings_1.GameSettings.PEST_WIDTH);
        _this.setHeight(ySpace + 2 * gamesettings_1.GameSettings.PEST_HEIGHT);
        var randi;
        do {
            randi = Math.floor(Math.random() * pestSprites.length);
        } while (randi == scene.lastPest);
        scene.lastPest = randi;
        _this.topPart = new ex.Actor();
        var topSprite = new ex.Sprite(pestSprites[randi], 0, 0, gamesettings_1.GameSettings.PEST_WIDTH, gamesettings_1.GameSettings.PEST_HEIGHT);
        topSprite.flipVertical = true;
        _this.topPart.addDrawing(topSprite);
        _this.topPart.x = 0;
        _this.topPart.y = yi - (gamesettings_1.GameSettings.PEST_HEIGHT + ySpace) / 2;
        _this.topPart.setWidth(gamesettings_1.GameSettings.PEST_WIDTH);
        _this.topPart.setHeight(gamesettings_1.GameSettings.PEST_HEIGHT);
        _this.add(_this.topPart);
        _this.bottomPart = new ex.Actor();
        var bottomSprite = new ex.Sprite(pestSprites[randi], 0, 0, gamesettings_1.GameSettings.PEST_WIDTH, gamesettings_1.GameSettings.PEST_HEIGHT);
        //bottomSprite.flipVertical = false;
        _this.bottomPart.addDrawing(bottomSprite);
        _this.bottomPart.x = 0;
        _this.bottomPart.y = yi + (gamesettings_1.GameSettings.PEST_HEIGHT + ySpace) / 2;
        _this.bottomPart.setWidth(gamesettings_1.GameSettings.PEST_WIDTH);
        _this.bottomPart.setHeight(gamesettings_1.GameSettings.PEST_HEIGHT);
        _this.add(_this.bottomPart);
        _this.gameScene = scene;
        _this.passed = false;
        return _this;
    }
    Pesticide.prototype.onInitialize = function (engine) {
        // do stuff
    };
    Pesticide.prototype.update = function (engine, delta) {
        _super.prototype.update.call(this, engine, delta); // call base update logic
        if (this.gameScene.gameOver || !this.gameScene.gameStarted)
            return;
        this.x -= gamesettings_1.GameSettings.HSPEED * delta / 1000;
        if (this.topPart.collides(this.gameScene.player) != null || this.bottomPart.collides(this.gameScene.player) != null)
            this.gameScene.setGameOver();
        if (this.x < gamesettings_1.GameSettings.PEST_WIDTH / 2) {
            if (!this.passed) {
                this.passed = true;
                this.gameScene.score++;
            }
            if (this.x < -gamesettings_1.GameSettings.PEST_WIDTH / 2) {
                this.kill();
            }
        }
    };
    return Pesticide;
}(ex.Actor));
exports.Pesticide = Pesticide;


/***/ }),

/***/ "./src/actors/player/player.ts":
/*!*************************************!*\
  !*** ./src/actors/player/player.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ex = __webpack_require__(/*! excalibur */ "./node_modules/excalibur/dist/excalibur.js");
var resource_1 = __webpack_require__(/*! ../../resource */ "./src/resource.ts");
var gamesettings_1 = __webpack_require__(/*! ../../gamesettings */ "./src/gamesettings.ts");
var Player = /** @class */ (function (_super) {
    __extends(Player, _super);
    function Player(scene) {
        var _this = _super.call(this) || this;
        _this.onPress = function () {
            //this.gameStarted = true;
            _this.pressed = true;
        };
        _this.reset = function () {
            _this.ypos = gamesettings_1.GameSettings.HEIGHT / 2;
            _this.yspeed = 0;
            _this.yacc = gamesettings_1.GameSettings.GRAVITY;
            _this.pressed = false;
            _this.y = _this.ypos;
            _this.rotation = 0;
            //this.gameStarted = false;
        };
        _this.setWidth(42);
        _this.setHeight(32);
        _this.x = 100;
        _this.ypos = gamesettings_1.GameSettings.HEIGHT / 2;
        _this.yspeed = 0;
        _this.yacc = gamesettings_1.GameSettings.GRAVITY;
        _this.pressed = false;
        _this.y = _this.ypos;
        //this.gameStarted = false;
        _this.gameScene = scene;
        return _this;
    }
    Player.prototype.onInitialize = function (engine) {
        this.addDrawing("idle", new ex.Sprite(resource_1.Resource.TxPlayer, 0, 0, 64, 64));
        this.setDrawing("idle");
        var playerIdleSheet = new ex.SpriteSheet(resource_1.Resource.TxPlayer, 16, 1, 64, 64);
        this.flapAnimation = playerIdleSheet.getAnimationBetween(engine, 1, 16, 3);
        this.flapAnimation.loop = false;
        this.addDrawing("flap", this.flapAnimation);
        engine.input.pointers.primary.on("down", this.onPress);
    };
    Player.prototype.update = function (engine, delta) {
        _super.prototype.update.call(this, engine, delta); // call base update logic
        if (this.gameScene.gameOver || !this.gameScene.gameStarted)
            return;
        if (this.pressed) {
            this.yspeed = gamesettings_1.GameSettings.FORCE;
            this.setDrawing("flap");
        }
        else
            this.yspeed = gamesettings_1.GameSettings.GRAVITY + (this.yspeed - gamesettings_1.GameSettings.GRAVITY) * (Math.exp(-delta / (1000 * gamesettings_1.GameSettings.INERTIA)));
        this.ypos += this.yspeed * delta / 1000;
        this.y = this.ypos;
        //this.rotation = Math.max(-0.3, Math.min(0.3, Math.atan2(this.yspeed, GameSettings.HSPEED)/2));
        this.rotation = this.yspeed < 300 ? -0.3 : (this.yspeed > 600 ? 0.3 : -0.9 + 0.002 * this.yspeed);
        this.pressed = false;
        if (this.flapAnimation.isDone())
            this.setDrawing("idle");
        if (this.collides(this.gameScene.ground) != null)
            this.gameScene.setGameOver();
    };
    return Player;
}(ex.Actor));
exports.Player = Player;


/***/ }),

/***/ "./src/communication.ts":
/*!******************************!*\
  !*** ./src/communication.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Communication;
(function (Communication) {
    function loadRequest() {
        var msg = { messageType: "LOAD_REQUEST" };
        window.parent.postMessage(msg, "*");
    }
    Communication.loadRequest = loadRequest;
    function postScore(newScore) {
        var msg = { messageType: "SCORE", score: newScore };
        window.parent.postMessage(msg, "*");
    }
    Communication.postScore = postScore;
    function postSettings(width, height) {
        var msg = { messageType: "SETTING", options: { "width": width, "height": height } };
        window.parent.postMessage(msg, "*");
    }
    Communication.postSettings = postSettings;
    function postGameState(highScore) {
        var msg = { messageType: "SAVE", gameState: { bestScore: highScore } };
        window.parent.postMessage(msg, "*");
    }
    Communication.postGameState = postGameState;
})(Communication = exports.Communication || (exports.Communication = {}));


/***/ }),

/***/ "./src/gamesettings.ts":
/*!*****************************!*\
  !*** ./src/gamesettings.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var GameSettings;
(function (GameSettings) {
    GameSettings.WIDTH = 800;
    GameSettings.HEIGHT = 600;
    GameSettings.GRAVITY = 800;
    GameSettings.FORCE = -800;
    GameSettings.INERTIA = 0.3;
    GameSettings.HSPEED = 200;
    GameSettings.TIME_INTERVAL = 1.5;
    GameSettings.VARIABILITY = 100;
    GameSettings.MAX_SPACE = 180;
    GameSettings.MIN_SPACE = 100;
    GameSettings.SCORE_MAX_DIFF = 100;
    GameSettings.START_V_LIMIT = 0.2;
    GameSettings.END_V_LIMIT = 1;
    GameSettings.BG_TIME_INTERVAL = 30;
    GameSettings.BG_HSPEED = 80;
    GameSettings.BG_VARIABILITY = 300;
    GameSettings.GROUND_HEIGHT = 64;
    GameSettings.PEST_HEIGHT = 512;
    GameSettings.PEST_WIDTH = 64;
})(GameSettings = exports.GameSettings || (exports.GameSettings = {}));


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ex = __webpack_require__(/*! excalibur */ "./node_modules/excalibur/dist/excalibur.js");
var gamescene_1 = __webpack_require__(/*! ./scenes/gameScene/gamescene */ "./src/scenes/gameScene/gamescene.ts");
var resource_1 = __webpack_require__(/*! ./resource */ "./src/resource.ts");
var gamesettings_1 = __webpack_require__(/*! ./gamesettings */ "./src/gamesettings.ts");
var communication_1 = __webpack_require__(/*! ./communication */ "./src/communication.ts");
var Game = /** @class */ (function (_super) {
    __extends(Game, _super);
    function Game() {
        var _this = _super.call(this, { width: gamesettings_1.GameSettings.WIDTH,
            height: gamesettings_1.GameSettings.HEIGHT,
            displayMode: ex.DisplayMode.Fixed,
            pointerScope: ex.Input.PointerScope.Canvas }) || this;
        communication_1.Communication.postSettings(gamesettings_1.GameSettings.WIDTH, gamesettings_1.GameSettings.HEIGHT);
        return _this;
    }
    Game.prototype.start = function (loader) {
        return _super.prototype.start.call(this, loader);
    };
    return Game;
}(ex.Engine));
var loader = new ex.Loader();
for (var resource in resource_1.Resource) {
    loader.addResource(resource_1.Resource[resource]);
}
var game = new Game();
var gameScene = new gamescene_1.GameScene();
game.add('gameScene', gameScene);
game.start(loader).then(function () {
    game.goToScene('gameScene');
});


/***/ }),

/***/ "./src/resource.ts":
/*!*************************!*\
  !*** ./src/resource.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ex = __webpack_require__(/*! excalibur */ "./node_modules/excalibur/dist/excalibur.js");
// Image and sound resources to be loaded
var Resource = {
    Background: new ex.Texture("assets/background.png"),
    TxPlayer: new ex.Texture("assets/bee.png"),
    Ground: new ex.Texture("assets/ground.png"),
    Rndp: new ex.Texture("assets/rndp.png"),
    Smrtx: new ex.Texture("assets/smrtx.png"),
    InsctWasp: new ex.Texture("assets/insct_wasp.png"),
    Chogo: new ex.Texture("assets/chogo.png"),
    ChemicalPlant: new ex.Texture("assets/chemical_plant.png"),
    RadioTower: new ex.Texture("assets/radio_tower.png")
};
exports.Resource = Resource;


/***/ }),

/***/ "./src/scenes/gameScene/gamescene.ts":
/*!*******************************************!*\
  !*** ./src/scenes/gameScene/gamescene.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ex = __webpack_require__(/*! excalibur */ "./node_modules/excalibur/dist/excalibur.js");
var resource_1 = __webpack_require__(/*! ../../resource */ "./src/resource.ts");
var player_1 = __webpack_require__(/*! ../../actors/player/player */ "./src/actors/player/player.ts");
var pesticide_1 = __webpack_require__(/*! ../../actors/obstacles/pesticide */ "./src/actors/obstacles/pesticide.ts");
var backgroundObject_1 = __webpack_require__(/*! ../../actors/decor/backgroundObject */ "./src/actors/decor/backgroundObject.ts");
var gamesettings_1 = __webpack_require__(/*! ../../gamesettings */ "./src/gamesettings.ts");
var communication_1 = __webpack_require__(/*! ../../communication */ "./src/communication.ts");
//import { Input } from 'excalibur';
var GameScene = /** @class */ (function (_super) {
    __extends(GameScene, _super);
    function GameScene() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.onPress = function () {
            if (!_this.gameStarted) {
                _this.gameStarted = true;
                _this.centerLabel.visible = false;
            }
            if (_this.gameOver && _this.canRestart)
                _this.resetScene = true;
        };
        _this.receiveMessage = function (event) {
            if (event.data.messageType == "LOAD") {
                //console.log("received message");
                _this.bestScore = Math.max(_this.bestScore, event.data.gameState.bestScore);
            }
        };
        _this.setGameOver = function () {
            _this.gameOver = true;
            _this.centerLabel.text = "Game Over";
            _this.centerLabel.visible = true;
            _this.lastObstacleTime = 0;
            if (_this.score > _this.bestScore) {
                _this.bestScore = _this.score;
                communication_1.Communication.postGameState(_this.bestScore);
            }
            communication_1.Communication.postScore(_this.score);
        };
        return _this;
    }
    GameScene.prototype.onInitialize = function (engine) {
        this.score = 0;
        this.bestScore = 0;
        var background = new ex.Actor();
        background.addDrawing(resource_1.Resource.Background.asSprite());
        this.add(background);
        background.x = gamesettings_1.GameSettings.WIDTH / 2;
        background.y = gamesettings_1.GameSettings.HEIGHT / 2;
        background.z = -10;
        this.player = new player_1.Player(this);
        this.add(this.player);
        this.player.z = 7;
        this.lastObstacleTime = gamesettings_1.GameSettings.TIME_INTERVAL;
        this.lastObstacleY = gamesettings_1.GameSettings.HEIGHT / 2;
        this.lastPest = -1;
        this.lastBackgroundTime = gamesettings_1.GameSettings.BG_TIME_INTERVAL;
        this.centerLabel = new ex.Label("Click to start flapping.", gamesettings_1.GameSettings.WIDTH / 2, gamesettings_1.GameSettings.HEIGHT / 2, "Arial");
        this.centerLabel.textAlign = ex.TextAlign.Center;
        this.centerLabel.baseAlign = ex.BaseAlign.Middle;
        this.centerLabel.fontSize = 42;
        this.centerLabel.color = ex.Color.White;
        this.add(this.centerLabel);
        this.centerLabel.z = 10;
        this.restartLabel = new ex.Label("click to restart", gamesettings_1.GameSettings.WIDTH / 2, gamesettings_1.GameSettings.HEIGHT / 2 + 32, "Arial");
        this.restartLabel.textAlign = ex.TextAlign.Center;
        this.restartLabel.baseAlign = ex.BaseAlign.Top;
        this.restartLabel.fontSize = 28;
        this.restartLabel.color = ex.Color.White;
        this.add(this.restartLabel);
        this.restartLabel.z = 10;
        this.restartLabel.visible = false;
        this.scoreLabel = new ex.Label("0", 32, 32, "Arial");
        this.scoreLabel.textAlign = ex.TextAlign.Left;
        this.scoreLabel.baseAlign = ex.BaseAlign.Top;
        this.scoreLabel.fontSize = 42;
        this.scoreLabel.color = ex.Color.White;
        this.add(this.scoreLabel);
        this.scoreLabel.z = 10;
        this.bestScoreLabel = new ex.Label("Best: 0", gamesettings_1.GameSettings.WIDTH - 32, 32, "Arial");
        this.bestScoreLabel.textAlign = ex.TextAlign.Right;
        this.bestScoreLabel.baseAlign = ex.BaseAlign.Top;
        this.bestScoreLabel.fontSize = 42;
        this.bestScoreLabel.color = ex.Color.White;
        this.add(this.bestScoreLabel);
        this.bestScoreLabel.z = 10;
        this.gameStarted = false;
        this.gameOver = false;
        this.resetScene = false;
        this.canRestart = false;
        this.ground = new ex.Actor();
        this.ground.addDrawing(resource_1.Resource.Ground.asSprite());
        this.ground.x = gamesettings_1.GameSettings.WIDTH / 2;
        this.ground.y = gamesettings_1.GameSettings.HEIGHT - gamesettings_1.GameSettings.GROUND_HEIGHT / 2;
        this.ground.setWidth(gamesettings_1.GameSettings.WIDTH);
        this.ground.setHeight(gamesettings_1.GameSettings.GROUND_HEIGHT);
        this.add(this.ground);
        this.ground.z = 5;
        engine.input.pointers.primary.on("down", this.onPress);
        //engine.input.keyboard.on("press", (evt: Input.KeyEvent) => { if(evt.key == Input.Keys.Space) this.onSpace() });
        window.addEventListener("message", this.receiveMessage, false);
        communication_1.Communication.loadRequest();
        this.camera.pos = new ex.Vector(gamesettings_1.GameSettings.WIDTH / 2, gamesettings_1.GameSettings.HEIGHT / 2);
    };
    GameScene.prototype.update = function (engine, delta) {
        _super.prototype.update.call(this, engine, delta);
        this.bestScoreLabel.text = "Best: " + this.bestScore;
        if (this.gameOver && !this.canRestart) {
            this.lastObstacleTime += delta / 1000;
            if (this.lastObstacleTime > 1) {
                this.canRestart = true;
                this.restartLabel.visible = true;
            }
        }
        if (this.resetScene) {
            for (var ac in this.actors) {
                if (this.actors[ac] instanceof pesticide_1.Pesticide || this.actors[ac] instanceof backgroundObject_1.BackgroundObject) {
                    this.actors[ac].kill();
                }
            }
            this.player.reset();
            this.score = 0;
            this.restartLabel.visible = false;
            this.centerLabel.text = "Click to start flapping.";
            this.gameStarted = false;
            this.gameOver = false;
            this.canRestart = false;
            this.lastObstacleTime = gamesettings_1.GameSettings.TIME_INTERVAL;
            this.lastObstacleY = gamesettings_1.GameSettings.HEIGHT / 2;
            this.lastBackgroundTime = gamesettings_1.GameSettings.BG_TIME_INTERVAL;
            this.resetScene = false;
        }
        else if (this.gameOver || !this.gameStarted)
            return;
        else {
            //super.update(engine, delta); // call base update logic
            this.lastObstacleTime += delta / 1000;
            this.lastBackgroundTime += delta / 1000;
            if (this.lastObstacleTime > gamesettings_1.GameSettings.TIME_INTERVAL) {
                var posx = gamesettings_1.GameSettings.WIDTH + Math.floor(Math.random() * gamesettings_1.GameSettings.VARIABILITY);
                var spaceY = Math.floor(gamesettings_1.GameSettings.MAX_SPACE - (gamesettings_1.GameSettings.MAX_SPACE - gamesettings_1.GameSettings.MIN_SPACE) / gamesettings_1.GameSettings.SCORE_MAX_DIFF);
                var posy;
                do {
                    posy = Math.floor(spaceY + Math.random() * (gamesettings_1.GameSettings.HEIGHT - gamesettings_1.GameSettings.GROUND_HEIGHT - 2 * spaceY));
                } while (Math.abs(posy - this.lastObstacleY) > (gamesettings_1.GameSettings.START_V_LIMIT + (gamesettings_1.GameSettings.END_V_LIMIT - gamesettings_1.GameSettings.START_V_LIMIT) * this.score / gamesettings_1.GameSettings.SCORE_MAX_DIFF) * gamesettings_1.GameSettings.HEIGHT);
                //alert(posx + " " + posy + " " + spaceY);
                this.add(new pesticide_1.Pesticide(posx, posy, spaceY, this));
                this.lastObstacleY = posy;
                this.lastObstacleTime = 0;
            }
            if (this.lastBackgroundTime > gamesettings_1.GameSettings.BG_TIME_INTERVAL) {
                var bg = new backgroundObject_1.BackgroundObject(this);
                this.add(bg);
                bg.z = -3;
                this.lastBackgroundTime = 0;
            }
            this.scoreLabel.text = this.score.toString();
        }
    };
    GameScene.prototype.onActivate = function () { };
    GameScene.prototype.onDeactivate = function () { };
    return GameScene;
}(ex.Scene));
exports.GameScene = GameScene;


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V4Y2FsaWJ1ci9kaXN0L2V4Y2FsaWJ1ci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYWN0b3JzL2RlY29yL2JhY2tncm91bmRPYmplY3QudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FjdG9ycy9vYnN0YWNsZXMvcGVzdGljaWRlLnRzIiwid2VicGFjazovLy8uL3NyYy9hY3RvcnMvcGxheWVyL3BsYXllci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tbXVuaWNhdGlvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZ2FtZXNldHRpbmdzLnRzIiwid2VicGFjazovLy8uL3NyYy9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVzb3VyY2UudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjZW5lcy9nYW1lU2NlbmUvZ2FtZXNjZW5lLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlEQUFpRCxjQUFjO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOzs7QUFHQTtBQUNBOzs7Ozs7Ozs7Ozs7Z0VDbkVBO0FBQ0E7QUFDQSxpR0FBaUc7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUFBO0FBQ1QsS0FBSyxRQVFMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixtQkFBbUI7QUFDbkIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLE9BQU87QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE9BQU87QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsMENBQTBDO0FBQzFDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQix1RkFBdUY7QUFDdkY7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsaUdBQWlHO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0JBQWdCLHNDQUFzQyxpQkFBaUIsRUFBRTtBQUNuRix5QkFBeUIsdURBQXVEO0FBQ2hGO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxtRUFBbUU7QUFDeEUsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsa0JBQWtCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFVBQVU7QUFDekMsK0JBQStCLFVBQVU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGdIQUFnSDtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxxRkFBcUY7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyw2REFBNkQ7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssbUVBQW1FO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHVCQUF1QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qyx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdUJBQXVCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxpQkFBaUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMseUJBQXlCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsY0FBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBCQUEwQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsWUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssMkNBQTJDO0FBQ2hELENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdDQUFnQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQ0FBZ0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsc0NBQXNDO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsV0FBVztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixXQUFXO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFdBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsV0FBVztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssMkNBQTJDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsNkRBQTZEO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxjQUFjO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGdCQUFnQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHVCQUF1QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELDRCQUE0QixFQUFFO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUUsV0FBVyxFQUFFO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixTQUFTO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsZ0JBQWdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVELDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdCQUFnQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxxQ0FBcUM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0MsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdCQUF3QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsbUNBQW1DO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsVUFBVTtBQUM1QyxpQ0FBaUMsU0FBUztBQUMxQyxtQ0FBbUMsV0FBVztBQUM5QyxvQ0FBb0MsWUFBWTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtQkFBbUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsdUNBQXVDO0FBQzFFLDREQUE0RCwrQkFBK0IsRUFBRTtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsNEJBQTRCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDRCQUE0QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsOEJBQThCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0JBQWdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsbUNBQW1DO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUNBQW1DO0FBQ2xFLG1DQUFtQyxlQUFlO0FBQ2xELDZCQUE2QixjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQ0FBbUM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGFBQWE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxZQUFZO0FBQzVDLGdDQUFnQyw4QkFBOEI7QUFDOUQsOEJBQThCLGFBQWE7QUFDM0M7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsOEJBQThCO0FBQzlELDhCQUE4QixhQUFhO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx3Q0FBd0M7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx3Q0FBd0M7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHdDQUF3QztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHNEQUFzRDtBQUM3RjtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGVBQWU7QUFDdEQ7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssdURBQXVEO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJCQUEyQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEUsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsZ0JBQWdCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsc0JBQXNCLEVBQUU7QUFDL0U7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEUsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGtCQUFrQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRCw0Q0FBNEMsUUFBUTtBQUNwRCx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGdCQUFnQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxrQkFBa0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGVBQWU7QUFDMUMsK0JBQStCLGtCQUFrQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEYsa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwyQkFBMkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssdURBQXVEO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssMERBQTBEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDBEQUEwRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSywwREFBMEQ7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBSSxhQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMscUJBQXFCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRCwyQ0FBMkMsUUFBUTtBQUNuRCx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxxQkFBcUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGdCQUFnQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGdCQUFnQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsc0JBQXNCLEVBQUU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsZ0JBQWdCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxnQkFBZ0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHNCQUFzQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0IsNEJBQTRCLEVBQUU7QUFDbkUsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHdCQUF3QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCwrQkFBK0I7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkY7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsK0JBQStCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pELHlDQUF5QyxRQUFRO0FBQ2pELDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0EsZ0NBQWdDO0FBQ2hDLHFCQUFxQixHQUFHLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUY7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEUsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMkJBQTJCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix5Q0FBeUM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxnRUFBZ0U7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsbURBQW1EO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHlCQUF5QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCx3QkFBd0IsRUFBRTtBQUMzRSxxREFBcUQseUNBQXlDLEVBQUU7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxvQkFBb0IsRUFBRTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsVUFBVTtBQUNyQywrQkFBK0IsVUFBVTtBQUN6QztBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxZQUFZO0FBQ3RELDZDQUE2QyxhQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCLHVCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixvREFBb0QsYUFBYTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbUJBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbUJBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGVBQWU7QUFDbEQscUNBQXFDLGNBQWM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsUUFBUSxFQUFFO0FBQ3ZDLDZCQUE2QixhQUFhLEVBQUU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGFBQWE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZ0RBQWdELHlCQUF5QjtBQUN6RSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHVIQUF1SDtBQUNoSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEUsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsT0FBTztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxrQ0FBa0M7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxvQkFBb0IsRUFBRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHFCQUFxQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxxQkFBcUIsRUFBRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMscUJBQXFCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxnQkFBZ0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxnQkFBZ0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsT0FBTztBQUNqRTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxxQkFBcUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGdCQUFnQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxxQkFBcUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHFCQUFxQixFQUFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFlBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsWUFBWTtBQUN2QywrQkFBK0IsV0FBVztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxnRUFBZ0U7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFlBQVk7QUFDdkMsK0JBQStCLFdBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUsseUVBQXlFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGtCQUFrQjtBQUN4RCx1Q0FBdUMsc0NBQXNDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RCwyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDLHlDQUF5QztBQUN6Qyw4QkFBOEI7QUFDOUI7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSxrREFBa0Q7QUFDbEQsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsa0JBQWtCO0FBQ2xCLDREQUE0RDtBQUM1RDtBQUNBLDJDQUEyQztBQUMzQztBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQiw4QkFBOEI7QUFDOUIsMERBQTBEO0FBQzFEO0FBQ0EsK0VBQStFO0FBQy9FLCtFQUErRTtBQUMvRSxrRkFBa0Y7QUFDbEY7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZELHNFQUFzRTtBQUN0RSw2REFBNkQ7QUFDN0Q7QUFDQSw0QkFBNEI7QUFDNUIsdUZBQXVGO0FBQ3ZGLHlGQUF5RjtBQUN6Riw0RkFBNEY7QUFDNUYsK0JBQStCO0FBQy9CLHVDQUF1QztBQUN2QyxpQ0FBaUM7QUFDakMsb0NBQW9DO0FBQ3BDLGlFQUFpRTtBQUNqRSxpRUFBaUU7QUFDakUsNkNBQTZDO0FBQzdDLG9DQUFvQztBQUNwQztBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsOEJBQThCO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRSwrREFBK0Q7QUFDL0QsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCx3RUFBd0U7QUFDeEUsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCwrREFBK0Q7QUFDL0QsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQSwrR0FBK0c7QUFDL0c7QUFDQTtBQUNBLG9IQUFvSDtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0Usb0JBQW9CO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSxnRUFBZ0UsU0FBUztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdUJBQXVCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELG9CQUFvQixFQUFFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFNBQVM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMkJBQTJCO0FBQ2xEO0FBQ0E7QUFDQSx1QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGVBQWU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLG9EQUFvRDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDJDQUEyQztBQUNoRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssZ0VBQWdFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssc0VBQXNFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHlFQUF5RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxtRUFBbUU7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLFNBQVM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxTQUFTO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUNBQWlDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSywyQ0FBMkM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdUJBQXVCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxHQUFHLGlHQUFpRztBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsaUVBQWlFLGdCQUFnQjtBQUNqRjtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLGlEQUFpRDtBQUNqRCxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyxpREFBaUQ7QUFDakQsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssZ0VBQWdFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDJGQUEyRjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsc0NBQXNDO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRHQUE0RyxjQUFjLG9CQUFvQixlQUFlLGtCQUFrQixtQkFBbUI7QUFDbE07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5SEFBeUgsZ0JBQWdCO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlCQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdDQUFnQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsaUJBQWlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGdCQUFnQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFNBQVM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZ0JBQWdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsU0FBUztBQUMxRDtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELHlCQUF5QjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsU0FBUztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxTQUFTO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxTQUFTO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxnQkFBZ0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGdCQUFnQjtBQUM5RDtBQUNBO0FBQ0EscURBQXFELGdCQUFnQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHNDQUFzQztBQUMzRTtBQUNBO0FBQ0EscUNBQXFDLDBCQUEwQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZ0JBQWdCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsaUJBQWlCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0JBQWdCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBCQUEwQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwwQkFBMEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdCQUF3QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBCQUEwQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHNFQUFzRTtBQUMzRSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGVBQWU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRCwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsUUFBUTtBQUM3RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGNBQWMsNEJBQTRCLFFBQVEsRUFBRTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMseUNBQXlDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRyxRQUFRLEVBQUU7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxxQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMzBmQSw0RkFBZ0M7QUFDaEMsZ0ZBQTBDO0FBQzFDLDRGQUFrRDtBQUdsRCxJQUFNLFVBQVUsR0FBRyxDQUFDLG1CQUFRLENBQUMsYUFBYSxFQUFFLG1CQUFRLENBQUMsVUFBVSxDQUFDLENBQUM7QUFFakU7SUFBK0Isb0NBQVE7SUFJbkMsMEJBQVksS0FBZ0I7UUFBNUIsWUFDSSxpQkFBTyxTQWlCVjtRQWZHLEtBQUksQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFDLDJCQUFZLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLDJCQUFZLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDMUYsS0FBSSxDQUFDLENBQUMsR0FBRywyQkFBWSxDQUFDLE1BQU0sR0FBRywyQkFBWSxDQUFDLGFBQWEsQ0FBQztRQUUxRCxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFMUQsS0FBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBRXhCLElBQUksTUFBTSxHQUFHLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUMxQyxNQUFNLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDMUIsS0FBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUV4QixLQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUM5QixLQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUU1QixLQUFJLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQzs7SUFDM0IsQ0FBQztJQUVNLHVDQUFZLEdBQW5CLFVBQW9CLE1BQWlCO1FBQ2pDLFdBQVc7SUFDZixDQUFDO0lBRU0saUNBQU0sR0FBYixVQUFjLE1BQWlCLEVBQUUsS0FBYTtRQUM1QyxpQkFBTSxNQUFNLFlBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMseUJBQXlCO1FBRXRELEVBQUUsRUFBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDO1lBQ3RELE1BQU0sQ0FBQztRQUVYLElBQUksQ0FBQyxDQUFDLElBQUksMkJBQVksQ0FBQyxTQUFTLEdBQUcsS0FBSyxHQUFDLElBQUksQ0FBQztRQUU1QyxFQUFFLEVBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLDJCQUFZLENBQUMsS0FBSyxHQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDaEMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ2hCLENBQUM7SUFDTixDQUFDO0lBQ0osdUJBQUM7QUFBRCxDQUFDLENBeEM4QixFQUFFLENBQUMsS0FBSyxHQXdDdEM7QUFFUSw0Q0FBZ0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqRHpCLDRGQUFnQztBQUNoQyxnRkFBMEM7QUFDMUMsNEZBQWtEO0FBR2xELElBQU0sV0FBVyxHQUFHLENBQUMsbUJBQVEsQ0FBQyxJQUFJLEVBQUUsbUJBQVEsQ0FBQyxLQUFLLEVBQUUsbUJBQVEsQ0FBQyxTQUFTLEVBQUUsbUJBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUV4RjtJQUF3Qiw2QkFBUTtJQU01QixtQkFBWSxFQUFVLEVBQUUsRUFBVSxFQUFFLE1BQWMsRUFBRSxLQUFnQjtRQUFwRSxZQUNJLGlCQUFPLFNBa0NWO1FBaENHLEtBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQ1osS0FBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLEdBQUMsMkJBQVksQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUMzQyxLQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLEdBQUcsMkJBQVksQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUV0RCxJQUFJLEtBQUssQ0FBQztRQUNWLEdBQUcsQ0FBQztZQUNBLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDM0QsQ0FBQyxRQUFPLEtBQUssSUFBSSxLQUFLLENBQUMsUUFBUSxFQUFFO1FBQ2pDLEtBQUssQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDO1FBRXZCLEtBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxFQUFFLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDOUIsSUFBSSxTQUFTLEdBQUcsSUFBSSxFQUFFLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLDJCQUFZLENBQUMsVUFBVSxFQUFFLDJCQUFZLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDM0csU0FBUyxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUM7UUFDOUIsS0FBSSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDbkMsS0FBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ25CLEtBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLDJCQUFZLENBQUMsV0FBVyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUM5RCxLQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQywyQkFBWSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQy9DLEtBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLDJCQUFZLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDakQsS0FBSSxDQUFDLEdBQUcsQ0FBQyxLQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFdkIsS0FBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLEVBQUUsQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUNqQyxJQUFJLFlBQVksR0FBRyxJQUFJLEVBQUUsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsMkJBQVksQ0FBQyxVQUFVLEVBQUUsMkJBQVksQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUM5RyxvQ0FBb0M7UUFDcEMsS0FBSSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDekMsS0FBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3RCLEtBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLDJCQUFZLENBQUMsV0FBVyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNqRSxLQUFJLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQywyQkFBWSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ2xELEtBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLDJCQUFZLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDcEQsS0FBSSxDQUFDLEdBQUcsQ0FBQyxLQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7UUFFMUIsS0FBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7UUFDdkIsS0FBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUM7O0lBQ3hCLENBQUM7SUFFTSxnQ0FBWSxHQUFuQixVQUFvQixNQUFpQjtRQUNqQyxXQUFXO0lBQ2YsQ0FBQztJQUVNLDBCQUFNLEdBQWIsVUFBYyxNQUFpQixFQUFFLEtBQWE7UUFDNUMsaUJBQU0sTUFBTSxZQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLHlCQUF5QjtRQUV0RCxFQUFFLEVBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQztZQUN0RCxNQUFNLENBQUM7UUFFWCxJQUFJLENBQUMsQ0FBQyxJQUFJLDJCQUFZLENBQUMsTUFBTSxHQUFHLEtBQUssR0FBQyxJQUFJLENBQUM7UUFFM0MsRUFBRSxFQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLElBQUksSUFBSSxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLElBQUksSUFBSSxDQUFDO1lBQ2hILElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxFQUFFLENBQUM7UUFFaEMsRUFBRSxFQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsMkJBQVksQ0FBQyxVQUFVLEdBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNwQyxFQUFFLEVBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztnQkFDZCxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQztnQkFDbkIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUMzQixDQUFDO1lBRUQsRUFBRSxFQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQywyQkFBWSxDQUFDLFVBQVUsR0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNyQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDaEIsQ0FBQztRQUNMLENBQUM7SUFDSixDQUFDO0lBQ0osZ0JBQUM7QUFBRCxDQUFDLENBckV1QixFQUFFLENBQUMsS0FBSyxHQXFFL0I7QUFFUSw4QkFBUzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlFbEIsNEZBQWdDO0FBQ2hDLGdGQUEwQztBQUMxQyw0RkFBa0Q7QUFHbEQ7SUFBcUIsMEJBQVE7SUFTekIsZ0JBQVksS0FBZ0I7UUFBNUIsWUFDSSxpQkFBTyxTQWVWO1FBY00sYUFBTyxHQUFHO1lBQ2IsMEJBQTBCO1lBQzFCLEtBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO1FBQ3hCLENBQUM7UUFFTSxXQUFLLEdBQUc7WUFDWCxLQUFJLENBQUMsSUFBSSxHQUFHLDJCQUFZLENBQUMsTUFBTSxHQUFDLENBQUMsQ0FBQztZQUNsQyxLQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztZQUNoQixLQUFJLENBQUMsSUFBSSxHQUFHLDJCQUFZLENBQUMsT0FBTyxDQUFDO1lBQ2pDLEtBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO1lBQ3JCLEtBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSSxDQUFDLElBQUksQ0FBQztZQUNuQixLQUFJLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQztZQUVsQiwyQkFBMkI7UUFDL0IsQ0FBQztRQXpDRyxLQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ2xCLEtBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDbkIsS0FBSSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUM7UUFFYixLQUFJLENBQUMsSUFBSSxHQUFHLDJCQUFZLENBQUMsTUFBTSxHQUFDLENBQUMsQ0FBQztRQUNsQyxLQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztRQUNoQixLQUFJLENBQUMsSUFBSSxHQUFHLDJCQUFZLENBQUMsT0FBTyxDQUFDO1FBQ2pDLEtBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO1FBQ3JCLEtBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSSxDQUFDLElBQUksQ0FBQztRQUVuQiwyQkFBMkI7UUFFM0IsS0FBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7O0lBQzNCLENBQUM7SUFFTSw2QkFBWSxHQUFuQixVQUFvQixNQUFpQjtRQUNqQyxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBRSxJQUFJLEVBQUUsQ0FBQyxNQUFNLENBQUMsbUJBQVEsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUN4RSxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRXhCLElBQU0sZUFBZSxHQUFHLElBQUksRUFBRSxDQUFDLFdBQVcsQ0FBQyxtQkFBUSxDQUFDLFFBQVEsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUM3RSxJQUFJLENBQUMsYUFBYSxHQUFHLGVBQWUsQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUMzRSxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksR0FBRyxLQUFLLENBQUM7UUFDaEMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBRTVDLE1BQU0sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUMzRCxDQUFDO0lBa0JNLHVCQUFNLEdBQWIsVUFBYyxNQUFpQixFQUFFLEtBQWE7UUFDNUMsaUJBQU0sTUFBTSxZQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLHlCQUF5QjtRQUV0RCxFQUFFLEVBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQztZQUN0RCxNQUFNLENBQUM7UUFFWCxFQUFFLEVBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7WUFDZCxJQUFJLENBQUMsTUFBTSxHQUFHLDJCQUFZLENBQUMsS0FBSyxDQUFDO1lBQ2pDLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDNUIsQ0FBQztRQUNELElBQUk7WUFDQSxJQUFJLENBQUMsTUFBTSxHQUFHLDJCQUFZLENBQUMsT0FBTyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sR0FBRywyQkFBWSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBQyxDQUFDLElBQUksR0FBQywyQkFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUUvSCxJQUFJLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxHQUFDLElBQUksQ0FBQztRQUN0QyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7UUFDbkIsZ0dBQWdHO1FBQ2hHLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLEtBQUssR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFbEcsSUFBSSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUM7UUFFckIsRUFBRSxFQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxFQUFFLENBQUM7WUFDM0IsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUc1QixFQUFFLEVBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxJQUFJLElBQUksQ0FBQztZQUM3QyxJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQ25DLENBQUM7SUFDSixhQUFDO0FBQUQsQ0FBQyxDQWxGb0IsRUFBRSxDQUFDLEtBQUssR0FrRjVCO0FBRVEsd0JBQU07Ozs7Ozs7Ozs7Ozs7OztBQ3pGZixJQUFpQixhQUFhLENBb0I3QjtBQXBCRCxXQUFpQixhQUFhO0lBQzFCO1FBQ0ksSUFBSSxHQUFHLEdBQUcsRUFBRSxXQUFXLEVBQUUsY0FBYyxFQUFFLENBQUM7UUFDMUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQ3hDLENBQUM7SUFIZSx5QkFBVyxjQUcxQjtJQUVELG1CQUEyQixRQUFnQjtRQUN2QyxJQUFJLEdBQUcsR0FBRyxFQUFDLFdBQVcsRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBQyxDQUFDO1FBQ2xELE1BQU0sQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztJQUN4QyxDQUFDO0lBSGUsdUJBQVMsWUFHeEI7SUFFRCxzQkFBOEIsS0FBYSxFQUFFLE1BQWM7UUFDdkQsSUFBSSxHQUFHLEdBQUcsRUFBQyxXQUFXLEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFBRSxFQUFDLE9BQU8sRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBQyxFQUFDLENBQUM7UUFDaEYsTUFBTSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQ3hDLENBQUM7SUFIZSwwQkFBWSxlQUczQjtJQUVELHVCQUErQixTQUFpQjtRQUM1QyxJQUFJLEdBQUcsR0FBRyxFQUFFLFdBQVcsRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxFQUFFLENBQUM7UUFDdkUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQ3hDLENBQUM7SUFIZSwyQkFBYSxnQkFHNUI7QUFDTCxDQUFDLEVBcEJnQixhQUFhLEdBQWIscUJBQWEsS0FBYixxQkFBYSxRQW9CN0I7Ozs7Ozs7Ozs7Ozs7OztBQ3BCRCxJQUFpQixZQUFZLENBd0I1QjtBQXhCRCxXQUFpQixZQUFZO0lBQ1osa0JBQUssR0FBRyxHQUFHLENBQUM7SUFDWixtQkFBTSxHQUFHLEdBQUcsQ0FBQztJQUViLG9CQUFPLEdBQUcsR0FBRyxDQUFDO0lBQ2Qsa0JBQUssR0FBRyxDQUFDLEdBQUcsQ0FBQztJQUNiLG9CQUFPLEdBQUcsR0FBRyxDQUFDO0lBQ2QsbUJBQU0sR0FBRyxHQUFHLENBQUM7SUFFYiwwQkFBYSxHQUFHLEdBQUcsQ0FBQztJQUNwQix3QkFBVyxHQUFHLEdBQUcsQ0FBQztJQUNsQixzQkFBUyxHQUFHLEdBQUcsQ0FBQztJQUNoQixzQkFBUyxHQUFHLEdBQUcsQ0FBQztJQUNoQiwyQkFBYyxHQUFHLEdBQUcsQ0FBQztJQUNyQiwwQkFBYSxHQUFHLEdBQUcsQ0FBQztJQUNwQix3QkFBVyxHQUFHLENBQUMsQ0FBQztJQUVoQiw2QkFBZ0IsR0FBRyxFQUFFLENBQUM7SUFDdEIsc0JBQVMsR0FBRyxFQUFFLENBQUM7SUFDZiwyQkFBYyxHQUFHLEdBQUcsQ0FBQztJQUVyQiwwQkFBYSxHQUFHLEVBQUUsQ0FBQztJQUNuQix3QkFBVyxHQUFHLEdBQUcsQ0FBQztJQUNsQix1QkFBVSxHQUFHLEVBQUUsQ0FBQztBQUNqQyxDQUFDLEVBeEJnQixZQUFZLEdBQVosb0JBQVksS0FBWixvQkFBWSxRQXdCNUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4QkQsNEZBQWdDO0FBQ2hDLGlIQUF5RDtBQUV6RCw0RUFBc0M7QUFDdEMsd0ZBQThDO0FBQzlDLDJGQUFnRDtBQUVoRDtJQUFtQix3QkFBUztJQUN4QjtRQUFBLFlBQ0ksa0JBQU0sRUFBRSxLQUFLLEVBQUUsMkJBQVksQ0FBQyxLQUFLO1lBQ3pCLE1BQU0sRUFBRSwyQkFBWSxDQUFDLE1BQU07WUFDM0IsV0FBVyxFQUFFLEVBQUUsQ0FBQyxXQUFXLENBQUMsS0FBSztZQUNqQyxZQUFZLEVBQUUsRUFBRSxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsTUFBTSxFQUFFLENBQUMsU0FFeEQ7UUFERyw2QkFBYSxDQUFDLFlBQVksQ0FBQywyQkFBWSxDQUFDLEtBQUssRUFBRSwyQkFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDOztJQUN4RSxDQUFDO0lBRU0sb0JBQUssR0FBWixVQUFhLE1BQW1CO1FBQzVCLE1BQU0sQ0FBQyxpQkFBTSxLQUFLLFlBQUMsTUFBTSxDQUFDLENBQUM7SUFDL0IsQ0FBQztJQUNMLFdBQUM7QUFBRCxDQUFDLENBWmtCLEVBQUUsQ0FBQyxNQUFNLEdBWTNCO0FBRUQsSUFBSSxNQUFNLEdBQUcsSUFBSSxFQUFFLENBQUMsTUFBTSxFQUFFLENBQUM7QUFDN0IsR0FBRyxFQUFDLElBQUksUUFBUSxJQUFJLG1CQUFRLENBQUMsRUFBQztJQUMxQixNQUFNLENBQUMsV0FBVyxDQUFDLG1CQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztBQUMzQyxDQUFDO0FBRUQsSUFBTSxJQUFJLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQztBQUN4QixJQUFNLFNBQVMsR0FBRyxJQUFJLHFCQUFTLEVBQUUsQ0FBQztBQUVsQyxJQUFJLENBQUMsR0FBRyxDQUFDLFdBQVcsRUFBRSxTQUFTLENBQUMsQ0FBQztBQUVqQyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQztJQUNwQixJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBQ2hDLENBQUMsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7QUNqQ0gsNEZBQWdDO0FBRWhDLHlDQUF5QztBQUN6QyxJQUFJLFFBQVEsR0FBRztJQUNkLFVBQVUsRUFBRSxJQUFJLEVBQUUsQ0FBQyxPQUFPLENBQUMsdUJBQXVCLENBQUM7SUFFaEQsUUFBUSxFQUFFLElBQUksRUFBRSxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQztJQUMxQyxNQUFNLEVBQUUsSUFBSSxFQUFFLENBQUMsT0FBTyxDQUFDLG1CQUFtQixDQUFDO0lBRTNDLElBQUksRUFBRSxJQUFJLEVBQUUsQ0FBQyxPQUFPLENBQUMsaUJBQWlCLENBQUM7SUFDdkMsS0FBSyxFQUFFLElBQUksRUFBRSxDQUFDLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQztJQUN6QyxTQUFTLEVBQUUsSUFBSSxFQUFFLENBQUMsT0FBTyxDQUFDLHVCQUF1QixDQUFDO0lBQ2xELEtBQUssRUFBRSxJQUFJLEVBQUUsQ0FBQyxPQUFPLENBQUMsa0JBQWtCLENBQUM7SUFFekMsYUFBYSxFQUFFLElBQUksRUFBRSxDQUFDLE9BQU8sQ0FBQywyQkFBMkIsQ0FBQztJQUMxRCxVQUFVLEVBQUUsSUFBSSxFQUFFLENBQUMsT0FBTyxDQUFDLHdCQUF3QixDQUFDO0NBQ3ZEO0FBRVEsNEJBQVE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsQmpCLDRGQUFnQztBQUNoQyxnRkFBMEM7QUFDMUMsc0dBQW9EO0FBQ3BELHFIQUE2RDtBQUM3RCxrSUFBdUU7QUFDdkUsNEZBQWtEO0FBQ2xELCtGQUFvRDtBQUNwRCxvQ0FBb0M7QUFHcEM7SUFBd0IsNkJBQVE7SUFBaEM7UUFBQSxxRUE4TUM7UUE1R1UsYUFBTyxHQUFHO1lBQ2IsRUFBRSxFQUFDLENBQUMsS0FBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7Z0JBQ25CLEtBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDO2dCQUN4QixLQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUM7WUFDckMsQ0FBQztZQUVELEVBQUUsRUFBQyxLQUFJLENBQUMsUUFBUSxJQUFJLEtBQUksQ0FBQyxVQUFVLENBQUM7Z0JBQ2hDLEtBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDO1FBQy9CLENBQUM7UUFFTSxvQkFBYyxHQUFHLFVBQUMsS0FBVTtZQUMvQixFQUFFLEVBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxXQUFXLElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQztnQkFDbEMsa0NBQWtDO2dCQUNsQyxLQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSSxDQUFDLFNBQVMsRUFBRSxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUM5RSxDQUFDO1FBQ0wsQ0FBQztRQTZFTSxpQkFBVyxHQUFHO1lBQ2pCLEtBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO1lBQ3JCLEtBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxHQUFHLFdBQVc7WUFDbkMsS0FBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO1lBQ2hDLEtBQUksQ0FBQyxnQkFBZ0IsR0FBRyxDQUFDLENBQUM7WUFFMUIsRUFBRSxFQUFDLEtBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7Z0JBQzdCLEtBQUksQ0FBQyxTQUFTLEdBQUcsS0FBSSxDQUFDLEtBQUssQ0FBQztnQkFDNUIsNkJBQWEsQ0FBQyxhQUFhLENBQUMsS0FBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQ2hELENBQUM7WUFFRCw2QkFBYSxDQUFDLFNBQVMsQ0FBQyxLQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDeEMsQ0FBQzs7SUFJTCxDQUFDO0lBeExVLGdDQUFZLEdBQW5CLFVBQW9CLE1BQWlCO1FBQ2pDLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDO1FBQ2YsSUFBSSxDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUM7UUFFbkIsSUFBSSxVQUFVLEdBQUcsSUFBSSxFQUFFLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDaEMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxtQkFBUSxDQUFDLFVBQVUsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO1FBQ3RELElBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDckIsVUFBVSxDQUFDLENBQUMsR0FBRywyQkFBWSxDQUFDLEtBQUssR0FBQyxDQUFDLENBQUM7UUFDcEMsVUFBVSxDQUFDLENBQUMsR0FBRywyQkFBWSxDQUFDLE1BQU0sR0FBQyxDQUFDLENBQUM7UUFDckMsVUFBVSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQztRQUVuQixJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksZUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQy9CLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3RCLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUVsQixJQUFJLENBQUMsZ0JBQWdCLEdBQUcsMkJBQVksQ0FBQyxhQUFhLENBQUM7UUFDbkQsSUFBSSxDQUFDLGFBQWEsR0FBRywyQkFBWSxDQUFDLE1BQU0sR0FBQyxDQUFDLENBQUM7UUFDM0MsSUFBSSxDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUNuQixJQUFJLENBQUMsa0JBQWtCLEdBQUcsMkJBQVksQ0FBQyxnQkFBZ0IsQ0FBQztRQUV4RCxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksRUFBRSxDQUFDLEtBQUssQ0FBQywwQkFBMEIsRUFBRSwyQkFBWSxDQUFDLEtBQUssR0FBQyxDQUFDLEVBQUUsMkJBQVksQ0FBQyxNQUFNLEdBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ2xILElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDO1FBQ2pELElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDO1FBQ2pELElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxHQUFHLEVBQUUsQ0FBQztRQUMvQixJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQztRQUN4QyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUMzQixJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7UUFFeEIsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLEVBQUUsQ0FBQyxLQUFLLENBQUMsa0JBQWtCLEVBQUUsMkJBQVksQ0FBQyxLQUFLLEdBQUMsQ0FBQyxFQUFFLDJCQUFZLENBQUMsTUFBTSxHQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDaEgsSUFBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLEdBQUcsRUFBRSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUM7UUFDbEQsSUFBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLEdBQUcsRUFBRSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUM7UUFDL0MsSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLEdBQUcsRUFBRSxDQUFDO1FBQ2hDLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDO1FBQ3pDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBQzVCLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUN6QixJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUM7UUFFbEMsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLEVBQUUsQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDckQsSUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTLEdBQUcsRUFBRSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUM7UUFDOUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTLEdBQUcsRUFBRSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUM7UUFDN0MsSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLEdBQUcsRUFBRSxDQUFDO1FBQzlCLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDO1FBQ3ZDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQzFCLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUV2QixJQUFJLENBQUMsY0FBYyxHQUFHLElBQUksRUFBRSxDQUFDLEtBQUssQ0FBQyxTQUFTLEVBQUUsMkJBQVksQ0FBQyxLQUFLLEdBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUNsRixJQUFJLENBQUMsY0FBYyxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQztRQUNuRCxJQUFJLENBQUMsY0FBYyxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQztRQUNqRCxJQUFJLENBQUMsY0FBYyxDQUFDLFFBQVEsR0FBRyxFQUFFLENBQUM7UUFDbEMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUM7UUFDM0MsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDOUIsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBRTNCLElBQUksQ0FBQyxXQUFXLEdBQUcsS0FBSyxDQUFDO1FBQ3pCLElBQUksQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDO1FBQ3RCLElBQUksQ0FBQyxVQUFVLEdBQUcsS0FBSyxDQUFDO1FBQ3hCLElBQUksQ0FBQyxVQUFVLEdBQUcsS0FBSyxDQUFDO1FBRXhCLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxFQUFFLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDN0IsSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsbUJBQVEsQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztRQUNuRCxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRywyQkFBWSxDQUFDLEtBQUssR0FBQyxDQUFDLENBQUM7UUFDckMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsMkJBQVksQ0FBQyxNQUFNLEdBQUcsMkJBQVksQ0FBQyxhQUFhLEdBQUMsQ0FBQyxDQUFDO1FBQ25FLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLDJCQUFZLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDekMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsMkJBQVksQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUNsRCxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUN0QixJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7UUFFbEIsTUFBTSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3ZELGlIQUFpSDtRQUVqSCxNQUFNLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxjQUFjLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDL0QsNkJBQWEsQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUU1QixJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsR0FBRyxJQUFJLEVBQUUsQ0FBQyxNQUFNLENBQUMsMkJBQVksQ0FBQyxLQUFLLEdBQUMsQ0FBQyxFQUFFLDJCQUFZLENBQUMsTUFBTSxHQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2pGLENBQUM7SUFvQk0sMEJBQU0sR0FBYixVQUFjLE1BQWlCLEVBQUUsS0FBYTtRQUMxQyxpQkFBTSxNQUFNLFlBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBRTVCLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxHQUFHLFFBQVEsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDO1FBRXJELEVBQUUsRUFBQyxJQUFJLENBQUMsUUFBUSxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7WUFDbkMsSUFBSSxDQUFDLGdCQUFnQixJQUFJLEtBQUssR0FBQyxJQUFJLENBQUM7WUFDcEMsRUFBRSxFQUFDLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUMzQixJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQztnQkFDdkIsSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO1lBQ3JDLENBQUM7UUFDTCxDQUFDO1FBRUQsRUFBRSxFQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1lBQ2pCLEdBQUcsRUFBQyxJQUFJLEVBQUUsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztnQkFDeEIsRUFBRSxFQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFlBQVkscUJBQVMsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxZQUFZLG1DQUFnQixDQUFDLENBQUMsQ0FBQztvQkFDckYsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztnQkFDM0IsQ0FBQztZQUNMLENBQUM7WUFFRCxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDO1lBRXBCLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDO1lBQ2YsSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO1lBQ2xDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxHQUFHLDBCQUEwQixDQUFDO1lBRW5ELElBQUksQ0FBQyxXQUFXLEdBQUcsS0FBSyxDQUFDO1lBQ3pCLElBQUksQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDO1lBQ3RCLElBQUksQ0FBQyxVQUFVLEdBQUcsS0FBSyxDQUFDO1lBRXhCLElBQUksQ0FBQyxnQkFBZ0IsR0FBRywyQkFBWSxDQUFDLGFBQWEsQ0FBQztZQUNuRCxJQUFJLENBQUMsYUFBYSxHQUFHLDJCQUFZLENBQUMsTUFBTSxHQUFDLENBQUMsQ0FBQztZQUUzQyxJQUFJLENBQUMsa0JBQWtCLEdBQUcsMkJBQVksQ0FBQyxnQkFBZ0IsQ0FBQztZQUV4RCxJQUFJLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQztRQUM1QixDQUFDO1FBRUQsSUFBSSxDQUFDLEVBQUUsRUFBQyxJQUFJLENBQUMsUUFBUSxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQztZQUN2QyxNQUFNLENBQUM7UUFFWCxJQUFJLENBQUMsQ0FBQztZQUVGLHdEQUF3RDtZQUV4RCxJQUFJLENBQUMsZ0JBQWdCLElBQUksS0FBSyxHQUFDLElBQUksQ0FBQztZQUNwQyxJQUFJLENBQUMsa0JBQWtCLElBQUksS0FBSyxHQUFDLElBQUksQ0FBQztZQUV0QyxFQUFFLEVBQUMsSUFBSSxDQUFDLGdCQUFnQixHQUFHLDJCQUFZLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztnQkFDcEQsSUFBSSxJQUFJLEdBQUcsMkJBQVksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsMkJBQVksQ0FBQyxXQUFXLENBQUMsQ0FBQztnQkFDckYsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQywyQkFBWSxDQUFDLFNBQVMsR0FBRyxDQUFDLDJCQUFZLENBQUMsU0FBUyxHQUFHLDJCQUFZLENBQUMsU0FBUyxDQUFDLEdBQUcsMkJBQVksQ0FBQyxjQUFjLENBQUMsQ0FBQztnQkFDbEksSUFBSSxJQUFJLENBQUM7Z0JBQ1QsR0FBRyxDQUFDO29CQUNBLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQywyQkFBWSxDQUFDLE1BQU0sR0FBRywyQkFBWSxDQUFDLGFBQWEsR0FBRyxDQUFDLEdBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQzdHLENBQUMsUUFBTyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQywyQkFBWSxDQUFDLGFBQWEsR0FBRyxDQUFDLDJCQUFZLENBQUMsV0FBVyxHQUFHLDJCQUFZLENBQUMsYUFBYSxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssR0FBRywyQkFBWSxDQUFDLGNBQWMsQ0FBQyxHQUFHLDJCQUFZLENBQUMsTUFBTSxFQUFFO2dCQUN2TSwwQ0FBMEM7Z0JBRTFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxxQkFBUyxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7Z0JBQ2xELElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDO2dCQUMxQixJQUFJLENBQUMsZ0JBQWdCLEdBQUcsQ0FBQyxDQUFDO1lBQzlCLENBQUM7WUFHRCxFQUFFLEVBQUMsSUFBSSxDQUFDLGtCQUFrQixHQUFHLDJCQUFZLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDO2dCQUN6RCxJQUFJLEVBQUUsR0FBRyxJQUFJLG1DQUFnQixDQUFDLElBQUksQ0FBQztnQkFDbkMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQztnQkFDYixFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFDVCxJQUFJLENBQUMsa0JBQWtCLEdBQUcsQ0FBQyxDQUFDO1lBQ2hDLENBQUM7WUFFRCxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ2pELENBQUM7SUFDTCxDQUFDO0lBZ0JNLDhCQUFVLEdBQWpCLGNBQXFCLENBQUM7SUFDZixnQ0FBWSxHQUFuQixjQUF1QixDQUFDO0lBQzVCLGdCQUFDO0FBQUQsQ0FBQyxDQTlNdUIsRUFBRSxDQUFDLEtBQUssR0E4TS9CO0FBRVEsOEJBQVMiLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL2luZGV4LnRzXCIpO1xuIiwiLyohIGV4Y2FsaWJ1ciAtIHYwLjE1LjAgLSAyMDE4LTAyLTE3XHJcbiogaHR0cHM6Ly9naXRodWIuY29tL2V4Y2FsaWJ1cmpzL0V4Y2FsaWJ1clxyXG4qIENvcHlyaWdodCAoYykgMjAxOCBFeGNhbGlidXIuanMgPGh0dHBzOi8vZ2l0aHViLmNvbS9leGNhbGlidXJqcy9FeGNhbGlidXIvZ3JhcGhzL2NvbnRyaWJ1dG9ycz47IExpY2Vuc2VkIEJTRC0yLUNsYXVzZVxyXG4qIEBwcmVzZXJ2ZSAqL1xyXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcclxuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcclxuICAgICAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXHJcbiAgICAgICAgZGVmaW5lKFtdLCBmdW5jdGlvbiAoYikge1xyXG4gICAgICAgICAgICByZXR1cm4gKHJvb3QuZXggPSBmYWN0b3J5KGIpKTtcclxuICAgICAgICB9KTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcclxuICAgICAgICAvLyBOb2RlLiBEb2VzIG5vdCB3b3JrIHdpdGggc3RyaWN0IENvbW1vbkpTLCBidXRcclxuICAgICAgICAvLyBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cyxcclxuICAgICAgICAvLyBsaWtlIE5vZGUuXHJcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIEJyb3dzZXIgZ2xvYmFsc1xyXG4gICAgICAgIHJvb3QuZXggPSBmYWN0b3J5KCk7XHJcbiAgICB9XHJcbn0odGhpcywgZnVuY3Rpb24gKCkge1xyXG4gICAgLy9hbG1vbmQsIGFuZCB5b3VyIG1vZHVsZXMgd2lsbCBiZSBpbmxpbmVkIGhlcmVcclxuLyoqXHJcbiAqIEBsaWNlbnNlIGFsbW9uZCAwLjMuMyBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycy5cclxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UsIGh0dHA6Ly9naXRodWIuY29tL3JlcXVpcmVqcy9hbG1vbmQvTElDRU5TRVxyXG4gKi9cclxuLy9Hb2luZyBzbG9wcHkgdG8gYXZvaWQgJ3VzZSBzdHJpY3QnIHN0cmluZyBjb3N0LCBidXQgc3RyaWN0IHByYWN0aWNlcyBzaG91bGRcclxuLy9iZSBmb2xsb3dlZC5cclxuLypnbG9iYWwgc2V0VGltZW91dDogZmFsc2UgKi9cclxuXHJcbnZhciByZXF1aXJlanMsIHJlcXVpcmUsIGRlZmluZTtcclxuKGZ1bmN0aW9uICh1bmRlZikge1xyXG4gICAgdmFyIG1haW4sIHJlcSwgbWFrZU1hcCwgaGFuZGxlcnMsXHJcbiAgICAgICAgZGVmaW5lZCA9IHt9LFxyXG4gICAgICAgIHdhaXRpbmcgPSB7fSxcclxuICAgICAgICBjb25maWcgPSB7fSxcclxuICAgICAgICBkZWZpbmluZyA9IHt9LFxyXG4gICAgICAgIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXHJcbiAgICAgICAgYXBzID0gW10uc2xpY2UsXHJcbiAgICAgICAganNTdWZmaXhSZWdFeHAgPSAvXFwuanMkLztcclxuXHJcbiAgICBmdW5jdGlvbiBoYXNQcm9wKG9iaiwgcHJvcCkge1xyXG4gICAgICAgIHJldHVybiBoYXNPd24uY2FsbChvYmosIHByb3ApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gYSByZWxhdGl2ZSBtb2R1bGUgbmFtZSwgbGlrZSAuL3NvbWV0aGluZywgbm9ybWFsaXplIGl0IHRvXHJcbiAgICAgKiBhIHJlYWwgbmFtZSB0aGF0IGNhbiBiZSBtYXBwZWQgdG8gYSBwYXRoLlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgdGhlIHJlbGF0aXZlIG5hbWVcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlTmFtZSBhIHJlYWwgbmFtZSB0aGF0IHRoZSBuYW1lIGFyZyBpcyByZWxhdGl2ZVxyXG4gICAgICogdG8uXHJcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBub3JtYWxpemVkIG5hbWVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplKG5hbWUsIGJhc2VOYW1lKSB7XHJcbiAgICAgICAgdmFyIG5hbWVQYXJ0cywgbmFtZVNlZ21lbnQsIG1hcFZhbHVlLCBmb3VuZE1hcCwgbGFzdEluZGV4LFxyXG4gICAgICAgICAgICBmb3VuZEksIGZvdW5kU3Rhck1hcCwgc3RhckksIGksIGosIHBhcnQsIG5vcm1hbGl6ZWRCYXNlUGFydHMsXHJcbiAgICAgICAgICAgIGJhc2VQYXJ0cyA9IGJhc2VOYW1lICYmIGJhc2VOYW1lLnNwbGl0KFwiL1wiKSxcclxuICAgICAgICAgICAgbWFwID0gY29uZmlnLm1hcCxcclxuICAgICAgICAgICAgc3Rhck1hcCA9IChtYXAgJiYgbWFwWycqJ10pIHx8IHt9O1xyXG5cclxuICAgICAgICAvL0FkanVzdCBhbnkgcmVsYXRpdmUgcGF0aHMuXHJcbiAgICAgICAgaWYgKG5hbWUpIHtcclxuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3BsaXQoJy8nKTtcclxuICAgICAgICAgICAgbGFzdEluZGV4ID0gbmFtZS5sZW5ndGggLSAxO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgd2FudGluZyBub2RlIElEIGNvbXBhdGliaWxpdHksIHN0cmlwIC5qcyBmcm9tIGVuZFxyXG4gICAgICAgICAgICAvLyBvZiBJRHMuIEhhdmUgdG8gZG8gdGhpcyBoZXJlLCBhbmQgbm90IGluIG5hbWVUb1VybFxyXG4gICAgICAgICAgICAvLyBiZWNhdXNlIG5vZGUgYWxsb3dzIGVpdGhlciAuanMgb3Igbm9uIC5qcyB0byBtYXBcclxuICAgICAgICAgICAgLy8gdG8gc2FtZSBmaWxlLlxyXG4gICAgICAgICAgICBpZiAoY29uZmlnLm5vZGVJZENvbXBhdCAmJiBqc1N1ZmZpeFJlZ0V4cC50ZXN0KG5hbWVbbGFzdEluZGV4XSkpIHtcclxuICAgICAgICAgICAgICAgIG5hbWVbbGFzdEluZGV4XSA9IG5hbWVbbGFzdEluZGV4XS5yZXBsYWNlKGpzU3VmZml4UmVnRXhwLCAnJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFN0YXJ0cyB3aXRoIGEgJy4nIHNvIG5lZWQgdGhlIGJhc2VOYW1lXHJcbiAgICAgICAgICAgIGlmIChuYW1lWzBdLmNoYXJBdCgwKSA9PT0gJy4nICYmIGJhc2VQYXJ0cykge1xyXG4gICAgICAgICAgICAgICAgLy9Db252ZXJ0IGJhc2VOYW1lIHRvIGFycmF5LCBhbmQgbG9wIG9mZiB0aGUgbGFzdCBwYXJ0LFxyXG4gICAgICAgICAgICAgICAgLy9zbyB0aGF0IC4gbWF0Y2hlcyB0aGF0ICdkaXJlY3RvcnknIGFuZCBub3QgbmFtZSBvZiB0aGUgYmFzZU5hbWUnc1xyXG4gICAgICAgICAgICAgICAgLy9tb2R1bGUuIEZvciBpbnN0YW5jZSwgYmFzZU5hbWUgb2YgJ29uZS90d28vdGhyZWUnLCBtYXBzIHRvXHJcbiAgICAgICAgICAgICAgICAvLydvbmUvdHdvL3RocmVlLmpzJywgYnV0IHdlIHdhbnQgdGhlIGRpcmVjdG9yeSwgJ29uZS90d28nIGZvclxyXG4gICAgICAgICAgICAgICAgLy90aGlzIG5vcm1hbGl6YXRpb24uXHJcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkQmFzZVBhcnRzID0gYmFzZVBhcnRzLnNsaWNlKDAsIGJhc2VQYXJ0cy5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgICAgIG5hbWUgPSBub3JtYWxpemVkQmFzZVBhcnRzLmNvbmNhdChuYW1lKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9zdGFydCB0cmltRG90c1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbmFtZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcGFydCA9IG5hbWVbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAocGFydCA9PT0gJy4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZS5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaSAtPSAxO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJ0ID09PSAnLi4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYXQgdGhlIHN0YXJ0LCBvciBwcmV2aW91cyB2YWx1ZSBpcyBzdGlsbCAuLixcclxuICAgICAgICAgICAgICAgICAgICAvLyBrZWVwIHRoZW0gc28gdGhhdCB3aGVuIGNvbnZlcnRlZCB0byBhIHBhdGggaXQgbWF5XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RpbGwgd29yayB3aGVuIGNvbnZlcnRlZCB0byBhIHBhdGgsIGV2ZW4gdGhvdWdoXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgYW4gSUQgaXQgaXMgbGVzcyB0aGFuIGlkZWFsLiBJbiBsYXJnZXIgcG9pbnRcclxuICAgICAgICAgICAgICAgICAgICAvLyByZWxlYXNlcywgbWF5IGJlIGJldHRlciB0byBqdXN0IGtpY2sgb3V0IGFuIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAwIHx8IChpID09PSAxICYmIG5hbWVbMl0gPT09ICcuLicpIHx8IG5hbWVbaSAtIDFdID09PSAnLi4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZS5zcGxpY2UoaSAtIDEsIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpIC09IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vZW5kIHRyaW1Eb3RzXHJcblxyXG4gICAgICAgICAgICBuYW1lID0gbmFtZS5qb2luKCcvJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL0FwcGx5IG1hcCBjb25maWcgaWYgYXZhaWxhYmxlLlxyXG4gICAgICAgIGlmICgoYmFzZVBhcnRzIHx8IHN0YXJNYXApICYmIG1hcCkge1xyXG4gICAgICAgICAgICBuYW1lUGFydHMgPSBuYW1lLnNwbGl0KCcvJyk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGkgPSBuYW1lUGFydHMubGVuZ3RoOyBpID4gMDsgaSAtPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lU2VnbWVudCA9IG5hbWVQYXJ0cy5zbGljZSgwLCBpKS5qb2luKFwiL1wiKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoYmFzZVBhcnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9GaW5kIHRoZSBsb25nZXN0IGJhc2VOYW1lIHNlZ21lbnQgbWF0Y2ggaW4gdGhlIGNvbmZpZy5cclxuICAgICAgICAgICAgICAgICAgICAvL1NvLCBkbyBqb2lucyBvbiB0aGUgYmlnZ2VzdCB0byBzbWFsbGVzdCBsZW5ndGhzIG9mIGJhc2VQYXJ0cy5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSBiYXNlUGFydHMubGVuZ3RoOyBqID4gMDsgaiAtPSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcFZhbHVlID0gbWFwW2Jhc2VQYXJ0cy5zbGljZSgwLCBqKS5qb2luKCcvJyldO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9iYXNlTmFtZSBzZWdtZW50IGhhcyAgY29uZmlnLCBmaW5kIGlmIGl0IGhhcyBvbmUgZm9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhpcyBuYW1lLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFwVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcFZhbHVlID0gbWFwVmFsdWVbbmFtZVNlZ21lbnRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hcFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9NYXRjaCwgdXBkYXRlIG5hbWUgdG8gdGhlIG5ldyB2YWx1ZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZE1hcCA9IG1hcFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kSSA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kTWFwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9DaGVjayBmb3IgYSBzdGFyIG1hcCBtYXRjaCwgYnV0IGp1c3QgaG9sZCBvbiB0byBpdCxcclxuICAgICAgICAgICAgICAgIC8vaWYgdGhlcmUgaXMgYSBzaG9ydGVyIHNlZ21lbnQgbWF0Y2ggbGF0ZXIgaW4gYSBtYXRjaGluZ1xyXG4gICAgICAgICAgICAgICAgLy9jb25maWcsIHRoZW4gZmF2b3Igb3ZlciB0aGlzIHN0YXIgbWFwLlxyXG4gICAgICAgICAgICAgICAgaWYgKCFmb3VuZFN0YXJNYXAgJiYgc3Rhck1hcCAmJiBzdGFyTWFwW25hbWVTZWdtZW50XSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kU3Rhck1hcCA9IHN0YXJNYXBbbmFtZVNlZ21lbnRdO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJJID0gaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFmb3VuZE1hcCAmJiBmb3VuZFN0YXJNYXApIHtcclxuICAgICAgICAgICAgICAgIGZvdW5kTWFwID0gZm91bmRTdGFyTWFwO1xyXG4gICAgICAgICAgICAgICAgZm91bmRJID0gc3Rhckk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChmb3VuZE1hcCkge1xyXG4gICAgICAgICAgICAgICAgbmFtZVBhcnRzLnNwbGljZSgwLCBmb3VuZEksIGZvdW5kTWFwKTtcclxuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lUGFydHMuam9pbignLycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbmFtZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtYWtlUmVxdWlyZShyZWxOYW1lLCBmb3JjZVN5bmMpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvL0EgdmVyc2lvbiBvZiBhIHJlcXVpcmUgZnVuY3Rpb24gdGhhdCBwYXNzZXMgYSBtb2R1bGVOYW1lXHJcbiAgICAgICAgICAgIC8vdmFsdWUgZm9yIGl0ZW1zIHRoYXQgbWF5IG5lZWQgdG9cclxuICAgICAgICAgICAgLy9sb29rIHVwIHBhdGhzIHJlbGF0aXZlIHRvIHRoZSBtb2R1bGVOYW1lXHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gYXBzLmNhbGwoYXJndW1lbnRzLCAwKTtcclxuXHJcbiAgICAgICAgICAgIC8vSWYgZmlyc3QgYXJnIGlzIG5vdCByZXF1aXJlKCdzdHJpbmcnKSwgYW5kIHRoZXJlIGlzIG9ubHlcclxuICAgICAgICAgICAgLy9vbmUgYXJnLCBpdCBpcyB0aGUgYXJyYXkgZm9ybSB3aXRob3V0IGEgY2FsbGJhY2suIEluc2VydFxyXG4gICAgICAgICAgICAvL2EgbnVsbCBzbyB0aGF0IHRoZSBmb2xsb3dpbmcgY29uY2F0IGlzIGNvcnJlY3QuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnc1swXSAhPT0gJ3N0cmluZycgJiYgYXJncy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVxLmFwcGx5KHVuZGVmLCBhcmdzLmNvbmNhdChbcmVsTmFtZSwgZm9yY2VTeW5jXSkpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbWFrZU5vcm1hbGl6ZShyZWxOYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpemUobmFtZSwgcmVsTmFtZSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtYWtlTG9hZChkZXBOYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBkZWZpbmVkW2RlcE5hbWVdID0gdmFsdWU7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjYWxsRGVwKG5hbWUpIHtcclxuICAgICAgICBpZiAoaGFzUHJvcCh3YWl0aW5nLCBuYW1lKSkge1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IHdhaXRpbmdbbmFtZV07XHJcbiAgICAgICAgICAgIGRlbGV0ZSB3YWl0aW5nW25hbWVdO1xyXG4gICAgICAgICAgICBkZWZpbmluZ1tuYW1lXSA9IHRydWU7XHJcbiAgICAgICAgICAgIG1haW4uYXBwbHkodW5kZWYsIGFyZ3MpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFoYXNQcm9wKGRlZmluZWQsIG5hbWUpICYmICFoYXNQcm9wKGRlZmluaW5nLCBuYW1lKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vICcgKyBuYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRlZmluZWRbbmFtZV07XHJcbiAgICB9XHJcblxyXG4gICAgLy9UdXJucyBhIHBsdWdpbiFyZXNvdXJjZSB0byBbcGx1Z2luLCByZXNvdXJjZV1cclxuICAgIC8vd2l0aCB0aGUgcGx1Z2luIGJlaW5nIHVuZGVmaW5lZCBpZiB0aGUgbmFtZVxyXG4gICAgLy9kaWQgbm90IGhhdmUgYSBwbHVnaW4gcHJlZml4LlxyXG4gICAgZnVuY3Rpb24gc3BsaXRQcmVmaXgobmFtZSkge1xyXG4gICAgICAgIHZhciBwcmVmaXgsXHJcbiAgICAgICAgICAgIGluZGV4ID0gbmFtZSA/IG5hbWUuaW5kZXhPZignIScpIDogLTE7XHJcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgcHJlZml4ID0gbmFtZS5zdWJzdHJpbmcoMCwgaW5kZXgpO1xyXG4gICAgICAgICAgICBuYW1lID0gbmFtZS5zdWJzdHJpbmcoaW5kZXggKyAxLCBuYW1lLmxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbcHJlZml4LCBuYW1lXTtcclxuICAgIH1cclxuXHJcbiAgICAvL0NyZWF0ZXMgYSBwYXJ0cyBhcnJheSBmb3IgYSByZWxOYW1lIHdoZXJlIGZpcnN0IHBhcnQgaXMgcGx1Z2luIElELFxyXG4gICAgLy9zZWNvbmQgcGFydCBpcyByZXNvdXJjZSBJRC4gQXNzdW1lcyByZWxOYW1lIGhhcyBhbHJlYWR5IGJlZW4gbm9ybWFsaXplZC5cclxuICAgIGZ1bmN0aW9uIG1ha2VSZWxQYXJ0cyhyZWxOYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlbE5hbWUgPyBzcGxpdFByZWZpeChyZWxOYW1lKSA6IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFrZXMgYSBuYW1lIG1hcCwgbm9ybWFsaXppbmcgdGhlIG5hbWUsIGFuZCB1c2luZyBhIHBsdWdpblxyXG4gICAgICogZm9yIG5vcm1hbGl6YXRpb24gaWYgbmVjZXNzYXJ5LiBHcmFicyBhIHJlZiB0byBwbHVnaW5cclxuICAgICAqIHRvbywgYXMgYW4gb3B0aW1pemF0aW9uLlxyXG4gICAgICovXHJcbiAgICBtYWtlTWFwID0gZnVuY3Rpb24gKG5hbWUsIHJlbFBhcnRzKSB7XHJcbiAgICAgICAgdmFyIHBsdWdpbixcclxuICAgICAgICAgICAgcGFydHMgPSBzcGxpdFByZWZpeChuYW1lKSxcclxuICAgICAgICAgICAgcHJlZml4ID0gcGFydHNbMF0sXHJcbiAgICAgICAgICAgIHJlbFJlc291cmNlTmFtZSA9IHJlbFBhcnRzWzFdO1xyXG5cclxuICAgICAgICBuYW1lID0gcGFydHNbMV07XHJcblxyXG4gICAgICAgIGlmIChwcmVmaXgpIHtcclxuICAgICAgICAgICAgcHJlZml4ID0gbm9ybWFsaXplKHByZWZpeCwgcmVsUmVzb3VyY2VOYW1lKTtcclxuICAgICAgICAgICAgcGx1Z2luID0gY2FsbERlcChwcmVmaXgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9Ob3JtYWxpemUgYWNjb3JkaW5nXHJcbiAgICAgICAgaWYgKHByZWZpeCkge1xyXG4gICAgICAgICAgICBpZiAocGx1Z2luICYmIHBsdWdpbi5ub3JtYWxpemUpIHtcclxuICAgICAgICAgICAgICAgIG5hbWUgPSBwbHVnaW4ubm9ybWFsaXplKG5hbWUsIG1ha2VOb3JtYWxpemUocmVsUmVzb3VyY2VOYW1lKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lID0gbm9ybWFsaXplKG5hbWUsIHJlbFJlc291cmNlTmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBuYW1lID0gbm9ybWFsaXplKG5hbWUsIHJlbFJlc291cmNlTmFtZSk7XHJcbiAgICAgICAgICAgIHBhcnRzID0gc3BsaXRQcmVmaXgobmFtZSk7XHJcbiAgICAgICAgICAgIHByZWZpeCA9IHBhcnRzWzBdO1xyXG4gICAgICAgICAgICBuYW1lID0gcGFydHNbMV07XHJcbiAgICAgICAgICAgIGlmIChwcmVmaXgpIHtcclxuICAgICAgICAgICAgICAgIHBsdWdpbiA9IGNhbGxEZXAocHJlZml4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9Vc2luZyByaWRpY3Vsb3VzIHByb3BlcnR5IG5hbWVzIGZvciBzcGFjZSByZWFzb25zXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZjogcHJlZml4ID8gcHJlZml4ICsgJyEnICsgbmFtZSA6IG5hbWUsIC8vZnVsbE5hbWVcclxuICAgICAgICAgICAgbjogbmFtZSxcclxuICAgICAgICAgICAgcHI6IHByZWZpeCxcclxuICAgICAgICAgICAgcDogcGx1Z2luXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gbWFrZUNvbmZpZyhuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChjb25maWcgJiYgY29uZmlnLmNvbmZpZyAmJiBjb25maWcuY29uZmlnW25hbWVdKSB8fCB7fTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGhhbmRsZXJzID0ge1xyXG4gICAgICAgIHJlcXVpcmU6IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtYWtlUmVxdWlyZShuYW1lKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGV4cG9ydHM6IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBlID0gZGVmaW5lZFtuYW1lXTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKGRlZmluZWRbbmFtZV0gPSB7fSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG1vZHVsZTogZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGlkOiBuYW1lLFxyXG4gICAgICAgICAgICAgICAgdXJpOiAnJyxcclxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IGRlZmluZWRbbmFtZV0sXHJcbiAgICAgICAgICAgICAgICBjb25maWc6IG1ha2VDb25maWcobmFtZSlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIG1haW4gPSBmdW5jdGlvbiAobmFtZSwgZGVwcywgY2FsbGJhY2ssIHJlbE5hbWUpIHtcclxuICAgICAgICB2YXIgY2pzTW9kdWxlLCBkZXBOYW1lLCByZXQsIG1hcCwgaSwgcmVsUGFydHMsXHJcbiAgICAgICAgICAgIGFyZ3MgPSBbXSxcclxuICAgICAgICAgICAgY2FsbGJhY2tUeXBlID0gdHlwZW9mIGNhbGxiYWNrLFxyXG4gICAgICAgICAgICB1c2luZ0V4cG9ydHM7XHJcblxyXG4gICAgICAgIC8vVXNlIG5hbWUgaWYgbm8gcmVsTmFtZVxyXG4gICAgICAgIHJlbE5hbWUgPSByZWxOYW1lIHx8IG5hbWU7XHJcbiAgICAgICAgcmVsUGFydHMgPSBtYWtlUmVsUGFydHMocmVsTmFtZSk7XHJcblxyXG4gICAgICAgIC8vQ2FsbCB0aGUgY2FsbGJhY2sgdG8gZGVmaW5lIHRoZSBtb2R1bGUsIGlmIG5lY2Vzc2FyeS5cclxuICAgICAgICBpZiAoY2FsbGJhY2tUeXBlID09PSAndW5kZWZpbmVkJyB8fCBjYWxsYmFja1R5cGUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgLy9QdWxsIG91dCB0aGUgZGVmaW5lZCBkZXBlbmRlbmNpZXMgYW5kIHBhc3MgdGhlIG9yZGVyZWRcclxuICAgICAgICAgICAgLy92YWx1ZXMgdG8gdGhlIGNhbGxiYWNrLlxyXG4gICAgICAgICAgICAvL0RlZmF1bHQgdG8gW3JlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZV0gaWYgbm8gZGVwc1xyXG4gICAgICAgICAgICBkZXBzID0gIWRlcHMubGVuZ3RoICYmIGNhbGxiYWNrLmxlbmd0aCA/IFsncmVxdWlyZScsICdleHBvcnRzJywgJ21vZHVsZSddIDogZGVwcztcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGRlcHMubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgICAgIG1hcCA9IG1ha2VNYXAoZGVwc1tpXSwgcmVsUGFydHMpO1xyXG4gICAgICAgICAgICAgICAgZGVwTmFtZSA9IG1hcC5mO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vRmFzdCBwYXRoIENvbW1vbkpTIHN0YW5kYXJkIGRlcGVuZGVuY2llcy5cclxuICAgICAgICAgICAgICAgIGlmIChkZXBOYW1lID09PSBcInJlcXVpcmVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbaV0gPSBoYW5kbGVycy5yZXF1aXJlKG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkZXBOYW1lID09PSBcImV4cG9ydHNcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vQ29tbW9uSlMgbW9kdWxlIHNwZWMgMS4xXHJcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tpXSA9IGhhbmRsZXJzLmV4cG9ydHMobmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdXNpbmdFeHBvcnRzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVwTmFtZSA9PT0gXCJtb2R1bGVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vQ29tbW9uSlMgbW9kdWxlIHNwZWMgMS4xXHJcbiAgICAgICAgICAgICAgICAgICAgY2pzTW9kdWxlID0gYXJnc1tpXSA9IGhhbmRsZXJzLm1vZHVsZShuYW1lKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFzUHJvcChkZWZpbmVkLCBkZXBOYW1lKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNQcm9wKHdhaXRpbmcsIGRlcE5hbWUpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc1Byb3AoZGVmaW5pbmcsIGRlcE5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tpXSA9IGNhbGxEZXAoZGVwTmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1hcC5wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFwLnAubG9hZChtYXAubiwgbWFrZVJlcXVpcmUocmVsTmFtZSwgdHJ1ZSksIG1ha2VMb2FkKGRlcE5hbWUpLCB7fSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tpXSA9IGRlZmluZWRbZGVwTmFtZV07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihuYW1lICsgJyBtaXNzaW5nICcgKyBkZXBOYW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0ID0gY2FsbGJhY2sgPyBjYWxsYmFjay5hcHBseShkZWZpbmVkW25hbWVdLCBhcmdzKSA6IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgIGlmIChuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAvL0lmIHNldHRpbmcgZXhwb3J0cyB2aWEgXCJtb2R1bGVcIiBpcyBpbiBwbGF5LFxyXG4gICAgICAgICAgICAgICAgLy9mYXZvciB0aGF0IG92ZXIgcmV0dXJuIHZhbHVlIGFuZCBleHBvcnRzLiBBZnRlciB0aGF0LFxyXG4gICAgICAgICAgICAgICAgLy9mYXZvciBhIG5vbi11bmRlZmluZWQgcmV0dXJuIHZhbHVlIG92ZXIgZXhwb3J0cyB1c2UuXHJcbiAgICAgICAgICAgICAgICBpZiAoY2pzTW9kdWxlICYmIGNqc01vZHVsZS5leHBvcnRzICE9PSB1bmRlZiAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjanNNb2R1bGUuZXhwb3J0cyAhPT0gZGVmaW5lZFtuYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmluZWRbbmFtZV0gPSBjanNNb2R1bGUuZXhwb3J0cztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmV0ICE9PSB1bmRlZiB8fCAhdXNpbmdFeHBvcnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9Vc2UgdGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBmdW5jdGlvbi5cclxuICAgICAgICAgICAgICAgICAgICBkZWZpbmVkW25hbWVdID0gcmV0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChuYW1lKSB7XHJcbiAgICAgICAgICAgIC8vTWF5IGp1c3QgYmUgYW4gb2JqZWN0IGRlZmluaXRpb24gZm9yIHRoZSBtb2R1bGUuIE9ubHlcclxuICAgICAgICAgICAgLy93b3JyeSBhYm91dCBkZWZpbmluZyBpZiBoYXZlIGEgbW9kdWxlIG5hbWUuXHJcbiAgICAgICAgICAgIGRlZmluZWRbbmFtZV0gPSBjYWxsYmFjaztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHJlcXVpcmVqcyA9IHJlcXVpcmUgPSByZXEgPSBmdW5jdGlvbiAoZGVwcywgY2FsbGJhY2ssIHJlbE5hbWUsIGZvcmNlU3luYywgYWx0KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBkZXBzID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIGlmIChoYW5kbGVyc1tkZXBzXSkge1xyXG4gICAgICAgICAgICAgICAgLy9jYWxsYmFjayBpbiB0aGlzIGNhc2UgaXMgcmVhbGx5IHJlbE5hbWVcclxuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyc1tkZXBzXShjYWxsYmFjayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9KdXN0IHJldHVybiB0aGUgbW9kdWxlIHdhbnRlZC4gSW4gdGhpcyBzY2VuYXJpbywgdGhlXHJcbiAgICAgICAgICAgIC8vZGVwcyBhcmcgaXMgdGhlIG1vZHVsZSBuYW1lLCBhbmQgc2Vjb25kIGFyZyAoaWYgcGFzc2VkKVxyXG4gICAgICAgICAgICAvL2lzIGp1c3QgdGhlIHJlbE5hbWUuXHJcbiAgICAgICAgICAgIC8vTm9ybWFsaXplIG1vZHVsZSBuYW1lLCBpZiBpdCBjb250YWlucyAuIG9yIC4uXHJcbiAgICAgICAgICAgIHJldHVybiBjYWxsRGVwKG1ha2VNYXAoZGVwcywgbWFrZVJlbFBhcnRzKGNhbGxiYWNrKSkuZik7XHJcbiAgICAgICAgfSBlbHNlIGlmICghZGVwcy5zcGxpY2UpIHtcclxuICAgICAgICAgICAgLy9kZXBzIGlzIGEgY29uZmlnIG9iamVjdCwgbm90IGFuIGFycmF5LlxyXG4gICAgICAgICAgICBjb25maWcgPSBkZXBzO1xyXG4gICAgICAgICAgICBpZiAoY29uZmlnLmRlcHMpIHtcclxuICAgICAgICAgICAgICAgIHJlcShjb25maWcuZGVwcywgY29uZmlnLmNhbGxiYWNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjYWxsYmFjay5zcGxpY2UpIHtcclxuICAgICAgICAgICAgICAgIC8vY2FsbGJhY2sgaXMgYW4gYXJyYXksIHdoaWNoIG1lYW5zIGl0IGlzIGEgZGVwZW5kZW5jeSBsaXN0LlxyXG4gICAgICAgICAgICAgICAgLy9BZGp1c3QgYXJncyBpZiB0aGVyZSBhcmUgZGVwZW5kZW5jaWVzXHJcbiAgICAgICAgICAgICAgICBkZXBzID0gY2FsbGJhY2s7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IHJlbE5hbWU7XHJcbiAgICAgICAgICAgICAgICByZWxOYW1lID0gbnVsbDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRlcHMgPSB1bmRlZjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9TdXBwb3J0IHJlcXVpcmUoWydhJ10pXHJcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcclxuXHJcbiAgICAgICAgLy9JZiByZWxOYW1lIGlzIGEgZnVuY3Rpb24sIGl0IGlzIGFuIGVycmJhY2sgaGFuZGxlcixcclxuICAgICAgICAvL3NvIHJlbW92ZSBpdC5cclxuICAgICAgICBpZiAodHlwZW9mIHJlbE5hbWUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgcmVsTmFtZSA9IGZvcmNlU3luYztcclxuICAgICAgICAgICAgZm9yY2VTeW5jID0gYWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9TaW11bGF0ZSBhc3luYyBjYWxsYmFjaztcclxuICAgICAgICBpZiAoZm9yY2VTeW5jKSB7XHJcbiAgICAgICAgICAgIG1haW4odW5kZWYsIGRlcHMsIGNhbGxiYWNrLCByZWxOYW1lKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvL1VzaW5nIGEgbm9uLXplcm8gdmFsdWUgYmVjYXVzZSBvZiBjb25jZXJuIGZvciB3aGF0IG9sZCBicm93c2Vyc1xyXG4gICAgICAgICAgICAvL2RvLCBhbmQgbGF0ZXN0IGJyb3dzZXJzIFwidXBncmFkZVwiIHRvIDQgaWYgbG93ZXIgdmFsdWUgaXMgdXNlZDpcclxuICAgICAgICAgICAgLy9odHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aW1lcnMuaHRtbCNkb20td2luZG93dGltZXJzLXNldHRpbWVvdXQ6XHJcbiAgICAgICAgICAgIC8vSWYgd2FudCBhIHZhbHVlIGltbWVkaWF0ZWx5LCB1c2UgcmVxdWlyZSgnaWQnKSBpbnN0ZWFkIC0tIHNvbWV0aGluZ1xyXG4gICAgICAgICAgICAvL3RoYXQgd29ya3MgaW4gYWxtb25kIG9uIHRoZSBnbG9iYWwgbGV2ZWwsIGJ1dCBub3QgZ3VhcmFudGVlZCBhbmRcclxuICAgICAgICAgICAgLy91bmxpa2VseSB0byB3b3JrIGluIG90aGVyIEFNRCBpbXBsZW1lbnRhdGlvbnMuXHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgbWFpbih1bmRlZiwgZGVwcywgY2FsbGJhY2ssIHJlbE5hbWUpO1xyXG4gICAgICAgICAgICB9LCA0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXE7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSnVzdCBkcm9wcyB0aGUgY29uZmlnIG9uIHRoZSBmbG9vciwgYnV0IHJldHVybnMgcmVxIGluIGNhc2VcclxuICAgICAqIHRoZSBjb25maWcgcmV0dXJuIHZhbHVlIGlzIHVzZWQuXHJcbiAgICAgKi9cclxuICAgIHJlcS5jb25maWcgPSBmdW5jdGlvbiAoY2ZnKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlcShjZmcpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEV4cG9zZSBtb2R1bGUgcmVnaXN0cnkgZm9yIGRlYnVnZ2luZyBhbmQgdG9vbGluZ1xyXG4gICAgICovXHJcbiAgICByZXF1aXJlanMuX2RlZmluZWQgPSBkZWZpbmVkO1xyXG5cclxuICAgIGRlZmluZSA9IGZ1bmN0aW9uIChuYW1lLCBkZXBzLCBjYWxsYmFjaykge1xyXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZWUgYWxtb25kIFJFQURNRTogaW5jb3JyZWN0IG1vZHVsZSBidWlsZCwgbm8gbW9kdWxlIG5hbWUnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vVGhpcyBtb2R1bGUgbWF5IG5vdCBoYXZlIGRlcGVuZGVuY2llc1xyXG4gICAgICAgIGlmICghZGVwcy5zcGxpY2UpIHtcclxuICAgICAgICAgICAgLy9kZXBzIGlzIG5vdCBhbiBhcnJheSwgc28gcHJvYmFibHkgbWVhbnNcclxuICAgICAgICAgICAgLy9hbiBvYmplY3QgbGl0ZXJhbCBvciBmYWN0b3J5IGZ1bmN0aW9uIGZvclxyXG4gICAgICAgICAgICAvL3RoZSB2YWx1ZS4gQWRqdXN0IGFyZ3MuXHJcbiAgICAgICAgICAgIGNhbGxiYWNrID0gZGVwcztcclxuICAgICAgICAgICAgZGVwcyA9IFtdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFoYXNQcm9wKGRlZmluZWQsIG5hbWUpICYmICFoYXNQcm9wKHdhaXRpbmcsIG5hbWUpKSB7XHJcbiAgICAgICAgICAgIHdhaXRpbmdbbmFtZV0gPSBbbmFtZSwgZGVwcywgY2FsbGJhY2tdO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgZGVmaW5lLmFtZCA9IHtcclxuICAgICAgICBqUXVlcnk6IHRydWVcclxuICAgIH07XHJcbn0oKSk7XHJcbi8qISBleGNhbGlidXIgLSB2MC4xNS4wIC0gMjAxOC0wMi0xN1xyXG4qIGh0dHBzOi8vZ2l0aHViLmNvbS9leGNhbGlidXJqcy9FeGNhbGlidXJcclxuKiBDb3B5cmlnaHQgKGMpIDIwMTggRXhjYWxpYnVyLmpzIDxodHRwczovL2dpdGh1Yi5jb20vZXhjYWxpYnVyanMvRXhjYWxpYnVyL2dyYXBocy9jb250cmlidXRvcnM+OyBMaWNlbnNlZCBCU0QtMi1DbGF1c2VcclxuKiBAcHJlc2VydmUgKi9cclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbmRlZmluZShcIkFjdGlvbnMvUm90YXRpb25UeXBlXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEFuIGVudW0gdGhhdCBkZXNjcmliZXMgdGhlIHN0cmF0ZWdpZXMgdGhhdCByb3RhdGlvbiBhY3Rpb25zIGNhbiB1c2VcclxuICAgICAqL1xyXG4gICAgdmFyIFJvdGF0aW9uVHlwZTtcclxuICAgIChmdW5jdGlvbiAoUm90YXRpb25UeXBlKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUm90YXRpb24gdmlhIGBTaG9ydGVzdFBhdGhgIHdpbGwgdXNlIHRoZSBzbWFsbGVzdCBhbmdsZVxyXG4gICAgICAgICAqIGJldHdlZW4gdGhlIHN0YXJ0aW5nIGFuZCBlbmRpbmcgcG9pbnRzLiBUaGlzIHN0cmF0ZWd5IGlzIHRoZSBkZWZhdWx0IGJlaGF2aW9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJvdGF0aW9uVHlwZVtSb3RhdGlvblR5cGVbXCJTaG9ydGVzdFBhdGhcIl0gPSAwXSA9IFwiU2hvcnRlc3RQYXRoXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUm90YXRpb24gdmlhIGBMb25nZXN0UGF0aGAgd2lsbCB1c2UgdGhlIGxhcmdlc3QgYW5nbGVcclxuICAgICAgICAgKiBiZXR3ZWVuIHRoZSBzdGFydGluZyBhbmQgZW5kaW5nIHBvaW50cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBSb3RhdGlvblR5cGVbUm90YXRpb25UeXBlW1wiTG9uZ2VzdFBhdGhcIl0gPSAxXSA9IFwiTG9uZ2VzdFBhdGhcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSb3RhdGlvbiB2aWEgYENsb2Nrd2lzZWAgd2lsbCB0cmF2ZWwgaW4gYSBjbG9ja3dpc2UgZGlyZWN0aW9uLFxyXG4gICAgICAgICAqIHJlZ2FyZGxlc3Mgb2YgdGhlIHN0YXJ0aW5nIGFuZCBlbmRpbmcgcG9pbnRzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJvdGF0aW9uVHlwZVtSb3RhdGlvblR5cGVbXCJDbG9ja3dpc2VcIl0gPSAyXSA9IFwiQ2xvY2t3aXNlXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUm90YXRpb24gdmlhIGBDb3VudGVyQ2xvY2t3aXNlYCB3aWxsIHRyYXZlbCBpbiBhIGNvdW50ZXJjbG9ja3dpc2UgZGlyZWN0aW9uLFxyXG4gICAgICAgICAqIHJlZ2FyZGxlc3Mgb2YgdGhlIHN0YXJ0aW5nIGFuZCBlbmRpbmcgcG9pbnRzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJvdGF0aW9uVHlwZVtSb3RhdGlvblR5cGVbXCJDb3VudGVyQ2xvY2t3aXNlXCJdID0gM10gPSBcIkNvdW50ZXJDbG9ja3dpc2VcIjtcclxuICAgIH0pKFJvdGF0aW9uVHlwZSA9IGV4cG9ydHMuUm90YXRpb25UeXBlIHx8IChleHBvcnRzLlJvdGF0aW9uVHlwZSA9IHt9KSk7XHJcbn0pO1xyXG5kZWZpbmUoXCJBbGdlYnJhXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEEgMkQgdmVjdG9yIG9uIGEgcGxhbmUuXHJcbiAgICAgKi9cclxuICAgIHZhciBWZWN0b3IgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB4ICBYIGNvbXBvbmVudCBvZiB0aGUgVmVjdG9yXHJcbiAgICAgICAgICogQHBhcmFtIHkgIFkgY29tcG9uZW50IG9mIHRoZSBWZWN0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBWZWN0b3IoeCwgeSkge1xyXG4gICAgICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgdmVjdG9yIG9mIHVuaXQgbGVuZ3RoIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHNwZWNpZmllZCBhbmdsZSBpbiBSYWRpYW5zLlxyXG4gICAgICAgICAqIEBwYXJhbSBhbmdsZSBUaGUgYW5nbGUgdG8gZ2VuZXJhdGUgdGhlIHZlY3RvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFZlY3Rvci5mcm9tQW5nbGUgPSBmdW5jdGlvbiAoYW5nbGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoTWF0aC5jb3MoYW5nbGUpLCBNYXRoLnNpbihhbmdsZSkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hlY2tzIGlmIHZlY3RvciBpcyBub3QgbnVsbCwgdW5kZWZpbmVkLCBvciBpZiBhbnkgb2YgaXRzIGNvbXBvbmVudHMgYXJlIE5hTiBvciBJbmZpbml0eS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBWZWN0b3IuaXNWYWxpZCA9IGZ1bmN0aW9uICh2ZWMpIHtcclxuICAgICAgICAgICAgaWYgKHZlYyA9PT0gbnVsbCB8fCB2ZWMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc05hTih2ZWMueCkgfHwgaXNOYU4odmVjLnkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZlYy54ID09PSBJbmZpbml0eSB8fFxyXG4gICAgICAgICAgICAgICAgdmVjLnkgPT09IEluZmluaXR5IHx8XHJcbiAgICAgICAgICAgICAgICB2ZWMueCA9PT0gLUluZmluaXR5IHx8XHJcbiAgICAgICAgICAgICAgICB2ZWMueSA9PT0gSW5maW5pdHkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGN1bGF0ZXMgZGlzdGFuY2UgYmV0d2VlbiB0d28gVmVjdG9yc1xyXG4gICAgICAgICAqIEBwYXJhbSB2ZWMxXHJcbiAgICAgICAgICogQHBhcmFtIHZlYzJcclxuICAgICAgICAgKi9cclxuICAgICAgICBWZWN0b3IuZGlzdGFuY2UgPSBmdW5jdGlvbiAodmVjMSwgdmVjMikge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHZlYzEueCAtIHZlYzIueCwgMikgKyBNYXRoLnBvdyh2ZWMxLnkgLSB2ZWMyLnksIDIpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIHggYW5kIHkgY29tcG9uZW50cyBhdCBvbmNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS5zZXRUbyA9IGZ1bmN0aW9uICh4LCB5KSB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb21wYXJlcyB0aGlzIHBvaW50IGFnYWluc3QgYW5vdGhlciBhbmQgdGVzdHMgZm9yIGVxdWFsaXR5XHJcbiAgICAgICAgICogQHBhcmFtIHBvaW50ICBUaGUgb3RoZXIgcG9pbnQgdG8gY29tcGFyZSB0b1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKHZlY3RvciwgdG9sZXJhbmNlKSB7XHJcbiAgICAgICAgICAgIGlmICh0b2xlcmFuY2UgPT09IHZvaWQgMCkgeyB0b2xlcmFuY2UgPSAuMDAxOyB9XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnggLSB2ZWN0b3IueCkgPD0gdG9sZXJhbmNlICYmIE1hdGguYWJzKHRoaXMueSAtIHZlY3Rvci55KSA8PSB0b2xlcmFuY2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZGlzdGFuY2UgdG8gYW5vdGhlciB2ZWN0b3IuIElmIG5vIG90aGVyIFZlY3RvciBpcyBzcGVjaWZpZWQsIHRoaXMgd2lsbCByZXR1cm4gdGhlIFtbbWFnbml0dWRlXV0uXHJcbiAgICAgICAgICogQHBhcmFtIHYgIFRoZSBvdGhlciB2ZWN0b3IuIExlYXZlIGJsYW5rIHRvIHVzZSBvcmlnaW4gdmVjdG9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUuZGlzdGFuY2UgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICBpZiAoIXYpIHtcclxuICAgICAgICAgICAgICAgIHYgPSBWZWN0b3IuWmVybztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMueCAtIHYueCwgMikgKyBNYXRoLnBvdyh0aGlzLnkgLSB2LnksIDIpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBtYWduaXR1ZGUgKHNpemUpIG9mIHRoZSBWZWN0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBWZWN0b3IucHJvdG90eXBlLm1hZ25pdHVkZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlzdGFuY2UoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE5vcm1hbGl6ZXMgYSB2ZWN0b3IgdG8gaGF2ZSBhIG1hZ25pdHVkZSBvZiAxLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZCA9IHRoaXMuZGlzdGFuY2UoKTtcclxuICAgICAgICAgICAgaWYgKGQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLnggLyBkLCB0aGlzLnkgLyBkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKDAsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBhdmVyYWdlIChtaWRwb2ludCkgYmV0d2VlbiB0aGUgY3VycmVudCBwb2ludCBhbmQgdGhlIHNwZWNpZmllZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUuYXZlcmFnZSA9IGZ1bmN0aW9uICh2ZWMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKHZlYykuc2NhbGUoLjUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2NhbGVzIGEgdmVjdG9yJ3MgYnkgYSBmYWN0b3Igb2Ygc2l6ZVxyXG4gICAgICAgICAqIEBwYXJhbSBzaXplICBUaGUgZmFjdG9yIHRvIHNjYWxlIHRoZSBtYWduaXR1ZGUgYnlcclxuICAgICAgICAgKi9cclxuICAgICAgICBWZWN0b3IucHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24gKHNpemUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy54ICogc2l6ZSwgdGhpcy55ICogc2l6ZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIG9uZSB2ZWN0b3IgdG8gYW5vdGhlclxyXG4gICAgICAgICAqIEBwYXJhbSB2IFRoZSB2ZWN0b3IgdG8gYWRkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLnggKyB2LngsIHRoaXMueSArIHYueSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTdWJ0cmFjdHMgYSB2ZWN0b3IgZnJvbSBhbm90aGVyLCBpZiB5b3Ugc3VicmFjdCB2ZWN0b3IgYEIuc3ViKEEpYCB0aGUgcmVzdWx0aW5nIHZlY3RvciBwb2ludHMgZnJvbSBBIC0+IEJcclxuICAgICAgICAgKiBAcGFyYW0gdiBUaGUgdmVjdG9yIHRvIHN1YnRyYWN0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLnggLSB2LngsIHRoaXMueSAtIHYueSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIG9uZSB2ZWN0b3IgdG8gdGhpcyBvbmUgbW9kaWZ5aW5nIHRoZSBvcmlnaW5hbFxyXG4gICAgICAgICAqIEBwYXJhbSB2IFRoZSB2ZWN0b3IgdG8gYWRkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS5hZGRFcXVhbCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIHRoaXMueCArPSB2Lng7XHJcbiAgICAgICAgICAgIHRoaXMueSArPSB2Lnk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3VidHJhY3RzIGEgdmVjdG9yIGZyb20gdGhpcyBvbmUgbW9kaWZ5aW5nIHRoZSBvcmlnaW5hbFxyXG4gICAgICAgICAqIEBwYXJhbGxlbCB2IFRoZSB2ZWN0b3IgdG8gc3VidHJhY3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBWZWN0b3IucHJvdG90eXBlLnN1YkVxdWFsID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgdGhpcy54IC09IHYueDtcclxuICAgICAgICAgICAgdGhpcy55IC09IHYueTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTY2FsZXMgdGhpcyB2ZWN0b3IgYnkgYSBmYWN0b3Igb2Ygc2l6ZSBhbmQgbW9kaWZpZXMgdGhlIG9yaWdpbmFsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS5zY2FsZUVxdWFsID0gZnVuY3Rpb24gKHNpemUpIHtcclxuICAgICAgICAgICAgdGhpcy54ICo9IHNpemU7XHJcbiAgICAgICAgICAgIHRoaXMueSAqPSBzaXplO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBlcmZvcm1zIGEgZG90IHByb2R1Y3Qgd2l0aCBhbm90aGVyIHZlY3RvclxyXG4gICAgICAgICAqIEBwYXJhbSB2ICBUaGUgdmVjdG9yIHRvIGRvdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUuZG90ID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUuY3Jvc3MgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICBpZiAodiBpbnN0YW5jZW9mIFZlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueCAqIHYueSAtIHRoaXMueSAqIHYueDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHYgKiB0aGlzLnksIC12ICogdGhpcy54KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgcGVycGVuZGljdWxhciB2ZWN0b3IgdG8gdGhpcyBvbmVcclxuICAgICAgICAgKi9cclxuICAgICAgICBWZWN0b3IucHJvdG90eXBlLnBlcnBlbmRpY3VsYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMueSwgLXRoaXMueCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBub3JtYWwgdmVjdG9yIHRvIHRoaXMgb25lLCBzYW1lIGFzIHRoZSBwZXJwZW5kaWN1bGFyIG9mIGxlbmd0aCAxXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS5ub3JtYWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBlcnBlbmRpY3VsYXIoKS5ub3JtYWxpemUoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE5lZ2F0ZSB0aGUgY3VycmVudCB2ZWN0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBWZWN0b3IucHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGUoLTEpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgYW5nbGUgb2YgdGhpcyB2ZWN0b3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS50b0FuZ2xlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hdGFuMih0aGlzLnksIHRoaXMueCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSb3RhdGVzIHRoZSBjdXJyZW50IHZlY3RvciBhcm91bmQgYSBwb2ludCBieSBhIGNlcnRhaW4gbnVtYmVyIG9mXHJcbiAgICAgICAgICogZGVncmVlcyBpbiByYWRpYW5zXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS5yb3RhdGUgPSBmdW5jdGlvbiAoYW5nbGUsIGFuY2hvcikge1xyXG4gICAgICAgICAgICBpZiAoIWFuY2hvcikge1xyXG4gICAgICAgICAgICAgICAgYW5jaG9yID0gbmV3IFZlY3RvcigwLCAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc2luQW5nbGUgPSBNYXRoLnNpbihhbmdsZSk7XHJcbiAgICAgICAgICAgIHZhciBjb3NBbmdsZSA9IE1hdGguY29zKGFuZ2xlKTtcclxuICAgICAgICAgICAgdmFyIHggPSBjb3NBbmdsZSAqICh0aGlzLnggLSBhbmNob3IueCkgLSBzaW5BbmdsZSAqICh0aGlzLnkgLSBhbmNob3IueSkgKyBhbmNob3IueDtcclxuICAgICAgICAgICAgdmFyIHkgPSBzaW5BbmdsZSAqICh0aGlzLnggLSBhbmNob3IueCkgKyBjb3NBbmdsZSAqICh0aGlzLnkgLSBhbmNob3IueSkgKyBhbmNob3IueTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoeCwgeSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIG5ldyB2ZWN0b3IgdGhhdCBoYXMgdGhlIHNhbWUgdmFsdWVzIGFzIHRoZSBwcmV2aW91cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBWZWN0b3IucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLngsIHRoaXMueSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcGVzZW50YXRpb24gb2YgdGhlIHZlY3Rvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBWZWN0b3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCIoXCIgKyB0aGlzLnggKyBcIiwgXCIgKyB0aGlzLnkgKyBcIilcIjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBWZWN0b3I7XHJcbiAgICB9KCkpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBICgwLCAwKSB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgVmVjdG9yLlplcm8gPSBuZXcgVmVjdG9yKDAsIDApO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBICgxLCAxKSB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgVmVjdG9yLk9uZSA9IG5ldyBWZWN0b3IoMSwgMSk7XHJcbiAgICAvKipcclxuICAgICAqIEEgKDAuNSwgMC41KSB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgVmVjdG9yLkhhbGYgPSBuZXcgVmVjdG9yKDAuNSwgMC41KTtcclxuICAgIC8qKlxyXG4gICAgICogQSB1bml0IHZlY3RvciBwb2ludGluZyB1cCAoMCwgLTEpXHJcbiAgICAgKi9cclxuICAgIFZlY3Rvci5VcCA9IG5ldyBWZWN0b3IoMCwgLTEpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIHVuaXQgdmVjdG9yIHBvaW50aW5nIGRvd24gKDAsIDEpXHJcbiAgICAgKi9cclxuICAgIFZlY3Rvci5Eb3duID0gbmV3IFZlY3RvcigwLCAxKTtcclxuICAgIC8qKlxyXG4gICAgICogQSB1bml0IHZlY3RvciBwb2ludGluZyBsZWZ0ICgtMSwgMClcclxuICAgICAqL1xyXG4gICAgVmVjdG9yLkxlZnQgPSBuZXcgVmVjdG9yKC0xLCAwKTtcclxuICAgIC8qKlxyXG4gICAgICogQSB1bml0IHZlY3RvciBwb2ludGluZyByaWdodCAoMSwgMClcclxuICAgICAqL1xyXG4gICAgVmVjdG9yLlJpZ2h0ID0gbmV3IFZlY3RvcigxLCAwKTtcclxuICAgIGV4cG9ydHMuVmVjdG9yID0gVmVjdG9yO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIDJEIHJheSB0aGF0IGNhbiBiZSBjYXN0IGludG8gdGhlIHNjZW5lIHRvIGRvIGNvbGxpc2lvbiBkZXRlY3Rpb25cclxuICAgICAqL1xyXG4gICAgdmFyIFJheSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHBvcyBUaGUgc3RhcnRpbmcgcG9zaXRpb24gZm9yIHRoZSByYXlcclxuICAgICAgICAgKiBAcGFyYW0gZGlyIFRoZSB2ZWN0b3IgaW5kaWNhdGluZyB0aGUgZGlyZWN0aW9uIG9mIHRoZSByYXlcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBSYXkocG9zLCBkaXIpIHtcclxuICAgICAgICAgICAgdGhpcy5wb3MgPSBwb3M7XHJcbiAgICAgICAgICAgIHRoaXMuZGlyID0gZGlyLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZXN0cyBhIHdoZXRoZXIgdGhpcyByYXkgaW50ZXJzZWN0cyB3aXRoIGEgbGluZSBzZWdtZW50LiBSZXR1cm5zIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwIG9uIHN1Y2Nlc3MuXHJcbiAgICAgICAgICogVGhpcyBudW1iZXIgaW5kaWNhdGVzIHRoZSBtYXRoZW1hdGljYWwgaW50ZXJzZWN0aW9uIHRpbWUuXHJcbiAgICAgICAgICogQHBhcmFtIGxpbmUgIFRoZSBsaW5lIHRvIHRlc3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBSYXkucHJvdG90eXBlLmludGVyc2VjdCA9IGZ1bmN0aW9uIChsaW5lKSB7XHJcbiAgICAgICAgICAgIHZhciBudW1lcmF0b3IgPSBsaW5lLmJlZ2luLnN1Yih0aGlzLnBvcyk7XHJcbiAgICAgICAgICAgIC8vIFRlc3QgaXMgbGluZSBhbmQgcmF5IGFyZSBwYXJhbGxlbCBhbmQgbm9uIGludGVyc2VjdGluZ1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kaXIuY3Jvc3MobGluZS5nZXRTbG9wZSgpKSA9PT0gMCAmJiBudW1lcmF0b3IuY3Jvc3ModGhpcy5kaXIpICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gTGluZXMgYXJlIHBhcmFsbGVsXHJcbiAgICAgICAgICAgIHZhciBkaXZpc29yID0gKHRoaXMuZGlyLmNyb3NzKGxpbmUuZ2V0U2xvcGUoKSkpO1xyXG4gICAgICAgICAgICBpZiAoZGl2aXNvciA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB0ID0gbnVtZXJhdG9yLmNyb3NzKGxpbmUuZ2V0U2xvcGUoKSkgLyBkaXZpc29yO1xyXG4gICAgICAgICAgICBpZiAodCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdSA9IChudW1lcmF0b3IuY3Jvc3ModGhpcy5kaXIpIC8gZGl2aXNvcikgLyBsaW5lLmdldExlbmd0aCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHUgPj0gMCAmJiB1IDw9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBwb2ludCBvZiBpbnRlcnNlY3Rpb24gZ2l2ZW4gdGhlIGludGVyc2VjdGlvbiB0aW1lXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmF5LnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICh0aW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvcy5hZGQodGhpcy5kaXIuc2NhbGUodGltZSkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFJheTtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLlJheSA9IFJheTtcclxuICAgIC8qKlxyXG4gICAgICogQSAyRCBsaW5lIHNlZ21lbnRcclxuICAgICAqL1xyXG4gICAgdmFyIExpbmUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBiZWdpbiAgVGhlIHN0YXJ0aW5nIHBvaW50IG9mIHRoZSBsaW5lIHNlZ21lbnRcclxuICAgICAgICAgKiBAcGFyYW0gZW5kICBUaGUgZW5kaW5nIHBvaW50IG9mIHRoZSBsaW5lIHNlZ21lbnRcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBMaW5lKGJlZ2luLCBlbmQpIHtcclxuICAgICAgICAgICAgdGhpcy5iZWdpbiA9IGJlZ2luO1xyXG4gICAgICAgICAgICB0aGlzLmVuZCA9IGVuZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExpbmUucHJvdG90eXBlLCBcInNsb3BlXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIHJhdyBzbG9wZSAobSkgb2YgdGhlIGxpbmUuIFdpbGwgcmV0dXJuICgrLy0pSW5maW5pdHkgZm9yIHZlcnRpY2FsIGxpbmVzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuZW5kLnkgLSB0aGlzLmJlZ2luLnkpIC8gKHRoaXMuZW5kLnggLSB0aGlzLmJlZ2luLngpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGluZS5wcm90b3R5cGUsIFwiaW50ZXJjZXB0XCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIFktaW50ZXJjZXB0IChiKSBvZiB0aGUgbGluZS4gV2lsbCByZXR1cm4gKCsvLSlJbmZpbml0eSBpZiB0aGVyZSBpcyBubyBpbnRlcmNlcHQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJlZ2luLnkgLSAodGhpcy5zbG9wZSAqIHRoaXMuYmVnaW4ueCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIG5vcm1hbCBvZiB0aGUgbGluZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpbmUucHJvdG90eXBlLm5vcm1hbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5kLnN1Yih0aGlzLmJlZ2luKS5ub3JtYWwoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIHNsb3BlIG9mIHRoZSBsaW5lIGluIHRoZSBmb3JtIG9mIGEgdmVjdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGluZS5wcm90b3R5cGUuZ2V0U2xvcGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBiZWdpbiA9IHRoaXMuYmVnaW47XHJcbiAgICAgICAgICAgIHZhciBlbmQgPSB0aGlzLmVuZDtcclxuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gYmVnaW4uZGlzdGFuY2UoZW5kKTtcclxuICAgICAgICAgICAgcmV0dXJuIGVuZC5zdWIoYmVnaW4pLnNjYWxlKDEgLyBkaXN0YW5jZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIGxpbmUgc2VnbWVudCBpbiBwaXhlbHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBMaW5lLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBiZWdpbiA9IHRoaXMuYmVnaW47XHJcbiAgICAgICAgICAgIHZhciBlbmQgPSB0aGlzLmVuZDtcclxuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gYmVnaW4uZGlzdGFuY2UoZW5kKTtcclxuICAgICAgICAgICAgcmV0dXJuIGRpc3RhbmNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmluZCB0aGUgcGVycGVuZGljdWxhciBkaXN0YW5jZSBmcm9tIHRoZSBsaW5lIHRvIGEgcG9pbnRcclxuICAgICAgICAgKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EaXN0YW5jZV9mcm9tX2FfcG9pbnRfdG9fYV9saW5lXHJcbiAgICAgICAgICogQHBhcmFtIHBvaW50XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGluZS5wcm90b3R5cGUuZGlzdGFuY2VUb1BvaW50ID0gZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgICAgICAgICAgIHZhciB4MCA9IHBvaW50Lng7XHJcbiAgICAgICAgICAgIHZhciB5MCA9IHBvaW50Lnk7XHJcbiAgICAgICAgICAgIHZhciBsID0gdGhpcy5nZXRMZW5ndGgoKTtcclxuICAgICAgICAgICAgdmFyIGR5ID0gdGhpcy5lbmQueSAtIHRoaXMuYmVnaW4ueTtcclxuICAgICAgICAgICAgdmFyIGR4ID0gdGhpcy5lbmQueCAtIHRoaXMuYmVnaW4ueDtcclxuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gTWF0aC5hYnMoZHkgKiB4MCAtIGR4ICogeTAgKyB0aGlzLmVuZC54ICogdGhpcy5iZWdpbi55IC0gdGhpcy5lbmQueSAqIHRoaXMuYmVnaW4ueCkgLyBsO1xyXG4gICAgICAgICAgICByZXR1cm4gZGlzdGFuY2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGaW5kcyBhIHBvaW50IG9uIHRoZSBsaW5lIGdpdmVuIG9ubHkgYW4gWCBvciBhIFkgdmFsdWUuIEdpdmVuIGFuIFggdmFsdWUsIHRoZSBmdW5jdGlvbiByZXR1cm5zXHJcbiAgICAgICAgICogYSBuZXcgcG9pbnQgd2l0aCB0aGUgY2FsY3VsYXRlZCBZIHZhbHVlIGFuZCB2aWNlLXZlcnNhLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHggVGhlIGtub3duIFggdmFsdWUgb2YgdGhlIHRhcmdldCBwb2ludFxyXG4gICAgICAgICAqIEBwYXJhbSB5IFRoZSBrbm93biBZIHZhbHVlIG9mIHRoZSB0YXJnZXQgcG9pbnRcclxuICAgICAgICAgKiBAcmV0dXJucyBBIG5ldyBwb2ludCB3aXRoIHRoZSBvdGhlciBjYWxjdWxhdGVkIGF4aXMgdmFsdWVcclxuICAgICAgICAgKi9cclxuICAgICAgICBMaW5lLnByb3RvdHlwZS5maW5kUG9pbnQgPSBmdW5jdGlvbiAoeCwgeSkge1xyXG4gICAgICAgICAgICBpZiAoeCA9PT0gdm9pZCAwKSB7IHggPSBudWxsOyB9XHJcbiAgICAgICAgICAgIGlmICh5ID09PSB2b2lkIDApIHsgeSA9IG51bGw7IH1cclxuICAgICAgICAgICAgdmFyIG0gPSB0aGlzLnNsb3BlO1xyXG4gICAgICAgICAgICB2YXIgYiA9IHRoaXMuaW50ZXJjZXB0O1xyXG4gICAgICAgICAgICBpZiAoeCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoeCwgKG0gKiB4KSArIGIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKCh5IC0gYikgLyBtLCB5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgcHJvdmlkZSBhbiBYIG9yIGEgWSB2YWx1ZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAc2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzExOTA4MTU4LzEwOTQ1OFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpbmUucHJvdG90eXBlLmhhc1BvaW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgY3VyclBvaW50O1xyXG4gICAgICAgICAgICB2YXIgdGhyZXNob2xkID0gMDtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInICYmXHJcbiAgICAgICAgICAgICAgICB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgY3VyclBvaW50ID0gbmV3IFZlY3Rvcihhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSk7XHJcbiAgICAgICAgICAgICAgICB0aHJlc2hvbGQgPSBhcmd1bWVudHNbMl0gfHwgMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBWZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJQb2ludCA9IGFyZ3VtZW50c1swXTtcclxuICAgICAgICAgICAgICAgIHRocmVzaG9sZCA9IGFyZ3VtZW50c1sxXSB8fCAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgJ0NvdWxkIG5vdCBkZXRlcm1pbmUgdGhlIGFyZ3VtZW50cyBmb3IgVmVjdG9yLmhhc1BvaW50JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZHhjID0gY3VyclBvaW50LnggLSB0aGlzLmJlZ2luLng7XHJcbiAgICAgICAgICAgIHZhciBkeWMgPSBjdXJyUG9pbnQueSAtIHRoaXMuYmVnaW4ueTtcclxuICAgICAgICAgICAgdmFyIGR4MSA9IHRoaXMuZW5kLnggLSB0aGlzLmJlZ2luLng7XHJcbiAgICAgICAgICAgIHZhciBkeTEgPSB0aGlzLmVuZC55IC0gdGhpcy5iZWdpbi55O1xyXG4gICAgICAgICAgICB2YXIgY3Jvc3MgPSBkeGMgKiBkeTEgLSBkeWMgKiBkeDE7XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIHdoZXRoZXIgcG9pbnQgbGluZXMgb24gdGhlIGxpbmVcclxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGNyb3NzKSA+IHRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIHdoZXRoZXIgcG9pbnQgbGllcyBpbi1iZXR3ZWVuIHN0YXJ0IGFuZCBlbmRcclxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGR4MSkgPj0gTWF0aC5hYnMoZHkxKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGR4MSA+IDBcclxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMuYmVnaW4ueCA8PSBjdXJyUG9pbnQueCAmJiBjdXJyUG9pbnQueCA8PSB0aGlzLmVuZC54XHJcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmVuZC54IDw9IGN1cnJQb2ludC54ICYmIGN1cnJQb2ludC54IDw9IHRoaXMuYmVnaW4ueDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkeTEgPiAwXHJcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmJlZ2luLnkgPD0gY3VyclBvaW50LnkgJiYgY3VyclBvaW50LnkgPD0gdGhpcy5lbmQueVxyXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5lbmQueSA8PSBjdXJyUG9pbnQueSAmJiBjdXJyUG9pbnQueSA8PSB0aGlzLmJlZ2luLnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBMaW5lO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuTGluZSA9IExpbmU7XHJcbiAgICAvKipcclxuICAgICAqIEEgMSBkaW1lbnNpb25hbCBwcm9qZWN0aW9uIG9uIGFuIGF4aXMsIHVzZWQgdG8gdGVzdCBvdmVybGFwc1xyXG4gICAgICovXHJcbiAgICB2YXIgUHJvamVjdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gUHJvamVjdGlvbihtaW4sIG1heCkge1xyXG4gICAgICAgICAgICB0aGlzLm1pbiA9IG1pbjtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSBtYXg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFByb2plY3Rpb24ucHJvdG90eXBlLm92ZXJsYXBzID0gZnVuY3Rpb24gKHByb2plY3Rpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF4ID4gcHJvamVjdGlvbi5taW4gJiYgcHJvamVjdGlvbi5tYXggPiB0aGlzLm1pbjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFByb2plY3Rpb24ucHJvdG90eXBlLmdldE92ZXJsYXAgPSBmdW5jdGlvbiAocHJvamVjdGlvbikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vdmVybGFwcyhwcm9qZWN0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWF4ID4gcHJvamVjdGlvbi5tYXgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvamVjdGlvbi5tYXggLSB0aGlzLm1pbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1heCAtIHByb2plY3Rpb24ubWluO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFByb2plY3Rpb247XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5Qcm9qZWN0aW9uID0gUHJvamVjdGlvbjtcclxufSk7XHJcbmRlZmluZShcIlBoeXNpY3NcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJBbGdlYnJhXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgQWxnZWJyYV8xKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogUG9zc2libGUgY29sbGlzaW9uIHJlc29sdXRpb24gc3RyYXRlZ2llc1xyXG4gICAgICpcclxuICAgICAqIFRoZSBkZWZhdWx0IGlzIFtbQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5LkJveF1dIHdoaWNoIHBlcmZvcm1zIHNpbXBsZSBheGlzIGFsaWduZWQgYXJjYWRlIHN0eWxlIHBoeXNpY3MuXHJcbiAgICAgKlxyXG4gICAgICogTW9yZSBhZHZhbmNlZCByaWdpZCBib2R5IHBoeXNpY3MgYXJlIGVuYWJsZWQgYnkgc2V0dGluZyBbW0NvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneS5SaWdpZEJvZHldXSB3aGljaCBhbGxvd3MgZm9yIGNvbXBsaWNhdGVkXHJcbiAgICAgKiBzaW11bGF0ZWQgcGh5c2ljYWwgaW50ZXJhY3Rpb25zLlxyXG4gICAgICovXHJcbiAgICB2YXIgQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5O1xyXG4gICAgKGZ1bmN0aW9uIChDb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kpIHtcclxuICAgICAgICBDb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3lbQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5W1wiQm94XCJdID0gMF0gPSBcIkJveFwiO1xyXG4gICAgICAgIENvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneVtDb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3lbXCJSaWdpZEJvZHlcIl0gPSAxXSA9IFwiUmlnaWRCb2R5XCI7XHJcbiAgICB9KShDb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kgPSBleHBvcnRzLkNvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneSB8fCAoZXhwb3J0cy5Db2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kgPSB7fSkpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQb3NzaWJsZSBicm9hZHBoYXNlIGNvbGxpc2lvbiBwYWlyIGlkZW50aWZpY2F0aW9uIHN0cmF0ZWdpZXNcclxuICAgICAqXHJcbiAgICAgKiBUaGUgZGVmYXVsdCBzdHJhdGVneSBpcyBbW0Jyb2FkcGhhc2VTdHJhdGVneS5EeW5hbWljQUFCQlRyZWVdXSB3aGljaCB1c2VzIGEgYmluYXJ5IHRyZWUgb2YgYXhpcy1hbGlnbmVkIGJvdW5kaW5nIGJveGVzIHRvIGlkZW50aWZ5XHJcbiAgICAgKiBwb3RlbnRpYWwgY29sbGlzaW9uIHBhaXJzIHdoaWNoIGlzIE8obmxvZyhuKSkgZmFzdGVyLiBUaGUgb3RoZXIgcG9zc2libGUgc3RyYXRlZ3kgaXMgdGhlIFtbQnJvYWRwaGFzZVN0cmF0ZWd5Lk5haXZlXV0gc3RyYXRlZ3lcclxuICAgICAqIHdoaWNoIGxvb3BzIG92ZXIgZXZlcnkgb2JqZWN0IGZvciBldmVyeSBvYmplY3QgaW4gdGhlIHNjZW5lIHRvIGlkZW50aWZ5IGNvbGxpc2lvbiBwYWlycyB3aGljaCBpcyBPKG5eMikgc2xvd2VyLlxyXG4gICAgICovXHJcbiAgICB2YXIgQnJvYWRwaGFzZVN0cmF0ZWd5O1xyXG4gICAgKGZ1bmN0aW9uIChCcm9hZHBoYXNlU3RyYXRlZ3kpIHtcclxuICAgICAgICBCcm9hZHBoYXNlU3RyYXRlZ3lbQnJvYWRwaGFzZVN0cmF0ZWd5W1wiTmFpdmVcIl0gPSAwXSA9IFwiTmFpdmVcIjtcclxuICAgICAgICBCcm9hZHBoYXNlU3RyYXRlZ3lbQnJvYWRwaGFzZVN0cmF0ZWd5W1wiRHluYW1pY0FBQkJUcmVlXCJdID0gMV0gPSBcIkR5bmFtaWNBQUJCVHJlZVwiO1xyXG4gICAgfSkoQnJvYWRwaGFzZVN0cmF0ZWd5ID0gZXhwb3J0cy5Ccm9hZHBoYXNlU3RyYXRlZ3kgfHwgKGV4cG9ydHMuQnJvYWRwaGFzZVN0cmF0ZWd5ID0ge30pKTtcclxuICAgIC8qKlxyXG4gICAgICogUG9zc2libGUgbnVtZXJpY2FsIGludGVncmF0b3JzIGZvciBwb3NpdGlvbiBhbmQgdmVsb2NpdHlcclxuICAgICAqL1xyXG4gICAgdmFyIEludGVncmF0b3I7XHJcbiAgICAoZnVuY3Rpb24gKEludGVncmF0b3IpIHtcclxuICAgICAgICBJbnRlZ3JhdG9yW0ludGVncmF0b3JbXCJFdWxlclwiXSA9IDBdID0gXCJFdWxlclwiO1xyXG4gICAgfSkoSW50ZWdyYXRvciA9IGV4cG9ydHMuSW50ZWdyYXRvciB8fCAoZXhwb3J0cy5JbnRlZ3JhdG9yID0ge30pKTtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIFtbUGh5c2ljc11dIG9iamVjdCBpcyB0aGUgZ2xvYmFsIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBhbGwgRXhjYWxpYnVyIHBoeXNpY3MuXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOlBoeXNpY3MubWRdXVxyXG4gICAgICovXHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgdmFyIFBoeXNpY3MgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIFBoeXNpY3MoKSB7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbmZpZ3VyZXMgRXhjYWxpYnVyIHRvIHVzZSBib3ggcGh5c2ljcy4gQm94IHBoeXNpY3Mgd2hpY2ggcGVyZm9ybXMgc2ltcGxlIGF4aXMgYWxpZ25lZCBhcmNhZGUgc3R5bGUgcGh5c2ljcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQaHlzaWNzLnVzZUJveFBoeXNpY3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIFBoeXNpY3MuY29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5ID0gQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5LkJveDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbmZpZ3VyZXMgRXhjYWxpYnVyIHRvIHVzZSByaWdpZCBib2R5IHBoeXNpY3MuIFJpZ2lkIGJvZHkgcGh5c2ljcyBhbGxvd3MgZm9yIGNvbXBsaWNhdGVkXHJcbiAgICAgICAgICogc2ltdWxhdGVkIHBoeXNpY2FsIGludGVyYWN0aW9ucy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQaHlzaWNzLnVzZVJpZ2lkQm9keVBoeXNpY3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIFBoeXNpY3MuY29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5ID0gQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5LlJpZ2lkQm9keTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBQaHlzaWNzO1xyXG4gICAgfSgpKTtcclxuICAgIC8qKlxyXG4gICAgICogR2xvYmFsIGFjY2VsZXJhdGlvbiB0aGF0IGlzIGFwcGxpZWQgdG8gYWxsIHZhbmlsbGEgYWN0b3JzIChpdCB3b250IGVmZmVjdCBbW0xhYmVsfGxhYmVsc11dLCBbW1VJQWN0b3J8dWkgYWN0b3JzXV0sIG9yXHJcbiAgICAgKiBbW1RyaWdnZXJ8dHJpZ2dlcnNdXSBpbiBFeGNhbGlidXIgdGhhdCBoYXZlIGFuIFtbQ29sbGlzaW9uVHlwZS5BY3RpdmV8YWN0aXZlXV0gY29sbGlzaW9uIHR5cGUpLlxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBUaGlzIGlzIGEgZ3JlYXQgd2F5IHRvIGdsb2JhbGx5IHNpbXVsYXRlIGVmZmVjdHMgbGlrZSBncmF2aXR5LlxyXG4gICAgICovXHJcbiAgICBQaHlzaWNzLmFjYyA9IG5ldyBBbGdlYnJhXzEuVmVjdG9yKDAsIDApO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHbG9iYWxseSBzd2l0Y2hlcyBhbGwgRXhjYWxpYnVyIHBoeXNpY3MgYmVoYXZpb3Igb24gb3Igb2ZmLlxyXG4gICAgICovXHJcbiAgICBQaHlzaWNzLmVuYWJsZWQgPSB0cnVlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG51bWJlciBvZiBjb2xsaXNpb24gcGFzc2VzIGZvciBFeGNhbGlidXIgdG8gcGVyZm9ybSBvbiBwaHlzaWNzIGJvZGllcy5cclxuICAgICAqXHJcbiAgICAgKiBSZWR1Y2luZyBjb2xsaXNpb24gcGFzc2VzIG1heSBjYXVzZSB0aGluZ3Mgbm90IHRvIGNvbGxpZGUgYXMgZXhwZWN0ZWQgaW4geW91ciBnYW1lLCBidXQgbWF5IGluY3JlYXNlIHBlcmZvcm1hbmNlLlxyXG4gICAgICpcclxuICAgICAqIE1vcmUgcGFzc2VzIGNhbiBpbXByb3ZlIHRoZSB2aXN1YWwgcXVhbGl0eSBvZiBjb2xsaXNpb25zIHdoZW4gbWFueSBvYmplY3RzIGFyZSBvbiB0aGUgc2NyZWVuLiBUaGlzIGNhbiByZWR1Y2Ugaml0dGVyLCBpbXByb3ZlIHRoZVxyXG4gICAgICogY29sbGlzaW9uIHJlc29sdXRpb24gb2YgZmFzdCBtb3ZlIG9iamVjdHMsIG9yIHRoZSBzdGFiaWxpdHkgb2YgbGFyZ2UgbnVtYmVycyBvZiBvYmplY3RzIHN0YWNrZWQgdG9nZXRoZXIuXHJcbiAgICAgKlxyXG4gICAgICogRmV3ZXIgcGFzc2VzIHdpbGwgaW1wcm92ZSB0aGUgcGVyZm9ybWFuY2Ugb2YgdGhlIGdhbWUgYXQgdGhlIGNvc3Qgb2YgY29sbGlzaW9uIHF1YWxpdHksIG1vcmUgcGFzc2VzIHdpbGwgaW1wcm92ZSBxdWFsaXR5IGF0IHRoZVxyXG4gICAgICogY29zdCBvZiBwZXJmb3JtYW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgZGVmYXVsdCBpcyBzZXQgdG8gNSBwYXNzZXMgd2hpY2ggaXMgYSBnb29kIHN0YXJ0LlxyXG4gICAgICovXHJcbiAgICBQaHlzaWNzLmNvbGxpc2lvblBhc3NlcyA9IDU7XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgYnJvYWRwaGFzZSBwYWlyIGlkZW50aWZpY2F0aW9uIHN0cmF0ZWd5LlxyXG4gICAgICpcclxuICAgICAqIFRoZSBkZWZhdWx0IHN0cmF0ZWd5IGlzIFtbQnJvYWRwaGFzZVN0cmF0ZWd5LkR5bmFtaWNBQUJCVHJlZV1dIHdoaWNoIHVzZXMgYSBiaW5hcnkgdHJlZSBvZiBheGlzLWFsaWduZWQgYm91bmRpbmcgYm94ZXMgdG8gaWRlbnRpZnlcclxuICAgICAqIHBvdGVudGlhbCBjb2xsaXNpb24gcGFpcnMgd2hpY2ggaXMgTyhubG9nKG4pKSBmYXN0ZXIuIFRoZSBvdGhlciBwb3NzaWJsZSBzdHJhdGVneSBpcyB0aGUgW1tCcm9hZHBoYXNlU3RyYXRlZ3kuTmFpdmVdXSBzdHJhdGVneVxyXG4gICAgICogd2hpY2ggbG9vcHMgb3ZlciBldmVyeSBvYmplY3QgZm9yIGV2ZXJ5IG9iamVjdCBpbiB0aGUgc2NlbmUgdG8gaWRlbnRpZnkgY29sbGlzaW9uIHBhaXJzIHdoaWNoIGlzIE8obl4yKSBzbG93ZXIuXHJcbiAgICAgKi9cclxuICAgIFBoeXNpY3MuYnJvYWRwaGFzZVN0cmF0ZWd5ID0gQnJvYWRwaGFzZVN0cmF0ZWd5LkR5bmFtaWNBQUJCVHJlZTtcclxuICAgIC8qKlxyXG4gICAgICogR2xvYmFsbHkgc3dpdGNoZXMgdGhlIGRlYnVnIGluZm9ybWF0aW9uIGZvciB0aGUgYnJvYWRwaGFzZSBzdHJhdGVneVxyXG4gICAgICovXHJcbiAgICBQaHlzaWNzLmJyb2FkcGhhc2VEZWJ1ZyA9IGZhbHNlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93IHRoZSBub3JtYWxzIGFzIGEgcmVzdWx0IG9mIGNvbGxpc2lvbiBvbiB0aGUgc2NyZWVuLlxyXG4gICAgICovXHJcbiAgICBQaHlzaWNzLnNob3dDb2xsaXNpb25Ob3JtYWxzID0gZmFsc2U7XHJcbiAgICAvKipcclxuICAgICAqIFNob3cgdGhlIHBvc2l0aW9uLCB2ZWxvY2l0eSwgYW5kIGFjY2VsZXJhdGlvbiBhcyBncmFwaGljYWwgdmVjdG9ycy5cclxuICAgICAqL1xyXG4gICAgUGh5c2ljcy5zaG93TW90aW9uVmVjdG9ycyA9IGZhbHNlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93IHRoZSBheGlzLWFsaWduZWQgYm91bmRpbmcgYm94ZXMgb2YgdGhlIGNvbGxpc2lvbiBib2RpZXMgb24gdGhlIHNjcmVlbi5cclxuICAgICAqL1xyXG4gICAgUGh5c2ljcy5zaG93Qm91bmRzID0gZmFsc2U7XHJcbiAgICAvKipcclxuICAgICAqIFNob3cgdGhlIGJvdW5kaW5nIGNvbGxpc2lvbiBhcmVhIHNoYXBlc1xyXG4gICAgICovXHJcbiAgICBQaHlzaWNzLnNob3dBcmVhID0gZmFsc2U7XHJcbiAgICAvKipcclxuICAgICAqIFNob3cgcG9pbnRzIG9mIGNvbGxpc2lvbiBpbnRlcnByZXRlZCBieSBleGNhbGlidXIgYXMgYSByZXN1bHQgb2YgY29sbGlzaW9uLlxyXG4gICAgICovXHJcbiAgICBQaHlzaWNzLnNob3dDb250YWN0cyA9IGZhbHNlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93IHRoZSBzdXJmYWNlIG5vcm1hbHMgb2YgdGhlIGNvbGxpc2lvbiBhcmVhcy5cclxuICAgICAqL1xyXG4gICAgUGh5c2ljcy5zaG93Tm9ybWFscyA9IGZhbHNlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGdsb2JhbCBjb2xsaXNpb24gcmVzb2x1dGlvbiBzdHJhdGVneSAobmFycm93cGhhc2UpLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBkZWZhdWx0IGlzIFtbQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5LkJveF1dIHdoaWNoIHBlcmZvcm1zIHNpbXBsZSBheGlzIGFsaWduZWQgYXJjYWRlIHN0eWxlIHBoeXNpY3MuXHJcbiAgICAgKlxyXG4gICAgICogTW9yZSBhZHZhbmNlZCByaWdpZCBib2R5IHBoeXNpY3MgYXJlIGVuYWJsZWQgYnkgc2V0dGluZyBbW0NvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneS5SaWdpZEJvZHldXSB3aGljaCBhbGxvd3MgZm9yIGNvbXBsaWNhdGVkXHJcbiAgICAgKiBzaW11bGF0ZWQgcGh5c2ljYWwgaW50ZXJhY3Rpb25zLlxyXG4gICAgICovXHJcbiAgICBQaHlzaWNzLmNvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneSA9IENvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneS5Cb3g7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkZWZhdWx0IG1hc3MgdG8gdXNlIGlmIG5vbmUgaXMgc3BlY2lmaWVkXHJcbiAgICAgKi9cclxuICAgIFBoeXNpY3MuZGVmYXVsdE1hc3MgPSAxMDtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBwb3NpdGlvbiBhbmQgdmVsb2NpdHkgcG9zaXRpb25hbCBpbnRlZ3JhdG9yLCBjdXJyZW50bHkgb25seSBFdWxlciBpcyBzdXBwb3J0ZWQuXHJcbiAgICAgKi9cclxuICAgIFBoeXNpY3MuaW50ZWdyYXRvciA9IEludGVncmF0b3IuRXVsZXI7XHJcbiAgICAvKipcclxuICAgICAqIE51bWJlciBvZiBzdGVwcyB0byB1c2UgaW4gaW50ZWdyYXRpb24uIEEgaGlnaGVyIG51bWJlciBpbXByb3ZlcyB0aGUgcG9zaXRpb25hbCBhY2N1cmFjeSBvdmVyIHRpbWUuIFRoaXMgY2FuIGJlIHVzZWZ1bCB0byBpbmNyZWFzZVxyXG4gICAgICogaWYgeW91IGhhdmUgZmFzdCBtb3Zpbmcgb2JqZWN0cyBpbiB5b3VyIHNpbXVsYXRpb24gb3IgeW91IGhhdmUgYSBsYXJnZSBudW1iZXIgb2Ygb2JqZWN0cyBhbmQgbmVlZCB0byBpbmNyZWFzZSBzdGFiaWxpdHkuXHJcbiAgICAgKi9cclxuICAgIFBoeXNpY3MuaW50ZWdyYXRpb25TdGVwcyA9IDE7XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB3aGV0aGVyIHJvdGF0aW9uIGlzIGFsbG93ZWQgaW4gYSBSaWdpZEJvZHkgY29sbGlzaW9uIHJlc29sdXRpb25cclxuICAgICAqL1xyXG4gICAgUGh5c2ljcy5hbGxvd1JpZ2lkQm9keVJvdGF0aW9uID0gdHJ1ZTtcclxuICAgIC8qKlxyXG4gICAgICogU21hbGwgdmFsdWUgdG8gaGVscCBjb2xsaXNpb24gcGFzc2VzIHNldHRsZSB0aGVtc2VsdmVzIGFmdGVyIHRoZSBuYXJyb3dwaGFzZS5cclxuICAgICAqL1xyXG4gICAgUGh5c2ljcy5jb2xsaXNpb25TaGlmdCA9IC4wMDE7XHJcbiAgICAvKipcclxuICAgICAqIEZhY3RvciB0byBhZGQgdG8gdGhlIFJpZ2lkQm9keSBCb3VuZGluZ0JveCwgYm91bmRpbmcgYm94IChkaW1lbnNpb25zICs9IHZlbCAqIGR5bmFtaWNUcmVlVmVsb2NpdHlNdWx0aXBseWVyKTtcclxuICAgICAqL1xyXG4gICAgUGh5c2ljcy5keW5hbWljVHJlZVZlbG9jaXR5TXVsdGlwbHllciA9IDI7XHJcbiAgICAvKipcclxuICAgICAqIFBhZCBSaWdpZEJvZHkgQm91bmRpbmdCb3ggYnkgYSBjb25zdGFudCBhbW91bnRcclxuICAgICAqL1xyXG4gICAgUGh5c2ljcy5ib3VuZHNQYWRkaW5nID0gNTtcclxuICAgIC8qKlxyXG4gICAgICogU3VyZmFjZSBlcHNpbG9uIGlzIHVzZWQgdG8gaGVscCBkZWFsIHdpdGggc3VyZmFjZSBwZW5hdHJhdGlvblxyXG4gICAgICovXHJcbiAgICBQaHlzaWNzLnN1cmZhY2VFcHNpbG9uID0gLjE7XHJcbiAgICAvKipcclxuICAgICAqIEVuYWJsZSBmYXN0IG1vdmluZyBib2R5IGNoZWNraW5nLCB0aGlzIGVuYWJsZXMgY2hlY2tpbmcgZm9yIGNvbGxpc2lvbiBwYWlycyB2aWEgcmF5Y2FzdCBmb3IgZmFzdCBtb3Zpbmcgb2JqZWN0cyB0byBwcmV2ZW50XHJcbiAgICAgKiBib2RpZXMgZnJvbSB0dW5uZWxpbmcgdGhyb3VnaCBvbmUgYW5vdGhlci5cclxuICAgICAqL1xyXG4gICAgUGh5c2ljcy5jaGVja0ZvckZhc3RCb2RpZXMgPSB0cnVlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNhYmxlIG1pbmltdW0gZmFzdCBtb3ZpbmcgYm9keSByYXljYXN0LCBieSBkZWZhdWx0IGlmIGV4LlBoeXNpY3MuY2hlY2tGb3JGYXN0Qm9kaWVzID0gdHJ1ZSBFeGNhbGlidXIgd2lsbCBvbmx5IGNoZWNrIGlmIHRoZVxyXG4gICAgICogYm9keSBpcyBtb3ZpbmcgYXQgbGVhc3QgaGFsZiBvZiBpdHMgbWluaW11bSBkaW1pbmVuc2lvbiBpbiBhbiB1cGRhdGUuIElmIGV4LlBoeXNpY3MuZGlzYWJsZU1pbmltdW1TcGVlZEZvckZhc3RCb2R5IGlzIHNldCB0byB0cnVlLFxyXG4gICAgICogRXhjYWxpYnVyIHdpbGwgYWx3YXlzIHBlcmZvcm0gdGhlIGZhc3QgYm9keSByYXljYXN0IHJlZ2FyZGxlc3Mgb2Ygc3BlZWQuXHJcbiAgICAgKi9cclxuICAgIFBoeXNpY3MuZGlzYWJsZU1pbmltdW1TcGVlZEZvckZhc3RCb2R5ID0gZmFsc2U7XHJcbiAgICBleHBvcnRzLlBoeXNpY3MgPSBQaHlzaWNzO1xyXG59KTtcclxuZGVmaW5lKFwiVXRpbC9FYXNpbmdGdW5jdGlvbnNcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogU3RhbmRhcmQgZWFzaW5nIGZ1bmN0aW9ucyBmb3IgbW90aW9uIGluIEV4Y2FsaWJ1ciwgZGVmaW5lZCBvbiBhIGRvbWFpbiBvZiBbMCwgZHVyYXRpb25dIGFuZCBhIHJhbmdlIGZyb20gWytzdGFydFZhbHVlLCtlbmRWYWx1ZV1cclxuICAgICAqIEdpdmVuIGEgdGltZSwgdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGEgdmFsdWUgZnJvbSBwb3NpdGl2ZSBzdGFydFZhbHVlIHRvIHBvc2l0aXZlIGVuZFZhbHVlLlxyXG4gICAgICpcclxuICAgICAqIGBgYGpzXHJcbiAgICAgKiBmdW5jdGlvbiBMaW5lYXIgKHQpIHtcclxuICAgICAqICAgIHJldHVybiB0ICogdDtcclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiAvLyBhY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XHJcbiAgICAgKiBmdW5jdGlvbiBFYXNlSW5RdWFkICh0KSB7XHJcbiAgICAgKiAgICByZXR1cm4gdCAqIHQ7XHJcbiAgICAgKiB9XHJcbiAgICAgKlxyXG4gICAgICogLy8gZGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcclxuICAgICAqIGZ1bmN0aW9uIEVhc2VPdXRRdWFkICh0KSB7XHJcbiAgICAgKiAgICByZXR1cm4gdCAqICgyIC0gdCk7XHJcbiAgICAgKiB9XHJcbiAgICAgKlxyXG4gICAgICogLy8gYWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXHJcbiAgICAgKiBmdW5jdGlvbiBFYXNlSW5PdXRRdWFkICh0KSB7XHJcbiAgICAgKiAgICByZXR1cm4gdCA8IC41ID8gMiAqIHQgKiB0IDogLTEgKyAoNCAtIDIgKiB0KSAqIHQ7XHJcbiAgICAgKiB9XHJcbiAgICAgKlxyXG4gICAgICogLy8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxyXG4gICAgICogZnVuY3Rpb24gRWFzZUluQ3ViaWMgKHQpIHtcclxuICAgICAqICAgIHJldHVybiB0ICogdCAqIHQ7XHJcbiAgICAgKiB9XHJcbiAgICAgKlxyXG4gICAgICogLy8gZGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcclxuICAgICAqIGZ1bmN0aW9uIEVhc2VPdXRDdWJpYyAodCkge1xyXG4gICAgICogICAgcmV0dXJuICgtLXQpICogdCAqIHQgKyAxO1xyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIC8vIGFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxyXG4gICAgICogZnVuY3Rpb24gRWFzZUluT3V0Q3ViaWMgKHQpIHtcclxuICAgICAqICAgIHJldHVybiB0IDwgLjUgPyA0ICogdCAqIHQgKiB0IDogKHQgLSAxKSAqICgyICogdCAtIDIpICogKDIgKiB0IC0gMikgKyAxO1xyXG4gICAgICogfVxyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIHZhciBFYXNpbmdGdW5jdGlvbnMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIEVhc2luZ0Z1bmN0aW9ucygpIHtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEVhc2luZ0Z1bmN0aW9ucztcclxuICAgIH0oKSk7XHJcbiAgICBFYXNpbmdGdW5jdGlvbnMuTGluZWFyID0gZnVuY3Rpb24gKGN1cnJlbnRUaW1lLCBzdGFydFZhbHVlLCBlbmRWYWx1ZSwgZHVyYXRpb24pIHtcclxuICAgICAgICBlbmRWYWx1ZSA9IChlbmRWYWx1ZSAtIHN0YXJ0VmFsdWUpO1xyXG4gICAgICAgIHJldHVybiBlbmRWYWx1ZSAqIGN1cnJlbnRUaW1lIC8gZHVyYXRpb24gKyBzdGFydFZhbHVlO1xyXG4gICAgfTtcclxuICAgIEVhc2luZ0Z1bmN0aW9ucy5FYXNlSW5RdWFkID0gZnVuY3Rpb24gKGN1cnJlbnRUaW1lLCBzdGFydFZhbHVlLCBlbmRWYWx1ZSwgZHVyYXRpb24pIHtcclxuICAgICAgICBlbmRWYWx1ZSA9IChlbmRWYWx1ZSAtIHN0YXJ0VmFsdWUpO1xyXG4gICAgICAgIGN1cnJlbnRUaW1lIC89IGR1cmF0aW9uO1xyXG4gICAgICAgIHJldHVybiBlbmRWYWx1ZSAqIGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKyBzdGFydFZhbHVlO1xyXG4gICAgfTtcclxuICAgIEVhc2luZ0Z1bmN0aW9ucy5FYXNlT3V0UXVhZCA9IGZ1bmN0aW9uIChjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGR1cmF0aW9uKSB7XHJcbiAgICAgICAgZW5kVmFsdWUgPSAoZW5kVmFsdWUgLSBzdGFydFZhbHVlKTtcclxuICAgICAgICBjdXJyZW50VGltZSAvPSBkdXJhdGlvbjtcclxuICAgICAgICByZXR1cm4gLWVuZFZhbHVlICogY3VycmVudFRpbWUgKiAoY3VycmVudFRpbWUgLSAyKSArIHN0YXJ0VmFsdWU7XHJcbiAgICB9O1xyXG4gICAgRWFzaW5nRnVuY3Rpb25zLkVhc2VJbk91dFF1YWQgPSBmdW5jdGlvbiAoY3VycmVudFRpbWUsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBkdXJhdGlvbikge1xyXG4gICAgICAgIGVuZFZhbHVlID0gKGVuZFZhbHVlIC0gc3RhcnRWYWx1ZSk7XHJcbiAgICAgICAgY3VycmVudFRpbWUgLz0gZHVyYXRpb24gLyAyO1xyXG4gICAgICAgIGlmIChjdXJyZW50VGltZSA8IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVuZFZhbHVlIC8gMiAqIGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKyBzdGFydFZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50VGltZS0tO1xyXG4gICAgICAgIHJldHVybiAtZW5kVmFsdWUgLyAyICogKGN1cnJlbnRUaW1lICogKGN1cnJlbnRUaW1lIC0gMikgLSAxKSArIHN0YXJ0VmFsdWU7XHJcbiAgICB9O1xyXG4gICAgRWFzaW5nRnVuY3Rpb25zLkVhc2VJbkN1YmljID0gZnVuY3Rpb24gKGN1cnJlbnRUaW1lLCBzdGFydFZhbHVlLCBlbmRWYWx1ZSwgZHVyYXRpb24pIHtcclxuICAgICAgICBlbmRWYWx1ZSA9IChlbmRWYWx1ZSAtIHN0YXJ0VmFsdWUpO1xyXG4gICAgICAgIGN1cnJlbnRUaW1lIC89IGR1cmF0aW9uO1xyXG4gICAgICAgIHJldHVybiBlbmRWYWx1ZSAqIGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSArIHN0YXJ0VmFsdWU7XHJcbiAgICB9O1xyXG4gICAgRWFzaW5nRnVuY3Rpb25zLkVhc2VPdXRDdWJpYyA9IGZ1bmN0aW9uIChjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGR1cmF0aW9uKSB7XHJcbiAgICAgICAgZW5kVmFsdWUgPSAoZW5kVmFsdWUgLSBzdGFydFZhbHVlKTtcclxuICAgICAgICBjdXJyZW50VGltZSAvPSBkdXJhdGlvbjtcclxuICAgICAgICBjdXJyZW50VGltZS0tO1xyXG4gICAgICAgIHJldHVybiBlbmRWYWx1ZSAqIChjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKyAxKSArIHN0YXJ0VmFsdWU7XHJcbiAgICB9O1xyXG4gICAgRWFzaW5nRnVuY3Rpb25zLkVhc2VJbk91dEN1YmljID0gZnVuY3Rpb24gKGN1cnJlbnRUaW1lLCBzdGFydFZhbHVlLCBlbmRWYWx1ZSwgZHVyYXRpb24pIHtcclxuICAgICAgICBlbmRWYWx1ZSA9IChlbmRWYWx1ZSAtIHN0YXJ0VmFsdWUpO1xyXG4gICAgICAgIGN1cnJlbnRUaW1lIC89IGR1cmF0aW9uIC8gMjtcclxuICAgICAgICBpZiAoY3VycmVudFRpbWUgPCAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbmRWYWx1ZSAvIDIgKiBjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKyBzdGFydFZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50VGltZSAtPSAyO1xyXG4gICAgICAgIHJldHVybiBlbmRWYWx1ZSAvIDIgKiAoY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICsgMikgKyBzdGFydFZhbHVlO1xyXG4gICAgfTtcclxuICAgIGV4cG9ydHMuRWFzaW5nRnVuY3Rpb25zID0gRWFzaW5nRnVuY3Rpb25zO1xyXG59KTtcclxuLy8gUHJvbWlzZXMvQSsgU3BlYyBodHRwOi8vcHJvbWlzZXMtYXBsdXMuZ2l0aHViLmlvL3Byb21pc2VzLXNwZWMvXHJcbmRlZmluZShcIlByb21pc2VzXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIFZhbGlkIHN0YXRlcyBmb3IgYSBwcm9taXNlIHRvIGJlIGluXHJcbiAgICAgKi9cclxuICAgIHZhciBQcm9taXNlU3RhdGU7XHJcbiAgICAoZnVuY3Rpb24gKFByb21pc2VTdGF0ZSkge1xyXG4gICAgICAgIFByb21pc2VTdGF0ZVtQcm9taXNlU3RhdGVbXCJSZXNvbHZlZFwiXSA9IDBdID0gXCJSZXNvbHZlZFwiO1xyXG4gICAgICAgIFByb21pc2VTdGF0ZVtQcm9taXNlU3RhdGVbXCJSZWplY3RlZFwiXSA9IDFdID0gXCJSZWplY3RlZFwiO1xyXG4gICAgICAgIFByb21pc2VTdGF0ZVtQcm9taXNlU3RhdGVbXCJQZW5kaW5nXCJdID0gMl0gPSBcIlBlbmRpbmdcIjtcclxuICAgIH0pKFByb21pc2VTdGF0ZSA9IGV4cG9ydHMuUHJvbWlzZVN0YXRlIHx8IChleHBvcnRzLlByb21pc2VTdGF0ZSA9IHt9KSk7XHJcbiAgICAvKipcclxuICAgICAqIFByb21pc2VzIGFyZSB1c2VkIHRvIGRvIGFzeW5jaHJvbm91cyB3b3JrIGFuZCB0aGV5IGFyZSB1c2VmdWwgZm9yXHJcbiAgICAgKiBjcmVhdGluZyBhIGNoYWluIG9mIGFjdGlvbnMuIEluIEV4Y2FsaWJ1ciB0aGV5IGFyZSB1c2VkIGZvciBsb2FkaW5nLFxyXG4gICAgICogc291bmRzLCBhbmltYXRpb24sIGFjdGlvbnMsIGFuZCBtb3JlLlxyXG4gICAgICpcclxuICAgICAqIFtbaW5jbHVkZTpQcm9taXNlcy5tZF1dXHJcbiAgICAgKi9cclxuICAgIHZhciBQcm9taXNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBQcm9taXNlKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IFByb21pc2VTdGF0ZS5QZW5kaW5nO1xyXG4gICAgICAgICAgICB0aGlzLl9zdWNjZXNzQ2FsbGJhY2tzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuX3JlamVjdENhbGxiYWNrID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZSBhbmQgcmVzb2x2ZSBhIFByb21pc2Ugd2l0aCBhbiBvcHRpb25hbCB2YWx1ZVxyXG4gICAgICAgICAqIEBwYXJhbSB2YWx1ZSAgQW4gb3B0aW9uYWwgdmFsdWUgdG8gd3JhcCBpbiBhIHJlc29sdmVkIHByb21pc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBQcm9taXNlLnJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIHByb21pc2UgPSAobmV3IFByb21pc2UoKSkucmVzb2x2ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlIGFuZCByZWplY3QgYSBQcm9taXNlIHdpdGggYW4gb3B0aW9uYWwgdmFsdWVcclxuICAgICAgICAgKiBAcGFyYW0gdmFsdWUgIEFuIG9wdGlvbmFsIHZhbHVlIHRvIHdyYXAgaW4gYSByZWplY3RlZCBwcm9taXNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvbWlzZS5yZWplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIHByb21pc2UgPSAobmV3IFByb21pc2UoKSkucmVqZWN0KHZhbHVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQcm9taXNlLmpvaW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xyXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgIUFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xyXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMgPSBhcmd1bWVudHNbMF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGpvaW5lZFByb21pc2UgPSBuZXcgUHJvbWlzZSgpO1xyXG4gICAgICAgICAgICBpZiAoIXByb21pc2VzIHx8ICFwcm9taXNlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBqb2luZWRQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdG90YWwgPSBwcm9taXNlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHZhciBzdWNjZXNzZXMgPSAwO1xyXG4gICAgICAgICAgICB2YXIgcmVqZWN0cyA9IDA7XHJcbiAgICAgICAgICAgIHZhciBlcnJvcnMgPSBbXTtcclxuICAgICAgICAgICAgcHJvbWlzZXMuZm9yRWFjaChmdW5jdGlvbiAocCkge1xyXG4gICAgICAgICAgICAgICAgcC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzZXMgKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3VjY2Vzc2VzID09PSB0b3RhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqb2luZWRQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc3VjY2Vzc2VzICsgcmVqZWN0cyArIGVycm9ycy5sZW5ndGggPT09IHRvdGFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpvaW5lZFByb21pc2UucmVqZWN0KGVycm9ycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdHMgKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3VjY2Vzc2VzICsgcmVqZWN0cyArIGVycm9ycy5sZW5ndGggPT09IHRvdGFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpvaW5lZFByb21pc2UucmVqZWN0KGVycm9ycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSkuZXJyb3IoZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKGVycm9ycy5sZW5ndGggKyBzdWNjZXNzZXMgKyByZWplY3RzKSA9PT0gdG90YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgam9pbmVkUHJvbWlzZS5yZWplY3QoZXJyb3JzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBqb2luZWRQcm9taXNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hhaW4gc3VjY2VzcyBhbmQgcmVqZWN0IGNhbGxiYWNrcyBhZnRlciB0aGUgcHJvbWlzZSBpcyByZXNvbHZlZFxyXG4gICAgICAgICAqIEBwYXJhbSBzdWNjZXNzQ2FsbGJhY2sgIENhbGwgb24gcmVzb2x1dGlvbiBvZiBwcm9taXNlXHJcbiAgICAgICAgICogQHBhcmFtIHJlamVjdENhbGxiYWNrICAgQ2FsbCBvbiByZWplY3Rpb24gb2YgcHJvbWlzZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAoc3VjY2Vzc0NhbGxiYWNrLCByZWplY3RDYWxsYmFjaykge1xyXG4gICAgICAgICAgICBpZiAoc3VjY2Vzc0NhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdWNjZXNzQ2FsbGJhY2tzLnB1c2goc3VjY2Vzc0NhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBwcm9taXNlIGlzIGFscmVhZHkgcmVzb3ZsZWQgY2FsbCBpbW1lZGlhdGVseVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUoKSA9PT0gUHJvbWlzZVN0YXRlLlJlc29sdmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc0NhbGxiYWNrLmNhbGwodGhpcywgdGhpcy5fdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVFcnJvcihlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJlamVjdENhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWplY3RDYWxsYmFjayA9IHJlamVjdENhbGxiYWNrO1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHByb21pc2UgaXMgYWxyZWFkeSByZWplY3RlZCBjYWxsIGltbWVkaWF0ZWx5XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSgpID09PSBQcm9taXNlU3RhdGUuUmVqZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3RDYWxsYmFjay5jYWxsKHRoaXMsIHRoaXMuX3ZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlRXJyb3IoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkIGFuIGVycm9yIGNhbGxiYWNrIHRvIHRoZSBwcm9taXNlXHJcbiAgICAgICAgICogQHBhcmFtIGVycm9yQ2FsbGJhY2sgIENhbGwgaWYgdGhlcmUgd2FzIGFuIGVycm9yIGluIGEgY2FsbGJhY2tcclxuICAgICAgICAgKi9cclxuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnJvckNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGlmIChlcnJvckNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJvckNhbGxiYWNrID0gZXJyb3JDYWxsYmFjaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlc29sdmUgdGhlIHByb21pc2UgYW5kIHBhc3MgYW4gb3B0aW9uIHZhbHVlIHRvIHRoZSBzdWNjZXNzIGNhbGxiYWNrc1xyXG4gICAgICAgICAqIEBwYXJhbSB2YWx1ZSAgVmFsdWUgdG8gcGFzcyB0byB0aGUgc3VjY2VzcyBjYWxsYmFja3NcclxuICAgICAgICAgKi9cclxuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gUHJvbWlzZVN0YXRlLlBlbmRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gUHJvbWlzZVN0YXRlLlJlc29sdmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N1Y2Nlc3NDYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2IuY2FsbChfdGhpcywgX3RoaXMuX3ZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlRXJyb3IoZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZXNvbHZlIGEgcHJvbWlzZSB0aGF0IGlzIG5vdCBpbiBhIHBlbmRpbmcgc3RhdGUhJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWplY3QgdGhlIHByb21pc2UgYW5kIHBhc3MgYW4gb3B0aW9uIHZhbHVlIHRvIHRoZSByZWplY3QgY2FsbGJhY2tzXHJcbiAgICAgICAgICogQHBhcmFtIHZhbHVlICBWYWx1ZSB0byBwYXNzIHRvIHRoZSByZWplY3QgY2FsbGJhY2tzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUucmVqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gUHJvbWlzZVN0YXRlLlBlbmRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gUHJvbWlzZVN0YXRlLlJlamVjdGVkO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlamVjdENhbGxiYWNrLmNhbGwodGhpcywgdGhpcy5fdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVFcnJvcihlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlamVjdCBhIHByb21pc2UgdGhhdCBpcyBub3QgaW4gYSBwZW5kaW5nIHN0YXRlIScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5zcGVjdCB0aGUgY3VycmVudCBzdGF0ZSBvZiBhIHByb21pc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5zdGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2hhbmRsZUVycm9yID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2Vycm9yQ2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9yQ2FsbGJhY2suY2FsbCh0aGlzLCBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHJldGhyb3cgZXJyb3JcclxuICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuUHJvbWlzZSA9IFByb21pc2U7XHJcbn0pO1xyXG4vKipcclxuICogUHNldWRvLVJhbmRvbSBVdGlsaXR5XHJcbiAqXHJcbiAqIEEgcHNldWRvLXJhbmRvbSB1dGlsaXR5IHRvIGFkZCBzZWVkZWQgcmFuZG9tIHN1cHBvcnQgZm9yIGhlbHAgaW5cclxuICogZ2VuZXJhdGluZyB0aGluZ3MgbGlrZSB0ZXJyYWluIG9yIHJlcHJvZHVjaWJsZSByYW5kb21uZXNzLiBVc2VzIHRoZVxyXG4gKiBbTWVyc2VubmUgVHdpc3Rlcl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWVyc2VubmVfVHdpc3RlcikgYWxnb3JpdGhtLlxyXG4gKlxyXG4gKiBbW2luY2x1ZGU6UmFuZG9tLm1kXV1cclxuICovXHJcbmRlZmluZShcIk1hdGgvUmFuZG9tXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIDMyLWJpdCBtYXNrXHJcbiAgICAgKi9cclxuICAgIHZhciBCSVRNQVNLMzIgPSAweEZGRkZGRkZGO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQc2V1ZG8tcmFuZG9tIG51bWJlciBnZW5lcmF0b3IgZm9sbG93aW5nIHRoZSBNZXJzZW5uZV9Ud2lzdGVyIGFsZ29yaXRobS4gR2l2ZW4gYSBzZWVkIHRoaXMgZ2VuZXJhdG9yIHdpbGwgcHJvZHVjZSB0aGUgc2FtZSBzZXF1ZW5jZVxyXG4gICAgICogb2YgbnVtYmVycyBlYWNoIHRpbWUgaXQgaXMgY2FsbGVkLlxyXG4gICAgICogU2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01lcnNlbm5lX1R3aXN0ZXIgZm9yIG1vcmUgZGV0YWlscy5cclxuICAgICAqIFVzZXMgdGhlIE1UMTk5MzctMzIgKDIwMDIpIGltcGxlbWVudGF0aW9uIGRvY3VtZW50ZWQgaGVyZSBodHRwOi8vd3d3Lm1hdGguc2NpLmhpcm9zaGltYS11LmFjLmpwL35tLW1hdC9NVC9NVDIwMDIvZW10MTk5Mzdhci5odG1sXHJcbiAgICAgKlxyXG4gICAgICogQXBpIGluc3BpcmVkIGJ5IGh0dHA6Ly9jaGFuY2Vqcy5jb20vIyBodHRwczovL2dpdGh1Yi5jb20vY2hhbmNlanMvY2hhbmNlanNcclxuICAgICAqL1xyXG4gICAgdmFyIFJhbmRvbSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgbm8gc2VlZCBpcyBzcGVjaWZpZWQsIHRoZSBEYXRlLm5vdygpIGlzIHVzZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBSYW5kb20oc2VlZCkge1xyXG4gICAgICAgICAgICB0aGlzLnNlZWQgPSBzZWVkO1xyXG4gICAgICAgICAgICAvLyBTZXBhcmF0aW9uIHBvaW50IG9mIG9uZSBvbmUgd29yZCwgdGhlIG51bWJlciBvZiBiaXRzIGluIHRoZSBsb3dlciBiaXRtYXNrIDAgPD0gciA8PSB3LTFcclxuICAgICAgICAgICAgdGhpcy5fbG93ZXJNYXNrID0gMHg3RkZGRkZGRjsgLy8gMzEgYml0cyBzYW1lIGFzIF9yXHJcbiAgICAgICAgICAgIHRoaXMuX3VwcGVyTWFzayA9IDB4ODAwMDAwMDA7IC8vIDM0IGhpZ2ggYml0c1xyXG4gICAgICAgICAgICAvLyBXb3JkIHNpemUsIDY0IGJpdHNcclxuICAgICAgICAgICAgdGhpcy5fdyA9IDMyO1xyXG4gICAgICAgICAgICAvLyBEZWdyZWUgb2YgcmVjdXJyYW5jZVxyXG4gICAgICAgICAgICB0aGlzLl9uID0gNjI0O1xyXG4gICAgICAgICAgICAvLyBNaWRkbGUgd29yZCwgYW4gb2Zmc2V0IHVzZWQgaW4gdGhlIHJlY3VycmFuY2UgZGVmaW5pbmcgdGhlIHNlcmllcyB4LCAxPD1tPG5cclxuICAgICAgICAgICAgdGhpcy5fbSA9IDM5NztcclxuICAgICAgICAgICAgLy8gY29lZmZpY2llbnRzIG9mIHRlaCByYXRpb25hbCBub3JtYWwgZm9ybSB0d2lzdCBtYXRyaXhcclxuICAgICAgICAgICAgdGhpcy5fYSA9IDB4OTkwOEIwREY7XHJcbiAgICAgICAgICAgIC8vIHRlbXBlcmluZyBiaXQgc2hpZnRzIGFuZCBtYXNrc1xyXG4gICAgICAgICAgICB0aGlzLl91ID0gMTE7XHJcbiAgICAgICAgICAgIHRoaXMuX3MgPSA3O1xyXG4gICAgICAgICAgICB0aGlzLl9iID0gMHg5ZDJjNTY4MDtcclxuICAgICAgICAgICAgdGhpcy5fdCA9IDE1O1xyXG4gICAgICAgICAgICB0aGlzLl9jID0gMHhlZmM2MDAwMDtcclxuICAgICAgICAgICAgdGhpcy5fbCA9IDE4O1xyXG4gICAgICAgICAgICB0aGlzLl9mID0gMTgxMjQzMzI1MztcclxuICAgICAgICAgICAgdGhpcy5fbXQgPSBuZXcgQXJyYXkodGhpcy5fbik7XHJcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gbWFzayB0byBzdXBwb3J0IGhpZ2hlciBiaXQgbWFjaGluZXNcclxuICAgICAgICAgICAgdGhpcy5fbXRbMF0gPSAoc2VlZCB8fCBEYXRlLm5vdygpKSA+Pj4gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLl9uOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBzID0gdGhpcy5fbXRbaSAtIDFdIF4gKHRoaXMuX210W2kgLSAxXSA+Pj4gKHRoaXMuX3cgLSAyKSk7XHJcbiAgICAgICAgICAgICAgICAvLyBudW1iZXJzIGFyZSBiaWdnZXIgdGhhbiB0aGUgSlMgbWF4IHNhZmUgaW50LCBhZGQgaW4gMTYtYml0IGNodW5rcyB0byBwcmV2ZW50IElFRUUgcm91bmRpbmcgZXJyb3JzIG9uIGhpZ2ggYml0cyAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fbXRbaV0gPSAoKCh0aGlzLl9mICogKChzICYgMHhGRkZGMDAwMCkgPj4+IDE2KSkgPDwgMTYpICsgKHRoaXMuX2YgKiAocyAmIDB4RkZGRikpICsgaSkgPj4+IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5faW5kZXggPSB0aGlzLl9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcHBseSB0aGUgdHdpc3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5kb20ucHJvdG90eXBlLl90d2lzdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG1hZzAxID0gWzB4MCwgdGhpcy5fYV07XHJcbiAgICAgICAgICAgIHZhciB5ID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9uIC0gdGhpcy5fbTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB5ID0gKHRoaXMuX210W2ldICYgdGhpcy5fdXBwZXJNYXNrKSB8ICh0aGlzLl9tdFtpICsgMV0gJiB0aGlzLl9sb3dlck1hc2spO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbXRbaV0gPSB0aGlzLl9tdFtpICsgdGhpcy5fbV0gXiAoeSA+Pj4gMSkgXiBtYWcwMVt5ICYgMHgxXSAmIEJJVE1BU0szMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKDsgaSA8IHRoaXMuX24gLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHkgPSAodGhpcy5fbXRbaV0gJiB0aGlzLl91cHBlck1hc2spIHwgKHRoaXMuX210W2kgKyAxXSAmIHRoaXMuX2xvd2VyTWFzayk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tdFtpXSA9IHRoaXMuX210W2kgKyAodGhpcy5fbSAtIHRoaXMuX24pXSBeICh5ID4+PiAxKSBeIG1hZzAxW3kgJiAweDFdICYgQklUTUFTSzMyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHkgPSAodGhpcy5fbXRbdGhpcy5fbiAtIDFdICYgdGhpcy5fdXBwZXJNYXNrKSB8ICh0aGlzLl9tdFswXSAmIHRoaXMuX2xvd2VyTWFzayk7XHJcbiAgICAgICAgICAgIHRoaXMuX210W3RoaXMuX24gLSAxXSA9IHRoaXMuX210W3RoaXMuX20gLSAxXSBeICh5ID4+PiAxKSBeIG1hZzAxW3kgJiAweDFdICYgQklUTUFTSzMyO1xyXG4gICAgICAgICAgICB0aGlzLl9pbmRleCA9IDA7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm4gbmV4dCAzMiBiaXQgaW50ZWdlciBudW1iZXIgaW4gc2VxdWVuY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5kb20ucHJvdG90eXBlLm5leHRJbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbmRleCA+PSB0aGlzLl9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90d2lzdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB5ID0gdGhpcy5fbXRbdGhpcy5faW5kZXgrK107XHJcbiAgICAgICAgICAgIHkgXj0geSA+Pj4gdGhpcy5fdTtcclxuICAgICAgICAgICAgeSBePSAoKHkgPDwgdGhpcy5fcykgJiB0aGlzLl9iKTtcclxuICAgICAgICAgICAgeSBePSAoKHkgPDwgdGhpcy5fdCkgJiB0aGlzLl9jKTtcclxuICAgICAgICAgICAgeSBePSAoeSA+Pj4gdGhpcy5fbCk7XHJcbiAgICAgICAgICAgIHJldHVybiB5ID4+PiAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJuIGEgcmFuZG9tIGZsb2F0aW5nIHBvaW50IG51bWJlciBiZXR3ZWVuIFswLCAxKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmRvbS5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dEludCgpICogKDEuMCAvIDQyOTQ5NjcyOTYuMCk7IC8vIGRpdmlkZWQgYnkgMl4zMlxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJuIGEgcmFuZG9tIGZsb2F0aW5nIHBvaW50IGluIHJhbmdlIFttaW4sIG1heCkgbWluIGlzIGluY2x1ZGVkLCBtYXggaXMgbm90IGluY2x1ZGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFuZG9tLnByb3RvdHlwZS5mbG9hdGluZyA9IGZ1bmN0aW9uIChtaW4sIG1heCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKG1heCAtIG1pbikgKiB0aGlzLm5leHQoKSArIG1pbjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybiBhIHJhbmRvbSBpbnRlZ2VyIGluIHJhbmdlIFttaW4sIG1heF0gbWluIGlzIGluY2x1ZGVkLCBtYXggaXMgaW5jbHVkZWQuXHJcbiAgICAgICAgICogSW1wbGVtZW50ZWQgd2l0aCByZWplY3Rpb24gc2FtcGxpbmcsIHNlZSBodHRwczovL21lZGl1bS5jb20vQGJldGFibGUvdGlmdS1ieS11c2luZy1tYXRoLXJhbmRvbS1mMWMzMDhjNGZkOWQjLmkxM3RkaXU1YVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmRvbS5wcm90b3R5cGUuaW50ZWdlciA9IGZ1bmN0aW9uIChtaW4sIG1heCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigobWF4IC0gbWluICsgMSkgKiB0aGlzLm5leHQoKSArIG1pbik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgb3IgZmFsc2UgcmFuZG9tbHkgd2l0aCA1MC81MCBvZGRzIGJ5IGRlZmF1bHQuXHJcbiAgICAgICAgICogQnkgZGVmYXVsdCB0aGUgbGlrZWxpaG9vZCBvZiByZXR1cm5pbmcgYSB0cnVlIGlzIC41ICg1MCUpLlxyXG4gICAgICAgICAqIEBwYXJhbSBsaWtlbGlob29kIHRha2VzIHZhbHVlcyBiZXR3ZWVuIFswLCAxXVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmRvbS5wcm90b3R5cGUuYm9vbCA9IGZ1bmN0aW9uIChsaWtlbGlob29kKSB7XHJcbiAgICAgICAgICAgIGlmIChsaWtlbGlob29kID09PSB2b2lkIDApIHsgbGlrZWxpaG9vZCA9IC41OyB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHQoKSA8PSBsaWtlbGlob29kO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBvbmUgZWxlbWVudCBmcm9tIGFuIGFycmF5IGF0IHJhbmRvbVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmRvbS5wcm90b3R5cGUucGlja09uZSA9IGZ1bmN0aW9uIChhcnJheSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXJyYXlbdGhpcy5pbnRlZ2VyKDAsIGFycmF5Lmxlbmd0aCAtIDEpXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBuZXcgYXJyYXkgcmFuZG9tIHBpY2tpbmcgZWxlbWVudHMgZnJvbSB0aGUgb3JpZ2luYWxcclxuICAgICAgICAgKiBAcGFyYW0gYXJyYXkgT3JpZ2luYWwgYXJyYXkgdG8gcGljayBmcm9tXHJcbiAgICAgICAgICogQHBhcmFtIG51bVBpY2tzIGNhbiBiZSBhbnkgcG9zaXRpdmUgbnVtYmVyXHJcbiAgICAgICAgICogQHBhcmFtIGFsbG93RHVwbGljYXRlcyBpbmRpY2F0ZXMgd2hldGhlciB0aGUgcmV0dXJuZWQgc2V0IGlzIGFsbG93ZWQgZHVwbGljYXRlcyAoaXQgZG9lcyBub3QgbWVhbiB0aGVyZSB3aWxsIGFsd2F5cyBiZSBkdXBsaWNhdGVzXHJcbiAgICAgICAgICoganVzdCB0aGF0IGl0IGlzIHBvc3NpYmxlKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmRvbS5wcm90b3R5cGUucGlja1NldCA9IGZ1bmN0aW9uIChhcnJheSwgbnVtUGlja3MsIGFsbG93RHVwbGljYXRlcykge1xyXG4gICAgICAgICAgICBpZiAoYWxsb3dEdXBsaWNhdGVzID09PSB2b2lkIDApIHsgYWxsb3dEdXBsaWNhdGVzID0gZmFsc2U7IH1cclxuICAgICAgICAgICAgaWYgKGFsbG93RHVwbGljYXRlcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BpY2tTZXRXaXRoRHVwbGljYXRlcyhhcnJheSwgbnVtUGlja3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BpY2tTZXRXaXRob3V0RHVwbGljYXRlcyhhcnJheSwgbnVtUGlja3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgbmV3IGFycmF5IHJhbmRvbWx5IHBpY2tpbmcgZWxlbWVudHMgaW4gdGhlIG9yaWdpbmFsIChub3QgcmV1c2VkKVxyXG4gICAgICAgICAqIEBwYXJhbSBudW1QaWNrcyBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBhcnJheS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5kb20ucHJvdG90eXBlLl9waWNrU2V0V2l0aG91dER1cGxpY2F0ZXMgPSBmdW5jdGlvbiAoYXJyYXksIG51bVBpY2tzKSB7XHJcbiAgICAgICAgICAgIGlmIChudW1QaWNrcyA+IGFycmF5Lmxlbmd0aCB8fCBudW1QaWNrcyA8IDApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBudW1iZXIgb2YgZWxlbWVudHMgdG8gcGljaywgbXVzdCBwaWNrIGEgdmFsdWUgMCA8IG4gPD0gbGVuZ3RoJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG51bVBpY2tzID09PSBhcnJheS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KG51bVBpY2tzKTtcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRQaWNrID0gMDtcclxuICAgICAgICAgICAgdmFyIHRlbXBBcnJheSA9IGFycmF5LnNsaWNlKDApO1xyXG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudFBpY2sgPCBudW1QaWNrcykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbnRlZ2VyKDAsIHRlbXBBcnJheS5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFtjdXJyZW50UGljaysrXSA9IHRlbXBBcnJheVtpbmRleF07XHJcbiAgICAgICAgICAgICAgICB0ZW1wQXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIG5ldyBhcnJheSByYW5kb20gcGlja2luZyBlbGVtZW50cyBmcm9tIHRoZSBvcmlnaW5hbCBhbGxvd2luZyBkdXBsaWNhdGVzXHJcbiAgICAgICAgICogQHBhcmFtIG51bVBpY2tzIGNhbiBiZSBhbnkgcG9zaXRpdmUgbnVtYmVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFuZG9tLnByb3RvdHlwZS5fcGlja1NldFdpdGhEdXBsaWNhdGVzID0gZnVuY3Rpb24gKGFycmF5LCBudW1QaWNrcykge1xyXG4gICAgICAgICAgICAvLyBUeXBlc2NyaXB0IG51bWJlcnMgYXJlIGFsbCBmbG9hdGluZyBwb2ludCwgc28gZG8gd2UgYWRkIGNoZWNrIGZvciBpbnQ/IChvciBmbG9vciB0aGUgaW5wdXQ/KVxyXG4gICAgICAgICAgICBpZiAobnVtUGlja3MgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHBpY2ssIG11c3QgcGljayBhIHZhbHVlIDAgPD0gbiA8IE1BWF9JTlQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KG51bVBpY2tzKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1QaWNrczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLnBpY2tPbmUoYXJyYXkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIG5ldyBhcnJheSB0aGF0IGhhcyBpdHMgZWxlbWVudHMgc2h1ZmZsZWQuIFVzaW5nIHRoZSBGaXNoZXIvWWF0ZXMgbWV0aG9kXHJcbiAgICAgICAgICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVyJUUyJTgwJTkzWWF0ZXNfc2h1ZmZsZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmRvbS5wcm90b3R5cGUuc2h1ZmZsZSA9IGZ1bmN0aW9uIChhcnJheSkge1xyXG4gICAgICAgICAgICB2YXIgdGVtcEFycmF5ID0gYXJyYXkuc2xpY2UoMCk7XHJcbiAgICAgICAgICAgIHZhciBzd2FwID0gbnVsbDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZW1wQXJyYXkubGVuZ3RoIC0gMjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmFuZG9tSW5kZXggPSB0aGlzLmludGVnZXIoaSwgdGVtcEFycmF5Lmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgc3dhcCA9IHRlbXBBcnJheVtpXTtcclxuICAgICAgICAgICAgICAgIHRlbXBBcnJheVtpXSA9IHRlbXBBcnJheVtyYW5kb21JbmRleF07XHJcbiAgICAgICAgICAgICAgICB0ZW1wQXJyYXlbcmFuZG9tSW5kZXhdID0gc3dhcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGVtcEFycmF5O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2VuZXJhdGUgYSBsaXN0IG9mIHJhbmRvbSBpbnRlZ2VyIG51bWJlcnNcclxuICAgICAgICAgKiBAcGFyYW0gbGVuZ3RoIHRoZSBsZW5ndGggb2YgdGhlIGZpbmFsIGFycmF5XHJcbiAgICAgICAgICogQHBhcmFtIG1pbiB0aGUgbWluaW11bSBpbnRlZ2VyIG51bWJlciB0byBnZW5lcmF0ZSBpbmNsdXNpdmVcclxuICAgICAgICAgKiBAcGFyYW0gbWF4IHRoZSBtYXhpbXVtIGludGVnZXIgbnVtYmVyIHRvIGdlbmVyYXRlIGluY2x1c2l2ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmRvbS5wcm90b3R5cGUucmFuZ2UgPSBmdW5jdGlvbiAobGVuZ3RoLCBtaW4sIG1heCkge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KGxlbmd0aCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IHRoaXMuaW50ZWdlcihtaW4sIG1heCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiBhIGQ0IGRpY2Ugcm9sbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmRvbS5wcm90b3R5cGUuZDQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVnZXIoMSwgNCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYSBkNiBkaWNlIHJvbGxcclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5kb20ucHJvdG90eXBlLmQ2ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlZ2VyKDEsIDYpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIGEgZDggZGljZSByb2xsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFuZG9tLnByb3RvdHlwZS5kOCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZWdlcigxLCA4KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiBhIGQxMCBkaWNlIHJvbGxcclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5kb20ucHJvdG90eXBlLmQxMCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZWdlcigxLCAxMCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYSBkMTIgZGljZSByb2xsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFuZG9tLnByb3RvdHlwZS5kMTIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVnZXIoMSwgMTIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIGEgZDIwIGRpY2Ugcm9sbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmRvbS5wcm90b3R5cGUuZDIwID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlZ2VyKDEsIDIwKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBSYW5kb207XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5SYW5kb20gPSBSYW5kb207XHJcbn0pO1xyXG5kZWZpbmUoXCJDb2xsaXNpb24vU2lkZVwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBlbnVtIHRoYXQgZGVzY3JpYmVzIHRoZSBzaWRlcyBvZiBhbiBBY3RvciBmb3IgY29sbGlzaW9uXHJcbiAgICAgKi9cclxuICAgIHZhciBTaWRlO1xyXG4gICAgKGZ1bmN0aW9uIChTaWRlKSB7XHJcbiAgICAgICAgU2lkZVtTaWRlW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XHJcbiAgICAgICAgU2lkZVtTaWRlW1wiVG9wXCJdID0gMV0gPSBcIlRvcFwiO1xyXG4gICAgICAgIFNpZGVbU2lkZVtcIkJvdHRvbVwiXSA9IDJdID0gXCJCb3R0b21cIjtcclxuICAgICAgICBTaWRlW1NpZGVbXCJMZWZ0XCJdID0gM10gPSBcIkxlZnRcIjtcclxuICAgICAgICBTaWRlW1NpZGVbXCJSaWdodFwiXSA9IDRdID0gXCJSaWdodFwiO1xyXG4gICAgfSkoU2lkZSA9IGV4cG9ydHMuU2lkZSB8fCAoZXhwb3J0cy5TaWRlID0ge30pKTtcclxufSk7XHJcbmRlZmluZShcIlV0aWwvVXRpbFwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkFsZ2VicmFcIiwgXCJNYXRoL1JhbmRvbVwiLCBcIkNvbGxpc2lvbi9TaWRlXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgQWxnZWJyYV8yLCBSYW5kb21fMSwgU2lkZV8xKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogVHdvIFBJIGNvbnN0YW50XHJcbiAgICAgKi9cclxuICAgIGV4cG9ydHMuVHdvUEkgPSBNYXRoLlBJICogMjtcclxuICAgIC8qKlxyXG4gICAgICogTWVyZ2VzIG9uZSBvciBtb3JlIG9iamVjdHMgaW50byBhIHNpbmdsZSB0YXJnZXQgb2JqZWN0XHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgTWVyZ2VkIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgZnJvbSBvdGhlciBvYmplY3RzXHJcbiAgICAgKiBAY3JlZGl0IGh0dHBzOi8vZ29tYWtldGhpbmdzLmNvbS92YW5pbGxhLWphdmFzY3JpcHQtdmVyc2lvbi1vZi1qcXVlcnktZXh0ZW5kL1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBleHRlbmQoKSB7XHJcbiAgICAgICAgdmFyIGV4dGVuZGVkID0ge307XHJcbiAgICAgICAgdmFyIGRlZXAgPSBmYWxzZTtcclxuICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgYSBkZWVwIG1lcmdlXHJcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmd1bWVudHNbMF0pID09PSAnW29iamVjdCBCb29sZWFuXScpIHtcclxuICAgICAgICAgICAgZGVlcCA9IGFyZ3VtZW50c1swXTtcclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBNZXJnZSB0aGUgb2JqZWN0IGludG8gdGhlIGV4dGVuZGVkIG9iamVjdFxyXG4gICAgICAgIHZhciBhc3NpZ25FeGlzdHMgPSB0eXBlb2YgT2JqZWN0LmFzc2lnbiA9PT0gJ2Z1bmN0aW9uJztcclxuICAgICAgICB2YXIgbWVyZ2UgPSBudWxsO1xyXG4gICAgICAgIGlmICghYXNzaWduRXhpc3RzKSB7XHJcbiAgICAgICAgICAgIG1lcmdlID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgZGVlcCBtZXJnZSBhbmQgcHJvcGVydHkgaXMgYW4gb2JqZWN0LCBtZXJnZSBwcm9wZXJ0aWVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWVwICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmpbcHJvcF0pID09PSAnW29iamVjdCBPYmplY3RdJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kZWRbcHJvcF0gPSBleHRlbmQodHJ1ZSwgZXh0ZW5kZWRbcHJvcF0sIG9ialtwcm9wXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbmRlZFtwcm9wXSA9IG9ialtwcm9wXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG1lcmdlID0gT2JqZWN0LmFzc2lnbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTG9vcCB0aHJvdWdoIGVhY2ggb2JqZWN0IGFuZCBjb25kdWN0IGEgbWVyZ2VcclxuICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBvYmogPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGlmICghYXNzaWduRXhpc3RzKSB7XHJcbiAgICAgICAgICAgICAgICBtZXJnZShvYmopO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbWVyZ2UoZXh0ZW5kZWQsIG9iaik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZGVkO1xyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5leHRlbmQgPSBleHRlbmQ7XHJcbiAgICBmdW5jdGlvbiBiYXNlNjRFbmNvZGUoaW5wdXRTdHIpIHtcclxuICAgICAgICB2YXIgYjY0ID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89JztcclxuICAgICAgICB2YXIgb3V0cHV0U3RyID0gJyc7XHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgIHdoaWxlIChpIDwgaW5wdXRTdHIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIC8vYWxsIHRocmVlIFwiJiAweGZmXCIgYWRkZWQgYmVsb3cgYXJlIHRoZXJlIHRvIGZpeCBhIGtub3duIGJ1Z1xyXG4gICAgICAgICAgICAvL3dpdGggYnl0ZXMgcmV0dXJuZWQgYnkgeGhyLnJlc3BvbnNlVGV4dFxyXG4gICAgICAgICAgICB2YXIgYnl0ZTEgPSBpbnB1dFN0ci5jaGFyQ29kZUF0KGkrKykgJiAweGZmO1xyXG4gICAgICAgICAgICB2YXIgYnl0ZTIgPSBpbnB1dFN0ci5jaGFyQ29kZUF0KGkrKykgJiAweGZmO1xyXG4gICAgICAgICAgICB2YXIgYnl0ZTMgPSBpbnB1dFN0ci5jaGFyQ29kZUF0KGkrKykgJiAweGZmO1xyXG4gICAgICAgICAgICB2YXIgZW5jMSA9IGJ5dGUxID4+IDI7XHJcbiAgICAgICAgICAgIHZhciBlbmMyID0gKChieXRlMSAmIDMpIDw8IDQpIHwgKGJ5dGUyID4+IDQpO1xyXG4gICAgICAgICAgICB2YXIgZW5jMywgZW5jNDtcclxuICAgICAgICAgICAgaWYgKGlzTmFOKGJ5dGUyKSkge1xyXG4gICAgICAgICAgICAgICAgZW5jMyA9IGVuYzQgPSA2NDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGVuYzMgPSAoKGJ5dGUyICYgMTUpIDw8IDIpIHwgKGJ5dGUzID4+IDYpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKGJ5dGUzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVuYzQgPSA2NDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGVuYzQgPSBieXRlMyAmIDYzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG91dHB1dFN0ciArPSBiNjQuY2hhckF0KGVuYzEpICsgYjY0LmNoYXJBdChlbmMyKSArIGI2NC5jaGFyQXQoZW5jMykgKyBiNjQuY2hhckF0KGVuYzQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3V0cHV0U3RyO1xyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5iYXNlNjRFbmNvZGUgPSBiYXNlNjRFbmNvZGU7XHJcbiAgICAvKipcclxuICAgICAqIENsYW1wcyBhIHZhbHVlIGJldHdlZW4gYSBtaW4gYW5kIG1heCBpbmNsdXNpdmVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY2xhbXAodmFsLCBtaW4sIG1heCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChtaW4sIHZhbCksIG1heCk7XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLmNsYW1wID0gY2xhbXA7XHJcbiAgICBmdW5jdGlvbiByYW5kb21JblJhbmdlKG1pbiwgbWF4LCByYW5kb20pIHtcclxuICAgICAgICBpZiAocmFuZG9tID09PSB2b2lkIDApIHsgcmFuZG9tID0gbmV3IFJhbmRvbV8xLlJhbmRvbSgpOyB9XHJcbiAgICAgICAgcmV0dXJuIHJhbmRvbSA/IHJhbmRvbS5mbG9hdGluZyhtaW4sIG1heCkgOiBtaW4gKyBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbik7XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLnJhbmRvbUluUmFuZ2UgPSByYW5kb21JblJhbmdlO1xyXG4gICAgZnVuY3Rpb24gcmFuZG9tSW50SW5SYW5nZShtaW4sIG1heCwgcmFuZG9tKSB7XHJcbiAgICAgICAgaWYgKHJhbmRvbSA9PT0gdm9pZCAwKSB7IHJhbmRvbSA9IG5ldyBSYW5kb21fMS5SYW5kb20oKTsgfVxyXG4gICAgICAgIHJldHVybiByYW5kb20gPyByYW5kb20uaW50ZWdlcihtaW4sIG1heCkgOiBNYXRoLnJvdW5kKHJhbmRvbUluUmFuZ2UobWluLCBtYXgpKTtcclxuICAgIH1cclxuICAgIGV4cG9ydHMucmFuZG9tSW50SW5SYW5nZSA9IHJhbmRvbUludEluUmFuZ2U7XHJcbiAgICBmdW5jdGlvbiBjYW5vbmljYWxpemVBbmdsZShhbmdsZSkge1xyXG4gICAgICAgIHZhciB0bXBBbmdsZSA9IGFuZ2xlO1xyXG4gICAgICAgIGlmIChhbmdsZSA+IGV4cG9ydHMuVHdvUEkpIHtcclxuICAgICAgICAgICAgd2hpbGUgKHRtcEFuZ2xlID4gZXhwb3J0cy5Ud29QSSkge1xyXG4gICAgICAgICAgICAgICAgdG1wQW5nbGUgLT0gZXhwb3J0cy5Ud29QSTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYW5nbGUgPCAwKSB7XHJcbiAgICAgICAgICAgIHdoaWxlICh0bXBBbmdsZSA8IDApIHtcclxuICAgICAgICAgICAgICAgIHRtcEFuZ2xlICs9IGV4cG9ydHMuVHdvUEk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRtcEFuZ2xlO1xyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5jYW5vbmljYWxpemVBbmdsZSA9IGNhbm9uaWNhbGl6ZUFuZ2xlO1xyXG4gICAgZnVuY3Rpb24gdG9EZWdyZWVzKHJhZGlhbnMpIHtcclxuICAgICAgICByZXR1cm4gMTgwIC8gTWF0aC5QSSAqIHJhZGlhbnM7XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLnRvRGVncmVlcyA9IHRvRGVncmVlcztcclxuICAgIGZ1bmN0aW9uIHRvUmFkaWFucyhkZWdyZWVzKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlZ3JlZXMgLyAxODAgKiBNYXRoLlBJO1xyXG4gICAgfVxyXG4gICAgZXhwb3J0cy50b1JhZGlhbnMgPSB0b1JhZGlhbnM7XHJcbiAgICBmdW5jdGlvbiBnZXRQb3NpdGlvbihlbCkge1xyXG4gICAgICAgIHZhciBvTGVmdCA9IDAsIG9Ub3AgPSAwO1xyXG4gICAgICAgIHZhciBjYWxjT2Zmc2V0TGVmdCA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgb0xlZnQgKz0gcGFyZW50Lm9mZnNldExlZnQ7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnQub2Zmc2V0UGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBjYWxjT2Zmc2V0TGVmdChwYXJlbnQub2Zmc2V0UGFyZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIGNhbGNPZmZzZXRUb3AgPSBmdW5jdGlvbiAocGFyZW50KSB7XHJcbiAgICAgICAgICAgIG9Ub3AgKz0gcGFyZW50Lm9mZnNldFRvcDtcclxuICAgICAgICAgICAgaWYgKHBhcmVudC5vZmZzZXRQYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGNhbGNPZmZzZXRUb3AocGFyZW50Lm9mZnNldFBhcmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGNhbGNPZmZzZXRMZWZ0KGVsKTtcclxuICAgICAgICBjYWxjT2Zmc2V0VG9wKGVsKTtcclxuICAgICAgICByZXR1cm4gbmV3IEFsZ2VicmFfMi5WZWN0b3Iob0xlZnQsIG9Ub3ApO1xyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5nZXRQb3NpdGlvbiA9IGdldFBvc2l0aW9uO1xyXG4gICAgZnVuY3Rpb24gYWRkSXRlbVRvQXJyYXkoaXRlbSwgYXJyYXkpIHtcclxuICAgICAgICBpZiAoYXJyYXkuaW5kZXhPZihpdGVtKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgYXJyYXkucHVzaChpdGVtKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGV4cG9ydHMuYWRkSXRlbVRvQXJyYXkgPSBhZGRJdGVtVG9BcnJheTtcclxuICAgIGZ1bmN0aW9uIHJlbW92ZUl0ZW1Gcm9tQXJyYXkoaXRlbSwgYXJyYXkpIHtcclxuICAgICAgICB2YXIgaW5kZXggPSAtMTtcclxuICAgICAgICBpZiAoKGluZGV4ID0gYXJyYXkuaW5kZXhPZihpdGVtKSkgPiAtMSkge1xyXG4gICAgICAgICAgICBhcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5yZW1vdmVJdGVtRnJvbUFycmF5ID0gcmVtb3ZlSXRlbUZyb21BcnJheTtcclxuICAgIGZ1bmN0aW9uIGNvbnRhaW5zKGFycmF5LCBvYmopIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChhcnJheVtpXSA9PT0gb2JqKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLmNvbnRhaW5zID0gY29udGFpbnM7XHJcbiAgICBmdW5jdGlvbiBnZXRPcHBvc2l0ZVNpZGUoc2lkZSkge1xyXG4gICAgICAgIGlmIChzaWRlID09PSBTaWRlXzEuU2lkZS5Ub3ApIHtcclxuICAgICAgICAgICAgcmV0dXJuIFNpZGVfMS5TaWRlLkJvdHRvbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNpZGUgPT09IFNpZGVfMS5TaWRlLkJvdHRvbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gU2lkZV8xLlNpZGUuVG9wO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2lkZSA9PT0gU2lkZV8xLlNpZGUuTGVmdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gU2lkZV8xLlNpZGUuUmlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaWRlID09PSBTaWRlXzEuU2lkZS5SaWdodCkge1xyXG4gICAgICAgICAgICByZXR1cm4gU2lkZV8xLlNpZGUuTGVmdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFNpZGVfMS5TaWRlLk5vbmU7XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLmdldE9wcG9zaXRlU2lkZSA9IGdldE9wcG9zaXRlU2lkZTtcclxuICAgIGZ1bmN0aW9uIGdldFNpZGVGcm9tVmVjdG9yKGRpcmVjdGlvbikge1xyXG4gICAgICAgIHZhciBkaXJlY3Rpb25zID0gW0FsZ2VicmFfMi5WZWN0b3IuTGVmdCwgQWxnZWJyYV8yLlZlY3Rvci5SaWdodCwgQWxnZWJyYV8yLlZlY3Rvci5VcCwgQWxnZWJyYV8yLlZlY3Rvci5Eb3duXTtcclxuICAgICAgICB2YXIgZGlyZWN0aW9uRW51bSA9IFtTaWRlXzEuU2lkZS5MZWZ0LCBTaWRlXzEuU2lkZS5SaWdodCwgU2lkZV8xLlNpZGUuVG9wLCBTaWRlXzEuU2lkZS5Cb3R0b21dO1xyXG4gICAgICAgIHZhciBtYXggPSAtTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICB2YXIgbWF4SW5kZXggPSAtMTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcmVjdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbnNbaV0uZG90KGRpcmVjdGlvbikgPiBtYXgpIHtcclxuICAgICAgICAgICAgICAgIG1heCA9IGRpcmVjdGlvbnNbaV0uZG90KGRpcmVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICBtYXhJbmRleCA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRpcmVjdGlvbkVudW1bbWF4SW5kZXhdO1xyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5nZXRTaWRlRnJvbVZlY3RvciA9IGdldFNpZGVGcm9tVmVjdG9yO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFeGNhbGlidXIncyBkeW5hbWljYWxseSByZXNpemluZyBjb2xsZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIHZhciBDb2xsZWN0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gaW5pdGlhbFNpemUgIEluaXRpYWwgc2l6ZSBvZiB0aGUgaW50ZXJuYWwgYmFja2luZyBhcnJheVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIENvbGxlY3Rpb24oaW5pdGlhbFNpemUpIHtcclxuICAgICAgICAgICAgaWYgKGluaXRpYWxTaXplID09PSB2b2lkIDApIHsgaW5pdGlhbFNpemUgPSBDb2xsZWN0aW9uLkRlZmF1bHRTaXplOyB9XHJcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsQXJyYXkgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl9lbmRQb2ludGVyID0gMDtcclxuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxBcnJheSA9IG5ldyBBcnJheShpbml0aWFsU2l6ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLl9yZXNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBuZXdTaXplID0gdGhpcy5faW50ZXJuYWxBcnJheS5sZW5ndGggKiAyO1xyXG4gICAgICAgICAgICB2YXIgbmV3QXJyYXkgPSBuZXcgQXJyYXkobmV3U2l6ZSk7XHJcbiAgICAgICAgICAgIHZhciBjb3VudCA9IHRoaXMuY291bnQoKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdBcnJheVtpXSA9IHRoaXMuX2ludGVybmFsQXJyYXlbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2ludGVybmFsQXJyYXk7XHJcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsQXJyYXkgPSBuZXdBcnJheTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFB1c2ggZWxlbWVudHMgdG8gdGhlIGVuZCBvZiB0aGUgY29sbGVjdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fZW5kUG9pbnRlciA9PT0gdGhpcy5faW50ZXJuYWxBcnJheS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbEFycmF5W3RoaXMuX2VuZFBvaW50ZXIrK10gPSBlbGVtZW50O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlcyBlbGVtZW50cyBmcm9tIHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZFBvaW50ZXIgPSB0aGlzLl9lbmRQb2ludGVyIC0gMSA8IDAgPyAwIDogdGhpcy5fZW5kUG9pbnRlciAtIDE7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbEFycmF5W3RoaXMuX2VuZFBvaW50ZXJdO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgY291bnQgb2YgdGhlIGNvbGxlY3Rpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VuZFBvaW50ZXI7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbXB0aWVzIHRoZSBjb2xsZWN0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZFBvaW50ZXIgPSAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgaW50ZXJuYWwgYmFja2luZyBhcnJheVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmludGVybmFsU2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsQXJyYXkubGVuZ3RoO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhbiBlbGVtZW50IGF0IGEgc3BlY2lmaWMgaW5kZXhcclxuICAgICAgICAgKiBAcGFyYW0gaW5kZXggIEluZGV4IG9mIGVsZW1lbnQgdG8gcmV0cmlldmVcclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5lbGVtZW50QXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID49IHRoaXMuY291bnQoKSkge1xyXG4gICAgICAgICAgICAgICAgLy9Mb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcignSW52YWxpZCBwYXJhbWV0ZXI6ICcgKyBpbmRleCk7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5kZXggJyArIGluZGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxBcnJheVtpbmRleF07XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbnNlcnRzIGFuIGVsZW1lbnQgYXQgYSBzcGVjaWZpYyBpbmRleFxyXG4gICAgICAgICAqIEBwYXJhbSBpbmRleCAgSW5kZXggdG8gaW5zZXJ0IHRoZSBlbGVtZW50XHJcbiAgICAgICAgICogQHBhcmFtIHZhbHVlICBFbGVtZW50IHRvIGluc2VydFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChpbmRleCwgdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID49IHRoaXMuY291bnQoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzaXplKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsQXJyYXlbaW5kZXhdID0gdmFsdWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGFuIGVsZW1lbnQgYXQgYSBzcGVjaWZpYyBpbmRleFxyXG4gICAgICAgICAqIEBwYXJhbSBpbmRleCAgSW5kZXggb2YgZWxlbWVudCB0byByZW1vdmVcclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5jb3VudCgpO1xyXG4gICAgICAgICAgICBpZiAoY291bnQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIC8vTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoJ0ludmFsaWQgcGFyYW1ldGVyOiAnICsgaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhcmFtZXRlciAnICsgaW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE8obikgU2hpZnRcclxuICAgICAgICAgICAgdmFyIHJlbW92ZWQgPSB0aGlzLl9pbnRlcm5hbEFycmF5W2luZGV4XTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGluZGV4OyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxBcnJheVtpXSA9IHRoaXMuX2ludGVybmFsQXJyYXlbaSArIDFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZFBvaW50ZXItLTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlbW92ZWQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGFuIGVsZW1lbnQgYnkgcmVmZXJlbmNlXHJcbiAgICAgICAgICogQHBhcmFtIGVsZW1lbnQgIEVsZW1lbnQgdG8gcmV0cmlldmVcclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5faW50ZXJuYWxBcnJheS5pbmRleE9mKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZShpbmRleCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBjb2xsZWN0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsQXJyYXkuc2xpY2UoMCwgdGhpcy5fZW5kUG9pbnRlcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJdGVyYXRlIG92ZXIgZXZlcnkgZWxlbWVudCBpbiB0aGUgY29sbGVjdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSBmdW5jICBDYWxsYmFjayB0byBjYWxsIGZvciBlYWNoIGVsZW1lbnQgcGFzc2luZyBhIHJlZmVyZW5jZSB0byB0aGUgZWxlbWVudCBhbmQgaXRzIGluZGV4LCByZXR1cm5lZCB2YWx1ZXMgYXJlIGlnbm9yZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGZ1bmMpIHtcclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBjb3VudCA9IHRoaXMuY291bnQoKTtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgZnVuYy5jYWxsKHRoaXMsIHRoaXMuX2ludGVybmFsQXJyYXlbaV0sIGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNdXRhdGUgZXZlcnkgZWxlbWVudCBpbiB0aGUgY29sbGVjdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSBmdW5jICBDYWxsYmFjayB0byBjYWxsIGZvciBlYWNoIGVsZW1lbnQgcGFzc2luZyBhIHJlZmVyZW5jZSB0byB0aGUgZWxlbWVudCBhbmQgaXRzIGluZGV4LCBhbnkgdmFsdWVzIHJldHVybmVkIG11dGF0ZVxyXG4gICAgICAgICAqIHRoZSBjb2xsZWN0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGZ1bmMpIHtcclxuICAgICAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5jb3VudCgpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ludGVybmFsQXJyYXlbaV0gPSBmdW5jLmNhbGwodGhpcywgdGhpcy5faW50ZXJuYWxBcnJheVtpXSwgaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBDb2xsZWN0aW9uO1xyXG4gICAgfSgpKTtcclxuICAgIC8qKlxyXG4gICAgICogRGVmYXVsdCBjb2xsZWN0aW9uIHNpemVcclxuICAgICAqL1xyXG4gICAgQ29sbGVjdGlvbi5EZWZhdWx0U2l6ZSA9IDIwMDtcclxuICAgIGV4cG9ydHMuQ29sbGVjdGlvbiA9IENvbGxlY3Rpb247XHJcbn0pO1xyXG5kZWZpbmUoXCJDYW1lcmFcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJVdGlsL0Vhc2luZ0Z1bmN0aW9uc1wiLCBcIlByb21pc2VzXCIsIFwiQWxnZWJyYVwiLCBcIlV0aWwvVXRpbFwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIEVhc2luZ0Z1bmN0aW9uc18xLCBQcm9taXNlc18xLCBBbGdlYnJhXzMsIFV0aWxfMSkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIENvbnRhaW5lciB0byBob3VzZSBjb252ZW5pZW5jZSBzdHJhdGVneSBtZXRob2RzXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgdmFyIFN0cmF0ZWd5Q29udGFpbmVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBTdHJhdGVneUNvbnRhaW5lcihjYW1lcmEpIHtcclxuICAgICAgICAgICAgdGhpcy5jYW1lcmEgPSBjYW1lcmE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYW5kIGFkZHMgdGhlIFtbTG9ja0NhbWVyYVRvQWN0b3JTdHJhdGVneV1dIG9uIHRoZSBjdXJyZW50IGNhbWVyYS5cclxuICAgICAgICAgKiBAcGFyYW0gYWN0b3IgVGhlIGFjdG9yIHRvIGxvY2sgdGhlIGNhbWVyYSB0b1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFN0cmF0ZWd5Q29udGFpbmVyLnByb3RvdHlwZS5sb2NrVG9BY3RvciA9IGZ1bmN0aW9uIChhY3Rvcikge1xyXG4gICAgICAgICAgICB0aGlzLmNhbWVyYS5hZGRTdHJhdGVneShuZXcgTG9ja0NhbWVyYVRvQWN0b3JTdHJhdGVneShhY3RvcikpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhbmQgYWRkcyB0aGUgW1tMb2NrQ2FtZXJhVG9BY3RvckF4aXNTdHJhdGVneV1dIG9uIHRoZSBjdXJyZW50IGNhbWVyYVxyXG4gICAgICAgICAqIEBwYXJhbSBhY3RvciBUaGUgYWN0b3IgdG8gbG9jayB0aGUgY2FtZXJhIHRvXHJcbiAgICAgICAgICogQHBhcmFtIGF4aXMgVGhlIGF4aXMgdG8gZm9sbG93IHRoZSBhY3RvciBvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFN0cmF0ZWd5Q29udGFpbmVyLnByb3RvdHlwZS5sb2NrVG9BY3RvckF4aXMgPSBmdW5jdGlvbiAoYWN0b3IsIGF4aXMpIHtcclxuICAgICAgICAgICAgdGhpcy5jYW1lcmEuYWRkU3RyYXRlZ3kobmV3IExvY2tDYW1lcmFUb0FjdG9yQXhpc1N0cmF0ZWd5KGFjdG9yLCBheGlzKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGFuZCBhZGRzIHRoZSBbW0VsYXN0aWNUb0FjdG9yU3RyYXRlZ3ldXSBvbiB0aGUgY3VycmVudCBjYW1lcmFcclxuICAgICAgICAgKiBJZiBjYW1lcmFFbGFzdGljaXR5IDwgY2FtZXJhRnJpY3Rpb24gPCAxLjAsIHRoZSBiZWhhdmlvciB3aWxsIGJlIGEgZGFtcGVuZWQgc3ByaW5nIHRoYXQgd2lsbCBzbG93bHkgZW5kIGF0IHRoZSB0YXJnZXQgd2l0aG91dCBib3VuY2luZ1xyXG4gICAgICAgICAqIElmIGNhbWVyYUZyaWN0aW9uIDwgY2FtZXJhRWxhc3RpY2l0eSA8IDEuMCwgdGhlIGJlaGF2aW9yIHdpbGwgYmUgYW4gb3NjaWxsYXRpb25nIHNwcmluZyB0aGF0IHdpbGwgb3ZlclxyXG4gICAgICAgICAqIGNvcnJlY3QgYW5kIGJvdW5jZSBhcm91bmQgdGhlIHRhcmdldFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHRhcmdldCBUYXJnZXQgYWN0b3IgdG8gZWxhc3RpY2FsbHkgZm9sbG93XHJcbiAgICAgICAgICogQHBhcmFtIGNhbWVyYUVsYXN0aWNpdHkgWzAgLSAxLjBdIFRoZSBoaWdoZXIgdGhlIGVsYXN0aWNpdHkgdGhlIG1vcmUgZm9yY2UgdGhhdCB3aWxsIGRyaXZlIHRoZSBjYW1lcmEgdG93YXJkcyB0aGUgdGFyZ2V0XHJcbiAgICAgICAgICogQHBhcmFtIGNhbWVyYUZyaWN0aW9uIFswIC0gMS4wXSBUaGUgaGlnaGVyIHRoZSBmcmljdGlvbiB0aGUgbW9yZSB0aGF0IHRoZSBjYW1lcmEgd2lsbCByZXNpc3QgbW90aW9uIHRvd2FyZHMgdGhlIHRhcmdldFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFN0cmF0ZWd5Q29udGFpbmVyLnByb3RvdHlwZS5lbGFzdGljVG9BY3RvciA9IGZ1bmN0aW9uIChhY3RvciwgY2FtZXJhRWxhc3RpY2l0eSwgY2FtZXJhRnJpY3Rpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5jYW1lcmEuYWRkU3RyYXRlZ3kobmV3IEVsYXN0aWNUb0FjdG9yU3RyYXRlZ3koYWN0b3IsIGNhbWVyYUVsYXN0aWNpdHksIGNhbWVyYUZyaWN0aW9uKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGFuZCBhZGRzIHRoZSBbW1JhZGl1c0Fyb3VuZEFjdG9yU3RyYXRlZ3ldXSBvbiB0aGUgY3VycmVudCBjYW1lcmFcclxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRhcmdldCBhY3RvciB0byBmb2xsb3cgd2hlbiBpdCBpcyBcInJhZGl1c1wiIHBpeGVscyBhd2F5XHJcbiAgICAgICAgICogQHBhcmFtIHJhZGl1cyBOdW1iZXIgb2YgcGl4ZWxzIGF3YXkgYmVmb3JlIHRoZSBjYW1lcmEgd2lsbCBmb2xsb3dcclxuICAgICAgICAgKi9cclxuICAgICAgICBTdHJhdGVneUNvbnRhaW5lci5wcm90b3R5cGUucmFkaXVzQXJvdW5kQWN0b3IgPSBmdW5jdGlvbiAoYWN0b3IsIHJhZGl1cykge1xyXG4gICAgICAgICAgICB0aGlzLmNhbWVyYS5hZGRTdHJhdGVneShuZXcgUmFkaXVzQXJvdW5kQWN0b3JTdHJhdGVneShhY3RvciwgcmFkaXVzKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gU3RyYXRlZ3lDb250YWluZXI7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5TdHJhdGVneUNvbnRhaW5lciA9IFN0cmF0ZWd5Q29udGFpbmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYW1lcmEgYXhpcyBlbnVtXHJcbiAgICAgKi9cclxuICAgIHZhciBBeGlzO1xyXG4gICAgKGZ1bmN0aW9uIChBeGlzKSB7XHJcbiAgICAgICAgQXhpc1tBeGlzW1wiWFwiXSA9IDBdID0gXCJYXCI7XHJcbiAgICAgICAgQXhpc1tBeGlzW1wiWVwiXSA9IDFdID0gXCJZXCI7XHJcbiAgICB9KShBeGlzID0gZXhwb3J0cy5BeGlzIHx8IChleHBvcnRzLkF4aXMgPSB7fSkpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBMb2NrIGEgY2FtZXJhIHRvIHRoZSBleGFjdCB4L3kgcG9zdGl0aW9uIG9mIGFuIGFjdG9yLlxyXG4gICAgICovXHJcbiAgICB2YXIgTG9ja0NhbWVyYVRvQWN0b3JTdHJhdGVneSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gTG9ja0NhbWVyYVRvQWN0b3JTdHJhdGVneSh0YXJnZXQpIHtcclxuICAgICAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uID0gZnVuY3Rpb24gKHRhcmdldCwgX2NhbSwgX2VuZywgX2RlbHRhKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2VudGVyID0gdGFyZ2V0LmdldENlbnRlcigpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNlbnRlcjtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIExvY2tDYW1lcmFUb0FjdG9yU3RyYXRlZ3k7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5Mb2NrQ2FtZXJhVG9BY3RvclN0cmF0ZWd5ID0gTG9ja0NhbWVyYVRvQWN0b3JTdHJhdGVneTtcclxuICAgIC8qKlxyXG4gICAgICogTG9jayBhIGNhbWVyYSB0byBhIHNwZWNpZmljIGF4aXMgYXJvdW5kIGFuIGFjdG9yLlxyXG4gICAgICovXHJcbiAgICB2YXIgTG9ja0NhbWVyYVRvQWN0b3JBeGlzU3RyYXRlZ3kgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIExvY2tDYW1lcmFUb0FjdG9yQXhpc1N0cmF0ZWd5KHRhcmdldCwgYXhpcykge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgdGhpcy5heGlzID0gYXhpcztcclxuICAgICAgICAgICAgdGhpcy5hY3Rpb24gPSBmdW5jdGlvbiAodGFyZ2V0LCBjYW0sIF9lbmcsIF9kZWx0YSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNlbnRlciA9IHRhcmdldC5nZXRDZW50ZXIoKTtcclxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50Rm9jdXMgPSBjYW0uZ2V0Rm9jdXMoKTtcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5heGlzID09PSBBeGlzLlgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFsZ2VicmFfMy5WZWN0b3IoY2VudGVyLngsIGN1cnJlbnRGb2N1cy55KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWxnZWJyYV8zLlZlY3RvcihjdXJyZW50Rm9jdXMueCwgY2VudGVyLnkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gTG9ja0NhbWVyYVRvQWN0b3JBeGlzU3RyYXRlZ3k7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5Mb2NrQ2FtZXJhVG9BY3RvckF4aXNTdHJhdGVneSA9IExvY2tDYW1lcmFUb0FjdG9yQXhpc1N0cmF0ZWd5O1xyXG4gICAgLyoqXHJcbiAgICAgKiBVc2luZyBbSG9vaydzIGxhd10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSG9va2Unc19sYXcpLCBlbGFzdGljYWxseSBtb3ZlIHRoZSBjYW1lcmEgdG93YXJkcyB0aGUgdGFyZ2V0IGFjdG9yLlxyXG4gICAgICovXHJcbiAgICB2YXIgRWxhc3RpY1RvQWN0b3JTdHJhdGVneSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgY2FtZXJhRWxhc3RpY2l0eSA8IGNhbWVyYUZyaWN0aW9uIDwgMS4wLCB0aGUgYmVoYXZpb3Igd2lsbCBiZSBhIGRhbXBlbmVkIHNwcmluZyB0aGF0IHdpbGwgc2xvd2x5IGVuZCBhdCB0aGUgdGFyZ2V0IHdpdGhvdXQgYm91bmNpbmdcclxuICAgICAgICAgKiBJZiBjYW1lcmFGcmljdGlvbiA8IGNhbWVyYUVsYXN0aWNpdHkgPCAxLjAsIHRoZSBiZWhhdmlvciB3aWxsIGJlIGFuIG9zY2lsbGF0aW9uZyBzcHJpbmcgdGhhdCB3aWxsIG92ZXJcclxuICAgICAgICAgKiBjb3JyZWN0IGFuZCBib3VuY2UgYXJvdW5kIHRoZSB0YXJnZXRcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB0YXJnZXQgVGFyZ2V0IGFjdG9yIHRvIGVsYXN0aWNhbGx5IGZvbGxvd1xyXG4gICAgICAgICAqIEBwYXJhbSBjYW1lcmFFbGFzdGljaXR5IFswIC0gMS4wXSBUaGUgaGlnaGVyIHRoZSBlbGFzdGljaXR5IHRoZSBtb3JlIGZvcmNlIHRoYXQgd2lsbCBkcml2ZSB0aGUgY2FtZXJhIHRvd2FyZHMgdGhlIHRhcmdldFxyXG4gICAgICAgICAqIEBwYXJhbSBjYW1lcmFGcmljdGlvbiBbMCAtIDEuMF0gVGhlIGhpZ2hlciB0aGUgZnJpY3Rpb24gdGhlIG1vcmUgdGhhdCB0aGUgY2FtZXJhIHdpbGwgcmVzaXN0IG1vdGlvbiB0b3dhcmRzIHRoZSB0YXJnZXRcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBFbGFzdGljVG9BY3RvclN0cmF0ZWd5KHRhcmdldCwgY2FtZXJhRWxhc3RpY2l0eSwgY2FtZXJhRnJpY3Rpb24pIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhRWxhc3RpY2l0eSA9IGNhbWVyYUVsYXN0aWNpdHk7XHJcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhRnJpY3Rpb24gPSBjYW1lcmFGcmljdGlvbjtcclxuICAgICAgICAgICAgdGhpcy5hY3Rpb24gPSBmdW5jdGlvbiAodGFyZ2V0LCBjYW0sIF9lbmcsIF9kZWx0YSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gdGFyZ2V0LmdldENlbnRlcigpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZvY3VzID0gY2FtLmdldEZvY3VzKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2FtZXJhVmVsID0gbmV3IEFsZ2VicmFfMy5WZWN0b3IoY2FtLmR4LCBjYW0uZHkpO1xyXG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBzdHJlY2ggdmVjdG9yLCB1c2luZyB0aGUgc3ByaW5nIGVxdWF0aW9uXHJcbiAgICAgICAgICAgICAgICAvLyBGID0ga1hcclxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hvb2tlJ3NfbGF3XHJcbiAgICAgICAgICAgICAgICAvLyBBcHBseSB0byB0aGUgY3VycmVudCBjYW1lcmEgdmVsb2NpdHlcclxuICAgICAgICAgICAgICAgIHZhciBzdHJldGNoID0gcG9zaXRpb24uc3ViKGZvY3VzKS5zY2FsZShfdGhpcy5jYW1lcmFFbGFzdGljaXR5KTsgLy8gc3RyZXRjaCBpcyBYXHJcbiAgICAgICAgICAgICAgICBjYW1lcmFWZWwgPSBjYW1lcmFWZWwuYWRkKHN0cmV0Y2gpO1xyXG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBmcmljdGlvbiAoLTEgdG8gYXBwbHkgYSBmb3JjZSBpbiB0aGUgb3Bwb3NpdGlvbiBvZiBtb3Rpb24pXHJcbiAgICAgICAgICAgICAgICAvLyBBcHBseSB0byB0aGUgY3VycmVudCBjYW1lcmEgdmVsb2NpdHlcclxuICAgICAgICAgICAgICAgIHZhciBmcmljdGlvbiA9IGNhbWVyYVZlbC5zY2FsZSgtMSkuc2NhbGUoX3RoaXMuY2FtZXJhRnJpY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgY2FtZXJhVmVsID0gY2FtZXJhVmVsLmFkZChmcmljdGlvbik7XHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgcG9zaXRpb24gYnkgdmVsb2NpdHkgZGVsdGFzXHJcbiAgICAgICAgICAgICAgICBmb2N1cyA9IGZvY3VzLmFkZChjYW1lcmFWZWwpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvY3VzO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gRWxhc3RpY1RvQWN0b3JTdHJhdGVneTtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkVsYXN0aWNUb0FjdG9yU3RyYXRlZ3kgPSBFbGFzdGljVG9BY3RvclN0cmF0ZWd5O1xyXG4gICAgdmFyIFJhZGl1c0Fyb3VuZEFjdG9yU3RyYXRlZ3kgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHRhcmdldCBUYXJnZXQgYWN0b3IgdG8gZm9sbG93IHdoZW4gaXQgaXMgXCJyYWRpdXNcIiBwaXhlbHMgYXdheVxyXG4gICAgICAgICAqIEBwYXJhbSByYWRpdXMgTnVtYmVyIG9mIHBpeGVscyBhd2F5IGJlZm9yZSB0aGUgY2FtZXJhIHdpbGwgZm9sbG93XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gUmFkaXVzQXJvdW5kQWN0b3JTdHJhdGVneSh0YXJnZXQsIHJhZGl1cykge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgdGhpcy5yYWRpdXMgPSByYWRpdXM7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uID0gZnVuY3Rpb24gKHRhcmdldCwgY2FtLCBfZW5nLCBfZGVsdGEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHRhcmdldC5nZXRDZW50ZXIoKTtcclxuICAgICAgICAgICAgICAgIHZhciBmb2N1cyA9IGNhbS5nZXRGb2N1cygpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHBvc2l0aW9uLnN1Yihmb2N1cyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBkaXJlY3Rpb24ubWFnbml0dWRlKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgPj0gX3RoaXMucmFkaXVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IGRpc3RhbmNlIC0gX3RoaXMucmFkaXVzO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb2N1cy5hZGQoZGlyZWN0aW9uLm5vcm1hbGl6ZSgpLnNjYWxlKG9mZnNldCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvY3VzO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUmFkaXVzQXJvdW5kQWN0b3JTdHJhdGVneTtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLlJhZGl1c0Fyb3VuZEFjdG9yU3RyYXRlZ3kgPSBSYWRpdXNBcm91bmRBY3RvclN0cmF0ZWd5O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYW1lcmFzXHJcbiAgICAgKlxyXG4gICAgICogW1tCYXNlQ2FtZXJhXV0gaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGFsbCBFeGNhbGlidXIgY2FtZXJhcy4gQ2FtZXJhcyBhcmUgdXNlZFxyXG4gICAgICogdG8gbW92ZSBhcm91bmQgeW91ciBnYW1lIGFuZCBzZXQgZm9jdXMuIFRoZXkgYXJlIHVzZWQgdG8gZGV0ZXJtaW5lXHJcbiAgICAgKiB3aGF0IGlzIFwib2ZmIHNjcmVlblwiIGFuZCBjYW4gYmUgdXNlZCB0byBzY2FsZSB0aGUgZ2FtZS5cclxuICAgICAqXHJcbiAgICAgKiBbW2luY2x1ZGU6Q2FtZXJhcy5tZF1dXHJcbiAgICAgKi9cclxuICAgIHZhciBCYXNlQ2FtZXJhID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBCYXNlQ2FtZXJhKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9jYW1lcmFTdHJhdGVnaWVzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuc3RyYXRlZ3kgPSBuZXcgU3RyYXRlZ3lDb250YWluZXIodGhpcyk7XHJcbiAgICAgICAgICAgIC8vIGNhbWVyYSBwaHlzaWNhbCBxdWFudGl0aWVzXHJcbiAgICAgICAgICAgIHRoaXMueiA9IDE7XHJcbiAgICAgICAgICAgIHRoaXMuZHggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmR5ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5keiA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuYXggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmF5ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5heiA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMucm90YXRpb24gPSAwO1xyXG4gICAgICAgICAgICB0aGlzLnJ4ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5feCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3kgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9jYW1lcmFNb3ZpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudExlcnBUaW1lID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fbGVycER1cmF0aW9uID0gMTAwMDsgLy8gMSBzZWNvbmQgICBcclxuICAgICAgICAgICAgdGhpcy5fbGVycFN0YXJ0ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5fbGVycEVuZCA9IG51bGw7XHJcbiAgICAgICAgICAgIC8vY2FtZXJhIGVmZmVjdHNcclxuICAgICAgICAgICAgdGhpcy5faXNTaGFraW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3NoYWtlTWFnbml0dWRlWCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3NoYWtlTWFnbml0dWRlWSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3NoYWtlRHVyYXRpb24gPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9lbGFwc2VkU2hha2VUaW1lID0gMDtcclxuICAgICAgICAgICAgdGhpcy5feFNoYWtlID0gMDtcclxuICAgICAgICAgICAgdGhpcy5feVNoYWtlID0gMDtcclxuICAgICAgICAgICAgdGhpcy5faXNab29taW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX21heFpvb21TY2FsZSA9IDE7XHJcbiAgICAgICAgICAgIHRoaXMuX3pvb21JbmNyZW1lbnQgPSAwLjAxO1xyXG4gICAgICAgICAgICB0aGlzLl9lYXNpbmcgPSBFYXNpbmdGdW5jdGlvbnNfMS5FYXNpbmdGdW5jdGlvbnMuRWFzZUluT3V0Q3ViaWM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlQ2FtZXJhLnByb3RvdHlwZSwgXCJ4XCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldCB0aGUgY2FtZXJhJ3MgeCBwb3NpdGlvblxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5feDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldCB0aGUgY2FtZXJhJ3MgeCBwb3NpdGlvbiAoY2Fubm90IGJlIHNldCB3aGVuIGZvbGxvd2luZyBhbiBbW0FjdG9yXV0gb3Igd2hlbiBtb3ZpbmcpXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9mb2xsb3cgJiYgIXRoaXMuX2NhbWVyYU1vdmluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ggPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VDYW1lcmEucHJvdG90eXBlLCBcInlcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0IHRoZSBjYW1lcmEncyB5IHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl95O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0IHRoZSBjYW1lcmEncyB5IHBvc2l0aW9uIChjYW5ub3QgYmUgc2V0IHdoZW4gZm9sbG93aW5nIGFuIFtbQWN0b3JdXSBvciB3aGVuIG1vdmluZylcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2ZvbGxvdyAmJiAhdGhpcy5fY2FtZXJhTW92aW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5feSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZUNhbWVyYS5wcm90b3R5cGUsIFwicG9zXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldCB0aGUgY2FtZXJhJ3MgcG9zaXRpb24gYXMgYSB2ZWN0b3JcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBbGdlYnJhXzMuVmVjdG9yKHRoaXMueCwgdGhpcy55KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldCB0aGUgY2FtZXJhcyBwb3NpdGlvblxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMueCA9IHZhbHVlLng7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnkgPSB2YWx1ZS55O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZUNhbWVyYS5wcm90b3R5cGUsIFwidmVsXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldCB0aGUgY2FtZXJhJ3MgdmVsb2NpdHkgYXMgYSB2ZWN0b3JcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBbGdlYnJhXzMuVmVjdG9yKHRoaXMuZHgsIHRoaXMuZHkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0IHRoZSBjYW1lcmEncyB2ZWxvY2l0eVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZHggPSB2YWx1ZS54O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5keSA9IHZhbHVlLnk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIGZvY2FsIHBvaW50IG9mIHRoZSBjYW1lcmEsIGEgbmV3IHBvaW50IGdpdmluZyB0aGUgeCBhbmQgeSBwb3NpdGlvbiBvZiB0aGUgY2FtZXJhXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQmFzZUNhbWVyYS5wcm90b3R5cGUuZ2V0Rm9jdXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWxnZWJyYV8zLlZlY3Rvcih0aGlzLngsIHRoaXMueSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIG1vdmVzIHRoZSBjYW1lcmEgZm9jYWwgcG9pbnQgdG8gdGhlIHNwZWNpZmllZCBwb3NpdGlvbiB1c2luZyBzcGVjaWZpZWQgZWFzaW5nIGZ1bmN0aW9uLiBDYW5ub3QgbW92ZSB3aGVuIGZvbGxvd2luZyBhbiBBY3Rvci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBwb3MgVGhlIHRhcmdldCBwb3NpdGlvbiB0byBtb3ZlIHRvXHJcbiAgICAgICAgICogQHBhcmFtIGR1cmF0aW9uIFRoZSBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgdGhlIG1vdmUgc2hvdWxkIGxhc3RcclxuICAgICAgICAgKiBAcGFyYW0gW2Vhc2luZ0ZuXSBBbiBvcHRpb25hbCBlYXNpbmcgZnVuY3Rpb24gKFtbZXguRWFzaW5nRnVuY3Rpb25zLkVhc2VJbk91dEN1YmljXV0gYnkgZGVmYXVsdClcclxuICAgICAgICAgKiBAcmV0dXJucyBBIFtbUHJvbWlzZV1dIHRoYXQgcmVzb2x2ZXMgd2hlbiBtb3ZlbWVudCBpcyBmaW5pc2hlZCwgaW5jbHVkaW5nIGlmIGl0J3MgaW50ZXJydXB0ZWQuXHJcbiAgICAgICAgICogICAgICAgICAgVGhlIFtbUHJvbWlzZV1dIHZhbHVlIGlzIHRoZSBbW1ZlY3Rvcl1dIG9mIHRoZSB0YXJnZXQgcG9zaXRpb24uIEl0IHdpbGwgYmUgcmVqZWN0ZWQgaWYgYSBtb3ZlIGNhbm5vdCBiZSBtYWRlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJhc2VDYW1lcmEucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbiAocG9zLCBkdXJhdGlvbiwgZWFzaW5nRm4pIHtcclxuICAgICAgICAgICAgaWYgKGVhc2luZ0ZuID09PSB2b2lkIDApIHsgZWFzaW5nRm4gPSBFYXNpbmdGdW5jdGlvbnNfMS5FYXNpbmdGdW5jdGlvbnMuRWFzZUluT3V0Q3ViaWM7IH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlYXNpbmdGbiAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgJ1BsZWFzZSBzcGVjaWZ5IGFuIEVhc2luZ0Z1bmN0aW9uJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjYW5ub3QgbW92ZSB3aGVuIGZvbGxvd2luZyBhbiBhY3RvclxyXG4gICAgICAgICAgICBpZiAodGhpcy5fZm9sbG93KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2VzXzEuUHJvbWlzZSgpLnJlamVjdChwb3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHJlc29sdmUgZXhpc3RpbmcgcHJvbWlzZSwgaWYgYW55XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9sZXJwUHJvbWlzZSAmJiB0aGlzLl9sZXJwUHJvbWlzZS5zdGF0ZSgpID09PSBQcm9taXNlc18xLlByb21pc2VTdGF0ZS5QZW5kaW5nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sZXJwUHJvbWlzZS5yZXNvbHZlKHBvcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbGVycFByb21pc2UgPSBuZXcgUHJvbWlzZXNfMS5Qcm9taXNlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2xlcnBTdGFydCA9IHRoaXMuZ2V0Rm9jdXMoKS5jbG9uZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9sZXJwRHVyYXRpb24gPSBkdXJhdGlvbjtcclxuICAgICAgICAgICAgdGhpcy5fbGVycEVuZCA9IHBvcztcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudExlcnBUaW1lID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fY2FtZXJhTW92aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fZWFzaW5nID0gZWFzaW5nRm47XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZXJwUHJvbWlzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIGNhbWVyYSB0byBzaGFrZSBhdCB0aGUgc3BlY2lmaWVkIG1hZ25pdHVkZXMgZm9yIHRoZSBzcGVjaWZpZWQgZHVyYXRpb25cclxuICAgICAgICAgKiBAcGFyYW0gbWFnbml0dWRlWCAgVGhlIHggbWFnbml0dWRlIG9mIHRoZSBzaGFrZVxyXG4gICAgICAgICAqIEBwYXJhbSBtYWduaXR1ZGVZICBUaGUgeSBtYWduaXR1ZGUgb2YgdGhlIHNoYWtlXHJcbiAgICAgICAgICogQHBhcmFtIGR1cmF0aW9uICAgIFRoZSBkdXJhdGlvbiBvZiB0aGUgc2hha2UgaW4gbWlsbGlzZWNvbmRzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQmFzZUNhbWVyYS5wcm90b3R5cGUuc2hha2UgPSBmdW5jdGlvbiAobWFnbml0dWRlWCwgbWFnbml0dWRlWSwgZHVyYXRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5faXNTaGFraW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fc2hha2VNYWduaXR1ZGVYID0gbWFnbml0dWRlWDtcclxuICAgICAgICAgICAgdGhpcy5fc2hha2VNYWduaXR1ZGVZID0gbWFnbml0dWRlWTtcclxuICAgICAgICAgICAgdGhpcy5fc2hha2VEdXJhdGlvbiA9IGR1cmF0aW9uO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogWm9vbXMgdGhlIGNhbWVyYSBpbiBvciBvdXQgYnkgdGhlIHNwZWNpZmllZCBzY2FsZSBvdmVyIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24uXHJcbiAgICAgICAgICogSWYgbm8gZHVyYXRpb24gaXMgc3BlY2lmaWVkLCBpdCB0YWtlIGVmZmVjdCBpbW1lZGlhdGVseS5cclxuICAgICAgICAgKiBAcGFyYW0gc2NhbGUgICAgVGhlIHNjYWxlIG9mIHRoZSB6b29tXHJcbiAgICAgICAgICogQHBhcmFtIGR1cmF0aW9uIFRoZSBkdXJhdGlvbiBvZiB0aGUgem9vbSBpbiBtaWxsaXNlY29uZHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBCYXNlQ2FtZXJhLnByb3RvdHlwZS56b29tID0gZnVuY3Rpb24gKHNjYWxlLCBkdXJhdGlvbikge1xyXG4gICAgICAgICAgICBpZiAoZHVyYXRpb24gPT09IHZvaWQgMCkgeyBkdXJhdGlvbiA9IDA7IH1cclxuICAgICAgICAgICAgdGhpcy5fem9vbVByb21pc2UgPSBuZXcgUHJvbWlzZXNfMS5Qcm9taXNlKCk7XHJcbiAgICAgICAgICAgIGlmIChkdXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faXNab29taW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21heFpvb21TY2FsZSA9IHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fem9vbUluY3JlbWVudCA9IChzY2FsZSAtIHRoaXMueikgLyBkdXJhdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2lzWm9vbWluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy56ID0gc2NhbGU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl96b29tUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl96b29tUHJvbWlzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGN1cnJlbnQgem9vbSBzY2FsZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJhc2VDYW1lcmEucHJvdG90eXBlLmdldFpvb20gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLno7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgbmV3IGNhbWVyYSBzdHJhdGVneSB0byB0aGlzIGNhbWVyYVxyXG4gICAgICAgICAqIEBwYXJhbSBjYW1lcmFTdHJhdGVneSBJbnN0YW5jZSBvZiBhbiBbW0lDYW1lcmFTdHJhdGVneV1dXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQmFzZUNhbWVyYS5wcm90b3R5cGUuYWRkU3RyYXRlZ3kgPSBmdW5jdGlvbiAoY2FtZXJhU3RyYXRlZ3kpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2FtZXJhU3RyYXRlZ2llcy5wdXNoKGNhbWVyYVN0cmF0ZWd5KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgYSBjYW1lcmEgc3RyYXRlZ3kgYnkgcmVmZXJlbmNlXHJcbiAgICAgICAgICogQHBhcmFtIGNhbWVyYVN0cmF0ZWd5IEluc3RhbmNlIG9mIGFuIFtbSUNhbWVyYVN0cmF0ZWd5XV1cclxuICAgICAgICAgKi9cclxuICAgICAgICBCYXNlQ2FtZXJhLnByb3RvdHlwZS5yZW1vdmVTdHJhdGVneSA9IGZ1bmN0aW9uIChjYW1lcmFTdHJhdGVneSkge1xyXG4gICAgICAgICAgICBVdGlsXzEucmVtb3ZlSXRlbUZyb21BcnJheShjYW1lcmFTdHJhdGVneSwgdGhpcy5fY2FtZXJhU3RyYXRlZ2llcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDbGVhcnMgYWxsIGNhbWVyYSBzdHJhdGVnaWVzIGZyb20gdGhlIGNhbWVyYVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJhc2VDYW1lcmEucHJvdG90eXBlLmNsZWFyQWxsU3RyYXRlZ2llcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2FtZXJhU3RyYXRlZ2llcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQmFzZUNhbWVyYS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKF9lbmdpbmUsIGRlbHRhKSB7XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBwbGFjZW1lbnRzIGJhc2VkIG9uIGxpbmVhciBhbGdlYnJhXHJcbiAgICAgICAgICAgIHRoaXMuX3ggKz0gdGhpcy5keCAqIGRlbHRhIC8gMTAwMDtcclxuICAgICAgICAgICAgdGhpcy5feSArPSB0aGlzLmR5ICogZGVsdGEgLyAxMDAwO1xyXG4gICAgICAgICAgICB0aGlzLnogKz0gdGhpcy5keiAqIGRlbHRhIC8gMTAwMDtcclxuICAgICAgICAgICAgdGhpcy5keCArPSB0aGlzLmF4ICogZGVsdGEgLyAxMDAwO1xyXG4gICAgICAgICAgICB0aGlzLmR5ICs9IHRoaXMuYXkgKiBkZWx0YSAvIDEwMDA7XHJcbiAgICAgICAgICAgIHRoaXMuZHogKz0gdGhpcy5heiAqIGRlbHRhIC8gMTAwMDtcclxuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbiArPSB0aGlzLnJ4ICogZGVsdGEgLyAxMDAwO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNab29taW5nKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3Wm9vbSA9IHRoaXMueiArIHRoaXMuX3pvb21JbmNyZW1lbnQgKiBkZWx0YTtcclxuICAgICAgICAgICAgICAgIHRoaXMueiA9IG5ld1pvb207XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fem9vbUluY3JlbWVudCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3Wm9vbSA+PSB0aGlzLl9tYXhab29tU2NhbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNab29taW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueiA9IHRoaXMuX21heFpvb21TY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fem9vbVByb21pc2UucmVzb2x2ZSh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3Wm9vbSA8PSB0aGlzLl9tYXhab29tU2NhbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNab29taW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueiA9IHRoaXMuX21heFpvb21TY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fem9vbVByb21pc2UucmVzb2x2ZSh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2NhbWVyYU1vdmluZykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRMZXJwVGltZSA8IHRoaXMuX2xlcnBEdXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sZXJwRW5kLnggPCB0aGlzLl9sZXJwU3RhcnQueCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl94ID0gdGhpcy5fbGVycFN0YXJ0LnggLSAodGhpcy5fZWFzaW5nKHRoaXMuX2N1cnJlbnRMZXJwVGltZSwgdGhpcy5fbGVycEVuZC54LCB0aGlzLl9sZXJwU3RhcnQueCwgdGhpcy5fbGVycER1cmF0aW9uKSAtIHRoaXMuX2xlcnBFbmQueCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl94ID0gdGhpcy5fZWFzaW5nKHRoaXMuX2N1cnJlbnRMZXJwVGltZSwgdGhpcy5fbGVycFN0YXJ0LngsIHRoaXMuX2xlcnBFbmQueCwgdGhpcy5fbGVycER1cmF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xlcnBFbmQueSA8IHRoaXMuX2xlcnBTdGFydC55KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3kgPSB0aGlzLl9sZXJwU3RhcnQueSAtICh0aGlzLl9lYXNpbmcodGhpcy5fY3VycmVudExlcnBUaW1lLCB0aGlzLl9sZXJwRW5kLnksIHRoaXMuX2xlcnBTdGFydC55LCB0aGlzLl9sZXJwRHVyYXRpb24pIC0gdGhpcy5fbGVycEVuZC55KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3kgPSB0aGlzLl9lYXNpbmcodGhpcy5fY3VycmVudExlcnBUaW1lLCB0aGlzLl9sZXJwU3RhcnQueSwgdGhpcy5fbGVycEVuZC55LCB0aGlzLl9sZXJwRHVyYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50TGVycFRpbWUgKz0gZGVsdGE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl94ID0gdGhpcy5fbGVycEVuZC54O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3kgPSB0aGlzLl9sZXJwRW5kLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGVycFByb21pc2UucmVzb2x2ZSh0aGlzLl9sZXJwRW5kKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sZXJwU3RhcnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xlcnBFbmQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRMZXJwVGltZSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FtZXJhTW92aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzRG9uZVNoYWtpbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faXNTaGFraW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lbGFwc2VkU2hha2VUaW1lID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NoYWtlTWFnbml0dWRlWCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zaGFrZU1hZ25pdHVkZVkgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2hha2VEdXJhdGlvbiA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl94U2hha2UgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5feVNoYWtlID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VsYXBzZWRTaGFrZVRpbWUgKz0gZGVsdGE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl94U2hha2UgPSAoTWF0aC5yYW5kb20oKSAqIHRoaXMuX3NoYWtlTWFnbml0dWRlWCB8IDApICsgMTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3lTaGFrZSA9IChNYXRoLnJhbmRvbSgpICogdGhpcy5fc2hha2VNYWduaXR1ZGVZIHwgMCkgKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl9jYW1lcmFTdHJhdGVnaWVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHMgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IHMuYWN0aW9uLmNhbGwocywgcy50YXJnZXQsIHRoaXMsIF9lbmdpbmUsIGRlbHRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXBwbGllcyB0aGUgcmVsZXZhbnQgdHJhbnNmb3JtYXRpb25zIHRvIHRoZSBnYW1lIGNhbnZhcyB0byBcIm1vdmVcIiBvciBhcHBseSBlZmZlY3RzIHRvIHRoZSBDYW1lcmFcclxuICAgICAgICAgKiBAcGFyYW0gY3R4ICAgIENhbnZhcyBjb250ZXh0IHRvIGFwcGx5IHRyYW5zZm9ybWF0aW9uc1xyXG4gICAgICAgICAqIEBwYXJhbSBkZWx0YSAgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGxhc3QgdXBkYXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQmFzZUNhbWVyYS5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICAgICAgICAgICAgdmFyIGZvY3VzID0gdGhpcy5nZXRGb2N1cygpO1xyXG4gICAgICAgICAgICB2YXIgY2FudmFzV2lkdGggPSBjdHguY2FudmFzLndpZHRoO1xyXG4gICAgICAgICAgICB2YXIgY2FudmFzSGVpZ2h0ID0gY3R4LmNhbnZhcy5oZWlnaHQ7XHJcbiAgICAgICAgICAgIHZhciBwaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XHJcbiAgICAgICAgICAgIHZhciB6b29tID0gdGhpcy5nZXRab29tKCk7XHJcbiAgICAgICAgICAgIHZhciBuZXdDYW52YXNXaWR0aCA9IChjYW52YXNXaWR0aCAvIHpvb20pIC8gcGl4ZWxSYXRpbztcclxuICAgICAgICAgICAgdmFyIG5ld0NhbnZhc0hlaWdodCA9IChjYW52YXNIZWlnaHQgLyB6b29tKSAvIHBpeGVsUmF0aW87XHJcbiAgICAgICAgICAgIGN0eC5zY2FsZSh6b29tLCB6b29tKTtcclxuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtZm9jdXMueCArIG5ld0NhbnZhc1dpZHRoIC8gMiArIHRoaXMuX3hTaGFrZSwgLWZvY3VzLnkgKyBuZXdDYW52YXNIZWlnaHQgLyAyICsgdGhpcy5feVNoYWtlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEJhc2VDYW1lcmEucHJvdG90eXBlLmRlYnVnRHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICAgICAgICAgICAgdmFyIGZvY3VzID0gdGhpcy5nZXRGb2N1cygpO1xyXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3JlZCc7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICd3aGl0ZSc7XHJcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAzO1xyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5hcmMoZm9jdXMueCwgZm9jdXMueSwgMTUsIDAsIE1hdGguUEkgKiAyKTtcclxuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgY3R4LmFyYyhmb2N1cy54LCBmb2N1cy55LCA1LCAwLCBNYXRoLlBJICogMik7XHJcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQmFzZUNhbWVyYS5wcm90b3R5cGUuX2lzRG9uZVNoYWtpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhKHRoaXMuX2lzU2hha2luZykgfHwgKHRoaXMuX2VsYXBzZWRTaGFrZVRpbWUgPj0gdGhpcy5fc2hha2VEdXJhdGlvbik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gQmFzZUNhbWVyYTtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkJhc2VDYW1lcmEgPSBCYXNlQ2FtZXJhO1xyXG59KTtcclxuZGVmaW5lKFwiQ29uZmlndXJhYmxlXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICBmdW5jdGlvbiBDb25maWd1cmFibGUoYmFzZSkge1xyXG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoY2xhc3NfMSwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gY2xhc3NfMSgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBhcmdzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICAgICAgLy9nZXQgdGhlIG51bWJlciBvZiBhcmd1bWVudHMgdGhhdCBhcmVuJ3QgdW5kZWZpbmVkLiBUUyBwYXNzZXMgYSB2YWx1ZSB0byBhbGwgcGFyYW1ldGVyc1xyXG4gICAgICAgICAgICAgICAgLy9vZiB3aGF0ZXZlciBjdG9yIGlzIHRoZSBpbXBsZW1lbnRhdGlvbiwgc28gYXJncy5sZW5ndGggZG9lc24ndCB3b3JrIGhlcmUuXHJcbiAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IGFyZ3MuZmlsdGVyKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZDsgfSkubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNpemUgPT09IDEgJiYgYXJnc1swXSAmJiB0eXBlb2YgYXJnc1swXSA9PT0gJ29iamVjdCcgJiYgIShhcmdzWzBdIGluc3RhbmNlb2YgQXJyYXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXNzaWduKGFyZ3NbMF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmFzc2lnbiA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG4gICAgICAgICAgICAgICAgLy9zZXQgdGhlIHZhbHVlIG9mIGV2ZXJ5IHByb3BlcnR5IHRoYXQgd2FzIHBhc3NlZCBpbixcclxuICAgICAgICAgICAgICAgIC8vaWYgdGhlIGNvbnN0cnVjdG9yIHByZXZpb3VzbHkgc2V0IHRoaXMgdmFsdWUsIGl0IHdpbGwgYmUgb3ZlcnJpZGRlbiBoZXJlXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrIGluIHByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzW2tdICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba10gPSBwcm9wc1trXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBjbGFzc18xO1xyXG4gICAgICAgIH0oYmFzZSkpO1xyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5Db25maWd1cmFibGUgPSBDb25maWd1cmFibGU7XHJcbn0pO1xyXG5kZWZpbmUoXCJEZWJ1Z0ZsYWdzXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbn0pO1xyXG5kZWZpbmUoXCJEcmF3aW5nL0NvbG9yXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIFByb3ZpZGVzIHN0YW5kYXJkIGNvbG9ycyAoZS5nLiBbW0NvbG9yLkJsYWNrXV0pXHJcbiAgICAgKiBidXQgeW91IGNhbiBhbHNvIGNyZWF0ZSBjdXN0b20gY29sb3JzIHVzaW5nIFJHQiwgSFNMLCBvciBIZXguIEFsc28gcHJvdmlkZXNcclxuICAgICAqIHVzZWZ1bCBjb2xvciBvcGVyYXRpb25zIGxpa2UgW1tDb2xvci5saWdodGVuXV0sIFtbQ29sb3IuZGFya2VuXV0sIGFuZCBtb3JlLlxyXG4gICAgICpcclxuICAgICAqIFtbaW5jbHVkZTpDb2xvcnMubWRdXVxyXG4gICAgICovXHJcbiAgICB2YXIgQ29sb3IgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgQ29sb3IgZnJvbSBhbiByLCBnLCBiLCBhXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gciAgVGhlIHJlZCBjb21wb25lbnQgb2YgY29sb3IgKDAtMjU1KVxyXG4gICAgICAgICAqIEBwYXJhbSBnICBUaGUgZ3JlZW4gY29tcG9uZW50IG9mIGNvbG9yICgwLTI1NSlcclxuICAgICAgICAgKiBAcGFyYW0gYiAgVGhlIGJsdWUgY29tcG9uZW50IG9mIGNvbG9yICgwLTI1NSlcclxuICAgICAgICAgKiBAcGFyYW0gYSAgVGhlIGFscGhhIGNvbXBvbmVudCBvZiBjb2xvciAoMC0xLjApXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gQ29sb3IociwgZywgYiwgYSkge1xyXG4gICAgICAgICAgICB0aGlzLnIgPSByO1xyXG4gICAgICAgICAgICB0aGlzLmcgPSBnO1xyXG4gICAgICAgICAgICB0aGlzLmIgPSBiO1xyXG4gICAgICAgICAgICB0aGlzLmEgPSAoYSAhPSBudWxsID8gYSA6IDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIENvbG9yIGZyb20gYW4gciwgZywgYiwgYVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHIgIFRoZSByZWQgY29tcG9uZW50IG9mIGNvbG9yICgwLTI1NSlcclxuICAgICAgICAgKiBAcGFyYW0gZyAgVGhlIGdyZWVuIGNvbXBvbmVudCBvZiBjb2xvciAoMC0yNTUpXHJcbiAgICAgICAgICogQHBhcmFtIGIgIFRoZSBibHVlIGNvbXBvbmVudCBvZiBjb2xvciAoMC0yNTUpXHJcbiAgICAgICAgICogQHBhcmFtIGEgIFRoZSBhbHBoYSBjb21wb25lbnQgb2YgY29sb3IgKDAtMS4wKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbG9yLmZyb21SR0IgPSBmdW5jdGlvbiAociwgZywgYiwgYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKHIsIGcsIGIsIGEpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBpbnNjYW5jZSBvZiBDb2xvciBmcm9tIGEgaGV4IHN0cmluZ1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGhleCAgQ1NTIGNvbG9yIHN0cmluZyBvZiB0aGUgZm9ybSAjZmZmZmZmLCB0aGUgYWxwaGEgY29tcG9uZW50IGlzIG9wdGlvbmFsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sb3IuZnJvbUhleCA9IGZ1bmN0aW9uIChoZXgpIHtcclxuICAgICAgICAgICAgdmFyIGhleFJlZ0V4ID0gL14jPyhbMC05YS1mXXsyfSkoWzAtOWEtZl17Mn0pKFswLTlhLWZdezJ9KShbMC05YS1mXXsyfSk/JC9pO1xyXG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAobWF0Y2ggPSBoZXgubWF0Y2goaGV4UmVnRXgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgciA9IHBhcnNlSW50KG1hdGNoWzFdLCAxNik7XHJcbiAgICAgICAgICAgICAgICB2YXIgZyA9IHBhcnNlSW50KG1hdGNoWzJdLCAxNik7XHJcbiAgICAgICAgICAgICAgICB2YXIgYiA9IHBhcnNlSW50KG1hdGNoWzNdLCAxNik7XHJcbiAgICAgICAgICAgICAgICB2YXIgYSA9IDE7XHJcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hbNF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBhID0gcGFyc2VJbnQobWF0Y2hbNF0sIDE2KSAvIDI1NTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IociwgZywgYiwgYSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZzogJyArIGhleCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0cyBhIG5ldyBpbnN0YW5jZSBvZiBDb2xvciBmcm9tIGhzbGEgdmFsdWVzXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gaCAgSHVlIGlzIHJlcHJlc2VudGVkIFswLTFdXHJcbiAgICAgICAgICogQHBhcmFtIHMgIFNhdHVyYXRpb24gaXMgcmVwcmVzZW50ZWQgWzAtMV1cclxuICAgICAgICAgKiBAcGFyYW0gbCAgTHVtaW5hbmNlIGlzIHJlcHJlc2VudGVkIFswLTFdXHJcbiAgICAgICAgICogQHBhcmFtIGEgIEFscGhhIGlzIHJlcHJlc2VudGVkIFswLTFdXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sb3IuZnJvbUhTTCA9IGZ1bmN0aW9uIChoLCBzLCBsLCBhKSB7XHJcbiAgICAgICAgICAgIGlmIChhID09PSB2b2lkIDApIHsgYSA9IDEuMDsgfVxyXG4gICAgICAgICAgICB2YXIgdGVtcCA9IG5ldyBIU0xDb2xvcihoLCBzLCBsLCBhKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRlbXAudG9SR0JBKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMaWdodGVucyB0aGUgY3VycmVudCBjb2xvciBieSBhIHNwZWNpZmllZCBhbW91bnRcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBmYWN0b3IgIFRoZSBhbW91bnQgdG8gbGlnaHRlbiBieSBbMC0xXVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbG9yLnByb3RvdHlwZS5saWdodGVuID0gZnVuY3Rpb24gKGZhY3Rvcikge1xyXG4gICAgICAgICAgICBpZiAoZmFjdG9yID09PSB2b2lkIDApIHsgZmFjdG9yID0gMC4xOyB9XHJcbiAgICAgICAgICAgIHZhciB0ZW1wID0gSFNMQ29sb3IuZnJvbVJHQkEodGhpcy5yLCB0aGlzLmcsIHRoaXMuYiwgdGhpcy5hKTtcclxuICAgICAgICAgICAgdGVtcC5sICs9ICh0ZW1wLmwgKiBmYWN0b3IpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGVtcC50b1JHQkEoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERhcmtlbnMgdGhlIGN1cnJlbnQgY29sb3IgYnkgYSBzcGVjaWZpZWQgYW1vdW50XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gZmFjdG9yICBUaGUgYW1vdW50IHRvIGRhcmtlbiBieSBbMC0xXVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbG9yLnByb3RvdHlwZS5kYXJrZW4gPSBmdW5jdGlvbiAoZmFjdG9yKSB7XHJcbiAgICAgICAgICAgIGlmIChmYWN0b3IgPT09IHZvaWQgMCkgeyBmYWN0b3IgPSAwLjE7IH1cclxuICAgICAgICAgICAgdmFyIHRlbXAgPSBIU0xDb2xvci5mcm9tUkdCQSh0aGlzLnIsIHRoaXMuZywgdGhpcy5iLCB0aGlzLmEpO1xyXG4gICAgICAgICAgICB0ZW1wLmwgLT0gKHRlbXAubCAqIGZhY3Rvcik7XHJcbiAgICAgICAgICAgIHJldHVybiB0ZW1wLnRvUkdCQSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2F0dXJhdGVzIHRoZSBjdXJyZW50IGNvbG9yIGJ5IGEgc3BlY2lmaWVkIGFtb3VudFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGZhY3RvciAgVGhlIGFtb3VudCB0byBzYXR1cmF0ZSBieSBbMC0xXVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbG9yLnByb3RvdHlwZS5zYXR1cmF0ZSA9IGZ1bmN0aW9uIChmYWN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKGZhY3RvciA9PT0gdm9pZCAwKSB7IGZhY3RvciA9IDAuMTsgfVxyXG4gICAgICAgICAgICB2YXIgdGVtcCA9IEhTTENvbG9yLmZyb21SR0JBKHRoaXMuciwgdGhpcy5nLCB0aGlzLmIsIHRoaXMuYSk7XHJcbiAgICAgICAgICAgIHRlbXAucyArPSAodGVtcC5zICogZmFjdG9yKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRlbXAudG9SR0JBKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZXNhdHVyYXRlcyB0aGUgY3VycmVudCBjb2xvciBieSBhIHNwZWNpZmllZCBhbW91bnRcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBmYWN0b3IgIFRoZSBhbW91bnQgdG8gZGVzYXR1cmF0ZSBieSBbMC0xXVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbG9yLnByb3RvdHlwZS5kZXNhdHVyYXRlID0gZnVuY3Rpb24gKGZhY3Rvcikge1xyXG4gICAgICAgICAgICBpZiAoZmFjdG9yID09PSB2b2lkIDApIHsgZmFjdG9yID0gMC4xOyB9XHJcbiAgICAgICAgICAgIHZhciB0ZW1wID0gSFNMQ29sb3IuZnJvbVJHQkEodGhpcy5yLCB0aGlzLmcsIHRoaXMuYiwgdGhpcy5hKTtcclxuICAgICAgICAgICAgdGVtcC5zIC09ICh0ZW1wLnMgKiBmYWN0b3IpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGVtcC50b1JHQkEoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE11bHRpcGxpZXMgYSBjb2xvciBieSBhbm90aGVyLCByZXN1bHRzIGluIGEgZGFya2VyIGNvbG9yXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gY29sb3IgIFRoZSBvdGhlciBjb2xvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbG9yLnByb3RvdHlwZS5tdWxpdGlwbHkgPSBmdW5jdGlvbiAoY29sb3IpIHtcclxuICAgICAgICAgICAgdmFyIG5ld1IgPSAoKGNvbG9yLnIgLyAyNTUgKiB0aGlzLnIgLyAyNTUpICogMjU1KTtcclxuICAgICAgICAgICAgdmFyIG5ld0cgPSAoKGNvbG9yLmcgLyAyNTUgKiB0aGlzLmcgLyAyNTUpICogMjU1KTtcclxuICAgICAgICAgICAgdmFyIG5ld0IgPSAoKGNvbG9yLmIgLyAyNTUgKiB0aGlzLmIgLyAyNTUpICogMjU1KTtcclxuICAgICAgICAgICAgdmFyIG5ld0EgPSAoY29sb3IuYSAqIHRoaXMuYSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IobmV3UiwgbmV3RywgbmV3QiwgbmV3QSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTY3JlZW5zIGEgY29sb3IgYnkgYW5vdGhlciwgcmVzdWx0cyBpbiBhIGxpZ2h0ZXIgY29sb3JcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBjb2xvciAgVGhlIG90aGVyIGNvbG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sb3IucHJvdG90eXBlLnNjcmVlbiA9IGZ1bmN0aW9uIChjb2xvcikge1xyXG4gICAgICAgICAgICB2YXIgY29sb3IxID0gY29sb3IuaW52ZXJ0KCk7XHJcbiAgICAgICAgICAgIHZhciBjb2xvcjIgPSBjb2xvci5pbnZlcnQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbG9yMS5tdWxpdGlwbHkoY29sb3IyKS5pbnZlcnQoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEludmVydHMgdGhlIGN1cnJlbnQgY29sb3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xvci5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKDI1NSAtIHRoaXMuciwgMjU1IC0gdGhpcy5nLCAyNTUgLSB0aGlzLmIsIDEuMCAtIHRoaXMuYSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBdmVyYWdlcyB0aGUgY3VycmVudCBjb2xvciB3aXRoIGFub3RoZXJcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBjb2xvciAgVGhlIG90aGVyIGNvbG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sb3IucHJvdG90eXBlLmF2ZXJhZ2UgPSBmdW5jdGlvbiAoY29sb3IpIHtcclxuICAgICAgICAgICAgdmFyIG5ld1IgPSAoY29sb3IuciArIHRoaXMucikgLyAyO1xyXG4gICAgICAgICAgICB2YXIgbmV3RyA9IChjb2xvci5nICsgdGhpcy5nKSAvIDI7XHJcbiAgICAgICAgICAgIHZhciBuZXdCID0gKGNvbG9yLmIgKyB0aGlzLmIpIC8gMjtcclxuICAgICAgICAgICAgdmFyIG5ld0EgPSAoY29sb3IuYSArIHRoaXMuYSkgLyAyO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKG5ld1IsIG5ld0csIG5ld0IsIG5ld0EpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIENTUyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBjb2xvci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBmb3JtYXQgQ29sb3IgcmVwcmVzZW50YXRpb24sIGFjY2VwdHM6IHJnYiwgaHNsLCBvciBoZXhcclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XHJcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09IHZvaWQgMCkgeyBmb3JtYXQgPSAncmdiJzsgfVxyXG4gICAgICAgICAgICBzd2l0Y2ggKGZvcm1hdCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAncmdiJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b1JHQkEoKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2hzbCc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9IU0xBKCk7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdoZXgnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvSGV4KCk7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBDb2xvciBmb3JtYXQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBIZXggVmFsdWUgb2YgYSBjb2xvciBjb21wb25lbnRcclxuICAgICAgICAgKiBAcGFyYW0gYyBjb2xvciBjb21wb25lbnRcclxuICAgICAgICAgKiBAc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzU2MjM4MzgvcmdiLXRvLWhleC1hbmQtaGV4LXRvLXJnYlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbG9yLnByb3RvdHlwZS5fY29tcG9uZW50VG9IZXggPSBmdW5jdGlvbiAoYykge1xyXG4gICAgICAgICAgICB2YXIgaGV4ID0gYy50b1N0cmluZygxNik7XHJcbiAgICAgICAgICAgIHJldHVybiBoZXgubGVuZ3RoID09PSAxID8gJzAnICsgaGV4IDogaGV4O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJuIEhleCByZXByZXNlbnRhdGlvbiBvZiBhIGNvbG9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbG9yLnByb3RvdHlwZS50b0hleCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICcjJyArIHRoaXMuX2NvbXBvbmVudFRvSGV4KHRoaXMucikgKyB0aGlzLl9jb21wb25lbnRUb0hleCh0aGlzLmcpICsgdGhpcy5fY29tcG9uZW50VG9IZXgodGhpcy5iKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybiBSR0JBIHJlcHJlc2VudGF0aW9uIG9mIGEgY29sb3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sb3IucHJvdG90eXBlLnRvUkdCQSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFN0cmluZyh0aGlzLnIudG9GaXhlZCgwKSkgKyAnLCAnICsgU3RyaW5nKHRoaXMuZy50b0ZpeGVkKDApKSArICcsICcgKyBTdHJpbmcodGhpcy5iLnRvRml4ZWQoMCkpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hICE9PSB1bmRlZmluZWQgfHwgdGhpcy5hICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3JnYmEoJyArIHJlc3VsdCArICcsICcgKyBTdHJpbmcodGhpcy5hKSArICcpJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gJ3JnYignICsgcmVzdWx0ICsgJyknO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJuIEhTTEEgcmVwcmVzZW50YXRpb24gb2YgYSBjb2xvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xvci5wcm90b3R5cGUudG9IU0xBID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gSFNMQ29sb3IuZnJvbVJHQkEodGhpcy5yLCB0aGlzLmcsIHRoaXMuYiwgdGhpcy5hKS50b1N0cmluZygpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIENTUyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBjb2xvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xvci5wcm90b3R5cGUuZmlsbFN0eWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBjdXJyZW50IGNvbG9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbG9yLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcih0aGlzLnIsIHRoaXMuZywgdGhpcy5iLCB0aGlzLmEpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIENvbG9yO1xyXG4gICAgfSgpKTtcclxuICAgIC8qKlxyXG4gICAgICogQmxhY2sgKCMwMDAwMDApXHJcbiAgICAgKi9cclxuICAgIENvbG9yLkJsYWNrID0gQ29sb3IuZnJvbUhleCgnIzAwMDAwMCcpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBXaGl0ZSAoI0ZGRkZGRilcclxuICAgICAqL1xyXG4gICAgQ29sb3IuV2hpdGUgPSBDb2xvci5mcm9tSGV4KCcjRkZGRkZGJyk7XHJcbiAgICAvKipcclxuICAgICAqIEdyYXkgKCM4MDgwODApXHJcbiAgICAgKi9cclxuICAgIENvbG9yLkdyYXkgPSBDb2xvci5mcm9tSGV4KCcjODA4MDgwJyk7XHJcbiAgICAvKipcclxuICAgICAqIExpZ2h0IGdyYXkgKCNEM0QzRDMpXHJcbiAgICAgKi9cclxuICAgIENvbG9yLkxpZ2h0R3JheSA9IENvbG9yLmZyb21IZXgoJyNEM0QzRDMnKTtcclxuICAgIC8qKlxyXG4gICAgICogRGFyayBncmF5ICgjQTlBOUE5KVxyXG4gICAgICovXHJcbiAgICBDb2xvci5EYXJrR3JheSA9IENvbG9yLmZyb21IZXgoJyNBOUE5QTknKTtcclxuICAgIC8qKlxyXG4gICAgICogWWVsbG93ICgjRkZGRjAwKVxyXG4gICAgICovXHJcbiAgICBDb2xvci5ZZWxsb3cgPSBDb2xvci5mcm9tSGV4KCcjRkZGRjAwJyk7XHJcbiAgICAvKipcclxuICAgICAqIE9yYW5nZSAoI0ZGQTUwMClcclxuICAgICAqL1xyXG4gICAgQ29sb3IuT3JhbmdlID0gQ29sb3IuZnJvbUhleCgnI0ZGQTUwMCcpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZWQgKCNGRjAwMDApXHJcbiAgICAgKi9cclxuICAgIENvbG9yLlJlZCA9IENvbG9yLmZyb21IZXgoJyNGRjAwMDAnKTtcclxuICAgIC8qKlxyXG4gICAgICogVmVybWlsbGlvbiAoI0ZGNUIzMSlcclxuICAgICAqL1xyXG4gICAgQ29sb3IuVmVybWlsbGlvbiA9IENvbG9yLmZyb21IZXgoJyNGRjVCMzEnKTtcclxuICAgIC8qKlxyXG4gICAgICogUm9zZSAoI0ZGMDA3RilcclxuICAgICAqL1xyXG4gICAgQ29sb3IuUm9zZSA9IENvbG9yLmZyb21IZXgoJyNGRjAwN0YnKTtcclxuICAgIC8qKlxyXG4gICAgICogTWFnZW50YSAoI0ZGMDBGRilcclxuICAgICAqL1xyXG4gICAgQ29sb3IuTWFnZW50YSA9IENvbG9yLmZyb21IZXgoJyNGRjAwRkYnKTtcclxuICAgIC8qKlxyXG4gICAgICogVmlvbGV0ICgjN0YwMEZGKVxyXG4gICAgICovXHJcbiAgICBDb2xvci5WaW9sZXQgPSBDb2xvci5mcm9tSGV4KCcjN0YwMEZGJyk7XHJcbiAgICAvKipcclxuICAgICAqIEJsdWUgKCMwMDAwRkYpXHJcbiAgICAgKi9cclxuICAgIENvbG9yLkJsdWUgPSBDb2xvci5mcm9tSGV4KCcjMDAwMEZGJyk7XHJcbiAgICAvKipcclxuICAgICAqIEF6dXJlICgjMDA3RkZGKVxyXG4gICAgICovXHJcbiAgICBDb2xvci5BenVyZSA9IENvbG9yLmZyb21IZXgoJyMwMDdGRkYnKTtcclxuICAgIC8qKlxyXG4gICAgICogQ3lhbiAoIzAwRkZGRilcclxuICAgICAqL1xyXG4gICAgQ29sb3IuQ3lhbiA9IENvbG9yLmZyb21IZXgoJyMwMEZGRkYnKTtcclxuICAgIC8qKlxyXG4gICAgICogVmlyaWRpYW4gKCM1OTk3OEYpXHJcbiAgICAgKi9cclxuICAgIENvbG9yLlZpcmlkaWFuID0gQ29sb3IuZnJvbUhleCgnIzU5OTc4RicpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHcmVlbiAoIzAwRkYwMClcclxuICAgICAqL1xyXG4gICAgQ29sb3IuR3JlZW4gPSBDb2xvci5mcm9tSGV4KCcjMDBGRjAwJyk7XHJcbiAgICAvKipcclxuICAgICAqIENoYXJ0cmV1c2UgKCM3RkZGMDApXHJcbiAgICAgKi9cclxuICAgIENvbG9yLkNoYXJ0cmV1c2UgPSBDb2xvci5mcm9tSGV4KCcjN0ZGRjAwJyk7XHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zcGFyZW50ICgjRkZGRkZGMDApXHJcbiAgICAgKi9cclxuICAgIENvbG9yLlRyYW5zcGFyZW50ID0gQ29sb3IuZnJvbUhleCgnI0ZGRkZGRjAwJyk7XHJcbiAgICBleHBvcnRzLkNvbG9yID0gQ29sb3I7XHJcbiAgICAvKipcclxuICAgICAqIEludGVybmFsIEhTTCBDb2xvciByZXByZXNlbnRhdGlvblxyXG4gICAgICpcclxuICAgICAqIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSFNMX2FuZF9IU1ZcclxuICAgICAqIGh0dHA6Ly9heG9uZmx1eC5jb20vaGFuZHktcmdiLXRvLWhzbC1hbmQtcmdiLXRvLWhzdi1jb2xvci1tb2RlbC1jXHJcbiAgICAgKi9cclxuICAgIHZhciBIU0xDb2xvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gSFNMQ29sb3IoaCwgcywgbCwgYSkge1xyXG4gICAgICAgICAgICB0aGlzLmggPSBoO1xyXG4gICAgICAgICAgICB0aGlzLnMgPSBzO1xyXG4gICAgICAgICAgICB0aGlzLmwgPSBsO1xyXG4gICAgICAgICAgICB0aGlzLmEgPSBhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBIU0xDb2xvci5odWUycmdiID0gZnVuY3Rpb24gKHAsIHEsIHQpIHtcclxuICAgICAgICAgICAgaWYgKHQgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICB0ICs9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHQgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICB0IC09IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHQgPCAxIC8gNikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHQgPCAxIC8gMikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHQgPCAyIC8gMykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHAgKyAocSAtIHApICogKDIgLyAzIC0gdCkgKiA2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgSFNMQ29sb3IuZnJvbVJHQkEgPSBmdW5jdGlvbiAociwgZywgYiwgYSkge1xyXG4gICAgICAgICAgICByIC89IDI1NTtcclxuICAgICAgICAgICAgZyAvPSAyNTU7XHJcbiAgICAgICAgICAgIGIgLz0gMjU1O1xyXG4gICAgICAgICAgICB2YXIgbWF4ID0gTWF0aC5tYXgociwgZywgYiksIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xyXG4gICAgICAgICAgICB2YXIgaCwgcywgbCA9IChtYXggKyBtaW4pIC8gMjtcclxuICAgICAgICAgICAgaWYgKG1heCA9PT0gbWluKSB7XHJcbiAgICAgICAgICAgICAgICBoID0gcyA9IDA7IC8vIGFjaHJvbWF0aWNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gbWF4IC0gbWluO1xyXG4gICAgICAgICAgICAgICAgcyA9IGwgPiAwLjUgPyBkIC8gKDIgLSBtYXggLSBtaW4pIDogZCAvIChtYXggKyBtaW4pO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChtYXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIHI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSAoZyAtIGIpIC8gZCArIChnIDwgYiA/IDYgOiAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoID0gKGIgLSByKSAvIGQgKyAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIGI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSAociAtIGcpIC8gZCArIDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaCAvPSA2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSFNMQ29sb3IoaCwgcywgbCwgYSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBIU0xDb2xvci5wcm90b3R5cGUudG9SR0JBID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgciwgZywgYjtcclxuICAgICAgICAgICAgaWYgKHRoaXMucyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgciA9IGcgPSBiID0gdGhpcy5sOyAvLyBhY2hyb21hdGljXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcSA9IHRoaXMubCA8IDAuNSA/IHRoaXMubCAqICgxICsgdGhpcy5zKSA6IHRoaXMubCArIHRoaXMucyAtIHRoaXMubCAqIHRoaXMucztcclxuICAgICAgICAgICAgICAgIHZhciBwID0gMiAqIHRoaXMubCAtIHE7XHJcbiAgICAgICAgICAgICAgICByID0gSFNMQ29sb3IuaHVlMnJnYihwLCBxLCB0aGlzLmggKyAxIC8gMyk7XHJcbiAgICAgICAgICAgICAgICBnID0gSFNMQ29sb3IuaHVlMnJnYihwLCBxLCB0aGlzLmgpO1xyXG4gICAgICAgICAgICAgICAgYiA9IEhTTENvbG9yLmh1ZTJyZ2IocCwgcSwgdGhpcy5oIC0gMSAvIDMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IociAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NSwgdGhpcy5hKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEhTTENvbG9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGggPSB0aGlzLmgudG9GaXhlZCgwKSwgcyA9IHRoaXMucy50b0ZpeGVkKDApLCBsID0gdGhpcy5sLnRvRml4ZWQoMCksIGEgPSB0aGlzLmEudG9GaXhlZCgwKTtcclxuICAgICAgICAgICAgcmV0dXJuIFwiaHNsYShcIiArIGggKyBcIiwgXCIgKyBzICsgXCIsIFwiICsgbCArIFwiLCBcIiArIGEgKyBcIilcIjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBIU0xDb2xvcjtcclxuICAgIH0oKSk7XHJcbn0pO1xyXG5kZWZpbmUoXCJDb2xsaXNpb24vQ29sbGlzaW9uQ29udGFjdFwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkFjdG9yXCIsIFwiQWxnZWJyYVwiLCBcIlBoeXNpY3NcIiwgXCJFdmVudHNcIiwgXCJVdGlsL1V0aWxcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBBY3Rvcl8xLCBBbGdlYnJhXzQsIFBoeXNpY3NfMSwgRXZlbnRzXzEsIFV0aWwpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb2xsaXNpb24gY29udGFjdHMgYXJlIHVzZWQgaW50ZXJuYWxseSBieSBFeGNhbGlidXIgdG8gcmVzb2x2ZSBjb2xsaXNpb24gYmV0d2VlbiBhY3RvcnMuIFRoaXNcclxuICAgICAqIFBhaXIgcHJldmVudHMgY29sbGlzaW9ucyBmcm9tIGJlaW5nIGV2YWx1YXRlZCBtb3JlIHRoYW4gb25lIHRpbWVcclxuICAgICAqL1xyXG4gICAgdmFyIENvbGxpc2lvbkNvbnRhY3QgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIENvbGxpc2lvbkNvbnRhY3QoYm9keUEsIGJvZHlCLCBtdHYsIHBvaW50LCBub3JtYWwpIHtcclxuICAgICAgICAgICAgdGhpcy5ib2R5QSA9IGJvZHlBO1xyXG4gICAgICAgICAgICB0aGlzLmJvZHlCID0gYm9keUI7XHJcbiAgICAgICAgICAgIHRoaXMubXR2ID0gbXR2O1xyXG4gICAgICAgICAgICB0aGlzLnBvaW50ID0gcG9pbnQ7XHJcbiAgICAgICAgICAgIHRoaXMubm9ybWFsID0gbm9ybWFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBDb2xsaXNpb25Db250YWN0LnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gKHN0cmF0ZWd5KSB7XHJcbiAgICAgICAgICAgIGlmIChzdHJhdGVneSA9PT0gUGh5c2ljc18xLkNvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneS5SaWdpZEJvZHkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVSaWdpZEJvZHlDb2xsaXNpb24oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzdHJhdGVneSA9PT0gUGh5c2ljc18xLkNvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneS5Cb3gpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVCb3hDb2xsaXNpb24oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBjb2xsaXNpb24gcmVzb2x1dGlvbiBzdHJhdGVneScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDb2xsaXNpb25Db250YWN0LnByb3RvdHlwZS5fYXBwbHlCb3hJbXB1bHNlID0gZnVuY3Rpb24gKGJvZHlBLCBib2R5QiwgbXR2KSB7XHJcbiAgICAgICAgICAgIGlmIChib2R5QS5jb2xsaXNpb25UeXBlID09PSBBY3Rvcl8xLkNvbGxpc2lvblR5cGUuQWN0aXZlICYmXHJcbiAgICAgICAgICAgICAgICBib2R5Qi5jb2xsaXNpb25UeXBlICE9PSBBY3Rvcl8xLkNvbGxpc2lvblR5cGUuUGFzc2l2ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gUmVzb2x2ZSBvdmVybGFwc1xyXG4gICAgICAgICAgICAgICAgaWYgKGJvZHlBLmNvbGxpc2lvblR5cGUgPT09IEFjdG9yXzEuQ29sbGlzaW9uVHlwZS5BY3RpdmUgJiZcclxuICAgICAgICAgICAgICAgICAgICBib2R5Qi5jb2xsaXNpb25UeXBlID09PSBBY3Rvcl8xLkNvbGxpc2lvblR5cGUuQWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc3BsaXQgb3ZlcmxhcHMgaWYgYm90aCBhcmUgQWN0aXZlXHJcbiAgICAgICAgICAgICAgICAgICAgbXR2ID0gbXR2LnNjYWxlKC41KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIEFwcGx5IG10dlxyXG4gICAgICAgICAgICAgICAgYm9keUEucG9zLnkgKz0gbXR2Lnk7XHJcbiAgICAgICAgICAgICAgICBib2R5QS5wb3MueCArPSBtdHYueDtcclxuICAgICAgICAgICAgICAgIC8vIG5vbi16ZXJvIGludGVyc2VjdGlvbiBvbiB0aGUgeSBheGlzXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tdHYueCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2ZWxYID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAvLyBib3RoIGJvZGllcyBhcmUgdHJhdmVsaW5nIGluIHRoZSBzYW1lIGRpcmVjdGlvbiAobmVnYXRpdmUgb3IgcG9zaXRpdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvZHlBLnZlbC54IDwgMCAmJiBib2R5Qi52ZWwueCA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVsWCA9IE1hdGgubWluKGJvZHlBLnZlbC54LCBib2R5Qi52ZWwueCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJvZHlBLnZlbC54ID4gMCAmJiBib2R5Qi52ZWwueCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVsWCA9IE1hdGgubWF4KGJvZHlBLnZlbC54LCBib2R5Qi52ZWwueCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJvZHlCLmNvbGxpc2lvblR5cGUgPT09IEFjdG9yXzEuQ29sbGlzaW9uVHlwZS5GaXhlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBib2RpZXMgYXJlIHRyYXZlbGluZyBpbiBvcHBvc2l0ZSBkaXJlY3Rpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChib2R5QS5wb3Muc3ViKGJvZHlCLnBvcykuZG90KGJvZHlBLnZlbCkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWxYID0gYm9keUEudmVsLng7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBib2R5QSBpcyBoZWFkaW5nIHRvd2FyZHMgYlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVsWCA9IGJvZHlCLnZlbC54O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlBLnZlbC54ID0gdmVsWDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm10di55ICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZlbFkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGJvdGggYm9kaWVzIGFyZSB0cmF2ZWxpbmcgaW4gdGhlIHNhbWUgZGlyZWN0aW9uIChuZWdhdGl2ZSBvciBwb3NpdGl2ZSlcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYm9keUEudmVsLnkgPCAwICYmIGJvZHlCLnZlbC55IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWxZID0gTWF0aC5taW4oYm9keUEudmVsLnksIGJvZHlCLnZlbC55KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYm9keUEudmVsLnkgPiAwICYmIGJvZHlCLnZlbC55ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWxZID0gTWF0aC5tYXgoYm9keUEudmVsLnksIGJvZHlCLnZlbC55KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYm9keUIuY29sbGlzaW9uVHlwZSA9PT0gQWN0b3JfMS5Db2xsaXNpb25UeXBlLkZpeGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJvZGllcyBhcmUgdHJhdmVsaW5nIGluIG9wcG9zaXRlIGRpcmVjdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJvZHlBLnBvcy5zdWIoYm9keUIucG9zKS5kb3QoYm9keUEudmVsKSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlbFkgPSBib2R5QS52ZWwueTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJvZHlBIGlzIGhlYWRpbmcgdG93YXJkcyBiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWxZID0gYm9keUIudmVsLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keUEudmVsLnkgPSB2ZWxZO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYm9keUEuZW1pdCgncG9zdGNvbGxpc2lvbicsIG5ldyBFdmVudHNfMS5Qb3N0Q29sbGlzaW9uRXZlbnQoYm9keUEsIGJvZHlCLCBVdGlsLmdldFNpZGVGcm9tVmVjdG9yKG10diksIG10dikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDb2xsaXNpb25Db250YWN0LnByb3RvdHlwZS5fcmVzb2x2ZUJveENvbGxpc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGJvZHlBID0gdGhpcy5ib2R5QS5ib2R5LmFjdG9yO1xyXG4gICAgICAgICAgICB2YXIgYm9keUIgPSB0aGlzLmJvZHlCLmJvZHkuYWN0b3I7XHJcbiAgICAgICAgICAgIHZhciBzaWRlID0gVXRpbC5nZXRTaWRlRnJvbVZlY3Rvcih0aGlzLm10dik7XHJcbiAgICAgICAgICAgIHZhciBtdHYgPSB0aGlzLm10di5uZWdhdGUoKTtcclxuICAgICAgICAgICAgLy8gUHVibGlzaCBjb2xsaXNpb24gZXZlbnRzIG9uIGJvdGggcGFydGljaXBhbnRzXHJcbiAgICAgICAgICAgIGJvZHlBLmVtaXQoJ3ByZWNvbGxpc2lvbicsIG5ldyBFdmVudHNfMS5QcmVDb2xsaXNpb25FdmVudChib2R5QSwgYm9keUIsIHNpZGUsIG10dikpO1xyXG4gICAgICAgICAgICBib2R5Qi5lbWl0KCdwcmVjb2xsaXNpb24nLCBuZXcgRXZlbnRzXzEuUHJlQ29sbGlzaW9uRXZlbnQoYm9keUIsIGJvZHlBLCBVdGlsLmdldE9wcG9zaXRlU2lkZShzaWRlKSwgbXR2Lm5lZ2F0ZSgpKSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5Qm94SW1wdWxzZShib2R5QSwgYm9keUIsIG10dik7XHJcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5Qm94SW1wdWxzZShib2R5QiwgYm9keUEsIG10di5uZWdhdGUoKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDb2xsaXNpb25Db250YWN0LnByb3RvdHlwZS5fcmVzb2x2ZVJpZ2lkQm9keUNvbGxpc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gcGVyZm9ybSBjb2xsaXNvbiBvbiBib3VuZGluZyBhcmVhc1xyXG4gICAgICAgICAgICB2YXIgYm9keUEgPSB0aGlzLmJvZHlBLmJvZHk7XHJcbiAgICAgICAgICAgIHZhciBib2R5QiA9IHRoaXMuYm9keUIuYm9keTtcclxuICAgICAgICAgICAgdmFyIG10diA9IHRoaXMubXR2OyAvLyBub3JtYWwgcG9pbnRpbmcgYXdheSBmcm9tIGJvZHlBXHJcbiAgICAgICAgICAgIHZhciBub3JtYWwgPSB0aGlzLm5vcm1hbDsgLy8gbm9ybWFsIHBvaW50aW5nIGF3YXkgZnJvbSBib2R5QVxyXG4gICAgICAgICAgICBpZiAoYm9keUEuYWN0b3IgPT09IGJvZHlCLmFjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUHVibGlzaCBjb2xsaXNpb24gZXZlbnRzIG9uIGJvdGggcGFydGljaXBhbnRzXHJcbiAgICAgICAgICAgIHZhciBzaWRlID0gVXRpbC5nZXRTaWRlRnJvbVZlY3Rvcih0aGlzLm10dik7XHJcbiAgICAgICAgICAgIGJvZHlBLmFjdG9yLmVtaXQoJ3ByZWNvbGxpc2lvbicsIG5ldyBFdmVudHNfMS5QcmVDb2xsaXNpb25FdmVudCh0aGlzLmJvZHlBLmJvZHkuYWN0b3IsIHRoaXMuYm9keUIuYm9keS5hY3Rvciwgc2lkZSwgdGhpcy5tdHYpKTtcclxuICAgICAgICAgICAgYm9keUIuYWN0b3IuZW1pdCgncHJlY29sbGlzaW9uJywgbmV3IEV2ZW50c18xLlByZUNvbGxpc2lvbkV2ZW50KHRoaXMuYm9keUIuYm9keS5hY3RvciwgdGhpcy5ib2R5QS5ib2R5LmFjdG9yLCBVdGlsLmdldE9wcG9zaXRlU2lkZShzaWRlKSwgdGhpcy5tdHYubmVnYXRlKCkpKTtcclxuICAgICAgICAgICAgLy8gSWYgYW55IG9mIHRoZSBwYXJ0aWNpcGFudHMgYXJlIHBhc3NpdmUgdGhlbiBzaG9ydCBjaXJjdWl0XHJcbiAgICAgICAgICAgIGlmIChib2R5QS5hY3Rvci5jb2xsaXNpb25UeXBlID09PSBBY3Rvcl8xLkNvbGxpc2lvblR5cGUuUGFzc2l2ZSB8fFxyXG4gICAgICAgICAgICAgICAgYm9keUIuYWN0b3IuY29sbGlzaW9uVHlwZSA9PT0gQWN0b3JfMS5Db2xsaXNpb25UeXBlLlBhc3NpdmUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaW52TWFzc0EgPSBib2R5QS5hY3Rvci5jb2xsaXNpb25UeXBlID09PSBBY3Rvcl8xLkNvbGxpc2lvblR5cGUuRml4ZWQgPyAwIDogMSAvIGJvZHlBLm1hc3M7XHJcbiAgICAgICAgICAgIHZhciBpbnZNYXNzQiA9IGJvZHlCLmFjdG9yLmNvbGxpc2lvblR5cGUgPT09IEFjdG9yXzEuQ29sbGlzaW9uVHlwZS5GaXhlZCA/IDAgOiAxIC8gYm9keUIubWFzcztcclxuICAgICAgICAgICAgdmFyIGludk1vaUEgPSBib2R5QS5hY3Rvci5jb2xsaXNpb25UeXBlID09PSBBY3Rvcl8xLkNvbGxpc2lvblR5cGUuRml4ZWQgPyAwIDogMSAvIGJvZHlBLm1vaTtcclxuICAgICAgICAgICAgdmFyIGludk1vaUIgPSBib2R5Qi5hY3Rvci5jb2xsaXNpb25UeXBlID09PSBBY3Rvcl8xLkNvbGxpc2lvblR5cGUuRml4ZWQgPyAwIDogMSAvIGJvZHlCLm1vaTtcclxuICAgICAgICAgICAgLy8gYXZlcmFnZSByZXN0aXR1dGlvbiBtb3JlIHJlbGlzdGljXHJcbiAgICAgICAgICAgIHZhciBjb2VmUmVzdGl0dXRpb24gPSBNYXRoLm1pbihib2R5QS5yZXN0aXR1dGlvbiwgYm9keUIucmVzdGl0dXRpb24pO1xyXG4gICAgICAgICAgICB2YXIgY29lZkZyaWN0aW9uID0gTWF0aC5taW4oYm9keUEuZnJpY3Rpb24sIGJvZHlCLmZyaWN0aW9uKTtcclxuICAgICAgICAgICAgbm9ybWFsID0gbm9ybWFsLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICB2YXIgdGFuZ2VudCA9IG5vcm1hbC5ub3JtYWwoKS5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgdmFyIHJhID0gdGhpcy5wb2ludC5zdWIodGhpcy5ib2R5QS5nZXRDZW50ZXIoKSk7IC8vIHBvaW50IHJlbGF0aXZlIHRvIGJvZHlBIHBvc2l0aW9uXHJcbiAgICAgICAgICAgIHZhciByYiA9IHRoaXMucG9pbnQuc3ViKHRoaXMuYm9keUIuZ2V0Q2VudGVyKCkpOyAvLy8gcG9pbnQgcmVsYXRpdmUgdG8gYm9keUJcclxuICAgICAgICAgICAgLy8gUmVsYXRpdmUgdmVsb2NpdHkgaW4gbGluZWFyIHRlcm1zXHJcbiAgICAgICAgICAgIC8vIEFuZ3VsYXIgdG8gbGluZWFyIHZlbG9jaXR5IGZvcm11bGEgLT4gb21lZ2EgPSB2L3JcclxuICAgICAgICAgICAgdmFyIHJ2ID0gYm9keUIudmVsLmFkZChyYi5jcm9zcygtYm9keUIucngpKS5zdWIoYm9keUEudmVsLnN1YihyYS5jcm9zcyhib2R5QS5yeCkpKTtcclxuICAgICAgICAgICAgdmFyIHJ2Tm9ybWFsID0gcnYuZG90KG5vcm1hbCk7XHJcbiAgICAgICAgICAgIHZhciBydlRhbmdlbnQgPSBydi5kb3QodGFuZ2VudCk7XHJcbiAgICAgICAgICAgIHZhciByYVRhbmdlbnQgPSByYS5kb3QodGFuZ2VudCk7XHJcbiAgICAgICAgICAgIHZhciByYU5vcm1hbCA9IHJhLmRvdChub3JtYWwpO1xyXG4gICAgICAgICAgICB2YXIgcmJUYW5nZW50ID0gcmIuZG90KHRhbmdlbnQpO1xyXG4gICAgICAgICAgICB2YXIgcmJOb3JtYWwgPSByYi5kb3Qobm9ybWFsKTtcclxuICAgICAgICAgICAgLy8gSWYgb2JqZWN0cyBhcmUgbW92aW5nIGF3YXkgaWdub3JlXHJcbiAgICAgICAgICAgIGlmIChydk5vcm1hbCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBDb2xsaXNpb24gaW1wdWxzZSBmb3JtdWxhIGZyb20gQ2hyaXMgSGVja2VyXHJcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbGxpc2lvbl9yZXNwb25zZVxyXG4gICAgICAgICAgICB2YXIgaW1wdWxzZSA9IC0oKDEgKyBjb2VmUmVzdGl0dXRpb24pICogcnZOb3JtYWwpIC9cclxuICAgICAgICAgICAgICAgICgoaW52TWFzc0EgKyBpbnZNYXNzQikgKyBpbnZNb2lBICogcmFUYW5nZW50ICogcmFUYW5nZW50ICsgaW52TW9pQiAqIHJiVGFuZ2VudCAqIHJiVGFuZ2VudCk7XHJcbiAgICAgICAgICAgIGlmIChib2R5QS5hY3Rvci5jb2xsaXNpb25UeXBlID09PSBBY3Rvcl8xLkNvbGxpc2lvblR5cGUuRml4ZWQpIHtcclxuICAgICAgICAgICAgICAgIGJvZHlCLnZlbCA9IGJvZHlCLnZlbC5hZGQobm9ybWFsLnNjYWxlKGltcHVsc2UgKiBpbnZNYXNzQikpO1xyXG4gICAgICAgICAgICAgICAgaWYgKFBoeXNpY3NfMS5QaHlzaWNzLmFsbG93UmlnaWRCb2R5Um90YXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBib2R5Qi5yeCAtPSBpbXB1bHNlICogaW52TW9pQiAqIC1yYi5jcm9zcyhub3JtYWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYm9keUIuYWRkTXR2KG10dik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYm9keUIuYWN0b3IuY29sbGlzaW9uVHlwZSA9PT0gQWN0b3JfMS5Db2xsaXNpb25UeXBlLkZpeGVkKSB7XHJcbiAgICAgICAgICAgICAgICBib2R5QS52ZWwgPSBib2R5QS52ZWwuc3ViKG5vcm1hbC5zY2FsZShpbXB1bHNlICogaW52TWFzc0EpKTtcclxuICAgICAgICAgICAgICAgIGlmIChQaHlzaWNzXzEuUGh5c2ljcy5hbGxvd1JpZ2lkQm9keVJvdGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keUEucnggKz0gaW1wdWxzZSAqIGludk1vaUEgKiAtcmEuY3Jvc3Mobm9ybWFsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJvZHlBLmFkZE10dihtdHYubmVnYXRlKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYm9keUIudmVsID0gYm9keUIudmVsLmFkZChub3JtYWwuc2NhbGUoaW1wdWxzZSAqIGludk1hc3NCKSk7XHJcbiAgICAgICAgICAgICAgICBib2R5QS52ZWwgPSBib2R5QS52ZWwuc3ViKG5vcm1hbC5zY2FsZShpbXB1bHNlICogaW52TWFzc0EpKTtcclxuICAgICAgICAgICAgICAgIGlmIChQaHlzaWNzXzEuUGh5c2ljcy5hbGxvd1JpZ2lkQm9keVJvdGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keUIucnggLT0gaW1wdWxzZSAqIGludk1vaUIgKiAtcmIuY3Jvc3Mobm9ybWFsKTtcclxuICAgICAgICAgICAgICAgICAgICBib2R5QS5yeCArPSBpbXB1bHNlICogaW52TW9pQSAqIC1yYS5jcm9zcyhub3JtYWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gU3BsaXQgdGhlIG10diBpbiBoYWxmIGZvciB0aGUgdHdvIGJvZGllcywgcG90ZW50aWFsbHkgd2UgY291bGQgZG8gc29tZXRoaW5nIHNtYXJ0ZXIgaGVyZVxyXG4gICAgICAgICAgICAgICAgYm9keUIuYWRkTXR2KG10di5zY2FsZSguNSkpO1xyXG4gICAgICAgICAgICAgICAgYm9keUEuYWRkTXR2KG10di5zY2FsZSgtLjUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBGcmljdGlvbiBwb3J0aW9uIG9mIGltcHVsc2VcclxuICAgICAgICAgICAgaWYgKGNvZWZGcmljdGlvbiAmJiBydlRhbmdlbnQpIHtcclxuICAgICAgICAgICAgICAgIC8vIENvbHVtYiBtb2RlbCBvZiBmcmljdGlvbiwgZm9ybXVsYSBmb3IgaW1wdWxzZSBkdWUgdG8gZnJpY3Rpb24gZnJvbSAgXHJcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db2xsaXNpb25fcmVzcG9uc2VcclxuICAgICAgICAgICAgICAgIC8vIHRhbmdlbnQgZm9yY2UgZXhlcnRlZCBieSBib2R5IG9uIGFub3RoZXIgaW4gY29udGFjdFxyXG4gICAgICAgICAgICAgICAgdmFyIHQgPSBydi5zdWIobm9ybWFsLnNjYWxlKHJ2LmRvdChub3JtYWwpKSkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBpbXB1bHNlIGluIHRoZSBkaXJlY3Rpb24gb2YgdGFuZ2VudCBmb3JjZVxyXG4gICAgICAgICAgICAgICAgdmFyIGp0ID0gcnYuZG90KHQpIC8gKGludk1hc3NBICsgaW52TWFzc0IgKyByYU5vcm1hbCAqIHJhTm9ybWFsICogaW52TW9pQSArIHJiTm9ybWFsICogcmJOb3JtYWwgKiBpbnZNb2lCKTtcclxuICAgICAgICAgICAgICAgIHZhciBmcmljdGlvbkltcHVsc2UgPSBuZXcgQWxnZWJyYV80LlZlY3RvcigwLCAwKTtcclxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhqdCkgPD0gaW1wdWxzZSAqIGNvZWZGcmljdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGZyaWN0aW9uSW1wdWxzZSA9IHQuc2NhbGUoanQpLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnJpY3Rpb25JbXB1bHNlID0gdC5zY2FsZSgtaW1wdWxzZSAqIGNvZWZGcmljdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYm9keUEuYWN0b3IuY29sbGlzaW9uVHlwZSA9PT0gQWN0b3JfMS5Db2xsaXNpb25UeXBlLkZpeGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXBwbHkgZnJpY3Rpb25hbCBpbXB1bHNlXHJcbiAgICAgICAgICAgICAgICAgICAgYm9keUIudmVsID0gYm9keUIudmVsLmFkZChmcmljdGlvbkltcHVsc2Uuc2NhbGUoaW52TWFzc0IpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoUGh5c2ljc18xLlBoeXNpY3MuYWxsb3dSaWdpZEJvZHlSb3RhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5Qi5yeCArPSBmcmljdGlvbkltcHVsc2UuZG90KHQpICogaW52TW9pQiAqIHJiLmNyb3NzKHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJvZHlCLmFjdG9yLmNvbGxpc2lvblR5cGUgPT09IEFjdG9yXzEuQ29sbGlzaW9uVHlwZS5GaXhlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFwcGx5IGZyaWN0aW9uYWwgaW1wdWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlBLnZlbCA9IGJvZHlBLnZlbC5zdWIoZnJpY3Rpb25JbXB1bHNlLnNjYWxlKGludk1hc3NBKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFBoeXNpY3NfMS5QaHlzaWNzLmFsbG93UmlnaWRCb2R5Um90YXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keUEucnggLT0gZnJpY3Rpb25JbXB1bHNlLmRvdCh0KSAqIGludk1vaUEgKiByYS5jcm9zcyh0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhcHBseSBmcmljdGlvbmFsIGltcHVsc2VcclxuICAgICAgICAgICAgICAgICAgICBib2R5Qi52ZWwgPSBib2R5Qi52ZWwuYWRkKGZyaWN0aW9uSW1wdWxzZS5zY2FsZShpbnZNYXNzQikpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlBLnZlbCA9IGJvZHlBLnZlbC5zdWIoZnJpY3Rpb25JbXB1bHNlLnNjYWxlKGludk1hc3NBKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXBwbHkgZnJpY3Rpb25hbCBpbXB1bHNlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFBoeXNpY3NfMS5QaHlzaWNzLmFsbG93UmlnaWRCb2R5Um90YXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keUIucnggKz0gZnJpY3Rpb25JbXB1bHNlLmRvdCh0KSAqIGludk1vaUIgKiByYi5jcm9zcyh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keUEucnggLT0gZnJpY3Rpb25JbXB1bHNlLmRvdCh0KSAqIGludk1vaUEgKiByYS5jcm9zcyh0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYm9keUEuYWN0b3IuZW1pdCgncG9zdGNvbGxpc2lvbicsIG5ldyBFdmVudHNfMS5Qb3N0Q29sbGlzaW9uRXZlbnQodGhpcy5ib2R5QS5ib2R5LmFjdG9yLCB0aGlzLmJvZHlCLmJvZHkuYWN0b3IsIHNpZGUsIHRoaXMubXR2KSk7XHJcbiAgICAgICAgICAgIGJvZHlCLmFjdG9yLmVtaXQoJ3Bvc3Rjb2xsaXNpb24nLCBuZXcgRXZlbnRzXzEuUG9zdENvbGxpc2lvbkV2ZW50KHRoaXMuYm9keUIuYm9keS5hY3RvciwgdGhpcy5ib2R5QS5ib2R5LmFjdG9yLCBVdGlsLmdldE9wcG9zaXRlU2lkZShzaWRlKSwgdGhpcy5tdHYubmVnYXRlKCkpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBDb2xsaXNpb25Db250YWN0O1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuQ29sbGlzaW9uQ29udGFjdCA9IENvbGxpc2lvbkNvbnRhY3Q7XHJcbn0pO1xyXG5kZWZpbmUoXCJDb2xsaXNpb24vSUNvbGxpc2lvbkFyZWFcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxufSk7XHJcbmRlZmluZShcIkNvbGxpc2lvbi9DaXJjbGVBcmVhXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiQ29sbGlzaW9uL0JvdW5kaW5nQm94XCIsIFwiQ29sbGlzaW9uL1BvbHlnb25BcmVhXCIsIFwiQ29sbGlzaW9uL0VkZ2VBcmVhXCIsIFwiQ29sbGlzaW9uL0NvbGxpc2lvbkp1bXBUYWJsZVwiLCBcIkFsZ2VicmFcIiwgXCJQaHlzaWNzXCIsIFwiRHJhd2luZy9Db2xvclwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIEJvdW5kaW5nQm94XzEsIFBvbHlnb25BcmVhXzEsIEVkZ2VBcmVhXzEsIENvbGxpc2lvbkp1bXBUYWJsZV8xLCBBbGdlYnJhXzUsIFBoeXNpY3NfMiwgQ29sb3JfMSkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgaXMgYSBjaXJjbGUgY29sbGlzaW9uIGFyZWEgZm9yIHRoZSBleGNhbGlidXIgcmlnaWQgYm9keSBwaHlzaWNzIHNpbXVsYXRpb25cclxuICAgICAqL1xyXG4gICAgdmFyIENpcmNsZUFyZWEgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIENpcmNsZUFyZWEob3B0aW9ucykge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhpcyBpcyB0aGUgY2VudGVyIHBvc2l0aW9uIG9mIHRoZSBjaXJjbGUsIHJlbGF0aXZlIHRvIHRoZSBib2R5IHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnBvcyA9IEFsZ2VicmFfNS5WZWN0b3IuWmVyby5jbG9uZSgpO1xyXG4gICAgICAgICAgICB0aGlzLnBvcyA9IG9wdGlvbnMucG9zIHx8IEFsZ2VicmFfNS5WZWN0b3IuWmVyby5jbG9uZSgpO1xyXG4gICAgICAgICAgICB0aGlzLnJhZGl1cyA9IG9wdGlvbnMucmFkaXVzIHx8IDA7XHJcbiAgICAgICAgICAgIHRoaXMuYm9keSA9IG9wdGlvbnMuYm9keSB8fCBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgdGhlIGNlbnRlciBvZiB0aGUgY29sbGlzaW9uIGFyZWEgaW4gd29ybGQgY29vcmRpbmF0ZXNcclxuICAgICAgICAgKi9cclxuICAgICAgICBDaXJjbGVBcmVhLnByb3RvdHlwZS5nZXRDZW50ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmJvZHkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBvcy5hZGQodGhpcy5ib2R5LnBvcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVzdHMgaWYgYSBwb2ludCBpcyBjb250YWluZWQgaW4gdGhpcyBjb2xsaXNpb24gYXJlYVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENpcmNsZUFyZWEucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IHRoaXMuYm9keS5wb3MuZGlzdGFuY2UocG9pbnQpO1xyXG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPD0gdGhpcy5yYWRpdXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhc3RzIGEgcmF5IGF0IHRoZSBDaXJjbGVBcmVhIGFuZCByZXR1cm5zIHRoZSBuZWFyZXN0IHBvaW50IG9mIGNvbGxpc2lvblxyXG4gICAgICAgICAqIEBwYXJhbSByYXlcclxuICAgICAgICAgKi9cclxuICAgICAgICBDaXJjbGVBcmVhLnByb3RvdHlwZS5yYXlDYXN0ID0gZnVuY3Rpb24gKHJheSwgbWF4KSB7XHJcbiAgICAgICAgICAgIGlmIChtYXggPT09IHZvaWQgMCkgeyBtYXggPSBJbmZpbml0eTsgfVxyXG4gICAgICAgICAgICAvL2h0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpbmUlRTIlODAlOTNzcGhlcmVfaW50ZXJzZWN0aW9uXHJcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5nZXRDZW50ZXIoKTtcclxuICAgICAgICAgICAgdmFyIGRpciA9IHJheS5kaXI7XHJcbiAgICAgICAgICAgIHZhciBvcmlnID0gcmF5LnBvcztcclxuICAgICAgICAgICAgdmFyIGRpc2NyaW1pbmFudCA9IE1hdGguc3FydChNYXRoLnBvdyhkaXIuZG90KG9yaWcuc3ViKGMpKSwgMikgLVxyXG4gICAgICAgICAgICAgICAgTWF0aC5wb3cob3JpZy5zdWIoYykuZGlzdGFuY2UoKSwgMikgK1xyXG4gICAgICAgICAgICAgICAgTWF0aC5wb3codGhpcy5yYWRpdXMsIDIpKTtcclxuICAgICAgICAgICAgaWYgKGRpc2NyaW1pbmFudCA8IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIG5vIGludGVyc2VjdGlvblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdG9pID0gMDtcclxuICAgICAgICAgICAgICAgIGlmIChkaXNjcmltaW5hbnQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0b2kgPSAtZGlyLmRvdChvcmlnLnN1YihjKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvaSA+IDAgJiYgdG9pIDwgbWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByYXkuZ2V0UG9pbnQodG9pKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdG9pMSA9IC1kaXIuZG90KG9yaWcuc3ViKGMpKSArIGRpc2NyaW1pbmFudDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdG9pMiA9IC1kaXIuZG90KG9yaWcuc3ViKGMpKSAtIGRpc2NyaW1pbmFudDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWludG9pID0gTWF0aC5taW4odG9pMSwgdG9pMik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pbnRvaSA8PSBtYXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJheS5nZXRQb2ludChtaW50b2kpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGluaGVyaXRkb2NcclxuICAgICAgICAgKi9cclxuICAgICAgICBDaXJjbGVBcmVhLnByb3RvdHlwZS5jb2xsaWRlID0gZnVuY3Rpb24gKGFyZWEpIHtcclxuICAgICAgICAgICAgaWYgKGFyZWEgaW5zdGFuY2VvZiBDaXJjbGVBcmVhKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29sbGlzaW9uSnVtcFRhYmxlXzEuQ29sbGlzaW9uSnVtcFRhYmxlLkNvbGxpZGVDaXJjbGVDaXJjbGUodGhpcywgYXJlYSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYXJlYSBpbnN0YW5jZW9mIFBvbHlnb25BcmVhXzEuUG9seWdvbkFyZWEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDb2xsaXNpb25KdW1wVGFibGVfMS5Db2xsaXNpb25KdW1wVGFibGUuQ29sbGlkZUNpcmNsZVBvbHlnb24odGhpcywgYXJlYSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYXJlYSBpbnN0YW5jZW9mIEVkZ2VBcmVhXzEuRWRnZUFyZWEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDb2xsaXNpb25KdW1wVGFibGVfMS5Db2xsaXNpb25KdW1wVGFibGUuQ29sbGlkZUNpcmNsZUVkZ2UodGhpcywgYXJlYSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDaXJjbGUgY291bGQgbm90IGNvbGxpZGUgd2l0aCB1bmtub3duIElDb2xsaXNpb25BcmVhIFwiICsgdHlwZW9mIGFyZWEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGaW5kIHRoZSBwb2ludCBvbiB0aGUgc2hhcGUgZnVydGhlc3QgaW4gdGhlIGRpcmVjdGlvbiBzcGVjaWZpZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBDaXJjbGVBcmVhLnByb3RvdHlwZS5nZXRGdXJ0aGVzdFBvaW50ID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDZW50ZXIoKS5hZGQoZGlyZWN0aW9uLm5vcm1hbGl6ZSgpLnNjYWxlKHRoaXMucmFkaXVzKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgdGhlIGF4aXMgYWxpZ25lZCBib3VuZGluZyBib3ggZm9yIHRoZSBjaXJjbGUgYXJlYVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENpcmNsZUFyZWEucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveF8xLkJvdW5kaW5nQm94KHRoaXMucG9zLnggKyB0aGlzLmJvZHkucG9zLnggLSB0aGlzLnJhZGl1cywgdGhpcy5wb3MueSArIHRoaXMuYm9keS5wb3MueSAtIHRoaXMucmFkaXVzLCB0aGlzLnBvcy54ICsgdGhpcy5ib2R5LnBvcy54ICsgdGhpcy5yYWRpdXMsIHRoaXMucG9zLnkgKyB0aGlzLmJvZHkucG9zLnkgKyB0aGlzLnJhZGl1cyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgYXhpcyBub3QgaW1wbGVtZW50ZWQgb24gY2lyY2xlcywgc2luY2UgdGhlcmUgYXJlIGluZmluaXRlIGF4aXMgaW4gYSBjaXJjbGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBDaXJjbGVBcmVhLnByb3RvdHlwZS5nZXRBeGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIG1vbWVudCBvZiBpbmVydGlhIG9mIGEgY2lyY2xlIGdpdmVuIGl0J3MgbWFzc1xyXG4gICAgICAgICAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpc3Rfb2ZfbW9tZW50c19vZl9pbmVydGlhXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2lyY2xlQXJlYS5wcm90b3R5cGUuZ2V0TW9tZW50T2ZJbmVydGlhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbWFzcyA9IHRoaXMuYm9keSA/IHRoaXMuYm9keS5tYXNzIDogUGh5c2ljc18yLlBoeXNpY3MuZGVmYXVsdE1hc3M7XHJcbiAgICAgICAgICAgIHJldHVybiAobWFzcyAqIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMpIC8gMjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRlc3RzIHRoZSBzZXBhcmF0aW5nIGF4aXMgdGhlb3JlbSBmb3IgY2lyY2xlcyBhZ2FpbnN0IHBvbHlnb25zXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2lyY2xlQXJlYS5wcm90b3R5cGUudGVzdFNlcGFyYXRpbmdBeGlzVGhlb3JlbSA9IGZ1bmN0aW9uIChwb2x5Z29uKSB7XHJcbiAgICAgICAgICAgIHZhciBheGVzID0gcG9seWdvbi5nZXRBeGVzKCk7XHJcbiAgICAgICAgICAgIHZhciBwYyA9IHBvbHlnb24uZ2V0Q2VudGVyKCk7XHJcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgU0FUIHdpdGggY2lyY2xlc1xyXG4gICAgICAgICAgICB2YXIgY2xvc2VzdFBvaW50T25Qb2x5ID0gcG9seWdvbi5nZXRGdXJ0aGVzdFBvaW50KHRoaXMucG9zLnN1YihwYykpO1xyXG4gICAgICAgICAgICBheGVzLnB1c2godGhpcy5wb3Muc3ViKGNsb3Nlc3RQb2ludE9uUG9seSkubm9ybWFsaXplKCkpO1xyXG4gICAgICAgICAgICB2YXIgbWluT3ZlcmxhcCA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgICAgIHZhciBtaW5BeGlzID0gbnVsbDtcclxuICAgICAgICAgICAgdmFyIG1pbkluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHByb2oxID0gcG9seWdvbi5wcm9qZWN0KGF4ZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIHByb2oyID0gdGhpcy5wcm9qZWN0KGF4ZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIG92ZXJsYXAgPSBwcm9qMS5nZXRPdmVybGFwKHByb2oyKTtcclxuICAgICAgICAgICAgICAgIGlmIChvdmVybGFwIDw9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdmVybGFwIDwgbWluT3ZlcmxhcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5PdmVybGFwID0gb3ZlcmxhcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluQXhpcyA9IGF4ZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbkluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1pbkluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1pbkF4aXMubm9ybWFsaXplKCkuc2NhbGUobWluT3ZlcmxhcCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIENpcmNsZUFyZWEucHJvdG90eXBlLnJlY2FsYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gY2lyY2xlcyBkb24ndCBjYWNoZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJvamVjdCB0aGUgY2lyY2xlIGFsb25nIGEgc3BlY2lmaWVkIGF4aXNcclxuICAgICAgICAgKi9cclxuICAgICAgICBDaXJjbGVBcmVhLnByb3RvdHlwZS5wcm9qZWN0ID0gZnVuY3Rpb24gKGF4aXMpIHtcclxuICAgICAgICAgICAgdmFyIHNjYWxhcnMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIHBvaW50ID0gdGhpcy5nZXRDZW50ZXIoKTtcclxuICAgICAgICAgICAgdmFyIGRvdFByb2R1Y3QgPSBwb2ludC5kb3QoYXhpcyk7XHJcbiAgICAgICAgICAgIHNjYWxhcnMucHVzaChkb3RQcm9kdWN0KTtcclxuICAgICAgICAgICAgc2NhbGFycy5wdXNoKGRvdFByb2R1Y3QgKyB0aGlzLnJhZGl1cyk7XHJcbiAgICAgICAgICAgIHNjYWxhcnMucHVzaChkb3RQcm9kdWN0IC0gdGhpcy5yYWRpdXMpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFsZ2VicmFfNS5Qcm9qZWN0aW9uKE1hdGgubWluLmFwcGx5KE1hdGgsIHNjYWxhcnMpLCBNYXRoLm1heC5hcHBseShNYXRoLCBzY2FsYXJzKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIENpcmNsZUFyZWEucHJvdG90eXBlLmRlYnVnRHJhdyA9IGZ1bmN0aW9uIChjdHgsIGNvbG9yKSB7XHJcbiAgICAgICAgICAgIGlmIChjb2xvciA9PT0gdm9pZCAwKSB7IGNvbG9yID0gQ29sb3JfMS5Db2xvci5HcmVlbi5jbG9uZSgpOyB9XHJcbiAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLmJvZHkgPyB0aGlzLmJvZHkucG9zLmFkZCh0aGlzLnBvcykgOiB0aGlzLnBvcztcclxuICAgICAgICAgICAgdmFyIHJvdGF0aW9uID0gdGhpcy5ib2R5ID8gdGhpcy5ib2R5LnJvdGF0aW9uIDogMDtcclxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvci50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBjdHguYXJjKHBvcy54LCBwb3MueSwgdGhpcy5yYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcclxuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgY3R4Lm1vdmVUbyhwb3MueCwgcG9zLnkpO1xyXG4gICAgICAgICAgICBjdHgubGluZVRvKE1hdGguY29zKHJvdGF0aW9uKSAqIHRoaXMucmFkaXVzICsgcG9zLngsIE1hdGguc2luKHJvdGF0aW9uKSAqIHRoaXMucmFkaXVzICsgcG9zLnkpO1xyXG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBDaXJjbGVBcmVhO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuQ2lyY2xlQXJlYSA9IENpcmNsZUFyZWE7XHJcbn0pO1xyXG5kZWZpbmUoXCJDb2xsaXNpb24vQ29sbGlzaW9uSnVtcFRhYmxlXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiQ29sbGlzaW9uL0NvbGxpc2lvbkNvbnRhY3RcIiwgXCJDb2xsaXNpb24vUG9seWdvbkFyZWFcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBDb2xsaXNpb25Db250YWN0XzEsIFBvbHlnb25BcmVhXzIpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgZXhwb3J0cy5Db2xsaXNpb25KdW1wVGFibGUgPSB7XHJcbiAgICAgICAgQ29sbGlkZUNpcmNsZUNpcmNsZTogZnVuY3Rpb24gKGNpcmNsZUEsIGNpcmNsZUIpIHtcclxuICAgICAgICAgICAgdmFyIHJhZGl1cyA9IGNpcmNsZUEucmFkaXVzICsgY2lyY2xlQi5yYWRpdXM7XHJcbiAgICAgICAgICAgIHZhciBjaXJjbGVBUG9zID0gY2lyY2xlQS5ib2R5LnBvcy5hZGQoY2lyY2xlQS5wb3MpO1xyXG4gICAgICAgICAgICB2YXIgY2lyY2xlQlBvcyA9IGNpcmNsZUIuYm9keS5wb3MuYWRkKGNpcmNsZUIucG9zKTtcclxuICAgICAgICAgICAgaWYgKGNpcmNsZUFQb3MuZGlzdGFuY2UoY2lyY2xlQlBvcykgPiByYWRpdXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBheGlzT2ZDb2xsaXNpb24gPSBjaXJjbGVCUG9zLnN1YihjaXJjbGVBUG9zKS5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgdmFyIG12dCA9IGF4aXNPZkNvbGxpc2lvbi5zY2FsZShyYWRpdXMgLSBjaXJjbGVCUG9zLmRpc3RhbmNlKGNpcmNsZUFQb3MpKTtcclxuICAgICAgICAgICAgdmFyIHBvaW50T2ZDb2xsaXNpb24gPSBjaXJjbGVBLmdldEZ1cnRoZXN0UG9pbnQoYXhpc09mQ29sbGlzaW9uKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xsaXNpb25Db250YWN0XzEuQ29sbGlzaW9uQ29udGFjdChjaXJjbGVBLCBjaXJjbGVCLCBtdnQsIHBvaW50T2ZDb2xsaXNpb24sIGF4aXNPZkNvbGxpc2lvbik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBDb2xsaWRlQ2lyY2xlUG9seWdvbjogZnVuY3Rpb24gKGNpcmNsZSwgcG9seWdvbikge1xyXG4gICAgICAgICAgICB2YXIgbWluQXhpcyA9IGNpcmNsZS50ZXN0U2VwYXJhdGluZ0F4aXNUaGVvcmVtKHBvbHlnb24pO1xyXG4gICAgICAgICAgICBpZiAoIW1pbkF4aXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGF0IHRoZSBtaW5BeGlzIGlzIHBvaW50aW5nIGF3YXkgZnJvbSBjaXJjbGVcclxuICAgICAgICAgICAgdmFyIHNhbWVkaXIgPSBtaW5BeGlzLmRvdChwb2x5Z29uLmdldENlbnRlcigpLnN1YihjaXJjbGUuZ2V0Q2VudGVyKCkpKTtcclxuICAgICAgICAgICAgbWluQXhpcyA9IHNhbWVkaXIgPCAwID8gbWluQXhpcy5uZWdhdGUoKSA6IG1pbkF4aXM7XHJcbiAgICAgICAgICAgIHZhciB2ZXJ0cyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgcG9pbnQxID0gcG9seWdvbi5nZXRGdXJ0aGVzdFBvaW50KG1pbkF4aXMubmVnYXRlKCkpO1xyXG4gICAgICAgICAgICB2YXIgcG9pbnQyID0gY2lyY2xlLmdldEZ1cnRoZXN0UG9pbnQobWluQXhpcyk7IC8vLmFkZChjYyk7XHJcbiAgICAgICAgICAgIGlmIChjaXJjbGUuY29udGFpbnMocG9pbnQxKSkge1xyXG4gICAgICAgICAgICAgICAgdmVydHMucHVzaChwb2ludDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwb2x5Z29uLmNvbnRhaW5zKHBvaW50MikpIHtcclxuICAgICAgICAgICAgICAgIHZlcnRzLnB1c2gocG9pbnQyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodmVydHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbGxpc2lvbkNvbnRhY3RfMS5Db2xsaXNpb25Db250YWN0KGNpcmNsZSwgcG9seWdvbiwgbWluQXhpcywgdmVydHMubGVuZ3RoID09PSAyID8gdmVydHNbMF0uYXZlcmFnZSh2ZXJ0c1sxXSkgOiB2ZXJ0c1swXSwgbWluQXhpcy5ub3JtYWxpemUoKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBDb2xsaWRlQ2lyY2xlRWRnZTogZnVuY3Rpb24gKGNpcmNsZSwgZWRnZSkge1xyXG4gICAgICAgICAgICAvLyBjZW50ZXIgb2YgdGhlIGNpcmNsZVxyXG4gICAgICAgICAgICB2YXIgY2MgPSBjaXJjbGUuZ2V0Q2VudGVyKCk7XHJcbiAgICAgICAgICAgIC8vIHZlY3RvciBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBlZGdlXHJcbiAgICAgICAgICAgIHZhciBlID0gZWRnZS5lbmQuc3ViKGVkZ2UuYmVnaW4pO1xyXG4gICAgICAgICAgICAvLyBhbW91bnQgb2Ygb3ZlcmxhcCB3aXRoIHRoZSBjaXJjbGUncyBjZW50ZXIgYWxvbmcgdGhlIGVkZ2UgZGlyZWN0aW9uXHJcbiAgICAgICAgICAgIHZhciB1ID0gZS5kb3QoZWRnZS5lbmQuc3ViKGNjKSk7XHJcbiAgICAgICAgICAgIHZhciB2ID0gZS5kb3QoY2Muc3ViKGVkZ2UuYmVnaW4pKTtcclxuICAgICAgICAgICAgLy8gUG90ZW50aWFsIHJlZ2lvbiBBIGNvbGxpc2lvbiAoY2lyY2xlIGlzIG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIGVkZ2UsIGJlZm9yZSB0aGUgYmVnaW5uaW5nKVxyXG4gICAgICAgICAgICBpZiAodiA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGEgPSBlZGdlLmJlZ2luLnN1YihjYyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGRhID0gZGEuZG90KGRhKTsgLy8gcXVpY2sgYW5kIGRpcnR5IHdheSBvZiBjYWxjJ24gZGlzdGFuY2UgaW4gcl4yIHRlcm1zIHNhdmVzIHNvbWUgc3FydHNcclxuICAgICAgICAgICAgICAgIC8vIHNhdmUgc29tZSBzcXJ0c1xyXG4gICAgICAgICAgICAgICAgaWYgKGRkYSA+IGNpcmNsZS5yYWRpdXMgKiBjaXJjbGUucmFkaXVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIG5vIGNvbGxpc2lvblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xsaXNpb25Db250YWN0XzEuQ29sbGlzaW9uQ29udGFjdChjaXJjbGUsIGVkZ2UsIGRhLm5vcm1hbGl6ZSgpLnNjYWxlKGNpcmNsZS5yYWRpdXMgLSBNYXRoLnNxcnQoZGRhKSksIGVkZ2UuYmVnaW4sIGRhLm5vcm1hbGl6ZSgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBQb3RlbnRpYWwgcmVnaW9uIEIgY29sbGlzaW9uIChjaXJjbGUgaXMgb24gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGVkZ2UsIGFmdGVyIHRoZSBlbmQpXHJcbiAgICAgICAgICAgIGlmICh1IDw9IDApIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYiA9IGVkZ2UuZW5kLnN1YihjYyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGRiID0gZGIuZG90KGRiKTtcclxuICAgICAgICAgICAgICAgIGlmIChkZGIgPiBjaXJjbGUucmFkaXVzICogY2lyY2xlLnJhZGl1cykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xsaXNpb25Db250YWN0XzEuQ29sbGlzaW9uQ29udGFjdChjaXJjbGUsIGVkZ2UsIGRiLm5vcm1hbGl6ZSgpLnNjYWxlKGNpcmNsZS5yYWRpdXMgLSBNYXRoLnNxcnQoZGRiKSksIGVkZ2UuZW5kLCBkYi5ub3JtYWxpemUoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHBvdGVudGlhbCByZWdpb24gQUIgY29sbGlzaW9uIChjaXJjbGUgaXMgaW4gdGhlIG1pZGRsZSBvZiB0aGUgZWRnZSBiZXR3ZWVuIHRoZSBiZWdpbm5pbmcgYW5kIGVuZClcclxuICAgICAgICAgICAgdmFyIGRlbiA9IGUuZG90KGUpO1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRPbkVkZ2UgPSAoZWRnZS5iZWdpbi5zY2FsZSh1KS5hZGQoZWRnZS5lbmQuc2NhbGUodikpKS5zY2FsZSgxIC8gZGVuKTtcclxuICAgICAgICAgICAgdmFyIGQgPSBjYy5zdWIocG9pbnRPbkVkZ2UpO1xyXG4gICAgICAgICAgICB2YXIgZGQgPSBkLmRvdChkKTtcclxuICAgICAgICAgICAgaWYgKGRkID4gY2lyY2xlLnJhZGl1cyAqIGNpcmNsZS5yYWRpdXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyBubyBjb2xsaXNpb25cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbiA9IGUucGVycGVuZGljdWxhcigpO1xyXG4gICAgICAgICAgICAvLyBmbGlwIGNvcnJlY3QgZGlyZWN0aW9uXHJcbiAgICAgICAgICAgIGlmIChuLmRvdChjYy5zdWIoZWRnZS5iZWdpbikpIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgbi54ID0gLW4ueDtcclxuICAgICAgICAgICAgICAgIG4ueSA9IC1uLnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbiA9IG4ubm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgIHZhciBtdnQgPSBuLnNjYWxlKE1hdGguYWJzKGNpcmNsZS5yYWRpdXMgLSBNYXRoLnNxcnQoZGQpKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sbGlzaW9uQ29udGFjdF8xLkNvbGxpc2lvbkNvbnRhY3QoY2lyY2xlLCBlZGdlLCBtdnQubmVnYXRlKCksIHBvaW50T25FZGdlLCBuLm5lZ2F0ZSgpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIENvbGxpZGVFZGdlRWRnZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBFZGdlLWVkZ2UgY29sbGlzaW9uIGRvZXNuJ3QgbWFrZSBzZW5zZVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIENvbGxpZGVQb2x5Z29uRWRnZTogZnVuY3Rpb24gKHBvbHlnb24sIGVkZ2UpIHtcclxuICAgICAgICAgICAgLy8gMyBjYXNlczpcclxuICAgICAgICAgICAgLy8gKDEpIFBvbHlnb24gbGFuZHMgb24gdGhlIGZ1bGwgZmFjZVxyXG4gICAgICAgICAgICAvLyAoMikgUG9seWdvbiBsYW5kcyBvbiB0aGUgcmlnaHQgcG9pbnRcclxuICAgICAgICAgICAgLy8gKDMpIFBvbHlnb24gbGFuZHMgb24gdGhlIGxlZnQgcG9pbnRcclxuICAgICAgICAgICAgdmFyIGUgPSBlZGdlLmVuZC5zdWIoZWRnZS5iZWdpbik7XHJcbiAgICAgICAgICAgIHZhciBlZGdlTm9ybWFsID0gZS5ub3JtYWwoKTtcclxuICAgICAgICAgICAgaWYgKHBvbHlnb24uY29udGFpbnMoZWRnZS5iZWdpbikpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfYSA9IHBvbHlnb24uZ2V0Q2xvc2VzdEZhY2UoZWRnZS5iZWdpbiksIG10diA9IF9hLmRpc3RhbmNlLCBmYWNlID0gX2EuZmFjZTtcclxuICAgICAgICAgICAgICAgIGlmIChtdHYpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbGxpc2lvbkNvbnRhY3RfMS5Db2xsaXNpb25Db250YWN0KHBvbHlnb24sIGVkZ2UsIG10di5uZWdhdGUoKSwgZWRnZS5iZWdpbi5hZGQobXR2Lm5lZ2F0ZSgpKSwgZmFjZS5ub3JtYWwoKS5uZWdhdGUoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHBvbHlnb24uY29udGFpbnMoZWRnZS5lbmQpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2IgPSBwb2x5Z29uLmdldENsb3Nlc3RGYWNlKGVkZ2UuZW5kKSwgbXR2ID0gX2IuZGlzdGFuY2UsIGZhY2UgPSBfYi5mYWNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKG10dikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29sbGlzaW9uQ29udGFjdF8xLkNvbGxpc2lvbkNvbnRhY3QocG9seWdvbiwgZWRnZSwgbXR2Lm5lZ2F0ZSgpLCBlZGdlLmVuZC5hZGQobXR2Lm5lZ2F0ZSgpKSwgZmFjZS5ub3JtYWwoKS5uZWdhdGUoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHBjID0gcG9seWdvbi5nZXRDZW50ZXIoKTtcclxuICAgICAgICAgICAgdmFyIGVjID0gZWRnZS5nZXRDZW50ZXIoKTtcclxuICAgICAgICAgICAgdmFyIGRpciA9IGVjLnN1YihwYykubm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgIC8vIGJ1aWxkIGEgdGVtcG9yYXJ5IHBvbHlnb24gZnJvbSB0aGUgZWRnZSB0byB1c2UgU0FUXHJcbiAgICAgICAgICAgIHZhciBsaW5lUG9seSA9IG5ldyBQb2x5Z29uQXJlYV8yLlBvbHlnb25BcmVhKHtcclxuICAgICAgICAgICAgICAgIHBvaW50czogW1xyXG4gICAgICAgICAgICAgICAgICAgIGVkZ2UuYmVnaW4sXHJcbiAgICAgICAgICAgICAgICAgICAgZWRnZS5lbmQsXHJcbiAgICAgICAgICAgICAgICAgICAgZWRnZS5lbmQuYWRkKGRpci5zY2FsZSgzMCkpLFxyXG4gICAgICAgICAgICAgICAgICAgIGVkZ2UuYmVnaW4uYWRkKGRpci5zY2FsZSgzMCkpXHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2YXIgbWluQXhpcyA9IHBvbHlnb24udGVzdFNlcGFyYXRpbmdBeGlzVGhlb3JlbShsaW5lUG9seSk7XHJcbiAgICAgICAgICAgIC8vIG5vIG1pbkF4aXMsIG5vIG92ZXJsYXAsIG5vIGNvbGxpc2lvblxyXG4gICAgICAgICAgICBpZiAoIW1pbkF4aXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGZsaXAgdGhlIG5vcm1hbCBhbmQgYXhpcyB0byBhbHdheXMgaGF2ZSBwb3NpdGl2ZSBjb2xsaXNpb25zXHJcbiAgICAgICAgICAgIGVkZ2VOb3JtYWwgPSBlZGdlTm9ybWFsLmRvdChkaXIpIDwgMCA/IGVkZ2VOb3JtYWwubmVnYXRlKCkgOiBlZGdlTm9ybWFsO1xyXG4gICAgICAgICAgICBtaW5BeGlzID0gbWluQXhpcy5kb3QoZGlyKSA8IDAgPyBtaW5BeGlzLm5lZ2F0ZSgpIDogbWluQXhpcztcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xsaXNpb25Db250YWN0XzEuQ29sbGlzaW9uQ29udGFjdChwb2x5Z29uLCBlZGdlLCBtaW5BeGlzLCBwb2x5Z29uLmdldEZ1cnRoZXN0UG9pbnQoZWRnZU5vcm1hbCksIGVkZ2VOb3JtYWwpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgQ29sbGlkZVBvbHlnb25Qb2x5Z29uOiBmdW5jdGlvbiAocG9seUEsIHBvbHlCKSB7XHJcbiAgICAgICAgICAgIC8vIGRvIGEgU0FUIHRlc3QgdG8gZmluZCBhIG1pbiBheGlzIGlmIGl0IGV4aXN0c1xyXG4gICAgICAgICAgICB2YXIgbWluQXhpcyA9IHBvbHlBLnRlc3RTZXBhcmF0aW5nQXhpc1RoZW9yZW0ocG9seUIpO1xyXG4gICAgICAgICAgICAvLyBubyBvdmVybGFwLCBubyBjb2xsaXNpb24gcmV0dXJuIG51bGxcclxuICAgICAgICAgICAgaWYgKCFtaW5BeGlzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhhdCBtaW5BeGlzIGlzIHBvaW50aW5nIGZyb20gQSAtPiBCXHJcbiAgICAgICAgICAgIHZhciBzYW1lRGlyID0gbWluQXhpcy5kb3QocG9seUIuZ2V0Q2VudGVyKCkuc3ViKHBvbHlBLmdldENlbnRlcigpKSk7XHJcbiAgICAgICAgICAgIG1pbkF4aXMgPSBzYW1lRGlyIDwgMCA/IG1pbkF4aXMubmVnYXRlKCkgOiBtaW5BeGlzO1xyXG4gICAgICAgICAgICAvLyBmaW5kIHJvdWdoIHBvaW50IG9mIGNvbGxpc2lvblxyXG4gICAgICAgICAgICAvLyB0b2RvIHRoaXMgY291bGQgYmUgYmV0dGVyXHJcbiAgICAgICAgICAgIHZhciB2ZXJ0cyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRBID0gcG9seUEuZ2V0RnVydGhlc3RQb2ludChtaW5BeGlzKTtcclxuICAgICAgICAgICAgdmFyIHBvaW50QiA9IHBvbHlCLmdldEZ1cnRoZXN0UG9pbnQobWluQXhpcy5uZWdhdGUoKSk7XHJcbiAgICAgICAgICAgIGlmIChwb2x5Qi5jb250YWlucyhwb2ludEEpKSB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0cy5wdXNoKHBvaW50QSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHBvbHlBLmNvbnRhaW5zKHBvaW50QikpIHtcclxuICAgICAgICAgICAgICAgIHZlcnRzLnB1c2gocG9pbnRCKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBubyBjYW5kaWRhdGVzLCBwaWNrIHNvbWV0aGluZ1xyXG4gICAgICAgICAgICBpZiAodmVydHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0cy5wdXNoKHBvaW50Qik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGNvbnRhY3QgPSB2ZXJ0cy5sZW5ndGggPT09IDIgPyB2ZXJ0c1swXS5hZGQodmVydHNbMV0pLnNjYWxlKC41KSA6IHZlcnRzWzBdO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbGxpc2lvbkNvbnRhY3RfMS5Db2xsaXNpb25Db250YWN0KHBvbHlBLCBwb2x5QiwgbWluQXhpcywgY29udGFjdCwgbWluQXhpcy5ub3JtYWxpemUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufSk7XHJcbmRlZmluZShcIkNvbGxpc2lvbi9Qb2x5Z29uQXJlYVwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkRyYXdpbmcvQ29sb3JcIiwgXCJQaHlzaWNzXCIsIFwiQ29sbGlzaW9uL0JvdW5kaW5nQm94XCIsIFwiQ29sbGlzaW9uL0VkZ2VBcmVhXCIsIFwiQ29sbGlzaW9uL0NvbGxpc2lvbkp1bXBUYWJsZVwiLCBcIkNvbGxpc2lvbi9DaXJjbGVBcmVhXCIsIFwiQWxnZWJyYVwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIENvbG9yXzIsIFBoeXNpY3NfMywgQm91bmRpbmdCb3hfMiwgRWRnZUFyZWFfMiwgQ29sbGlzaW9uSnVtcFRhYmxlXzIsIENpcmNsZUFyZWFfMSwgQWxnZWJyYV82KSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogUG9seWdvbiBjb2xsaXNpb24gYXJlYSBmb3IgZGV0ZWN0aW5nIGNvbGxpc2lvbnMgZm9yIGFjdG9ycywgb3IgaW5kZXBlbmRlbnRseVxyXG4gICAgICovXHJcbiAgICB2YXIgUG9seWdvbkFyZWEgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIFBvbHlnb25BcmVhKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtZWRQb2ludHMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5fYXhlcyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLl9zaWRlcyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLnBvcyA9IG9wdGlvbnMucG9zIHx8IEFsZ2VicmFfNi5WZWN0b3IuWmVyby5jbG9uZSgpO1xyXG4gICAgICAgICAgICB2YXIgd2luZGluZyA9ICEhb3B0aW9ucy5jbG9ja3dpc2VXaW5kaW5nO1xyXG4gICAgICAgICAgICB0aGlzLnBvaW50cyA9ICh3aW5kaW5nID8gb3B0aW9ucy5wb2ludHMucmV2ZXJzZSgpIDogb3B0aW9ucy5wb2ludHMpIHx8IFtdO1xyXG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBvcHRpb25zLmJvZHkgfHwgbnVsbDtcclxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIGluaXRpYWwgdHJhbnNmb3JtYXRpb25cclxuICAgICAgICAgICAgdGhpcy5fY2FsY3VsYXRlVHJhbnNmb3JtYXRpb24oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IHRoZSBjZW50ZXIgb2YgdGhlIGNvbGxpc2lvbiBhcmVhIGluIHdvcmxkIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUG9seWdvbkFyZWEucHJvdG90eXBlLmdldENlbnRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYm9keSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5wb3MuYWRkKHRoaXMucG9zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3M7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSB1bmRlcmx5aW5nIHRyYW5zZm9ybWF0aW9uIGZyb20gdGhlIGJvZHkgcmVsYXRpdmUgc3BhY2UgdG8gd29ybGQgc3BhY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBQb2x5Z29uQXJlYS5wcm90b3R5cGUuX2NhbGN1bGF0ZVRyYW5zZm9ybWF0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5ib2R5ID8gdGhpcy5ib2R5LnBvcy5hZGQodGhpcy5wb3MpIDogdGhpcy5wb3M7XHJcbiAgICAgICAgICAgIHZhciBhbmdsZSA9IHRoaXMuYm9keSA/IHRoaXMuYm9keS5yb3RhdGlvbiA6IDA7XHJcbiAgICAgICAgICAgIHZhciBsZW4gPSB0aGlzLnBvaW50cy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybWVkUG9pbnRzLmxlbmd0aCA9IDA7IC8vIGNsZWFyIG91dCBvbGQgdHJhbnNmb3JtXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybWVkUG9pbnRzW2ldID0gdGhpcy5wb2ludHNbaV0ucm90YXRlKGFuZ2xlKS5hZGQocG9zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgcG9pbnRzIHRoYXQgbWFrZSB1cCB0aGUgcG9seWdvbiBpbiB3b3JsZCBzcGFjZSwgZnJvbSBhY3RvciByZWxhdGl2ZSBzcGFjZSAoaWYgc3BlY2lmaWVkKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBvbHlnb25BcmVhLnByb3RvdHlwZS5nZXRUcmFuc2Zvcm1lZFBvaW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl90cmFuc2Zvcm1lZFBvaW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGN1bGF0ZVRyYW5zZm9ybWF0aW9uKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtZWRQb2ludHM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBzaWRlcyBvZiB0aGUgcG9seWdvbiBpbiB3b3JsZCBzcGFjZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBvbHlnb25BcmVhLnByb3RvdHlwZS5nZXRTaWRlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3NpZGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpZGVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBsaW5lcyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50cygpO1xyXG4gICAgICAgICAgICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbGluZXMucHVzaChuZXcgQWxnZWJyYV82LkxpbmUocG9pbnRzW2ldLCBwb2ludHNbKGkgLSAxICsgbGVuKSAlIGxlbl0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9zaWRlcyA9IGxpbmVzO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2lkZXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQb2x5Z29uQXJlYS5wcm90b3R5cGUucmVjYWxjID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zaWRlcy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9heGVzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybWVkUG9pbnRzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludHMoKTtcclxuICAgICAgICAgICAgdGhpcy5nZXRBeGVzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0U2lkZXMoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRlc3RzIGlmIGEgcG9pbnQgaXMgY29udGFpbmVkIGluIHRoaXMgY29sbGlzaW9uIGFyZWEgaW4gd29ybGQgc3BhY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBQb2x5Z29uQXJlYS5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAocG9pbnQpIHtcclxuICAgICAgICAgICAgLy8gQWx3YXlzIGNhc3QgdG8gdGhlIHJpZ2h0LCBhcyBsb25nIGFzIHdlIGNhc3QgaW4gYSBjb25zaXRlbnQgZml4ZWQgZGlyZWN0aW9uIHdlXHJcbiAgICAgICAgICAgIC8vIHdpbGwgYmUgZmluZVxyXG4gICAgICAgICAgICB2YXIgdGVzdFJheSA9IG5ldyBBbGdlYnJhXzYuUmF5KHBvaW50LCBuZXcgQWxnZWJyYV82LlZlY3RvcigxLCAwKSk7XHJcbiAgICAgICAgICAgIHZhciBpbnRlcnNlY3RDb3VudCA9IHRoaXMuZ2V0U2lkZXMoKS5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtLCBzaWRlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGVzdFJheS5pbnRlcnNlY3Qoc2lkZSkgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bSArIDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW07XHJcbiAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0Q291bnQgJSAyID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgY29sbGlzaW9uIGNvbnRhY3QgaWYgdGhlIDIgY29sbGlzaW9uIGFyZWFzIGNvbGxpZGUsIG90aGVyd2lzZSBjb2xsaWRlIHdpbGxcclxuICAgICAgICAgKiByZXR1cm4gbnVsbC5cclxuICAgICAgICAgKiBAcGFyYW0gYXJlYVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBvbHlnb25BcmVhLnByb3RvdHlwZS5jb2xsaWRlID0gZnVuY3Rpb24gKGFyZWEpIHtcclxuICAgICAgICAgICAgaWYgKGFyZWEgaW5zdGFuY2VvZiBDaXJjbGVBcmVhXzEuQ2lyY2xlQXJlYSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbGxpc2lvbkp1bXBUYWJsZV8yLkNvbGxpc2lvbkp1bXBUYWJsZS5Db2xsaWRlQ2lyY2xlUG9seWdvbihhcmVhLCB0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChhcmVhIGluc3RhbmNlb2YgUG9seWdvbkFyZWEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDb2xsaXNpb25KdW1wVGFibGVfMi5Db2xsaXNpb25KdW1wVGFibGUuQ29sbGlkZVBvbHlnb25Qb2x5Z29uKHRoaXMsIGFyZWEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGFyZWEgaW5zdGFuY2VvZiBFZGdlQXJlYV8yLkVkZ2VBcmVhKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29sbGlzaW9uSnVtcFRhYmxlXzIuQ29sbGlzaW9uSnVtcFRhYmxlLkNvbGxpZGVQb2x5Z29uRWRnZSh0aGlzLCBhcmVhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvbHlnb24gY291bGQgbm90IGNvbGxpZGUgd2l0aCB1bmtub3duIElDb2xsaXNpb25BcmVhIFwiICsgdHlwZW9mIGFyZWEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGaW5kIHRoZSBwb2ludCBvbiB0aGUgc2hhcGUgZnVydGhlc3QgaW4gdGhlIGRpcmVjdGlvbiBzcGVjaWZpZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBQb2x5Z29uQXJlYS5wcm90b3R5cGUuZ2V0RnVydGhlc3RQb2ludCA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgdmFyIHB0cyA9IHRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludHMoKTtcclxuICAgICAgICAgICAgdmFyIGZ1cnRoZXN0UG9pbnQgPSBudWxsO1xyXG4gICAgICAgICAgICB2YXIgbWF4RGlzdGFuY2UgPSAtTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IGRpcmVjdGlvbi5kb3QocHRzW2ldKTtcclxuICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZSA+IG1heERpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4RGlzdGFuY2UgPSBkaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICBmdXJ0aGVzdFBvaW50ID0gcHRzW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmdXJ0aGVzdFBvaW50O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmluZHMgdGhlIGNsb3NlcyBmYWNlIHRvIHRoZSBwb2ludCB1c2luZyBwZXJwZW5kaWN1bGFyIGRpc3RhbmNlXHJcbiAgICAgICAgICogQHBhcmFtIHBvaW50IHBvaW50IHRvIHRlc3QgYWdhaW5zdCBwb2x5Z29uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUG9seWdvbkFyZWEucHJvdG90eXBlLmdldENsb3Nlc3RGYWNlID0gZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgICAgICAgICAgIHZhciBzaWRlcyA9IHRoaXMuZ2V0U2lkZXMoKTtcclxuICAgICAgICAgICAgdmFyIG1pbiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuICAgICAgICAgICAgdmFyIGZhY2VJbmRleCA9IC0xO1xyXG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSAtMTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWRlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRpc3QgPSBzaWRlc1tpXS5kaXN0YW5jZVRvUG9pbnQocG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpc3QgPCBtaW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBkaXN0O1xyXG4gICAgICAgICAgICAgICAgICAgIGZhY2VJbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBkaXN0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmYWNlSW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlOiBzaWRlc1tmYWNlSW5kZXhdLm5vcm1hbCgpLnNjYWxlKGRpc3RhbmNlKSxcclxuICAgICAgICAgICAgICAgICAgICBmYWNlOiBzaWRlc1tmYWNlSW5kZXhdXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IHRoZSBheGlzIGFsaWduZWQgYm91bmRpbmcgYm94IGZvciB0aGUgcG9seWdvbiBhcmVhXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUG9seWdvbkFyZWEucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gdG9kbyB0aGVyZSBpcyBhIGZhc3RlciB3YXkgdG8gZG8gdGhpc1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50cygpO1xyXG4gICAgICAgICAgICB2YXIgbWluWCA9IHBvaW50cy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cnIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbihwcmV2LCBjdXJyLngpO1xyXG4gICAgICAgICAgICB9LCA5OTk5OTk5OTkpO1xyXG4gICAgICAgICAgICB2YXIgbWF4WCA9IHBvaW50cy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cnIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChwcmV2LCBjdXJyLngpO1xyXG4gICAgICAgICAgICB9LCAtOTk5OTk5OTkpO1xyXG4gICAgICAgICAgICB2YXIgbWluWSA9IHBvaW50cy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cnIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbihwcmV2LCBjdXJyLnkpO1xyXG4gICAgICAgICAgICB9LCA5OTk5OTk5OTk5KTtcclxuICAgICAgICAgICAgdmFyIG1heFkgPSBwb2ludHMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgocHJldiwgY3Vyci55KTtcclxuICAgICAgICAgICAgfSwgLTk5OTk5OTk5OTkpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJvdW5kaW5nQm94XzIuQm91bmRpbmdCb3gobWluWCwgbWluWSwgbWF4WCwgbWF4WSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgdGhlIG1vbWVudCBvZiBpbmVydGlhIGZvciBhbiBhcmJpdHJhcnkgcG9seWdvblxyXG4gICAgICAgICAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpc3Rfb2ZfbW9tZW50c19vZl9pbmVydGlhXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUG9seWdvbkFyZWEucHJvdG90eXBlLmdldE1vbWVudE9mSW5lcnRpYSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG1hc3MgPSB0aGlzLmJvZHkgPyB0aGlzLmJvZHkubWFzcyA6IFBoeXNpY3NfMy5QaHlzaWNzLmRlZmF1bHRNYXNzO1xyXG4gICAgICAgICAgICB2YXIgbnVtZXJhdG9yID0gMDtcclxuICAgICAgICAgICAgdmFyIGRlbm9taW5hdG9yID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBvaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlwbHVzb25lID0gKGkgKyAxKSAlIHRoaXMucG9pbnRzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHZhciBjcm9zc1Rlcm0gPSB0aGlzLnBvaW50c1tpcGx1c29uZV0uY3Jvc3ModGhpcy5wb2ludHNbaV0pO1xyXG4gICAgICAgICAgICAgICAgbnVtZXJhdG9yICs9IGNyb3NzVGVybSAqICh0aGlzLnBvaW50c1tpXS5kb3QodGhpcy5wb2ludHNbaV0pICtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvaW50c1tpXS5kb3QodGhpcy5wb2ludHNbaXBsdXNvbmVdKSArXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2ludHNbaXBsdXNvbmVdLmRvdCh0aGlzLnBvaW50c1tpcGx1c29uZV0pKTtcclxuICAgICAgICAgICAgICAgIGRlbm9taW5hdG9yICs9IGNyb3NzVGVybTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gKG1hc3MgLyA2KSAqIChudW1lcmF0b3IgLyBkZW5vbWluYXRvcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYXN0cyBhIHJheSBpbnRvIHRoZSBwb2x5Z29uIGFuZCByZXR1cm5zIGEgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgcG9pbnQgb2YgY29udGFjdCAoaW4gd29ybGQgc3BhY2UpIG9yIG51bGwgaWYgbm8gY29sbGlzaW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBvbHlnb25BcmVhLnByb3RvdHlwZS5yYXlDYXN0ID0gZnVuY3Rpb24gKHJheSwgbWF4KSB7XHJcbiAgICAgICAgICAgIGlmIChtYXggPT09IHZvaWQgMCkgeyBtYXggPSBJbmZpbml0eTsgfVxyXG4gICAgICAgICAgICAvLyBmaW5kIHRoZSBtaW5pbXVtIGNvbnRhY3QgdGltZSBncmVhdGVyIHRoYW4gMFxyXG4gICAgICAgICAgICAvLyBjb250YWN0IHRpbWVzIGxlc3MgdGhhbiAwIGFyZSBiZWhpbmQgdGhlIHJheSBhbmQgd2UgZG9uJ3Qgd2FudCB0aG9zZVxyXG4gICAgICAgICAgICB2YXIgc2lkZXMgPSB0aGlzLmdldFNpZGVzKCk7XHJcbiAgICAgICAgICAgIHZhciBsZW4gPSBzaWRlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHZhciBtaW5Db250YWN0VGltZSA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgICAgIHZhciBjb250YWN0SW5kZXggPSAtMTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhY3RUaW1lID0gcmF5LmludGVyc2VjdChzaWRlc1tpXSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udGFjdFRpbWUgPj0gMCAmJiBjb250YWN0VGltZSA8IG1pbkNvbnRhY3RUaW1lICYmIGNvbnRhY3RUaW1lIDw9IG1heCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbkNvbnRhY3RUaW1lID0gY29udGFjdFRpbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGFjdEluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjb250YWN0IHdhcyBmb3VuZFxyXG4gICAgICAgICAgICBpZiAoY29udGFjdEluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByYXkuZ2V0UG9pbnQobWluQ29udGFjdFRpbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIG5vIGNvbnRhY3QgZm91bmRcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgdGhlIGF4aXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBlZGdlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUG9seWdvbkFyZWEucHJvdG90eXBlLmdldEF4ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9heGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2F4ZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGF4ZXMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludHMoKTtcclxuICAgICAgICAgICAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGF4ZXMucHVzaChwb2ludHNbaV0uc3ViKHBvaW50c1soaSArIDEpICUgbGVuXSkubm9ybWFsKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2F4ZXMgPSBheGVzO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXhlcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBlcmZvcm0gU2VwYXJhdGluZyBBeGlzIHRlc3QgYWdhaW5zdCBhbm90aGVyIHBvbHlnb24sIHJldHVybnMgbnVsbCBpZiBubyBvdmVybGFwIGluIHBvbHlzXHJcbiAgICAgICAgICogUmVmZXJlbmNlIGh0dHA6Ly93d3cuZHluNGoub3JnLzIwMTAvMDEvc2F0L1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBvbHlnb25BcmVhLnByb3RvdHlwZS50ZXN0U2VwYXJhdGluZ0F4aXNUaGVvcmVtID0gZnVuY3Rpb24gKG90aGVyKSB7XHJcbiAgICAgICAgICAgIHZhciBwb2x5MSA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBwb2x5MiA9IG90aGVyO1xyXG4gICAgICAgICAgICB2YXIgYXhlcyA9IHBvbHkxLmdldEF4ZXMoKS5jb25jYXQocG9seTIuZ2V0QXhlcygpKTtcclxuICAgICAgICAgICAgdmFyIG1pbk92ZXJsYXAgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgICAgICB2YXIgbWluQXhpcyA9IG51bGw7XHJcbiAgICAgICAgICAgIHZhciBtaW5JbmRleCA9IC0xO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF4ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBwcm9qMSA9IHBvbHkxLnByb2plY3QoYXhlc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJvajIgPSBwb2x5Mi5wcm9qZWN0KGF4ZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIG92ZXJsYXAgPSBwcm9qMS5nZXRPdmVybGFwKHByb2oyKTtcclxuICAgICAgICAgICAgICAgIGlmIChvdmVybGFwIDw9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdmVybGFwIDwgbWluT3ZlcmxhcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5PdmVybGFwID0gb3ZlcmxhcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluQXhpcyA9IGF4ZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbkluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gU2FuaXR5IGNoZWNrXHJcbiAgICAgICAgICAgIGlmIChtaW5JbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBtaW5BeGlzLm5vcm1hbGl6ZSgpLnNjYWxlKG1pbk92ZXJsYXApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJvamVjdCB0aGUgZWRnZXMgb2YgdGhlIHBvbHlnb24gYWxvbmcgYSBzcGVjaWZpZWQgYXhpc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBvbHlnb25BcmVhLnByb3RvdHlwZS5wcm9qZWN0ID0gZnVuY3Rpb24gKGF4aXMpIHtcclxuICAgICAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludHMoKTtcclxuICAgICAgICAgICAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHZhciBtaW4gPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgICAgICB2YXIgbWF4ID0gLU51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBzY2FsYXIgPSBwb2ludHNbaV0uZG90KGF4aXMpO1xyXG4gICAgICAgICAgICAgICAgbWluID0gTWF0aC5taW4obWluLCBzY2FsYXIpO1xyXG4gICAgICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBzY2FsYXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWxnZWJyYV82LlByb2plY3Rpb24obWluLCBtYXgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBQb2x5Z29uQXJlYS5wcm90b3R5cGUuZGVidWdEcmF3ID0gZnVuY3Rpb24gKGN0eCwgY29sb3IpIHtcclxuICAgICAgICAgICAgaWYgKGNvbG9yID09PSB2b2lkIDApIHsgY29sb3IgPSBDb2xvcl8yLkNvbG9yLlJlZC5jbG9uZSgpOyB9XHJcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3IudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSBzdXBwbGllZCBwb2ludHMgYW5kIGNvbnN0cnVjdCBhICdwb2x5Z29uJ1xyXG4gICAgICAgICAgICB2YXIgZmlyc3RQb2ludCA9IHRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludHMoKVswXTtcclxuICAgICAgICAgICAgY3R4Lm1vdmVUbyhmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSk7XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludHMoKS5mb3JFYWNoKGZ1bmN0aW9uIChwb2ludCkge1xyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhwb2ludC54LCBwb2ludC55KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGN0eC5saW5lVG8oZmlyc3RQb2ludC54LCBmaXJzdFBvaW50LnkpO1xyXG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBQb2x5Z29uQXJlYTtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLlBvbHlnb25BcmVhID0gUG9seWdvbkFyZWE7XHJcbn0pO1xyXG5kZWZpbmUoXCJDb2xsaXNpb24vQm91bmRpbmdCb3hcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJDb2xsaXNpb24vUG9seWdvbkFyZWFcIiwgXCJBbGdlYnJhXCIsIFwiRHJhd2luZy9Db2xvclwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIFBvbHlnb25BcmVhXzMsIEFsZ2VicmFfNywgQ29sb3JfMykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEF4aXMgQWxpZ25lZCBjb2xsaXNpb24gcHJpbWl0aXZlIGZvciBFeGNhbGlidXIuXHJcbiAgICAgKi9cclxuICAgIHZhciBCb3VuZGluZ0JveCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIGxlZnQgICAgeCBjb29yZGluYXRlIG9mIHRoZSBsZWZ0IGVkZ2VcclxuICAgICAgICAgKiBAcGFyYW0gdG9wICAgICB5IGNvb3JkaW5hdGUgb2YgdGhlIHRvcCBlZGdlXHJcbiAgICAgICAgICogQHBhcmFtIHJpZ2h0ICAgeCBjb29yZGluYXRlIG9mIHRoZSByaWdodCBlZGdlXHJcbiAgICAgICAgICogQHBhcmFtIGJvdHRvbSAgeSBjb29yZGluYXRlIG9mIHRoZSBib3R0b20gZWRnZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIEJvdW5kaW5nQm94KGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbSkge1xyXG4gICAgICAgICAgICBpZiAobGVmdCA9PT0gdm9pZCAwKSB7IGxlZnQgPSAwOyB9XHJcbiAgICAgICAgICAgIGlmICh0b3AgPT09IHZvaWQgMCkgeyB0b3AgPSAwOyB9XHJcbiAgICAgICAgICAgIGlmIChyaWdodCA9PT0gdm9pZCAwKSB7IHJpZ2h0ID0gMDsgfVxyXG4gICAgICAgICAgICBpZiAoYm90dG9tID09PSB2b2lkIDApIHsgYm90dG9tID0gMDsgfVxyXG4gICAgICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xyXG4gICAgICAgICAgICB0aGlzLnRvcCA9IHRvcDtcclxuICAgICAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xyXG4gICAgICAgICAgICB0aGlzLmJvdHRvbSA9IGJvdHRvbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgQm91bmRpbmdCb3guZnJvbVBvaW50cyA9IGZ1bmN0aW9uIChwb2ludHMpIHtcclxuICAgICAgICAgICAgdmFyIG1pblggPSBJbmZpbml0eTtcclxuICAgICAgICAgICAgdmFyIG1pblkgPSBJbmZpbml0eTtcclxuICAgICAgICAgICAgdmFyIG1heFggPSAtSW5maW5pdHk7XHJcbiAgICAgICAgICAgIHZhciBtYXhZID0gLUluZmluaXR5O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvaW50c1tpXS54IDwgbWluWCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pblggPSBwb2ludHNbaV0ueDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChwb2ludHNbaV0ueCA+IG1heFgpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXhYID0gcG9pbnRzW2ldLng7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocG9pbnRzW2ldLnkgPCBtaW5ZKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluWSA9IHBvaW50c1tpXS55O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHBvaW50c1tpXS55ID4gbWF4WSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1heFkgPSBwb2ludHNbaV0ueTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJvdW5kaW5nQm94KG1pblgsIG1pblksIG1heFgsIG1heFkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgY2FsY3VsYXRlZCB3aWR0aCBvZiB0aGUgYm91bmRpbmcgYm94XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQm91bmRpbmdCb3gucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yaWdodCAtIHRoaXMubGVmdDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIGNhbGN1bGF0ZWQgaGVpZ2h0IG9mIHRoZSBib3VuZGluZyBib3hcclxuICAgICAgICAgKi9cclxuICAgICAgICBCb3VuZGluZ0JveC5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ib3R0b20gLSB0aGlzLnRvcDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJvdGF0ZXMgYSBib3VuZGluZyBib3ggYnkgYW5kIGFuZ2xlIGFuZCBhcm91bmQgYSBwb2ludCwgaWYgbm8gcG9pbnQgaXMgc3BlY2lmaWVkICgwLCAwKSBpcyB1c2VkIGJ5IGRlZmF1bHRcclxuICAgICAgICAgKi9cclxuICAgICAgICBCb3VuZGluZ0JveC5wcm90b3R5cGUucm90YXRlID0gZnVuY3Rpb24gKGFuZ2xlLCBwb2ludCkge1xyXG4gICAgICAgICAgICBpZiAocG9pbnQgPT09IHZvaWQgMCkgeyBwb2ludCA9IEFsZ2VicmFfNy5WZWN0b3IuWmVyby5jbG9uZSgpOyB9XHJcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmdldFBvaW50cygpLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5yb3RhdGUoYW5nbGUsIHBvaW50KTsgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBCb3VuZGluZ0JveC5mcm9tUG9pbnRzKHBvaW50cyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBwZXJpbWV0ZXIgb2YgdGhlIGJvdW5kaW5nIGJveFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJvdW5kaW5nQm94LnByb3RvdHlwZS5nZXRQZXJpbWV0ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB3eCA9IHRoaXMuZ2V0V2lkdGgoKTtcclxuICAgICAgICAgICAgdmFyIHd5ID0gdGhpcy5nZXRIZWlnaHQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIDIgKiAod3ggKyB3eSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBCb3VuZGluZ0JveC5wcm90b3R5cGUuZ2V0UG9pbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xyXG4gICAgICAgICAgICByZXN1bHRzLnB1c2gobmV3IEFsZ2VicmFfNy5WZWN0b3IodGhpcy5sZWZ0LCB0aGlzLnRvcCkpO1xyXG4gICAgICAgICAgICByZXN1bHRzLnB1c2gobmV3IEFsZ2VicmFfNy5WZWN0b3IodGhpcy5yaWdodCwgdGhpcy50b3ApKTtcclxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKG5ldyBBbGdlYnJhXzcuVmVjdG9yKHRoaXMucmlnaHQsIHRoaXMuYm90dG9tKSk7XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChuZXcgQWxnZWJyYV83LlZlY3Rvcih0aGlzLmxlZnQsIHRoaXMuYm90dG9tKSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIFBvbHlnb24gY29sbGlzaW9uIGFyZWEgZnJvbSB0aGUgcG9pbnRzIG9mIHRoZSBib3VuZGluZyBib3hcclxuICAgICAgICAgKi9cclxuICAgICAgICBCb3VuZGluZ0JveC5wcm90b3R5cGUudG9Qb2x5Z29uID0gZnVuY3Rpb24gKGFjdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9seWdvbkFyZWFfMy5Qb2x5Z29uQXJlYSh7XHJcbiAgICAgICAgICAgICAgICBib2R5OiBhY3RvciA/IGFjdG9yLmJvZHkgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgcG9pbnRzOiB0aGlzLmdldFBvaW50cygpLFxyXG4gICAgICAgICAgICAgICAgcG9zOiBBbGdlYnJhXzcuVmVjdG9yLlplcm8uY2xvbmUoKVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciBhIHJheSBpbnRlcnNlY3RzIHdpdGggYSBib3VuZGluZyBib3hcclxuICAgICAgICAgKi9cclxuICAgICAgICBCb3VuZGluZ0JveC5wcm90b3R5cGUucmF5Q2FzdCA9IGZ1bmN0aW9uIChyYXksIGZhckNsaXBEaXN0YW5jZSkge1xyXG4gICAgICAgICAgICBpZiAoZmFyQ2xpcERpc3RhbmNlID09PSB2b2lkIDApIHsgZmFyQ2xpcERpc3RhbmNlID0gSW5maW5pdHk7IH1cclxuICAgICAgICAgICAgLy8gYWxnb3JpdGhtIGZyb20gaHR0cHM6Ly90YXZpYW5hdG9yLmNvbS9mYXN0LWJyYW5jaGxlc3MtcmF5Ym91bmRpbmctYm94LWludGVyc2VjdGlvbnMvIFxyXG4gICAgICAgICAgICB2YXIgdG1pbiA9IC1JbmZpbml0eTtcclxuICAgICAgICAgICAgdmFyIHRtYXggPSArSW5maW5pdHk7XHJcbiAgICAgICAgICAgIHZhciB4aW52ID0gcmF5LmRpci54ID09PSAwID8gTnVtYmVyLk1BWF9WQUxVRSA6ICgxIC8gcmF5LmRpci54KTtcclxuICAgICAgICAgICAgdmFyIHlpbnYgPSByYXkuZGlyLnkgPT09IDAgPyBOdW1iZXIuTUFYX1ZBTFVFIDogKDEgLyByYXkuZGlyLnkpO1xyXG4gICAgICAgICAgICB2YXIgdHgxID0gKHRoaXMubGVmdCAtIHJheS5wb3MueCkgKiB4aW52O1xyXG4gICAgICAgICAgICB2YXIgdHgyID0gKHRoaXMucmlnaHQgLSByYXkucG9zLngpICogeGludjtcclxuICAgICAgICAgICAgdG1pbiA9IE1hdGgubWluKHR4MSwgdHgyKTtcclxuICAgICAgICAgICAgdG1heCA9IE1hdGgubWF4KHR4MSwgdHgyKTtcclxuICAgICAgICAgICAgdmFyIHR5MSA9ICh0aGlzLnRvcCAtIHJheS5wb3MueSkgKiB5aW52O1xyXG4gICAgICAgICAgICB2YXIgdHkyID0gKHRoaXMuYm90dG9tIC0gcmF5LnBvcy55KSAqIHlpbnY7XHJcbiAgICAgICAgICAgIHRtaW4gPSBNYXRoLm1heCh0bWluLCBNYXRoLm1pbih0eTEsIHR5MikpO1xyXG4gICAgICAgICAgICB0bWF4ID0gTWF0aC5taW4odG1heCwgTWF0aC5tYXgodHkxLCB0eTIpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRtYXggPj0gTWF0aC5tYXgoMCwgdG1pbikgJiYgdG1pbiA8IGZhckNsaXBEaXN0YW5jZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEJvdW5kaW5nQm94LnByb3RvdHlwZS5yYXlDYXN0VGltZSA9IGZ1bmN0aW9uIChyYXksIGZhckNsaXBEaXN0YW5jZSkge1xyXG4gICAgICAgICAgICBpZiAoZmFyQ2xpcERpc3RhbmNlID09PSB2b2lkIDApIHsgZmFyQ2xpcERpc3RhbmNlID0gSW5maW5pdHk7IH1cclxuICAgICAgICAgICAgLy8gYWxnb3JpdGhtIGZyb20gaHR0cHM6Ly90YXZpYW5hdG9yLmNvbS9mYXN0LWJyYW5jaGxlc3MtcmF5Ym91bmRpbmctYm94LWludGVyc2VjdGlvbnMvIFxyXG4gICAgICAgICAgICB2YXIgdG1pbiA9IC1JbmZpbml0eTtcclxuICAgICAgICAgICAgdmFyIHRtYXggPSArSW5maW5pdHk7XHJcbiAgICAgICAgICAgIHZhciB4aW52ID0gcmF5LmRpci54ID09PSAwID8gTnVtYmVyLk1BWF9WQUxVRSA6ICgxIC8gcmF5LmRpci54KTtcclxuICAgICAgICAgICAgdmFyIHlpbnYgPSByYXkuZGlyLnkgPT09IDAgPyBOdW1iZXIuTUFYX1ZBTFVFIDogKDEgLyByYXkuZGlyLnkpO1xyXG4gICAgICAgICAgICB2YXIgdHgxID0gKHRoaXMubGVmdCAtIHJheS5wb3MueCkgKiB4aW52O1xyXG4gICAgICAgICAgICB2YXIgdHgyID0gKHRoaXMucmlnaHQgLSByYXkucG9zLngpICogeGludjtcclxuICAgICAgICAgICAgdG1pbiA9IE1hdGgubWluKHR4MSwgdHgyKTtcclxuICAgICAgICAgICAgdG1heCA9IE1hdGgubWF4KHR4MSwgdHgyKTtcclxuICAgICAgICAgICAgdmFyIHR5MSA9ICh0aGlzLnRvcCAtIHJheS5wb3MueSkgKiB5aW52O1xyXG4gICAgICAgICAgICB2YXIgdHkyID0gKHRoaXMuYm90dG9tIC0gcmF5LnBvcy55KSAqIHlpbnY7XHJcbiAgICAgICAgICAgIHRtaW4gPSBNYXRoLm1heCh0bWluLCBNYXRoLm1pbih0eTEsIHR5MikpO1xyXG4gICAgICAgICAgICB0bWF4ID0gTWF0aC5taW4odG1heCwgTWF0aC5tYXgodHkxLCB0eTIpKTtcclxuICAgICAgICAgICAgaWYgKHRtYXggPj0gTWF0aC5tYXgoMCwgdG1pbikgJiYgdG1pbiA8IGZhckNsaXBEaXN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRtaW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQm91bmRpbmdCb3gucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKHZhbCkge1xyXG4gICAgICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgQWxnZWJyYV83LlZlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmxlZnQgPD0gdmFsLnggJiYgdGhpcy50b3AgPD0gdmFsLnkgJiYgdGhpcy5ib3R0b20gPj0gdmFsLnkgJiYgdGhpcy5yaWdodCA+PSB2YWwueCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgQm91bmRpbmdCb3gpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxlZnQgPCB2YWwubGVmdCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9wIDwgdmFsLnRvcCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbC5ib3R0b20gPCB0aGlzLmJvdHRvbSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbC5yaWdodCA8IHRoaXMucmlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb21iaW5lcyB0aGlzIGJvdW5kaW5nIGJveCBhbmQgYW5vdGhlciB0b2dldGhlciByZXR1cm5pbmcgYSBuZXcgYm91bmRpbmcgYm94XHJcbiAgICAgICAgICogQHBhcmFtIG90aGVyICBUaGUgYm91bmRpbmcgYm94IHRvIGNvbWJpbmVcclxuICAgICAgICAgKi9cclxuICAgICAgICBCb3VuZGluZ0JveC5wcm90b3R5cGUuY29tYmluZSA9IGZ1bmN0aW9uIChvdGhlcikge1xyXG4gICAgICAgICAgICB2YXIgY29tcG9zaXRlQkIgPSBuZXcgQm91bmRpbmdCb3goTWF0aC5taW4odGhpcy5sZWZ0LCBvdGhlci5sZWZ0KSwgTWF0aC5taW4odGhpcy50b3AsIG90aGVyLnRvcCksIE1hdGgubWF4KHRoaXMucmlnaHQsIG90aGVyLnJpZ2h0KSwgTWF0aC5tYXgodGhpcy5ib3R0b20sIG90aGVyLmJvdHRvbSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gY29tcG9zaXRlQkI7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZXN0IHdldGhlciB0aGlzIGJvdW5kaW5nIGJveCBjb2xsaWRlcyB3aXRoIGFub3RoZXIgcmV0dXJuaW5nLFxyXG4gICAgICAgICAqIHRoZSBpbnRlcnNlY3Rpb24gdmVjdG9yIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVzb2x2ZSB0aGUgY29sbGlzaW9uLiBJZiB0aGVyZVxyXG4gICAgICAgICAqIGlzIG5vIGNvbGxpc2lvbiBudWxsIGlzIHJldHVybmVkLlxyXG4gICAgICAgICAqIEBwYXJhbSBjb2xsaWRhYmxlICBPdGhlciBjb2xsaWRhYmxlIHRvIHRlc3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBCb3VuZGluZ0JveC5wcm90b3R5cGUuY29sbGlkZXMgPSBmdW5jdGlvbiAoY29sbGlkYWJsZSkge1xyXG4gICAgICAgICAgICBpZiAoY29sbGlkYWJsZSBpbnN0YW5jZW9mIEJvdW5kaW5nQm94KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBjb2xsaWRhYmxlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRvdGFsQm91bmRpbmdCb3ggPSB0aGlzLmNvbWJpbmUob3RoZXIpO1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHRvdGFsIGJvdW5kaW5nIGJveCBpcyBsZXNzIHRoYW4gdGhlIHN1bSBvZiB0aGUgMiBib3VuZHMgdGhlbiB0aGVyZSBpcyBjb2xsaXNpb25cclxuICAgICAgICAgICAgICAgIGlmICh0b3RhbEJvdW5kaW5nQm94LmdldFdpZHRoKCkgPCBvdGhlci5nZXRXaWR0aCgpICsgdGhpcy5nZXRXaWR0aCgpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgdG90YWxCb3VuZGluZ0JveC5nZXRIZWlnaHQoKSA8IG90aGVyLmdldEhlaWdodCgpICsgdGhpcy5nZXRIZWlnaHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbGxpc2lvblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvdmVybGFwWCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmlnaHQgPj0gb3RoZXIubGVmdCAmJiB0aGlzLnJpZ2h0IDw9IG90aGVyLnJpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXBYID0gb3RoZXIubGVmdCAtIHRoaXMucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGFwWCA9IG90aGVyLnJpZ2h0IC0gdGhpcy5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3ZlcmxhcFkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRvcCA8PSBvdGhlci5ib3R0b20gJiYgdGhpcy50b3AgPj0gb3RoZXIudG9wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXBZID0gb3RoZXIuYm90dG9tIC0gdGhpcy50b3A7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGFwWSA9IG90aGVyLnRvcCAtIHRoaXMuYm90dG9tO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMob3ZlcmxhcFgpIDwgTWF0aC5hYnMob3ZlcmxhcFkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWxnZWJyYV83LlZlY3RvcihvdmVybGFwWCwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFsZ2VicmFfNy5WZWN0b3IoMCwgb3ZlcmxhcFkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBCb3VuZGluZ0JveC5wcm90b3R5cGUuZGVidWdEcmF3ID0gZnVuY3Rpb24gKGN0eCwgY29sb3IpIHtcclxuICAgICAgICAgICAgaWYgKGNvbG9yID09PSB2b2lkIDApIHsgY29sb3IgPSBDb2xvcl8zLkNvbG9yLlllbGxvdzsgfVxyXG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvci50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlUmVjdCh0aGlzLmxlZnQsIHRoaXMudG9wLCB0aGlzLmdldFdpZHRoKCksIHRoaXMuZ2V0SGVpZ2h0KCkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEJvdW5kaW5nQm94O1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuQm91bmRpbmdCb3ggPSBCb3VuZGluZ0JveDtcclxufSk7XHJcbmRlZmluZShcIkNvbGxpc2lvbi9FZGdlQXJlYVwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkNvbGxpc2lvbi9Cb3VuZGluZ0JveFwiLCBcIkNvbGxpc2lvbi9Db2xsaXNpb25KdW1wVGFibGVcIiwgXCJDb2xsaXNpb24vQ2lyY2xlQXJlYVwiLCBcIkNvbGxpc2lvbi9Qb2x5Z29uQXJlYVwiLCBcIkFsZ2VicmFcIiwgXCJQaHlzaWNzXCIsIFwiRHJhd2luZy9Db2xvclwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIEJvdW5kaW5nQm94XzMsIENvbGxpc2lvbkp1bXBUYWJsZV8zLCBDaXJjbGVBcmVhXzIsIFBvbHlnb25BcmVhXzQsIEFsZ2VicmFfOCwgUGh5c2ljc180LCBDb2xvcl80KSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIHZhciBFZGdlQXJlYSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gRWRnZUFyZWEob3B0aW9ucykge1xyXG4gICAgICAgICAgICB0aGlzLmJlZ2luID0gb3B0aW9ucy5iZWdpbiB8fCBBbGdlYnJhXzguVmVjdG9yLlplcm8uY2xvbmUoKTtcclxuICAgICAgICAgICAgdGhpcy5lbmQgPSBvcHRpb25zLmVuZCB8fCBBbGdlYnJhXzguVmVjdG9yLlplcm8uY2xvbmUoKTtcclxuICAgICAgICAgICAgdGhpcy5ib2R5ID0gb3B0aW9ucy5ib2R5IHx8IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMucG9zID0gdGhpcy5nZXRDZW50ZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IHRoZSBjZW50ZXIgb2YgdGhlIGNvbGxpc2lvbiBhcmVhIGluIHdvcmxkIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRWRnZUFyZWEucHJvdG90eXBlLmdldENlbnRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHBvcyA9IHRoaXMuYmVnaW4uYXZlcmFnZSh0aGlzLmVuZCkuYWRkKHRoaXMuX2dldEJvZHlQb3MoKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBwb3M7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBFZGdlQXJlYS5wcm90b3R5cGUuX2dldEJvZHlQb3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBib2R5UG9zID0gQWxnZWJyYV84LlZlY3Rvci5aZXJvLmNsb25lKCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmJvZHkucG9zKSB7XHJcbiAgICAgICAgICAgICAgICBib2R5UG9zID0gdGhpcy5ib2R5LnBvcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYm9keVBvcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIEVkZ2VBcmVhLnByb3RvdHlwZS5fZ2V0VHJhbnNmb3JtZWRCZWdpbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGFuZ2xlID0gdGhpcy5ib2R5ID8gdGhpcy5ib2R5LnJvdGF0aW9uIDogMDtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmVnaW4ucm90YXRlKGFuZ2xlKS5hZGQodGhpcy5fZ2V0Qm9keVBvcygpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEVkZ2VBcmVhLnByb3RvdHlwZS5fZ2V0VHJhbnNmb3JtZWRFbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhbmdsZSA9IHRoaXMuYm9keSA/IHRoaXMuYm9keS5yb3RhdGlvbiA6IDA7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuZC5yb3RhdGUoYW5nbGUpLmFkZCh0aGlzLl9nZXRCb2R5UG9zKCkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgc2xvcGUgb2YgdGhlIGxpbmUgaW4gdGhlIGZvcm0gb2YgYSB2ZWN0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBFZGdlQXJlYS5wcm90b3R5cGUuZ2V0U2xvcGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBiZWdpbiA9IHRoaXMuX2dldFRyYW5zZm9ybWVkQmVnaW4oKTtcclxuICAgICAgICAgICAgdmFyIGVuZCA9IHRoaXMuX2dldFRyYW5zZm9ybWVkRW5kKCk7XHJcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IGJlZ2luLmRpc3RhbmNlKGVuZCk7XHJcbiAgICAgICAgICAgIHJldHVybiBlbmQuc3ViKGJlZ2luKS5zY2FsZSgxIC8gZGlzdGFuY2UpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSBsaW5lIHNlZ21lbnQgaW4gcGl4ZWxzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRWRnZUFyZWEucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGJlZ2luID0gdGhpcy5fZ2V0VHJhbnNmb3JtZWRCZWdpbigpO1xyXG4gICAgICAgICAgICB2YXIgZW5kID0gdGhpcy5fZ2V0VHJhbnNmb3JtZWRFbmQoKTtcclxuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gYmVnaW4uZGlzdGFuY2UoZW5kKTtcclxuICAgICAgICAgICAgcmV0dXJuIGRpc3RhbmNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVzdHMgaWYgYSBwb2ludCBpcyBjb250YWluZWQgaW4gdGhpcyBjb2xsaXNpb24gYXJlYVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVkZ2VBcmVhLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGluaGVyaXRkb2NcclxuICAgICAgICAgKi9cclxuICAgICAgICBFZGdlQXJlYS5wcm90b3R5cGUucmF5Q2FzdCA9IGZ1bmN0aW9uIChyYXksIG1heCkge1xyXG4gICAgICAgICAgICBpZiAobWF4ID09PSB2b2lkIDApIHsgbWF4ID0gSW5maW5pdHk7IH1cclxuICAgICAgICAgICAgdmFyIG51bWVyYXRvciA9IHRoaXMuX2dldFRyYW5zZm9ybWVkQmVnaW4oKS5zdWIocmF5LnBvcyk7XHJcbiAgICAgICAgICAgIC8vIFRlc3QgaXMgbGluZSBhbmQgcmF5IGFyZSBwYXJhbGxlbCBhbmQgbm9uIGludGVyc2VjdGluZ1xyXG4gICAgICAgICAgICBpZiAocmF5LmRpci5jcm9zcyh0aGlzLmdldFNsb3BlKCkpID09PSAwICYmIG51bWVyYXRvci5jcm9zcyhyYXkuZGlyKSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gTGluZXMgYXJlIHBhcmFsbGVsXHJcbiAgICAgICAgICAgIHZhciBkaXZpc29yID0gKHJheS5kaXIuY3Jvc3ModGhpcy5nZXRTbG9wZSgpKSk7XHJcbiAgICAgICAgICAgIGlmIChkaXZpc29yID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdCA9IG51bWVyYXRvci5jcm9zcyh0aGlzLmdldFNsb3BlKCkpIC8gZGl2aXNvcjtcclxuICAgICAgICAgICAgaWYgKHQgPj0gMCAmJiB0IDw9IG1heCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHUgPSAobnVtZXJhdG9yLmNyb3NzKHJheS5kaXIpIC8gZGl2aXNvcikgLyB0aGlzLmdldExlbmd0aCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHUgPj0gMCAmJiB1IDw9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmF5LmdldFBvaW50KHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGluaGVyaXRkb2NcclxuICAgICAgICAgKi9cclxuICAgICAgICBFZGdlQXJlYS5wcm90b3R5cGUuY29sbGlkZSA9IGZ1bmN0aW9uIChhcmVhKSB7XHJcbiAgICAgICAgICAgIGlmIChhcmVhIGluc3RhbmNlb2YgQ2lyY2xlQXJlYV8yLkNpcmNsZUFyZWEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDb2xsaXNpb25KdW1wVGFibGVfMy5Db2xsaXNpb25KdW1wVGFibGUuQ29sbGlkZUNpcmNsZUVkZ2UoYXJlYSwgdGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYXJlYSBpbnN0YW5jZW9mIFBvbHlnb25BcmVhXzQuUG9seWdvbkFyZWEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDb2xsaXNpb25KdW1wVGFibGVfMy5Db2xsaXNpb25KdW1wVGFibGUuQ29sbGlkZVBvbHlnb25FZGdlKGFyZWEsIHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGFyZWEgaW5zdGFuY2VvZiBFZGdlQXJlYSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbGxpc2lvbkp1bXBUYWJsZV8zLkNvbGxpc2lvbkp1bXBUYWJsZS5Db2xsaWRlRWRnZUVkZ2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVkZ2UgY291bGQgbm90IGNvbGxpZGUgd2l0aCB1bmtub3duIElDb2xsaXNpb25BcmVhIFwiICsgdHlwZW9mIGFyZWEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGaW5kIHRoZSBwb2ludCBvbiB0aGUgc2hhcGUgZnVydGhlc3QgaW4gdGhlIGRpcmVjdGlvbiBzcGVjaWZpZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBFZGdlQXJlYS5wcm90b3R5cGUuZ2V0RnVydGhlc3RQb2ludCA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkQmVnaW4gPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZEJlZ2luKCk7XHJcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZEVuZCA9IHRoaXMuX2dldFRyYW5zZm9ybWVkRW5kKCk7XHJcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24uZG90KHRyYW5zZm9ybWVkQmVnaW4pID4gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkQmVnaW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWRFbmQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCB0aGUgYXhpcyBhbGlnbmVkIGJvdW5kaW5nIGJveCBmb3IgdGhlIGNpcmNsZSBhcmVhXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRWRnZUFyZWEucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkQmVnaW4gPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZEJlZ2luKCk7XHJcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZEVuZCA9IHRoaXMuX2dldFRyYW5zZm9ybWVkRW5kKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3hfMy5Cb3VuZGluZ0JveChNYXRoLm1pbih0cmFuc2Zvcm1lZEJlZ2luLngsIHRyYW5zZm9ybWVkRW5kLngpLCBNYXRoLm1pbih0cmFuc2Zvcm1lZEJlZ2luLnksIHRyYW5zZm9ybWVkRW5kLnkpLCBNYXRoLm1heCh0cmFuc2Zvcm1lZEJlZ2luLngsIHRyYW5zZm9ybWVkRW5kLngpLCBNYXRoLm1heCh0cmFuc2Zvcm1lZEJlZ2luLnksIHRyYW5zZm9ybWVkRW5kLnkpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCB0aGUgYXhpcyBhc3NvY2lhdGVkIHdpdGggdGhlIGVkZ2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBFZGdlQXJlYS5wcm90b3R5cGUuZ2V0QXhlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZEVuZCgpLnN1Yih0aGlzLl9nZXRUcmFuc2Zvcm1lZEJlZ2luKCkpO1xyXG4gICAgICAgICAgICB2YXIgZWRnZU5vcm1hbCA9IGUubm9ybWFsKCk7XHJcbiAgICAgICAgICAgIHZhciBheGVzID0gW107XHJcbiAgICAgICAgICAgIGF4ZXMucHVzaChlZGdlTm9ybWFsKTtcclxuICAgICAgICAgICAgYXhlcy5wdXNoKGVkZ2VOb3JtYWwubmVnYXRlKCkpO1xyXG4gICAgICAgICAgICBheGVzLnB1c2goZWRnZU5vcm1hbC5ub3JtYWwoKSk7XHJcbiAgICAgICAgICAgIGF4ZXMucHVzaChlZGdlTm9ybWFsLm5vcm1hbCgpLm5lZ2F0ZSgpKTtcclxuICAgICAgICAgICAgcmV0dXJuIGF4ZXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgdGhlIG1vbWVudCBvZiBpbmVydGlhIGZvciBhbiBlZGdlXHJcbiAgICAgICAgICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGlzdF9vZl9tb21lbnRzX29mX2luZXJ0aWFcclxuICAgICAgICAgKi9cclxuICAgICAgICBFZGdlQXJlYS5wcm90b3R5cGUuZ2V0TW9tZW50T2ZJbmVydGlhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbWFzcyA9IHRoaXMuYm9keSA/IHRoaXMuYm9keS5tYXNzIDogUGh5c2ljc180LlBoeXNpY3MuZGVmYXVsdE1hc3M7XHJcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmVuZC5zdWIodGhpcy5iZWdpbikuZGlzdGFuY2UoKSAvIDI7XHJcbiAgICAgICAgICAgIHJldHVybiBtYXNzICogbGVuZ3RoICogbGVuZ3RoO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGluaGVyaXRkb2NcclxuICAgICAgICAgKi9cclxuICAgICAgICBFZGdlQXJlYS5wcm90b3R5cGUucmVjYWxjID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBlZGdlcyBkb24ndCBoYXZlIGFueSBjYWNoZWQgZGF0YVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJvamVjdCB0aGUgZWRnZSBhbG9uZyBhIHNwZWNpZmllZCBheGlzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRWRnZUFyZWEucHJvdG90eXBlLnByb2plY3QgPSBmdW5jdGlvbiAoYXhpcykge1xyXG4gICAgICAgICAgICB2YXIgc2NhbGFycyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gW3RoaXMuX2dldFRyYW5zZm9ybWVkQmVnaW4oKSwgdGhpcy5fZ2V0VHJhbnNmb3JtZWRFbmQoKV07XHJcbiAgICAgICAgICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzY2FsYXJzLnB1c2gocG9pbnRzW2ldLmRvdChheGlzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbGdlYnJhXzguUHJvamVjdGlvbihNYXRoLm1pbi5hcHBseShNYXRoLCBzY2FsYXJzKSwgTWF0aC5tYXguYXBwbHkoTWF0aCwgc2NhbGFycykpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBFZGdlQXJlYS5wcm90b3R5cGUuZGVidWdEcmF3ID0gZnVuY3Rpb24gKGN0eCwgY29sb3IpIHtcclxuICAgICAgICAgICAgaWYgKGNvbG9yID09PSB2b2lkIDApIHsgY29sb3IgPSBDb2xvcl80LkNvbG9yLlJlZC5jbG9uZSgpOyB9XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh0aGlzLmJlZ2luLngsIHRoaXMuYmVnaW4ueSk7XHJcbiAgICAgICAgICAgIGN0eC5saW5lVG8odGhpcy5lbmQueCwgdGhpcy5lbmQueSk7XHJcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEVkZ2VBcmVhO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuRWRnZUFyZWEgPSBFZGdlQXJlYTtcclxufSk7XHJcbmRlZmluZShcIlV0aWwvRHJhd1V0aWxcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJEcmF3aW5nL0NvbG9yXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgQ29sb3JfNSkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIERyYXcgYSBsaW5lIG9uIGNhbnZhcyBjb250ZXh0XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCBUaGUgY2FudmFzIGNvbnRleHRcclxuICAgICAqIEBwYXJhbSBjb2xvciBUaGUgY29sb3Igb2YgdGhlIGxpbmVcclxuICAgICAqIEBwYXJhbSB4MSBUaGUgc3RhcnQgeCBjb29yZGluYXRlXHJcbiAgICAgKiBAcGFyYW0geTEgVGhlIHN0YXJ0IHkgY29vcmRpbmF0ZVxyXG4gICAgICogQHBhcmFtIHgyIFRoZSBlbmRpbmcgeCBjb29yZGluYXRlXHJcbiAgICAgKiBAcGFyYW0geTIgVGhlIGVuZGluZyB5IGNvb3JkaW5hdGVcclxuICAgICAqIEBwYXJhbSB0aGlja25lc3MgVGhlIGxpbmUgdGhpY2tuZXNzXHJcbiAgICAgKiBAcGFyYW0gY2FwIFRoZSBbW0xpbmVDYXBTdHlsZV1dIChidXR0LCByb3VuZCwgb3Igc3F1YXJlKVxyXG4gICAgICovXHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgZnVuY3Rpb24gbGluZShjdHgsIGNvbG9yLCB4MSwgeTEsIHgyLCB5MiwgdGhpY2tuZXNzLCBjYXApIHtcclxuICAgICAgICBpZiAoY29sb3IgPT09IHZvaWQgMCkgeyBjb2xvciA9IENvbG9yXzUuQ29sb3IuUmVkLmNsb25lKCk7IH1cclxuICAgICAgICBpZiAodGhpY2tuZXNzID09PSB2b2lkIDApIHsgdGhpY2tuZXNzID0gMTsgfVxyXG4gICAgICAgIGlmIChjYXAgPT09IHZvaWQgMCkgeyBjYXAgPSAnYnV0dCc7IH1cclxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaWNrbmVzcztcclxuICAgICAgICBjdHgubGluZUNhcCA9IGNhcDtcclxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvci50b1N0cmluZygpO1xyXG4gICAgICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcclxuICAgICAgICBjdHgubGluZVRvKHgyLCB5Mik7XHJcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgIH1cclxuICAgIGV4cG9ydHMubGluZSA9IGxpbmU7XHJcbiAgICAvKipcclxuICAgICAqIERyYXcgdGhlIHZlY3RvciBhcyBhIHBvaW50IG9udG8gdGhlIGNhbnZhcy5cclxuICAgICAqL1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIGZ1bmN0aW9uIHBvaW50KGN0eCwgY29sb3IsIHBvaW50KSB7XHJcbiAgICAgICAgaWYgKGNvbG9yID09PSB2b2lkIDApIHsgY29sb3IgPSBDb2xvcl81LkNvbG9yLlJlZC5jbG9uZSgpOyB9XHJcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgY3R4LmFyYyhwb2ludC54LCBwb2ludC55LCA1LCAwLCBNYXRoLlBJICogMik7XHJcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgIH1cclxuICAgIGV4cG9ydHMucG9pbnQgPSBwb2ludDtcclxuICAgIC8qKlxyXG4gICAgICogRHJhdyB0aGUgdmVjdG9yIGFzIGEgbGluZSBvbnRvIHRoZSBjYW52YXMgc3RhcnRpbmcgYSBvcmlnaW4gcG9pbnQuXHJcbiAgICAgKi9cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICBmdW5jdGlvbiB2ZWN0b3IoY3R4LCBjb2xvciwgb3JpZ2luLCB2ZWN0b3IsIHNjYWxlKSB7XHJcbiAgICAgICAgaWYgKHNjYWxlID09PSB2b2lkIDApIHsgc2NhbGUgPSAxLjA7IH1cclxuICAgICAgICB2YXIgYyA9IGNvbG9yID8gY29sb3IudG9TdHJpbmcoKSA6ICdibHVlJztcclxuICAgICAgICB2YXIgdiA9IHZlY3Rvci5zY2FsZShzY2FsZSk7XHJcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGM7XHJcbiAgICAgICAgY3R4Lm1vdmVUbyhvcmlnaW4ueCwgb3JpZ2luLnkpO1xyXG4gICAgICAgIGN0eC5saW5lVG8ob3JpZ2luLnggKyB2LngsIG9yaWdpbi55ICsgdi55KTtcclxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgfVxyXG4gICAgZXhwb3J0cy52ZWN0b3IgPSB2ZWN0b3I7XHJcbiAgICAvKipcclxuICAgICAqIERyYXcgYSByb3VuZCByZWN0YW5nbGUgb24gYSBjYW52YXMgY29udGV4dFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggVGhlIGNhbnZhcyBjb250ZXh0XHJcbiAgICAgKiBAcGFyYW0geCBUaGUgdG9wLWxlZnQgeCBjb29yZGluYXRlXHJcbiAgICAgKiBAcGFyYW0geSBUaGUgdG9wLWxlZnQgeSBjb29yZGluYXRlXHJcbiAgICAgKiBAcGFyYW0gd2lkdGggVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGVcclxuICAgICAqIEBwYXJhbSBoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXHJcbiAgICAgKiBAcGFyYW0gcmFkaXVzIFRoZSBib3JkZXIgcmFkaXVzIG9mIHRoZSByZWN0YW5nbGVcclxuICAgICAqIEBwYXJhbSBmaWxsIFRoZSBbW0NvbG9yXV0gdG8gZmlsbCByZWN0YW5nbGUgd2l0aFxyXG4gICAgICogQHBhcmFtIHN0cm9rZSBUaGUgW1tDb2xvcl1dIHRvIHN0cm9rZSByZWN0YW5nbGUgd2l0aFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiByb3VuZFJlY3QoY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMsIHN0cm9rZSwgZmlsbCkge1xyXG4gICAgICAgIGlmIChyYWRpdXMgPT09IHZvaWQgMCkgeyByYWRpdXMgPSA1OyB9XHJcbiAgICAgICAgaWYgKHN0cm9rZSA9PT0gdm9pZCAwKSB7IHN0cm9rZSA9IENvbG9yXzUuQ29sb3IuV2hpdGU7IH1cclxuICAgICAgICBpZiAoZmlsbCA9PT0gdm9pZCAwKSB7IGZpbGwgPSBudWxsOyB9XHJcbiAgICAgICAgdmFyIGJyO1xyXG4gICAgICAgIGlmICh0eXBlb2YgcmFkaXVzID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICBiciA9IHsgdGw6IHJhZGl1cywgdHI6IHJhZGl1cywgYnI6IHJhZGl1cywgYmw6IHJhZGl1cyB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGRlZmF1bHRSYWRpdXMgPSB7IHRsOiAwLCB0cjogMCwgYnI6IDAsIGJsOiAwIH07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gZGVmYXVsdFJhZGl1cykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRSYWRpdXMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2lkZSA9IHByb3A7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJbc2lkZV0gPSByYWRpdXNbc2lkZV0gfHwgZGVmYXVsdFJhZGl1c1tzaWRlXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgY3R4Lm1vdmVUbyh4ICsgYnIudGwsIHkpO1xyXG4gICAgICAgIGN0eC5saW5lVG8oeCArIHdpZHRoIC0gYnIudHIsIHkpO1xyXG4gICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgYnIudHIpO1xyXG4gICAgICAgIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gYnIuYnIpO1xyXG4gICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gYnIuYnIsIHkgKyBoZWlnaHQpO1xyXG4gICAgICAgIGN0eC5saW5lVG8oeCArIGJyLmJsLCB5ICsgaGVpZ2h0KTtcclxuICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gYnIuYmwpO1xyXG4gICAgICAgIGN0eC5saW5lVG8oeCwgeSArIGJyLnRsKTtcclxuICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgYnIudGwsIHkpO1xyXG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICBpZiAoZmlsbCkge1xyXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3Ryb2tlKSB7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5yb3VuZFJlY3QgPSByb3VuZFJlY3Q7XHJcbiAgICBmdW5jdGlvbiBjaXJjbGUoY3R4LCB4LCB5LCByYWRpdXMsIHN0cm9rZSwgZmlsbCkge1xyXG4gICAgICAgIGlmIChzdHJva2UgPT09IHZvaWQgMCkgeyBzdHJva2UgPSBDb2xvcl81LkNvbG9yLldoaXRlOyB9XHJcbiAgICAgICAgaWYgKGZpbGwgPT09IHZvaWQgMCkgeyBmaWxsID0gbnVsbDsgfVxyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICBjdHguYXJjKHgsIHksIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xyXG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICBpZiAoZmlsbCkge1xyXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3Ryb2tlKSB7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5jaXJjbGUgPSBjaXJjbGU7XHJcbn0pO1xyXG5kZWZpbmUoXCJDb2xsaXNpb24vQm9keVwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIlBoeXNpY3NcIiwgXCJDb2xsaXNpb24vRWRnZUFyZWFcIiwgXCJDb2xsaXNpb24vQ2lyY2xlQXJlYVwiLCBcIkNvbGxpc2lvbi9Qb2x5Z29uQXJlYVwiLCBcIkNvbGxpc2lvbi9QYWlyXCIsIFwiQWxnZWJyYVwiLCBcIkRyYXdpbmcvQ29sb3JcIiwgXCJVdGlsL0RyYXdVdGlsXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgUGh5c2ljc181LCBFZGdlQXJlYV8zLCBDaXJjbGVBcmVhXzMsIFBvbHlnb25BcmVhXzUsIFBhaXJfMSwgQWxnZWJyYV85LCBDb2xvcl82LCBEcmF3VXRpbCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICB2YXIgQm9keSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBwaHlzaWNzIGJvZHkgYXNzb2NpYXRlZCB3aXRoIGFuIGFjdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gQm9keShhY3Rvcikge1xyXG4gICAgICAgICAgICB0aGlzLmFjdG9yID0gYWN0b3I7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBbW0lDb2xsaXNpb25BcmVhfENvbGxpc2lvbiBhcmVhXV0gb2YgdGhpcyBwaHlzaWNzIGJvZHksIGRlZmluZXMgdGhlIHNoYXBlIGZvciByaWdpZCBib2R5IGNvbGxpc2lvblxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25BcmVhID0gbnVsbDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSAoeCwgeSkgcG9zaXRpb24gb2YgdGhlIGFjdG9yIHRoaXMgd2lsbCBiZSBpbiB0aGUgbWlkZGxlIG9mIHRoZSBhY3RvciBpZiB0aGVcclxuICAgICAgICAgICAgICogW1tBY3Rvci5hbmNob3JdXSBpcyBzZXQgdG8gKDAuNSwgMC41KSB3aGljaCBpcyBkZWZhdWx0LlxyXG4gICAgICAgICAgICAgKiBJZiB5b3Ugd2FudCB0aGUgKHgsIHkpIHBvc2l0aW9uIHRvIGJlIHRoZSB0b3AgbGVmdCBvZiB0aGUgYWN0b3Igc3BlY2lmeSBhbiBhbmNob3Igb2YgKDAsIDApLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5wb3MgPSBuZXcgQWxnZWJyYV85LlZlY3RvcigwLCAwKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBwb3NpdGlvbiBvZiB0aGUgYWN0b3IgbGFzdCBmcmFtZSAoeCwgeSkgaW4gcGl4ZWxzXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLm9sZFBvcyA9IG5ldyBBbGdlYnJhXzkuVmVjdG9yKDAsIDApO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGN1cnJlbnQgdmVsb2NpdHkgdmVjdG9yICh2eCwgdnkpIG9mIHRoZSBhY3RvciBpbiBwaXhlbHMvc2Vjb25kXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnZlbCA9IG5ldyBBbGdlYnJhXzkuVmVjdG9yKDAsIDApO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIHZlbG9jaXR5IG9mIHRoZSBhY3RvciBsYXN0IGZyYW1lICh2eCwgdnkpIGluIHBpeGVscy9zZWNvbmRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMub2xkVmVsID0gbmV3IEFsZ2VicmFfOS5WZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgY3VycmV0IGFjY2VsZXJhdGlvbiB2ZWN0b3IgKGF4LCBheSkgb2YgdGhlIGFjdG9yIGluIHBpeGVscy9zZWNvbmQvc2Vjb25kLiBBbiBhY2NlbGVyYXRpb24gcG9pbnRpbmcgZG93biBzdWNoIGFzICgwLCAxMDApIG1heVxyXG4gICAgICAgICAgICAgKiBiZSB1c2VmdWwgdG8gc2ltdWxhdGUgYSBncmF2aXRhdGlvbmFsIGVmZmVjdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuYWNjID0gbmV3IEFsZ2VicmFfOS5WZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgY3VycmVudCB0b3JxdWUgYXBwbGllZCB0byB0aGUgYWN0b3JcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMudG9ycXVlID0gMDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBjdXJyZW50IG1hc3Mgb2YgdGhlIGFjdG9yLCBtYXNzIGNhbiBiZSB0aG91Z2h0IG9mIGFzIHRoZSByZXNpc3RhbmNlIHRvIGFjY2VsZXJhdGlvbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMubWFzcyA9IDEuMDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBjdXJyZW50IG1vbWVudCBvZiBpbmVydGlhLCBtb2kgY2FuIGJlIHRob3VnaHQgb2YgYXMgdGhlIHJlc2lzdGFuY2UgdG8gcm90YXRpb24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLm1vaSA9IDEwMDA7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgY3VycmVudCBcIm1vdGlvblwiIG9mIHRoZSBhY3RvciwgdXNlZCB0byBjYWxjdWxhdGVkIHNsZWVwIGluIHRoZSBwaHlzaWNzIHNpbXVsYXRpb25cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMubW90aW9uID0gMTA7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgY29lZmZpY2llbnQgb2YgZnJpY3Rpb24gb24gdGhpcyBhY3RvclxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5mcmljdGlvbiA9IC45OTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBjb2VmZmljaWVudCBvZiByZXN0aXR1dGlvbiBvZiB0aGlzIGFjdG9yLCByZXByZXNlbnRzIHRoZSBhbW91bnQgb2YgZW5lcmd5IHByZXNlcnZlZCBhZnRlciBjb2xsaXNpb25cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMucmVzdGl0dXRpb24gPSAuMjtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSByb3RhdGlvbiBvZiB0aGUgYWN0b3IgaW4gcmFkaWFuc1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbiA9IDA7IC8vIHJhZGlhbnNcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSByb3RhdGlvbmFsIHZlbG9jaXR5IG9mIHRoZSBhY3RvciBpbiByYWRpYW5zL3NlY29uZFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5yeCA9IDA7IC8vcmFkaWFucy9zZWNcclxuICAgICAgICAgICAgdGhpcy5fdG90YWxNdHYgPSBBbGdlYnJhXzkuVmVjdG9yLlplcm8uY2xvbmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkIG1pbmltdW0gdHJhbnNsYXRpb24gdmVjdG9ycyBhY2N1bXVsYXRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgZnJhbWUgdG8gcmVzb2x2ZSBjb2xsaXNpb25zLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJvZHkucHJvdG90eXBlLmFkZE10diA9IGZ1bmN0aW9uIChtdHYpIHtcclxuICAgICAgICAgICAgdGhpcy5fdG90YWxNdHYuYWRkRXF1YWwobXR2KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFwcGxpZXMgdGhlIGFjY3VtdWxhdGVkIHRyYW5zbGF0aW9uIHZlY3RvcnMgdG8gdGhlIGFjdG9ycyBwb3NpdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJvZHkucHJvdG90eXBlLmFwcGx5TXR2ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnBvcy5hZGRFcXVhbCh0aGlzLl90b3RhbE10dik7XHJcbiAgICAgICAgICAgIHRoaXMuX3RvdGFsTXR2LnNldFRvKDAsIDApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgYm9keSdzIFtbQm91bmRpbmdCb3hdXSBjYWxjdWxhdGVkIGZvciB0aGlzIGluc3RhbnQgaW4gd29ybGQgc3BhY2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQm9keS5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoUGh5c2ljc181LlBoeXNpY3MuY29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5ID09PSBQaHlzaWNzXzUuQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5LkJveCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0b3IuZ2V0Qm91bmRzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb2xsaXNpb25BcmVhLmdldEJvdW5kcygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBhY3RvcidzIFtbQm91bmRpbmdCb3hdXSByZWxhdGl2ZSB0byB0aGUgYWN0b3JzIHBvc2l0aW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJvZHkucHJvdG90eXBlLmdldFJlbGF0aXZlQm91bmRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoUGh5c2ljc181LlBoeXNpY3MuY29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5ID09PSBQaHlzaWNzXzUuQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5LkJveCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0b3IuZ2V0UmVsYXRpdmVCb3VuZHMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdG9yLmdldFJlbGF0aXZlQm91bmRzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwZGF0ZXMgdGhlIGNvbGxpc2lvbiBhcmVhIGdlb21ldHJ5IGFuZCBpbnRlcm5hbCBjYWNoZXNcclxuICAgICAgICAgKi9cclxuICAgICAgICBCb2R5LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbGxpc2lvbkFyZWEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uQXJlYS5yZWNhbGMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB1cCBhIGJveCBjb2xsaXNpb24gYXJlYSBiYXNlZCBvbiB0aGUgY3VycmVudCBib3VuZHMgb2YgdGhlIGFzc29jaWF0ZWQgYWN0b3Igb2YgdGhpcyBwaHlzaWNzIGJvZHkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBCeSBkZWZhdWx0LCB0aGUgYm94IGlzIGNlbnRlciBpcyBhdCAoMCwgMCkgd2hpY2ggbWVhbnMgaXQgaXMgY2VudGVyZWQgYXJvdW5kIHRoZSBhY3RvcnMgYW5jaG9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJvZHkucHJvdG90eXBlLnVzZUJveENvbGxpc2lvbiA9IGZ1bmN0aW9uIChjZW50ZXIpIHtcclxuICAgICAgICAgICAgaWYgKGNlbnRlciA9PT0gdm9pZCAwKSB7IGNlbnRlciA9IEFsZ2VicmFfOS5WZWN0b3IuWmVyby5jbG9uZSgpOyB9XHJcbiAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uQXJlYSA9IG5ldyBQb2x5Z29uQXJlYV81LlBvbHlnb25BcmVhKHtcclxuICAgICAgICAgICAgICAgIGJvZHk6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICBwb2ludHM6IHRoaXMuYWN0b3IuZ2V0UmVsYXRpdmVCb3VuZHMoKS5nZXRQb2ludHMoKSxcclxuICAgICAgICAgICAgICAgIHBvczogY2VudGVyIC8vIHBvc2l0aW9uIHJlbGF0aXZlIHRvIGFjdG9yXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyBpbiBjYXNlIG9mIGEgbmFuIG1vaSwgY29hbGVzY2UgdG8gYSBzYWZlIGRlZmF1bHRcclxuICAgICAgICAgICAgdGhpcy5tb2kgPSB0aGlzLmNvbGxpc2lvbkFyZWEuZ2V0TW9tZW50T2ZJbmVydGlhKCkgfHwgdGhpcy5tb2k7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHVwIGEgcG9seWdvbiBjb2xsaXNpb24gYXJlYSBiYXNlZCBvbiBhIGxpc3Qgb2Ygb2YgcG9pbnRzIHJlbGF0aXZlIHRvIHRoZSBhbmNob3Igb2YgdGhlIGFzc29jaWF0ZWQgYWN0b3Igb2YgdGhpcyBwaHlzaWNzIGJvZHkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBPbmx5IFtjb252ZXggcG9seWdvbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29udmV4X3BvbHlnb24pIGRlZmluaXRpb25zIGFyZSBzdXBwb3J0ZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBCeSBkZWZhdWx0LCB0aGUgYm94IGlzIGNlbnRlciBpcyBhdCAoMCwgMCkgd2hpY2ggbWVhbnMgaXQgaXMgY2VudGVyZWQgYXJvdW5kIHRoZSBhY3RvcnMgYW5jaG9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJvZHkucHJvdG90eXBlLnVzZVBvbHlnb25Db2xsaXNpb24gPSBmdW5jdGlvbiAocG9pbnRzLCBjZW50ZXIpIHtcclxuICAgICAgICAgICAgaWYgKGNlbnRlciA9PT0gdm9pZCAwKSB7IGNlbnRlciA9IEFsZ2VicmFfOS5WZWN0b3IuWmVyby5jbG9uZSgpOyB9XHJcbiAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uQXJlYSA9IG5ldyBQb2x5Z29uQXJlYV81LlBvbHlnb25BcmVhKHtcclxuICAgICAgICAgICAgICAgIGJvZHk6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICBwb2ludHM6IHBvaW50cyxcclxuICAgICAgICAgICAgICAgIHBvczogY2VudGVyIC8vIHBvc2l0aW9uIHJlbGF0aXZlIHRvIGFjdG9yXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyBpbiBjYXNlIG9mIGEgbmFuIG1vaSwgY29sbGVzY2UgdG8gYSBzYWZlIGRlZmF1bHRcclxuICAgICAgICAgICAgdGhpcy5tb2kgPSB0aGlzLmNvbGxpc2lvbkFyZWEuZ2V0TW9tZW50T2ZJbmVydGlhKCkgfHwgdGhpcy5tb2k7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHVwIGEgW1tDaXJjbGVBcmVhfGNpcmNsZSBjb2xsaXNpb24gYXJlYV1dIHdpdGggYSBzcGVjaWZpZWQgcmFkaXVzIGluIHBpeGVscy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEJ5IGRlZmF1bHQsIHRoZSBib3ggaXMgY2VudGVyIGlzIGF0ICgwLCAwKSB3aGljaCBtZWFucyBpdCBpcyBjZW50ZXJlZCBhcm91bmQgdGhlIGFjdG9ycyBhbmNob3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQm9keS5wcm90b3R5cGUudXNlQ2lyY2xlQ29sbGlzaW9uID0gZnVuY3Rpb24gKHJhZGl1cywgY2VudGVyKSB7XHJcbiAgICAgICAgICAgIGlmIChjZW50ZXIgPT09IHZvaWQgMCkgeyBjZW50ZXIgPSBBbGdlYnJhXzkuVmVjdG9yLlplcm8uY2xvbmUoKTsgfVxyXG4gICAgICAgICAgICBpZiAoIXJhZGl1cykge1xyXG4gICAgICAgICAgICAgICAgcmFkaXVzID0gdGhpcy5hY3Rvci5nZXRXaWR0aCgpIC8gMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmNvbGxpc2lvbkFyZWEgPSBuZXcgQ2lyY2xlQXJlYV8zLkNpcmNsZUFyZWEoe1xyXG4gICAgICAgICAgICAgICAgYm9keTogdGhpcyxcclxuICAgICAgICAgICAgICAgIHJhZGl1czogcmFkaXVzLFxyXG4gICAgICAgICAgICAgICAgcG9zOiBjZW50ZXJcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMubW9pID0gdGhpcy5jb2xsaXNpb25BcmVhLmdldE1vbWVudE9mSW5lcnRpYSgpIHx8IHRoaXMubW9pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB1cCBhbiBbW0VkZ2VBcmVhfGVkZ2UgY29sbGlzaW9uXV0gd2l0aCBhIHN0YXJ0IHBvaW50IGFuZCBhbiBlbmQgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGFuY2hvciBvZiB0aGUgYXNzb2NpYXRlZCBhY3RvclxyXG4gICAgICAgICAqIG9mIHRoaXMgcGh5c2ljcyBib2R5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQnkgZGVmYXVsdCwgdGhlIGJveCBpcyBjZW50ZXIgaXMgYXQgKDAsIDApIHdoaWNoIG1lYW5zIGl0IGlzIGNlbnRlcmVkIGFyb3VuZCB0aGUgYWN0b3JzIGFuY2hvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBCb2R5LnByb3RvdHlwZS51c2VFZGdlQ29sbGlzaW9uID0gZnVuY3Rpb24gKGJlZ2luLCBlbmQpIHtcclxuICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25BcmVhID0gbmV3IEVkZ2VBcmVhXzMuRWRnZUFyZWEoe1xyXG4gICAgICAgICAgICAgICAgYmVnaW46IGJlZ2luLFxyXG4gICAgICAgICAgICAgICAgZW5kOiBlbmQsXHJcbiAgICAgICAgICAgICAgICBib2R5OiB0aGlzXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLm1vaSA9IHRoaXMuY29sbGlzaW9uQXJlYS5nZXRNb21lbnRPZkluZXJ0aWEoKSB8fCB0aGlzLm1vaTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgQm9keS5wcm90b3R5cGUuZGVidWdEcmF3ID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gICAgICAgICAgICAvLyBEcmF3IG1vdGlvbiB2ZWN0b3JzXHJcbiAgICAgICAgICAgIGlmIChQaHlzaWNzXzUuUGh5c2ljcy5zaG93TW90aW9uVmVjdG9ycykge1xyXG4gICAgICAgICAgICAgICAgRHJhd1V0aWwudmVjdG9yKGN0eCwgQ29sb3JfNi5Db2xvci5ZZWxsb3csIHRoaXMucG9zLCAodGhpcy5hY2MuYWRkKFBoeXNpY3NfNS5QaHlzaWNzLmFjYykpKTtcclxuICAgICAgICAgICAgICAgIERyYXdVdGlsLnZlY3RvcihjdHgsIENvbG9yXzYuQ29sb3IuUmVkLCB0aGlzLnBvcywgKHRoaXMudmVsKSk7XHJcbiAgICAgICAgICAgICAgICBEcmF3VXRpbC5wb2ludChjdHgsIENvbG9yXzYuQ29sb3IuUmVkLCB0aGlzLnBvcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKFBoeXNpY3NfNS5QaHlzaWNzLnNob3dCb3VuZHMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0Qm91bmRzKCkuZGVidWdEcmF3KGN0eCwgQ29sb3JfNi5Db2xvci5ZZWxsb3cpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChQaHlzaWNzXzUuUGh5c2ljcy5zaG93QXJlYSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25BcmVhLmRlYnVnRHJhdyhjdHgsIENvbG9yXzYuQ29sb3IuR3JlZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBib2R5IGNvbGxpZGVkIHdpdGhcclxuICAgICAgICAgKiBvciB3YXMgaW4gc3RhdGlvbmFyeSBjb250YWN0IHdpdGhcclxuICAgICAgICAgKiB0aGUgYm9keSBvZiB0aGUgb3RoZXIgW1tBY3Rvcl1dXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQm9keS5wcm90b3R5cGUudG91Y2hpbmcgPSBmdW5jdGlvbiAob3RoZXIpIHtcclxuICAgICAgICAgICAgdmFyIHBhaXIgPSBuZXcgUGFpcl8xLlBhaXIodGhpcywgb3RoZXIuYm9keSk7XHJcbiAgICAgICAgICAgIHBhaXIuY29sbGlkZSgpO1xyXG4gICAgICAgICAgICBpZiAocGFpci5jb2xsaXNpb24pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBCb2R5O1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuQm9keSA9IEJvZHk7XHJcbn0pO1xyXG5kZWZpbmUoXCJDb2xsaXNpb24vUGFpclwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIlBoeXNpY3NcIiwgXCJEcmF3aW5nL0NvbG9yXCIsIFwiQWN0b3JcIiwgXCJVdGlsL0RyYXdVdGlsXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgUGh5c2ljc182LCBDb2xvcl83LCBBY3Rvcl8yLCBEcmF3VXRpbCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIE1vZGVscyBhIHBvdGVudGlhbCBjb2xsaXNpb24gYmV0d2VlbiAyIGJvZGllc1xyXG4gICAgICovXHJcbiAgICB2YXIgUGFpciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gUGFpcihib2R5QSwgYm9keUIpIHtcclxuICAgICAgICAgICAgdGhpcy5ib2R5QSA9IGJvZHlBO1xyXG4gICAgICAgICAgICB0aGlzLmJvZHlCID0gYm9keUI7XHJcbiAgICAgICAgICAgIHRoaXMuaWQgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmNvbGxpc2lvbiA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuaWQgPSBQYWlyLmNhbGN1bGF0ZVBhaXJIYXNoKGJvZHlBLCBib2R5Qik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQYWlyLnByb3RvdHlwZSwgXCJjYW5Db2xsaWRlXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgaXQgaXMgcG9zc2libGUgZm9yIHRoZSBwYWlycyB0byBjb2xsaWRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhY3RvckEgPSB0aGlzLmJvZHlBLmFjdG9yO1xyXG4gICAgICAgICAgICAgICAgdmFyIGFjdG9yQiA9IHRoaXMuYm9keUIuYWN0b3I7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiBib3RoIGFyZSBmaXhlZCBzaG9ydCBjaXJjdWl0XHJcbiAgICAgICAgICAgICAgICBpZiAoYWN0b3JBLmNvbGxpc2lvblR5cGUgPT09IEFjdG9yXzIuQ29sbGlzaW9uVHlwZS5GaXhlZCAmJiBhY3RvckIuY29sbGlzaW9uVHlwZSA9PT0gQWN0b3JfMi5Db2xsaXNpb25UeXBlLkZpeGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIG90aGVyIGlzIHByZXZlbnQgY29sbGlzaW9uIG9yIGlzIGRlYWQgc2hvcnQgY2lyY3VpdFxyXG4gICAgICAgICAgICAgICAgaWYgKGFjdG9yQi5jb2xsaXNpb25UeXBlID09PSBBY3Rvcl8yLkNvbGxpc2lvblR5cGUuUHJldmVudENvbGxpc2lvbiB8fCBhY3RvckIuaXNLaWxsZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSdW5zIHRoZSBjb2xsaXNvbiBpbnRlcnNlY3Rpb24gbG9naWMgb24gdGhlIG1lbWJlcnMgb2YgdGhpcyBwYWlyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUGFpci5wcm90b3R5cGUuY29sbGlkZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5jb2xsaXNpb24gPSB0aGlzLmJvZHlBLmNvbGxpc2lvbkFyZWEuY29sbGlkZSh0aGlzLmJvZHlCLmNvbGxpc2lvbkFyZWEpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVzb3ZsZXMgdGhlIGNvbGxpc2lvbiBib2R5IHBvc2l0aW9uIGFuZCB2ZWxvY2l0eSBpZiBhIGNvbGxpc2lvbiBvY2N1cmVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUGFpci5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIChzdHJhdGVneSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb2xsaXNpb24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uLnJlc29sdmUoc3RyYXRlZ3kpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSB1bmlxdWUgcGFpciBoYXNoIGlkIGZvciB0aGlzIGNvbGxpc2lvbiBwYWlyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUGFpci5jYWxjdWxhdGVQYWlySGFzaCA9IGZ1bmN0aW9uIChib2R5QSwgYm9keUIpIHtcclxuICAgICAgICAgICAgaWYgKGJvZHlBLmFjdG9yLmlkIDwgYm9keUIuYWN0b3IuaWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIiNcIiArIGJvZHlBLmFjdG9yLmlkICsgXCIrXCIgKyBib2R5Qi5hY3Rvci5pZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIiNcIiArIGJvZHlCLmFjdG9yLmlkICsgXCIrXCIgKyBib2R5QS5hY3Rvci5pZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBQYWlyLnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbGxpc2lvbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKFBoeXNpY3NfNi5QaHlzaWNzLnNob3dDb250YWN0cykge1xyXG4gICAgICAgICAgICAgICAgICAgIERyYXdVdGlsLnBvaW50KGN0eCwgQ29sb3JfNy5Db2xvci5SZWQsIHRoaXMuY29sbGlzaW9uLnBvaW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChQaHlzaWNzXzYuUGh5c2ljcy5zaG93Q29sbGlzaW9uTm9ybWFscykge1xyXG4gICAgICAgICAgICAgICAgICAgIERyYXdVdGlsLnZlY3RvcihjdHgsIENvbG9yXzcuQ29sb3IuQ3lhbiwgdGhpcy5jb2xsaXNpb24ucG9pbnQsIHRoaXMuY29sbGlzaW9uLm5vcm1hbCwgMzApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gUGFpcjtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLlBhaXIgPSBQYWlyO1xyXG59KTtcclxuZGVmaW5lKFwiRGVidWdcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogRGVidWcgc3RhdGlzdGljcyBhbmQgZmxhZ3MgZm9yIEV4Y2FsaWJ1ci4gSWYgcG9sbGluZyB0aGVzZSB2YWx1ZXMsIGl0IHdvdWxkIGJlXHJcbiAgICAgKiBiZXN0IHRvIGRvIHNvIG9uIHRoZSBgcG9zdHVwZGF0ZWAgZXZlbnQgZm9yIFtbRW5naW5lXV0sIGFmdGVyIGFsbCB2YWx1ZXMgaGF2ZSBiZWVuXHJcbiAgICAgKiB1cGRhdGVkIGR1cmluZyBhIGZyYW1lLlxyXG4gICAgICovXHJcbiAgICB2YXIgRGVidWcgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIERlYnVnKCkge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUGVyZm9ybWFuY2Ugc3RhdGlzdGljc1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5zdGF0cyA9IHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQ3VycmVudCBmcmFtZSBzdGF0aXN0aWNzLiBFbmdpbmUgcmV1c2VzIHRoaXMgaW5zdGFuY2UsIHVzZSBbW0ZyYW1lU3RhdHMuY2xvbmVdXSB0byBjb3B5IGZyYW1lIHN0YXRzLlxyXG4gICAgICAgICAgICAgICAgICogQmVzdCBhY2Nlc3NlZCBvbiBbW3Bvc3RmcmFtZV1dIGV2ZW50LiBTZWUgW1tJRnJhbWVTdGF0c11dXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGN1cnJGcmFtZTogbmV3IEZyYW1lU3RhdHMoKSxcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUHJldmlvdXMgZnJhbWUgc3RhdGlzdGljcy4gRW5naW5lIHJldXNlcyB0aGlzIGluc3RhbmNlLCB1c2UgW1tGcmFtZVN0YXRzLmNsb25lXV0gdG8gY29weSBmcmFtZSBzdGF0cy5cclxuICAgICAgICAgICAgICAgICAqIEJlc3QgYWNjZXNzZWQgb24gW1twcmVmcmFtZV1dIGV2ZW50LiBCZXN0IGluc3BlY3RlZCBvbiBlbmdpbmUgZXZlbnQgYHByZWZyYW1lYC4gU2VlIFtbSUZyYW1lU3RhdHNdXVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBwcmV2RnJhbWU6IG5ldyBGcmFtZVN0YXRzKClcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIERlYnVnO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuRGVidWcgPSBEZWJ1ZztcclxuICAgIC8qKlxyXG4gICAgICogSW1wbGVtZW50YXRpb24gb2YgYSBmcmFtZSdzIHN0YXRzLiBNZWFudCB0byBoYXZlIHZhbHVlcyBjb3BpZWQgdmlhIFtbRnJhbWVTdGF0cy5yZXNldF1dLCBhdm9pZFxyXG4gICAgICogY3JlYXRpbmcgaW5zdGFuY2VzIG9mIHRoaXMgZXZlcnkgZnJhbWUuXHJcbiAgICAgKi9cclxuICAgIHZhciBGcmFtZVN0YXRzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBGcmFtZVN0YXRzKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9pZCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2RlbHRhID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fZnBzID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3JTdGF0cyA9IHtcclxuICAgICAgICAgICAgICAgIGFsaXZlOiAwLFxyXG4gICAgICAgICAgICAgICAga2lsbGVkOiAwLFxyXG4gICAgICAgICAgICAgICAgdWk6IDAsXHJcbiAgICAgICAgICAgICAgICBnZXQgcmVtYWluaW5nKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFsaXZlIC0gdGhpcy5raWxsZWQ7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZ2V0IHRvdGFsKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbWFpbmluZyArIHRoaXMudWk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuX2R1cmF0aW9uU3RhdHMgPSB7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGU6IDAsXHJcbiAgICAgICAgICAgICAgICBkcmF3OiAwLFxyXG4gICAgICAgICAgICAgICAgZ2V0IHRvdGFsKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZSArIHRoaXMuZHJhdztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5fcGh5c2ljc1N0YXRzID0gbmV3IFBoeXNpY3NTdGF0cygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBaZXJvIG91dCB2YWx1ZXMgb3IgY2xvbmUgb3RoZXIgSUZyYW1lU3RhdCBzdGF0cy4gQWxsb3dzIGluc3RhbmNlIHJldXNlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIFtvdGhlclN0YXRzXSBPcHRpb25hbCBzdGF0cyB0byBjbG9uZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEZyYW1lU3RhdHMucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKG90aGVyU3RhdHMpIHtcclxuICAgICAgICAgICAgaWYgKG90aGVyU3RhdHMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaWQgPSBvdGhlclN0YXRzLmlkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWx0YSA9IG90aGVyU3RhdHMuZGVsdGE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZwcyA9IG90aGVyU3RhdHMuZnBzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hY3RvcnMuYWxpdmUgPSBvdGhlclN0YXRzLmFjdG9ycy5hbGl2ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWN0b3JzLmtpbGxlZCA9IG90aGVyU3RhdHMuYWN0b3JzLmtpbGxlZDtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWN0b3JzLnVpID0gb3RoZXJTdGF0cy5hY3RvcnMudWk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmR1cmF0aW9uLnVwZGF0ZSA9IG90aGVyU3RhdHMuZHVyYXRpb24udXBkYXRlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kdXJhdGlvbi5kcmF3ID0gb3RoZXJTdGF0cy5kdXJhdGlvbi5kcmF3O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGh5c2ljc1N0YXRzLnJlc2V0KG90aGVyU3RhdHMucGh5c2ljcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlkID0gdGhpcy5kZWx0YSA9IHRoaXMuZnBzID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWN0b3JzLmFsaXZlID0gdGhpcy5hY3RvcnMua2lsbGVkID0gdGhpcy5hY3RvcnMudWkgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kdXJhdGlvbi51cGRhdGUgPSB0aGlzLmR1cmF0aW9uLmRyYXcgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGh5c2ljc1N0YXRzLnJlc2V0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByb3ZpZGVzIGEgY2xvbmUgb2YgdGhpcyBpbnN0YW5jZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBGcmFtZVN0YXRzLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGZzID0gbmV3IEZyYW1lU3RhdHMoKTtcclxuICAgICAgICAgICAgZnMucmVzZXQodGhpcyk7XHJcbiAgICAgICAgICAgIHJldHVybiBmcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGcmFtZVN0YXRzLnByb3RvdHlwZSwgXCJpZFwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBmcmFtZSdzIGlkXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pZDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHMgdGhlIGZyYW1lJ3MgaWRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pZCA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnJhbWVTdGF0cy5wcm90b3R5cGUsIFwiZGVsdGFcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgZnJhbWUncyBkZWx0YSAodGltZSBzaW5jZSBsYXN0IGZyYW1lKVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVsdGE7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXRzIHRoZSBmcmFtZSdzIGRlbHRhICh0aW1lIHNpbmNlIGxhc3QgZnJhbWUpLiBJbnRlcm5hbCB1c2Ugb25seS5cclxuICAgICAgICAgICAgICogQGludGVybmFsXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGVsdGEgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZyYW1lU3RhdHMucHJvdG90eXBlLCBcImZwc1wiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBmcmFtZSdzIGZyYW1lcy1wZXItc2Vjb25kIChGUFMpXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9mcHM7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXRzIHRoZSBmcmFtZSdzIGZyYW1lcy1wZXItc2Vjb25kIChGUFMpLiBJbnRlcm5hbCB1c2Ugb25seS5cclxuICAgICAgICAgICAgICogQGludGVybmFsXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZnBzID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGcmFtZVN0YXRzLnByb3RvdHlwZSwgXCJhY3RvcnNcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgZnJhbWUncyBhY3RvciBzdGF0aXN0aWNzXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hY3RvclN0YXRzO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnJhbWVTdGF0cy5wcm90b3R5cGUsIFwiZHVyYXRpb25cIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgZnJhbWUncyBkdXJhdGlvbiBzdGF0aXN0aWNzXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kdXJhdGlvblN0YXRzO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnJhbWVTdGF0cy5wcm90b3R5cGUsIFwicGh5c2ljc1wiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBmcmFtZSdzIHBoeXNpY3Mgc3RhdGlzdGljc1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGh5c2ljc1N0YXRzO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gRnJhbWVTdGF0cztcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkZyYW1lU3RhdHMgPSBGcmFtZVN0YXRzO1xyXG4gICAgdmFyIFBoeXNpY3NTdGF0cyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gUGh5c2ljc1N0YXRzKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9wYWlycyA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbGxpc2lvbnMgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9jb2xsaWRlcnNIYXNoID0ge307XHJcbiAgICAgICAgICAgIHRoaXMuX2Zhc3RCb2RpZXMgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9mYXN0Qm9keUNvbGxpc2lvbnMgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9icm9hZHBoYXNlID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fbmFycm93cGhhc2UgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBaZXJvIG91dCB2YWx1ZXMgb3IgY2xvbmUgb3RoZXIgSVBoeXNpY3NTdGF0cyBzdGF0cy4gQWxsb3dzIGluc3RhbmNlIHJldXNlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIFtvdGhlclN0YXRzXSBPcHRpb25hbCBzdGF0cyB0byBjbG9uZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBoeXNpY3NTdGF0cy5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAob3RoZXJTdGF0cykge1xyXG4gICAgICAgICAgICBpZiAob3RoZXJTdGF0cykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYWlycyA9IG90aGVyU3RhdHMucGFpcnM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbGxpc2lvbnMgPSBvdGhlclN0YXRzLmNvbGxpc2lvbnM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbGxpZGVyc0hhc2ggPSBvdGhlclN0YXRzLmNvbGxpZGVyc0hhc2g7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZhc3RCb2RpZXMgPSBvdGhlclN0YXRzLmZhc3RCb2RpZXM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZhc3RCb2R5Q29sbGlzaW9ucyA9IG90aGVyU3RhdHMuZmFzdEJvZHlDb2xsaXNpb25zO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5icm9hZHBoYXNlID0gb3RoZXJTdGF0cy5icm9hZHBoYXNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uYXJyb3dwaGFzZSA9IG90aGVyU3RhdHMubmFycm93cGhhc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhaXJzID0gdGhpcy5jb2xsaXNpb25zID0gdGhpcy5mYXN0Qm9kaWVzID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmFzdEJvZHlDb2xsaXNpb25zID0gdGhpcy5icm9hZHBoYXNlID0gdGhpcy5uYXJyb3dwaGFzZSA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbGxpZGVyc0hhc2ggPSB7fTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJvdmlkZXMgYSBjbG9uZSBvZiB0aGlzIGluc3RhbmNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBoeXNpY3NTdGF0cy5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBwcyA9IG5ldyBQaHlzaWNzU3RhdHMoKTtcclxuICAgICAgICAgICAgcHMucmVzZXQodGhpcyk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQaHlzaWNzU3RhdHMucHJvdG90eXBlLCBcInBhaXJzXCIsIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFpcnM7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wYWlycyA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGh5c2ljc1N0YXRzLnByb3RvdHlwZSwgXCJjb2xsaXNpb25zXCIsIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sbGlzaW9ucztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxpc2lvbnMgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBoeXNpY3NTdGF0cy5wcm90b3R5cGUsIFwiY29sbGlkZXJzSGFzaFwiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbGxpZGVyc0hhc2g7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGNvbGxpZGVycykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY29sbGlkZXJzSGFzaCA9IGNvbGxpZGVycztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBoeXNpY3NTdGF0cy5wcm90b3R5cGUsIFwiZmFzdEJvZGllc1wiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Zhc3RCb2RpZXM7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mYXN0Qm9kaWVzID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQaHlzaWNzU3RhdHMucHJvdG90eXBlLCBcImZhc3RCb2R5Q29sbGlzaW9uc1wiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Zhc3RCb2R5Q29sbGlzaW9ucztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Zhc3RCb2R5Q29sbGlzaW9ucyA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGh5c2ljc1N0YXRzLnByb3RvdHlwZSwgXCJicm9hZHBoYXNlXCIsIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYnJvYWRwaGFzZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Jyb2FkcGhhc2UgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBoeXNpY3NTdGF0cy5wcm90b3R5cGUsIFwibmFycm93cGhhc2VcIiwge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXJyb3dwaGFzZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX25hcnJvd3BoYXNlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBQaHlzaWNzU3RhdHM7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5QaHlzaWNzU3RhdHMgPSBQaHlzaWNzU3RhdHM7XHJcbn0pO1xyXG5kZWZpbmUoXCJJbnRlcmZhY2VzL0lFdmVudGVkXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbn0pO1xyXG5kZWZpbmUoXCJFdmVudERpc3BhdGNoZXJcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJFdmVudHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBFdmVudHNfMikge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEV4Y2FsaWJ1cidzIGludGVybmFsIGV2ZW50IGRpc3BhdGNoZXIgaW1wbGVtZW50YXRpb24uXHJcbiAgICAgKiBDYWxsYmFja3MgYXJlIGZpcmVkIGltbWVkaWF0ZWx5IGFmdGVyIGFuIGV2ZW50IGlzIHB1Ymxpc2hlZC5cclxuICAgICAqIFR5cGljYWxseSB5b3Ugd2lsbCB1c2UgW1tDbGFzcy5ldmVudERpc3BhdGNoZXJdXSBzaW5jZSBtb3N0IGNsYXNzZXMgaW5cclxuICAgICAqIEV4Y2FsaWJ1ciBpbmhlcml0IGZyb20gW1tDbGFzc11dLiBZb3Ugd2lsbCByYXJlbHkgY3JlYXRlIGFuIGBFdmVudERpc3BhdGNoZXJgXHJcbiAgICAgKiB5b3Vyc2VsZi5cclxuICAgICAqXHJcbiAgICAgKiBbW2luY2x1ZGU6RXZlbnRzLm1kXV1cclxuICAgICAqL1xyXG4gICAgdmFyIEV2ZW50RGlzcGF0Y2hlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHRhcmdldCAgVGhlIG9iamVjdCB0aGF0IHdpbGwgYmUgdGhlIHJlY2lwaWVudCBvZiBldmVudHMgZnJvbSB0aGlzIGV2ZW50IGRpc3BhdGNoZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBFdmVudERpc3BhdGNoZXIodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzID0ge307XHJcbiAgICAgICAgICAgIHRoaXMuX3dpcmVkRXZlbnREaXNwYXRjaGVycyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVtaXRzIGFuIGV2ZW50IGZvciB0YXJnZXRcclxuICAgICAgICAgKiBAcGFyYW0gZXZlbnROYW1lICBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gcHVibGlzaFxyXG4gICAgICAgICAqIEBwYXJhbSBldmVudCAgICAgIE9wdGlvbmFsbHkgcGFzcyBhbiBldmVudCBkYXRhIG9iamVjdCB0byB0aGUgaGFuZGxlclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGlmICghZXZlbnROYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBrZXkgbm90IG1hcHBlZFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGV2ZW50TmFtZSA9IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fdGFyZ2V0O1xyXG4gICAgICAgICAgICBpZiAoIWV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICBldmVudCA9IG5ldyBFdmVudHNfMi5HYW1lRXZlbnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBldmVudC50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIHZhciBpLCBsZW47XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgICAgICAgIGxlbiA9IHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV0ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdW2ldLmNhbGwodGFyZ2V0LCBldmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgICAgIGxlbiA9IHRoaXMuX3dpcmVkRXZlbnREaXNwYXRjaGVycy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl93aXJlZEV2ZW50RGlzcGF0Y2hlcnNbaV0uZW1pdChldmVudE5hbWUsIGV2ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3Vic2NyaWJlIGFuIGV2ZW50IGhhbmRsZXIgdG8gYSBwYXJ0aWN1bGFyIGV2ZW50IG5hbWUsIG11bHRpcGxlIGhhbmRsZXJzIHBlciBldmVudCBuYW1lIGFyZSBhbGxvd2VkLlxyXG4gICAgICAgICAqIEBwYXJhbSBldmVudE5hbWUgIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBzdWJzY3JpYmUgdG9cclxuICAgICAgICAgKiBAcGFyYW0gaGFuZGxlciAgICBUaGUgaGFuZGxlciBjYWxsYmFjayB0byBmaXJlIG9uIHRoaXMgZXZlbnRcclxuICAgICAgICAgKi9cclxuICAgICAgICBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgICAgICBldmVudE5hbWUgPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXS5wdXNoKGhhbmRsZXIpO1xyXG4gICAgICAgICAgICAvLyBtZXRhIGV2ZW50IGhhbmRsZXJzXHJcbiAgICAgICAgICAgIGlmIChldmVudE5hbWUgIT09ICd1bnN1YnNjcmliZScgJiYgZXZlbnROYW1lICE9PSAnc3Vic2NyaWJlJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdzdWJzY3JpYmUnLCBuZXcgRXZlbnRzXzIuU3Vic2NyaWJlRXZlbnQoZXZlbnROYW1lLCBoYW5kbGVyKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVuc3Vic2NyaWJlIGFuIGV2ZW50IGhhbmRsZXIocykgZnJvbSBhbiBldmVudC4gSWYgYSBzcGVjaWZpYyBoYW5kbGVyXHJcbiAgICAgICAgICogaXMgc3BlY2lmaWVkIGZvciBhbiBldmVudCwgb25seSB0aGF0IGhhbmRsZXIgd2lsbCBiZSB1bnN1YnNjcmliZWQuXHJcbiAgICAgICAgICogT3RoZXJ3aXNlIGFsbCBoYW5kbGVycyB3aWxsIGJlIHVuc3Vic2NyaWJlZCBmb3IgdGhhdCBldmVudC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBldmVudE5hbWUgIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byB1bnN1YnNjcmliZVxyXG4gICAgICAgICAqIEBwYXJhbSBoYW5kbGVyICAgIE9wdGlvbmFsbHkgdGhlIHNwZWNpZmljIGhhbmRsZXIgdG8gdW5zdWJzY3JpYmVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgICAgICBldmVudE5hbWUgPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgdmFyIGV2ZW50SGFuZGxlcnMgPSB0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdO1xyXG4gICAgICAgICAgICBpZiAoZXZlbnRIYW5kbGVycykge1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgbm8gZXhwbGljaXQgaGFuZGxlciBpcyBnaXZlIHdpdGggdGhlIGV2ZW50IG5hbWUgY2xlYXIgYWxsIGhhbmRsZXJzXHJcbiAgICAgICAgICAgICAgICBpZiAoIWhhbmRsZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBldmVudEhhbmRsZXJzLmluZGV4T2YoaGFuZGxlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIG1ldGEgZXZlbnQgaGFuZGxlcnNcclxuICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSAhPT0gJ3Vuc3Vic2NyaWJlJyAmJiBldmVudE5hbWUgIT09ICdzdWJzY3JpYmUnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3Vuc3Vic2NyaWJlJywgbmV3IEV2ZW50c18yLlVuc3Vic2NyaWJlRXZlbnQoZXZlbnROYW1lLCBoYW5kbGVyKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE9uY2UgbGlzdGVucyB0byBhbiBldmVudCBvbmUgdGltZSwgdGhlbiB1bnN1YnNjcmliZXMgZnJvbSB0aGF0IGV2ZW50XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gZXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBzdWJzY3JpYmUgdG8gb25jZVxyXG4gICAgICAgICAqIEBwYXJhbSBoYW5kbGVyICAgVGhlIGhhbmRsZXIgb2YgdGhlIGV2ZW50IHRoYXQgd2lsbCBiZSBhdXRvIHVuc3Vic2NyaWJlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIG1ldGFIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXYgPSBldmVudCB8fCBuZXcgRXZlbnRzXzIuR2FtZUV2ZW50KCk7XHJcbiAgICAgICAgICAgICAgICBldi50YXJnZXQgPSBldi50YXJnZXQgfHwgX3RoaXMuX3RhcmdldDtcclxuICAgICAgICAgICAgICAgIF90aGlzLm9mZihldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlci5jYWxsKGV2LnRhcmdldCwgZXYpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLm9uKGV2ZW50TmFtZSwgbWV0YUhhbmRsZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2lyZXMgdGhpcyBldmVudCBkaXNwYXRjaGVyIHRvIGFsc28gcmVjaWV2ZSBldmVudHMgZnJvbSBhbm90aGVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS53aXJlID0gZnVuY3Rpb24gKGV2ZW50RGlzcGF0Y2hlcikge1xyXG4gICAgICAgICAgICBldmVudERpc3BhdGNoZXIuX3dpcmVkRXZlbnREaXNwYXRjaGVycy5wdXNoKHRoaXMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVW53aXJlcyB0aGlzIGV2ZW50IGRpc3BhdGNoZXIgZnJvbSBhbm90aGVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS51bndpcmUgPSBmdW5jdGlvbiAoZXZlbnREaXNwYXRjaGVyKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGV2ZW50RGlzcGF0Y2hlci5fd2lyZWRFdmVudERpc3BhdGNoZXJzLmluZGV4T2YodGhpcyk7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudERpc3BhdGNoZXIuX3dpcmVkRXZlbnREaXNwYXRjaGVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gRXZlbnREaXNwYXRjaGVyO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuRXZlbnREaXNwYXRjaGVyID0gRXZlbnREaXNwYXRjaGVyO1xyXG59KTtcclxuZGVmaW5lKFwiQWN0aW9ucy9BY3Rpb25Db250ZXh0XCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiQWN0aW9ucy9BY3Rpb25cIiwgXCJQcm9taXNlc1wiLCBcIlV0aWwvRWFzaW5nRnVuY3Rpb25zXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgQWN0aW9ucywgUHJvbWlzZXNfMiwgRWFzaW5nRnVuY3Rpb25zXzIpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZmx1ZW50IEFjdGlvbiBBUEkgYWxsb3dzIHlvdSB0byBwZXJmb3JtIFwiYWN0aW9uc1wiIG9uXHJcbiAgICAgKiBbW0FjdG9yfEFjdG9yc11dIHN1Y2ggYXMgZm9sbG93aW5nLCBtb3ZpbmcsIHJvdGF0aW5nLCBhbmRcclxuICAgICAqIG1vcmUuIFlvdSBjYW4gaW1wbGVtZW50IHlvdXIgb3duIGFjdGlvbnMgYnkgaW1wbGVtZW50aW5nXHJcbiAgICAgKiB0aGUgW1tJQWN0aW9uXV0gaW50ZXJmYWNlLlxyXG4gICAgICpcclxuICAgICAqIFtbaW5jbHVkZTpBY3Rpb25zLm1kXV1cclxuICAgICAqL1xyXG4gICAgdmFyIEFjdGlvbkNvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIEFjdGlvbkNvbnRleHQoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9ycyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLl9xdWV1ZXMgPSBbXTtcclxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3JzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlcyA9IHRoaXMuX2FjdG9ycy5tYXAoZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5hY3Rpb25RdWV1ZTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENsZWFycyBhbGwgcXVldWVkIGFjdGlvbnMgZnJvbSB0aGUgQWN0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3Rpb25Db250ZXh0LnByb3RvdHlwZS5jbGVhckFjdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gMCwgbGVuID0gdGhpcy5fcXVldWVzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlc1tpXS5jbGVhckFjdGlvbnMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgQWN0aW9uQ29udGV4dC5wcm90b3R5cGUuYWRkQWN0b3JUb0NvbnRleHQgPSBmdW5jdGlvbiAoYWN0b3IpIHtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3JzLnB1c2goYWN0b3IpO1xyXG4gICAgICAgICAgICAvLyBpZiB3ZSBydW4gaW50byBwcm9ibGVtcyByZXBsYWNlIHRoZSBsaW5lIGJlbG93IHdpdGg6XHJcbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlcy5wdXNoKGFjdG9yLmFjdGlvblF1ZXVlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEFjdGlvbkNvbnRleHQucHJvdG90eXBlLnJlbW92ZUFjdG9yRnJvbUNvbnRleHQgPSBmdW5jdGlvbiAoYWN0b3IpIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fYWN0b3JzLmluZGV4T2YoYWN0b3IpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3JzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZXMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCBtb3ZlIGFuIGFjdG9yIHRvIHRoZSBzcGVjaWZpZWQgYHhgIGFuZCBgeWAgcG9zaXRpb24gb3ZlciB0aGVcclxuICAgICAgICAgKiBzcGVjaWZpZWQgZHVyYXRpb24gdXNpbmcgYSBnaXZlbiBbW0Vhc2luZ0Z1bmN0aW9uc11dIGFuZCByZXR1cm4gYmFjayB0aGUgYWN0b3IuIFRoaXNcclxuICAgICAgICAgKiBtZXRob2QgaXMgcGFydCBvZiB0aGUgYWN0b3IgJ0FjdGlvbicgZmx1ZW50IEFQSSBhbGxvd2luZyBhY3Rpb24gY2hhaW5pbmcuXHJcbiAgICAgICAgICogQHBhcmFtIHggICAgICAgICBUaGUgeCBsb2NhdGlvbiB0byBtb3ZlIHRoZSBhY3RvciB0b1xyXG4gICAgICAgICAqIEBwYXJhbSB5ICAgICAgICAgVGhlIHkgbG9jYXRpb24gdG8gbW92ZSB0aGUgYWN0b3IgdG9cclxuICAgICAgICAgKiBAcGFyYW0gZHVyYXRpb24gIFRoZSB0aW1lIGl0IHNob3VsZCB0YWtlIHRoZSBhY3RvciB0byBtb3ZlIHRvIHRoZSBuZXcgbG9jYXRpb24gaW4gbWlsbGlzZWNvbmRzXHJcbiAgICAgICAgICogQHBhcmFtIGVhc2luZ0ZjbiBVc2UgW1tFYXNpbmdGdW5jdGlvbnNdXSBvciBhIGN1c3RvbSBmdW5jdGlvbiB0byB1c2UgdG8gY2FsY3VsYXRlIHBvc2l0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0aW9uQ29udGV4dC5wcm90b3R5cGUuZWFzZVRvID0gZnVuY3Rpb24gKHgsIHksIGR1cmF0aW9uLCBlYXNpbmdGY24pIHtcclxuICAgICAgICAgICAgaWYgKGVhc2luZ0ZjbiA9PT0gdm9pZCAwKSB7IGVhc2luZ0ZjbiA9IEVhc2luZ0Z1bmN0aW9uc18yLkVhc2luZ0Z1bmN0aW9ucy5MaW5lYXI7IH1cclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9xdWV1ZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWVzW2ldLmFkZChuZXcgQWN0aW9ucy5FYXNlVG8odGhpcy5fYWN0b3JzW2ldLCB4LCB5LCBkdXJhdGlvbiwgZWFzaW5nRmNuKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIG1vdmUgYW4gYWN0b3IgdG8gdGhlIHNwZWNpZmllZCB4IGFuZCB5IHBvc2l0aW9uIGF0IHRoZVxyXG4gICAgICAgICAqIHNwZWVkIHNwZWNpZmllZCAoaW4gcGl4ZWxzIHBlciBzZWNvbmQpIGFuZCByZXR1cm4gYmFjayB0aGUgYWN0b3IuIFRoaXNcclxuICAgICAgICAgKiBtZXRob2QgaXMgcGFydCBvZiB0aGUgYWN0b3IgJ0FjdGlvbicgZmx1ZW50IEFQSSBhbGxvd2luZyBhY3Rpb24gY2hhaW5pbmcuXHJcbiAgICAgICAgICogQHBhcmFtIHggICAgICBUaGUgeCBsb2NhdGlvbiB0byBtb3ZlIHRoZSBhY3RvciB0b1xyXG4gICAgICAgICAqIEBwYXJhbSB5ICAgICAgVGhlIHkgbG9jYXRpb24gdG8gbW92ZSB0aGUgYWN0b3IgdG9cclxuICAgICAgICAgKiBAcGFyYW0gc3BlZWQgIFRoZSBzcGVlZCBpbiBwaXhlbHMgcGVyIHNlY29uZCB0byBtb3ZlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0aW9uQ29udGV4dC5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24gKHgsIHksIHNwZWVkKSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gMCwgbGVuID0gdGhpcy5fcXVldWVzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlc1tpXS5hZGQobmV3IEFjdGlvbnMuTW92ZVRvKHRoaXMuX2FjdG9yc1tpXSwgeCwgeSwgc3BlZWQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgbW92ZSBhbiBhY3RvciB0byB0aGUgc3BlY2lmaWVkIHggYW5kIHkgcG9zaXRpb24gYnkgYVxyXG4gICAgICAgICAqIGNlcnRhaW4gdGltZSAoaW4gbWlsbGlzZWNvbmRzKS4gVGhpcyBtZXRob2QgaXMgcGFydCBvZiB0aGUgYWN0b3JcclxuICAgICAgICAgKiAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZy5cclxuICAgICAgICAgKiBAcGFyYW0geCAgICAgVGhlIHggbG9jYXRpb24gdG8gbW92ZSB0aGUgYWN0b3IgdG9cclxuICAgICAgICAgKiBAcGFyYW0geSAgICAgVGhlIHkgbG9jYXRpb24gdG8gbW92ZSB0aGUgYWN0b3IgdG9cclxuICAgICAgICAgKiBAcGFyYW0gdGltZSAgVGhlIHRpbWUgaXQgc2hvdWxkIHRha2UgdGhlIGFjdG9yIHRvIG1vdmUgdG8gdGhlIG5ldyBsb2NhdGlvbiBpbiBtaWxsaXNlY29uZHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3Rpb25Db250ZXh0LnByb3RvdHlwZS5tb3ZlQnkgPSBmdW5jdGlvbiAoeCwgeSwgdGltZSkge1xyXG4gICAgICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3F1ZXVlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZXNbaV0uYWRkKG5ldyBBY3Rpb25zLk1vdmVCeSh0aGlzLl9hY3RvcnNbaV0sIHgsIHksIHRpbWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgcm90YXRlIGFuIGFjdG9yIHRvIHRoZSBzcGVjaWZpZWQgYW5nbGUgYXQgdGhlIHNwZWVkXHJcbiAgICAgICAgICogc3BlY2lmaWVkIChpbiByYWRpYW5zIHBlciBzZWNvbmQpIGFuZCByZXR1cm4gYmFjayB0aGUgYWN0b3IuIFRoaXNcclxuICAgICAgICAgKiBtZXRob2QgaXMgcGFydCBvZiB0aGUgYWN0b3IgJ0FjdGlvbicgZmx1ZW50IEFQSSBhbGxvd2luZyBhY3Rpb24gY2hhaW5pbmcuXHJcbiAgICAgICAgICogQHBhcmFtIGFuZ2xlUmFkaWFucyAgVGhlIGFuZ2xlIHRvIHJvdGF0ZSB0byBpbiByYWRpYW5zXHJcbiAgICAgICAgICogQHBhcmFtIHNwZWVkICAgICAgICAgVGhlIGFuZ3VsYXIgdmVsb2NpdHkgb2YgdGhlIHJvdGF0aW9uIHNwZWNpZmllZCBpbiByYWRpYW5zIHBlciBzZWNvbmRcclxuICAgICAgICAgKiBAcGFyYW0gcm90YXRpb25UeXBlICBUaGUgW1tSb3RhdGlvblR5cGVdXSB0byB1c2UgZm9yIHRoaXMgcm90YXRpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3Rpb25Db250ZXh0LnByb3RvdHlwZS5yb3RhdGVUbyA9IGZ1bmN0aW9uIChhbmdsZVJhZGlhbnMsIHNwZWVkLCByb3RhdGlvblR5cGUpIHtcclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9xdWV1ZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWVzW2ldLmFkZChuZXcgQWN0aW9ucy5Sb3RhdGVUbyh0aGlzLl9hY3RvcnNbaV0sIGFuZ2xlUmFkaWFucywgc3BlZWQsIHJvdGF0aW9uVHlwZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCByb3RhdGUgYW4gYWN0b3IgdG8gdGhlIHNwZWNpZmllZCBhbmdsZSBieSBhIGNlcnRhaW5cclxuICAgICAgICAgKiB0aW1lIChpbiBtaWxsaXNlY29uZHMpIGFuZCByZXR1cm4gYmFjayB0aGUgYWN0b3IuIFRoaXMgbWV0aG9kIGlzIHBhcnRcclxuICAgICAgICAgKiBvZiB0aGUgYWN0b3IgJ0FjdGlvbicgZmx1ZW50IEFQSSBhbGxvd2luZyBhY3Rpb24gY2hhaW5pbmcuXHJcbiAgICAgICAgICogQHBhcmFtIGFuZ2xlUmFkaWFucyAgVGhlIGFuZ2xlIHRvIHJvdGF0ZSB0byBpbiByYWRpYW5zXHJcbiAgICAgICAgICogQHBhcmFtIHRpbWUgICAgICAgICAgVGhlIHRpbWUgaXQgc2hvdWxkIHRha2UgdGhlIGFjdG9yIHRvIGNvbXBsZXRlIHRoZSByb3RhdGlvbiBpbiBtaWxsaXNlY29uZHNcclxuICAgICAgICAgKiBAcGFyYW0gcm90YXRpb25UeXBlICBUaGUgW1tSb3RhdGlvblR5cGVdXSB0byB1c2UgZm9yIHRoaXMgcm90YXRpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3Rpb25Db250ZXh0LnByb3RvdHlwZS5yb3RhdGVCeSA9IGZ1bmN0aW9uIChhbmdsZVJhZGlhbnMsIHRpbWUsIHJvdGF0aW9uVHlwZSkge1xyXG4gICAgICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3F1ZXVlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZXNbaV0uYWRkKG5ldyBBY3Rpb25zLlJvdGF0ZUJ5KHRoaXMuX2FjdG9yc1tpXSwgYW5nbGVSYWRpYW5zLCB0aW1lLCByb3RhdGlvblR5cGUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgc2NhbGUgYW4gYWN0b3IgdG8gdGhlIHNwZWNpZmllZCBzaXplIGF0IHRoZSBzcGVlZFxyXG4gICAgICAgICAqIHNwZWNpZmllZCAoaW4gbWFnbml0dWRlIGluY3JlYXNlIHBlciBzZWNvbmQpIGFuZCByZXR1cm4gYmFjayB0aGVcclxuICAgICAgICAgKiBhY3Rvci4gVGhpcyBtZXRob2QgaXMgcGFydCBvZiB0aGUgYWN0b3IgJ0FjdGlvbicgZmx1ZW50IEFQSSBhbGxvd2luZ1xyXG4gICAgICAgICAqIGFjdGlvbiBjaGFpbmluZy5cclxuICAgICAgICAgKiBAcGFyYW0gc2l6ZVggICBUaGUgc2NhbGluZyBmYWN0b3IgdG8gYXBwbHkgb24gWCBheGlzXHJcbiAgICAgICAgICogQHBhcmFtIHNpemVZICAgVGhlIHNjYWxpbmcgZmFjdG9yIHRvIGFwcGx5IG9uIFkgYXhpc1xyXG4gICAgICAgICAqIEBwYXJhbSBzcGVlZFggIFRoZSBzcGVlZCBvZiBzY2FsaW5nIHNwZWNpZmllZCBpbiBtYWduaXR1ZGUgaW5jcmVhc2UgcGVyIHNlY29uZCBvbiBYIGF4aXNcclxuICAgICAgICAgKiBAcGFyYW0gc3BlZWRZICBUaGUgc3BlZWQgb2Ygc2NhbGluZyBzcGVjaWZpZWQgaW4gbWFnbml0dWRlIGluY3JlYXNlIHBlciBzZWNvbmQgb24gWSBheGlzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0aW9uQ29udGV4dC5wcm90b3R5cGUuc2NhbGVUbyA9IGZ1bmN0aW9uIChzaXplWCwgc2l6ZVksIHNwZWVkWCwgc3BlZWRZKSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gMCwgbGVuID0gdGhpcy5fcXVldWVzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlc1tpXS5hZGQobmV3IEFjdGlvbnMuU2NhbGVUbyh0aGlzLl9hY3RvcnNbaV0sIHNpemVYLCBzaXplWSwgc3BlZWRYLCBzcGVlZFkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgc2NhbGUgYW4gYWN0b3IgdG8gdGhlIHNwZWNpZmllZCBzaXplIGJ5IGEgY2VydGFpbiB0aW1lXHJcbiAgICAgICAgICogKGluIG1pbGxpc2Vjb25kcykgYW5kIHJldHVybiBiYWNrIHRoZSBhY3Rvci4gVGhpcyBtZXRob2QgaXMgcGFydCBvZiB0aGVcclxuICAgICAgICAgKiBhY3RvciAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZy5cclxuICAgICAgICAgKiBAcGFyYW0gc2l6ZVggICBUaGUgc2NhbGluZyBmYWN0b3IgdG8gYXBwbHkgb24gWCBheGlzXHJcbiAgICAgICAgICogQHBhcmFtIHNpemVZICAgVGhlIHNjYWxpbmcgZmFjdG9yIHRvIGFwcGx5IG9uIFkgYXhpc1xyXG4gICAgICAgICAqIEBwYXJhbSB0aW1lICAgIFRoZSB0aW1lIGl0IHNob3VsZCB0YWtlIHRvIGNvbXBsZXRlIHRoZSBzY2FsaW5nIGluIG1pbGxpc2Vjb25kc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdGlvbkNvbnRleHQucHJvdG90eXBlLnNjYWxlQnkgPSBmdW5jdGlvbiAoc2l6ZVgsIHNpemVZLCB0aW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gMCwgbGVuID0gdGhpcy5fcXVldWVzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlc1tpXS5hZGQobmV3IEFjdGlvbnMuU2NhbGVCeSh0aGlzLl9hY3RvcnNbaV0sIHNpemVYLCBzaXplWSwgdGltZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCBjYXVzZSBhbiBhY3RvciB0byBibGluayAoYmVjb21lIHZpc2libGUgYW5kIG5vdFxyXG4gICAgICAgICAqIHZpc2libGUpLiBPcHRpb25hbGx5LCB5b3UgbWF5IHNwZWNpZnkgdGhlIG51bWJlciBvZiBibGlua3MuIFNwZWNpZnkgdGhlIGFtb3VudCBvZiB0aW1lXHJcbiAgICAgICAgICogdGhlIGFjdG9yIHNob3VsZCBiZSB2aXNpYmxlIHBlciBibGluaywgYW5kIHRoZSBhbW91bnQgb2YgdGltZSBub3QgdmlzaWJsZS5cclxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBpcyBwYXJ0IG9mIHRoZSBhY3RvciAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZy5cclxuICAgICAgICAgKiBAcGFyYW0gdGltZVZpc2libGUgICAgIFRoZSBhbW91bnQgb2YgdGltZSB0byBzdGF5IHZpc2libGUgcGVyIGJsaW5rIGluIG1pbGxpc2Vjb25kc1xyXG4gICAgICAgICAqIEBwYXJhbSB0aW1lTm90VmlzaWJsZSAgVGhlIGFtb3VudCBvZiB0aW1lIHRvIHN0YXkgbm90IHZpc2libGUgcGVyIGJsaW5rIGluIG1pbGxpc2Vjb25kc1xyXG4gICAgICAgICAqIEBwYXJhbSBudW1CbGlua3MgICAgICAgVGhlIG51bWJlciBvZiB0aW1lcyB0byBibGlua1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdGlvbkNvbnRleHQucHJvdG90eXBlLmJsaW5rID0gZnVuY3Rpb24gKHRpbWVWaXNpYmxlLCB0aW1lTm90VmlzaWJsZSwgbnVtQmxpbmtzKSB7XHJcbiAgICAgICAgICAgIGlmIChudW1CbGlua3MgPT09IHZvaWQgMCkgeyBudW1CbGlua3MgPSAxOyB9XHJcbiAgICAgICAgICAgIHZhciBpID0gMCwgbGVuID0gdGhpcy5fcXVldWVzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlc1tpXS5hZGQobmV3IEFjdGlvbnMuQmxpbmsodGhpcy5fYWN0b3JzW2ldLCB0aW1lVmlzaWJsZSwgdGltZU5vdFZpc2libGUsIG51bUJsaW5rcykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCBjYXVzZSBhbiBhY3RvcidzIG9wYWNpdHkgdG8gY2hhbmdlIGZyb20gaXRzIGN1cnJlbnQgdmFsdWVcclxuICAgICAgICAgKiB0byB0aGUgcHJvdmlkZWQgdmFsdWUgYnkgYSBzcGVjaWZpZWQgdGltZSAoaW4gbWlsbGlzZWNvbmRzKS4gVGhpcyBtZXRob2QgaXNcclxuICAgICAgICAgKiBwYXJ0IG9mIHRoZSBhY3RvciAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZy5cclxuICAgICAgICAgKiBAcGFyYW0gb3BhY2l0eSAgVGhlIGVuZGluZyBvcGFjaXR5XHJcbiAgICAgICAgICogQHBhcmFtIHRpbWUgICAgIFRoZSB0aW1lIGl0IHNob3VsZCB0YWtlIHRvIGZhZGUgdGhlIGFjdG9yIChpbiBtaWxsaXNlY29uZHMpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0aW9uQ29udGV4dC5wcm90b3R5cGUuZmFkZSA9IGZ1bmN0aW9uIChvcGFjaXR5LCB0aW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gMCwgbGVuID0gdGhpcy5fcXVldWVzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlc1tpXS5hZGQobmV3IEFjdGlvbnMuRmFkZSh0aGlzLl9hY3RvcnNbaV0sIG9wYWNpdHksIHRpbWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgZGVsYXkgdGhlIG5leHQgYWN0aW9uIGZyb20gZXhlY3V0aW5nIGZvciBhIGNlcnRhaW5cclxuICAgICAgICAgKiBhbW91bnQgb2YgdGltZSAoaW4gbWlsbGlzZWNvbmRzKS4gVGhpcyBtZXRob2QgaXMgcGFydCBvZiB0aGUgYWN0b3JcclxuICAgICAgICAgKiAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZy5cclxuICAgICAgICAgKiBAcGFyYW0gdGltZSAgVGhlIGFtb3VudCBvZiB0aW1lIHRvIGRlbGF5IHRoZSBuZXh0IGFjdGlvbiBpbiB0aGUgcXVldWUgZnJvbSBleGVjdXRpbmcgaW4gbWlsbGlzZWNvbmRzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0aW9uQ29udGV4dC5wcm90b3R5cGUuZGVsYXkgPSBmdW5jdGlvbiAodGltZSkge1xyXG4gICAgICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3F1ZXVlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZXNbaV0uYWRkKG5ldyBBY3Rpb25zLkRlbGF5KHRoaXMuX2FjdG9yc1tpXSwgdGltZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCBhZGQgYW4gYWN0aW9uIHRvIHRoZSBxdWV1ZSB0aGF0IHdpbGwgcmVtb3ZlIHRoZSBhY3RvciBmcm9tIHRoZVxyXG4gICAgICAgICAqIHNjZW5lIG9uY2UgaXQgaGFzIGNvbXBsZXRlZCBpdHMgcHJldmlvdXMgYWN0aW9ucy4gQW55IGFjdGlvbnMgb24gdGhlXHJcbiAgICAgICAgICogYWN0aW9uIHF1ZXVlIGFmdGVyIHRoaXMgYWN0aW9uIHdpbGwgbm90IGJlIGV4ZWN1dGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdGlvbkNvbnRleHQucHJvdG90eXBlLmRpZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9xdWV1ZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWVzW2ldLmFkZChuZXcgQWN0aW9ucy5EaWUodGhpcy5fYWN0b3JzW2ldKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBhbGxvd3MgeW91IHRvIGNhbGwgYW4gYXJiaXRyYXJ5IG1ldGhvZCBhcyB0aGUgbmV4dCBhY3Rpb24gaW4gdGhlXHJcbiAgICAgICAgICogYWN0aW9uIHF1ZXVlLiBUaGlzIGlzIHVzZWZ1bCBpZiB5b3Ugd2FudCB0byBleGVjdXRlIGNvZGUgaW4gYWZ0ZXIgYSBzcGVjaWZpY1xyXG4gICAgICAgICAqIGFjdGlvbiwgaS5lIEFuIGFjdG9yIGFycml2ZXMgYXQgYSBkZXN0aW5hdGlvbiBhZnRlciB0cmF2ZXJzaW5nIGEgcGF0aFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdGlvbkNvbnRleHQucHJvdG90eXBlLmNhbGxNZXRob2QgPSBmdW5jdGlvbiAobWV0aG9kKSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gMCwgbGVuID0gdGhpcy5fcXVldWVzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlc1tpXS5hZGQobmV3IEFjdGlvbnMuQ2FsbE1ldGhvZCh0aGlzLl9hY3RvcnNbaV0sIG1ldGhvZCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCBjYXVzZSB0aGUgYWN0b3IgdG8gcmVwZWF0IGFsbCBvZiB0aGUgcHJldmlvdXNseVxyXG4gICAgICAgICAqIGNhbGxlZCBhY3Rpb25zIGEgY2VydGFpbiBudW1iZXIgb2YgdGltZXMuIElmIHRoZSBudW1iZXIgb2YgcmVwZWF0c1xyXG4gICAgICAgICAqIGlzIG5vdCBzcGVjaWZpZWQgaXQgd2lsbCByZXBlYXQgZm9yZXZlci4gVGhpcyBtZXRob2QgaXMgcGFydCBvZlxyXG4gICAgICAgICAqIHRoZSBhY3RvciAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZ1xyXG4gICAgICAgICAqIEBwYXJhbSB0aW1lcyAgVGhlIG51bWJlciBvZiB0aW1lcyB0byByZXBlYXQgYWxsIHRoZSBwcmV2aW91cyBhY3Rpb25zIGluIHRoZSBhY3Rpb24gcXVldWUuIElmIG5vdGhpbmcgaXMgc3BlY2lmaWVkIHRoZSBhY3Rpb25zXHJcbiAgICAgICAgICogd2lsbCByZXBlYXQgZm9yZXZlclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdGlvbkNvbnRleHQucHJvdG90eXBlLnJlcGVhdCA9IGZ1bmN0aW9uICh0aW1lcykge1xyXG4gICAgICAgICAgICBpZiAoIXRpbWVzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGVhdEZvcmV2ZXIoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpID0gMCwgbGVuID0gdGhpcy5fcXVldWVzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlc1tpXS5hZGQobmV3IEFjdGlvbnMuUmVwZWF0KHRoaXMuX2FjdG9yc1tpXSwgdGltZXMsIHRoaXMuX2FjdG9yc1tpXS5hY3Rpb25RdWV1ZS5nZXRBY3Rpb25zKCkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgY2F1c2UgdGhlIGFjdG9yIHRvIHJlcGVhdCBhbGwgb2YgdGhlIHByZXZpb3VzbHlcclxuICAgICAgICAgKiBjYWxsZWQgYWN0aW9ucyBmb3JldmVyLiBUaGlzIG1ldGhvZCBpcyBwYXJ0IG9mIHRoZSBhY3RvciAnQWN0aW9uJ1xyXG4gICAgICAgICAqIGZsdWVudCBBUEkgYWxsb3dpbmcgYWN0aW9uIGNoYWluaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdGlvbkNvbnRleHQucHJvdG90eXBlLnJlcGVhdEZvcmV2ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gMCwgbGVuID0gdGhpcy5fcXVldWVzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlc1tpXS5hZGQobmV3IEFjdGlvbnMuUmVwZWF0Rm9yZXZlcih0aGlzLl9hY3RvcnNbaV0sIHRoaXMuX2FjdG9yc1tpXS5hY3Rpb25RdWV1ZS5nZXRBY3Rpb25zKCkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgY2F1c2UgdGhlIGFjdG9yIHRvIGZvbGxvdyBhbm90aGVyIGF0IGEgc3BlY2lmaWVkIGRpc3RhbmNlXHJcbiAgICAgICAgICogQHBhcmFtIGFjdG9yICAgICAgICAgICBUaGUgYWN0b3IgdG8gZm9sbG93XHJcbiAgICAgICAgICogQHBhcmFtIGZvbGxvd0Rpc3RhbmNlICBUaGUgZGlzdGFuY2UgdG8gbWFpbnRhaW4gd2hlbiBmb2xsb3dpbmcsIGlmIG5vdCBzcGVjaWZpZWQgdGhlIGFjdG9yIHdpbGwgZm9sbG93IGF0IHRoZSBjdXJyZW50IGRpc3RhbmNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdGlvbkNvbnRleHQucHJvdG90eXBlLmZvbGxvdyA9IGZ1bmN0aW9uIChhY3RvciwgZm9sbG93RGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9xdWV1ZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGZvbGxvd0Rpc3RhbmNlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZXNbaV0uYWRkKG5ldyBBY3Rpb25zLkZvbGxvdyh0aGlzLl9hY3RvcnNbaV0sIGFjdG9yKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZXNbaV0uYWRkKG5ldyBBY3Rpb25zLkZvbGxvdyh0aGlzLl9hY3RvcnNbaV0sIGFjdG9yLCBmb2xsb3dEaXN0YW5jZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCBjYXVzZSB0aGUgYWN0b3IgdG8gbW92ZSB0b3dhcmRzIGFub3RoZXIgdW50aWwgdGhleVxyXG4gICAgICAgICAqIGNvbGxpZGUgXCJtZWV0XCIgYXQgYSBzcGVjaWZpZWQgc3BlZWQuXHJcbiAgICAgICAgICogQHBhcmFtIGFjdG9yICBUaGUgYWN0b3IgdG8gbWVldFxyXG4gICAgICAgICAqIEBwYXJhbSBzcGVlZCAgVGhlIHNwZWVkIGluIHBpeGVscyBwZXIgc2Vjb25kIHRvIG1vdmUsIGlmIG5vdCBzcGVjaWZpZWQgaXQgd2lsbCBtYXRjaCB0aGUgc3BlZWQgb2YgdGhlIG90aGVyIGFjdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0aW9uQ29udGV4dC5wcm90b3R5cGUubWVldCA9IGZ1bmN0aW9uIChhY3Rvciwgc3BlZWQpIHtcclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9xdWV1ZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNwZWVkID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZXNbaV0uYWRkKG5ldyBBY3Rpb25zLk1lZXQodGhpcy5fYWN0b3JzW2ldLCBhY3RvcikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcXVldWVzW2ldLmFkZChuZXcgQWN0aW9ucy5NZWV0KHRoaXMuX2FjdG9yc1tpXSwgYWN0b3IsIHNwZWVkKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGN1cnJlbnQgYWN0aW9uIHF1ZXVlIHVwIHRvIG5vd1xyXG4gICAgICAgICAqIGlzIGZpbmlzaGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdGlvbkNvbnRleHQucHJvdG90eXBlLmFzUHJvbWlzZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIHByb21pc2VzID0gdGhpcy5fcXVldWVzLm1hcChmdW5jdGlvbiAocSwgaSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRlbXAgPSBuZXcgUHJvbWlzZXNfMi5Qcm9taXNlKCk7XHJcbiAgICAgICAgICAgICAgICBxLmFkZChuZXcgQWN0aW9ucy5DYWxsTWV0aG9kKF90aGlzLl9hY3RvcnNbaV0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0ZW1wO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2VzXzIuUHJvbWlzZS5qb2luLmFwcGx5KHRoaXMsIHByb21pc2VzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBBY3Rpb25Db250ZXh0O1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuQWN0aW9uQ29udGV4dCA9IEFjdGlvbkNvbnRleHQ7XHJcbn0pO1xyXG5kZWZpbmUoXCJVdGlsL0xvZ1wiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBMb2dnaW5nIGxldmVsIHRoYXQgRXhjYWxpYnVyIHdpbGwgdGFnXHJcbiAgICAgKi9cclxuICAgIHZhciBMb2dMZXZlbDtcclxuICAgIChmdW5jdGlvbiAoTG9nTGV2ZWwpIHtcclxuICAgICAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkRlYnVnXCJdID0gMF0gPSBcIkRlYnVnXCI7XHJcbiAgICAgICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJJbmZvXCJdID0gMV0gPSBcIkluZm9cIjtcclxuICAgICAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIldhcm5cIl0gPSAyXSA9IFwiV2FyblwiO1xyXG4gICAgICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiRXJyb3JcIl0gPSAzXSA9IFwiRXJyb3JcIjtcclxuICAgICAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkZhdGFsXCJdID0gNF0gPSBcIkZhdGFsXCI7XHJcbiAgICB9KShMb2dMZXZlbCA9IGV4cG9ydHMuTG9nTGV2ZWwgfHwgKGV4cG9ydHMuTG9nTGV2ZWwgPSB7fSkpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdGF0aWMgc2luZ2xldG9uIHRoYXQgcmVwcmVzZW50cyB0aGUgbG9nZ2luZyBmYWNpbGl0eSBmb3IgRXhjYWxpYnVyLlxyXG4gICAgICogRXhjYWxpYnVyIGNvbWVzIGJ1aWx0LWluIHdpdGggYSBbW0NvbnNvbGVBcHBlbmRlcl1dIGFuZCBbW1NjcmVlbkFwcGVuZGVyXV0uXHJcbiAgICAgKiBEZXJpdmUgZnJvbSBbW0lBcHBlbmRlcl1dIHRvIGNyZWF0ZSB5b3VyIG93biBsb2dnaW5nIGFwcGVuZGVycy5cclxuICAgICAqXHJcbiAgICAgKiBbW2luY2x1ZGU6TG9nZ2VyLm1kXV1cclxuICAgICAqL1xyXG4gICAgdmFyIExvZ2dlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gTG9nZ2VyKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9hcHBlbmRlcnMgPSBbXTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgZGVmYXVsdCBsb2dnaW5nIGxldmVsLiBFeGNhbGlidXIgd2lsbCBvbmx5IGxvZ1xyXG4gICAgICAgICAgICAgKiBtZXNzYWdlcyBpZiBlcXVhbCB0byBvciBhYm92ZSB0aGlzIGxldmVsLiBEZWZhdWx0OiBbW0xvZ0xldmVsLkluZm9dXVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5kZWZhdWx0TGV2ZWwgPSBMb2dMZXZlbC5JbmZvO1xyXG4gICAgICAgICAgICBpZiAoTG9nZ2VyLl9pbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMb2dnZXIgaXMgYSBzaW5nbGV0b24nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBMb2dnZXIuX2luc3RhbmNlID0gdGhpcztcclxuICAgICAgICAgICAgLy8gRGVmYXVsdCBjb25zb2xlIGFwcGVuZGVyXHJcbiAgICAgICAgICAgIExvZ2dlci5faW5zdGFuY2UuYWRkQXBwZW5kZXIobmV3IENvbnNvbGVBcHBlbmRlcigpKTtcclxuICAgICAgICAgICAgcmV0dXJuIExvZ2dlci5faW5zdGFuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGN1cnJlbnQgc3RhdGljIGluc3RhbmNlIG9mIExvZ2dlclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKExvZ2dlci5faW5zdGFuY2UgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgTG9nZ2VyLl9pbnN0YW5jZSA9IG5ldyBMb2dnZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gTG9nZ2VyLl9pbnN0YW5jZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYSBuZXcgW1tJQXBwZW5kZXJdXSB0byB0aGUgbGlzdCBvZiBhcHBlbmRlcnMgdG8gd3JpdGUgdG9cclxuICAgICAgICAgKi9cclxuICAgICAgICBMb2dnZXIucHJvdG90eXBlLmFkZEFwcGVuZGVyID0gZnVuY3Rpb24gKGFwcGVuZGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FwcGVuZGVycy5wdXNoKGFwcGVuZGVyKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENsZWFycyBhbGwgYXBwZW5kZXJzIGZyb20gdGhlIGxvZ2dlclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExvZ2dlci5wcm90b3R5cGUuY2xlYXJBcHBlbmRlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FwcGVuZGVycy5sZW5ndGggPSAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTG9ncyBhIG1lc3NhZ2UgYXQgYSBnaXZlbiBMb2dMZXZlbFxyXG4gICAgICAgICAqIEBwYXJhbSBsZXZlbCAgVGhlIExvZ0xldmVsYHRvIGxvZyB0aGUgbWVzc2FnZSBhdFxyXG4gICAgICAgICAqIEBwYXJhbSBhcmdzICAgQW4gYXJyYXkgb2YgYXJndW1lbnRzIHRvIHdyaXRlIHRvIGFuIGFwcGVuZGVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTG9nZ2VyLnByb3RvdHlwZS5fbG9nID0gZnVuY3Rpb24gKGxldmVsLCBhcmdzKSB7XHJcbiAgICAgICAgICAgIGlmIChsZXZlbCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBsZXZlbCA9IHRoaXMuZGVmYXVsdExldmVsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpID0gMCwgbGVuID0gdGhpcy5fYXBwZW5kZXJzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChsZXZlbCA+PSB0aGlzLmRlZmF1bHRMZXZlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FwcGVuZGVyc1tpXS5sb2cobGV2ZWwsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXcml0ZXMgYSBsb2cgbWVzc2FnZSBhdCB0aGUgW1tMb2dMZXZlbC5EZWJ1Z11dIGxldmVsXHJcbiAgICAgICAgICogQHBhcmFtIGFyZ3MgIEFjY2VwdHMgYW55IG51bWJlciBvZiBhcmd1bWVudHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBMb2dnZXIucHJvdG90eXBlLmRlYnVnID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZyhMb2dMZXZlbC5EZWJ1ZywgYXJncyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXcml0ZXMgYSBsb2cgbWVzc2FnZSBhdCB0aGUgW1tMb2dMZXZlbC5JbmZvXV0gbGV2ZWxcclxuICAgICAgICAgKiBAcGFyYW0gYXJncyAgQWNjZXB0cyBhbnkgbnVtYmVyIG9mIGFyZ3VtZW50c1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExvZ2dlci5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9sb2coTG9nTGV2ZWwuSW5mbywgYXJncyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXcml0ZXMgYSBsb2cgbWVzc2FnZSBhdCB0aGUgW1tMb2dMZXZlbC5XYXJuXV0gbGV2ZWxcclxuICAgICAgICAgKiBAcGFyYW0gYXJncyAgQWNjZXB0cyBhbnkgbnVtYmVyIG9mIGFyZ3VtZW50c1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExvZ2dlci5wcm90b3R5cGUud2FybiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9sb2coTG9nTGV2ZWwuV2FybiwgYXJncyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXcml0ZXMgYSBsb2cgbWVzc2FnZSBhdCB0aGUgW1tMb2dMZXZlbC5FcnJvcl1dIGxldmVsXHJcbiAgICAgICAgICogQHBhcmFtIGFyZ3MgIEFjY2VwdHMgYW55IG51bWJlciBvZiBhcmd1bWVudHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBMb2dnZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZyhMb2dMZXZlbC5FcnJvciwgYXJncyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXcml0ZXMgYSBsb2cgbWVzc2FnZSBhdCB0aGUgW1tMb2dMZXZlbC5GYXRhbF1dIGxldmVsXHJcbiAgICAgICAgICogQHBhcmFtIGFyZ3MgIEFjY2VwdHMgYW55IG51bWJlciBvZiBhcmd1bWVudHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBMb2dnZXIucHJvdG90eXBlLmZhdGFsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZyhMb2dMZXZlbC5GYXRhbCwgYXJncyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gTG9nZ2VyO1xyXG4gICAgfSgpKTtcclxuICAgIExvZ2dlci5faW5zdGFuY2UgPSBudWxsO1xyXG4gICAgZXhwb3J0cy5Mb2dnZXIgPSBMb2dnZXI7XHJcbiAgICAvKipcclxuICAgICAqIENvbnNvbGUgYXBwZW5kZXIgZm9yIGJyb3dzZXJzIChpLmUuIGBjb25zb2xlLmxvZ2ApXHJcbiAgICAgKi9cclxuICAgIHZhciBDb25zb2xlQXBwZW5kZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIENvbnNvbGVBcHBlbmRlcigpIHtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTG9ncyBhIG1lc3NhZ2UgYXQgdGhlIGdpdmVuIFtbTG9nTGV2ZWxdXVxyXG4gICAgICAgICAqIEBwYXJhbSBsZXZlbCAgTGV2ZWwgdG8gbG9nIGF0XHJcbiAgICAgICAgICogQHBhcmFtIGFyZ3MgICBBcmd1bWVudHMgdG8gbG9nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29uc29sZUFwcGVuZGVyLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAobGV2ZWwsIGFyZ3MpIHtcclxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGNvbnNvbGUgc3VwcG9ydFxyXG4gICAgICAgICAgICBpZiAoIWNvbnNvbGUgJiYgIWNvbnNvbGUubG9nICYmIGNvbnNvbGUud2FybiAmJiBjb25zb2xlLmVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0b2RvIG1heWJlIGRvIHNvbWV0aGluZyBiZXR0ZXIgdGhhbiBub3RoaW5nXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGNvbnNvbGUgYXJncyBhcnJheVxyXG4gICAgICAgICAgICB2YXIgY29uc29sZUFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgY29uc29sZUFyZ3MudW5zaGlmdC5hcHBseShjb25zb2xlQXJncywgYXJncyk7XHJcbiAgICAgICAgICAgIGNvbnNvbGVBcmdzLnVuc2hpZnQoJ1snICsgTG9nTGV2ZWxbbGV2ZWxdICsgJ10gOiAnKTtcclxuICAgICAgICAgICAgaWYgKGxldmVsIDwgTG9nTGV2ZWwuV2Fybikge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2FsbCAubG9nIGZvciBEZWJ1Zy9JbmZvXHJcbiAgICAgICAgICAgICAgICBpZiAoY29uc29sZS5sb2cuYXBwbHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIHJlcXVpcmVkIG9uIHNvbWUgb2xkZXIgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IGFwcGx5IG9uIGNvbnNvbGUubG9nIDooXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgY29uc29sZUFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coY29uc29sZUFyZ3Muam9pbignICcpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChsZXZlbCA8IExvZ0xldmVsLkVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDYWxsIC53YXJuIGZvciBXYXJuXHJcbiAgICAgICAgICAgICAgICBpZiAoY29uc29sZS53YXJuLmFwcGx5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIGNvbnNvbGVBcmdzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybihjb25zb2xlQXJncy5qb2luKCcgJykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2FsbCAuZXJyb3IgZm9yIEVycm9yL0ZhdGFsXHJcbiAgICAgICAgICAgICAgICBpZiAoY29uc29sZS5lcnJvci5hcHBseSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IuYXBwbHkoY29uc29sZSwgY29uc29sZUFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihjb25zb2xlQXJncy5qb2luKCcgJykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gQ29uc29sZUFwcGVuZGVyO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuQ29uc29sZUFwcGVuZGVyID0gQ29uc29sZUFwcGVuZGVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBPbi1zY3JlZW4gKGNhbnZhcykgYXBwZW5kZXJcclxuICAgICAqL1xyXG4gICAgdmFyIFNjcmVlbkFwcGVuZGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gd2lkdGggICBXaWR0aCBvZiB0aGUgc2NyZWVuIGFwcGVuZGVyIGluIHBpeGVsc1xyXG4gICAgICAgICAqIEBwYXJhbSBoZWlnaHQgIEhlaWdodCBvZiB0aGUgc2NyZWVuIGFwcGVuZGVyIGluIHBpeGVsc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIFNjcmVlbkFwcGVuZGVyKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICAgICAgLy8gQHRvZG8gQ2xlYW4gdGhpcyB1cFxyXG4gICAgICAgICAgICB0aGlzLl9tZXNzYWdlcyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLl9jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICAgICAgdGhpcy5fY2FudmFzLndpZHRoID0gd2lkdGggfHwgd2luZG93LmlubmVyV2lkdGg7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5oZWlnaHQgPSBoZWlnaHQgfHwgd2luZG93LmlubmVySGVpZ2h0O1xyXG4gICAgICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgICAgICAgICB0aGlzLl9jdHggPSB0aGlzLl9jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLl9jYW52YXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMb2dzIGEgbWVzc2FnZSBhdCB0aGUgZ2l2ZW4gW1tMb2dMZXZlbF1dXHJcbiAgICAgICAgICogQHBhcmFtIGxldmVsICBMZXZlbCB0byBsb2cgYXRcclxuICAgICAgICAgKiBAcGFyYW0gYXJncyAgIEFyZ3VtZW50cyB0byBsb2dcclxuICAgICAgICAgKi9cclxuICAgICAgICBTY3JlZW5BcHBlbmRlci5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKGxldmVsLCBhcmdzKSB7XHJcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gYXJncy5qb2luKCcsJyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2N0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5fY2FudmFzLndpZHRoLCB0aGlzLl9jYW52YXMuaGVpZ2h0KTtcclxuICAgICAgICAgICAgdGhpcy5fbWVzc2FnZXMudW5zaGlmdCgnWycgKyBMb2dMZXZlbFtsZXZlbF0gKyAnXSA6ICcgKyBtZXNzYWdlKTtcclxuICAgICAgICAgICAgdmFyIHBvcyA9IDEwO1xyXG4gICAgICAgICAgICB2YXIgb3BhY2l0eSA9IDEuMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9tZXNzYWdlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3R4LmZpbGxTdHlsZSA9ICdyZ2JhKDI1NSwyNTUsMjU1LCcgKyBvcGFjaXR5LnRvRml4ZWQoMikgKyAnKSc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jdHguZmlsbFRleHQodGhpcy5fbWVzc2FnZXNbaV0sIDIwMCwgcG9zKTtcclxuICAgICAgICAgICAgICAgIHBvcyArPSAxMDtcclxuICAgICAgICAgICAgICAgIG9wYWNpdHkgPSBvcGFjaXR5ID4gMCA/IG9wYWNpdHkgLSAuMDUgOiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gU2NyZWVuQXBwZW5kZXI7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5TY3JlZW5BcHBlbmRlciA9IFNjcmVlbkFwcGVuZGVyO1xyXG59KTtcclxuZGVmaW5lKFwiQWN0aW9ucy9JQWN0aW9uYWJsZVwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG59KTtcclxuZGVmaW5lKFwiR3JvdXBcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJBbGdlYnJhXCIsIFwiQWN0aW9ucy9BY3Rpb25Db250ZXh0XCIsIFwiQWN0b3JcIiwgXCJVdGlsL0xvZ1wiLCBcIkNsYXNzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgQWxnZWJyYV8xMCwgQWN0aW9uQ29udGV4dF8xLCBBY3Rvcl8zLCBMb2dfMSwgQ2xhc3NfMSkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEdyb3VwcyBhcmUgdXNlZCBmb3IgbG9naWNhbGx5IGdyb3VwaW5nIEFjdG9ycyBzbyB0aGV5IGNhbiBiZSBhY3RlZCB1cG9uXHJcbiAgICAgKiBpbiBidWxrLlxyXG4gICAgICpcclxuICAgICAqIFtbaW5jbHVkZTpHcm91cHMubWRdXVxyXG4gICAgICovXHJcbiAgICB2YXIgR3JvdXAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhHcm91cCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBHcm91cChuYW1lLCBzY2VuZSkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICAgICAgX3RoaXMuc2NlbmUgPSBzY2VuZTtcclxuICAgICAgICAgICAgX3RoaXMuX2xvZ2dlciA9IExvZ18xLkxvZ2dlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgICAgICBfdGhpcy5fbWVtYmVycyA9IFtdO1xyXG4gICAgICAgICAgICBfdGhpcy5hY3Rpb25zID0gbmV3IEFjdGlvbkNvbnRleHRfMS5BY3Rpb25Db250ZXh0KCk7XHJcbiAgICAgICAgICAgIGlmIChzY2VuZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmVycm9yKCdJbnZhbGlkIGNvbnN0cnVjdG9yIGFyZ3VtZW50cyBwYXNzZWQgdG8gR3JvdXA6ICcsIG5hbWUsICcsIHNjZW5lIG11c3Qgbm90IGJlIG51bGwhJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXhpc3RpbmdHcm91cCA9IHNjZW5lLmdyb3Vwc1tuYW1lXTtcclxuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ0dyb3VwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci53YXJuKCdHcm91cCB3aXRoIG5hbWUnLCBuYW1lLCAnYWxyZWFkeSBleGlzdHMuIFRoaXMgbmV3IGdyb3VwIHdpbGwgcmVwbGFjZSBpdC4nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNjZW5lLmdyb3Vwc1tuYW1lXSA9IF90aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgR3JvdXAucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChhY3Rvck9yQWN0b3JzKSB7XHJcbiAgICAgICAgICAgIGlmIChhY3Rvck9yQWN0b3JzIGluc3RhbmNlb2YgQWN0b3JfMy5BY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgYWN0b3JPckFjdG9ycyA9IFtdLmNvbmNhdChhY3Rvck9yQWN0b3JzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IGFjdG9yT3JBY3RvcnMubGVuZ3RoLCBncm91cElkeDtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGdyb3VwSWR4ID0gdGhpcy5nZXRNZW1iZXJzKCkuaW5kZXhPZihhY3Rvck9yQWN0b3JzW2ldKTtcclxuICAgICAgICAgICAgICAgIGlmIChncm91cElkeCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZW1iZXJzLnB1c2goYWN0b3JPckFjdG9yc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2VuZS5hZGQoYWN0b3JPckFjdG9yc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25zLmFkZEFjdG9yVG9Db250ZXh0KGFjdG9yT3JBY3RvcnNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLndpcmUoYWN0b3JPckFjdG9yc1tpXS5ldmVudERpc3BhdGNoZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBHcm91cC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGFjdG9yKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX21lbWJlcnMuaW5kZXhPZihhY3Rvcik7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tZW1iZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGlvbnMucmVtb3ZlQWN0b3JGcm9tQ29udGV4dChhY3Rvcik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci51bndpcmUoYWN0b3IuZXZlbnREaXNwYXRjaGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgR3JvdXAucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbiAoYXJncykge1xyXG4gICAgICAgICAgICB2YXIgaSA9IDAsIG1lbWJlcnMgPSB0aGlzLmdldE1lbWJlcnMoKSwgbGVuID0gbWVtYmVycy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIGFyZ3MgaW5zdGFuY2VvZiBBbGdlYnJhXzEwLlZlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBtZW1iZXJzW2ldLnBvcy54ICs9IGFyZ3MueDtcclxuICAgICAgICAgICAgICAgICAgICBtZW1iZXJzW2ldLnBvcy55ICs9IGFyZ3MueTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHggPSBhcmd1bWVudHNbMF07XHJcbiAgICAgICAgICAgICAgICB2YXIgeSA9IGFyZ3VtZW50c1sxXTtcclxuICAgICAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVtYmVyc1tpXS5wb3MueCArPSB4O1xyXG4gICAgICAgICAgICAgICAgICAgIG1lbWJlcnNbaV0ucG9zLnkgKz0geTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcignSW52YWxpZCBhcmd1bWVudHMgcGFzc2VkIHRvIGdyb3VwIG1vdmUnLCB0aGlzLm5hbWUsICdhcmdzOicsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEdyb3VwLnByb3RvdHlwZS5yb3RhdGUgPSBmdW5jdGlvbiAoYW5nbGUpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBhbmdsZSAhPT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcignSW52YWxpZCBhcmd1bWVudHMgcGFzc2VkIHRvIGdyb3VwIHJvdGF0ZScsIHRoaXMubmFtZSwgJ2FyZ3M6JywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5nZXRNZW1iZXJzKCk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWVtYmVyID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgbWVtYmVyLnJvdGF0aW9uICs9IGFuZ2xlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBHcm91cC5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLm9uKGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBHcm91cC5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5vZmYoZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEdyb3VwLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKHRvcGljLCBldmVudCkge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5lbWl0KHRvcGljLCBldmVudCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBHcm91cC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAoYWN0b3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWVtYmVycygpLmluZGV4T2YoYWN0b3IpID4gLTE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBHcm91cC5wcm90b3R5cGUuZ2V0TWVtYmVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21lbWJlcnM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBHcm91cC5wcm90b3R5cGUuZ2V0UmFuZG9tTWVtYmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWVtYmVyc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB0aGlzLl9tZW1iZXJzLmxlbmd0aCldO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgR3JvdXAucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWVtYmVycygpLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gYS5nZXRCb3VuZHMoKTsgfSkucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldi5jb21iaW5lKGN1cnIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBHcm91cDtcclxuICAgIH0oQ2xhc3NfMS5DbGFzcykpO1xyXG4gICAgZXhwb3J0cy5Hcm91cCA9IEdyb3VwO1xyXG59KTtcclxuLyoqXHJcbiAqIFRoZXNlIGVmZmVjdHMgY2FuIGJlIGFwcGxpZWQgdG8gYW55IGJpdG1hcCBpbWFnZSBidXQgYXJlIG1haW5seSB1c2VkXHJcbiAqIGZvciBbW1Nwcml0ZV1dIGVmZmVjdHMgb3IgW1tBbmltYXRpb25dXSBlZmZlY3RzLlxyXG4gKlxyXG4gKiBbW2luY2x1ZGU6U3ByaXRlRWZmZWN0cy5tZF1dXHJcbiAqL1xyXG5kZWZpbmUoXCJEcmF3aW5nL1Nwcml0ZUVmZmVjdHNcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJEcmF3aW5nL0NvbG9yXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgQ29sb3JfOCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIFwiR3JheXNjYWxlXCIgZWZmZWN0IHRvIGEgc3ByaXRlLCByZW1vdmluZyBjb2xvciBpbmZvcm1hdGlvbi5cclxuICAgICAqL1xyXG4gICAgdmFyIEdyYXlzY2FsZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gR3JheXNjYWxlKCkge1xyXG4gICAgICAgIH1cclxuICAgICAgICBHcmF5c2NhbGUucHJvdG90eXBlLnVwZGF0ZVBpeGVsID0gZnVuY3Rpb24gKHgsIHksIGltYWdlRGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgZmlyc3RQaXhlbCA9ICh4ICsgeSAqIGltYWdlRGF0YS53aWR0aCkgKiA0O1xyXG4gICAgICAgICAgICB2YXIgcGl4ZWwgPSBpbWFnZURhdGEuZGF0YTtcclxuICAgICAgICAgICAgdmFyIGF2ZyA9IChwaXhlbFtmaXJzdFBpeGVsICsgMF0gKyBwaXhlbFtmaXJzdFBpeGVsICsgMV0gKyBwaXhlbFtmaXJzdFBpeGVsICsgMl0pIC8gMztcclxuICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDBdID0gYXZnO1xyXG4gICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMV0gPSBhdmc7XHJcbiAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAyXSA9IGF2ZztcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBHcmF5c2NhbGU7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5HcmF5c2NhbGUgPSBHcmF5c2NhbGU7XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIFwiSW52ZXJ0XCIgZWZmZWN0IHRvIGEgc3ByaXRlLCBpbnZlcnRpbmcgdGhlIHBpeGVsIGNvbG9ycy5cclxuICAgICAqL1xyXG4gICAgdmFyIEludmVydCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gSW52ZXJ0KCkge1xyXG4gICAgICAgIH1cclxuICAgICAgICBJbnZlcnQucHJvdG90eXBlLnVwZGF0ZVBpeGVsID0gZnVuY3Rpb24gKHgsIHksIGltYWdlRGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgZmlyc3RQaXhlbCA9ICh4ICsgeSAqIGltYWdlRGF0YS53aWR0aCkgKiA0O1xyXG4gICAgICAgICAgICB2YXIgcGl4ZWwgPSBpbWFnZURhdGEuZGF0YTtcclxuICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDBdID0gMjU1IC0gcGl4ZWxbZmlyc3RQaXhlbCArIDBdO1xyXG4gICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMV0gPSAyNTUgLSBwaXhlbFtmaXJzdFBpeGVsICsgMV07XHJcbiAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAyXSA9IDI1NSAtIHBpeGVsW2ZpcnN0UGl4ZWwgKyAyXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBJbnZlcnQ7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5JbnZlcnQgPSBJbnZlcnQ7XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIFwiT3BhY2l0eVwiIGVmZmVjdCB0byBhIHNwcml0ZSwgc2V0dGluZyB0aGUgYWxwaGEgb2YgYWxsIHBpeGVscyB0byBhIGdpdmVuIHZhbHVlLlxyXG4gICAgICovXHJcbiAgICB2YXIgT3BhY2l0eSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIG9wYWNpdHkgIFRoZSBuZXcgb3BhY2l0eSBvZiB0aGUgc3ByaXRlIGZyb20gMC0xLjBcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBPcGFjaXR5KG9wYWNpdHkpIHtcclxuICAgICAgICAgICAgdGhpcy5vcGFjaXR5ID0gb3BhY2l0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgT3BhY2l0eS5wcm90b3R5cGUudXBkYXRlUGl4ZWwgPSBmdW5jdGlvbiAoeCwgeSwgaW1hZ2VEYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciBmaXJzdFBpeGVsID0gKHggKyB5ICogaW1hZ2VEYXRhLndpZHRoKSAqIDQ7XHJcbiAgICAgICAgICAgIHZhciBwaXhlbCA9IGltYWdlRGF0YS5kYXRhO1xyXG4gICAgICAgICAgICBpZiAocGl4ZWxbZmlyc3RQaXhlbCArIDNdICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgM10gPSBNYXRoLnJvdW5kKHRoaXMub3BhY2l0eSAqIHBpeGVsW2ZpcnN0UGl4ZWwgKyAzXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBPcGFjaXR5O1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuT3BhY2l0eSA9IE9wYWNpdHk7XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIFwiQ29sb3JpemVcIiBlZmZlY3QgdG8gYSBzcHJpdGUsIGNoYW5naW5nIHRoZSBjb2xvciBjaGFubmVscyBvZiBhbGwgdGhlIHBpeGVscyB0byBhblxyXG4gICAgICogYXZlcmFnZSBvZiB0aGUgb3JpZ2luYWwgY29sb3IgYW5kIHRoZSBwcm92aWRlZCBjb2xvclxyXG4gICAgICovXHJcbiAgICB2YXIgQ29sb3JpemUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBjb2xvciAgVGhlIGNvbG9yIHRvIGFwcGx5IHRvIHRoZSBzcHJpdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBDb2xvcml6ZShjb2xvcikge1xyXG4gICAgICAgICAgICB0aGlzLmNvbG9yID0gY29sb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIENvbG9yaXplLnByb3RvdHlwZS51cGRhdGVQaXhlbCA9IGZ1bmN0aW9uICh4LCB5LCBpbWFnZURhdGEpIHtcclxuICAgICAgICAgICAgdmFyIGZpcnN0UGl4ZWwgPSAoeCArIHkgKiBpbWFnZURhdGEud2lkdGgpICogNDtcclxuICAgICAgICAgICAgdmFyIHBpeGVsID0gaW1hZ2VEYXRhLmRhdGE7XHJcbiAgICAgICAgICAgIGlmIChwaXhlbFtmaXJzdFBpeGVsICsgM10gIT09IDApIHtcclxuICAgICAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAwXSA9IChwaXhlbFtmaXJzdFBpeGVsICsgMF0gKyB0aGlzLmNvbG9yLnIpIC8gMjtcclxuICAgICAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXSA9IChwaXhlbFtmaXJzdFBpeGVsICsgMV0gKyB0aGlzLmNvbG9yLmcpIC8gMjtcclxuICAgICAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAyXSA9IChwaXhlbFtmaXJzdFBpeGVsICsgMl0gKyB0aGlzLmNvbG9yLmIpIC8gMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIENvbG9yaXplO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuQ29sb3JpemUgPSBDb2xvcml6ZTtcclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgXCJMaWdodGVuXCIgZWZmZWN0IHRvIGEgc3ByaXRlLCBjaGFuZ2VzIHRoZSBsaWdodG5lc3Mgb2YgdGhlIGNvbG9yIGFjY29yZGluZyB0byBIU0xcclxuICAgICAqL1xyXG4gICAgdmFyIExpZ2h0ZW4gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBmYWN0b3IgIFRoZSBmYWN0b3Igb2YgdGhlIGVmZmVjdCBiZXR3ZWVuIDAtMVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIExpZ2h0ZW4oZmFjdG9yKSB7XHJcbiAgICAgICAgICAgIGlmIChmYWN0b3IgPT09IHZvaWQgMCkgeyBmYWN0b3IgPSAwLjE7IH1cclxuICAgICAgICAgICAgdGhpcy5mYWN0b3IgPSBmYWN0b3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIExpZ2h0ZW4ucHJvdG90eXBlLnVwZGF0ZVBpeGVsID0gZnVuY3Rpb24gKHgsIHksIGltYWdlRGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgZmlyc3RQaXhlbCA9ICh4ICsgeSAqIGltYWdlRGF0YS53aWR0aCkgKiA0O1xyXG4gICAgICAgICAgICB2YXIgcGl4ZWwgPSBpbWFnZURhdGEuZGF0YTtcclxuICAgICAgICAgICAgdmFyIGNvbG9yID0gQ29sb3JfOC5Db2xvci5mcm9tUkdCKHBpeGVsW2ZpcnN0UGl4ZWwgKyAwXSwgcGl4ZWxbZmlyc3RQaXhlbCArIDFdLCBwaXhlbFtmaXJzdFBpeGVsICsgMl0sIHBpeGVsW2ZpcnN0UGl4ZWwgKyAzXSkubGlnaHRlbih0aGlzLmZhY3Rvcik7XHJcbiAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAwXSA9IGNvbG9yLnI7XHJcbiAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXSA9IGNvbG9yLmc7XHJcbiAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAyXSA9IGNvbG9yLmI7XHJcbiAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAzXSA9IGNvbG9yLmE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gTGlnaHRlbjtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkxpZ2h0ZW4gPSBMaWdodGVuO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBcIkRhcmtlblwiIGVmZmVjdCB0byBhIHNwcml0ZSwgY2hhbmdlcyB0aGUgZGFya25lc3Mgb2YgdGhlIGNvbG9yIGFjY29yZGluZyB0byBIU0xcclxuICAgICAqL1xyXG4gICAgdmFyIERhcmtlbiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIGZhY3RvciAgVGhlIGZhY3RvciBvZiB0aGUgZWZmZWN0IGJldHdlZW4gMC0xXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gRGFya2VuKGZhY3Rvcikge1xyXG4gICAgICAgICAgICBpZiAoZmFjdG9yID09PSB2b2lkIDApIHsgZmFjdG9yID0gMC4xOyB9XHJcbiAgICAgICAgICAgIHRoaXMuZmFjdG9yID0gZmFjdG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBEYXJrZW4ucHJvdG90eXBlLnVwZGF0ZVBpeGVsID0gZnVuY3Rpb24gKHgsIHksIGltYWdlRGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgZmlyc3RQaXhlbCA9ICh4ICsgeSAqIGltYWdlRGF0YS53aWR0aCkgKiA0O1xyXG4gICAgICAgICAgICB2YXIgcGl4ZWwgPSBpbWFnZURhdGEuZGF0YTtcclxuICAgICAgICAgICAgdmFyIGNvbG9yID0gQ29sb3JfOC5Db2xvci5mcm9tUkdCKHBpeGVsW2ZpcnN0UGl4ZWwgKyAwXSwgcGl4ZWxbZmlyc3RQaXhlbCArIDFdLCBwaXhlbFtmaXJzdFBpeGVsICsgMl0sIHBpeGVsW2ZpcnN0UGl4ZWwgKyAzXSkuZGFya2VuKHRoaXMuZmFjdG9yKTtcclxuICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDBdID0gY29sb3IucjtcclxuICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDFdID0gY29sb3IuZztcclxuICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDJdID0gY29sb3IuYjtcclxuICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDNdID0gY29sb3IuYTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBEYXJrZW47XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5EYXJrZW4gPSBEYXJrZW47XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIFwiU2F0dXJhdGVcIiBlZmZlY3QgdG8gYSBzcHJpdGUsIHNhdHVyYXRlcyB0aGUgY29sb3IgYWNjb3JkaW5nIHRvIEhTTFxyXG4gICAgICovXHJcbiAgICB2YXIgU2F0dXJhdGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBmYWN0b3IgIFRoZSBmYWN0b3Igb2YgdGhlIGVmZmVjdCBiZXR3ZWVuIDAtMVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIFNhdHVyYXRlKGZhY3Rvcikge1xyXG4gICAgICAgICAgICBpZiAoZmFjdG9yID09PSB2b2lkIDApIHsgZmFjdG9yID0gMC4xOyB9XHJcbiAgICAgICAgICAgIHRoaXMuZmFjdG9yID0gZmFjdG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBTYXR1cmF0ZS5wcm90b3R5cGUudXBkYXRlUGl4ZWwgPSBmdW5jdGlvbiAoeCwgeSwgaW1hZ2VEYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciBmaXJzdFBpeGVsID0gKHggKyB5ICogaW1hZ2VEYXRhLndpZHRoKSAqIDQ7XHJcbiAgICAgICAgICAgIHZhciBwaXhlbCA9IGltYWdlRGF0YS5kYXRhO1xyXG4gICAgICAgICAgICB2YXIgY29sb3IgPSBDb2xvcl84LkNvbG9yLmZyb21SR0IocGl4ZWxbZmlyc3RQaXhlbCArIDBdLCBwaXhlbFtmaXJzdFBpeGVsICsgMV0sIHBpeGVsW2ZpcnN0UGl4ZWwgKyAyXSwgcGl4ZWxbZmlyc3RQaXhlbCArIDNdKS5zYXR1cmF0ZSh0aGlzLmZhY3Rvcik7XHJcbiAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAwXSA9IGNvbG9yLnI7XHJcbiAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXSA9IGNvbG9yLmc7XHJcbiAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAyXSA9IGNvbG9yLmI7XHJcbiAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAzXSA9IGNvbG9yLmE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gU2F0dXJhdGU7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5TYXR1cmF0ZSA9IFNhdHVyYXRlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBcIkRlc2F0dXJhdGVcIiBlZmZlY3QgdG8gYSBzcHJpdGUsIGRlc2F0dXJhdGVzIHRoZSBjb2xvciBhY2NvcmRpbmcgdG8gSFNMXHJcbiAgICAgKi9cclxuICAgIHZhciBEZXNhdHVyYXRlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gZmFjdG9yICBUaGUgZmFjdG9yIG9mIHRoZSBlZmZlY3QgYmV0d2VlbiAwLTFcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBEZXNhdHVyYXRlKGZhY3Rvcikge1xyXG4gICAgICAgICAgICBpZiAoZmFjdG9yID09PSB2b2lkIDApIHsgZmFjdG9yID0gMC4xOyB9XHJcbiAgICAgICAgICAgIHRoaXMuZmFjdG9yID0gZmFjdG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBEZXNhdHVyYXRlLnByb3RvdHlwZS51cGRhdGVQaXhlbCA9IGZ1bmN0aW9uICh4LCB5LCBpbWFnZURhdGEpIHtcclxuICAgICAgICAgICAgdmFyIGZpcnN0UGl4ZWwgPSAoeCArIHkgKiBpbWFnZURhdGEud2lkdGgpICogNDtcclxuICAgICAgICAgICAgdmFyIHBpeGVsID0gaW1hZ2VEYXRhLmRhdGE7XHJcbiAgICAgICAgICAgIHZhciBjb2xvciA9IENvbG9yXzguQ29sb3IuZnJvbVJHQihwaXhlbFtmaXJzdFBpeGVsICsgMF0sIHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXSwgcGl4ZWxbZmlyc3RQaXhlbCArIDJdLCBwaXhlbFtmaXJzdFBpeGVsICsgM10pLmRlc2F0dXJhdGUodGhpcy5mYWN0b3IpO1xyXG4gICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMF0gPSBjb2xvci5yO1xyXG4gICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMV0gPSBjb2xvci5nO1xyXG4gICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMl0gPSBjb2xvci5iO1xyXG4gICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgM10gPSBjb2xvci5hO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIERlc2F0dXJhdGU7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5EZXNhdHVyYXRlID0gRGVzYXR1cmF0ZTtcclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgXCJGaWxsXCIgZWZmZWN0IHRvIGEgc3ByaXRlLCBjaGFuZ2luZyB0aGUgY29sb3IgY2hhbm5lbHMgb2YgYWxsIG5vbi10cmFuc3BhcmVudCBwaXhlbHMgdG8gbWF0Y2hcclxuICAgICAqIGEgZ2l2ZW4gY29sb3JcclxuICAgICAqL1xyXG4gICAgdmFyIEZpbGwgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBjb2xvciAgVGhlIGNvbG9yIHRvIGFwcGx5IHRvIHRoZSBzcHJpdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBGaWxsKGNvbG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgRmlsbC5wcm90b3R5cGUudXBkYXRlUGl4ZWwgPSBmdW5jdGlvbiAoeCwgeSwgaW1hZ2VEYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciBmaXJzdFBpeGVsID0gKHggKyB5ICogaW1hZ2VEYXRhLndpZHRoKSAqIDQ7XHJcbiAgICAgICAgICAgIHZhciBwaXhlbCA9IGltYWdlRGF0YS5kYXRhO1xyXG4gICAgICAgICAgICBpZiAocGl4ZWxbZmlyc3RQaXhlbCArIDNdICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMF0gPSB0aGlzLmNvbG9yLnI7XHJcbiAgICAgICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMV0gPSB0aGlzLmNvbG9yLmc7XHJcbiAgICAgICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMl0gPSB0aGlzLmNvbG9yLmI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBGaWxsO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuRmlsbCA9IEZpbGw7XHJcbn0pO1xyXG5kZWZpbmUoXCJJbnRlcmZhY2VzL0lEcmF3YWJsZVwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG59KTtcclxuZGVmaW5lKFwiSW50ZXJmYWNlcy9JTG9hZGFibGVcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxufSk7XHJcbmRlZmluZShcIlJlc291cmNlcy9SZXNvdXJjZVwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkNsYXNzXCIsIFwiUHJvbWlzZXNcIiwgXCJVdGlsL0xvZ1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIENsYXNzXzIsIFByb21pc2VzXzMsIExvZ18yKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIFtbUmVzb3VyY2VdXSB0eXBlIGFsbG93cyBnYW1lcyBidWlsdCBpbiBFeGNhbGlidXIgdG8gbG9hZCBnZW5lcmljIHJlc291cmNlcy5cclxuICAgICAqIEZvciBhbnkgdHlwZSBvZiByZW1vdGUgcmVzb3VyY2UgaXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIFtbUmVzb3VyY2VdXSBmb3IgcHJlbG9hZGluZy5cclxuICAgICAqXHJcbiAgICAgKiBbW2luY2x1ZGU6UmVzb3VyY2VzLm1kXV1cclxuICAgICAqL1xyXG4gICAgdmFyIFJlc291cmNlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoUmVzb3VyY2UsIF9zdXBlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHBhdGggICAgICAgICAgUGF0aCB0byB0aGUgcmVtb3RlIHJlc291cmNlXHJcbiAgICAgICAgICogQHBhcmFtIHJlc3BvbnNlVHlwZSAgVGhlIHR5cGUgdG8gZXhwZWN0IGFzIGEgcmVzcG9uc2U6IFwiXCIgfCBcImFycmF5YnVmZmVyXCIgfCBcImJsb2JcIiB8IFwiZG9jdW1lbnRcIiB8IFwianNvblwiIHwgXCJ0ZXh0XCI7XHJcbiAgICAgICAgICogQHBhcmFtIGJ1c3RDYWNoZSAgICAgV2hldGhlciBvciBub3QgdG8gY2FjaGUtYnVzdCByZXF1ZXN0c1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIFJlc291cmNlKHBhdGgsIHJlc3BvbnNlVHlwZSwgYnVzdENhY2hlKSB7XHJcbiAgICAgICAgICAgIGlmIChidXN0Q2FjaGUgPT09IHZvaWQgMCkgeyBidXN0Q2FjaGUgPSB0cnVlOyB9XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLnBhdGggPSBwYXRoO1xyXG4gICAgICAgICAgICBfdGhpcy5yZXNwb25zZVR5cGUgPSByZXNwb25zZVR5cGU7XHJcbiAgICAgICAgICAgIF90aGlzLmJ1c3RDYWNoZSA9IGJ1c3RDYWNoZTtcclxuICAgICAgICAgICAgX3RoaXMuZGF0YSA9IG51bGw7XHJcbiAgICAgICAgICAgIF90aGlzLmxvZ2dlciA9IExvZ18yLkxvZ2dlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgICAgICBfdGhpcy5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XHJcbiAgICAgICAgICAgIF90aGlzLm9uY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybjsgfTtcclxuICAgICAgICAgICAgX3RoaXMub25lcnJvciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuOyB9O1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgUmVzb3VyY2UgaXMgY29tcGxldGVseSBsb2FkZWQgYW5kIGlzIHJlYWR5XHJcbiAgICAgICAgICogdG8gYmUgZHJhd24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVzb3VyY2UucHJvdG90eXBlLmlzTG9hZGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhICE9PSBudWxsO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUmVzb3VyY2UucHJvdG90eXBlLndpcmVFbmdpbmUgPSBmdW5jdGlvbiAoX2VuZ2luZSkge1xyXG4gICAgICAgICAgICAvLyBvdmVycmlkZSBtZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgUmVzb3VyY2UucHJvdG90eXBlLl9jYWNoZUJ1c3QgPSBmdW5jdGlvbiAodXJpKSB7XHJcbiAgICAgICAgICAgIHZhciBxdWVyeSA9IC9cXD9cXHcqPVxcdyovO1xyXG4gICAgICAgICAgICBpZiAocXVlcnkudGVzdCh1cmkpKSB7XHJcbiAgICAgICAgICAgICAgICB1cmkgKz0gKCcmX189JyArIERhdGUubm93KCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdXJpICs9ICgnP19fPScgKyBEYXRlLm5vdygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdXJpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUmVzb3VyY2UucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ1N0YXJ0ZWQgbG9hZGluZyByZXNvdXJjZSAnICsgdGhpcy5wYXRoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJlZ2luIGxvYWRpbmcgdGhlIHJlc291cmNlIGFuZCByZXR1cm5zIGEgcHJvbWlzZSB0byBiZSByZXNvbHZlZCBvbiBjb21wbGV0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVzb3VyY2UucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBjb21wbGV0ZSA9IG5ldyBQcm9taXNlc18zLlByb21pc2UoKTtcclxuICAgICAgICAgICAgLy8gRXhpdCBlYXJseSBpZiB3ZSBhbHJlYWR5IGhhdmUgZGF0YVxyXG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnQWxyZWFkeSBoYXZlIGRhdGEgZm9yIHJlc291cmNlJywgdGhpcy5wYXRoKTtcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlLnJlc29sdmUodGhpcy5kYXRhKTtcclxuICAgICAgICAgICAgICAgIHRoaXMub25jb21wbGV0ZSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgICAgIHJlcXVlc3Qub3BlbignR0VUJywgdGhpcy5idXN0Q2FjaGUgPyB0aGlzLl9jYWNoZUJ1c3QodGhpcy5wYXRoKSA6IHRoaXMucGF0aCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gdGhpcy5yZXNwb25zZVR5cGU7XHJcbiAgICAgICAgICAgIHJlcXVlc3Qub25sb2Fkc3RhcnQgPSBmdW5jdGlvbiAoKSB7IF90aGlzLl9zdGFydCgpOyB9O1xyXG4gICAgICAgICAgICByZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSB0aGlzLm9ucHJvZ3Jlc3M7XHJcbiAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9IHRoaXMub25lcnJvcjtcclxuICAgICAgICAgICAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBYSFIgb24gZmlsZTovLyBzdWNjZXNzIHN0YXR1cyBpcyAwLCBzdWNoIGFzIHdpdGggUGhhbnRvbUpTXHJcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgIT09IDAgJiYgcmVxdWVzdC5zdGF0dXMgIT09IDIwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5lcnJvcignRmFpbGVkIHRvIGxvYWQgcmVzb3VyY2UgJywgX3RoaXMucGF0aCwgJyBzZXJ2ZXIgcmVzcG9uZGVkIHdpdGggZXJyb3IgY29kZScsIHJlcXVlc3Quc3RhdHVzKTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbmVycm9yKHJlcXVlc3QucmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlLnJlc29sdmUocmVxdWVzdC5yZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3RoaXMuZGF0YSA9IF90aGlzLnByb2Nlc3NEYXRhKHJlcXVlc3QucmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMub25jb21wbGV0ZSgpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmRlYnVnKCdDb21wbGV0ZWQgbG9hZGluZyByZXNvdXJjZScsIF90aGlzLnBhdGgpO1xyXG4gICAgICAgICAgICAgICAgY29tcGxldGUucmVzb2x2ZShfdGhpcy5kYXRhKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmVxdWVzdC5zZW5kKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIGxvYWRlZCBkYXRhIG9uY2UgdGhlIHJlc291cmNlIGlzIGxvYWRlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlc291cmNlLnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgZGF0YSBmb3IgdGhpcyByZXNvdXJjZSBkaXJlY3RseVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlc291cmNlLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhID0gdGhpcy5wcm9jZXNzRGF0YShkYXRhKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGlzIG1lYW50IHRvIGJlIG92ZXJyaWRlbiB0byBoYW5kbGUgYW55IGFkZGl0aW9uYWxcclxuICAgICAgICAgKiBwcm9jZXNzaW5nLiBTdWNoIGFzIGRlY29kaW5nIGRvd25sb2FkZWQgYXVkaW8gYml0cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBSZXNvdXJjZS5wcm90b3R5cGUucHJvY2Vzc0RhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvWE1MSHR0cFJlcXVlc3QvcmVzcG9uc2VUeXBlXHJcbiAgICAgICAgICAgIC8vIEJsb2IgcmVxdWlyZXMgYW4gb2JqZWN0IHVybFxyXG4gICAgICAgICAgICBpZiAodGhpcy5yZXNwb25zZVR5cGUgPT09ICdibG9iJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwoZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gUmVzb3VyY2U7XHJcbiAgICB9KENsYXNzXzIuQ2xhc3MpKTtcclxuICAgIGV4cG9ydHMuUmVzb3VyY2UgPSBSZXNvdXJjZTtcclxufSk7XHJcbmRlZmluZShcIlJlc291cmNlcy9UZXh0dXJlXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiUmVzb3VyY2VzL1Jlc291cmNlXCIsIFwiUHJvbWlzZXNcIiwgXCJEcmF3aW5nL1Nwcml0ZVwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIFJlc291cmNlXzEsIFByb21pc2VzXzQsIFNwcml0ZV8xKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIFtbVGV4dHVyZV1dIG9iamVjdCBhbGxvd3MgZ2FtZXMgYnVpbHQgaW4gRXhjYWxpYnVyIHRvIGxvYWQgaW1hZ2UgcmVzb3VyY2VzLlxyXG4gICAgICogW1tUZXh0dXJlXV0gaXMgYW4gW1tJTG9hZGFibGVdXSB3aGljaCBtZWFucyBpdCBjYW4gYmUgcGFzc2VkIHRvIGEgW1tMb2FkZXJdXVxyXG4gICAgICogdG8gcHJlLWxvYWQgYmVmb3JlIHN0YXJ0aW5nIGEgbGV2ZWwgb3IgZ2FtZS5cclxuICAgICAqXHJcbiAgICAgKiBbW2luY2x1ZGU6VGV4dHVyZXMubWRdXVxyXG4gICAgICovXHJcbiAgICB2YXIgVGV4dHVyZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFRleHR1cmUsIF9zdXBlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHBhdGggICAgICAgUGF0aCB0byB0aGUgaW1hZ2UgcmVzb3VyY2VcclxuICAgICAgICAgKiBAcGFyYW0gYnVzdENhY2hlICBPcHRpb25hbGx5IGxvYWQgdGV4dHVyZSB3aXRoIGNhY2hlIGJ1c3RpbmdcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBUZXh0dXJlKHBhdGgsIGJ1c3RDYWNoZSkge1xyXG4gICAgICAgICAgICBpZiAoYnVzdENhY2hlID09PSB2b2lkIDApIHsgYnVzdENhY2hlID0gdHJ1ZTsgfVxyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwYXRoLCAnYmxvYicsIGJ1c3RDYWNoZSkgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMucGF0aCA9IHBhdGg7XHJcbiAgICAgICAgICAgIF90aGlzLmJ1c3RDYWNoZSA9IGJ1c3RDYWNoZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgW1tQcm9taXNlXV0gdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBUZXh0dXJlIGlzIGxvYWRlZC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmxvYWRlZCA9IG5ldyBQcm9taXNlc180LlByb21pc2UoKTtcclxuICAgICAgICAgICAgX3RoaXMuX2lzTG9hZGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIF90aGlzLl9zcHJpdGUgPSBudWxsO1xyXG4gICAgICAgICAgICBfdGhpcy5fc3ByaXRlID0gbmV3IFNwcml0ZV8xLlNwcml0ZShfdGhpcywgMCwgMCwgMCwgMCk7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBUZXh0dXJlIGlzIGNvbXBsZXRlbHkgbG9hZGVkIGFuZCBpcyByZWFkeVxyXG4gICAgICAgICAqIHRvIGJlIGRyYXduLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRleHR1cmUucHJvdG90eXBlLmlzTG9hZGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNMb2FkZWQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCZWdpbnMgbG9hZGluZyB0aGUgdGV4dHVyZSBhbmQgcmV0dXJucyBhIHByb21pc2UgdG8gYmUgcmVzb2x2ZWQgb24gY29tcGxldGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRleHR1cmUucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBjb21wbGV0ZSA9IG5ldyBQcm9taXNlc180LlByb21pc2UoKTtcclxuICAgICAgICAgICAgdmFyIGxvYWRlZCA9IF9zdXBlci5wcm90b3R5cGUubG9hZC5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICBsb2FkZWQudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5pbWFnZSA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5faXNMb2FkZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLndpZHRoID0gX3RoaXMuX3Nwcml0ZS5zd2lkdGggPSBfdGhpcy5fc3ByaXRlLm5hdHVyYWxXaWR0aCA9IF90aGlzLl9zcHJpdGUud2lkdGggPSBfdGhpcy5pbWFnZS5uYXR1cmFsV2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGVpZ2h0ID0gX3RoaXMuX3Nwcml0ZS5zaGVpZ2h0ID0gX3RoaXMuX3Nwcml0ZS5uYXR1cmFsSGVpZ2h0ID0gX3RoaXMuX3Nwcml0ZS5oZWlnaHQgPSBfdGhpcy5pbWFnZS5uYXR1cmFsSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxvYWRlZC5yZXNvbHZlKF90aGlzLmltYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZS5yZXNvbHZlKF90aGlzLmltYWdlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuaW1hZ2Uuc3JjID0gX3N1cGVyLnByb3RvdHlwZS5nZXREYXRhLmNhbGwoX3RoaXMpO1xyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZS5yZWplY3QoJ0Vycm9yIGxvYWRpbmcgdGV4dHVyZS4nKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFRleHR1cmUucHJvdG90eXBlLmFzU3ByaXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3ByaXRlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFRleHR1cmU7XHJcbiAgICB9KFJlc291cmNlXzEuUmVzb3VyY2UpKTtcclxuICAgIGV4cG9ydHMuVGV4dHVyZSA9IFRleHR1cmU7XHJcbn0pO1xyXG5kZWZpbmUoXCJEcmF3aW5nL1Nwcml0ZVwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkRyYXdpbmcvU3ByaXRlRWZmZWN0c1wiLCBcIkRyYXdpbmcvQ29sb3JcIiwgXCJSZXNvdXJjZXMvVGV4dHVyZVwiLCBcIkFsZ2VicmFcIiwgXCJVdGlsL0xvZ1wiLCBcIlV0aWwvVXRpbFwiLCBcIkNvbmZpZ3VyYWJsZVwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIEVmZmVjdHMsIENvbG9yXzksIFRleHR1cmVfMSwgQWxnZWJyYV8xMSwgTG9nXzMsIFV0aWxfMiwgQ29uZmlndXJhYmxlXzEpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaGlkZGVuXHJcbiAgICAgKi9cclxuICAgIHZhciBTcHJpdGVJbXBsID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gaW1hZ2UgICBUaGUgYmFja2luZyBpbWFnZSB0ZXh0dXJlIHRvIGJ1aWxkIHRoZSBTcHJpdGVcclxuICAgICAgICAgKiBAcGFyYW0gc3ggICAgICBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgc3ByaXRlXHJcbiAgICAgICAgICogQHBhcmFtIHN5ICAgICAgVGhlIHkgcG9zaXRpb24gb2YgdGhlIHNwcml0ZVxyXG4gICAgICAgICAqIEBwYXJhbSBzd2lkdGggIFRoZSB3aWR0aCBvZiB0aGUgc3ByaXRlIGluIHBpeGVsc1xyXG4gICAgICAgICAqIEBwYXJhbSBzaGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIHNwcml0ZSBpbiBwaXhlbHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBTcHJpdGVJbXBsKGltYWdlT3JDb25maWcsIHN4LCBzeSwgc3dpZHRoLCBzaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHRoaXMucm90YXRpb24gPSAwLjA7XHJcbiAgICAgICAgICAgIHRoaXMuYW5jaG9yID0gbmV3IEFsZ2VicmFfMTEuVmVjdG9yKDAuMCwgMC4wKTtcclxuICAgICAgICAgICAgdGhpcy5zY2FsZSA9IG5ldyBBbGdlYnJhXzExLlZlY3RvcigxLCAxKTtcclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIgPSBMb2dfMy5Mb2dnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERyYXdzIHRoZSBzcHJpdGUgZmxpcHBlZCB2ZXJ0aWNhbGx5XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmZsaXBWZXJ0aWNhbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRHJhd3MgdGhlIHNwcml0ZSBmbGlwcGVkIGhvcml6b250YWxseVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5mbGlwSG9yaXpvbnRhbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gMDtcclxuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmVmZmVjdHMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5zeCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuc3kgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLnN3aWR0aCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuc2hlaWdodCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMubmF0dXJhbFdpZHRoID0gMDtcclxuICAgICAgICAgICAgdGhpcy5uYXR1cmFsSGVpZ2h0ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fc3ByaXRlQ2FudmFzID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5fc3ByaXRlQ3R4ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5fcGl4ZWxEYXRhID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5fcGl4ZWxzTG9hZGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2RpcnR5RWZmZWN0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChzeCA8IDAgfHwgc3kgPCAwIHx8IHN3aWR0aCA8IDAgfHwgc2hlaWdodCA8IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdTcHJpdGUgY2Fubm90IGhhdmUgYW55IG5lZ2F0aXZlIGRpbWVuc2lvbnMgeDonLCBzeCwgJ3k6Jywgc3ksICd3aWR0aDonLCBzd2lkdGgsICdoZWlnaHQ6Jywgc2hlaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGltYWdlID0gaW1hZ2VPckNvbmZpZztcclxuICAgICAgICAgICAgaWYgKGltYWdlT3JDb25maWcgJiYgIShpbWFnZU9yQ29uZmlnIGluc3RhbmNlb2YgVGV4dHVyZV8xLlRleHR1cmUpKSB7XHJcbiAgICAgICAgICAgICAgICBzeCA9IGltYWdlT3JDb25maWcuc3g7XHJcbiAgICAgICAgICAgICAgICBzeSA9IGltYWdlT3JDb25maWcuc3k7XHJcbiAgICAgICAgICAgICAgICBzd2lkdGggPSBpbWFnZU9yQ29uZmlnLnN3aWR0aDtcclxuICAgICAgICAgICAgICAgIHNoZWlnaHQgPSBpbWFnZU9yQ29uZmlnLnNoZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBpbWFnZSA9IGltYWdlT3JDb25maWcuaW1hZ2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zeCA9IHN4IHx8IDA7XHJcbiAgICAgICAgICAgIHRoaXMuc3kgPSBzeSB8fCAwO1xyXG4gICAgICAgICAgICB0aGlzLnN3aWR0aCA9IHN3aWR0aCB8fCAwO1xyXG4gICAgICAgICAgICB0aGlzLnNoZWlnaHQgPSBzaGVpZ2h0IHx8IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3RleHR1cmUgPSBpbWFnZTtcclxuICAgICAgICAgICAgdGhpcy5fc3ByaXRlQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Nwcml0ZUNhbnZhcy53aWR0aCA9IHN3aWR0aDtcclxuICAgICAgICAgICAgdGhpcy5fc3ByaXRlQ2FudmFzLmhlaWdodCA9IHNoZWlnaHQ7XHJcbiAgICAgICAgICAgIHRoaXMuX3Nwcml0ZUN0eCA9IHRoaXMuX3Nwcml0ZUNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgICAgICB0aGlzLl90ZXh0dXJlLmxvYWRlZC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9zcHJpdGVDYW52YXMud2lkdGggPSBfdGhpcy5fc3ByaXRlQ2FudmFzLndpZHRoIHx8IF90aGlzLl90ZXh0dXJlLmltYWdlLm5hdHVyYWxXaWR0aDtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9zcHJpdGVDYW52YXMuaGVpZ2h0ID0gX3RoaXMuX3Nwcml0ZUNhbnZhcy5oZWlnaHQgfHwgX3RoaXMuX3RleHR1cmUuaW1hZ2UubmF0dXJhbEhlaWdodDtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9sb2FkUGl4ZWxzKCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fZGlydHlFZmZlY3QgPSB0cnVlO1xyXG4gICAgICAgICAgICB9KS5lcnJvcihmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKCdFcnJvciBsb2FkaW5nIHRleHR1cmUgJywgX3RoaXMuX3RleHR1cmUucGF0aCwgZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gc3dpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IHNoZWlnaHQ7XHJcbiAgICAgICAgICAgIHRoaXMubmF0dXJhbFdpZHRoID0gc3dpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLm5hdHVyYWxIZWlnaHQgPSBzaGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBTcHJpdGVJbXBsLnByb3RvdHlwZS5fbG9hZFBpeGVscyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3RleHR1cmUuaXNMb2FkZWQoKSAmJiAhdGhpcy5fcGl4ZWxzTG9hZGVkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmF0dXJhbFdpZHRoID0gdGhpcy5fdGV4dHVyZS5pbWFnZS5uYXR1cmFsV2lkdGggfHwgMDtcclxuICAgICAgICAgICAgICAgIHZhciBuYXR1cmFsSGVpZ2h0ID0gdGhpcy5fdGV4dHVyZS5pbWFnZS5uYXR1cmFsSGVpZ2h0IHx8IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zd2lkdGggPiBuYXR1cmFsV2lkdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdUaGUgc3ByaXRlIHdpZHRoJywgdGhpcy5zd2lkdGgsICdleGNlZWRzIHRoZSB3aWR0aCcsIG5hdHVyYWxXaWR0aCwgJ29mIHRoZSBiYWNraW5nIHRleHR1cmUnLCB0aGlzLl90ZXh0dXJlLnBhdGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hlaWdodCA+IG5hdHVyYWxIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdUaGUgc3ByaXRlIGhlaWdodCcsIHRoaXMuc2hlaWdodCwgJ2V4Y2VlZHMgdGhlIGhlaWdodCcsIG5hdHVyYWxIZWlnaHQsICdvZiB0aGUgYmFja2luZyB0ZXh0dXJlJywgdGhpcy5fdGV4dHVyZS5wYXRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3Nwcml0ZUN0eC5kcmF3SW1hZ2UodGhpcy5fdGV4dHVyZS5pbWFnZSwgVXRpbF8yLmNsYW1wKHRoaXMuc3gsIDAsIG5hdHVyYWxXaWR0aCksIFV0aWxfMi5jbGFtcCh0aGlzLnN5LCAwLCBuYXR1cmFsSGVpZ2h0KSwgVXRpbF8yLmNsYW1wKHRoaXMuc3dpZHRoLCAwLCBuYXR1cmFsV2lkdGgpLCBVdGlsXzIuY2xhbXAodGhpcy5zaGVpZ2h0LCAwLCBuYXR1cmFsSGVpZ2h0KSwgMCwgMCwgdGhpcy5zd2lkdGgsIHRoaXMuc2hlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9waXhlbHNMb2FkZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcHBsaWVzIHRoZSBbW09wYWNpdHldXSBlZmZlY3QgdG8gYSBzcHJpdGUsIHNldHRpbmcgdGhlIGFscGhhIG9mIGFsbCBwaXhlbHMgdG8gYSBnaXZlbiB2YWx1ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNwcml0ZUltcGwucHJvdG90eXBlLm9wYWNpdHkgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRFZmZlY3QobmV3IEVmZmVjdHMuT3BhY2l0eSh2YWx1ZSkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXBwbGllcyB0aGUgW1tHcmF5c2NhbGVdXSBlZmZlY3QgdG8gYSBzcHJpdGUsIHJlbW92aW5nIGNvbG9yIGluZm9ybWF0aW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNwcml0ZUltcGwucHJvdG90eXBlLmdyYXlzY2FsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRFZmZlY3QobmV3IEVmZmVjdHMuR3JheXNjYWxlKCkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXBwbGllcyB0aGUgW1tJbnZlcnRdXSBlZmZlY3QgdG8gYSBzcHJpdGUsIGludmVydGluZyB0aGUgcGl4ZWwgY29sb3JzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNwcml0ZUltcGwucHJvdG90eXBlLmludmVydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRFZmZlY3QobmV3IEVmZmVjdHMuSW52ZXJ0KCkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXBwbGllcyB0aGUgW1tGaWxsXV0gZWZmZWN0IHRvIGEgc3ByaXRlLCBjaGFuZ2luZyB0aGUgY29sb3IgY2hhbm5lbHMgb2YgYWxsIG5vbi10cmFuc3BhcmVudCBwaXhlbHMgdG8gbWF0Y2ggYSBnaXZlbiBjb2xvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNwcml0ZUltcGwucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAoY29sb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRFZmZlY3QobmV3IEVmZmVjdHMuRmlsbChjb2xvcikpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXBwbGllcyB0aGUgW1tDb2xvcml6ZV1dIGVmZmVjdCB0byBhIHNwcml0ZSwgY2hhbmdpbmcgdGhlIGNvbG9yIGNoYW5uZWxzIG9mIGFsbCBwaXhlbHMgdG8gYmUgdGhlIGF2ZXJhZ2Ugb2YgdGhlIG9yaWdpbmFsIGNvbG9yXHJcbiAgICAgICAgICogYW5kIHRoZSBwcm92aWRlZCBjb2xvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBTcHJpdGVJbXBsLnByb3RvdHlwZS5jb2xvcml6ZSA9IGZ1bmN0aW9uIChjb2xvcikge1xyXG4gICAgICAgICAgICB0aGlzLmFkZEVmZmVjdChuZXcgRWZmZWN0cy5Db2xvcml6ZShjb2xvcikpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXBwbGllcyB0aGUgW1tMaWdodGVuXV0gZWZmZWN0IHRvIGEgc3ByaXRlLCBjaGFuZ2VzIHRoZSBsaWdodG5lc3Mgb2YgdGhlIGNvbG9yIGFjY29yZGluZyB0byBIU0xcclxuICAgICAgICAgKi9cclxuICAgICAgICBTcHJpdGVJbXBsLnByb3RvdHlwZS5saWdodGVuID0gZnVuY3Rpb24gKGZhY3Rvcikge1xyXG4gICAgICAgICAgICBpZiAoZmFjdG9yID09PSB2b2lkIDApIHsgZmFjdG9yID0gMC4xOyB9XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRWZmZWN0KG5ldyBFZmZlY3RzLkxpZ2h0ZW4oZmFjdG9yKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcHBsaWVzIHRoZSBbW0Rhcmtlbl1dIGVmZmVjdCB0byBhIHNwcml0ZSwgY2hhbmdlcyB0aGUgZGFya25lc3Mgb2YgdGhlIGNvbG9yIGFjY29yZGluZyB0byBIU0xcclxuICAgICAgICAgKi9cclxuICAgICAgICBTcHJpdGVJbXBsLnByb3RvdHlwZS5kYXJrZW4gPSBmdW5jdGlvbiAoZmFjdG9yKSB7XHJcbiAgICAgICAgICAgIGlmIChmYWN0b3IgPT09IHZvaWQgMCkgeyBmYWN0b3IgPSAwLjE7IH1cclxuICAgICAgICAgICAgdGhpcy5hZGRFZmZlY3QobmV3IEVmZmVjdHMuRGFya2VuKGZhY3RvcikpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXBwbGllcyB0aGUgW1tTYXR1cmF0ZV1dIGVmZmVjdCB0byBhIHNwcml0ZSwgc2F0dXJhdGVzIHRoZSBjb2xvciBhY2NvcmRpbmcgdG8gSFNMXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU3ByaXRlSW1wbC5wcm90b3R5cGUuc2F0dXJhdGUgPSBmdW5jdGlvbiAoZmFjdG9yKSB7XHJcbiAgICAgICAgICAgIGlmIChmYWN0b3IgPT09IHZvaWQgMCkgeyBmYWN0b3IgPSAwLjE7IH1cclxuICAgICAgICAgICAgdGhpcy5hZGRFZmZlY3QobmV3IEVmZmVjdHMuU2F0dXJhdGUoZmFjdG9yKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcHBsaWVzIHRoZSBbW0Rlc2F0dXJhdGVdXSBlZmZlY3QgdG8gYSBzcHJpdGUsIGRlc2F0dXJhdGVzIHRoZSBjb2xvciBhY2NvcmRpbmcgdG8gSFNMXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU3ByaXRlSW1wbC5wcm90b3R5cGUuZGVzYXR1cmF0ZSA9IGZ1bmN0aW9uIChmYWN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKGZhY3RvciA9PT0gdm9pZCAwKSB7IGZhY3RvciA9IDAuMTsgfVxyXG4gICAgICAgICAgICB0aGlzLmFkZEVmZmVjdChuZXcgRWZmZWN0cy5EZXNhdHVyYXRlKGZhY3RvcikpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhIG5ldyBbW0lTcHJpdGVFZmZlY3RdXSB0byB0aGlzIGRyYXdpbmcuXHJcbiAgICAgICAgICogQHBhcmFtIGVmZmVjdCAgRWZmZWN0IHRvIGFkZCB0byB0aGUgdGhpcyBkcmF3aW5nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU3ByaXRlSW1wbC5wcm90b3R5cGUuYWRkRWZmZWN0ID0gZnVuY3Rpb24gKGVmZmVjdCkge1xyXG4gICAgICAgICAgICB0aGlzLmVmZmVjdHMucHVzaChlZmZlY3QpO1xyXG4gICAgICAgICAgICAvLyBXZSBtdXN0IGNoZWNrIGlmIHRoZSB0ZXh0dXJlIGFuZCB0aGUgYmFja2luZyBzcHJpdGUgcGl4ZWxzIGFyZSBsb2FkZWQgYXMgd2VsbCBiZWZvcmUgXHJcbiAgICAgICAgICAgIC8vIGFuIGVmZmVjdCBjYW4gYmUgYXBwbGllZFxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RleHR1cmUuaXNMb2FkZWQoKSB8fCAhdGhpcy5fcGl4ZWxzTG9hZGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXJ0eUVmZmVjdCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hcHBseUVmZmVjdHMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgU3ByaXRlSW1wbC5wcm90b3R5cGUucmVtb3ZlRWZmZWN0ID0gZnVuY3Rpb24gKHBhcmFtKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleFRvUmVtb3ZlID0gLTE7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyYW0gPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICBpbmRleFRvUmVtb3ZlID0gcGFyYW07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpbmRleFRvUmVtb3ZlID0gdGhpcy5lZmZlY3RzLmluZGV4T2YocGFyYW0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGJvdW5kcyBjaGVja1xyXG4gICAgICAgICAgICBpZiAoaW5kZXhUb1JlbW92ZSA8IDAgfHwgaW5kZXhUb1JlbW92ZSA+PSB0aGlzLmVmZmVjdHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5lZmZlY3RzLnNwbGljZShpbmRleFRvUmVtb3ZlLCAxKTtcclxuICAgICAgICAgICAgLy8gV2UgbXVzdCBjaGVjayBpZiB0aGUgdGV4dHVyZSBhbmQgdGhlIGJhY2tpbmcgc3ByaXRlIHBpeGVscyBhcmUgbG9hZGVkIGFzIHdlbGwgYmVmb3JlIFxyXG4gICAgICAgICAgICAvLyBhbiBlZmZlY3QgY2FuIGJlIGFwcGxpZWRcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl90ZXh0dXJlLmlzTG9hZGVkKCkgfHwgIXRoaXMuX3BpeGVsc0xvYWRlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlydHlFZmZlY3QgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYXBwbHlFZmZlY3RzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFNwcml0ZUltcGwucHJvdG90eXBlLl9hcHBseUVmZmVjdHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBuYXR1cmFsV2lkdGggPSB0aGlzLl90ZXh0dXJlLmltYWdlLm5hdHVyYWxXaWR0aCB8fCAwO1xyXG4gICAgICAgICAgICB2YXIgbmF0dXJhbEhlaWdodCA9IHRoaXMuX3RleHR1cmUuaW1hZ2UubmF0dXJhbEhlaWdodCB8fCAwO1xyXG4gICAgICAgICAgICB0aGlzLl9zcHJpdGVDdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuc3dpZHRoLCB0aGlzLnNoZWlnaHQpO1xyXG4gICAgICAgICAgICB0aGlzLl9zcHJpdGVDdHguZHJhd0ltYWdlKHRoaXMuX3RleHR1cmUuaW1hZ2UsIFV0aWxfMi5jbGFtcCh0aGlzLnN4LCAwLCBuYXR1cmFsV2lkdGgpLCBVdGlsXzIuY2xhbXAodGhpcy5zeSwgMCwgbmF0dXJhbEhlaWdodCksIFV0aWxfMi5jbGFtcCh0aGlzLnN3aWR0aCwgMCwgbmF0dXJhbFdpZHRoKSwgVXRpbF8yLmNsYW1wKHRoaXMuc2hlaWdodCwgMCwgbmF0dXJhbEhlaWdodCksIDAsIDAsIHRoaXMuc3dpZHRoLCB0aGlzLnNoZWlnaHQpO1xyXG4gICAgICAgICAgICB0aGlzLl9waXhlbERhdGEgPSB0aGlzLl9zcHJpdGVDdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHRoaXMuc3dpZHRoLCB0aGlzLnNoZWlnaHQpO1xyXG4gICAgICAgICAgICB2YXIgaSA9IDAsIHggPSAwLCB5ID0gMCwgbGVuID0gdGhpcy5lZmZlY3RzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHkgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yICh5OyB5IDwgdGhpcy5zaGVpZ2h0OyB5KyspIHtcclxuICAgICAgICAgICAgICAgICAgICB4ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHg7IHggPCB0aGlzLnN3aWR0aDsgeCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWZmZWN0c1tpXS51cGRhdGVQaXhlbCh4LCB5LCB0aGlzLl9waXhlbERhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9zcHJpdGVDdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuc3dpZHRoLCB0aGlzLnNoZWlnaHQpO1xyXG4gICAgICAgICAgICB0aGlzLl9zcHJpdGVDdHgucHV0SW1hZ2VEYXRhKHRoaXMuX3BpeGVsRGF0YSwgMCwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2RpcnR5RWZmZWN0ID0gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDbGVhcnMgYWxsIGVmZmVjdHMgZnJvbSB0aGUgZHJhd2luZyBhbmQgcmV0dXJuIGl0IHRvIGl0cyBvcmlnaW5hbCBzdGF0ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBTcHJpdGVJbXBsLnByb3RvdHlwZS5jbGVhckVmZmVjdHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWZmZWN0cy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9hcHBseUVmZmVjdHMoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlc2V0cyB0aGUgaW50ZXJuYWwgc3RhdGUgb2YgdGhlIGRyYXdpbmcgKGlmIGFueSlcclxuICAgICAgICAgKi9cclxuICAgICAgICBTcHJpdGVJbXBsLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgU3ByaXRlSW1wbC5wcm90b3R5cGUuZGVidWdEcmF3ID0gZnVuY3Rpb24gKGN0eCwgeCwgeSkge1xyXG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xyXG4gICAgICAgICAgICBjdHgucm90YXRlKHRoaXMucm90YXRpb24pO1xyXG4gICAgICAgICAgICB2YXIgc2NhbGVkU1dpZHRoID0gdGhpcy53aWR0aCAqIHRoaXMuc2NhbGUueDtcclxuICAgICAgICAgICAgdmFyIHNjYWxlZFNIZWlnaHQgPSB0aGlzLmhlaWdodCAqIHRoaXMuc2NhbGUueTtcclxuICAgICAgICAgICAgdmFyIHhwb2ludCA9IChzY2FsZWRTV2lkdGgpICogdGhpcy5hbmNob3IueDtcclxuICAgICAgICAgICAgdmFyIHlwb2ludCA9IChzY2FsZWRTSGVpZ2h0KSAqIHRoaXMuYW5jaG9yLnk7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IENvbG9yXzkuQ29sb3IuQmxhY2sudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZVJlY3QoLXhwb2ludCwgLXlwb2ludCwgc2NhbGVkU1dpZHRoLCBzY2FsZWRTSGVpZ2h0KTtcclxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERyYXdzIHRoZSBzcHJpdGUgYXBwcm9wcmlhdGVseSB0byB0aGUgMkQgcmVuZGVyaW5nIGNvbnRleHQsIGF0IGFuIHggYW5kIHkgY29vcmRpbmF0ZS5cclxuICAgICAgICAgKiBAcGFyYW0gY3R4ICBUaGUgMkQgcmVuZGVyaW5nIGNvbnRleHRcclxuICAgICAgICAgKiBAcGFyYW0geCAgICBUaGUgeCBjb29yZGluYXRlIG9mIHdoZXJlIHRvIGRyYXdcclxuICAgICAgICAgKiBAcGFyYW0geSAgICBUaGUgeSBjb29yZGluYXRlIG9mIHdoZXJlIHRvIGRyYXdcclxuICAgICAgICAgKi9cclxuICAgICAgICBTcHJpdGVJbXBsLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGN0eCwgeCwgeSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fZGlydHlFZmZlY3QpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5RWZmZWN0cygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNhbGN1bGF0aW5nIGN1cnJlbnQgZGltZW5zaW9uc1xyXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5uYXR1cmFsV2lkdGggKiB0aGlzLnNjYWxlLng7XHJcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5uYXR1cmFsSGVpZ2h0ICogdGhpcy5zY2FsZS55O1xyXG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgICAgICB2YXIgeHBvaW50ID0gdGhpcy53aWR0aCAqIHRoaXMuYW5jaG9yLng7XHJcbiAgICAgICAgICAgIHZhciB5cG9pbnQgPSB0aGlzLmhlaWdodCAqIHRoaXMuYW5jaG9yLnk7XHJcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoeCwgeSk7XHJcbiAgICAgICAgICAgIGN0eC5yb3RhdGUodGhpcy5yb3RhdGlvbik7XHJcbiAgICAgICAgICAgIHZhciBzY2FsZWRTV2lkdGggPSB0aGlzLnN3aWR0aCAqIHRoaXMuc2NhbGUueDtcclxuICAgICAgICAgICAgdmFyIHNjYWxlZFNIZWlnaHQgPSB0aGlzLnNoZWlnaHQgKiB0aGlzLnNjYWxlLnk7XHJcbiAgICAgICAgICAgIC8vIHRvZG8gY2FjaGUgZmxpcHBlZCBzcHJpdGVzXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZsaXBIb3Jpem9udGFsKSB7XHJcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHNjYWxlZFNXaWR0aCwgMCk7XHJcbiAgICAgICAgICAgICAgICBjdHguc2NhbGUoLTEsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZsaXBWZXJ0aWNhbCkge1xyXG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgwLCBzY2FsZWRTSGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIGN0eC5zY2FsZSgxLCAtMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLl9zcHJpdGVDYW52YXMsIDAsIDAsIHRoaXMuc3dpZHRoLCB0aGlzLnNoZWlnaHQsIC14cG9pbnQsIC15cG9pbnQsIHNjYWxlZFNXaWR0aCwgc2NhbGVkU0hlaWdodCk7XHJcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcm9kdWNlcyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgc3ByaXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU3ByaXRlSW1wbC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgU3ByaXRlKHRoaXMuX3RleHR1cmUsIHRoaXMuc3gsIHRoaXMuc3ksIHRoaXMuc3dpZHRoLCB0aGlzLnNoZWlnaHQpO1xyXG4gICAgICAgICAgICByZXN1bHQuc2NhbGUgPSB0aGlzLnNjYWxlLmNsb25lKCk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5yb3RhdGlvbiA9IHRoaXMucm90YXRpb247XHJcbiAgICAgICAgICAgIHJlc3VsdC5mbGlwSG9yaXpvbnRhbCA9IHRoaXMuZmxpcEhvcml6b250YWw7XHJcbiAgICAgICAgICAgIHJlc3VsdC5mbGlwVmVydGljYWwgPSB0aGlzLmZsaXBWZXJ0aWNhbDtcclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSB0aGlzLmVmZmVjdHMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LmFkZEVmZmVjdCh0aGlzLmVmZmVjdHNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gU3ByaXRlSW1wbDtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLlNwcml0ZUltcGwgPSBTcHJpdGVJbXBsO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIFtbU3ByaXRlXV0gaXMgb25lIG9mIHRoZSBtYWluIGRyYXdpbmcgcHJpbWl0aXZlcy4gSXQgaXMgcmVzcG9uc2libGUgZm9yIGRyYXdpbmdcclxuICAgICAqIGltYWdlcyBvciBwYXJ0cyBvZiBpbWFnZXMgZnJvbSBhIFtbVGV4dHVyZV1dIHJlc291cmNlIHRvIHRoZSBzY3JlZW4uXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOlNwcml0ZXMubWRdXVxyXG4gICAgICovXHJcbiAgICB2YXIgU3ByaXRlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoU3ByaXRlLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFNwcml0ZShpbWFnZU9yQ29uZmlnLCBzeCwgc3ksIHN3aWR0aCwgc2hlaWdodCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgaW1hZ2VPckNvbmZpZywgc3gsIHN5LCBzd2lkdGgsIHNoZWlnaHQpIHx8IHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBTcHJpdGU7XHJcbiAgICB9KENvbmZpZ3VyYWJsZV8xLkNvbmZpZ3VyYWJsZShTcHJpdGVJbXBsKSkpO1xyXG4gICAgZXhwb3J0cy5TcHJpdGUgPSBTcHJpdGU7XHJcbn0pO1xyXG5kZWZpbmUoXCJEcmF3aW5nL0FuaW1hdGlvblwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkRyYXdpbmcvU3ByaXRlRWZmZWN0c1wiLCBcIkFsZ2VicmFcIiwgXCJFbmdpbmVcIiwgXCJVdGlsL1V0aWxcIiwgXCJDb25maWd1cmFibGVcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBFZmZlY3RzLCBBbGdlYnJhXzEyLCBFbmdpbmVfMSwgVXRpbCwgQ29uZmlndXJhYmxlXzIpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaGlkZGVuXHJcbiAgICAgKi9cclxuICAgIHZhciBBbmltYXRpb25JbXBsID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUeXBpY2FsbHkgeW91IHdpbGwgdXNlIGEgW1tTcHJpdGVTaGVldF1dIHRvIGdlbmVyYXRlIGFuIFtbQW5pbWF0aW9uXV0uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gZW5naW5lICBSZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZ2FtZSBlbmdpbmVcclxuICAgICAgICAgKiBAcGFyYW0gaW1hZ2VzICBBbiBhcnJheSBvZiBzcHJpdGVzIHRvIGNyZWF0ZSB0aGUgZnJhbWVzIGZvciB0aGUgYW5pbWF0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHNwZWVkICAgVGhlIG51bWJlciBpbiBtaWxsaXNlY29uZHMgdG8gZGlzcGxheSBlYWNoIGZyYW1lIGluIHRoZSBhbmltYXRpb25cclxuICAgICAgICAgKiBAcGFyYW0gbG9vcCAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGUgYW5pbWF0aW9uIHNob3VsZCBsb29wIGFmdGVyIGl0IGlzIGNvbXBsZXRlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvbkltcGwoZW5naW5lT3JDb25maWcsIHNwcml0ZXMsIHNwZWVkLCBsb29wKSB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgc3ByaXRlIGZyYW1lcyB0byBwbGF5LCBpbiBvcmRlci4gU2VlIFtbU3ByaXRlU2hlZXQuZ2V0QW5pbWF0aW9uRm9yQWxsXV0gdG8gcXVpY2tseVxyXG4gICAgICAgICAgICAgKiBnZW5lcmF0ZSBhbiBbW0FuaW1hdGlvbl1dLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5zcHJpdGVzID0gW107XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDdXJyZW50IGZyYW1lIGluZGV4IGJlaW5nIHNob3duXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX29sZFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICB0aGlzLmFuY2hvciA9IG5ldyBBbGdlYnJhXzEyLlZlY3RvcigwLjAsIDAuMCk7XHJcbiAgICAgICAgICAgIHRoaXMucm90YXRpb24gPSAwLjA7XHJcbiAgICAgICAgICAgIHRoaXMuc2NhbGUgPSBuZXcgQWxnZWJyYV8xMi5WZWN0b3IoMSwgMSk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgYW5pbWF0aW9uIHNob3VsZCBsb29wIGFmdGVyIGl0IGlzIGNvbXBsZXRlZFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5sb29wID0gdHJ1ZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEluZGljYXRlcyB0aGUgZnJhbWUgaW5kZXggdGhlIGFuaW1hdGlvbiBzaG91bGQgZnJlZXplIG9uIGZvciBhIG5vbi1sb29waW5nXHJcbiAgICAgICAgICAgICAqIGFuaW1hdGlvbi4gQnkgZGVmYXVsdCBpdCBpcyB0aGUgbGFzdCBmcmFtZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuZnJlZXplRnJhbWUgPSAtMTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEZsaXAgZWFjaCBmcmFtZSB2ZXJ0aWNhbGx5LiBTZXRzIFtbU3ByaXRlLmZsaXBWZXJ0aWNhbF1dLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5mbGlwVmVydGljYWwgPSBmYWxzZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEZsaXAgZWFjaCBmcmFtZSBob3Jpem9udGFsbHkuIFNldHMgW1tTcHJpdGUuZmxpcEhvcml6b250YWxdXS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuZmxpcEhvcml6b250YWwgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy53aWR0aCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5uYXR1cmFsV2lkdGggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLm5hdHVyYWxIZWlnaHQgPSAwO1xyXG4gICAgICAgICAgICB2YXIgZW5naW5lID0gZW5naW5lT3JDb25maWc7XHJcbiAgICAgICAgICAgIGlmIChlbmdpbmVPckNvbmZpZyAmJiAhKGVuZ2luZU9yQ29uZmlnIGluc3RhbmNlb2YgRW5naW5lXzEuRW5naW5lKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbmZpZyA9IGVuZ2luZU9yQ29uZmlnO1xyXG4gICAgICAgICAgICAgICAgZW5naW5lID0gY29uZmlnLmVuZ2luZTtcclxuICAgICAgICAgICAgICAgIHNwcml0ZXMgPSBjb25maWcuc3ByaXRlcztcclxuICAgICAgICAgICAgICAgIHNwZWVkID0gY29uZmlnLnNwZWVkO1xyXG4gICAgICAgICAgICAgICAgbG9vcCA9IGNvbmZpZy5sb29wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlcyA9IHNwcml0ZXM7XHJcbiAgICAgICAgICAgIHRoaXMuc3BlZWQgPSBzcGVlZDtcclxuICAgICAgICAgICAgdGhpcy5fZW5naW5lID0gZW5naW5lO1xyXG4gICAgICAgICAgICBpZiAobG9vcCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvb3AgPSBsb29wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzcHJpdGVzICYmIHNwcml0ZXNbMF0pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gc3ByaXRlc1swXSA/IHNwcml0ZXNbMF0uaGVpZ2h0IDogMDtcclxuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSBzcHJpdGVzWzBdID8gc3ByaXRlc1swXS53aWR0aCA6IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5hdHVyYWxXaWR0aCA9IHNwcml0ZXNbMF0gPyBzcHJpdGVzWzBdLm5hdHVyYWxXaWR0aCA6IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5hdHVyYWxIZWlnaHQgPSBzcHJpdGVzWzBdID8gc3ByaXRlc1swXS5uYXR1cmFsSGVpZ2h0IDogMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJlZXplRnJhbWUgPSBzcHJpdGVzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXBwbGllcyB0aGUgb3BhY2l0eSBlZmZlY3QgdG8gYSBzcHJpdGUsIHNldHRpbmcgdGhlIGFscGhhIG9mIGFsbCBwaXhlbHMgdG8gYSBnaXZlbiB2YWx1ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFuaW1hdGlvbkltcGwucHJvdG90eXBlLm9wYWNpdHkgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRFZmZlY3QobmV3IEVmZmVjdHMuT3BhY2l0eSh2YWx1ZSkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXBwbGllcyB0aGUgZ3JheXNjYWxlIGVmZmVjdCB0byBhIHNwcml0ZSwgcmVtb3ZpbmcgY29sb3IgaW5mb3JtYXRpb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQW5pbWF0aW9uSW1wbC5wcm90b3R5cGUuZ3JheXNjYWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZEVmZmVjdChuZXcgRWZmZWN0cy5HcmF5c2NhbGUoKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcHBsaWVzIHRoZSBpbnZlcnQgZWZmZWN0IHRvIGEgc3ByaXRlLCBpbnZlcnRpbmcgdGhlIHBpeGVsIGNvbG9ycy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBBbmltYXRpb25JbXBsLnByb3RvdHlwZS5pbnZlcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRWZmZWN0KG5ldyBFZmZlY3RzLkludmVydCgpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFwcGxpZXMgdGhlIGZpbGwgZWZmZWN0IHRvIGEgc3ByaXRlLCBjaGFuZ2luZyB0aGUgY29sb3IgY2hhbm5lbHMgb2YgYWxsIG5vbi10cmFuc3BhcmVudCBwaXhlbHMgdG8gbWF0Y2ggYSBnaXZlbiBjb2xvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFuaW1hdGlvbkltcGwucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAoY29sb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRFZmZlY3QobmV3IEVmZmVjdHMuRmlsbChjb2xvcikpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXBwbGllcyB0aGUgY29sb3JpemUgZWZmZWN0IHRvIGEgc3ByaXRlLCBjaGFuZ2luZyB0aGUgY29sb3IgY2hhbm5lbHMgb2YgYWxsIHBpeGVscyB0byBiZSB0aGUgYXZlcmFnZSBvZiB0aGUgb3JpZ2luYWwgY29sb3IgYW5kIHRoZVxyXG4gICAgICAgICAqIHByb3ZpZGVkIGNvbG9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFuaW1hdGlvbkltcGwucHJvdG90eXBlLmNvbG9yaXplID0gZnVuY3Rpb24gKGNvbG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRWZmZWN0KG5ldyBFZmZlY3RzLkNvbG9yaXplKGNvbG9yKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcHBsaWVzIHRoZSBsaWdodGVuIGVmZmVjdCB0byBhIHNwcml0ZSwgY2hhbmdlcyB0aGUgbGlnaHRuZXNzIG9mIHRoZSBjb2xvciBhY2NvcmRpbmcgdG8gaHNsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQW5pbWF0aW9uSW1wbC5wcm90b3R5cGUubGlnaHRlbiA9IGZ1bmN0aW9uIChmYWN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKGZhY3RvciA9PT0gdm9pZCAwKSB7IGZhY3RvciA9IDAuMTsgfVxyXG4gICAgICAgICAgICB0aGlzLmFkZEVmZmVjdChuZXcgRWZmZWN0cy5MaWdodGVuKGZhY3RvcikpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXBwbGllcyB0aGUgZGFya2VuIGVmZmVjdCB0byBhIHNwcml0ZSwgY2hhbmdlcyB0aGUgZGFya25lc3Mgb2YgdGhlIGNvbG9yIGFjY29yZGluZyB0byBoc2xcclxuICAgICAgICAgKi9cclxuICAgICAgICBBbmltYXRpb25JbXBsLnByb3RvdHlwZS5kYXJrZW4gPSBmdW5jdGlvbiAoZmFjdG9yKSB7XHJcbiAgICAgICAgICAgIGlmIChmYWN0b3IgPT09IHZvaWQgMCkgeyBmYWN0b3IgPSAwLjE7IH1cclxuICAgICAgICAgICAgdGhpcy5hZGRFZmZlY3QobmV3IEVmZmVjdHMuRGFya2VuKGZhY3RvcikpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXBwbGllcyB0aGUgc2F0dXJhdGUgZWZmZWN0IHRvIGEgc3ByaXRlLCBzYXR1cmF0ZXMgdGhlIGNvbG9yIGFjY29yZGluZyB0byBoc2xcclxuICAgICAgICAgKi9cclxuICAgICAgICBBbmltYXRpb25JbXBsLnByb3RvdHlwZS5zYXR1cmF0ZSA9IGZ1bmN0aW9uIChmYWN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKGZhY3RvciA9PT0gdm9pZCAwKSB7IGZhY3RvciA9IDAuMTsgfVxyXG4gICAgICAgICAgICB0aGlzLmFkZEVmZmVjdChuZXcgRWZmZWN0cy5TYXR1cmF0ZShmYWN0b3IpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFwcGxpZXMgdGhlIGRlc2F0dXJhdGUgZWZmZWN0IHRvIGEgc3ByaXRlLCBkZXNhdHVyYXRlcyB0aGUgY29sb3IgYWNjb3JkaW5nIHRvIGhzbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFuaW1hdGlvbkltcGwucHJvdG90eXBlLmRlc2F0dXJhdGUgPSBmdW5jdGlvbiAoZmFjdG9yKSB7XHJcbiAgICAgICAgICAgIGlmIChmYWN0b3IgPT09IHZvaWQgMCkgeyBmYWN0b3IgPSAwLjE7IH1cclxuICAgICAgICAgICAgdGhpcy5hZGRFZmZlY3QobmV3IEVmZmVjdHMuRGVzYXR1cmF0ZShmYWN0b3IpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZCBhIFtbSVNwcml0ZUVmZmVjdF1dIG1hbnVhbGx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQW5pbWF0aW9uSW1wbC5wcm90b3R5cGUuYWRkRWZmZWN0ID0gZnVuY3Rpb24gKGVmZmVjdCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuc3ByaXRlcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVzW2ldLmFkZEVmZmVjdChlZmZlY3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBbmltYXRpb25JbXBsLnByb3RvdHlwZS5yZW1vdmVFZmZlY3QgPSBmdW5jdGlvbiAocGFyYW0pIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnNwcml0ZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlc1tpXS5yZW1vdmVFZmZlY3QocGFyYW0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDbGVhciBhbGwgc3ByaXRlIGVmZmVjdHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBBbmltYXRpb25JbXBsLnByb3RvdHlwZS5jbGVhckVmZmVjdHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5zcHJpdGVzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZXNbaV0uY2xlYXJFZmZlY3RzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEFuaW1hdGlvbkltcGwucHJvdG90eXBlLl9zZXRBbmNob3IgPSBmdW5jdGlvbiAocG9pbnQpIHtcclxuICAgICAgICAgICAgLy9pZiAoIXRoaXMuYW5jaG9yLmVxdWFscyhwb2ludCkpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnNwcml0ZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlc1tpXS5hbmNob3Iuc2V0VG8ocG9pbnQueCwgcG9pbnQueSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy99XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBbmltYXRpb25JbXBsLnByb3RvdHlwZS5fc2V0Um90YXRpb24gPSBmdW5jdGlvbiAocmFkaWFucykge1xyXG4gICAgICAgICAgICAvL2lmICh0aGlzLnJvdGF0aW9uICE9PSByYWRpYW5zKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5zcHJpdGVzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZXNbaV0ucm90YXRpb24gPSByYWRpYW5zO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgQW5pbWF0aW9uSW1wbC5wcm90b3R5cGUuX3NldFNjYWxlID0gZnVuY3Rpb24gKHNjYWxlKSB7XHJcbiAgICAgICAgICAgIC8vaWYgKCF0aGlzLnNjYWxlLmVxdWFscyhzY2FsZSkpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnNwcml0ZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlc1tpXS5zY2FsZSA9IHNjYWxlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVzZXRzIHRoZSBhbmltYXRpb24gdG8gZmlyc3QgZnJhbWUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQW5pbWF0aW9uSW1wbC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEZyYW1lID0gMDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBhbmltYXRpb24gaXMgY29tcGxldGUsIGFuaW1hdGlvbnMgdGhhdCBsb29wIGFyZSBuZXZlciBjb21wbGV0ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBBbmltYXRpb25JbXBsLnByb3RvdHlwZS5pc0RvbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoIXRoaXMubG9vcCAmJiB0aGlzLmN1cnJlbnRGcmFtZSA+PSB0aGlzLnNwcml0ZXMubGVuZ3RoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE5vdCBtZWFudCB0byBiZSBjYWxsZWQgYnkgZ2FtZSBkZXZlbG9wZXJzLiBUaWNrcyB0aGUgYW5pbWF0aW9uIGZvcndhcmQgaW50ZXJuYWxseSBhbmRcclxuICAgICAgICAgKiBjYWxjdWxhdGVzIHdoZXRoZXIgdG8gY2hhbmdlIHRvIHRoZSBmcmFtZS5cclxuICAgICAgICAgKiBAaW50ZXJuYWxcclxuICAgICAgICAgKi9cclxuICAgICAgICBBbmltYXRpb25JbXBsLnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIGlmICgodGltZSAtIHRoaXMuX29sZFRpbWUpID4gdGhpcy5zcGVlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50RnJhbWUgPSAodGhpcy5sb29wID8gKHRoaXMuY3VycmVudEZyYW1lICsgMSkgJSB0aGlzLnNwcml0ZXMubGVuZ3RoIDogdGhpcy5jdXJyZW50RnJhbWUgKyAxKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX29sZFRpbWUgPSB0aW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBbmltYXRpb25JbXBsLnByb3RvdHlwZS5fdXBkYXRlVmFsdWVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRBbmNob3IodGhpcy5hbmNob3IpO1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRSb3RhdGlvbih0aGlzLnJvdGF0aW9uKTtcclxuICAgICAgICAgICAgdGhpcy5fc2V0U2NhbGUodGhpcy5zY2FsZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTa2lwcyBhaGVhZCBhIHNwZWNpZmllZCBudW1iZXIgb2YgZnJhbWVzIGluIHRoZSBhbmltYXRpb25cclxuICAgICAgICAgKiBAcGFyYW0gZnJhbWVzICBGcmFtZXMgdG8gc2tpcCBhaGVhZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFuaW1hdGlvbkltcGwucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiAoZnJhbWVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEZyYW1lID0gKHRoaXMuY3VycmVudEZyYW1lICsgZnJhbWVzKSAlIHRoaXMuc3ByaXRlcy5sZW5ndGg7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBbmltYXRpb25JbXBsLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGN0eCwgeCwgeSkge1xyXG4gICAgICAgICAgICB0aGlzLnRpY2soKTtcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVmFsdWVzKCk7XHJcbiAgICAgICAgICAgIHZhciBjdXJyU3ByaXRlO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50RnJhbWUgPCB0aGlzLnNwcml0ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyU3ByaXRlID0gdGhpcy5zcHJpdGVzW3RoaXMuY3VycmVudEZyYW1lXTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZsaXBWZXJ0aWNhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJTcHJpdGUuZmxpcFZlcnRpY2FsID0gdGhpcy5mbGlwVmVydGljYWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mbGlwSG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJTcHJpdGUuZmxpcEhvcml6b250YWwgPSB0aGlzLmZsaXBIb3Jpem9udGFsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3VyclNwcml0ZS5kcmF3KGN0eCwgeCwgeSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuZnJlZXplRnJhbWUgIT09IC0xICYmIHRoaXMuY3VycmVudEZyYW1lID49IHRoaXMuc3ByaXRlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJTcHJpdGUgPSB0aGlzLnNwcml0ZXNbVXRpbC5jbGFtcCh0aGlzLmZyZWV6ZUZyYW1lLCAwLCB0aGlzLnNwcml0ZXMubGVuZ3RoIC0gMSldO1xyXG4gICAgICAgICAgICAgICAgY3VyclNwcml0ZS5kcmF3KGN0eCwgeCwgeSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gYWRkIHRoZSBjYWxjdWxhdGVkIHdpZHRoXHJcbiAgICAgICAgICAgIGlmIChjdXJyU3ByaXRlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gY3VyclNwcml0ZS53aWR0aDtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gY3VyclNwcml0ZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBsYXlzIGFuIGFuaW1hdGlvbiBhdCBhbiBhcmJpdHJhcnkgbG9jYXRpb24gaW4gdGhlIGdhbWUuXHJcbiAgICAgICAgICogQHBhcmFtIHggIFRoZSB4IHBvc2l0aW9uIGluIHRoZSBnYW1lIHRvIHBsYXlcclxuICAgICAgICAgKiBAcGFyYW0geSAgVGhlIHkgcG9zaXRpb24gaW4gdGhlIGdhbWUgdG8gcGxheVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFuaW1hdGlvbkltcGwucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAoeCwgeSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZ2luZS5wbGF5QW5pbWF0aW9uKHRoaXMsIHgsIHkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEFuaW1hdGlvbkltcGw7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5BbmltYXRpb25JbXBsID0gQW5pbWF0aW9uSW1wbDtcclxuICAgIC8qKlxyXG4gICAgICogQW5pbWF0aW9ucyBhbGxvdyB5b3UgdG8gZGlzcGxheSBhIHNlcmllcyBvZiBpbWFnZXMgb25lIGFmdGVyIGFub3RoZXIsXHJcbiAgICAgKiBjcmVhdGluZyB0aGUgaWxsdXNpb24gb2YgY2hhbmdlLiBHZW5lcmFsbHkgdGhlc2UgaW1hZ2VzIHdpbGwgY29tZSBmcm9tIGEgW1tTcHJpdGVTaGVldF1dIHNvdXJjZS5cclxuICAgICAqXHJcbiAgICAgKiBbW2luY2x1ZGU6QW5pbWF0aW9ucy5tZF1dXHJcbiAgICAgKi9cclxuICAgIHZhciBBbmltYXRpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhBbmltYXRpb24sIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uKGVuZ2luZU9yQ29uZmlnLCBpbWFnZXMsIHNwZWVkLCBsb29wKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBlbmdpbmVPckNvbmZpZywgaW1hZ2VzLCBzcGVlZCwgbG9vcCkgfHwgdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEFuaW1hdGlvbjtcclxuICAgIH0oQ29uZmlndXJhYmxlXzIuQ29uZmlndXJhYmxlKEFuaW1hdGlvbkltcGwpKSk7XHJcbiAgICBleHBvcnRzLkFuaW1hdGlvbiA9IEFuaW1hdGlvbjtcclxufSk7XHJcbmRlZmluZShcIkRyYXdpbmcvU3ByaXRlU2hlZXRcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJEcmF3aW5nL1Nwcml0ZVwiLCBcIkRyYXdpbmcvQW5pbWF0aW9uXCIsIFwiRHJhd2luZy9Db2xvclwiLCBcIkRyYXdpbmcvU3ByaXRlRWZmZWN0c1wiLCBcIlJlc291cmNlcy9UZXh0dXJlXCIsIFwiVXRpbC9Mb2dcIiwgXCJMYWJlbFwiLCBcIkNvbmZpZ3VyYWJsZVwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIFNwcml0ZV8yLCBBbmltYXRpb25fMSwgQ29sb3JfMTAsIEVmZmVjdHMsIFRleHR1cmVfMiwgTG9nXzQsIExhYmVsXzEsIENvbmZpZ3VyYWJsZV8zKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogQGhpZGRlblxyXG4gICAgICovXHJcbiAgICB2YXIgU3ByaXRlU2hlZXRJbXBsID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gaW1hZ2UgICAgIFRoZSBiYWNraW5nIGltYWdlIHRleHR1cmUgdG8gYnVpbGQgdGhlIFNwcml0ZVNoZWV0XHJcbiAgICAgICAgICogQHBhcmFtIGNvbHVtbnMgICBUaGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIGltYWdlIHRleHR1cmVcclxuICAgICAgICAgKiBAcGFyYW0gcm93cyAgICAgIFRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGUgaW1hZ2UgdGV4dHVyZVxyXG4gICAgICAgICAqIEBwYXJhbSBzcFdpZHRoICAgVGhlIHdpZHRoIG9mIGVhY2ggaW5kaXZpZHVhbCBzcHJpdGUgaW4gcGl4ZWxzXHJcbiAgICAgICAgICogQHBhcmFtIHNwSGVpZ2h0ICBUaGUgaGVpZ2h0IG9mIGVhY2ggaW5kaXZpZHVhbCBzcHJpdGUgaW4gcGl4ZWxzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gU3ByaXRlU2hlZXRJbXBsKGltYWdlT3JDb25maWdPclNwcml0ZXMsIGNvbHVtbnMsIHJvd3MsIHNwV2lkdGgsIHNwSGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlcyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLmltYWdlID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5jb2x1bW5zID0gMDtcclxuICAgICAgICAgICAgdGhpcy5yb3dzID0gMDtcclxuICAgICAgICAgICAgdmFyIGxvYWRGcm9tSW1hZ2UgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKGltYWdlT3JDb25maWdPclNwcml0ZXMgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVzID0gaW1hZ2VPckNvbmZpZ09yU3ByaXRlcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChpbWFnZU9yQ29uZmlnT3JTcHJpdGVzICYmICEoaW1hZ2VPckNvbmZpZ09yU3ByaXRlcyBpbnN0YW5jZW9mIFRleHR1cmVfMi5UZXh0dXJlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1ucyA9IGltYWdlT3JDb25maWdPclNwcml0ZXMuY29sdW1ucztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvd3MgPSBpbWFnZU9yQ29uZmlnT3JTcHJpdGVzLnJvd3M7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcFdpZHRoID0gaW1hZ2VPckNvbmZpZ09yU3ByaXRlcy5zcFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3BIZWlnaHQgPSBpbWFnZU9yQ29uZmlnT3JTcHJpdGVzLnNwSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2UgPSBpbWFnZU9yQ29uZmlnT3JTcHJpdGVzLmltYWdlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbWFnZSA9IGltYWdlT3JDb25maWdPclNwcml0ZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2x1bW5zID0gY29sdW1ucztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvd3MgPSByb3dzO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3BXaWR0aCA9IHNwV2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcEhlaWdodCA9IHNwSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVzID0gbmV3IEFycmF5KHRoaXMuY29sdW1ucyAqIHRoaXMucm93cyk7XHJcbiAgICAgICAgICAgICAgICBsb2FkRnJvbUltYWdlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBUT0RPOiBJbnNwZWN0IGFjdHVhbCBpbWFnZSBkaW1lbnNpb25zIHdpdGggcHJlbG9hZGluZ1xyXG4gICAgICAgICAgICAvKmlmKHNwV2lkdGggKiBjb2x1bW5zID4gdGhpcy5pbnRlcm5hbEltYWdlLm5hdHVyYWxXaWR0aCl7XHJcbiAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNwcml0ZVNoZWV0IHNwZWNpZmllZCBpcyB3aWRlciB0aGFuIGltYWdlIHdpZHRoXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAgICAgICBpZihzcEhlaWdodCAqIHJvd3MgPiB0aGlzLmludGVybmFsSW1hZ2UubmF0dXJhbEhlaWdodCl7XHJcbiAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNwcml0ZVNoZWV0IHNwZWNpZmllZCBpcyBoaWdoZXIgdGhhbiBpbWFnZSBoZWlnaHRcIik7XHJcbiAgICAgICAgICAgIH0qL1xyXG4gICAgICAgICAgICBpZiAobG9hZEZyb21JbWFnZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIGogPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlc1tqICsgaSAqIHRoaXMuY29sdW1uc10gPSBuZXcgU3ByaXRlXzIuU3ByaXRlKHRoaXMuaW1hZ2UsIGogKiB0aGlzLnNwV2lkdGgsIGkgKiB0aGlzLnNwSGVpZ2h0LCB0aGlzLnNwV2lkdGgsIHRoaXMuc3BIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGUgYW4gYW5pbWF0aW9uIGZyb20gdGhlIHRoaXMgU3ByaXRlU2hlZXQgYnkgbGlzdGluZyBvdXQgdGhlXHJcbiAgICAgICAgICogc3ByaXRlIGluZGljZXMuIFNwcml0ZXMgYXJlIG9yZ2FuaXplZCBpbiByb3cgbWFqb3Igb3JkZXIgaW4gdGhlIFNwcml0ZVNoZWV0LlxyXG4gICAgICAgICAqIEBwYXJhbSBlbmdpbmUgICBSZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZ2FtZSBbW0VuZ2luZV1dXHJcbiAgICAgICAgICogQHBhcmFtIGluZGljZXMgIEFuIGFycmF5IG9mIHNwcml0ZSBpbmRpY2VzIHRvIHVzZSBpbiB0aGUgYW5pbWF0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHNwZWVkICAgIFRoZSBudW1iZXIgaW4gbWlsbGlzZWNvbmRzIHRvIGRpc3BsYXkgZWFjaCBmcmFtZSBpbiB0aGUgYW5pbWF0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU3ByaXRlU2hlZXRJbXBsLnByb3RvdHlwZS5nZXRBbmltYXRpb25CeUluZGljZXMgPSBmdW5jdGlvbiAoZW5naW5lLCBpbmRpY2VzLCBzcGVlZCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgaW1hZ2VzID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc3ByaXRlc1tpbmRleF07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpbWFnZXMgPSBpbWFnZXMubWFwKGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaS5jbG9uZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb25fMS5BbmltYXRpb24oZW5naW5lLCBpbWFnZXMsIHNwZWVkKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZSBhbiBhbmltYXRpb24gZnJvbSB0aGUgdGhpcyBTcHJpdGVTaGVldCBieSBzcGVjaWZpbmcgdGhlIHJhbmdlIG9mXHJcbiAgICAgICAgICogaW1hZ2VzIHdpdGggdGhlIGJlZ2lubmluZyAoaW5jbHVzaXZlKSBhbmQgZW5kaW5nIChleGNsdXNpdmUpIGluZGV4XHJcbiAgICAgICAgICogRm9yIGV4YW1wbGUgYGdldEFuaW1hdGlvbkJldHdlZW4oZW5naW5lLCAwLCA1LCAyMDApYCByZXR1cm5zIGFuIGFuaW1hdGlvbiB3aXRoIDUgZnJhbWVzLlxyXG4gICAgICAgICAqIEBwYXJhbSBlbmdpbmUgICAgICBSZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZ2FtZSBFbmdpbmVcclxuICAgICAgICAgKiBAcGFyYW0gYmVnaW5JbmRleCAgVGhlIGluZGV4IHRvIHN0YXJ0IHRha2luZyBmcmFtZXMgKGluY2x1c2l2ZSlcclxuICAgICAgICAgKiBAcGFyYW0gZW5kSW5kZXggICAgVGhlIGluZGV4IHRvIHN0b3AgdGFraW5nIGZyYW1lcyAoZXhjbHVzaXZlKVxyXG4gICAgICAgICAqIEBwYXJhbSBzcGVlZCAgICAgICBUaGUgbnVtYmVyIGluIG1pbGxpc2Vjb25kcyB0byBkaXNwbGF5IGVhY2ggZnJhbWUgaW4gdGhlIGFuaW1hdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNwcml0ZVNoZWV0SW1wbC5wcm90b3R5cGUuZ2V0QW5pbWF0aW9uQmV0d2VlbiA9IGZ1bmN0aW9uIChlbmdpbmUsIGJlZ2luSW5kZXgsIGVuZEluZGV4LCBzcGVlZCkge1xyXG4gICAgICAgICAgICB2YXIgaW1hZ2VzID0gdGhpcy5zcHJpdGVzLnNsaWNlKGJlZ2luSW5kZXgsIGVuZEluZGV4KTtcclxuICAgICAgICAgICAgaW1hZ2VzID0gaW1hZ2VzLm1hcChmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGkuY2xvbmUoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uXzEuQW5pbWF0aW9uKGVuZ2luZSwgaW1hZ2VzLCBzcGVlZCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUcmVhdCB0aGUgZW50aXJlIFNwcml0ZVNoZWV0IGFzIG9uZSBhbmltYXRpb24sIG9yZ2FuaXppbmcgdGhlIGZyYW1lcyBpblxyXG4gICAgICAgICAqIHJvdyBtYWpvciBvcmRlci5cclxuICAgICAgICAgKiBAcGFyYW0gZW5naW5lICBSZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZ2FtZSBbW0VuZ2luZV1dXHJcbiAgICAgICAgICogQHBhcmFtIHNwZWVkICAgVGhlIG51bWJlciBpbiBtaWxsaXNlY29uZHMgdG8gZGlzcGxheSBlYWNoIGZyYW1lIHRoZSBhbmltYXRpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBTcHJpdGVTaGVldEltcGwucHJvdG90eXBlLmdldEFuaW1hdGlvbkZvckFsbCA9IGZ1bmN0aW9uIChlbmdpbmUsIHNwZWVkKSB7XHJcbiAgICAgICAgICAgIHZhciBzcHJpdGVzID0gdGhpcy5zcHJpdGVzLm1hcChmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGkuY2xvbmUoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uXzEuQW5pbWF0aW9uKGVuZ2luZSwgc3ByaXRlcywgc3BlZWQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0cmVpdmUgYSBzcGVjaWZpYyBzcHJpdGUgZnJvbSB0aGUgU3ByaXRlU2hlZXQgYnkgaXRzIGluZGV4LiBTcHJpdGVzIGFyZSBvcmdhbml6ZWRcclxuICAgICAgICAgKiBpbiByb3cgbWFqb3Igb3JkZXIgaW4gdGhlIFNwcml0ZVNoZWV0LlxyXG4gICAgICAgICAqIEBwYXJhbSBpbmRleCAgVGhlIGluZGV4IG9mIHRoZSBzcHJpdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBTcHJpdGVTaGVldEltcGwucHJvdG90eXBlLmdldFNwcml0ZSA9IGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuc3ByaXRlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNwcml0ZXNbaW5kZXhdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGluZGV4OiAnICsgaW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gU3ByaXRlU2hlZXRJbXBsO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuU3ByaXRlU2hlZXRJbXBsID0gU3ByaXRlU2hlZXRJbXBsO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTcHJpdGUgc2hlZXRzIGFyZSBhIHVzZWZ1bCBtZWNoYW5pc20gZm9yIHNsaWNpbmcgdXAgaW1hZ2UgcmVzb3VyY2VzIGludG9cclxuICAgICAqIHNlcGFyYXRlIHNwcml0ZXMgb3IgZm9yIGdlbmVyYXRpbmcgaW4gZ2FtZSBhbmltYXRpb25zLiBbW1Nwcml0ZXxTcHJpdGVzXV0gYXJlIG9yZ2FuaXplZFxyXG4gICAgICogaW4gcm93IG1ham9yIG9yZGVyIGluIHRoZSBbW1Nwcml0ZVNoZWV0XV0uXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOlNwcml0ZVNoZWV0cy5tZF1dXHJcbiAgICAgKi9cclxuICAgIHZhciBTcHJpdGVTaGVldCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFNwcml0ZVNoZWV0LCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFNwcml0ZVNoZWV0KGltYWdlT3JDb25maWdPclNwcml0ZXMsIGNvbHVtbnMsIHJvd3MsIHNwV2lkdGgsIHNwSGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBpbWFnZU9yQ29uZmlnT3JTcHJpdGVzLCBjb2x1bW5zLCByb3dzLCBzcFdpZHRoLCBzcEhlaWdodCkgfHwgdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFNwcml0ZVNoZWV0O1xyXG4gICAgfShDb25maWd1cmFibGVfMy5Db25maWd1cmFibGUoU3ByaXRlU2hlZXRJbXBsKSkpO1xyXG4gICAgZXhwb3J0cy5TcHJpdGVTaGVldCA9IFNwcml0ZVNoZWV0O1xyXG4gICAgdmFyIFNwcml0ZUZvbnRJbXBsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoU3ByaXRlRm9udEltcGwsIF9zdXBlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIGltYWdlICAgICAgICAgICBUaGUgYmFja2luZyBpbWFnZSB0ZXh0dXJlIHRvIGJ1aWxkIHRoZSBTcHJpdGVGb250XHJcbiAgICAgICAgICogQHBhcmFtIGFscGhhYmV0ICAgICAgICBBIHN0cmluZyByZXByZXNlbnRpbmcgYWxsIHRoZSBjaGFyYWN0ZXJzIGluIHRoZSBpbWFnZSwgaW4gcm93IG1ham9yIG9yZGVyLlxyXG4gICAgICAgICAqIEBwYXJhbSBjYXNlSW5zZW5zaXRpdmUgIEluZGljYXRlIHdoZXRoZXIgdGhpcyBmb250IHRha2VzIGNhc2UgaW50byBhY2NvdW50XHJcbiAgICAgICAgICogQHBhcmFtIGNvbHVtbnMgICAgICAgICBUaGUgbnVtYmVyIG9mIGNvbHVtbnMgb2YgY2hhcmFjdGVycyBpbiB0aGUgaW1hZ2VcclxuICAgICAgICAgKiBAcGFyYW0gcm93cyAgICAgICAgICAgIFRoZSBudW1iZXIgb2Ygcm93cyBvZiBjaGFyYWN0ZXJzIGluIHRoZSBpbWFnZVxyXG4gICAgICAgICAqIEBwYXJhbSBzcFdpZHRoICAgICAgICAgVGhlIHdpZHRoIG9mIGVhY2ggY2hhcmFjdGVyIGluIHBpeGVsc1xyXG4gICAgICAgICAqIEBwYXJhbSBzcEhlaWdodCAgICAgICAgVGhlIGhlaWdodCBvZiBlYWNoIGNoYXJhY3RlciBpbiBwaXhlbHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBTcHJpdGVGb250SW1wbChpbWFnZU9yQ29uZmlnLCBhbHBoYWJldCwgY2FzZUluc2Vuc2l0aXZlLCBjb2x1bW5zLCByb3dzLCBzcFdpZHRoLCBzcEhlaWdodCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbWFnZU9yQ29uZmlnIGluc3RhbmNlb2YgVGV4dHVyZV8yLlRleHR1cmUgPyB7IGltYWdlOiBpbWFnZU9yQ29uZmlnLCBzcFdpZHRoOiBzcFdpZHRoLFxyXG4gICAgICAgICAgICAgICAgc3BIZWlnaHQ6IHNwSGVpZ2h0LCByb3dzOiByb3dzLCBjb2x1bW5zOiBjb2x1bW5zIH0gOiBpbWFnZU9yQ29uZmlnKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5fY3VycmVudENvbG9yID0gQ29sb3JfMTAuQ29sb3IuQmxhY2suY2xvbmUoKTtcclxuICAgICAgICAgICAgX3RoaXMuX2N1cnJlbnRPcGFjaXR5ID0gMS4wO1xyXG4gICAgICAgICAgICBfdGhpcy5fc3ByaXRlcyA9IHt9O1xyXG4gICAgICAgICAgICAvLyB0ZXh0IHNoYWRvd1xyXG4gICAgICAgICAgICBfdGhpcy5fdGV4dFNoYWRvd09uID0gZmFsc2U7XHJcbiAgICAgICAgICAgIF90aGlzLl90ZXh0U2hhZG93RGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICBfdGhpcy5fdGV4dFNoYWRvd0NvbG9yID0gQ29sb3JfMTAuQ29sb3IuQmxhY2suY2xvbmUoKTtcclxuICAgICAgICAgICAgX3RoaXMuX3RleHRTaGFkb3dTcHJpdGVzID0ge307XHJcbiAgICAgICAgICAgIF90aGlzLl9zaGFkb3dPZmZzZXRYID0gNTtcclxuICAgICAgICAgICAgX3RoaXMuX3NoYWRvd09mZnNldFkgPSA1O1xyXG4gICAgICAgICAgICBpZiAoaW1hZ2VPckNvbmZpZyAmJiAhKGltYWdlT3JDb25maWcgaW5zdGFuY2VvZiBUZXh0dXJlXzIuVGV4dHVyZSkpIHtcclxuICAgICAgICAgICAgICAgIGFscGhhYmV0ID0gaW1hZ2VPckNvbmZpZy5hbHBoYWJldDtcclxuICAgICAgICAgICAgICAgIGNhc2VJbnNlbnNpdGl2ZSA9IGltYWdlT3JDb25maWcuY2FzZUluc2Vuc2l0aXZlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzLl9hbHBoYWJldCA9IGFscGhhYmV0O1xyXG4gICAgICAgICAgICBfdGhpcy5fY2FzZUluc2Vuc2l0aXZlID0gY2FzZUluc2Vuc2l0aXZlO1xyXG4gICAgICAgICAgICBfdGhpcy5fc3ByaXRlcyA9IF90aGlzLmdldFRleHRTcHJpdGVzKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIGRpY3Rpb25hcnkgdGhhdCBtYXBzIGVhY2ggY2hhcmFjdGVyIGluIHRoZSBhbHBoYWJldCB0byB0aGUgYXBwcm9wcmlhdGUgW1tTcHJpdGVdXS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBTcHJpdGVGb250SW1wbC5wcm90b3R5cGUuZ2V0VGV4dFNwcml0ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBsb29rdXAgPSB7fTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9hbHBoYWJldC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoYXIgPSB0aGlzLl9hbHBoYWJldFtpXTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jYXNlSW5zZW5zaXRpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFyID0gY2hhci50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbG9va3VwW2NoYXJdID0gdGhpcy5zcHJpdGVzW2ldLmNsb25lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGxvb2t1cDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIHRleHQgc2hhZG93IGZvciBzcHJpdGUgZm9udHNcclxuICAgICAgICAgKiBAcGFyYW0gb2Zmc2V0WCAgICAgIFRoZSB4IG9mZnNldCBpbiBwaXhlbHMgdG8gcGxhY2UgdGhlIHNoYWRvd1xyXG4gICAgICAgICAqIEBwYXJhbSBvZmZzZXRZICAgICAgVGhlIHkgb2Zmc2V0IGluIHBpeGVscyB0byBwbGFjZSB0aGUgc2hhZG93XHJcbiAgICAgICAgICogQHBhcmFtIHNoYWRvd0NvbG9yICBUaGUgY29sb3Igb2YgdGhlIHRleHQgc2hhZG93XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU3ByaXRlRm9udEltcGwucHJvdG90eXBlLnNldFRleHRTaGFkb3cgPSBmdW5jdGlvbiAob2Zmc2V0WCwgb2Zmc2V0WSwgc2hhZG93Q29sb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5fdGV4dFNoYWRvd09uID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fc2hhZG93T2Zmc2V0WCA9IG9mZnNldFg7XHJcbiAgICAgICAgICAgIHRoaXMuX3NoYWRvd09mZnNldFkgPSBvZmZzZXRZO1xyXG4gICAgICAgICAgICB0aGlzLl90ZXh0U2hhZG93Q29sb3IgPSBzaGFkb3dDb2xvci5jbG9uZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl90ZXh0U2hhZG93RGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBjaGFyYWN0ZXIgaW4gdGhpcy5fc3ByaXRlcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dFNoYWRvd1Nwcml0ZXNbY2hhcmFjdGVyXSA9IHRoaXMuX3Nwcml0ZXNbY2hhcmFjdGVyXS5jbG9uZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUb2dnbGVzIHRleHQgc2hhZG93cyBvbiBvciBvZmZcclxuICAgICAgICAgKi9cclxuICAgICAgICBTcHJpdGVGb250SW1wbC5wcm90b3R5cGUudXNlVGV4dFNoYWRvdyA9IGZ1bmN0aW9uIChvbikge1xyXG4gICAgICAgICAgICB0aGlzLl90ZXh0U2hhZG93T24gPSBvbjtcclxuICAgICAgICAgICAgaWYgKG9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFRleHRTaGFkb3coNSwgNSwgdGhpcy5fdGV4dFNoYWRvd0NvbG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRHJhd3MgdGhlIGN1cnJlbnQgc3ByaXRlIGZvbnRcclxuICAgICAgICAgKi9cclxuICAgICAgICBTcHJpdGVGb250SW1wbC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjdHgsIHRleHQsIHgsIHksIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgb3B0aW9ucyA9IHRoaXMuX3BhcnNlT3B0aW9ucyhvcHRpb25zKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRDb2xvci50b1N0cmluZygpICE9PSBvcHRpb25zLmNvbG9yLnRvU3RyaW5nKCkgfHwgdGhpcy5fY3VycmVudE9wYWNpdHkgIT09IG9wdGlvbnMub3BhY2l0eSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudE9wYWNpdHkgPSBvcHRpb25zLm9wYWNpdHk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50Q29sb3IgPSBvcHRpb25zLmNvbG9yO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgY2hhciBpbiB0aGlzLl9zcHJpdGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3ByaXRlc1tjaGFyXS5jbGVhckVmZmVjdHMoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zcHJpdGVzW2NoYXJdLmZpbGwob3B0aW9ucy5jb2xvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3ByaXRlc1tjaGFyXS5vcGFjaXR5KG9wdGlvbnMub3BhY2l0eSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX3RleHRTaGFkb3dPbiAmJiB0aGlzLl90ZXh0U2hhZG93RGlydHkgJiYgdGhpcy5fdGV4dFNoYWRvd0NvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjaGFyYWN0ZXJTaGFkb3cgaW4gdGhpcy5fdGV4dFNoYWRvd1Nwcml0ZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0U2hhZG93U3ByaXRlc1tjaGFyYWN0ZXJTaGFkb3ddLmNsZWFyRWZmZWN0cygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RleHRTaGFkb3dTcHJpdGVzW2NoYXJhY3RlclNoYWRvd10uYWRkRWZmZWN0KG5ldyBFZmZlY3RzLkZpbGwodGhpcy5fdGV4dFNoYWRvd0NvbG9yLmNsb25lKCkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3RleHRTaGFkb3dEaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGZpbmQgdGhlIGN1cnJlbnQgbGVuZ3RoIG9mIHRleHQgaW4gcGl4ZWxzXHJcbiAgICAgICAgICAgIHZhciBzcHJpdGUgPSB0aGlzLnNwcml0ZXNbMF07XHJcbiAgICAgICAgICAgIC8vIGZpbmQgdGhlIGN1cnJlbnQgaGVpZ2h0IGZvIHRoZSB0ZXh0IGluIHBpeGVsc1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gc3ByaXRlLnNoZWlnaHQ7XHJcbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBhcHByb3ByaWF0ZSBzY2FsZSBmb3IgZm9udCBzaXplXHJcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IG9wdGlvbnMuZm9udFNpemUgLyBoZWlnaHQ7XHJcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSAodGV4dC5sZW5ndGggKiBzcHJpdGUuc3dpZHRoICogc2NhbGUpICsgKHRleHQubGVuZ3RoICogb3B0aW9ucy5sZXR0ZXJTcGFjaW5nKTtcclxuICAgICAgICAgICAgdmFyIGN1cnJYID0geDtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMudGV4dEFsaWduID09PSBMYWJlbF8xLlRleHRBbGlnbi5MZWZ0IHx8IG9wdGlvbnMudGV4dEFsaWduID09PSBMYWJlbF8xLlRleHRBbGlnbi5TdGFydCkge1xyXG4gICAgICAgICAgICAgICAgY3VyclggPSB4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMudGV4dEFsaWduID09PSBMYWJlbF8xLlRleHRBbGlnbi5SaWdodCB8fCBvcHRpb25zLnRleHRBbGlnbiA9PT0gTGFiZWxfMS5UZXh0QWxpZ24uRW5kKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyWCA9IHggLSBsZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy50ZXh0QWxpZ24gPT09IExhYmVsXzEuVGV4dEFsaWduLkNlbnRlcikge1xyXG4gICAgICAgICAgICAgICAgY3VyclggPSB4IC0gbGVuZ3RoIC8gMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY3VyclkgPSB5IC0gaGVpZ2h0ICogc2NhbGU7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmJhc2VBbGlnbiA9PT0gTGFiZWxfMS5CYXNlQWxpZ24uVG9wIHx8IG9wdGlvbnMuYmFzZUFsaWduID09PSBMYWJlbF8xLkJhc2VBbGlnbi5IYW5naW5nKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyWSA9IHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5iYXNlQWxpZ24gPT09IExhYmVsXzEuQmFzZUFsaWduLklkZW9ncmFwaGljIHx8XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmJhc2VBbGlnbiA9PT0gTGFiZWxfMS5CYXNlQWxpZ24uQm90dG9tIHx8XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmJhc2VBbGlnbiA9PT0gTGFiZWxfMS5CYXNlQWxpZ24uQWxwaGFiZXRpYykge1xyXG4gICAgICAgICAgICAgICAgY3VyclkgPSB5IC0gaGVpZ2h0ICogc2NhbGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5iYXNlQWxpZ24gPT09IExhYmVsXzEuQmFzZUFsaWduLk1pZGRsZSkge1xyXG4gICAgICAgICAgICAgICAgY3VyclkgPSB5IC0gKGhlaWdodCAqIHNjYWxlKSAvIDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2hhcmFjdGVyID0gdGV4dFtpXTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jYXNlSW5zZW5zaXRpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFyYWN0ZXIgPSBjaGFyYWN0ZXIudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGV4dCBzaGFkb3dcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdGV4dFNoYWRvd09uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RleHRTaGFkb3dTcHJpdGVzW2NoYXJhY3Rlcl0uc2NhbGUueCA9IHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0U2hhZG93U3ByaXRlc1tjaGFyYWN0ZXJdLnNjYWxlLnkgPSBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGV4dFNoYWRvd1Nwcml0ZXNbY2hhcmFjdGVyXS5kcmF3KGN0eCwgY3VyclggKyB0aGlzLl9zaGFkb3dPZmZzZXRYLCBjdXJyWSArIHRoaXMuX3NoYWRvd09mZnNldFkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhclNwcml0ZSA9IHRoaXMuX3Nwcml0ZXNbY2hhcmFjdGVyXTtcclxuICAgICAgICAgICAgICAgICAgICBjaGFyU3ByaXRlLnNjYWxlLnggPSBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICBjaGFyU3ByaXRlLnNjYWxlLnkgPSBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICBjaGFyU3ByaXRlLmRyYXcoY3R4LCBjdXJyWCwgY3VyclkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJYICs9IChjaGFyU3ByaXRlLndpZHRoICsgb3B0aW9ucy5sZXR0ZXJTcGFjaW5nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgTG9nXzQuTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoXCJTcHJpdGVGb250IEVycm9yIGRyYXdpbmcgY2hhciBcIiArIGNoYXJhY3Rlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFNwcml0ZUZvbnRJbXBsLnByb3RvdHlwZS5fcGFyc2VPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiBvcHRpb25zLmZvbnRTaXplIHx8IDEwLFxyXG4gICAgICAgICAgICAgICAgbGV0dGVyU3BhY2luZzogb3B0aW9ucy5sZXR0ZXJTcGFjaW5nIHx8IDAsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogb3B0aW9ucy5jb2xvciB8fCBDb2xvcl8xMC5Db2xvci5CbGFjay5jbG9uZSgpLFxyXG4gICAgICAgICAgICAgICAgdGV4dEFsaWduOiB0eXBlb2Ygb3B0aW9ucy50ZXh0QWxpZ24gPT09IHVuZGVmaW5lZCA/IExhYmVsXzEuVGV4dEFsaWduLkxlZnQgOiBvcHRpb25zLnRleHRBbGlnbixcclxuICAgICAgICAgICAgICAgIGJhc2VBbGlnbjogdHlwZW9mIG9wdGlvbnMuYmFzZUFsaWduID09PSB1bmRlZmluZWQgPyBMYWJlbF8xLkJhc2VBbGlnbi5Cb3R0b20gOiBvcHRpb25zLmJhc2VBbGlnbixcclxuICAgICAgICAgICAgICAgIG1heFdpZHRoOiBvcHRpb25zLm1heFdpZHRoIHx8IC0xLFxyXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogb3B0aW9ucy5vcGFjaXR5IHx8IDBcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBTcHJpdGVGb250SW1wbDtcclxuICAgIH0oU3ByaXRlU2hlZXQpKTtcclxuICAgIGV4cG9ydHMuU3ByaXRlRm9udEltcGwgPSBTcHJpdGVGb250SW1wbDtcclxuICAgIC8qKlxyXG4gICAgICogU3ByaXRlIGZvbnRzIGFyZSBhIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBhIFtbTGFiZWxdXSB0byBzcGVjaWZ5XHJcbiAgICAgKiBhIHBhcnRpY3VsYXIgYml0bWFwIGFzIGEgZm9udC4gTm90ZSB0aGF0IHNvbWUgZm9udCBmZWF0dXJlcyBhcmUgbm90XHJcbiAgICAgKiBzdXBwb3J0ZWQgYnkgU3ByaXRlIGZvbnRzLlxyXG4gICAgICpcclxuICAgICAqIFtbaW5jbHVkZTpTcHJpdGVGb250cy5tZF1dXHJcbiAgICAgKi9cclxuICAgIHZhciBTcHJpdGVGb250ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoU3ByaXRlRm9udCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBTcHJpdGVGb250KGltYWdlT3JDb25maWcsIGFscGhhYmV0LCBjYXNlSW5zZW5zaXRpdmUsIGNvbHVtbnMsIHJvd3MsIHNwV2lkdGgsIHNwSGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBpbWFnZU9yQ29uZmlnLCBhbHBoYWJldCwgY2FzZUluc2Vuc2l0aXZlLCBjb2x1bW5zLCByb3dzLCBzcFdpZHRoLCBzcEhlaWdodCkgfHwgdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFNwcml0ZUZvbnQ7XHJcbiAgICB9KENvbmZpZ3VyYWJsZV8zLkNvbmZpZ3VyYWJsZShTcHJpdGVGb250SW1wbCkpKTtcclxuICAgIGV4cG9ydHMuU3ByaXRlRm9udCA9IFNwcml0ZUZvbnQ7XHJcbn0pO1xyXG5kZWZpbmUoXCJMYWJlbFwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkRyYXdpbmcvQ29sb3JcIiwgXCJBY3RvclwiLCBcIkNvbmZpZ3VyYWJsZVwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIENvbG9yXzExLCBBY3Rvcl80LCBDb25maWd1cmFibGVfNCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEVudW0gcmVwcmVzZW50aW5nIHRoZSBkaWZmZXJlbnQgZm9udCBzaXplIHVuaXRzXHJcbiAgICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvZm9udC1zaXplXHJcbiAgICAgKi9cclxuICAgIHZhciBGb250VW5pdDtcclxuICAgIChmdW5jdGlvbiAoRm9udFVuaXQpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbSBpcyBhIHNjYWxhYmxlIHVuaXQsIDEgZW0gaXMgZXF1YWwgdG8gdGhlIGN1cnJlbnQgZm9udCBzaXplIG9mIHRoZSBjdXJyZW50IGVsZW1lbnQsIHBhcmVudCBlbGVtZW50cyBjYW4gZWZmZWN0IGVtIHZhbHVlc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEZvbnRVbml0W0ZvbnRVbml0W1wiRW1cIl0gPSAwXSA9IFwiRW1cIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW0gaXMgc2ltaWxhciB0byB0aGUgRW0sIGl0IGlzIGEgc2NhbGFibGUgdW5pdC4gMSByZW0gaXMgZXFhdWwgdG8gdGhlIGZvbnQgc2l6ZSBvZiB0aGUgcm9vdCBlbGVtZW50XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRm9udFVuaXRbRm9udFVuaXRbXCJSZW1cIl0gPSAxXSA9IFwiUmVtXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGl4ZWwgaXMgYSB1bml0IG9mIGxlbmd0aCBpbiBzY3JlZW4gcGl4ZWxzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRm9udFVuaXRbRm9udFVuaXRbXCJQeFwiXSA9IDJdID0gXCJQeFwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBvaW50IGlzIGEgcGh5c2ljYWwgdW5pdCBsZW5ndGggKDEvNzIgb2YgYW4gaW5jaClcclxuICAgICAgICAgKi9cclxuICAgICAgICBGb250VW5pdFtGb250VW5pdFtcIlB0XCJdID0gM10gPSBcIlB0XCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGVyY2VudCBpcyBhIHNjYWxhYmxlIHVuaXQgc2ltaWxhciB0byBFbSwgdGhlIG9ubHkgZGlmZmVyZW5jZSBpcyB0aGUgRW0gdW5pdHMgc2NhbGUgZmFzdGVyIHdoZW4gVGV4dC1TaXplIHN0dWZmXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRm9udFVuaXRbRm9udFVuaXRbXCJQZXJjZW50XCJdID0gNF0gPSBcIlBlcmNlbnRcIjtcclxuICAgIH0pKEZvbnRVbml0ID0gZXhwb3J0cy5Gb250VW5pdCB8fCAoZXhwb3J0cy5Gb250VW5pdCA9IHt9KSk7XHJcbiAgICAvKipcclxuICAgICAqIEVudW0gcmVwcmVzZW50aW5nIHRoZSBkaWZmZXJlbnQgaG9yaXpvbnRhbCB0ZXh0IGFsaWdubWVudHNcclxuICAgICAqL1xyXG4gICAgdmFyIFRleHRBbGlnbjtcclxuICAgIChmdW5jdGlvbiAoVGV4dEFsaWduKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHRleHQgaXMgbGVmdC1hbGlnbmVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRleHRBbGlnbltUZXh0QWxpZ25bXCJMZWZ0XCJdID0gMF0gPSBcIkxlZnRcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdGV4dCBpcyByaWdodC1hbGlnbmVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRleHRBbGlnbltUZXh0QWxpZ25bXCJSaWdodFwiXSA9IDFdID0gXCJSaWdodFwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0ZXh0IGlzIGNlbnRlcmVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRleHRBbGlnbltUZXh0QWxpZ25bXCJDZW50ZXJcIl0gPSAyXSA9IFwiQ2VudGVyXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHRleHQgaXMgYWxpZ25lZCBhdCB0aGUgbm9ybWFsIHN0YXJ0IG9mIHRoZSBsaW5lIChsZWZ0LWFsaWduZWQgZm9yIGxlZnQtdG8tcmlnaHQgbG9jYWxlcyxcclxuICAgICAgICAgKiByaWdodC1hbGlnbmVkIGZvciByaWdodC10by1sZWZ0IGxvY2FsZXMpLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRleHRBbGlnbltUZXh0QWxpZ25bXCJTdGFydFwiXSA9IDNdID0gXCJTdGFydFwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0ZXh0IGlzIGFsaWduZWQgYXQgdGhlIG5vcm1hbCBlbmQgb2YgdGhlIGxpbmUgKHJpZ2h0LWFsaWduZWQgZm9yIGxlZnQtdG8tcmlnaHQgbG9jYWxlcyxcclxuICAgICAgICAgKiBsZWZ0LWFsaWduZWQgZm9yIHJpZ2h0LXRvLWxlZnQgbG9jYWxlcykuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVGV4dEFsaWduW1RleHRBbGlnbltcIkVuZFwiXSA9IDRdID0gXCJFbmRcIjtcclxuICAgIH0pKFRleHRBbGlnbiA9IGV4cG9ydHMuVGV4dEFsaWduIHx8IChleHBvcnRzLlRleHRBbGlnbiA9IHt9KSk7XHJcbiAgICAvKipcclxuICAgICAqIEVudW0gcmVwcmVzZW50aW5nIHRoZSBkaWZmZXJlbnQgYmFzZWxpbmUgdGV4dCBhbGlnbm1lbnRzXHJcbiAgICAgKi9cclxuICAgIHZhciBCYXNlQWxpZ247XHJcbiAgICAoZnVuY3Rpb24gKEJhc2VBbGlnbikge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0ZXh0IGJhc2VsaW5lIGlzIHRoZSB0b3Agb2YgdGhlIGVtIHNxdWFyZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBCYXNlQWxpZ25bQmFzZUFsaWduW1wiVG9wXCJdID0gMF0gPSBcIlRvcFwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0ZXh0IGJhc2VsaW5lIGlzIHRoZSBoYW5naW5nIGJhc2VsaW5lLiAgQ3VycmVudGx5IHVuc3VwcG9ydGVkOyB0aGlzIHdpbGwgYWN0IGxpa2VcclxuICAgICAgICAgKiBhbHBoYWJldGljLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJhc2VBbGlnbltCYXNlQWxpZ25bXCJIYW5naW5nXCJdID0gMV0gPSBcIkhhbmdpbmdcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdGV4dCBiYXNlbGluZSBpcyB0aGUgbWlkZGxlIG9mIHRoZSBlbSBzcXVhcmUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQmFzZUFsaWduW0Jhc2VBbGlnbltcIk1pZGRsZVwiXSA9IDJdID0gXCJNaWRkbGVcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdGV4dCBiYXNlbGluZSBpcyB0aGUgbm9ybWFsIGFscGhhYmV0aWMgYmFzZWxpbmUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQmFzZUFsaWduW0Jhc2VBbGlnbltcIkFscGhhYmV0aWNcIl0gPSAzXSA9IFwiQWxwaGFiZXRpY1wiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0ZXh0IGJhc2VsaW5lIGlzIHRoZSBpZGVvZ3JhcGhpYyBiYXNlbGluZTsgdGhpcyBpcyB0aGUgYm90dG9tIG9mXHJcbiAgICAgICAgICogdGhlIGJvZHkgb2YgdGhlIGNoYXJhY3RlcnMsIGlmIHRoZSBtYWluIGJvZHkgb2YgY2hhcmFjdGVycyBwcm90cnVkZXNcclxuICAgICAgICAgKiBiZW5lYXRoIHRoZSBhbHBoYWJldGljIGJhc2VsaW5lLiAgQ3VycmVudGx5IHVuc3VwcG9ydGVkOyB0aGlzIHdpbGxcclxuICAgICAgICAgKiBhY3QgbGlrZSBhbHBoYWJldGljLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJhc2VBbGlnbltCYXNlQWxpZ25bXCJJZGVvZ3JhcGhpY1wiXSA9IDRdID0gXCJJZGVvZ3JhcGhpY1wiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0ZXh0IGJhc2VsaW5lIGlzIHRoZSBib3R0b20gb2YgdGhlIGJvdW5kaW5nIGJveC4gIFRoaXMgZGlmZmVyc1xyXG4gICAgICAgICAqIGZyb20gdGhlIGlkZW9ncmFwaGljIGJhc2VsaW5lIGluIHRoYXQgdGhlIGlkZW9ncmFwaGljIGJhc2VsaW5lXHJcbiAgICAgICAgICogZG9lc24ndCBjb25zaWRlciBkZXNjZW5kZXJzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJhc2VBbGlnbltCYXNlQWxpZ25bXCJCb3R0b21cIl0gPSA1XSA9IFwiQm90dG9tXCI7XHJcbiAgICB9KShCYXNlQWxpZ24gPSBleHBvcnRzLkJhc2VBbGlnbiB8fCAoZXhwb3J0cy5CYXNlQWxpZ24gPSB7fSkpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFbnVtIHJlcHJlc2VudGluZyB0aGUgZGlmZmVyZW50IHBvc3NpYmxlIGZvbnQgc3R5bGVzXHJcbiAgICAgKi9cclxuICAgIHZhciBGb250U3R5bGU7XHJcbiAgICAoZnVuY3Rpb24gKEZvbnRTdHlsZSkge1xyXG4gICAgICAgIEZvbnRTdHlsZVtGb250U3R5bGVbXCJOb3JtYWxcIl0gPSAwXSA9IFwiTm9ybWFsXCI7XHJcbiAgICAgICAgRm9udFN0eWxlW0ZvbnRTdHlsZVtcIkl0YWxpY1wiXSA9IDFdID0gXCJJdGFsaWNcIjtcclxuICAgICAgICBGb250U3R5bGVbRm9udFN0eWxlW1wiT2JsaXF1ZVwiXSA9IDJdID0gXCJPYmxpcXVlXCI7XHJcbiAgICB9KShGb250U3R5bGUgPSBleHBvcnRzLkZvbnRTdHlsZSB8fCAoZXhwb3J0cy5Gb250U3R5bGUgPSB7fSkpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaGlkZGVuXHJcbiAgICAgKi9cclxuICAgIHZhciBMYWJlbEltcGwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhMYWJlbEltcGwsIF9zdXBlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHRleHQgICAgICAgIFRoZSB0ZXh0IG9mIHRoZSBsYWJlbFxyXG4gICAgICAgICAqIEBwYXJhbSB4ICAgICAgICAgICBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgbGFiZWxcclxuICAgICAgICAgKiBAcGFyYW0geSAgICAgICAgICAgVGhlIHkgcG9zaXRpb24gb2YgdGhlIGxhYmVsXHJcbiAgICAgICAgICogQHBhcmFtIGZvbnRGYW1pbHkgIFVzZSBhbnkgdmFsaWQgQ1NTIGZvbnQgc3RyaW5nIGZvciB0aGUgbGFiZWwncyBmb250LiBXZWIgZm9udHMgYXJlIHN1cHBvcnRlZC4gRGVmYXVsdCBpcyBgMTBweCBzYW5zLXNlcmlmYC5cclxuICAgICAgICAgKiBAcGFyYW0gc3ByaXRlRm9udCAgVXNlIGFuIEV4Y2FsaWJ1ciBzcHJpdGUgZm9udCBmb3IgdGhlIGxhYmVsJ3MgZm9udCwgaWYgYSBTcHJpdGVGb250IGlzIHByb3ZpZGVkIGl0IHdpbGwgdGFrZSBwcmVjZWRlbmNlXHJcbiAgICAgICAgICogb3ZlciBhIGNzcyBmb250LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIExhYmVsSW1wbCh0ZXh0T3JDb25maWcsIHgsIHksIGZvbnRGYW1pbHksIHNwcml0ZUZvbnQpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdGV4dE9yQ29uZmlnICYmIHR5cGVvZiB0ZXh0T3JDb25maWcgPT09ICdvYmplY3QnID8ge1xyXG4gICAgICAgICAgICAgICAgeDogdGV4dE9yQ29uZmlnLngsXHJcbiAgICAgICAgICAgICAgICB5OiB0ZXh0T3JDb25maWcueVxyXG4gICAgICAgICAgICB9IDogeyB4OiB4LCB5OiB5IH0pIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXRzIG9yIGdldHMgdGhlIGJvbGQgcHJvcGVydHkgb2YgdGhlIGxhYmVsJ3MgdGV4dCwgYnkgZGVmYXVsdCBpdCdzIGZhbHNlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5ib2xkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgZm9udCBzaXplIGluIHRoZSBzZWxlY3RlZCB1bml0cywgZGVmYXVsdCBpcyAxMCAoZGVmYXVsdCB1bml0cyBpcyBwaXhlbClcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmZvbnRTaXplID0gMTA7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgZm9udCBzdHlsZSBmb3IgdGhpcyBsYWJlbCwgdGhlIGRlZmF1bHQgaXMgW1tGb250U3R5bGUuTm9ybWFsXV1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmZvbnRTdHlsZSA9IEZvbnRTdHlsZS5Ob3JtYWw7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgY3NzIHVuaXRzIGZvciBhIGZvbnQgc2l6ZSBzdWNoIGFzIHB4LCBwdCwgZW0gKFNwcml0ZUZvbnQgb25seSBzdXBwb3J0IHB4KSwgYnkgZGVmYXVsdCBpcyAncHgnO1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuZm9udFVuaXQgPSBGb250VW5pdC5QeDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgaG9yaXpvbnRhbCB0ZXh0IGFsaWdubWVudCBwcm9wZXJ0eSBmb3IgdGhlIGxhYmVsLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMudGV4dEFsaWduID0gVGV4dEFsaWduLkxlZnQ7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGJhc2VsaW5lIGFsaWdubWVudCBwcm9wZXJ0eSBmb3IgdGhlIGxhYmVsLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuYmFzZUFsaWduID0gQmFzZUFsaWduLkJvdHRvbTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbGV0dGVyIHNwYWNpbmcgb24gYSBMYWJlbC4gT25seSBzdXBwb3J0ZWQgd2l0aCBTcHJpdGUgRm9udHMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5sZXR0ZXJTcGFjaW5nID0gMDsgLy9weFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIFtbU3ByaXRlRm9udF1dIHdpbGwgYmUgY2FzZS1zZW5zaXRpdmUgd2hlbiBtYXRjaGluZyBjaGFyYWN0ZXJzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuY2FzZUluc2Vuc2l0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgdmFyIHRleHQgPSAnJztcclxuICAgICAgICAgICAgaWYgKHRleHRPckNvbmZpZyAmJiB0eXBlb2YgdGV4dE9yQ29uZmlnID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgZm9udEZhbWlseSA9IHRleHRPckNvbmZpZy5mb250RmFtaWx5O1xyXG4gICAgICAgICAgICAgICAgc3ByaXRlRm9udCA9IHRleHRPckNvbmZpZy5zcHJpdGVGb250O1xyXG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHRPckNvbmZpZy50ZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHRPckNvbmZpZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy50ZXh0ID0gdGV4dCB8fCAnJztcclxuICAgICAgICAgICAgX3RoaXMuY29sb3IgPSBDb2xvcl8xMS5Db2xvci5CbGFjay5jbG9uZSgpO1xyXG4gICAgICAgICAgICBfdGhpcy5zcHJpdGVGb250ID0gc3ByaXRlRm9udDtcclxuICAgICAgICAgICAgX3RoaXMuY29sbGlzaW9uVHlwZSA9IEFjdG9yXzQuQ29sbGlzaW9uVHlwZS5QcmV2ZW50Q29sbGlzaW9uO1xyXG4gICAgICAgICAgICBfdGhpcy5mb250RmFtaWx5ID0gZm9udEZhbWlseSB8fCAnc2Fucy1zZXJpZic7IC8vIGNvYWxlc2NlIHRvIGRlZmF1bHQgY2FudmFzIGZvbnRcclxuICAgICAgICAgICAgX3RoaXMuX3RleHRTaGFkb3dPbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICBfdGhpcy5fc2hhZG93T2Zmc2V0WCA9IDA7XHJcbiAgICAgICAgICAgIF90aGlzLl9zaGFkb3dPZmZzZXRZID0gMDtcclxuICAgICAgICAgICAgaWYgKHNwcml0ZUZvbnQpIHtcclxuICAgICAgICAgICAgICAgIC8vdGhpcy5fdGV4dFNwcml0ZXMgPSBzcHJpdGVGb250LmdldFRleHRTcHJpdGVzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgdGV4dCBpbiB0aGUgbGFiZWwgKGluIHBpeGVscyk7XHJcbiAgICAgICAgICogQHBhcmFtIGN0eCAgUmVuZGVyaW5nIGNvbnRleHQgdG8gbWVhc3VyZSB0aGUgc3RyaW5nIHdpdGhcclxuICAgICAgICAgKi9cclxuICAgICAgICBMYWJlbEltcGwucHJvdG90eXBlLmdldFRleHRXaWR0aCA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICAgICAgICAgICAgdmFyIG9sZEZvbnQgPSBjdHguZm9udDtcclxuICAgICAgICAgICAgY3R4LmZvbnQgPSB0aGlzLl9mb250U3RyaW5nO1xyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSBjdHgubWVhc3VyZVRleHQodGhpcy50ZXh0KS53aWR0aDtcclxuICAgICAgICAgICAgY3R4LmZvbnQgPSBvbGRGb250O1xyXG4gICAgICAgICAgICByZXR1cm4gd2lkdGg7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBUeXBlU2NyaXB0IGRvZXNuJ3Qgc3VwcG9ydCBzdHJpbmcgZW51bXMgOihcclxuICAgICAgICBMYWJlbEltcGwucHJvdG90eXBlLl9sb29rdXBGb250VW5pdCA9IGZ1bmN0aW9uIChmb250VW5pdCkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGZvbnRVbml0KSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEZvbnRVbml0LkVtOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnZW0nO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBGb250VW5pdC5SZW06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdyZW0nO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBGb250VW5pdC5QdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3B0JztcclxuICAgICAgICAgICAgICAgIGNhc2UgRm9udFVuaXQuUHg6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdweCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEZvbnRVbml0LlBlcmNlbnQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICclJztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdweCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIExhYmVsSW1wbC5wcm90b3R5cGUuX2xvb2t1cFRleHRBbGlnbiA9IGZ1bmN0aW9uICh0ZXh0QWxpZ24pIHtcclxuICAgICAgICAgICAgc3dpdGNoICh0ZXh0QWxpZ24pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgVGV4dEFsaWduLkxlZnQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdsZWZ0JztcclxuICAgICAgICAgICAgICAgIGNhc2UgVGV4dEFsaWduLlJpZ2h0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAncmlnaHQnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBUZXh0QWxpZ24uQ2VudGVyOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnY2VudGVyJztcclxuICAgICAgICAgICAgICAgIGNhc2UgVGV4dEFsaWduLkVuZDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2VuZCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFRleHRBbGlnbi5TdGFydDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3N0YXJ0JztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdzdGFydCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIExhYmVsSW1wbC5wcm90b3R5cGUuX2xvb2t1cEJhc2VBbGlnbiA9IGZ1bmN0aW9uIChiYXNlQWxpZ24pIHtcclxuICAgICAgICAgICAgc3dpdGNoIChiYXNlQWxpZ24pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgQmFzZUFsaWduLkFscGhhYmV0aWM6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdhbHBoYWJldGljJztcclxuICAgICAgICAgICAgICAgIGNhc2UgQmFzZUFsaWduLkJvdHRvbTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2JvdHRvbSc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEJhc2VBbGlnbi5IYW5naW5nOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnaGFuZ2luJztcclxuICAgICAgICAgICAgICAgIGNhc2UgQmFzZUFsaWduLklkZW9ncmFwaGljOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnaWRlb2dyYXBoaWMnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBCYXNlQWxpZ24uTWlkZGxlOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnbWlkZGxlJztcclxuICAgICAgICAgICAgICAgIGNhc2UgQmFzZUFsaWduLlRvcDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RvcCc7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnYWxwaGFiZXRpYyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIExhYmVsSW1wbC5wcm90b3R5cGUuX2xvb2t1cEZvbnRTdHlsZSA9IGZ1bmN0aW9uIChmb250U3R5bGUpIHtcclxuICAgICAgICAgICAgdmFyIGJvbGRzdHJpbmcgPSB0aGlzLmJvbGQgPyAnIGJvbGQnIDogJyc7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoZm9udFN0eWxlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEZvbnRTdHlsZS5JdGFsaWM6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdpdGFsaWMnICsgYm9sZHN0cmluZztcclxuICAgICAgICAgICAgICAgIGNhc2UgRm9udFN0eWxlLk5vcm1hbDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ25vcm1hbCcgKyBib2xkc3RyaW5nO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBGb250U3R5bGUuT2JsaXF1ZTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ29ibGlxdWUnICsgYm9sZHN0cmluZztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdub3JtYWwnICsgYm9sZHN0cmluZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgdGV4dCBzaGFkb3cgZm9yIHNwcml0ZSBmb250c1xyXG4gICAgICAgICAqIEBwYXJhbSBvZmZzZXRYICAgICAgVGhlIHggb2Zmc2V0IGluIHBpeGVscyB0byBwbGFjZSB0aGUgc2hhZG93XHJcbiAgICAgICAgICogQHBhcmFtIG9mZnNldFkgICAgICBUaGUgeSBvZmZzZXQgaW4gcGl4ZWxzIHRvIHBsYWNlIHRoZSBzaGFkb3dcclxuICAgICAgICAgKiBAcGFyYW0gc2hhZG93Q29sb3IgIFRoZSBjb2xvciBvZiB0aGUgdGV4dCBzaGFkb3dcclxuICAgICAgICAgKi9cclxuICAgICAgICBMYWJlbEltcGwucHJvdG90eXBlLnNldFRleHRTaGFkb3cgPSBmdW5jdGlvbiAob2Zmc2V0WCwgb2Zmc2V0WSwgc2hhZG93Q29sb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGVGb250LnNldFRleHRTaGFkb3cob2Zmc2V0WCwgb2Zmc2V0WSwgc2hhZG93Q29sb3IpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVG9nZ2xlcyB0ZXh0IHNoYWRvd3Mgb24gb3Igb2ZmLCBvbmx5IGFwcGxpZXMgd2hlbiB1c2luZyBzcHJpdGUgZm9udHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBMYWJlbEltcGwucHJvdG90eXBlLnVzZVRleHRTaGFkb3cgPSBmdW5jdGlvbiAob24pIHtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGVGb250LnVzZVRleHRTaGFkb3cob24pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2xlYXJzIHRoZSBjdXJyZW50IHRleHQgc2hhZG93XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGFiZWxJbXBsLnByb3RvdHlwZS5jbGVhclRleHRTaGFkb3cgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RleHRTaGFkb3dPbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9zaGFkb3dPZmZzZXRYID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fc2hhZG93T2Zmc2V0WSA9IDA7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBMYWJlbEltcGwucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChlbmdpbmUsIGRlbHRhKSB7XHJcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcywgZW5naW5lLCBkZWx0YSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBMYWJlbEltcGwucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoY3R4LCBkZWx0YSkge1xyXG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKHRoaXMucG9zLngsIHRoaXMucG9zLnkpO1xyXG4gICAgICAgICAgICBjdHguc2NhbGUodGhpcy5zY2FsZS54LCB0aGlzLnNjYWxlLnkpO1xyXG4gICAgICAgICAgICBjdHgucm90YXRlKHRoaXMucm90YXRpb24pO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fdGV4dFNoYWRvd09uKSB7XHJcbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLl9zaGFkb3dPZmZzZXRYLCB0aGlzLl9zaGFkb3dPZmZzZXRZKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZvbnREcmF3KGN0eCk7XHJcbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2ZvbnREcmF3KGN0eCk7XHJcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZHJhdy5jYWxsKHRoaXMsIGN0eCwgZGVsdGEpO1xyXG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgTGFiZWxJbXBsLnByb3RvdHlwZS5fZm9udERyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNwcml0ZUZvbnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlRm9udC5kcmF3KGN0eCwgdGhpcy50ZXh0LCAwLCAwLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IHRoaXMuY29sb3IuY2xvbmUoKSxcclxuICAgICAgICAgICAgICAgICAgICBiYXNlQWxpZ246IHRoaXMuYmFzZUFsaWduLFxyXG4gICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogdGhpcy50ZXh0QWxpZ24sXHJcbiAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IHRoaXMuZm9udFNpemUsXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0dGVyU3BhY2luZzogdGhpcy5sZXR0ZXJTcGFjaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IHRoaXMub3BhY2l0eVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2xkQWxpZ24gPSBjdHgudGV4dEFsaWduO1xyXG4gICAgICAgICAgICAgICAgdmFyIG9sZFRleHRCYXNlbGluZSA9IGN0eC50ZXh0QmFzZWxpbmU7XHJcbiAgICAgICAgICAgICAgICBjdHgudGV4dEFsaWduID0gdGhpcy5fbG9va3VwVGV4dEFsaWduKHRoaXMudGV4dEFsaWduKTtcclxuICAgICAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSB0aGlzLl9sb29rdXBCYXNlQWxpZ24odGhpcy5iYXNlQWxpZ24pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29sb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbG9yLmEgPSB0aGlzLm9wYWNpdHk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5jb2xvci50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgY3R4LmZvbnQgPSB0aGlzLl9mb250U3RyaW5nO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWF4V2lkdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQodGhpcy50ZXh0LCAwLCAwLCB0aGlzLm1heFdpZHRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dCh0aGlzLnRleHQsIDAsIDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IG9sZEFsaWduO1xyXG4gICAgICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IG9sZFRleHRCYXNlbGluZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExhYmVsSW1wbC5wcm90b3R5cGUsIFwiX2ZvbnRTdHJpbmdcIiwge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb29rdXBGb250U3R5bGUodGhpcy5mb250U3R5bGUpICsgXCIgXCIgKyB0aGlzLmZvbnRTaXplICsgdGhpcy5fbG9va3VwRm9udFVuaXQodGhpcy5mb250VW5pdCkgKyBcIiBcIiArIHRoaXMuZm9udEZhbWlseTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgTGFiZWxJbXBsLnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGVidWdEcmF3LmNhbGwodGhpcywgY3R4KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBMYWJlbEltcGw7XHJcbiAgICB9KEFjdG9yXzQuQWN0b3IpKTtcclxuICAgIGV4cG9ydHMuTGFiZWxJbXBsID0gTGFiZWxJbXBsO1xyXG4gICAgLyoqXHJcbiAgICAgKiBMYWJlbHMgYXJlIHRoZSB3YXkgdG8gZHJhdyBzbWFsbCBhbW91bnRzIG9mIHRleHQgdG8gdGhlIHNjcmVlbi4gVGhleSBhcmVcclxuICAgICAqIGFjdG9ycyBhbmQgaW5oZXJpdCBhbGwgb2YgdGhlIGJlbmVmaXRzIGFuZCBjYXBhYmlsaXRpZXMuXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOkxhYmVscy5tZF1dXHJcbiAgICAgKi9cclxuICAgIHZhciBMYWJlbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKExhYmVsLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIExhYmVsKHRleHRPckNvbmZpZywgeCwgeSwgZm9udEZhbWlseSwgc3ByaXRlRm9udCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgdGV4dE9yQ29uZmlnLCB4LCB5LCBmb250RmFtaWx5LCBzcHJpdGVGb250KSB8fCB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gTGFiZWw7XHJcbiAgICB9KENvbmZpZ3VyYWJsZV80LkNvbmZpZ3VyYWJsZShMYWJlbEltcGwpKSk7XHJcbiAgICBleHBvcnRzLkxhYmVsID0gTGFiZWw7XHJcbn0pO1xyXG5kZWZpbmUoXCJJbnRlcmZhY2VzL0lBdWRpb1wiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG59KTtcclxuZGVmaW5lKFwiSW50ZXJmYWNlcy9JQXVkaW9JbXBsZW1lbnRhdGlvblwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG59KTtcclxuZGVmaW5lKFwiUmVzb3VyY2VzL1NvdW5kXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiVXRpbC9Mb2dcIiwgXCJVdGlsL1V0aWxcIiwgXCJQcm9taXNlc1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIExvZ181LCBVdGlsLCBQcm9taXNlc181KSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8vIHNldCB1cCBhdWRpbyBjb250ZXh0IHJlZmVyZW5jZVxyXG4gICAgLy8gd2hlbiB3ZSBpbnRyb2R1Y2UgbXVsdGktdHJhY2tpbmcsIHdlIG1heSBuZWVkIHRvIG1vdmUgdGhpcyB0byBhIGZhY3RvcnkgbWV0aG9kXHJcbiAgICBpZiAod2luZG93LkF1ZGlvQ29udGV4dCkge1xyXG4gICAgICAgIHZhciBhdWRpb0NvbnRleHQgPSBuZXcgd2luZG93LkF1ZGlvQ29udGV4dCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhdWRpbyBpbXBsZW1lbnRhdGlvbiBmb3IgSFRNTDUgYXVkaW8uXHJcbiAgICAgKi9cclxuICAgIHZhciBBdWRpb1RhZyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gQXVkaW9UYWcoKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzcG9uc2VUeXBlID0gJ2Jsb2InO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUcmFuc2Zvcm1zIHJhdyBCbG9iIGRhdGEgaW50byBhIG9iamVjdCBVUkwgZm9yIHVzZSBpbiBhdWRpbyB0YWdcclxuICAgICAgICAgKi9cclxuICAgICAgICBBdWRpb1RhZy5wcm90b3R5cGUucHJvY2Vzc0RhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChkYXRhKTtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2VzXzUuUHJvbWlzZS5yZXNvbHZlKHVybCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGFuIGF1ZGlvIHRhZyByZWZlcmVuY2luZyB0aGUgcHJvdmlkZWQgYXVkaW8gVVJMXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQXVkaW9UYWcucHJvdG90eXBlLmNyZWF0ZUluc3RhbmNlID0gZnVuY3Rpb24gKHVybCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEF1ZGlvVGFnSW5zdGFuY2UodXJsKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBBdWRpb1RhZztcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkF1ZGlvVGFnID0gQXVkaW9UYWc7XHJcbiAgICAvKipcclxuICAgICAqIEFuIGF1ZGlvIGltcGxlbWVudGF0aW9uIGZvciBXZWIgQXVkaW8gQVBJLlxyXG4gICAgICovXHJcbiAgICB2YXIgV2ViQXVkaW8gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIFdlYkF1ZGlvKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIgPSBMb2dfNS5Mb2dnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgdGhpcy5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcm9jZXNzZXMgcmF3IGFycmF5YnVmZmVyIGRhdGEgYW5kIGRlY29kZXMgaW50byBXZWJBdWRpbyBidWZmZXIgKGFzeW5jKS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBXZWJBdWRpby5wcm90b3R5cGUucHJvY2Vzc0RhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgY29tcGxldGUgPSBuZXcgUHJvbWlzZXNfNS5Qcm9taXNlKCk7XHJcbiAgICAgICAgICAgIGF1ZGlvQ29udGV4dC5kZWNvZGVBdWRpb0RhdGEoZGF0YSwgZnVuY3Rpb24gKGJ1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgY29tcGxldGUucmVzb2x2ZShidWZmZXIpO1xyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmVycm9yKCdVbmFibGUgdG8gZGVjb2RlICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICcgdGhpcyBicm93c2VyIG1heSBub3QgZnVsbHkgc3VwcG9ydCB0aGlzIGZvcm1hdCwgb3IgdGhlIGZpbGUgbWF5IGJlIGNvcnJ1cHQsICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdpZiB0aGlzIGlzIGFuIG1wMyB0cnkgcmVtb3ZpbmcgaWQzIHRhZ3MgYW5kIGFsYnVtIGFydCBmcm9tIHRoZSBmaWxlLicpO1xyXG4gICAgICAgICAgICAgICAgY29tcGxldGUucmVzb2x2ZSh1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBXZWJBdWRpbyBBdWRpb0J1ZmZlclNvdXJjZU5vZGUgdG8gcGxheSBhIHNvdW5kIGluc3RhbmNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgV2ViQXVkaW8ucHJvdG90eXBlLmNyZWF0ZUluc3RhbmNlID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkF1ZGlvSW5zdGFuY2UoYnVmZmVyKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBsYXkgYW4gZW1wdHkgc291bmQgdG8gdW5sb2NrIFNhZmFyaSBXZWJBdWRpbyBjb250ZXh0LiBDYWxsIHRoaXMgZnVuY3Rpb25cclxuICAgICAgICAgKiByaWdodCBhZnRlciBhIHVzZXIgaW50ZXJhY3Rpb24gZXZlbnQuIFR5cGljYWxseSB1c2VkIGJ5IFtbUGF1c2VBZnRlckxvYWRlcl1dXHJcbiAgICAgICAgICogQHNvdXJjZSBodHRwczovL3BhdWxiYWthdXMuY29tL3R1dG9yaWFscy9odG1sNS93ZWItYXVkaW8tb24taW9zL1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFdlYkF1ZGlvLnVubG9jayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKFdlYkF1ZGlvLl91bmxvY2tlZCB8fCAhYXVkaW9Db250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gY3JlYXRlIGVtcHR5IGJ1ZmZlciBhbmQgcGxheSBpdFxyXG4gICAgICAgICAgICB2YXIgYnVmZmVyID0gYXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlcigxLCAxLCAyMjA1MCk7XHJcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XHJcbiAgICAgICAgICAgIHZhciBlbmRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBzb3VyY2UuYnVmZmVyID0gYnVmZmVyO1xyXG4gICAgICAgICAgICBzb3VyY2UuY29ubmVjdChhdWRpb0NvbnRleHQuZGVzdGluYXRpb24pO1xyXG4gICAgICAgICAgICBzb3VyY2Uub25lbmRlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuZGVkID0gdHJ1ZTsgfTtcclxuICAgICAgICAgICAgaWYgKHNvdXJjZS5ub3RlT24pIHtcclxuICAgICAgICAgICAgICAgIC8vIGRlcHJlY2F0ZWRcclxuICAgICAgICAgICAgICAgIHNvdXJjZS5ub3RlT24oMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2Uuc3RhcnQoMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gYnkgY2hlY2tpbmcgdGhlIHBsYXkgc3RhdGUgYWZ0ZXIgc29tZSB0aW1lLCB3ZSBrbm93IGlmIHdlJ3JlIHJlYWxseSB1bmxvY2tlZFxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UucGxheWJhY2tTdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsZWdhY3lTb3VyY2UgPSBzb3VyY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZ2FjeVNvdXJjZS5wbGF5YmFja1N0YXRlID09PSBsZWdhY3lTb3VyY2UuUExBWUlOR19TVEFURSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWdhY3lTb3VyY2UucGxheWJhY2tTdGF0ZSA9PT0gbGVnYWN5U291cmNlLkZJTklTSEVEX1NUQVRFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFdlYkF1ZGlvLl91bmxvY2tlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSA+IDAgfHwgZW5kZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgV2ViQXVkaW8uX3VubG9ja2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgV2ViQXVkaW8uaXNVbmxvY2tlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VubG9ja2VkO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFdlYkF1ZGlvO1xyXG4gICAgfSgpKTtcclxuICAgIFdlYkF1ZGlvLl91bmxvY2tlZCA9IGZhbHNlO1xyXG4gICAgZXhwb3J0cy5XZWJBdWRpbyA9IFdlYkF1ZGlvO1xyXG4gICAgLyoqXHJcbiAgICAgKiBGYWN0b3J5IG1ldGhvZCB0aGF0IGdldHMgdGhlIGF1ZGlvIGltcGxlbWVudGF0aW9uIHRvIHVzZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRBdWRpb0ltcGxlbWVudGF0aW9uKCkge1xyXG4gICAgICAgIGlmICh3aW5kb3cuQXVkaW9Db250ZXh0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgV2ViQXVkaW8oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXVkaW9UYWcoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLmdldEF1ZGlvSW1wbGVtZW50YXRpb24gPSBnZXRBdWRpb0ltcGxlbWVudGF0aW9uO1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgW1tTb3VuZF1dIG9iamVjdCBhbGxvd3MgZ2FtZXMgYnVpbHQgaW4gRXhjYWxpYnVyIHRvIGxvYWQgYXVkaW9cclxuICAgICAqIGNvbXBvbmVudHMsIGZyb20gc291bmR0cmFja3MgdG8gc291bmQgZWZmZWN0cy4gW1tTb3VuZF1dIGlzIGFuIFtbSUxvYWRhYmxlXV1cclxuICAgICAqIHdoaWNoIG1lYW5zIGl0IGNhbiBiZSBwYXNzZWQgdG8gYSBbW0xvYWRlcl1dIHRvIHByZS1sb2FkIGJlZm9yZSBhIGdhbWUgb3IgbGV2ZWwuXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOlNvdW5kcy5tZF1dXHJcbiAgICAgKi9cclxuICAgIHZhciBTb3VuZCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHBhdGhzIEEgbGlzdCBvZiBhdWRpbyBzb3VyY2VzIChjbGlwLndhdiwgY2xpcC5tcDMsIGNsaXAub2dnKSBmb3IgdGhpcyBhdWRpbyBjbGlwLiBUaGlzIGlzIGRvbmUgZm9yIGJyb3dzZXIgY29tcGF0aWJpbGl0eS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBTb3VuZCgpIHtcclxuICAgICAgICAgICAgdmFyIHBhdGhzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRoc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlciA9IExvZ181LkxvZ2dlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9kYXRhID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5fdHJhY2tzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuX2lzTG9hZGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fdm9sdW1lID0gMS4wO1xyXG4gICAgICAgICAgICB0aGlzLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7IHJldHVybjsgfTtcclxuICAgICAgICAgICAgdGhpcy5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XHJcbiAgICAgICAgICAgIHRoaXMub25lcnJvciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuOyB9O1xyXG4gICAgICAgICAgICB0aGlzLl93YXNQbGF5aW5nT25IaWRkZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgLyogQ2hyb21lIDogTVAzLCBXQVYsIE9nZ1xyXG4gICAgICAgICAgICAgICAqIEZpcmVmb3ggOiBXQVYsIE9nZyxcclxuICAgICAgICAgICAgICAgKiBJRSA6IE1QMywgV0FWIGNvbWluZyBzb29uXHJcbiAgICAgICAgICAgICAgICogU2FmYXJpIE1QMywgV0FWLCBPZ2dcclxuICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5wYXRoID0gJyc7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9hID0gMCwgcGF0aHNfMSA9IHBhdGhzOyBfYSA8IHBhdGhzXzEubGVuZ3RoOyBfYSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IHBhdGhzXzFbX2FdO1xyXG4gICAgICAgICAgICAgICAgaWYgKFNvdW5kLmNhblBsYXlGaWxlKHBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMucGF0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oJ1RoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IGFueSBvZiB0aGUgYXVkaW8gZmlsZXMgc3BlY2lmaWVkOicsIHBhdGhzLmpvaW4oJywgJykpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oJ0F0dGVtcHRpbmcgdG8gdXNlJywgcGF0aHNbMF0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXRoID0gcGF0aHNbMF07IC8vIHNlbGVjdCB0aGUgZmlyc3Qgc3BlY2lmaWVkXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zb3VuZCA9IGdldEF1ZGlvSW1wbGVtZW50YXRpb24oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIGJyb3dzZXIgY2FuIHBsYXkgdGhpcyBmaWxlIGFzIEhUTUw1IEF1ZGlvXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU291bmQuY2FuUGxheUZpbGUgPSBmdW5jdGlvbiAoZmlsZSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGEgPSBuZXcgQXVkaW8oKTtcclxuICAgICAgICAgICAgICAgIHZhciBmaWxldHlwZSA9IC8uKlxcLihbQS1aYS16MC05XSspJC87XHJcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGZpbGUubWF0Y2goZmlsZXR5cGUpWzFdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGEuY2FuUGxheVR5cGUoJ2F1ZGlvLycgKyB0eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBMb2dfNS5Mb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKCdDYW5ub3QgZGV0ZXJtaW5lIGF1ZGlvIHN1cHBvcnQsIGFzc3VtaW5nIG5vIHN1cHBvcnQgZm9yIHRoZSBBdWRpbyBUYWcnLCBlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgU291bmQucHJvdG90eXBlLndpcmVFbmdpbmUgPSBmdW5jdGlvbiAoZW5naW5lKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmIChlbmdpbmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VuZ2luZSA9IGVuZ2luZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VuZ2luZS5vbignaGlkZGVuJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmdpbmUucGF1c2VBdWRpb1doZW5IaWRkZW4gJiYgX3RoaXMuaXNQbGF5aW5nKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3dhc1BsYXlpbmdPbkhpZGRlbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnBhdXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmdpbmUub24oJ3Zpc2libGUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZ2luZS5wYXVzZUF1ZGlvV2hlbkhpZGRlbiAmJiBfdGhpcy5fd2FzUGxheWluZ09uSGlkZGVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnBsYXkoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3dhc1BsYXlpbmdPbkhpZGRlbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGhvdyBtYW55IGluc3RhbmNlcyBvZiB0aGUgc291bmQgYXJlIGN1cnJlbnRseSBwbGF5aW5nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU291bmQucHJvdG90eXBlLmluc3RhbmNlQ291bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFja3MubGVuZ3RoO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgdm9sdW1lIG9mIHRoZSBzb3VuZCBjbGlwXHJcbiAgICAgICAgICogQHBhcmFtIHZvbHVtZSAgQSB2b2x1bWUgdmFsdWUgYmV0d2VlbiAwLTEuMFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNvdW5kLnByb3RvdHlwZS5zZXRWb2x1bWUgPSBmdW5jdGlvbiAodm9sdW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZvbHVtZSA9IHZvbHVtZTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuX3RyYWNrczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciB0cmFjayA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgIHRyYWNrLnNldFZvbHVtZSh2b2x1bWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZygnU2V0IHZvbHVtZSBmb3IgYWxsIGluc3RhbmNlcyBvZiBzb3VuZCcsIHRoaXMucGF0aCwgJ3RvJywgdm9sdW1lKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBjbGlwIHNob3VsZCBsb29wIHdoZW4gY29tcGxldGVcclxuICAgICAgICAgKiBAcGFyYW0gbG9vcCAgU2V0IHRoZSBsb29waW5nIGZsYWdcclxuICAgICAgICAgKi9cclxuICAgICAgICBTb3VuZC5wcm90b3R5cGUuc2V0TG9vcCA9IGZ1bmN0aW9uIChsb29wKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvb3AgPSBsb29wO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5fdHJhY2tzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRyYWNrID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgdHJhY2suc2V0TG9vcChsb29wKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoJ1NldCBsb29wIGZvciBhbGwgaW5zdGFuY2VzIG9mIHNvdW5kJywgdGhpcy5wYXRoLCAndG8nLCBsb29wKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBzb3VuZCBpcyBwbGF5aW5nIHJpZ2h0IG5vd1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNvdW5kLnByb3RvdHlwZS5pc1BsYXlpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFja3Muc29tZShmdW5jdGlvbiAodCkgeyByZXR1cm4gdC5pc1BsYXlpbmcoKTsgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQbGF5IHRoZSBzb3VuZCwgcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBzb3VuZCBpcyBkb25lIHBsYXlpbmdcclxuICAgICAgICAgKiBBbiBvcHRpb25hbCB2b2x1bWUgYXJndW1lbnQgY2FuIGJlIHBhc3NlZCBpbiB0byBwbGF5IHRoZSBzb3VuZC4gTWF4IHZvbHVtZSBpcyAxLjBcclxuICAgICAgICAgKi9cclxuICAgICAgICBTb3VuZC5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uICh2b2x1bWUpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzTG9hZGVkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdW1lZCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgLy8gZW5zdXJlIHdlIHJlc3VtZSAqY3VycmVudCogdHJhY2tzIChpZiBwYXVzZWQpXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5fdHJhY2tzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFjayA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bWVkLnB1c2godHJhY2sucGxheSgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHdoZW4gcGF1c2VkLCBkb24ndCBzdGFydCBwbGF5aW5nIG5ldyB0cmFja1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzUGF1c2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoJ1Jlc3VtaW5nIHBhdXNlZCBpbnN0YW5jZXMgZm9yIHNvdW5kJywgdGhpcy5wYXRoLCB0aGlzLl90cmFja3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc29sdmUgd2hlbiByZXN1bWVkIHRyYWNrcyBhcmUgZG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlc181LlByb21pc2Uuam9pbihyZXN1bWVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHB1c2ggYSBuZXcgdHJhY2tcclxuICAgICAgICAgICAgICAgIHZhciBuZXdUcmFjayA9IHRoaXMuc291bmQuY3JlYXRlSW5zdGFuY2UodGhpcy5fZGF0YSk7XHJcbiAgICAgICAgICAgICAgICBuZXdUcmFjay5zZXRMb29wKHRoaXMuX2xvb3ApO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZvbHVtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1RyYWNrLnNldFZvbHVtZShVdGlsLmNsYW1wKHZvbHVtZSwgMC4wLCAxLjApKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1RyYWNrLnNldFZvbHVtZSh0aGlzLl92b2x1bWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhY2tzLnB1c2gobmV3VHJhY2spO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCdQbGF5aW5nIG5ldyBpbnN0YW5jZSBmb3Igc291bmQnLCB0aGlzLnBhdGgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld1RyYWNrLnBsYXkoKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIGRvbmUsIHJlbW92ZSB0cmFja1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl90cmFja3Muc3BsaWNlKF90aGlzLl90cmFja3MuaW5kZXhPZihuZXdUcmFjayksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZXNfNS5Qcm9taXNlLnJlc29sdmUodHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN0b3AgdGhlIHNvdW5kLCBhbmQgZG8gbm90IHJld2luZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNvdW5kLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuX3RyYWNrczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciB0cmFjayA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgIHRyYWNrLnBhdXNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5faXNQYXVzZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoJ1BhdXNlZCBhbGwgaW5zdGFuY2VzIG9mIHNvdW5kJywgdGhpcy5wYXRoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN0b3AgdGhlIHNvdW5kIGFuZCByZXdpbmRcclxuICAgICAgICAgKi9cclxuICAgICAgICBTb3VuZC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdmFyIHRyYWNrcyA9IHRoaXMuX3RyYWNrcy5jb25jYXQoW10pO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHRyYWNrc18xID0gdHJhY2tzOyBfaSA8IHRyYWNrc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRyYWNrID0gdHJhY2tzXzFbX2ldO1xyXG4gICAgICAgICAgICAgICAgdHJhY2suc3RvcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZygnU3RvcHBlZCBhbGwgaW5zdGFuY2VzIG9mIHNvdW5kJywgdGhpcy5wYXRoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc291bmQgaXMgbG9hZGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU291bmQucHJvdG90eXBlLmlzTG9hZGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNMb2FkZWQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCZWdpbnMgbG9hZGluZyB0aGUgc291bmQgYW5kIHJldHVybnMgYSBwcm9taXNlIHRvIGJlIHJlc29sdmVkIG9uIGNvbXBsZXRpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBTb3VuZC5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGNvbXBsZXRlID0gbmV3IFByb21pc2VzXzUuUHJvbWlzZSgpO1xyXG4gICAgICAgICAgICBpZiAoISF0aGlzLmdldERhdGEoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCdBbHJlYWR5IGhhdmUgZGF0YSBmb3IgYXVkaW8gcmVzb3VyY2UnLCB0aGlzLnBhdGgpO1xyXG4gICAgICAgICAgICAgICAgY29tcGxldGUucmVzb2x2ZSh0aGlzLnNvdW5kKTtcclxuICAgICAgICAgICAgICAgIHRoaXMub25jb21wbGV0ZSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZygnU3RhcnRlZCBsb2FkaW5nIHNvdW5kJywgdGhpcy5wYXRoKTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZldGNoUmVzb3VyY2UoZnVuY3Rpb24gKHJlcXVlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgIT09IDIwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gbG9hZCBhdWRpbyByZXNvdXJjZSAnLCBfdGhpcy5wYXRoLCAnIHNlcnZlciByZXNwb25kZWQgd2l0aCBlcnJvciBjb2RlJywgcmVxdWVzdC5zdGF0dXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbmVycm9yKHJlcXVlc3QucmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZS5yZXNvbHZlKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGxvYWQgc291bmRcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXREYXRhKHJlcXVlc3QucmVzcG9uc2UpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbmNvbXBsZXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuZGVidWcoJ0NvbXBsZXRlZCBsb2FkaW5nIHNvdW5kJywgX3RoaXMucGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlLnJlc29sdmUoX3RoaXMuc291bmQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlKSB7IHJldHVybiBjb21wbGV0ZS5yZXNvbHZlKGUpOyB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgc291bmQhIElmIHRoaXMgaXMgYSBjcm9zcyBvcmlnaW4gZXJyb3IsIFxcXHJcbiAgICAgICAgICAgIHlvdSBtdXN0IGhvc3QgeW91ciBzb3VuZCB3aXRoIHlvdXIgaHRtbCBhbmQgamF2YXNjcmlwdC4nKTtcclxuICAgICAgICAgICAgICAgIHRoaXMub25lcnJvcihlKTtcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlLnJlc29sdmUoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBTb3VuZC5wcm90b3R5cGUuX2ZldGNoUmVzb3VyY2UgPSBmdW5jdGlvbiAob25sb2FkKSB7XHJcbiAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgICAgIHJlcXVlc3Qub3BlbignR0VUJywgdGhpcy5wYXRoLCB0cnVlKTtcclxuICAgICAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSB0aGlzLnNvdW5kLnJlc3BvbnNlVHlwZTtcclxuICAgICAgICAgICAgcmVxdWVzdC5vbnByb2dyZXNzID0gdGhpcy5vbnByb2dyZXNzO1xyXG4gICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSB0aGlzLm9uZXJyb3I7XHJcbiAgICAgICAgICAgIHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gb25sb2FkKHJlcXVlc3QpOyB9O1xyXG4gICAgICAgICAgICByZXF1ZXN0LnNlbmQoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIHJhdyBzb3VuZCBkYXRhIChlLmcuIGJsb2IgVVJMIG9yIEF1ZGlvQnVmZmVyKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNvdW5kLnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgcmF3IHNvdW5kIGRhdGEgYW5kIHJldHVybnMgYSBQcm9taXNlIHRoYXQgaXMgcmVzb2x2ZWQgd2hlbiBzb3VuZCBkYXRhIGlzIHByb2Nlc3NlZFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGRhdGEgVGhlIFhIUiBkYXRhIGZvciB0aGUgc291bmQgaW1wbGVtZW50YXRpb24gdG8gcHJvY2VzcyAoQmxvYiBvciBBcnJheUJ1ZmZlcilcclxuICAgICAgICAgKi9cclxuICAgICAgICBTb3VuZC5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNvdW5kLnByb2Nlc3NEYXRhKGRhdGEpLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9pc0xvYWRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fZGF0YSA9IF90aGlzLnByb2Nlc3NEYXRhKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0IHRoZSByYXcgc291bmQgZGF0YSAoZS5nLiBibG9iIFVSTCBvciBBdWRpb0J1ZmZlcilcclxuICAgICAgICAgKi9cclxuICAgICAgICBTb3VuZC5wcm90b3R5cGUucHJvY2Vzc0RhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBTb3VuZDtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLlNvdW5kID0gU291bmQ7XHJcbiAgICAvKipcclxuICAgICAqIEludGVybmFsIGNsYXNzIHJlcHJlc2VudGluZyBhIEhUTUw1IGF1ZGlvIGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICB2YXIgQXVkaW9UYWdJbnN0YW5jZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gQXVkaW9UYWdJbnN0YW5jZShzcmMpIHtcclxuICAgICAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fYXVkaW9FbGVtZW50ID0gbmV3IEF1ZGlvKHNyYyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEF1ZGlvVGFnSW5zdGFuY2UucHJvdG90eXBlLmlzUGxheWluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzUGxheWluZztcclxuICAgICAgICB9O1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBdWRpb1RhZ0luc3RhbmNlLnByb3RvdHlwZSwgXCJsb29wXCIsIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9vcDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgQXVkaW9UYWdJbnN0YW5jZS5wcm90b3R5cGUuc2V0TG9vcCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9sb29wID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2F1ZGlvRWxlbWVudC5sb29wID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuX3dpcmVVcE9uRW5kZWQoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEF1ZGlvVGFnSW5zdGFuY2UucHJvdG90eXBlLnNldFZvbHVtZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9hdWRpb0VsZW1lbnQudm9sdW1lID0gVXRpbC5jbGFtcCh2YWx1ZSwgMCwgMS4wKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEF1ZGlvVGFnSW5zdGFuY2UucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1BhdXNlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzdW1lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuX2lzUGxheWluZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGxheWluZ1Byb21pc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBdWRpb1RhZ0luc3RhbmNlLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2F1ZGlvRWxlbWVudC5sb2FkKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2F1ZGlvRWxlbWVudC5sb29wID0gdGhpcy5fbG9vcDtcclxuICAgICAgICAgICAgdGhpcy5fYXVkaW9FbGVtZW50LnBsYXkoKTtcclxuICAgICAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fcGxheWluZ1Byb21pc2UgPSBuZXcgUHJvbWlzZXNfNS5Qcm9taXNlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3dpcmVVcE9uRW5kZWQoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEF1ZGlvVGFnSW5zdGFuY2UucHJvdG90eXBlLl9yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNQYXVzZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9hdWRpb0VsZW1lbnQucGxheSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl93aXJlVXBPbkVuZGVkKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBdWRpb1RhZ0luc3RhbmNlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1BsYXlpbmcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9hdWRpb0VsZW1lbnQucGF1c2UoKTtcclxuICAgICAgICAgICAgdGhpcy5faXNQYXVzZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEF1ZGlvVGFnSW5zdGFuY2UucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNQbGF5aW5nKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fYXVkaW9FbGVtZW50LnBhdXNlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2F1ZGlvRWxlbWVudC5jdXJyZW50VGltZSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZU9uRW5kZWQoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEF1ZGlvVGFnSW5zdGFuY2UucHJvdG90eXBlLl93aXJlVXBPbkVuZGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2xvb3ApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2F1ZGlvRWxlbWVudC5vbmVuZGVkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2hhbmRsZU9uRW5kZWQoKTsgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgQXVkaW9UYWdJbnN0YW5jZS5wcm90b3R5cGUuX2hhbmRsZU9uRW5kZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9wbGF5aW5nUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEF1ZGlvVGFnSW5zdGFuY2U7XHJcbiAgICB9KCkpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcm5hbCBjbGFzcyByZXByZXNlbnRpbmcgYSBXZWIgQXVkaW8gQXVkaW9CdWZmZXJTb3VyY2VOb2RlIGluc3RhbmNlXHJcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJfQXVkaW9fQVBJXHJcbiAgICAgKi9cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICB2YXIgV2ViQXVkaW9JbnN0YW5jZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gV2ViQXVkaW9JbnN0YW5jZShfYnVmZmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlciA9IF9idWZmZXI7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZvbHVtZU5vZGUgPSBhdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpO1xyXG4gICAgICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ3VycmVudCBwbGF5YmFjayBvZmZzZXQgKGluIHNlY29uZHMpXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50T2Zmc2V0ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgV2ViQXVkaW9JbnN0YW5jZS5wcm90b3R5cGUuaXNQbGF5aW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNQbGF5aW5nO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgV2ViQXVkaW9JbnN0YW5jZS5wcm90b3R5cGUuc2V0Vm9sdW1lID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl92b2x1bWVOb2RlLmdhaW4uc2V0VGFyZ2V0QXRUaW1lKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl92b2x1bWVOb2RlLmdhaW4uc2V0VGFyZ2V0QXRUaW1lKFV0aWwuY2xhbXAodmFsdWUsIDAsIDEuMCksIGF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl92b2x1bWVOb2RlLmdhaW4udmFsdWUgPSBVdGlsLmNsYW1wKHZhbHVlLCAwLCAxLjApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBXZWJBdWRpb0luc3RhbmNlLnByb3RvdHlwZS5zZXRMb29wID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvb3AgPSB2YWx1ZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2J1ZmZlclNvdXJjZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYnVmZmVyU291cmNlLmxvb3AgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3dpcmVVcE9uRW5kZWQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgV2ViQXVkaW9JbnN0YW5jZS5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzUGF1c2VkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXN1bWUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5faXNQbGF5aW5nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wbGF5aW5nUHJvbWlzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFdlYkF1ZGlvSW5zdGFuY2UucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fdm9sdW1lTm9kZS5jb25uZWN0KGF1ZGlvQ29udGV4dC5kZXN0aW5hdGlvbik7XHJcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9idWZmZXJTb3VyY2Uuc3RhcnQoMCwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50T2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fcGxheWluZ1Byb21pc2UgPSBuZXcgUHJvbWlzZXNfNS5Qcm9taXNlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3dpcmVVcE9uRW5kZWQoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFdlYkF1ZGlvSW5zdGFuY2UucHJvdG90eXBlLl9yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNQYXVzZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBhIGJ1ZmZlciBzb3VyY2UgY2FuIG9ubHkgYmUgc3RhcnRlZCBvbmNlXHJcbiAgICAgICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gZGlzcG9zZSBvZiB0aGUgcHJldmlvdXMgaW5zdGFuY2UgYmVmb3JlXHJcbiAgICAgICAgICAgIC8vIFwicmVzdW1pbmdcIiB0aGUgbmV4dCBvbmVcclxuICAgICAgICAgICAgdGhpcy5fYnVmZmVyU291cmNlLm9uZW5kZWQgPSBudWxsOyAvLyBkaXNwb3NlIG9mIGFueSBwcmV2aW91cyBldmVudCBoYW5kbGVyXHJcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xyXG4gICAgICAgICAgICB2YXIgZHVyYXRpb24gPSAoMSAvIHRoaXMuX2J1ZmZlclNvdXJjZS5wbGF5YmFja1JhdGUudmFsdWUpICogdGhpcy5fYnVmZmVyLmR1cmF0aW9uO1xyXG4gICAgICAgICAgICB0aGlzLl9idWZmZXJTb3VyY2Uuc3RhcnQoMCwgdGhpcy5fY3VycmVudE9mZnNldCAlIGR1cmF0aW9uKTtcclxuICAgICAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fd2lyZVVwT25FbmRlZCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgV2ViQXVkaW9JbnN0YW5jZS5wcm90b3R5cGUuX2NyZWF0ZUJ1ZmZlclNvdXJjZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fYnVmZmVyU291cmNlID0gYXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9idWZmZXJTb3VyY2UuYnVmZmVyID0gdGhpcy5fYnVmZmVyO1xyXG4gICAgICAgICAgICB0aGlzLl9idWZmZXJTb3VyY2UubG9vcCA9IHRoaXMuX2xvb3A7XHJcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlclNvdXJjZS5wbGF5YmFja1JhdGUudmFsdWUgPSAxLjA7XHJcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlclNvdXJjZS5jb25uZWN0KHRoaXMuX3ZvbHVtZU5vZGUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgV2ViQXVkaW9JbnN0YW5jZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNQbGF5aW5nKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fYnVmZmVyU291cmNlLnN0b3AoMCk7XHJcbiAgICAgICAgICAgIC8vIFBsYXliYWNrIHJhdGUgd2lsbCBiZSBhIHNjYWxlIGZhY3RvciBvZiBob3cgZmFzdC9zbG93IHRoZSBhdWRpbyBpcyBiZWluZyBwbGF5ZWRcclxuICAgICAgICAgICAgLy8gZGVmYXVsdCBpcyAxLjBcclxuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBpbnZlcnQgaXQgdG8gZ2V0IHRoZSB0aW1lIHNjYWxlXHJcbiAgICAgICAgICAgIHZhciBwYlJhdGUgPSAxIC8gKHRoaXMuX2J1ZmZlclNvdXJjZS5wbGF5YmFja1JhdGUudmFsdWUgfHwgMS4wKTtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudE9mZnNldCA9ICgobmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLl9zdGFydFRpbWUpICogcGJSYXRlKSAvIDEwMDA7IC8vIGluIHNlY29uZHNcclxuICAgICAgICAgICAgdGhpcy5faXNQYXVzZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFdlYkF1ZGlvSW5zdGFuY2UucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNQbGF5aW5nKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fYnVmZmVyU291cmNlLnN0b3AoMCk7XHJcbiAgICAgICAgICAgIC8vIGhhbmRsZXIgd2lsbCBub3QgYmUgd2lyZWQgdXAgaWYgd2Ugd2VyZSBsb29waW5nXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fYnVmZmVyU291cmNlLm9uZW5kZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZU9uRW5kZWQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50T2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBXZWJBdWRpb0luc3RhbmNlLnByb3RvdHlwZS5fd2lyZVVwT25FbmRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9sb29wKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9idWZmZXJTb3VyY2Uub25lbmRlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9oYW5kbGVPbkVuZGVkKCk7IH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFdlYkF1ZGlvSW5zdGFuY2UucHJvdG90eXBlLl9oYW5kbGVPbkVuZGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBwYXVzaW5nIGNhbGxzIHN0b3AoMCkgd2hpY2ggdHJpZ2dlcnMgb25lbmRlZCBldmVudFxyXG4gICAgICAgICAgICAvLyBzbyB3ZSBkb24ndCBcInJlc29sdmVcIiB5ZXQgKHdoZW4gd2UgcmVzdW1lIHdlJ2xsIHRyeSBhZ2FpbilcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1BhdXNlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wbGF5aW5nUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gV2ViQXVkaW9JbnN0YW5jZTtcclxuICAgIH0oKSk7XHJcbn0pO1xyXG5kZWZpbmUoXCJJbnRlcmZhY2VzL0lMb2FkZXJcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxufSk7XHJcbmRlZmluZShcIkxvYWRlclwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkRyYXdpbmcvQ29sb3JcIiwgXCJSZXNvdXJjZXMvU291bmRcIiwgXCJVdGlsL0xvZ1wiLCBcIlByb21pc2VzXCIsIFwiQ2xhc3NcIiwgXCJVdGlsL0RyYXdVdGlsXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgQ29sb3JfMTIsIFNvdW5kXzEsIExvZ182LCBQcm9taXNlc182LCBDbGFzc18zLCBEcmF3VXRpbCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIFByZS1sb2FkaW5nIGFzc2V0c1xyXG4gICAgICpcclxuICAgICAqIFRoZSBsb2FkZXIgcHJvdmlkZXMgYSBtZWNoYW5pc20gdG8gcHJlbG9hZCBtdWx0aXBsZSByZXNvdXJjZXMgYXRcclxuICAgICAqIG9uZSB0aW1lLiBUaGUgbG9hZGVyIG11c3QgYmUgcGFzc2VkIHRvIHRoZSBlbmdpbmUgaW4gb3JkZXIgdG9cclxuICAgICAqIHRyaWdnZXIgdGhlIGxvYWRpbmcgcHJvZ3Jlc3MgYmFyLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBbW0xvYWRlcl1dIGl0c2VsZiBpbXBsZW1lbnRzIFtbSUxvYWRhYmxlXV0gc28geW91IGNhbiBsb2FkIGxvYWRlcnMuXHJcbiAgICAgKlxyXG4gICAgICogIyMgRXhhbXBsZTogUHJlLWxvYWRpbmcgcmVzb3VyY2VzIGZvciBhIGdhbWVcclxuICAgICAqXHJcbiAgICAgKiBgYGBqc1xyXG4gICAgICogLy8gY3JlYXRlIGEgbG9hZGVyXHJcbiAgICAgKiB2YXIgbG9hZGVyID0gbmV3IGV4LkxvYWRlcigpO1xyXG4gICAgICpcclxuICAgICAqIC8vIGNyZWF0ZSBhIHJlc291cmNlIGRpY3Rpb25hcnkgKGJlc3QgcHJhY3RpY2UgaXMgdG8ga2VlcCBhIHNlcGFyYXRlIGZpbGUpXHJcbiAgICAgKiB2YXIgcmVzb3VyY2VzID0ge1xyXG4gICAgICogICBUZXh0dXJlR3JvdW5kOiBuZXcgZXguVGV4dHVyZShcIi9pbWFnZXMvdGV4dHVyZXMvZ3JvdW5kLnBuZ1wiKSxcclxuICAgICAqICAgU291bmREZWF0aDogbmV3IGV4LlNvdW5kKFwiL3NvdW5kL2RlYXRoLndhdlwiLCBcIi9zb3VuZC9kZWF0aC5tcDNcIilcclxuICAgICAqIH07XHJcbiAgICAgKlxyXG4gICAgICogLy8gbG9vcCB0aHJvdWdoIGRpY3Rpb25hcnkgYW5kIGFkZCB0byBsb2FkZXJcclxuICAgICAqIGZvciAodmFyIGxvYWRhYmxlIGluIHJlc291cmNlcykge1xyXG4gICAgICogICBpZiAocmVzb3VyY2VzLmhhc093blByb3BlcnR5KGxvYWRhYmxlKSkge1xyXG4gICAgICogICAgIGxvYWRlci5hZGRSZXNvdXJjZShyZXNvdXJjZXNbbG9hZGFibGVdKTtcclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIC8vIHN0YXJ0IGdhbWVcclxuICAgICAqIGdhbWUuc3RhcnQobG9hZGVyKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAqICAgY29uc29sZS5sb2coXCJHYW1lIHN0YXJ0ZWQhXCIpO1xyXG4gICAgICogfSk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgdmFyIExvYWRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKExvYWRlciwgX3N1cGVyKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gbG9hZGFibGVzICBPcHRpb25hbGx5IHByb3ZpZGUgdGhlIGxpc3Qgb2YgcmVzb3VyY2VzIHlvdSB3YW50IHRvIGxvYWQgYXQgY29uc3RydWN0b3IgdGltZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIExvYWRlcihsb2FkYWJsZXMpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuX3Jlc291cmNlTGlzdCA9IFtdO1xyXG4gICAgICAgICAgICBfdGhpcy5faW5kZXggPSAwO1xyXG4gICAgICAgICAgICBfdGhpcy5fcmVzb3VyY2VDb3VudCA9IDA7XHJcbiAgICAgICAgICAgIF90aGlzLl9udW1Mb2FkZWQgPSAwO1xyXG4gICAgICAgICAgICBfdGhpcy5fcHJvZ3Jlc3NDb3VudHMgPSB7fTtcclxuICAgICAgICAgICAgX3RoaXMuX3RvdGFsQ291bnRzID0ge307XHJcbiAgICAgICAgICAgIC8vIGxvZ28gZHJhd2luZyBzdHVmZlxyXG4gICAgICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cclxuICAgICAgICAgICAgLy8gYmFzZTY0IHN0cmluZyBlbmNvZGluZyBvZiB0aGUgZXhjYWxpYnVyIGxvZ28gKGxvZ28td2hpdGUucG5nKVxyXG4gICAgICAgICAgICBfdGhpcy5sb2dvID0gJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBZFFBQUFCMkNBWUFBQUJ4aEdJOUFBQUFDWEJJV1hNQUFBc1NBQUFMRWdIUzNYNzhBQUFLblVsRVFWUjQydTNkUDJ3alN4MEg4TjhoSklvbklSbUpqc3EwU0JSK0JRMWRjcUtoZTBsRDc3U3ZTd3BLa0pLR1B1bHBrdGZSSU1VZEVxS0lxVjU3cnBBb2tNNGRiU2l5cTdPTlBUUDd4MzlpZno3U0ZibkVucDN4ZXI0N083dXpIMTVmWHdNQTZPWUhtZ0FBQkNvQUNGUUFFS2dBZ0VBRkFJRUtBQUlWQUFRcUFDQlFBVUNnQW9CQUJRQ0JDZ0FJVkFBUXFBQWdVQUZBb0FJQUFoVUFCQ29BQ0ZRQUVLZ0FnRUNGTGJtT2lOZUZmMlBiQXl6NjhQcjZxaFVnYlJ3UjkydisvendpSnJZSE1FS0ZNbWNOLy8vVXRnY1FxRkJrMVBELzk3VTlReDhWQ0ZTZ3U0RW1BSUVLQUFJVkFBUXFBQ0JRNFoyNWpvalA4ZVgrMFd0TkFnSVZhT1krSW01aitlS2gyNGg0MWpRZ1VJRXlaN0Y1TmFQVTd3Q0JDaXdZZC93OWNPQitxQWxnSjNLTExvdzBFVjE5ODgwM1JXdkpmdmZkZHgrMGxoRXFIS3U1SmdBalZDQnZsaG1GempRUlhVZWtIejkrVFA3OXk4dUxSak5DaFhmdm9lUHZBWUVLeE50ajFlNDIvTzVKb0lKQUJjcmRSTVJWTE0rWDNrVEVwYWFCOTg4Y0t1eldnOUVvYlRXZE14ME9seTh1TjRkcWhBb0FScWduYU4zYXJIZnF1N095SDhJdEtMVkIvUCtDRWZNVEh5R1BZM25weDFtOHpXR0RFZW9CZlVrL3hkdGk1N2RyL3IxV3YyKzZFUG93M3RaNXJSZFM3MnMxbmV1Rjk3eHZXZCtYVEgwL1YrVU10dERXcWJJL3IybnJ4ZnAranYydVNqU083UytPWHkvQS8zbE4rOXhYNVQ1SHhFVVBaWjB0ZkI3MSt3NTdlSi9IRnUreitqa3YxdTkyWVg5ZmJJL0hoWDNKQTlycDVNUHI2NnRXYUc5VWZVR2JySEl6aTdjTFV5WUZmL3RwVGFkeTAzRUVlTDhtVUo2aTdNS1lOdldOcXI0UGUyanJhZFhPNjBMcnZQQXoyUFE1UlBYNjg0YWg4ZHhEKzJ6YW50bkNnVmlwU1ZWK20vdGdCOVcyRERxMlN4L3ZNOTV3Y0hoWmhXVkptOHlydjU4Y1NnZlRkYzcwKysrL1gvcjUyMisvdFVLU0VlcEJxbytvbTRaTFBlck1qVXd1Tm5RQ3R4MUdXSnRlZTFGd2RENXVXZDg2eExzOFVhVnQyYU5FTzEvc2FaL1o1cllNVzR6cTZ2MzRyR1Y5QmczcTJlWjlTa2VObTlxd3lVaDMwT1BJSFlGS3g1RkcwM0M3em5TT3FZQnErcVcvenBRM2FuSDAzN1ROSGx1RzZmMFdQc1BoSHZhYjRRRnR5N29nT2V1eERZY055Mi96dTIyMTRXTllXeG1CdXJOTzhiR245N3BOQk9POHh5Lzl1Q29yWlo0STJyNEM3YUpnTzdaVjlpRTQ5RG02TnZPV3grcFdFOUNVcTN6YmRUcDlkb3ozOFRiWHR6cUg5UlQ1Q3lXZTQyMk9hWm9aR2VaQ2FicmhQUVk5SGp3c2pwVHZDZzRZdGxFMitUYS9qMmJ6bjhmcXJEcWdtKzZ5VUhPbUF2V1VqQXRHaGJOWXZzQmtuRG5xSDFRaGM3Vm14SGdlYi9OYnVkQTVqL1VYbFl3aWYycDZsdWhBYzl0ZXUxbnBpSEtuRHM4aWY2dENtN0pMWDNOS3BndHRYZTlydWM5bUhNZDdhODNpd2R4RjV2dDh0dXRBUmFDZWtsUm5OSzlDOFduTkY3Z2VKUTRUNFhHM0poU25WZGlsUXJHK3lPbnJsVkhmc0VHWXpoTkJuN0x1NnRTNytISmFmSlE0RU1pTmxOcVdYWjlXUHZWZ25WWUhHNU0xQnlEWGtUNmxlWDJFZ1RxSnR5dDQ1eXY3UzJxTzNzRVpqWmhETFhlUitZS2RKMFpkazhRb2N2SDlONzMyS3JOdHErRlovenpJSEFCY0pyWXBkK1h2MTRsT2Q1YXA3NlNncmR1Vy9WVFExcWNRcHFuYmd1NGlmWnZVTU5wZDlYdW9abXZDdFBhUTJZL0JDSFZMZ2JySlRlUlBEZFZmNnBmTUtEVTJmT2tIbVZGRmZYcjNNc291THNuTnZWNWtSb2U1K3M0MzFQZXVvS1BxV25hdXJZL1pQQkVlcXdjZU40bDk2aXdPNkg3TWpxNHk3VkdQVk5lMTBWYVpNelZDUFZXcEkvWjZGWmJjdjVmTXFHQ1UrZExmRkd6ajU4alA4K2JDZEpDbzd5ektUd2RPRjBidTlVZzdWNGMreXo3RkpmWWVHb3lzVXNzMEhzc0lkVlp3WUxEdWpNcWxFU29DZFR0R3NadGJIbkpCZU5kRFNKU3MwalRLZE1KTjFITlg1NFd2N2J2c1U5TmtWSlZhMTNkWCsvd3VBclYwWC9sNVJIeW8vbG5mRjRHNnA2RHJTMGtIZHRYaHkzNVRHRXJEUFlaVW4yV2ZXcURPby9sVnFkTUQyTy9oS0poRDdTL29kdWt5bXE5czAyUU40RUVQUi96YmFPdW1aYytyMTV6SzFacXpubDlqc2ZpZW1UTTFRbVYzSFV1VGtlZGxnOUhJUXpSYlVEOTNkZkMrMnRwajJmSUhFSDIrUnFDQ1FIMTNnWnE3aFdYVE5wVnUxOU9CMWZjOW5RMEFLT0tVYjVsVTBQMWtEeU9uZW9XazBsT1o5Y0lQMHg3cXU4KzJCaENvUjJ3WXUxK2U3RG1hWHpCU3N1NXZhWDFuZTJ6cnBtVVBUbXhmN1BNMURtNHkvdkM3bnk3TmlmNyt6LzlabXRNMFozcGFuUEx0UG1yYTlmMTZiY0swRHBibndrNDNWZC9SSHR1NnpmTlFUeTFRQnkzYXFHMmc5blZteG1sK0JPb0p5VDNOcFdtbjl4aGZGbnU0YnZEYSs0NEJYaHFxZmRmM3VVRjkreXo3N0FUMzFZdWUybWplY1lRNjJOTGZna0E5Z2hIcUxORWhOZW00SDFjNnZkeUR4aGYvYnB6NW00Y29XL2MzOXdpNlZIMmJQdEhsY2FWOWN2WHRzK3p4Q2U2clRlcWMybmRMN3VHZDkzUXdNOWJGY0F6TW9aWjdTZ1RCYld4K2FzdWk2MWgvaXExK1JtanFkYm5RWFEzVDFETlE2M1YvVTl1Y3FtL3BNelBiMXJlUHNrLzFpVE9qZ3ZhdFI0VzNMYzhVTEI3OHBFTHlybkFmZVRjajFOVTUwOS84Nm1mSjMzLzgrTWYwMGEwNVV5UFVFdzdVVkNlV0cvV05FaUV4eUhSTXQ1bHRXMzBpelVQazE4eXR0N2xOZmM4aS8vRHZ0dlh0byt5U0E1QmpsanNMVUY4bFBrcU1QRXRXMUpvbURzaUdCWjlCeWI0TkF2VUlUU045R3V3c0lqNnQ2VVRPcWs3akpSRWttenFsaTh4SXM5NnVkU08yMHNYMEgxdlc5MklMOWUxYTlyZ3FWeWY5MWdiUHNUeTlVRDluOWxPa1Q4aytSZmtGUjVQTU5xeE9jZFNmMzJQQnZnM3ZpbE8remR4RStva3g5V20wcGgzNlhZc1JaQ3BNRjk5M0dPazVxdnFCM0RjdDZqdnNzYjY3S3Z1VU5KM2ZydzkyYmhyOC9TVFNGMEpkUlBNTHBVQ2duc2dvOVM3NlBaMjQ2WkZrMXdXdks1bTN2Vm9ZdlcxU3o3bk45MWpmWGJRMVpRYzdUVzZIZWFvT2FseXBHLzgvcC9yUDFhTkFjNlpIelNuZmRxUFVQaGR5MlBRdzZOejlnU1ZodWhpcXVlVUhSM3V1N3k3SzNyZERYNHU0NlpyUGJVYTBJRkJaMHNlS1EzWFFUUnQydm0zVy9hMkRiTkt5cysrcnZtM2VwNit5MXgyVWRQM2JXVTlsenJhNDdVMUdtbGN0WC9zUTIzdCthT2xCeUxUaC80TkFQYUNSeHRjZE81SExTSi82dk50Q3dHeDY3VlBtUGJ2V2QxcTlmcktIdHA0a0FxUkoySFI5ajc2MkpmWDNiWi8vZWxQdGoxM1BQRHgxK0Q1dHFrL1hpNk5POFNIejdNbUgxOWRYcmRCTmZWRlA2VDJQVDFVSE5pdDg3L3Q0bTUrYVJIK25RQmR2cXloWkRLSkxmWnM4aDdYUHNxZFYyWk9WK3RhbktCOGFsbjBkeXhkQVhiVjRqNGd2dDRvTU9yYlA2dmJVNzNOVzdUTWxiZFRuUHJXcGZxWGZoOUhLWjl2a2U3S3VUZVpSTnRYUlNlNisxRlYvL2NlL2xuNWVYZnNYZ2NxWHpyNis5MjYxTTNtb09vYTdFNm52VFpUZnk3aU5zbWZiN2tqZmdYR3N2eGUwdmloc0V0czlIVHF1UHB0MXExdnRhaHUyVHFBaVVBRUVLajB6aHdvQVJxZ0F1L09uWC80NDJXSCs5eGMvV3ZyNThyZS9UcjdmNDEvK1pzUnFoQW9BQ0ZRQUVLZ0FjSGpNb1FKc2tKc3ovZXFycjVaK3Z2cjd2NWZtUUZldkFsNWx6dFFJRlFBUXFBQWdVQUhnSUpsREJkaGdkUTQxTjJlS0VTb0FJRkFCUUtBQ3dGRXdod29BUnFnQUlGQUJRS0FDQUFJVkFBUXFBQWhVQUJDb0FJQkFCUUNCQ2dBQ0ZRQUVLZ0FnVUFGQW9BS0FRQVVBZ1FvQUNGUUFFS2dBSUZBQlFLQUNBQUlWQUFRcUFBaFVBQkNvQUlCQUJRQ0JDZ0FDRlFBUXFBQWdVQUZBb0FLQVFBVUFsdndQY0ZEbnMxRHNINHNBQUFBQVNVVk9SSzVDWUlJPSc7XHJcbiAgICAgICAgICAgIC8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXHJcbiAgICAgICAgICAgIF90aGlzLmxvZ29XaWR0aCA9IDQ2ODtcclxuICAgICAgICAgICAgX3RoaXMubG9nb0hlaWdodCA9IDExODtcclxuICAgICAgICAgICAgX3RoaXMuYmFja2dyb3VuZENvbG9yID0gJyMxNzZCQUEnO1xyXG4gICAgICAgICAgICBfdGhpcy5nZXREYXRhID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XHJcbiAgICAgICAgICAgIF90aGlzLnNldERhdGEgPSBmdW5jdGlvbiAoKSB7IHJldHVybjsgfTtcclxuICAgICAgICAgICAgX3RoaXMucHJvY2Vzc0RhdGEgPSBmdW5jdGlvbiAoKSB7IHJldHVybjsgfTtcclxuICAgICAgICAgICAgX3RoaXMub25wcm9ncmVzcyA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBMb2dfNi5Mb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnW2V4LkxvYWRlcl0gTG9hZGluZyAnICsgKDEwMCAqIGUubG9hZGVkIC8gZS50b3RhbCkudG9GaXhlZCgwKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIF90aGlzLm9uY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybjsgfTtcclxuICAgICAgICAgICAgX3RoaXMub25lcnJvciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuOyB9O1xyXG4gICAgICAgICAgICBpZiAobG9hZGFibGVzKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5hZGRSZXNvdXJjZXMobG9hZGFibGVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb2FkZXIucHJvdG90eXBlLCBcIl9pbWFnZVwiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pbWFnZUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbWFnZUVsZW1lbnQgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbWFnZUVsZW1lbnQuc3JjID0gdGhpcy5sb2dvO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ltYWdlRWxlbWVudDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgO1xyXG4gICAgICAgIExvYWRlci5wcm90b3R5cGUud2lyZUVuZ2luZSA9IGZ1bmN0aW9uIChlbmdpbmUpIHtcclxuICAgICAgICAgICAgdGhpcy5fZW5naW5lID0gZW5naW5lO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkIGEgcmVzb3VyY2UgdG8gdGhlIGxvYWRlciB0byBsb2FkXHJcbiAgICAgICAgICogQHBhcmFtIGxvYWRhYmxlICBSZXNvdXJjZSB0byBhZGRcclxuICAgICAgICAgKi9cclxuICAgICAgICBMb2FkZXIucHJvdG90eXBlLmFkZFJlc291cmNlID0gZnVuY3Rpb24gKGxvYWRhYmxlKSB7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLl9pbmRleCsrO1xyXG4gICAgICAgICAgICB0aGlzLl9yZXNvdXJjZUxpc3QucHVzaChsb2FkYWJsZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Byb2dyZXNzQ291bnRzW2tleV0gPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl90b3RhbENvdW50c1trZXldID0gMTtcclxuICAgICAgICAgICAgdGhpcy5fcmVzb3VyY2VDb3VudCsrO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkIGEgbGlzdCBvZiByZXNvdXJjZXMgdG8gdGhlIGxvYWRlciB0byBsb2FkXHJcbiAgICAgICAgICogQHBhcmFtIGxvYWRhYmxlcyAgVGhlIGxpc3Qgb2YgcmVzb3VyY2VzIHRvIGxvYWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBMb2FkZXIucHJvdG90eXBlLmFkZFJlc291cmNlcyA9IGZ1bmN0aW9uIChsb2FkYWJsZXMpIHtcclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSBsb2FkYWJsZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRSZXNvdXJjZShsb2FkYWJsZXNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGxvYWRlciBoYXMgY29tcGxldGVseSBsb2FkZWQgYWxsIHJlc291cmNlc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExvYWRlci5wcm90b3R5cGUuaXNMb2FkZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9udW1Mb2FkZWQgPT09IHRoaXMuX3Jlc291cmNlQ291bnQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCZWdpbiBsb2FkaW5nIGFsbCBvZiB0aGUgc3VwcGxpZWQgcmVzb3VyY2VzLCByZXR1cm5pbmcgYSBwcm9taXNlXHJcbiAgICAgICAgICogdGhhdCByZXNvbHZlcyB3aGVuIGxvYWRpbmcgb2YgYWxsIGlzIGNvbXBsZXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTG9hZGVyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgY29tcGxldGUgPSBuZXcgUHJvbWlzZXNfNi5Qcm9taXNlKCk7XHJcbiAgICAgICAgICAgIHZhciBtZSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZXNvdXJjZUxpc3QubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBtZS5vbmNvbXBsZXRlLmNhbGwobWUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcHJvZ3Jlc3NBcnJheSA9IG5ldyBBcnJheSh0aGlzLl9yZXNvdXJjZUxpc3QubGVuZ3RoKTtcclxuICAgICAgICAgICAgdmFyIHByb2dyZXNzQ2h1bmtzID0gdGhpcy5fcmVzb3VyY2VMaXN0Lmxlbmd0aDtcclxuICAgICAgICAgICAgdGhpcy5fcmVzb3VyY2VMaXN0LmZvckVhY2goZnVuY3Rpb24gKHIsIGkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fZW5naW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgci53aXJlRW5naW5lKF90aGlzLl9lbmdpbmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgci5vbnByb2dyZXNzID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdG90YWwgPSBlLnRvdGFsO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsb2FkZWQgPSBlLmxvYWRlZDtcclxuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc0FycmF5W2ldID0geyBsb2FkZWQ6ICgobG9hZGVkIC8gdG90YWwpICogKDEwMCAvIHByb2dyZXNzQ2h1bmtzKSksIHRvdGFsOiAxMDAgfTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvZ3Jlc3NSZXN1bHQgPSBwcm9ncmVzc0FycmF5LnJlZHVjZShmdW5jdGlvbiAoYWNjdW0sIG5leHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbG9hZGVkOiAoYWNjdW0ubG9hZGVkICsgbmV4dC5sb2FkZWQpLCB0b3RhbDogMTAwIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgeyBsb2FkZWQ6IDAsIHRvdGFsOiAxMDAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWUub25wcm9ncmVzcy5jYWxsKG1lLCBwcm9ncmVzc1Jlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgci5vbmNvbXBsZXRlID0gci5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1lLl9udW1Mb2FkZWQrKztcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWUuX251bUxvYWRlZCA9PT0gbWUuX3Jlc291cmNlQ291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWUub25jb21wbGV0ZS5jYWxsKG1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGUucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBsb2FkTmV4dChsaXN0LCBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFsaXN0W2luZGV4XSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxpc3RbaW5kZXhdLmxvYWQoKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2FkTmV4dChsaXN0LCBpbmRleCArIDEpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbG9hZE5leHQodGhpcy5fcmVzb3VyY2VMaXN0LCAwKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTG9hZGVyIGRyYXcgZnVuY3Rpb24uIERyYXdzIHRoZSBkZWZhdWx0IEV4Y2FsaWJ1ciBsb2FkaW5nIHNjcmVlbi5cclxuICAgICAgICAgKiBPdmVycmlkZSBgbG9nb2AsIGBsb2dvV2lkdGhgLCBgbG9nb0hlaWdodGAgYW5kIGBiYWNrZ3JvdW5kQ29sb3JgIHByb3BlcnRpZXNcclxuICAgICAgICAgKiB0byBjdXN0b21pemUgdGhlIGRyYXdpbmcsIG9yIGp1c3Qgb3ZlcnJpZGUgZW50aXJlIG1ldGhvZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBMb2FkZXIucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgICAgICAgICAgIHZhciBjYW52YXNIZWlnaHQgPSB0aGlzLl9lbmdpbmUuY2FudmFzSGVpZ2h0IC8gd2luZG93LmRldmljZVBpeGVsUmF0aW87XHJcbiAgICAgICAgICAgIHZhciBjYW52YXNXaWR0aCA9IHRoaXMuX2VuZ2luZS5jYW52YXNXaWR0aCAvIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xyXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5iYWNrZ3JvdW5kQ29sb3I7XHJcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcclxuICAgICAgICAgICAgdmFyIHkgPSBjYW52YXNIZWlnaHQgLyAyO1xyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSBNYXRoLm1pbih0aGlzLmxvZ29XaWR0aCwgY2FudmFzV2lkdGggKiAwLjc1KTtcclxuICAgICAgICAgICAgdmFyIHggPSAoY2FudmFzV2lkdGggLyAyKSAtICh3aWR0aCAvIDIpO1xyXG4gICAgICAgICAgICB2YXIgaW1hZ2VIZWlnaHQgPSBNYXRoLmZsb29yKHdpZHRoICogKHRoaXMubG9nb0hlaWdodCAvIHRoaXMubG9nb1dpZHRoKSk7IC8vIE9HIGhlaWdodC93aWR0aCBmYWN0b3JcclxuICAgICAgICAgICAgdmFyIG9sZEFudGlhbGlhcyA9IHRoaXMuX2VuZ2luZS5nZXRBbnRpYWxpYXNpbmcoKTtcclxuICAgICAgICAgICAgdGhpcy5fZW5naW5lLnNldEFudGlhbGlhc2luZyh0cnVlKTtcclxuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLl9pbWFnZSwgMCwgMCwgdGhpcy5sb2dvV2lkdGgsIHRoaXMubG9nb0hlaWdodCwgeCwgeSAtIGltYWdlSGVpZ2h0IC0gMjAsIHdpZHRoLCBpbWFnZUhlaWdodCk7XHJcbiAgICAgICAgICAgIC8vIGxvYWRpbmcgYm94XHJcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAyO1xyXG4gICAgICAgICAgICBEcmF3VXRpbC5yb3VuZFJlY3QoY3R4LCB4LCB5LCB3aWR0aCwgMjAsIDEwKTtcclxuICAgICAgICAgICAgdmFyIHByb2dyZXNzID0gd2lkdGggKiAodGhpcy5fbnVtTG9hZGVkIC8gdGhpcy5fcmVzb3VyY2VDb3VudCk7XHJcbiAgICAgICAgICAgIHZhciBtYXJnaW4gPSA1O1xyXG4gICAgICAgICAgICB2YXIgcHJvZ3Jlc3NXaWR0aCA9IHByb2dyZXNzIC0gbWFyZ2luICogMjtcclxuICAgICAgICAgICAgdmFyIGhlaWdodCA9IDIwIC0gbWFyZ2luICogMjtcclxuICAgICAgICAgICAgRHJhd1V0aWwucm91bmRSZWN0KGN0eCwgeCArIG1hcmdpbiwgeSArIG1hcmdpbiwgcHJvZ3Jlc3NXaWR0aCA+IDAgPyBwcm9ncmVzc1dpZHRoIDogMCwgaGVpZ2h0LCA1LCBudWxsLCBDb2xvcl8xMi5Db2xvci5XaGl0ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZ2luZS5zZXRBbnRpYWxpYXNpbmcob2xkQW50aWFsaWFzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBlcmZvcm0gYW55IGNhbGN1bGF0aW9ucyBvciBsb2dpYyBpbiB0aGUgYHVwZGF0ZWAgbWV0aG9kLiBUaGUgZGVmYXVsdCBgTG9hZGVyYCBkb2VzIG5vdFxyXG4gICAgICAgICAqIGRvIGFueXRoaW5nIGluIHRoaXMgbWV0aG9kIHNvIGl0IGlzIHNhZmUgdG8gb3ZlcnJpZGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTG9hZGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoX2VuZ2luZSwgX2RlbHRhKSB7XHJcbiAgICAgICAgICAgIC8vIG92ZXJyaWRhYmxlIHVwZGF0ZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIExvYWRlcjtcclxuICAgIH0oQ2xhc3NfMy5DbGFzcykpO1xyXG4gICAgZXhwb3J0cy5Mb2FkZXIgPSBMb2FkZXI7XHJcbiAgICAvKipcclxuICAgICAqIEEgW1tMb2FkZXJdXSB0aGF0IHBhdXNlcyBhZnRlciBsb2FkaW5nIHRvIGFsbG93IHVzZXJcclxuICAgICAqIHRvIHByb2NlZWQgdG8gcGxheSB0aGUgZ2FtZS4gVHlwaWNhbGx5IHlvdSB3aWxsXHJcbiAgICAgKiB3YW50IHRvIHVzZSB0aGlzIGxvYWRlciBmb3IgaU9TIHRvIGFsbG93IHNvdW5kc1xyXG4gICAgICogdG8gcGxheSBhZnRlciBsb2FkaW5nIChBcHBsZSBTYWZhcmkgcmVxdWlyZXMgdXNlclxyXG4gICAgICogaW50ZXJhY3Rpb24gdG8gYWxsb3cgc291bmRzLCBldmVuIGZvciBnYW1lcylcclxuICAgICAqXHJcbiAgICAgKiAqKk5vdGU6KiogQmVjYXVzZSBMb2FkZXIgaXMgbm90IHBhcnQgb2YgYSBTY2VuZSwgeW91IG11c3RcclxuICAgICAqIGNhbGwgYHVwZGF0ZWAgYW5kIGBkcmF3YCBtYW51YWxseSBvbiBcImNoaWxkXCIgb2JqZWN0cy5cclxuICAgICAqXHJcbiAgICAgKiAjIyBJbXBsZW1lbnRpbmcgYSBUcmlnZ2VyXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGBQYXVzZUFmdGVyTG9hZGVyYCByZXF1aXJlcyBhbiBlbGVtZW50IHRvIGFjdCBhcyB0aGUgdHJpZ2dlciBidXR0b25cclxuICAgICAqIHRvIHN0YXJ0IHRoZSBnYW1lLlxyXG4gICAgICpcclxuICAgICAqIEZvciBleGFtcGxlLCBsZXQncyBjcmVhdGUgYW4gYDxhPmAgdGFnIHRvIGJlIG91ciB0cmlnZ2VyIGFuZCBjYWxsIGl0IGB0YXAtdG8tcGxheWAuXHJcbiAgICAgKlxyXG4gICAgICogYGBgaHRtbFxyXG4gICAgICogPGRpdiBpZD1cIndyYXBwZXJcIj5cclxuICAgICAqICAgIDxjYW52YXMgaWQ9XCJnYW1lXCI+PC9jYW52YXM+XHJcbiAgICAgKiAgICA8YSBpZD1cInRhcC10by1wbGF5XCIgaHJlZj0namF2YXNjcmlwdDp2b2lkKDApOyc+VGFwIHRvIFBsYXk8L2E+XHJcbiAgICAgKiA8L2Rpdj5cclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIFdlJ3ZlIHB1dCBpdCBpbnNpZGUgYSB3cmFwcGVyIHRvIHBvc2l0aW9uIGl0IHByb3Blcmx5IG92ZXIgdGhlIGdhbWUgY2FudmFzLlxyXG4gICAgICpcclxuICAgICAqIE5vdyBsZXQncyBhZGQgc29tZSBDU1MgdG8gc3R5bGUgaXQgKGluc2VydCBpbnRvIGA8aGVhZD5gKTpcclxuICAgICAqXHJcbiAgICAgKiBgYGBodG1sXHJcbiAgICAgKiA8c3R5bGU+XHJcbiAgICAgKiAgICAgI3dyYXBwZXIge1xyXG4gICAgICogICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICAgKiAgICAgICAgIHdpZHRoOiA1MDBweDtcclxuICAgICAqICAgICAgICAgaGVpZ2h0OiA1MDBweDtcclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgICAgI3RhcC10by1wbGF5IHtcclxuICAgICAqICAgICAgICAgZGlzcGxheTogbm9uZTtcclxuICAgICAqICAgICAgICAgZm9udC1zaXplOiAyNHB4O1xyXG4gICAgICogICAgICAgICBmb250LWZhbWlseTogc2Fucy1zZXJpZjtcclxuICAgICAqICAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xyXG4gICAgICogICAgICAgICBib3JkZXI6IDNweCBzb2xpZCB3aGl0ZTtcclxuICAgICAqICAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgICogICAgICAgICBjb2xvcjogd2hpdGU7XHJcbiAgICAgKiAgICAgICAgIHdpZHRoOiAyMDBweDtcclxuICAgICAqICAgICAgICAgaGVpZ2h0OiA1MHB4O1xyXG4gICAgICogICAgICAgICBsaW5lLWhlaWdodDogNTBweDtcclxuICAgICAqICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xyXG4gICAgICogICAgICAgICBsZWZ0OiAxNDdweDtcclxuICAgICAqICAgICAgICAgdG9wOiA4MCU7XHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogPC9zdHlsZT5cclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIE5vdyB3ZSBjYW4gY3JlYXRlIGEgYFBhdXNlQWZ0ZXJMb2FkZXJgIHdpdGggYSByZWZlcmVuY2UgdG8gb3VyIHRyaWdnZXIgYnV0dG9uOlxyXG4gICAgICpcclxuICAgICAqIGBgYHRzXHJcbiAgICAgKiB2YXIgbG9hZGVyID0gbmV3IGV4LlBhdXNlQWZ0ZXJMb2FkZXIoJ3RhcC10by1wbGF5JywgWy4uLl0pO1xyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogIyMgVXNlIFBhdXNlQWZ0ZXJMb2FkZXIgZm9yIGlPU1xyXG4gICAgICpcclxuICAgICAqIFRoZSBwcmltYXJ5IHVzZSBjYXNlIGZvciBwYXVzaW5nIGJlZm9yZSBzdGFydGluZyB0aGUgZ2FtZSBpcyB0b1xyXG4gICAgICogcGFzcyBBcHBsZSdzIHJlcXVpcmVtZW50IG9mIHVzZXIgaW50ZXJhY3Rpb24uIFRoZSBXZWIgQXVkaW8gY29udGV4dFxyXG4gICAgICogaW4gU2FmYXJpIGlzIGRpc2FibGVkIGJ5IGRlZmF1bHQgdW50aWwgdXNlciBpbnRlcmFjdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBUaGVyZWZvcmUsIHlvdSBjYW4gdXNlIHRoaXMgc25pcHBldCB0byBvbmx5IHVzZSBQYXVzZUFmdGVyTG9hZGVyIHdoZW5cclxuICAgICAqIGlPUyBpcyBkZXRlY3RlZCAoc2VlIFt0aGlzIHRocmVhZF0oaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy85MDM4NjI1L2RldGVjdC1pZi1kZXZpY2UtaXMtaW9zKVxyXG4gICAgICogZm9yIG1vcmUgdGVjaG5pcXVlcykuXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHNcclxuICAgICAqIHZhciBpT1MgPSAvaVBhZHxpUGhvbmV8aVBvZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhKDxhbnk+d2luZG93KS5NU1N0cmVhbTtcclxuICAgICAqIHZhciBsb2FkZXI6IGV4LkxvYWRlciA9IGlPUyA/IG5ldyBleC5QYXVzZUFmdGVyTG9hZGVyKCd0YXAtdG8tcGxheScpIDogbmV3IGV4LkxvYWRlcigpO1xyXG4gICAgICpcclxuICAgICAqIGxvYWRlci5hZGRSZXNvdXJjZSguLi4pO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIHZhciBQYXVzZUFmdGVyTG9hZGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoUGF1c2VBZnRlckxvYWRlciwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBQYXVzZUFmdGVyTG9hZGVyKHRyaWdnZXJFbGVtZW50SWQsIGxvYWRhYmxlcykge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBsb2FkYWJsZXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLl9oYW5kbGVPblRyaWdnZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX3dhaXRQcm9taXNlLnN0YXRlKCkgIT09IFByb21pc2VzXzYuUHJvbWlzZVN0YXRlLlBlbmRpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyB1bmxvY2sgU2FmYXJpIFdlYkF1ZGlvIGNvbnRleHRcclxuICAgICAgICAgICAgICAgIFNvdW5kXzEuV2ViQXVkaW8udW5sb2NrKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBjb250aW51ZSB0byBwbGF5IGdhbWVcclxuICAgICAgICAgICAgICAgIF90aGlzLl93YWl0UHJvbWlzZS5yZXNvbHZlKF90aGlzLl9sb2FkZWRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBoaWRlIERPTSBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fcGxheVRyaWdnZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgX3RoaXMuX3BsYXlUcmlnZ2VyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodHJpZ2dlckVsZW1lbnRJZCk7XHJcbiAgICAgICAgICAgIF90aGlzLl9wbGF5VHJpZ2dlci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIF90aGlzLl9oYW5kbGVPblRyaWdnZXIpO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFBhdXNlQWZ0ZXJMb2FkZXIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHRoaXMuX3dhaXRQcm9taXNlID0gbmV3IFByb21pc2VzXzYuUHJvbWlzZSgpO1xyXG4gICAgICAgICAgICAvLyB3YWl0IHVudGlsIHVzZXIgaW5kaWNhdGVzIHRvIHByb2NlZWQgYmVmb3JlIGZpbmlzaGluZyBsb2FkXHJcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUubG9hZC5jYWxsKHRoaXMpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9hZGVkVmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIC8vIHNob3cgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3BsYXlUcmlnZ2VyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl93YWl0UHJvbWlzZS5yZWplY3QodmFsdWUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dhaXRQcm9taXNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFBhdXNlQWZ0ZXJMb2FkZXI7XHJcbiAgICB9KExvYWRlcikpO1xyXG4gICAgZXhwb3J0cy5QYXVzZUFmdGVyTG9hZGVyID0gUGF1c2VBZnRlckxvYWRlcjtcclxufSk7XHJcbmRlZmluZShcIkludGVyZmFjZXMvSUFjdG9yVHJhaXRcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxufSk7XHJcbmRlZmluZShcIlRyYWl0cy9DYXB0dXJlUG9pbnRlclwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9wb2dhdGVzIHBvaW50ZXIgZXZlbnRzIHRvIHRoZSBhY3RvclxyXG4gICAgICovXHJcbiAgICB2YXIgQ2FwdHVyZVBvaW50ZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIENhcHR1cmVQb2ludGVyKCkge1xyXG4gICAgICAgIH1cclxuICAgICAgICBDYXB0dXJlUG9pbnRlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGFjdG9yLCBlbmdpbmUpIHtcclxuICAgICAgICAgICAgaWYgKCFhY3Rvci5lbmFibGVDYXB0dXJlUG9pbnRlcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhY3Rvci5pc0tpbGxlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZW5naW5lLmlucHV0LnBvaW50ZXJzLnByb3BvZ2F0ZShhY3Rvcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gQ2FwdHVyZVBvaW50ZXI7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5DYXB0dXJlUG9pbnRlciA9IENhcHR1cmVQb2ludGVyO1xyXG59KTtcclxuZGVmaW5lKFwiVHJhaXRzL0V1bGVyTW92ZW1lbnRcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJQaHlzaWNzXCIsIFwiQWN0b3JcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBQaHlzaWNzXzcsIEFjdG9yXzUpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgdmFyIEV1bGVyTW92ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIEV1bGVyTW92ZW1lbnQoKSB7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEV1bGVyTW92ZW1lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChhY3RvciwgX2VuZ2luZSwgZGVsdGEpIHtcclxuICAgICAgICAgICAgLy8gVXBkYXRlIHBsYWNlbWVudHMgYmFzZWQgb24gbGluZWFyIGFsZ2VicmFcclxuICAgICAgICAgICAgdmFyIHNlY29uZHMgPSBkZWx0YSAvIDEwMDA7XHJcbiAgICAgICAgICAgIHZhciB0b3RhbEFjYyA9IGFjdG9yLmFjYy5jbG9uZSgpO1xyXG4gICAgICAgICAgICAvLyBPbmx5IGFjdGl2ZSB2YW5pbGxhIGFjdG9ycyBhcmUgYWZmZWN0ZWQgYnkgZ2xvYmFsIGFjY2VsZXJhdGlvblxyXG4gICAgICAgICAgICBpZiAoYWN0b3IuY29sbGlzaW9uVHlwZSA9PT0gQWN0b3JfNS5Db2xsaXNpb25UeXBlLkFjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgdG90YWxBY2MuYWRkRXF1YWwoUGh5c2ljc183LlBoeXNpY3MuYWNjKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhY3Rvci5vbGRWZWwgPSBhY3Rvci52ZWw7XHJcbiAgICAgICAgICAgIGFjdG9yLnZlbC5hZGRFcXVhbCh0b3RhbEFjYy5zY2FsZShzZWNvbmRzKSk7XHJcbiAgICAgICAgICAgIGFjdG9yLnBvcy5hZGRFcXVhbChhY3Rvci52ZWwuc2NhbGUoc2Vjb25kcykpLmFkZEVxdWFsKHRvdGFsQWNjLnNjYWxlKDAuNSAqIHNlY29uZHMgKiBzZWNvbmRzKSk7XHJcbiAgICAgICAgICAgIGFjdG9yLnJ4ICs9IGFjdG9yLnRvcnF1ZSAqICgxLjAgLyBhY3Rvci5tb2kpICogc2Vjb25kcztcclxuICAgICAgICAgICAgYWN0b3Iucm90YXRpb24gKz0gYWN0b3IucnggKiBzZWNvbmRzO1xyXG4gICAgICAgICAgICBhY3Rvci5zY2FsZS54ICs9IGFjdG9yLnN4ICogZGVsdGEgLyAxMDAwO1xyXG4gICAgICAgICAgICBhY3Rvci5zY2FsZS55ICs9IGFjdG9yLnN5ICogZGVsdGEgLyAxMDAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEV1bGVyTW92ZW1lbnQ7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5FdWxlck1vdmVtZW50ID0gRXVsZXJNb3ZlbWVudDtcclxufSk7XHJcbmRlZmluZShcIlV0aWwvQ3VsbGluZ0JveFwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkFsZ2VicmFcIiwgXCJEcmF3aW5nL0NvbG9yXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgQWxnZWJyYV8xMywgQ29sb3JfMTMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgdmFyIEN1bGxpbmdCb3ggPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIEN1bGxpbmdCb3goKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RvcExlZnQgPSBuZXcgQWxnZWJyYV8xMy5WZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3RvcFJpZ2h0ID0gbmV3IEFsZ2VicmFfMTMuVmVjdG9yKDAsIDApO1xyXG4gICAgICAgICAgICB0aGlzLl9ib3R0b21MZWZ0ID0gbmV3IEFsZ2VicmFfMTMuVmVjdG9yKDAsIDApO1xyXG4gICAgICAgICAgICB0aGlzLl9ib3R0b21SaWdodCA9IG5ldyBBbGdlYnJhXzEzLlZlY3RvcigwLCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgQ3VsbGluZ0JveC5wcm90b3R5cGUuaXNTcHJpdGVPZmZTY3JlZW4gPSBmdW5jdGlvbiAoYWN0b3IsIGVuZ2luZSkge1xyXG4gICAgICAgICAgICB2YXIgZHJhd2luZ1dpZHRoID0gYWN0b3IuY3VycmVudERyYXdpbmcud2lkdGg7XHJcbiAgICAgICAgICAgIHZhciBkcmF3aW5nSGVpZ2h0ID0gYWN0b3IuY3VycmVudERyYXdpbmcuaGVpZ2h0O1xyXG4gICAgICAgICAgICB2YXIgcm90YXRpb24gPSBhY3Rvci5yb3RhdGlvbjtcclxuICAgICAgICAgICAgdmFyIGFuY2hvciA9IGFjdG9yLmdldENlbnRlcigpO1xyXG4gICAgICAgICAgICB2YXIgd29ybGRQb3MgPSBhY3Rvci5nZXRXb3JsZFBvcygpO1xyXG4gICAgICAgICAgICB0aGlzLl90b3BMZWZ0LnggPSB3b3JsZFBvcy54IC0gKGRyYXdpbmdXaWR0aCAvIDIpO1xyXG4gICAgICAgICAgICB0aGlzLl90b3BMZWZ0LnkgPSB3b3JsZFBvcy55IC0gKGRyYXdpbmdIZWlnaHQgLyAyKTtcclxuICAgICAgICAgICAgdGhpcy5fdG9wTGVmdCA9IHRoaXMuX3RvcExlZnQucm90YXRlKHJvdGF0aW9uLCBhbmNob3IpO1xyXG4gICAgICAgICAgICB0aGlzLl90b3BSaWdodC54ID0gd29ybGRQb3MueCArIChkcmF3aW5nV2lkdGggLyAyKTtcclxuICAgICAgICAgICAgdGhpcy5fdG9wUmlnaHQueSA9IHdvcmxkUG9zLnkgLSAoZHJhd2luZ0hlaWdodCAvIDIpO1xyXG4gICAgICAgICAgICB0aGlzLl90b3BSaWdodCA9IHRoaXMuX3RvcFJpZ2h0LnJvdGF0ZShyb3RhdGlvbiwgYW5jaG9yKTtcclxuICAgICAgICAgICAgdGhpcy5fYm90dG9tTGVmdC54ID0gd29ybGRQb3MueCAtIChkcmF3aW5nV2lkdGggLyAyKTtcclxuICAgICAgICAgICAgdGhpcy5fYm90dG9tTGVmdC55ID0gd29ybGRQb3MueSArIChkcmF3aW5nSGVpZ2h0IC8gMik7XHJcbiAgICAgICAgICAgIHRoaXMuX2JvdHRvbUxlZnQgPSB0aGlzLl9ib3R0b21MZWZ0LnJvdGF0ZShyb3RhdGlvbiwgYW5jaG9yKTtcclxuICAgICAgICAgICAgdGhpcy5fYm90dG9tUmlnaHQueCA9IHdvcmxkUG9zLnggKyAoZHJhd2luZ1dpZHRoIC8gMik7XHJcbiAgICAgICAgICAgIHRoaXMuX2JvdHRvbVJpZ2h0LnkgPSB3b3JsZFBvcy55ICsgKGRyYXdpbmdIZWlnaHQgLyAyKTtcclxuICAgICAgICAgICAgdGhpcy5fYm90dG9tUmlnaHQgPSB0aGlzLl9ib3R0b21SaWdodC5yb3RhdGUocm90YXRpb24sIGFuY2hvcik7XHJcbiAgICAgICAgICAgIC8vL1xyXG4gICAgICAgICAgICB2YXIgdG9wTGVmdFNjcmVlbiA9IGVuZ2luZS53b3JsZFRvU2NyZWVuQ29vcmRpbmF0ZXModGhpcy5fdG9wTGVmdCk7XHJcbiAgICAgICAgICAgIHZhciB0b3BSaWdodFNjcmVlbiA9IGVuZ2luZS53b3JsZFRvU2NyZWVuQ29vcmRpbmF0ZXModGhpcy5fdG9wUmlnaHQpO1xyXG4gICAgICAgICAgICB2YXIgYm90dG9tTGVmdFNjcmVlbiA9IGVuZ2luZS53b3JsZFRvU2NyZWVuQ29vcmRpbmF0ZXModGhpcy5fYm90dG9tTGVmdCk7XHJcbiAgICAgICAgICAgIHZhciBib3R0b21SaWdodFNjcmVlbiA9IGVuZ2luZS53b3JsZFRvU2NyZWVuQ29vcmRpbmF0ZXModGhpcy5fYm90dG9tUmlnaHQpO1xyXG4gICAgICAgICAgICB0aGlzLl94Q29vcmRzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuX3lDb29yZHMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5feENvb3Jkcy5wdXNoKHRvcExlZnRTY3JlZW4ueCwgdG9wUmlnaHRTY3JlZW4ueCwgYm90dG9tTGVmdFNjcmVlbi54LCBib3R0b21SaWdodFNjcmVlbi54KTtcclxuICAgICAgICAgICAgdGhpcy5feUNvb3Jkcy5wdXNoKHRvcExlZnRTY3JlZW4ueSwgdG9wUmlnaHRTY3JlZW4ueSwgYm90dG9tTGVmdFNjcmVlbi55LCBib3R0b21SaWdodFNjcmVlbi55KTtcclxuICAgICAgICAgICAgdGhpcy5feE1pbiA9IE1hdGgubWluLmFwcGx5KG51bGwsIHRoaXMuX3hDb29yZHMpO1xyXG4gICAgICAgICAgICB0aGlzLl95TWluID0gTWF0aC5taW4uYXBwbHkobnVsbCwgdGhpcy5feUNvb3Jkcyk7XHJcbiAgICAgICAgICAgIHRoaXMuX3hNYXggPSBNYXRoLm1heC5hcHBseShudWxsLCB0aGlzLl94Q29vcmRzKTtcclxuICAgICAgICAgICAgdGhpcy5feU1heCA9IE1hdGgubWF4LmFwcGx5KG51bGwsIHRoaXMuX3lDb29yZHMpO1xyXG4gICAgICAgICAgICB2YXIgbWluV29ybGQgPSBlbmdpbmUuc2NyZWVuVG9Xb3JsZENvb3JkaW5hdGVzKG5ldyBBbGdlYnJhXzEzLlZlY3Rvcih0aGlzLl94TWluLCB0aGlzLl95TWluKSk7XHJcbiAgICAgICAgICAgIHZhciBtYXhXb3JsZCA9IGVuZ2luZS5zY3JlZW5Ub1dvcmxkQ29vcmRpbmF0ZXMobmV3IEFsZ2VicmFfMTMuVmVjdG9yKHRoaXMuX3hNYXgsIHRoaXMuX3lNYXgpKTtcclxuICAgICAgICAgICAgdGhpcy5feE1pbldvcmxkID0gbWluV29ybGQueDtcclxuICAgICAgICAgICAgdGhpcy5feU1pbldvcmxkID0gbWluV29ybGQueTtcclxuICAgICAgICAgICAgdGhpcy5feE1heFdvcmxkID0gbWF4V29ybGQueDtcclxuICAgICAgICAgICAgdGhpcy5feU1heFdvcmxkID0gbWF4V29ybGQueTtcclxuICAgICAgICAgICAgdmFyIGJvdW5kaW5nUG9pbnRzID0gW1xyXG4gICAgICAgICAgICAgICAgbmV3IEFsZ2VicmFfMTMuVmVjdG9yKHRoaXMuX3hNaW4sIHRoaXMuX3lNaW4pLFxyXG4gICAgICAgICAgICAgICAgbmV3IEFsZ2VicmFfMTMuVmVjdG9yKHRoaXMuX3hNYXgsIHRoaXMuX3lNaW4pLFxyXG4gICAgICAgICAgICAgICAgbmV3IEFsZ2VicmFfMTMuVmVjdG9yKHRoaXMuX3hNaW4sIHRoaXMuX3lNYXgpLFxyXG4gICAgICAgICAgICAgICAgbmV3IEFsZ2VicmFfMTMuVmVjdG9yKHRoaXMuX3hNYXgsIHRoaXMuX3lNYXgpXHJcbiAgICAgICAgICAgIF07IC8vIGJvdHRvbXJpZ2h0XHJcbiAgICAgICAgICAgIC8vIHNwcml0ZSBjYW4gYmUgd2lkZXIgdGhhbiBjYW52YXMgc2NyZWVuIChhbmQgc3RpbGwgdmlzaWJsZSB3aXRoaW4gY2FudmFzKVxyXG4gICAgICAgICAgICAvLyB0b3Agb3IgYm90dG9tIG9mIHNwcml0ZSBtdXN0IGJlIHdpdGhpbiBjYW52YXNcclxuICAgICAgICAgICAgaWYgKGJvdW5kaW5nUG9pbnRzWzBdLnggPCAwICYmIGJvdW5kaW5nUG9pbnRzWzFdLnggPiBlbmdpbmUuY2FudmFzLmNsaWVudFdpZHRoICYmXHJcbiAgICAgICAgICAgICAgICAoYm91bmRpbmdQb2ludHNbMF0ueSA+IDAgfHwgYm91bmRpbmdQb2ludHNbMl0ueSA8IGVuZ2luZS5jYW52YXMuY2xpZW50SGVpZ2h0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHNwcml0ZSBjYW4gYmUgdGFsbGVyIHRoYW4gY2FudmFzIHNjcmVlbiAoYW5kIHN0aWxsIHZpc2libGUgd2l0aGluIGNhbnZhcylcclxuICAgICAgICAgICAgLy8gbGVmdCBvciByaWdodCBvZiBzcHJpdGUgbXVzdCBiZSB3aXRoaW4gY2FudmFzXHJcbiAgICAgICAgICAgIGlmIChib3VuZGluZ1BvaW50c1swXS55IDwgMCAmJiBib3VuZGluZ1BvaW50c1syXS55ID4gZW5naW5lLmNhbnZhcy5jbGllbnRIZWlnaHQgJiZcclxuICAgICAgICAgICAgICAgIChib3VuZGluZ1BvaW50c1sxXS54ID4gMCB8fCBib3VuZGluZ1BvaW50c1swXS54IDwgZW5naW5lLmNhbnZhcy5jbGllbnRXaWR0aCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgaWYgYW55IGNvcm5lciBpcyB2aXNpYmxlLCB3ZSdyZSBub3Qgb2Zmc2NyZWVuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmRpbmdQb2ludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChib3VuZGluZ1BvaW50c1tpXS54ID4gMCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kaW5nUG9pbnRzW2ldLnkgPiAwICYmXHJcbiAgICAgICAgICAgICAgICAgICAgYm91bmRpbmdQb2ludHNbaV0ueCA8IGVuZ2luZS5jYW52YXMuY2xpZW50V2lkdGggJiZcclxuICAgICAgICAgICAgICAgICAgICBib3VuZGluZ1BvaW50c1tpXS55IDwgZW5naW5lLmNhbnZhcy5jbGllbnRIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDdWxsaW5nQm94LnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgICAgICAgICAgIC8vIGJvdW5kaW5nIHJlY3RhbmdsZVxyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IENvbG9yXzEzLkNvbG9yLldoaXRlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGN0eC5yZWN0KHRoaXMuX3hNaW5Xb3JsZCwgdGhpcy5feU1pbldvcmxkLCB0aGlzLl94TWF4V29ybGQgLSB0aGlzLl94TWluV29ybGQsIHRoaXMuX3lNYXhXb3JsZCAtIHRoaXMuX3lNaW5Xb3JsZCk7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IENvbG9yXzEzLkNvbG9yLlJlZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5hcmModGhpcy5fdG9wTGVmdC54LCB0aGlzLl90b3BMZWZ0LnksIDUsIDAsIE1hdGguUEkgKiAyKTtcclxuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gQ29sb3JfMTMuQ29sb3IuR3JlZW4udG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHguYXJjKHRoaXMuX3RvcFJpZ2h0LngsIHRoaXMuX3RvcFJpZ2h0LnksIDUsIDAsIE1hdGguUEkgKiAyKTtcclxuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gQ29sb3JfMTMuQ29sb3IuQmx1ZS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5hcmModGhpcy5fYm90dG9tTGVmdC54LCB0aGlzLl9ib3R0b21MZWZ0LnksIDUsIDAsIE1hdGguUEkgKiAyKTtcclxuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gQ29sb3JfMTMuQ29sb3IuTWFnZW50YS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5hcmModGhpcy5fYm90dG9tUmlnaHQueCwgdGhpcy5fYm90dG9tUmlnaHQueSwgNSwgMCwgTWF0aC5QSSAqIDIpO1xyXG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gQ3VsbGluZ0JveDtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkN1bGxpbmdCb3ggPSBDdWxsaW5nQm94O1xyXG59KTtcclxuZGVmaW5lKFwiVHJhaXRzL09mZnNjcmVlbkN1bGxpbmdcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJVdGlsL0N1bGxpbmdCb3hcIiwgXCJBbGdlYnJhXCIsIFwiRXZlbnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgQ3VsbGluZ0JveF8xLCBBbGdlYnJhXzE0LCBFdmVudHNfMykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICB2YXIgT2Zmc2NyZWVuQ3VsbGluZyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gT2Zmc2NyZWVuQ3VsbGluZygpIHtcclxuICAgICAgICAgICAgdGhpcy5jdWxsaW5nQm94ID0gbmV3IEN1bGxpbmdCb3hfMS5DdWxsaW5nQm94KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9mZnNjcmVlbkN1bGxpbmcucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChhY3RvciwgZW5naW5lKSB7XHJcbiAgICAgICAgICAgIHZhciBldmVudERpc3BhdGNoZXIgPSBhY3Rvci5ldmVudERpc3BhdGNoZXI7XHJcbiAgICAgICAgICAgIHZhciBhbmNob3IgPSBhY3Rvci5hbmNob3I7XHJcbiAgICAgICAgICAgIHZhciBnbG9iYWxTY2FsZSA9IGFjdG9yLmdldEdsb2JhbFNjYWxlKCk7XHJcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGdsb2JhbFNjYWxlLnggKiBhY3Rvci5nZXRXaWR0aCgpIC8gYWN0b3Iuc2NhbGUueDtcclxuICAgICAgICAgICAgdmFyIGhlaWdodCA9IGdsb2JhbFNjYWxlLnkgKiBhY3Rvci5nZXRIZWlnaHQoKSAvIGFjdG9yLnNjYWxlLnk7XHJcbiAgICAgICAgICAgIHZhciB3b3JsZFBvcyA9IGFjdG9yLmdldFdvcmxkUG9zKCk7XHJcbiAgICAgICAgICAgIHZhciBhY3RvclNjcmVlbkNvb3JkcyA9IGVuZ2luZS53b3JsZFRvU2NyZWVuQ29vcmRpbmF0ZXMobmV3IEFsZ2VicmFfMTQuVmVjdG9yKHdvcmxkUG9zLnggLSBhbmNob3IueCAqIHdpZHRoLCB3b3JsZFBvcy55IC0gYW5jaG9yLnkgKiBoZWlnaHQpKTtcclxuICAgICAgICAgICAgdmFyIHpvb20gPSAxLjA7XHJcbiAgICAgICAgICAgIGlmIChhY3Rvci5zY2VuZSAmJiBhY3Rvci5zY2VuZS5jYW1lcmEpIHtcclxuICAgICAgICAgICAgICAgIHpvb20gPSBNYXRoLmFicyhhY3Rvci5zY2VuZS5jYW1lcmEuZ2V0Wm9vbSgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaXNTcHJpdGVPZmZTY3JlZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoYWN0b3IuY3VycmVudERyYXdpbmcgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaXNTcHJpdGVPZmZTY3JlZW4gPSB0aGlzLmN1bGxpbmdCb3guaXNTcHJpdGVPZmZTY3JlZW4oYWN0b3IsIGVuZ2luZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFhY3Rvci5pc09mZlNjcmVlbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKChhY3RvclNjcmVlbkNvb3Jkcy54ICsgd2lkdGggKiB6b29tIDwgMCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGFjdG9yU2NyZWVuQ29vcmRzLnkgKyBoZWlnaHQgKiB6b29tIDwgMCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGFjdG9yU2NyZWVuQ29vcmRzLnggPiBlbmdpbmUuY2FudmFzV2lkdGggfHxcclxuICAgICAgICAgICAgICAgICAgICBhY3RvclNjcmVlbkNvb3Jkcy55ID4gZW5naW5lLmNhbnZhc0hlaWdodCkgJiZcclxuICAgICAgICAgICAgICAgICAgICBpc1Nwcml0ZU9mZlNjcmVlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50RGlzcGF0Y2hlci5lbWl0KCdleGl0dmlld3BvcnQnLCBuZXcgRXZlbnRzXzMuRXhpdFZpZXdQb3J0RXZlbnQoYWN0b3IpKTtcclxuICAgICAgICAgICAgICAgICAgICBhY3Rvci5pc09mZlNjcmVlbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGFjdG9yU2NyZWVuQ29vcmRzLnggKyB3aWR0aCAqIHpvb20gPiAwICYmXHJcbiAgICAgICAgICAgICAgICAgICAgYWN0b3JTY3JlZW5Db29yZHMueSArIGhlaWdodCAqIHpvb20gPiAwICYmXHJcbiAgICAgICAgICAgICAgICAgICAgYWN0b3JTY3JlZW5Db29yZHMueCA8IGVuZ2luZS5jYW52YXNXaWR0aCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGFjdG9yU2NyZWVuQ29vcmRzLnkgPCBlbmdpbmUuY2FudmFzSGVpZ2h0KSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICFpc1Nwcml0ZU9mZlNjcmVlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50RGlzcGF0Y2hlci5lbWl0KCdlbnRlcnZpZXdwb3J0JywgbmV3IEV2ZW50c18zLkVudGVyVmlld1BvcnRFdmVudChhY3RvcikpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdG9yLmlzT2ZmU2NyZWVuID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBPZmZzY3JlZW5DdWxsaW5nO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuT2Zmc2NyZWVuQ3VsbGluZyA9IE9mZnNjcmVlbkN1bGxpbmc7XHJcbn0pO1xyXG5kZWZpbmUoXCJUcmFpdHMvVGlsZU1hcENvbGxpc2lvbkRldGVjdGlvblwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkFjdG9yXCIsIFwiQ29sbGlzaW9uL1NpZGVcIiwgXCJFdmVudHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBBY3Rvcl82LCBTaWRlXzIsIEV2ZW50c180KSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIHZhciBUaWxlTWFwQ29sbGlzaW9uRGV0ZWN0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBUaWxlTWFwQ29sbGlzaW9uRGV0ZWN0aW9uKCkge1xyXG4gICAgICAgIH1cclxuICAgICAgICBUaWxlTWFwQ29sbGlzaW9uRGV0ZWN0aW9uLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoYWN0b3IsIGVuZ2luZSkge1xyXG4gICAgICAgICAgICB2YXIgZXZlbnREaXNwYXRjaGVyID0gYWN0b3IuZXZlbnREaXNwYXRjaGVyO1xyXG4gICAgICAgICAgICBpZiAoYWN0b3IuY29sbGlzaW9uVHlwZSAhPT0gQWN0b3JfNi5Db2xsaXNpb25UeXBlLlByZXZlbnRDb2xsaXNpb24gJiYgZW5naW5lLmN1cnJlbnRTY2VuZSAmJiBlbmdpbmUuY3VycmVudFNjZW5lLnRpbGVNYXBzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVuZ2luZS5jdXJyZW50U2NlbmUudGlsZU1hcHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWFwID0gZW5naW5lLmN1cnJlbnRTY2VuZS50aWxlTWFwc1tqXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW50ZXJzZWN0TWFwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzaWRlID0gU2lkZV8yLlNpZGUuTm9uZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4ID0gMjtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaW50ZXJzZWN0TWFwID0gbWFwLmNvbGxpZGVzKGFjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF4LS0gPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWRlID0gYWN0b3IuZ2V0U2lkZUZyb21JbnRlcnNlY3QoaW50ZXJzZWN0TWFwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnREaXNwYXRjaGVyLmVtaXQoJ3ByZWNvbGxpc2lvbicsIG5ldyBFdmVudHNfNC5QcmVDb2xsaXNpb25FdmVudChhY3RvciwgbnVsbCwgc2lkZSwgaW50ZXJzZWN0TWFwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhY3Rvci5jb2xsaXNpb25UeXBlID09PSBBY3Rvcl82LkNvbGxpc2lvblR5cGUuQWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rvci5wb3MueSArPSBpbnRlcnNlY3RNYXAueTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdG9yLnBvcy54ICs9IGludGVyc2VjdE1hcC54O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnREaXNwYXRjaGVyLmVtaXQoJ3Bvc3Rjb2xsaXNpb24nLCBuZXcgRXZlbnRzXzQuUG9zdENvbGxpc2lvbkV2ZW50KGFjdG9yLCBudWxsLCBzaWRlLCBpbnRlcnNlY3RNYXApKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFRpbGVNYXBDb2xsaXNpb25EZXRlY3Rpb247XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5UaWxlTWFwQ29sbGlzaW9uRGV0ZWN0aW9uID0gVGlsZU1hcENvbGxpc2lvbkRldGVjdGlvbjtcclxufSk7XHJcbmRlZmluZShcIlRyYWl0cy9JbmRleFwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIlRyYWl0cy9DYXB0dXJlUG9pbnRlclwiLCBcIlRyYWl0cy9FdWxlck1vdmVtZW50XCIsIFwiVHJhaXRzL09mZnNjcmVlbkN1bGxpbmdcIiwgXCJUcmFpdHMvVGlsZU1hcENvbGxpc2lvbkRldGVjdGlvblwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIENhcHR1cmVQb2ludGVyXzEsIEV1bGVyTW92ZW1lbnRfMSwgT2Zmc2NyZWVuQ3VsbGluZ18xLCBUaWxlTWFwQ29sbGlzaW9uRGV0ZWN0aW9uXzEpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIF9fZXhwb3J0KENhcHR1cmVQb2ludGVyXzEpO1xyXG4gICAgX19leHBvcnQoRXVsZXJNb3ZlbWVudF8xKTtcclxuICAgIF9fZXhwb3J0KE9mZnNjcmVlbkN1bGxpbmdfMSk7XHJcbiAgICBfX2V4cG9ydChUaWxlTWFwQ29sbGlzaW9uRGV0ZWN0aW9uXzEpO1xyXG59KTtcclxuZGVmaW5lKFwiUGFydGljbGVzXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiQWN0b3JcIiwgXCJEcmF3aW5nL0NvbG9yXCIsIFwiQWxnZWJyYVwiLCBcIlV0aWwvVXRpbFwiLCBcIlV0aWwvRHJhd1V0aWxcIiwgXCJUcmFpdHMvSW5kZXhcIiwgXCJDb25maWd1cmFibGVcIiwgXCJNYXRoL1JhbmRvbVwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIEFjdG9yXzcsIENvbG9yXzE0LCBBbGdlYnJhXzE1LCBVdGlsLCBEcmF3VXRpbCwgVHJhaXRzLCBDb25maWd1cmFibGVfNSwgUmFuZG9tXzIpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBlbnVtIHRoYXQgcmVwcmVzZW50cyB0aGUgdHlwZXMgb2YgZW1pdHRlciBub3p6bGVzXHJcbiAgICAgKi9cclxuICAgIHZhciBFbWl0dGVyVHlwZTtcclxuICAgIChmdW5jdGlvbiAoRW1pdHRlclR5cGUpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25zdGFudCBmb3IgdGhlIGNpcmN1bGFyIGVtaXR0ZXIgdHlwZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVtaXR0ZXJUeXBlW0VtaXR0ZXJUeXBlW1wiQ2lyY2xlXCJdID0gMF0gPSBcIkNpcmNsZVwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0YW50IGZvciB0aGUgcmVjdGFuZ3VsYXIgZW1pdHRlciB0eXBlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRW1pdHRlclR5cGVbRW1pdHRlclR5cGVbXCJSZWN0YW5nbGVcIl0gPSAxXSA9IFwiUmVjdGFuZ2xlXCI7XHJcbiAgICB9KShFbWl0dGVyVHlwZSA9IGV4cG9ydHMuRW1pdHRlclR5cGUgfHwgKGV4cG9ydHMuRW1pdHRlclR5cGUgPSB7fSkpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaGlkZGVuXHJcbiAgICAgKi9cclxuICAgIHZhciBQYXJ0aWNsZUltcGwgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIFBhcnRpY2xlSW1wbChlbWl0dGVyT3JDb25maWcsIGxpZmUsIG9wYWNpdHksIGJlZ2luQ29sb3IsIGVuZENvbG9yLCBwb3NpdGlvbiwgdmVsb2NpdHksIGFjY2VsZXJhdGlvbiwgc3RhcnRTaXplLCBlbmRTaXplKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSBuZXcgQWxnZWJyYV8xNS5WZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMudmVsb2NpdHkgPSBuZXcgQWxnZWJyYV8xNS5WZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMuYWNjZWxlcmF0aW9uID0gbmV3IEFsZ2VicmFfMTUuVmVjdG9yKDAsIDApO1xyXG4gICAgICAgICAgICB0aGlzLnBhcnRpY2xlUm90YXRpb25hbFZlbG9jaXR5ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50Um90YXRpb24gPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmZvY3VzID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5mb2N1c0FjY2VsID0gMDtcclxuICAgICAgICAgICAgdGhpcy5vcGFjaXR5ID0gMTtcclxuICAgICAgICAgICAgdGhpcy5iZWdpbkNvbG9yID0gQ29sb3JfMTQuQ29sb3IuV2hpdGUuY2xvbmUoKTtcclxuICAgICAgICAgICAgdGhpcy5lbmRDb2xvciA9IENvbG9yXzE0LkNvbG9yLldoaXRlLmNsb25lKCk7XHJcbiAgICAgICAgICAgIC8vIExpZmUgaXMgY291bnRlZCBpbiBtc1xyXG4gICAgICAgICAgICB0aGlzLmxpZmUgPSAzMDA7XHJcbiAgICAgICAgICAgIHRoaXMuZmFkZUZsYWcgPSBmYWxzZTtcclxuICAgICAgICAgICAgLy8gQ29sb3IgdHJhbnNpdGlvbnNcclxuICAgICAgICAgICAgdGhpcy5fclJhdGUgPSAxO1xyXG4gICAgICAgICAgICB0aGlzLl9nUmF0ZSA9IDE7XHJcbiAgICAgICAgICAgIHRoaXMuX2JSYXRlID0gMTtcclxuICAgICAgICAgICAgdGhpcy5fYVJhdGUgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50Q29sb3IgPSBDb2xvcl8xNC5Db2xvci5XaGl0ZS5jbG9uZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLnBhcnRpY2xlU2l6ZSA9IDU7XHJcbiAgICAgICAgICAgIHRoaXMucGFydGljbGVTcHJpdGUgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLnNpemVSYXRlID0gMDtcclxuICAgICAgICAgICAgdGhpcy5lbGFwc2VkTXVsdGlwbGllciA9IDA7XHJcbiAgICAgICAgICAgIHZhciBlbWl0dGVyID0gZW1pdHRlck9yQ29uZmlnO1xyXG4gICAgICAgICAgICBpZiAoZW1pdHRlciAmJiAhKGVtaXR0ZXJPckNvbmZpZyBpbnN0YW5jZW9mIFBhcnRpY2xlRW1pdHRlcikpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb25maWcgPSBlbWl0dGVyT3JDb25maWc7XHJcbiAgICAgICAgICAgICAgICBlbWl0dGVyID0gY29uZmlnLmVtaXR0ZXI7XHJcbiAgICAgICAgICAgICAgICBsaWZlID0gY29uZmlnLmxpZmU7XHJcbiAgICAgICAgICAgICAgICBvcGFjaXR5ID0gY29uZmlnLm9wYWNpdHk7XHJcbiAgICAgICAgICAgICAgICBlbmRDb2xvciA9IGNvbmZpZy5lbmRDb2xvcjtcclxuICAgICAgICAgICAgICAgIGJlZ2luQ29sb3IgPSBjb25maWcuYmVnaW5Db2xvcjtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gY29uZmlnLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgdmVsb2NpdHkgPSBjb25maWcudmVsb2NpdHk7XHJcbiAgICAgICAgICAgICAgICBhY2NlbGVyYXRpb24gPSBjb25maWcuYWNjZWxlcmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgc3RhcnRTaXplID0gY29uZmlnLnN0YXJ0U2l6ZTtcclxuICAgICAgICAgICAgICAgIGVuZFNpemUgPSBjb25maWcuZW5kU2l6ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIgPSBlbWl0dGVyO1xyXG4gICAgICAgICAgICB0aGlzLmxpZmUgPSBsaWZlIHx8IHRoaXMubGlmZTtcclxuICAgICAgICAgICAgdGhpcy5vcGFjaXR5ID0gb3BhY2l0eSB8fCB0aGlzLm9wYWNpdHk7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kQ29sb3IgPSBlbmRDb2xvciB8fCB0aGlzLmVuZENvbG9yLmNsb25lKCk7XHJcbiAgICAgICAgICAgIHRoaXMuYmVnaW5Db2xvciA9IGJlZ2luQ29sb3IgfHwgdGhpcy5iZWdpbkNvbG9yLmNsb25lKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRDb2xvciA9IHRoaXMuYmVnaW5Db2xvci5jbG9uZSgpO1xyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb24gfHwgdGhpcy5wb3NpdGlvbjtcclxuICAgICAgICAgICAgdGhpcy52ZWxvY2l0eSA9IHZlbG9jaXR5IHx8IHRoaXMudmVsb2NpdHk7XHJcbiAgICAgICAgICAgIHRoaXMuYWNjZWxlcmF0aW9uID0gYWNjZWxlcmF0aW9uIHx8IHRoaXMuYWNjZWxlcmF0aW9uO1xyXG4gICAgICAgICAgICB0aGlzLl9yUmF0ZSA9ICh0aGlzLmVuZENvbG9yLnIgLSB0aGlzLmJlZ2luQ29sb3IucikgLyB0aGlzLmxpZmU7XHJcbiAgICAgICAgICAgIHRoaXMuX2dSYXRlID0gKHRoaXMuZW5kQ29sb3IuZyAtIHRoaXMuYmVnaW5Db2xvci5nKSAvIHRoaXMubGlmZTtcclxuICAgICAgICAgICAgdGhpcy5fYlJhdGUgPSAodGhpcy5lbmRDb2xvci5iIC0gdGhpcy5iZWdpbkNvbG9yLmIpIC8gdGhpcy5saWZlO1xyXG4gICAgICAgICAgICB0aGlzLl9hUmF0ZSA9IHRoaXMub3BhY2l0eSAvIHRoaXMubGlmZTtcclxuICAgICAgICAgICAgdGhpcy5zdGFydFNpemUgPSBzdGFydFNpemUgfHwgMDtcclxuICAgICAgICAgICAgdGhpcy5lbmRTaXplID0gZW5kU2l6ZSB8fCAwO1xyXG4gICAgICAgICAgICBpZiAoKHRoaXMuZW5kU2l6ZSA+IDApICYmICh0aGlzLnN0YXJ0U2l6ZSA+IDApKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNpemVSYXRlID0gKHRoaXMuZW5kU2l6ZSAtIHRoaXMuc3RhcnRTaXplKSAvIHRoaXMubGlmZTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFydGljbGVTaXplID0gdGhpcy5zdGFydFNpemU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgUGFydGljbGVJbXBsLnByb3RvdHlwZS5raWxsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIucmVtb3ZlUGFydGljbGUodGhpcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQYXJ0aWNsZUltcGwucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xyXG4gICAgICAgICAgICB0aGlzLmxpZmUgPSB0aGlzLmxpZmUgLSBkZWx0YTtcclxuICAgICAgICAgICAgdGhpcy5lbGFwc2VkTXVsdGlwbGllciA9IHRoaXMuZWxhcHNlZE11bHRpcGxpZXIgKyBkZWx0YTtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGlmZSA8IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMua2lsbCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZhZGVGbGFnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wYWNpdHkgPSBVdGlsLmNsYW1wKHRoaXMuX2FSYXRlICogdGhpcy5saWZlLCAwLjAwMDEsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgodGhpcy5zdGFydFNpemUgPiAwKSAmJiAodGhpcy5lbmRTaXplID4gMCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFydGljbGVTaXplID0gVXRpbC5jbGFtcCh0aGlzLnNpemVSYXRlICogZGVsdGEgKyB0aGlzLnBhcnRpY2xlU2l6ZSwgTWF0aC5taW4odGhpcy5zdGFydFNpemUsIHRoaXMuZW5kU2l6ZSksIE1hdGgubWF4KHRoaXMuc3RhcnRTaXplLCB0aGlzLmVuZFNpemUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50Q29sb3IuciA9IFV0aWwuY2xhbXAodGhpcy5fY3VycmVudENvbG9yLnIgKyB0aGlzLl9yUmF0ZSAqIGRlbHRhLCAwLCAyNTUpO1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50Q29sb3IuZyA9IFV0aWwuY2xhbXAodGhpcy5fY3VycmVudENvbG9yLmcgKyB0aGlzLl9nUmF0ZSAqIGRlbHRhLCAwLCAyNTUpO1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50Q29sb3IuYiA9IFV0aWwuY2xhbXAodGhpcy5fY3VycmVudENvbG9yLmIgKyB0aGlzLl9iUmF0ZSAqIGRlbHRhLCAwLCAyNTUpO1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50Q29sb3IuYSA9IFV0aWwuY2xhbXAodGhpcy5vcGFjaXR5LCAwLjAwMDEsIDEpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5mb2N1cykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFjY2VsID0gdGhpcy5mb2N1cy5zdWIodGhpcy5wb3NpdGlvbikubm9ybWFsaXplKCkuc2NhbGUodGhpcy5mb2N1c0FjY2VsKS5zY2FsZShkZWx0YSAvIDEwMDApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy52ZWxvY2l0eSA9IHRoaXMudmVsb2NpdHkuYWRkKGFjY2VsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmVsb2NpdHkgPSB0aGlzLnZlbG9jaXR5LmFkZCh0aGlzLmFjY2VsZXJhdGlvbi5zY2FsZShkZWx0YSAvIDEwMDApKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbi5hZGQodGhpcy52ZWxvY2l0eS5zY2FsZShkZWx0YSAvIDEwMDApKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGFydGljbGVSb3RhdGlvbmFsVmVsb2NpdHkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFJvdGF0aW9uID0gKHRoaXMuY3VycmVudFJvdGF0aW9uICsgdGhpcy5wYXJ0aWNsZVJvdGF0aW9uYWxWZWxvY2l0eSAqIGRlbHRhIC8gMTAwMCkgJSAoMiAqIE1hdGguUEkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQYXJ0aWNsZUltcGwucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnRpY2xlU3ByaXRlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnRpY2xlU3ByaXRlLnJvdGF0aW9uID0gdGhpcy5jdXJyZW50Um90YXRpb247XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnRpY2xlU3ByaXRlLnNjYWxlLnNldFRvKHRoaXMucGFydGljbGVTaXplLCB0aGlzLnBhcnRpY2xlU2l6ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnRpY2xlU3ByaXRlLmRyYXcoY3R4LCB0aGlzLnBvc2l0aW9uLngsIHRoaXMucG9zaXRpb24ueSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudENvbG9yLmEgPSBVdGlsLmNsYW1wKHRoaXMub3BhY2l0eSwgMC4wMDAxLCAxKTtcclxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuX2N1cnJlbnRDb2xvci50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5hcmModGhpcy5wb3NpdGlvbi54LCB0aGlzLnBvc2l0aW9uLnksIHRoaXMucGFydGljbGVTaXplLCAwLCBNYXRoLlBJICogMik7XHJcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XHJcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBQYXJ0aWNsZUltcGw7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5QYXJ0aWNsZUltcGwgPSBQYXJ0aWNsZUltcGw7XHJcbiAgICAvKipcclxuICAgICAqIFBhcnRpY2xlIGlzIHVzZWQgaW4gYSBbW1BhcnRpY2xlRW1pdHRlcl1dXHJcbiAgICAgKi9cclxuICAgIHZhciBQYXJ0aWNsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFBhcnRpY2xlLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFBhcnRpY2xlKGVtaXR0ZXJPckNvbmZpZywgbGlmZSwgb3BhY2l0eSwgYmVnaW5Db2xvciwgZW5kQ29sb3IsIHBvc2l0aW9uLCB2ZWxvY2l0eSwgYWNjZWxlcmF0aW9uLCBzdGFydFNpemUsIGVuZFNpemUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGVtaXR0ZXJPckNvbmZpZywgbGlmZSwgb3BhY2l0eSwgYmVnaW5Db2xvciwgZW5kQ29sb3IsIHBvc2l0aW9uLCB2ZWxvY2l0eSwgYWNjZWxlcmF0aW9uLCBzdGFydFNpemUsIGVuZFNpemUpIHx8IHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQYXJ0aWNsZTtcclxuICAgIH0oQ29uZmlndXJhYmxlXzUuQ29uZmlndXJhYmxlKFBhcnRpY2xlSW1wbCkpKTtcclxuICAgIGV4cG9ydHMuUGFydGljbGUgPSBQYXJ0aWNsZTtcclxuICAgIC8qKlxyXG4gICAgICogQGhpZGRlblxyXG4gICAgICovXHJcbiAgICB2YXIgUGFydGljbGVFbWl0dGVySW1wbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFBhcnRpY2xlRW1pdHRlckltcGwsIF9zdXBlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHggICAgICAgVGhlIHggcG9zaXRpb24gb2YgdGhlIGVtaXR0ZXJcclxuICAgICAgICAgKiBAcGFyYW0geSAgICAgICBUaGUgeSBwb3NpdGlvbiBvZiB0aGUgZW1pdHRlclxyXG4gICAgICAgICAqIEBwYXJhbSB3aWR0aCAgIFRoZSB3aWR0aCBvZiB0aGUgZW1pdHRlclxyXG4gICAgICAgICAqIEBwYXJhbSBoZWlnaHQgIFRoZSBoZWlnaHQgb2YgdGhlIGVtaXR0ZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBQYXJ0aWNsZUVtaXR0ZXJJbXBsKHhPckNvbmZpZywgeSwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlb2YgeE9yQ29uZmlnID09PSAnbnVtYmVyJyA/IHsgeDogeE9yQ29uZmlnLCB5OiB5LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0gOiB4T3JDb25maWcpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLm51bVBhcnRpY2xlcyA9IDA7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGlzRW1pdHRpbmcgZmxhZ1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuaXNFbWl0dGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGJhY2tpbmcgcGFydGljbGUgY29sbGVjdGlvblxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMucGFydGljbGVzID0gbnVsbDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgYmFja2luZyBkZWFkUGFydGljbGUgY29sbGVjdGlvblxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuZGVhZFBhcnRpY2xlcyA9IG51bGw7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG1pbmltdW0gcGFydGljbGUgdmVsb2NpdHlcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLm1pblZlbCA9IDA7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG1heGltdW0gcGFydGljbGUgdmVsb2NpdHlcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLm1heFZlbCA9IDA7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGFjY2VsZXJhdGlvbiB2ZWN0b3IgZm9yIGFsbCBwYXJ0aWNsZXNcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmFjY2VsZXJhdGlvbiA9IG5ldyBBbGdlYnJhXzE1LlZlY3RvcigwLCAwKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbWluaW11bSBhbmdsZSBpbiByYWRpYW5zXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5taW5BbmdsZSA9IDA7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG1heGltdW0gYW5nbGUgaW4gcmFkaWFuc1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMubWF4QW5nbGUgPSAwO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBlbWlzc2lvbiByYXRlIGZvciBwYXJ0aWNsZXMgKHBhcnRpY2xlcy9zZWMpXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5lbWl0UmF0ZSA9IDE7IC8vcGFydGljbGVzL3NlY1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBsaWZlIG9mIGVhY2ggcGFydGljbGUgaW4gbWlsbGlzZWNvbmRzXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5wYXJ0aWNsZUxpZmUgPSAyMDAwO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBvcGFjaXR5IG9mIGVhY2ggcGFydGljbGUgZnJvbSAwIHRvIDEuMFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMub3BhY2l0eSA9IDE7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGZhZGUgZmxhZyB3aGljaCBjYXVzZXMgcGFydGljbGVzIHRvIGdyYWR1YWxseSBmYWRlIG91dCBvdmVyIHRoZSBjb3Vyc2Ugb2YgdGhlaXIgbGlmZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmZhZGVGbGFnID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG9wdGlvbmFsIGZvY3VzIHdoZXJlIGFsbCBwYXJ0aWNsZXMgc2hvdWxkIGFjY2VsZXJhdGUgdG93YXJkc1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuZm9jdXMgPSBudWxsO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBhY2NlbGVyYXRpb24gZm9yIGZvY3VzaW5nIHBhcnRpY2xlcyBpZiBhIGZvY3VzIGhhcyBiZWVuIHNwZWNpZmllZFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuZm9jdXNBY2NlbCA9IDE7XHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgb3B0aW9uYWwgc3RhcnRpbmcgc2l6ZSBmb3IgdGhlIHBhcnRpY2xlc1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuc3RhcnRTaXplID0gbnVsbDtcclxuICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBvcHRpb25hbCBlbmRpbmcgc2l6ZSBmb3IgdGhlIHBhcnRpY2xlc1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuZW5kU2l6ZSA9IG51bGw7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG1pbmltdW0gc2l6ZSBvZiBhbGwgcGFydGljbGVzXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5taW5TaXplID0gNTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbWF4aW11bSBzaXplIG9mIGFsbCBwYXJ0aWNsZXNcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLm1heFNpemUgPSA1O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBiZWdpbm5pbmcgY29sb3Igb2YgYWxsIHBhcnRpY2xlc1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuYmVnaW5Db2xvciA9IENvbG9yXzE0LkNvbG9yLldoaXRlLmNsb25lKCk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGVuZGluZyBjb2xvciBvZiBhbGwgcGFydGljbGVzXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5lbmRDb2xvciA9IENvbG9yXzE0LkNvbG9yLldoaXRlLmNsb25lKCk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHNwcml0ZSB0aGF0IGEgcGFydGljbGUgc2hvdWxkIHVzZVxyXG4gICAgICAgICAgICAgKiBAd2FybmluZyBQZXJmb3JtYW5jZSBpbnRlbnNpdmVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLnBhcnRpY2xlU3ByaXRlID0gbnVsbDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgZW1pdHRlciB0eXBlIGZvciB0aGUgcGFydGljbGUgZW1pdHRlclxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuZW1pdHRlclR5cGUgPSBFbWl0dGVyVHlwZS5SZWN0YW5nbGU7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGVtaXR0ZXIgcmFkaXVzLCBvbmx5IHRha2VzIGVmZmVjdCB3aGVuIHRoZSBbW2VtaXR0ZXJUeXBlXV0gaXMgW1tFbWl0dGVyVHlwZS5DaXJjbGVdXVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMucmFkaXVzID0gMDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgcGFydGljbGUgcm90YXRpb25hbCBzcGVlZCB2ZWxvY2l0eVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMucGFydGljbGVSb3RhdGlvbmFsVmVsb2NpdHkgPSAwO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgcGFydGljbGVzIHNob3VsZCBzdGFydCB3aXRoIGEgcmFuZG9tIHJvdGF0aW9uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5yYW5kb21Sb3RhdGlvbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICBfdGhpcy5fcGFydGljbGVzVG9FbWl0ID0gMDtcclxuICAgICAgICAgICAgX3RoaXMuY29sbGlzaW9uVHlwZSA9IEFjdG9yXzcuQ29sbGlzaW9uVHlwZS5QcmV2ZW50Q29sbGlzaW9uO1xyXG4gICAgICAgICAgICBfdGhpcy5wYXJ0aWNsZXMgPSBuZXcgVXRpbC5Db2xsZWN0aW9uKCk7XHJcbiAgICAgICAgICAgIF90aGlzLmRlYWRQYXJ0aWNsZXMgPSBuZXcgVXRpbC5Db2xsZWN0aW9uKCk7XHJcbiAgICAgICAgICAgIF90aGlzLnJhbmRvbSA9IG5ldyBSYW5kb21fMi5SYW5kb20oKTtcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIG9mZnNjcmVlbiBjdWxsaW5nIGZyb20gcGFydGljbGUgZW1pdHRlcnNcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpcy50cmFpdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy50cmFpdHNbaV0gaW5zdGFuY2VvZiBUcmFpdHMuT2Zmc2NyZWVuQ3VsbGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRyYWl0cy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBQYXJ0aWNsZUVtaXR0ZXJJbXBsLnByb3RvdHlwZS5yZW1vdmVQYXJ0aWNsZSA9IGZ1bmN0aW9uIChwYXJ0aWNsZSkge1xyXG4gICAgICAgICAgICB0aGlzLmRlYWRQYXJ0aWNsZXMucHVzaChwYXJ0aWNsZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYXVzZXMgdGhlIGVtaXR0ZXIgdG8gZW1pdCBwYXJ0aWNsZXNcclxuICAgICAgICAgKiBAcGFyYW0gcGFydGljbGVDb3VudCAgTnVtYmVyIG9mIHBhcnRpY2xlcyB0byBlbWl0IHJpZ2h0IG5vd1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBhcnRpY2xlRW1pdHRlckltcGwucHJvdG90eXBlLmVtaXRQYXJ0aWNsZXMgPSBmdW5jdGlvbiAocGFydGljbGVDb3VudCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRpY2xlQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZXMucHVzaCh0aGlzLl9jcmVhdGVQYXJ0aWNsZSgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgUGFydGljbGVFbWl0dGVySW1wbC5wcm90b3R5cGUuY2xlYXJQYXJ0aWNsZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFydGljbGVzLmNsZWFyKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBDcmVhdGVzIGEgbmV3IHBhcnRpY2xlIGdpdmVuIHRoZSBjb25zdHJhaW50cyBvZiB0aGUgZW1pdHRlclxyXG4gICAgICAgIFBhcnRpY2xlRW1pdHRlckltcGwucHJvdG90eXBlLl9jcmVhdGVQYXJ0aWNsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gdG9kbyBpbXBsZW1lbnQgZW1pdHRlciBjb25zdHJhaW50cztcclxuICAgICAgICAgICAgdmFyIHJhblggPSAwO1xyXG4gICAgICAgICAgICB2YXIgcmFuWSA9IDA7XHJcbiAgICAgICAgICAgIHZhciBhbmdsZSA9IFV0aWwucmFuZG9tSW5SYW5nZSh0aGlzLm1pbkFuZ2xlLCB0aGlzLm1heEFuZ2xlLCB0aGlzLnJhbmRvbSk7XHJcbiAgICAgICAgICAgIHZhciB2ZWwgPSBVdGlsLnJhbmRvbUluUmFuZ2UodGhpcy5taW5WZWwsIHRoaXMubWF4VmVsLCB0aGlzLnJhbmRvbSk7XHJcbiAgICAgICAgICAgIHZhciBzaXplID0gdGhpcy5zdGFydFNpemUgfHwgVXRpbC5yYW5kb21JblJhbmdlKHRoaXMubWluU2l6ZSwgdGhpcy5tYXhTaXplLCB0aGlzLnJhbmRvbSk7XHJcbiAgICAgICAgICAgIHZhciBkeCA9IHZlbCAqIE1hdGguY29zKGFuZ2xlKTtcclxuICAgICAgICAgICAgdmFyIGR5ID0gdmVsICogTWF0aC5zaW4oYW5nbGUpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5lbWl0dGVyVHlwZSA9PT0gRW1pdHRlclR5cGUuUmVjdGFuZ2xlKSB7XHJcbiAgICAgICAgICAgICAgICByYW5YID0gVXRpbC5yYW5kb21JblJhbmdlKHRoaXMucG9zLngsIHRoaXMucG9zLnggKyB0aGlzLmdldFdpZHRoKCksIHRoaXMucmFuZG9tKTtcclxuICAgICAgICAgICAgICAgIHJhblkgPSBVdGlsLnJhbmRvbUluUmFuZ2UodGhpcy5wb3MueSwgdGhpcy5wb3MueSArIHRoaXMuZ2V0SGVpZ2h0KCksIHRoaXMucmFuZG9tKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmVtaXR0ZXJUeXBlID09PSBFbWl0dGVyVHlwZS5DaXJjbGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciByYWRpdXMgPSBVdGlsLnJhbmRvbUluUmFuZ2UoMCwgdGhpcy5yYWRpdXMsIHRoaXMucmFuZG9tKTtcclxuICAgICAgICAgICAgICAgIHJhblggPSByYWRpdXMgKiBNYXRoLmNvcyhhbmdsZSkgKyB0aGlzLnBvcy54O1xyXG4gICAgICAgICAgICAgICAgcmFuWSA9IHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlKSArIHRoaXMucG9zLnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHAgPSBuZXcgUGFydGljbGUodGhpcywgdGhpcy5wYXJ0aWNsZUxpZmUsIHRoaXMub3BhY2l0eSwgdGhpcy5iZWdpbkNvbG9yLCB0aGlzLmVuZENvbG9yLCBuZXcgQWxnZWJyYV8xNS5WZWN0b3IocmFuWCwgcmFuWSksIG5ldyBBbGdlYnJhXzE1LlZlY3RvcihkeCwgZHkpLCB0aGlzLmFjY2VsZXJhdGlvbiwgdGhpcy5zdGFydFNpemUsIHRoaXMuZW5kU2l6ZSk7XHJcbiAgICAgICAgICAgIHAuZmFkZUZsYWcgPSB0aGlzLmZhZGVGbGFnO1xyXG4gICAgICAgICAgICBwLnBhcnRpY2xlU2l6ZSA9IHNpemU7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnRpY2xlU3ByaXRlKSB7XHJcbiAgICAgICAgICAgICAgICBwLnBhcnRpY2xlU3ByaXRlID0gdGhpcy5wYXJ0aWNsZVNwcml0ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwLnBhcnRpY2xlUm90YXRpb25hbFZlbG9jaXR5ID0gdGhpcy5wYXJ0aWNsZVJvdGF0aW9uYWxWZWxvY2l0eTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucmFuZG9tUm90YXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHAuY3VycmVudFJvdGF0aW9uID0gVXRpbC5yYW5kb21JblJhbmdlKDAsIE1hdGguUEkgKiAyLCB0aGlzLnJhbmRvbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuZm9jdXMpIHtcclxuICAgICAgICAgICAgICAgIHAuZm9jdXMgPSB0aGlzLmZvY3VzLmFkZChuZXcgQWxnZWJyYV8xNS5WZWN0b3IodGhpcy5wb3MueCwgdGhpcy5wb3MueSkpO1xyXG4gICAgICAgICAgICAgICAgcC5mb2N1c0FjY2VsID0gdGhpcy5mb2N1c0FjY2VsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUGFydGljbGVFbWl0dGVySW1wbC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGVuZ2luZSwgZGVsdGEpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzLCBlbmdpbmUsIGRlbHRhKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNFbWl0dGluZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGFydGljbGVzVG9FbWl0ICs9IHRoaXMuZW1pdFJhdGUgKiAoZGVsdGEgLyAxMDAwKTtcclxuICAgICAgICAgICAgICAgIC8vdmFyIG51bVBhcnRpY2xlcyA9IE1hdGguY2VpbCh0aGlzLmVtaXRSYXRlICogZGVsdGEgLyAxMDAwKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wYXJ0aWNsZXNUb0VtaXQgPiAxLjApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRQYXJ0aWNsZXMoTWF0aC5mbG9vcih0aGlzLl9wYXJ0aWNsZXNUb0VtaXQpKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJ0aWNsZXNUb0VtaXQgPSB0aGlzLl9wYXJ0aWNsZXNUb0VtaXQgLSBNYXRoLmZsb29yKHRoaXMuX3BhcnRpY2xlc1RvRW1pdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZXMuZm9yRWFjaChmdW5jdGlvbiAocCkgeyByZXR1cm4gcC51cGRhdGUoZGVsdGEpOyB9KTtcclxuICAgICAgICAgICAgdGhpcy5kZWFkUGFydGljbGVzLmZvckVhY2goZnVuY3Rpb24gKHApIHsgcmV0dXJuIF90aGlzLnBhcnRpY2xlcy5yZW1vdmVFbGVtZW50KHApOyB9KTtcclxuICAgICAgICAgICAgdGhpcy5kZWFkUGFydGljbGVzLmNsZWFyKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQYXJ0aWNsZUVtaXR0ZXJJbXBsLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gICAgICAgICAgICAvLyB0b2RvIGlzIHRoZXJlIGEgbW9yZSBlZmZpY2llbnQgdG8gZHJhdyBcclxuICAgICAgICAgICAgLy8gcG9zc2libHkgdXNlIGEgd2ViZ2wgb2Zmc2NyZWVuIGNhbnZhcyBhbmQgc2hhZGVycyB0byBkbyBwYXJ0aWNsZXM/XHJcbiAgICAgICAgICAgIHRoaXMucGFydGljbGVzLmZvckVhY2goZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAuZHJhdyhjdHgpOyB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFBhcnRpY2xlRW1pdHRlckltcGwucHJvdG90eXBlLmRlYnVnRHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kZWJ1Z0RyYXcuY2FsbCh0aGlzLCBjdHgpO1xyXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gQ29sb3JfMTQuQ29sb3IuQmxhY2sudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KCdQYXJ0aWNsZXM6ICcgKyB0aGlzLnBhcnRpY2xlcy5jb3VudCgpLCB0aGlzLnBvcy54LCB0aGlzLnBvcy55ICsgMjApO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5mb2N1cykge1xyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KHRoaXMuZm9jdXMueCArIHRoaXMucG9zLngsIHRoaXMuZm9jdXMueSArIHRoaXMucG9zLnksIDMsIDMpO1xyXG4gICAgICAgICAgICAgICAgRHJhd1V0aWwubGluZShjdHgsIENvbG9yXzE0LkNvbG9yLlllbGxvdywgdGhpcy5mb2N1cy54ICsgdGhpcy5wb3MueCwgdGhpcy5mb2N1cy55ICsgdGhpcy5wb3MueSwgX3N1cGVyLnByb3RvdHlwZS5nZXRDZW50ZXIuY2FsbCh0aGlzKS54LCBfc3VwZXIucHJvdG90eXBlLmdldENlbnRlci5jYWxsKHRoaXMpLnkpO1xyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KCdGb2N1cycsIHRoaXMuZm9jdXMueCArIHRoaXMucG9zLngsIHRoaXMuZm9jdXMueSArIHRoaXMucG9zLnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gUGFydGljbGVFbWl0dGVySW1wbDtcclxuICAgIH0oQWN0b3JfNy5BY3RvcikpO1xyXG4gICAgZXhwb3J0cy5QYXJ0aWNsZUVtaXR0ZXJJbXBsID0gUGFydGljbGVFbWl0dGVySW1wbDtcclxuICAgIC8qKlxyXG4gICAgICogVXNpbmcgYSBwYXJ0aWNsZSBlbWl0dGVyIGlzIGEgZ3JlYXQgd2F5IHRvIGNyZWF0ZSBpbnRlcmVzdGluZyBlZmZlY3RzXHJcbiAgICAgKiBpbiB5b3VyIGdhbWUsIGxpa2Ugc21va2UsIGZpcmUsIHdhdGVyLCBleHBsb3Npb25zLCBldGMuIGBQYXJ0aWNsZUVtaXR0ZXJgXHJcbiAgICAgKiBleHRlbmQgW1tBY3Rvcl1dIGFsbG93aW5nIHlvdSB0byB1c2UgYWxsIG9mIHRoZSBmZWF0dXJlcyB0aGF0IGNvbWUgd2l0aC5cclxuICAgICAqXHJcbiAgICAgKiBbW2luY2x1ZGU6UGFydGljbGVzLm1kXV1cclxuICAgICAqL1xyXG4gICAgdmFyIFBhcnRpY2xlRW1pdHRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFBhcnRpY2xlRW1pdHRlciwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBQYXJ0aWNsZUVtaXR0ZXIoeE9yQ29uZmlnLCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB4T3JDb25maWcsIHksIHdpZHRoLCBoZWlnaHQpIHx8IHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQYXJ0aWNsZUVtaXR0ZXI7XHJcbiAgICB9KENvbmZpZ3VyYWJsZV81LkNvbmZpZ3VyYWJsZShQYXJ0aWNsZUVtaXR0ZXJJbXBsKSkpO1xyXG4gICAgZXhwb3J0cy5QYXJ0aWNsZUVtaXR0ZXIgPSBQYXJ0aWNsZUVtaXR0ZXI7XHJcbn0pO1xyXG5kZWZpbmUoXCJUaWxlTWFwXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiQ29sbGlzaW9uL0JvdW5kaW5nQm94XCIsIFwiRHJhd2luZy9Db2xvclwiLCBcIkNsYXNzXCIsIFwiQWxnZWJyYVwiLCBcIlV0aWwvTG9nXCIsIFwiRXZlbnRzXCIsIFwiQ29uZmlndXJhYmxlXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgQm91bmRpbmdCb3hfNCwgQ29sb3JfMTUsIENsYXNzXzQsIEFsZ2VicmFfMTYsIExvZ183LCBFdmVudHMsIENvbmZpZ3VyYWJsZV82KSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogQGhpZGRlblxyXG4gICAgICovXHJcbiAgICB2YXIgVGlsZU1hcEltcGwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhUaWxlTWFwSW1wbCwgX3N1cGVyKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0geCAgICAgICAgICAgICBUaGUgeCBjb29yZGluYXRlIHRvIGFuY2hvciB0aGUgVGlsZU1hcCdzIHVwcGVyIGxlZnQgY29ybmVyIChzaG91bGQgbm90IGJlIGNoYW5nZWQgb25jZSBzZXQpXHJcbiAgICAgICAgICogQHBhcmFtIHkgICAgICAgICAgICAgVGhlIHkgY29vcmRpbmF0ZSB0byBhbmNob3IgdGhlIFRpbGVNYXAncyB1cHBlciBsZWZ0IGNvcm5lciAoc2hvdWxkIG5vdCBiZSBjaGFuZ2VkIG9uY2Ugc2V0KVxyXG4gICAgICAgICAqIEBwYXJhbSBjZWxsV2lkdGggICAgIFRoZSBpbmRpdmlkdWFsIHdpZHRoIG9mIGVhY2ggY2VsbCAoaW4gcGl4ZWxzKSAoc2hvdWxkIG5vdCBiZSBjaGFuZ2VkIG9uY2Ugc2V0KVxyXG4gICAgICAgICAqIEBwYXJhbSBjZWxsSGVpZ2h0ICAgIFRoZSBpbmRpdmlkdWFsIGhlaWdodCBvZiBlYWNoIGNlbGwgKGluIHBpeGVscykgKHNob3VsZCBub3QgYmUgY2hhbmdlZCBvbmNlIHNldClcclxuICAgICAgICAgKiBAcGFyYW0gcm93cyAgICAgICAgICBUaGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIFRpbGVNYXAgKHNob3VsZCBub3QgYmUgY2hhbmdlZCBvbmNlIHNldClcclxuICAgICAgICAgKiBAcGFyYW0gY29scyAgICAgICAgICBUaGUgbnVtYmVyIG9mIGNvbHMgaW4gdGhlIFRpbGVNYXAgKHNob3VsZCBub3QgYmUgY2hhbmdlZCBvbmNlIHNldClcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBUaWxlTWFwSW1wbCh4T3JDb25maWcsIHksIGNlbGxXaWR0aCwgY2VsbEhlaWdodCwgcm93cywgY29scykge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5fY29sbGlkaW5nWCA9IC0xO1xyXG4gICAgICAgICAgICBfdGhpcy5fY29sbGlkaW5nWSA9IC0xO1xyXG4gICAgICAgICAgICBfdGhpcy5fb25TY3JlZW5YU3RhcnQgPSAwO1xyXG4gICAgICAgICAgICBfdGhpcy5fb25TY3JlZW5YRW5kID0gOTk5OTtcclxuICAgICAgICAgICAgX3RoaXMuX29uU2NyZWVuWVN0YXJ0ID0gMDtcclxuICAgICAgICAgICAgX3RoaXMuX29uU2NyZWVuWUVuZCA9IDk5OTk7XHJcbiAgICAgICAgICAgIF90aGlzLl9zcHJpdGVTaGVldHMgPSB7fTtcclxuICAgICAgICAgICAgX3RoaXMubG9nZ2VyID0gTG9nXzcuTG9nZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgICAgIF90aGlzLmRhdGEgPSBbXTtcclxuICAgICAgICAgICAgaWYgKHhPckNvbmZpZyAmJiB0eXBlb2YgeE9yQ29uZmlnID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbmZpZyA9IHhPckNvbmZpZztcclxuICAgICAgICAgICAgICAgIHhPckNvbmZpZyA9IGNvbmZpZy54O1xyXG4gICAgICAgICAgICAgICAgeSA9IGNvbmZpZy55O1xyXG4gICAgICAgICAgICAgICAgY2VsbFdpZHRoID0gY29uZmlnLmNlbGxXaWR0aDtcclxuICAgICAgICAgICAgICAgIGNlbGxIZWlnaHQgPSBjb25maWcuY2VsbEhlaWdodDtcclxuICAgICAgICAgICAgICAgIHJvd3MgPSBjb25maWcucm93cztcclxuICAgICAgICAgICAgICAgIGNvbHMgPSBjb25maWcuY29scztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy5kYXRhID0gbmV3IEFycmF5KHJvd3MgKiBjb2xzKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcm93czsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNkID0gbmV3IENlbGwoaSAqIGNlbGxXaWR0aCArIHhPckNvbmZpZywgaiAqIGNlbGxIZWlnaHQgKyB5LCBjZWxsV2lkdGgsIGNlbGxIZWlnaHQsIGkgKyBqICogY29scyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmRhdGFbaSArIGogKiBjb2xzXSA9IGNkO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBUaWxlTWFwSW1wbC5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVGlsZU1hcEltcGwucHJvdG90eXBlLnJlZ2lzdGVyU3ByaXRlU2hlZXQgPSBmdW5jdGlvbiAoa2V5LCBzcHJpdGVTaGVldCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zcHJpdGVTaGVldHNba2V5XSA9IHNwcml0ZVNoZWV0O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgaW50ZXJzZWN0aW9uIHZlY3RvciB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlc29sdmUgY29sbGlzaW9ucyB3aXRoIGFjdG9ycy4gSWYgdGhlcmVcclxuICAgICAgICAgKiBpcyBubyBjb2xsaXNpb24gbnVsbCBpcyByZXR1cm5lZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBUaWxlTWFwSW1wbC5wcm90b3R5cGUuY29sbGlkZXMgPSBmdW5jdGlvbiAoYWN0b3IpIHtcclxuICAgICAgICAgICAgdmFyIHdpZHRoID0gYWN0b3IucG9zLnggKyBhY3Rvci5nZXRXaWR0aCgpO1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gYWN0b3IucG9zLnkgKyBhY3Rvci5nZXRIZWlnaHQoKTtcclxuICAgICAgICAgICAgdmFyIGFjdG9yQm91bmRzID0gYWN0b3IuZ2V0Qm91bmRzKCk7XHJcbiAgICAgICAgICAgIHZhciBvdmVybGFwcyA9IFtdO1xyXG4gICAgICAgICAgICAvLyB0cmFjZSBwb2ludHMgZm9yIG92ZXJsYXBcclxuICAgICAgICAgICAgZm9yICh2YXIgeCA9IGFjdG9yQm91bmRzLmxlZnQ7IHggPD0gd2lkdGg7IHggKz0gTWF0aC5taW4oYWN0b3IuZ2V0V2lkdGgoKSAvIDIsIHRoaXMuY2VsbFdpZHRoIC8gMikpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHkgPSBhY3RvckJvdW5kcy50b3A7IHkgPD0gaGVpZ2h0OyB5ICs9IE1hdGgubWluKGFjdG9yLmdldEhlaWdodCgpIC8gMiwgdGhpcy5jZWxsSGVpZ2h0IC8gMikpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2VsbCA9IHRoaXMuZ2V0Q2VsbEJ5UG9pbnQoeCwgeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGwgJiYgY2VsbC5zb2xpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3ZlcmxhcCA9IGFjdG9yQm91bmRzLmNvbGxpZGVzKGNlbGwuZ2V0Qm91bmRzKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlyID0gYWN0b3IuZ2V0Q2VudGVyKCkuc3ViKGNlbGwuZ2V0Q2VudGVyKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcmxhcCAmJiBvdmVybGFwLmRvdChkaXIpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcHMucHVzaChvdmVybGFwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob3ZlcmxhcHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIHNtYWxsZXN0IGNoYW5nZSBvdGhlciB0aGFuIHplcm9cclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG92ZXJsYXBzLnJlZHVjZShmdW5jdGlvbiAoYWNjdW0sIG5leHQpIHtcclxuICAgICAgICAgICAgICAgIHZhciB4ID0gYWNjdW0ueDtcclxuICAgICAgICAgICAgICAgIHZhciB5ID0gYWNjdW0ueTtcclxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhhY2N1bS54KSA8IE1hdGguYWJzKG5leHQueCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB4ID0gbmV4dC54O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGFjY3VtLnkpIDwgTWF0aC5hYnMobmV4dC55KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHkgPSBuZXh0Lnk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFsZ2VicmFfMTYuVmVjdG9yKHgsIHkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIFtbQ2VsbF1dIGJ5IGluZGV4IChyb3cgbWFqb3Igb3JkZXIpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVGlsZU1hcEltcGwucHJvdG90eXBlLmdldENlbGxCeUluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFbaW5kZXhdO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgW1tDZWxsXV0gYnkgaXRzIHggYW5kIHkgY29vcmRpbmF0ZXNcclxuICAgICAgICAgKi9cclxuICAgICAgICBUaWxlTWFwSW1wbC5wcm90b3R5cGUuZ2V0Q2VsbCA9IGZ1bmN0aW9uICh4LCB5KSB7XHJcbiAgICAgICAgICAgIGlmICh4IDwgMCB8fCB5IDwgMCB8fCB4ID49IHRoaXMuY29scyB8fCB5ID49IHRoaXMucm93cykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVt4ICsgeSAqIHRoaXMuY29sc107XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBbW0NlbGxdXSBieSB0ZXN0aW5nIGEgcG9pbnQgaW4gZ2xvYmFsIGNvb3JkaW5hdGVzLFxyXG4gICAgICAgICAqIHJldHVybnMgYG51bGxgIGlmIG5vIGNlbGwgd2FzIGZvdW5kLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRpbGVNYXBJbXBsLnByb3RvdHlwZS5nZXRDZWxsQnlQb2ludCA9IGZ1bmN0aW9uICh4LCB5KSB7XHJcbiAgICAgICAgICAgIHggPSBNYXRoLmZsb29yKCh4IC0gdGhpcy54KSAvIHRoaXMuY2VsbFdpZHRoKTtcclxuICAgICAgICAgICAgeSA9IE1hdGguZmxvb3IoKHkgLSB0aGlzLnkpIC8gdGhpcy5jZWxsSGVpZ2h0KTtcclxuICAgICAgICAgICAgdmFyIGNlbGwgPSB0aGlzLmdldENlbGwoeCwgeSk7XHJcbiAgICAgICAgICAgIGlmICh4ID49IDAgJiYgeSA+PSAwICYmIHggPCB0aGlzLmNvbHMgJiYgeSA8IHRoaXMucm93cyAmJiBjZWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2VsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFRpbGVNYXBJbXBsLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZW5naW5lLCBkZWx0YSkge1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3ByZXVwZGF0ZScsIG5ldyBFdmVudHMuUHJlVXBkYXRlRXZlbnQoZW5naW5lLCBkZWx0YSwgdGhpcykpO1xyXG4gICAgICAgICAgICB2YXIgd29ybGRDb29yZHNVcHBlckxlZnQgPSBlbmdpbmUuc2NyZWVuVG9Xb3JsZENvb3JkaW5hdGVzKG5ldyBBbGdlYnJhXzE2LlZlY3RvcigwLCAwKSk7XHJcbiAgICAgICAgICAgIHZhciB3b3JsZENvb3Jkc0xvd2VyUmlnaHQgPSBlbmdpbmUuc2NyZWVuVG9Xb3JsZENvb3JkaW5hdGVzKG5ldyBBbGdlYnJhXzE2LlZlY3RvcihlbmdpbmUuY2FudmFzLmNsaWVudFdpZHRoLCBlbmdpbmUuY2FudmFzLmNsaWVudEhlaWdodCkpO1xyXG4gICAgICAgICAgICB0aGlzLl9vblNjcmVlblhTdGFydCA9IE1hdGgubWF4KE1hdGguZmxvb3Iod29ybGRDb29yZHNVcHBlckxlZnQueCAvIHRoaXMuY2VsbFdpZHRoKSAtIDIsIDApO1xyXG4gICAgICAgICAgICB0aGlzLl9vblNjcmVlbllTdGFydCA9IE1hdGgubWF4KE1hdGguZmxvb3IoKHdvcmxkQ29vcmRzVXBwZXJMZWZ0LnkgLSB0aGlzLnkpIC8gdGhpcy5jZWxsSGVpZ2h0KSAtIDIsIDApO1xyXG4gICAgICAgICAgICB0aGlzLl9vblNjcmVlblhFbmQgPSBNYXRoLm1heChNYXRoLmZsb29yKHdvcmxkQ29vcmRzTG93ZXJSaWdodC54IC8gdGhpcy5jZWxsV2lkdGgpICsgMiwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMuX29uU2NyZWVuWUVuZCA9IE1hdGgubWF4KE1hdGguZmxvb3IoKHdvcmxkQ29vcmRzTG93ZXJSaWdodC55IC0gdGhpcy55KSAvIHRoaXMuY2VsbEhlaWdodCkgKyAyLCAwKTtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdwb3N0dXBkYXRlJywgbmV3IEV2ZW50cy5Qb3N0VXBkYXRlRXZlbnQoZW5naW5lLCBkZWx0YSwgdGhpcykpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRHJhd3MgdGhlIHRpbGUgbWFwIHRvIHRoZSBzY3JlZW4uIENhbGxlZCBieSB0aGUgW1tTY2VuZV1dLlxyXG4gICAgICAgICAqIEBwYXJhbSBjdHggICAgVGhlIGN1cnJlbnQgcmVuZGVyaW5nIGNvbnRleHRcclxuICAgICAgICAgKiBAcGFyYW0gZGVsdGEgIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBsYXN0IGRyYXdcclxuICAgICAgICAgKi9cclxuICAgICAgICBUaWxlTWFwSW1wbC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjdHgsIGRlbHRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncHJlZHJhdycsIG5ldyBFdmVudHMuUHJlRHJhd0V2ZW50KGN0eCwgZGVsdGEsIHRoaXMpKTtcclxuICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLngsIHRoaXMueSk7XHJcbiAgICAgICAgICAgIHZhciB4ID0gdGhpcy5fb25TY3JlZW5YU3RhcnQsIHhFbmQgPSBNYXRoLm1pbih0aGlzLl9vblNjcmVlblhFbmQsIHRoaXMuY29scyk7XHJcbiAgICAgICAgICAgIHZhciB5ID0gdGhpcy5fb25TY3JlZW5ZU3RhcnQsIHlFbmQgPSBNYXRoLm1pbih0aGlzLl9vblNjcmVlbllFbmQsIHRoaXMucm93cyk7XHJcbiAgICAgICAgICAgIHZhciBjcywgY3NpLCBjc2xlbjtcclxuICAgICAgICAgICAgZm9yICh4OyB4IDwgeEVuZDsgeCsrKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHk7IHkgPCB5RW5kOyB5KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgbm9uLW5lZ2F0aXZlIHRpbGUgc3ByaXRlc1xyXG4gICAgICAgICAgICAgICAgICAgIGNzID0gdGhpcy5nZXRDZWxsKHgsIHkpLnNwcml0ZXMuZmlsdGVyKGZ1bmN0aW9uIChzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzLnNwcml0ZUlkID4gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjc2kgPSAwLCBjc2xlbiA9IGNzLmxlbmd0aDsgY3NpIDwgY3NsZW47IGNzaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcyA9IHRoaXMuX3Nwcml0ZVNoZWV0c1tjc1tjc2ldLnNwcml0ZVNoZWV0S2V5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZHJhdyBzcHJpdGUsIHdhcm5pbmcgaWYgc3ByaXRlIGRvZXNuJ3QgZXhpc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ByaXRlID0gc3MuZ2V0U3ByaXRlKGNzW2NzaV0uc3ByaXRlSWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNwcml0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZS5kcmF3KGN0eCwgeCAqIHRoaXMuY2VsbFdpZHRoLCB5ICogdGhpcy5jZWxsSGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ1Nwcml0ZSBkb2VzIG5vdCBleGlzdCBmb3IgaWQnLCBjc1tjc2ldLnNwcml0ZUlkLCAnaW4gc3ByaXRlIHNoZWV0JywgY3NbY3NpXS5zcHJpdGVTaGVldEtleSwgc3ByaXRlLCBzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdTcHJpdGUgc2hlZXQnLCBjc1tjc2ldLnNwcml0ZVNoZWV0S2V5LCAnZG9lcyBub3QgZXhpc3QnLCBzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB5ID0gdGhpcy5fb25TY3JlZW5ZU3RhcnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdwb3N0ZHJhdycsIG5ldyBFdmVudHMuUG9zdERyYXdFdmVudChjdHgsIGRlbHRhLCB0aGlzKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEcmF3cyBhbGwgdGhlIHRpbGUgbWFwJ3MgZGVidWcgaW5mby4gQ2FsbGVkIGJ5IHRoZSBbW1NjZW5lXV0uXHJcbiAgICAgICAgICogQHBhcmFtIGN0eCAgVGhlIGN1cnJlbnQgcmVuZGVyaW5nIGNvbnRleHRcclxuICAgICAgICAgKi9cclxuICAgICAgICBUaWxlTWFwSW1wbC5wcm90b3R5cGUuZGVidWdEcmF3ID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmNvbHMgKiB0aGlzLmNlbGxXaWR0aDtcclxuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMucm93cyAqIHRoaXMuY2VsbEhlaWdodDtcclxuICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gQ29sb3JfMTUuQ29sb3IuUmVkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdGhpcy5jb2xzICsgMTsgeCsrKSB7XHJcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHRoaXMueCArIHggKiB0aGlzLmNlbGxXaWR0aCwgdGhpcy55KTtcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8odGhpcy54ICsgeCAqIHRoaXMuY2VsbFdpZHRoLCB0aGlzLnkgKyBoZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgdGhpcy5yb3dzICsgMTsgeSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHRoaXMueCwgdGhpcy55ICsgeSAqIHRoaXMuY2VsbEhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHRoaXMueCArIHdpZHRoLCB0aGlzLnkgKyB5ICogdGhpcy5jZWxsSGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc29saWQgPSBDb2xvcl8xNS5Db2xvci5SZWQuY2xvbmUoKTtcclxuICAgICAgICAgICAgc29saWQuYSA9IC4zO1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEuZmlsdGVyKGZ1bmN0aW9uIChjZWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2VsbC5zb2xpZDtcclxuICAgICAgICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoY2VsbCkge1xyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHNvbGlkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoY2VsbC54LCBjZWxsLnksIGNlbGwud2lkdGgsIGNlbGwuaGVpZ2h0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb2xsaWRpbmdZID4gLTEgJiYgdGhpcy5fY29sbGlkaW5nWCA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gQ29sb3JfMTUuQ29sb3IuQ3lhbi50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KHRoaXMueCArIHRoaXMuX2NvbGxpZGluZ1ggKiB0aGlzLmNlbGxXaWR0aCwgdGhpcy55ICsgdGhpcy5fY29sbGlkaW5nWSAqIHRoaXMuY2VsbEhlaWdodCwgdGhpcy5jZWxsV2lkdGgsIHRoaXMuY2VsbEhlaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBUaWxlTWFwSW1wbDtcclxuICAgIH0oQ2xhc3NfNC5DbGFzcykpO1xyXG4gICAgZXhwb3J0cy5UaWxlTWFwSW1wbCA9IFRpbGVNYXBJbXBsO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgW1tUaWxlTWFwXV0gY2xhc3MgcHJvdmlkZXMgYSBsaWdodHdlaWdodCB3YXkgdG8gZG8gbGFyZ2UgY29tcGxleCBzY2VuZXMgd2l0aCBjb2xsaXNpb25cclxuICAgICAqIHdpdGhvdXQgdGhlIG92ZXJoZWFkIG9mIGFjdG9ycy5cclxuICAgICAqXHJcbiAgICAgKiBbW2luY2x1ZGU6VGlsZU1hcHMubWRdXVxyXG4gICAgICovXHJcbiAgICB2YXIgVGlsZU1hcCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFRpbGVNYXAsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gVGlsZU1hcCh4T3JDb25maWcsIHksIGNlbGxXaWR0aCwgY2VsbEhlaWdodCwgcm93cywgY29scykge1xyXG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgeE9yQ29uZmlnLCB5LCBjZWxsV2lkdGgsIGNlbGxIZWlnaHQsIHJvd3MsIGNvbHMpIHx8IHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBUaWxlTWFwO1xyXG4gICAgfShDb25maWd1cmFibGVfNi5Db25maWd1cmFibGUoVGlsZU1hcEltcGwpKSk7XHJcbiAgICBleHBvcnRzLlRpbGVNYXAgPSBUaWxlTWFwO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaWxlIHNwcml0ZXMgYXJlIHVzZWQgdG8gcmVuZGVyIGEgc3BlY2lmaWMgc3ByaXRlIGZyb20gYSBbW1RpbGVNYXBdXSdzIHNwcml0ZXNoZWV0KHMpXHJcbiAgICAgKi9cclxuICAgIHZhciBUaWxlU3ByaXRlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gc3ByaXRlU2hlZXRLZXkgIFRoZSBrZXkgb2YgdGhlIHNwcml0ZXNoZWV0IHRvIHVzZVxyXG4gICAgICAgICAqIEBwYXJhbSBzcHJpdGVJZCAgICAgICAgVGhlIGluZGV4IG9mIHRoZSBzcHJpdGUgaW4gdGhlIFtbU3ByaXRlU2hlZXRdXVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIFRpbGVTcHJpdGUoc3ByaXRlU2hlZXRLZXksIHNwcml0ZUlkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlU2hlZXRLZXkgPSBzcHJpdGVTaGVldEtleTtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGVJZCA9IHNwcml0ZUlkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gVGlsZVNwcml0ZTtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLlRpbGVTcHJpdGUgPSBUaWxlU3ByaXRlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaGlkZGVuXHJcbiAgICAgKi9cclxuICAgIHZhciBDZWxsSW1wbCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHggICAgICAgR2V0cyBvciBzZXRzIHggY29vcmRpbmF0ZSBvZiB0aGUgY2VsbCBpbiB3b3JsZCBjb29yZGluYXRlc1xyXG4gICAgICAgICAqIEBwYXJhbSB5ICAgICAgIEdldHMgb3Igc2V0cyB5IGNvb3JkaW5hdGUgb2YgdGhlIGNlbGwgaW4gd29ybGQgY29vcmRpbmF0ZXNcclxuICAgICAgICAgKiBAcGFyYW0gd2lkdGggICBHZXRzIG9yIHNldHMgdGhlIHdpZHRoIG9mIHRoZSBjZWxsXHJcbiAgICAgICAgICogQHBhcmFtIGhlaWdodCAgR2V0cyBvciBzZXRzIHRoZSBoZWlnaHQgb2YgdGhlIGNlbGxcclxuICAgICAgICAgKiBAcGFyYW0gaW5kZXggICBUaGUgaW5kZXggb2YgdGhlIGNlbGwgaW4gcm93IG1ham9yIG9yZGVyXHJcbiAgICAgICAgICogQHBhcmFtIHNvbGlkICAgR2V0cyBvciBzZXRzIHdoZXRoZXIgdGhpcyBjZWxsIGlzIHNvbGlkXHJcbiAgICAgICAgICogQHBhcmFtIHNwcml0ZXMgVGhlIGxpc3Qgb2YgdGlsZSBzcHJpdGVzIHRvIHVzZSB0byBkcmF3IGluIHRoaXMgY2VsbCAoaW4gb3JkZXIpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gQ2VsbEltcGwoeE9yQ29uZmlnLCB5LCB3aWR0aCwgaGVpZ2h0LCBpbmRleCwgc29saWQsIHNwcml0ZXMpIHtcclxuICAgICAgICAgICAgaWYgKHNvbGlkID09PSB2b2lkIDApIHsgc29saWQgPSBmYWxzZTsgfVxyXG4gICAgICAgICAgICBpZiAoc3ByaXRlcyA9PT0gdm9pZCAwKSB7IHNwcml0ZXMgPSBbXTsgfVxyXG4gICAgICAgICAgICB0aGlzLnNvbGlkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlcyA9IFtdO1xyXG4gICAgICAgICAgICBpZiAoeE9yQ29uZmlnICYmIHR5cGVvZiB4T3JDb25maWcgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29uZmlnID0geE9yQ29uZmlnO1xyXG4gICAgICAgICAgICAgICAgeE9yQ29uZmlnID0gY29uZmlnLng7XHJcbiAgICAgICAgICAgICAgICB5ID0gY29uZmlnLnk7XHJcbiAgICAgICAgICAgICAgICB3aWR0aCA9IGNvbmZpZy53aWR0aDtcclxuICAgICAgICAgICAgICAgIGhlaWdodCA9IGNvbmZpZy5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBpbmRleCA9IGNvbmZpZy5pbmRleDtcclxuICAgICAgICAgICAgICAgIHNvbGlkID0gY29uZmlnLnNvbGlkO1xyXG4gICAgICAgICAgICAgICAgc3ByaXRlcyA9IGNvbmZpZy5zcHJpdGVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMueCA9IHhPckNvbmZpZztcclxuICAgICAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICB0aGlzLnNvbGlkID0gc29saWQ7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlcyA9IHNwcml0ZXM7XHJcbiAgICAgICAgICAgIHRoaXMuX2JvdW5kcyA9IG5ldyBCb3VuZGluZ0JveF80LkJvdW5kaW5nQm94KHRoaXMueCwgdGhpcy55LCB0aGlzLnggKyB0aGlzLndpZHRoLCB0aGlzLnkgKyB0aGlzLmhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIGJvdW5kaW5nIGJveCBmb3IgdGhpcyBjZWxsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2VsbEltcGwucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JvdW5kcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGNlbnRlciBjb29yZGluYXRlIG9mIHRoaXMgY2VsbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENlbGxJbXBsLnByb3RvdHlwZS5nZXRDZW50ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWxnZWJyYV8xNi5WZWN0b3IodGhpcy54ICsgdGhpcy53aWR0aCAvIDIsIHRoaXMueSArIHRoaXMuaGVpZ2h0IC8gMik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGQgYW5vdGhlciBbW1RpbGVTcHJpdGVdXSB0byB0aGlzIGNlbGxcclxuICAgICAgICAgKi9cclxuICAgICAgICBDZWxsSW1wbC5wcm90b3R5cGUucHVzaFNwcml0ZSA9IGZ1bmN0aW9uICh0aWxlU3ByaXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlcy5wdXNoKHRpbGVTcHJpdGUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlIGFuIGluc3RhbmNlIG9mIFtbVGlsZVNwcml0ZV1dIGZyb20gdGhpcyBjZWxsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2VsbEltcGwucHJvdG90eXBlLnJlbW92ZVNwcml0ZSA9IGZ1bmN0aW9uICh0aWxlU3ByaXRlKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IC0xO1xyXG4gICAgICAgICAgICBpZiAoKGluZGV4ID0gdGhpcy5zcHJpdGVzLmluZGV4T2YodGlsZVNwcml0ZSkpID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDbGVhciBhbGwgc3ByaXRlcyBmcm9tIHRoaXMgY2VsbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENlbGxJbXBsLnByb3RvdHlwZS5jbGVhclNwcml0ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIENlbGxJbXBsO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuQ2VsbEltcGwgPSBDZWxsSW1wbDtcclxuICAgIC8qKlxyXG4gICAgICogVGlsZU1hcCBDZWxsXHJcbiAgICAgKlxyXG4gICAgICogQSBsaWdodC13ZWlnaHQgb2JqZWN0IHRoYXQgb2NjdXBpZXMgYSBzcGFjZSBpbiBhIGNvbGxpc2lvbiBtYXAuIEdlbmVyYWxseVxyXG4gICAgICogY3JlYXRlZCBieSBhIFtbVGlsZU1hcF1dLlxyXG4gICAgICpcclxuICAgICAqIENlbGxzIGNhbiBkcmF3IG11bHRpcGxlIHNwcml0ZXMuIE5vdGUgdGhhdCB0aGUgb3JkZXIgb2YgZHJhd2luZyBpcyB0aGUgb3JkZXJcclxuICAgICAqIG9mIHRoZSBzcHJpdGVzIGluIHRoZSBhcnJheSBzbyB0aGUgbGFzdCBvbmUgd2lsbCBiZSBkcmF3biBvbiB0b3AuIFlvdSBjYW5cclxuICAgICAqIHVzZSB0cmFuc3BhcmVuY3kgdG8gY3JlYXRlIGxheWVycyB0aGlzIHdheS5cclxuICAgICAqL1xyXG4gICAgdmFyIENlbGwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhDZWxsLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIENlbGwoeE9yQ29uZmlnLCB5LCB3aWR0aCwgaGVpZ2h0LCBpbmRleCwgc29saWQsIHNwcml0ZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHhPckNvbmZpZywgeSwgd2lkdGgsIGhlaWdodCwgaW5kZXgsIHNvbGlkLCBzcHJpdGVzKSB8fCB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gQ2VsbDtcclxuICAgIH0oQ29uZmlndXJhYmxlXzYuQ29uZmlndXJhYmxlKENlbGxJbXBsKSkpO1xyXG4gICAgZXhwb3J0cy5DZWxsID0gQ2VsbDtcclxufSk7XHJcbmRlZmluZShcIlRpbWVyXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBFeGNhbGlidXIgdGltZXIgaG9va3MgaW50byB0aGUgaW50ZXJuYWwgdGltZXIgYW5kIGZpcmVzIGNhbGxiYWNrcyxcclxuICAgICAqIGFmdGVyIGEgY2VydGFpbiBpbnRlcnZhbCwgb3B0aW9uYWxseSByZXBlYXRpbmcuXHJcbiAgICAgKi9cclxuICAgIHZhciBUaW1lciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIGZjbiAgICAgICAgVGhlIGNhbGxiYWNrIHRvIGJlIGZpcmVkIGFmdGVyIHRoZSBpbnRlcnZhbCBpcyBjb21wbGV0ZS5cclxuICAgICAgICAgKiBAcGFyYW0gaW50ZXJ2YWwgICBJbnRlcnZhbCBsZW5ndGhcclxuICAgICAgICAgKiBAcGFyYW0gcmVwZWF0cyAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIGNhbGwgYmFjayBzaG91bGQgYmUgZmlyZWQgb25seSBvbmNlLCBvciByZXBlYXQgYWZ0ZXIgZXZlcnkgaW50ZXJ2YWwgYXMgY29tcGxldGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIFRpbWVyKGZjbiwgaW50ZXJ2YWwsIHJlcGVhdHMpIHtcclxuICAgICAgICAgICAgdGhpcy5pZCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWwgPSAxMDtcclxuICAgICAgICAgICAgdGhpcy5mY24gPSBmdW5jdGlvbiAoKSB7IHJldHVybjsgfTtcclxuICAgICAgICAgICAgdGhpcy5yZXBlYXRzID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2VsYXBzZWRUaW1lID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fdG90YWxUaW1lQWxpdmUgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5jb21wbGV0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLnNjZW5lID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5pZCA9IFRpbWVyLmlkKys7XHJcbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWwgPSBpbnRlcnZhbCB8fCB0aGlzLmludGVydmFsO1xyXG4gICAgICAgICAgICB0aGlzLmZjbiA9IGZjbiB8fCB0aGlzLmZjbjtcclxuICAgICAgICAgICAgdGhpcy5yZXBlYXRzID0gcmVwZWF0cyB8fCB0aGlzLnJlcGVhdHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwZGF0ZXMgdGhlIHRpbWVyIGFmdGVyIGEgY2VydGFpbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZC4gVGhpcyBpcyB1c2VkIGludGVybmFsbHkgYnkgdGhlIGVuZ2luZS5cclxuICAgICAgICAgKiBAcGFyYW0gZGVsdGEgIE51bWJlciBvZiBlbGFwc2VkIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgbGFzdCB1cGRhdGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVGltZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3BhdXNlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdG90YWxUaW1lQWxpdmUgKz0gZGVsdGE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lbGFwc2VkVGltZSArPSBkZWx0YTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb21wbGV0ZSAmJiB0aGlzLl9lbGFwc2VkVGltZSA+PSB0aGlzLmludGVydmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mY24uY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXBlYXRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VsYXBzZWRUaW1lID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVzZXRzIHRoZSB0aW1lciBzbyB0aGF0IGl0IGNhbiBiZSByZXVzZWQsIGFuZCBvcHRpb25hbGx5IHJlY29uZmlndXJlIHRoZSB0aW1lcnMgaW50ZXJ2YWwuXHJcbiAgICAgICAgICogQHBhcmFtIG5ld0ludGVydmFsIElmIHNwZWNpZmllZCwgc2V0cyBhIG5ldyBub24tbmVnYXRpdmUgaW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzIHRvIHJlZmlyZSB0aGUgY2FsbGJhY2tcclxuICAgICAgICAgKi9cclxuICAgICAgICBUaW1lci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAobmV3SW50ZXJ2YWwpIHtcclxuICAgICAgICAgICAgaWYgKCEhbmV3SW50ZXJ2YWwgJiYgbmV3SW50ZXJ2YWwgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnRlcnZhbCA9IG5ld0ludGVydmFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fZWxhcHNlZFRpbWUgPSAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVGltZXIucHJvdG90eXBlLmdldFRpbWVSdW5uaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdG90YWxUaW1lQWxpdmU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQYXVzZXMgdGhlIHRpbWVyIHNvIHRoYXQgbm8gbW9yZSB0aW1lIHdpbGwgYmUgaW5jcmVtZW50ZWQgdG93YXJkcyB0aGUgbmV4dCBjYWxsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVGltZXIucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVW5wYXVzZXMgdGhlIHRpbWVyLiBUaW1lIHdpbGwgbm93IGluY3JlbWVudCB0b3dhcmRzIHRoZSBuZXh0IGNhbGxcclxuICAgICAgICAgKi9cclxuICAgICAgICBUaW1lci5wcm90b3R5cGUudW5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYW5jZWxzIHRoZSB0aW1lciwgcHJldmVudGluZyBhbnkgZnVydGhlciBleGVjdXRpb25zLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRpbWVyLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNjZW5lKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLmNhbmNlbFRpbWVyKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gVGltZXI7XHJcbiAgICB9KCkpO1xyXG4gICAgVGltZXIuaWQgPSAwO1xyXG4gICAgZXhwb3J0cy5UaW1lciA9IFRpbWVyO1xyXG59KTtcclxuZGVmaW5lKFwiVHJpZ2dlclwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkRyYXdpbmcvQ29sb3JcIiwgXCJBY3Rpb25zL0FjdGlvblwiLCBcIkV2ZW50RGlzcGF0Y2hlclwiLCBcIkFjdG9yXCIsIFwiQWxnZWJyYVwiLCBcIkV2ZW50c1wiLCBcIlV0aWwvVXRpbFwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIENvbG9yXzE2LCBBY3Rpb25fMSwgRXZlbnREaXNwYXRjaGVyXzEsIEFjdG9yXzgsIEFsZ2VicmFfMTcsIEV2ZW50c181LCBVdGlsKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIHZhciB0cmlnZ2VyRGVmYXVsdHMgPSB7XHJcbiAgICAgICAgcG9zOiBBbGdlYnJhXzE3LlZlY3Rvci5aZXJvLmNsb25lKCksXHJcbiAgICAgICAgd2lkdGg6IDEwLFxyXG4gICAgICAgIGhlaWdodDogMTAsXHJcbiAgICAgICAgdmlzaWJsZTogZmFsc2UsXHJcbiAgICAgICAgYWN0aW9uOiBmdW5jdGlvbiAoKSB7IHJldHVybjsgfSxcclxuICAgICAgICBmaWx0ZXI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH0sXHJcbiAgICAgICAgcmVwZWF0OiAtMVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVHJpZ2dlcnMgYXJlIGEgbWV0aG9kIG9mIGZpcmluZyBhcmJpdHJhcnkgY29kZSBvbiBjb2xsaXNpb24uIFRoZXNlIGFyZSB1c2VmdWxcclxuICAgICAqIGFzICdidXR0b25zJywgJ3N3aXRjaGVzJywgb3IgdG8gdHJpZ2dlciBlZmZlY3RzIGluIGEgZ2FtZS4gQnkgZGVmYXVsdCB0cmlnZ2Vyc1xyXG4gICAgICogYXJlIGludmlzaWJsZSwgYW5kIGNhbiBvbmx5IGJlIHNlZW4gd2hlbiBbW1RyaWdnZXIudmlzaWJsZV1dIGlzIHNldCB0byBgdHJ1ZWAuXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOlRyaWdnZXJzLm1kXV1cclxuICAgICAqL1xyXG4gICAgdmFyIFRyaWdnZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhUcmlnZ2VyLCBfc3VwZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIG9wdHMgVHJpZ2dlciBvcHRpb25zXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gVHJpZ2dlcihvcHRzKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdHMucG9zLngsIG9wdHMucG9zLnksIG9wdHMud2lkdGgsIG9wdHMuaGVpZ2h0KSB8fCB0aGlzO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQWN0aW9uIHRvIGZpcmUgd2hlbiB0cmlnZ2VyZWQgYnkgY29sbGlzaW9uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5hY3Rpb24gPSBmdW5jdGlvbiAoKSB7IHJldHVybjsgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEZpbHRlciB0byBhZGQgYWRkaXRpb25hbCBncmFudWxhcml0eSB0byBhY3Rpb24gZGlzcGF0Y2gsIGlmIGEgZmlsdGVyIGlzIHNwZWNpZmllZCB0aGUgYWN0aW9uIHdpbGwgb25seSBmaXJlIHdoZW5cclxuICAgICAgICAgICAgICogZmlsdGVyIHJldHVybiB0cnVlIGZvciB0aGUgY29sbGlkZWQgYWN0b3IuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5maWx0ZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogTnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCBiZWZvcmUga2lsbGluZyB0aGUgdHJpZ2dlcixcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLnJlcGVhdCA9IC0xO1xyXG4gICAgICAgICAgICBvcHRzID0gVXRpbC5leHRlbmQoe30sIHRyaWdnZXJEZWZhdWx0cywgb3B0cyk7XHJcbiAgICAgICAgICAgIF90aGlzLmZpbHRlciA9IG9wdHMuZmlsdGVyIHx8IF90aGlzLmZpbHRlcjtcclxuICAgICAgICAgICAgX3RoaXMucmVwZWF0ID0gb3B0cy5yZXBlYXQgfHwgX3RoaXMucmVwZWF0O1xyXG4gICAgICAgICAgICBfdGhpcy5hY3Rpb24gPSBvcHRzLmFjdGlvbiB8fCBfdGhpcy5hY3Rpb247XHJcbiAgICAgICAgICAgIGlmIChvcHRzLnRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudGFyZ2V0ID0gb3B0cy50YXJnZXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMudmlzaWJsZSA9IG9wdHMudmlzaWJsZTtcclxuICAgICAgICAgICAgX3RoaXMuY29sbGlzaW9uVHlwZSA9IEFjdG9yXzguQ29sbGlzaW9uVHlwZS5QYXNzaXZlO1xyXG4gICAgICAgICAgICBfdGhpcy5ldmVudERpc3BhdGNoZXIgPSBuZXcgRXZlbnREaXNwYXRjaGVyXzEuRXZlbnREaXNwYXRjaGVyKF90aGlzKTtcclxuICAgICAgICAgICAgX3RoaXMuYWN0aW9uUXVldWUgPSBuZXcgQWN0aW9uXzEuQWN0aW9uUXVldWUoX3RoaXMpO1xyXG4gICAgICAgICAgICBfdGhpcy5vbignY29sbGlzaW9uc3RhcnQnLCBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZmlsdGVyKGV2dC5vdGhlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KCdlbnRlcicsIG5ldyBFdmVudHNfNS5FbnRlclRyaWdnZXJFdmVudChfdGhpcywgZXZ0Lm90aGVyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2Rpc3BhdGNoQWN0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRyaWdnZXIgaWYgaXRzIGRvbmUsIC0xIHJlcGVhdCBmb3JldmVyXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnJlcGVhdCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5raWxsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgX3RoaXMub24oJ2NvbGxpc2lvbmVuZCcsIGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5maWx0ZXIoZXZ0Lm90aGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ2V4aXQnLCBuZXcgRXZlbnRzXzUuRXhpdFRyaWdnZXJFdmVudChfdGhpcywgZXZ0Lm90aGVyKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmlnZ2VyLnByb3RvdHlwZSwgXCJ0YXJnZXRcIiwge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90YXJnZXQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5maWx0ZXIgPSBmdW5jdGlvbiAoYWN0b3IpIHsgcmV0dXJuIGFjdG9yID09PSB0YXJnZXQ7IH07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFRyaWdnZXIucHJvdG90eXBlLl9pbml0aWFsaXplID0gZnVuY3Rpb24gKGVuZ2luZSkge1xyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9pbml0aWFsaXplLmNhbGwodGhpcywgZW5naW5lKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFRyaWdnZXIucHJvdG90eXBlLl9kaXNwYXRjaEFjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5hY3Rpb24uY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5yZXBlYXQtLTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgVHJpZ2dlci5wcm90b3R5cGUuZGVidWdEcmF3ID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRlYnVnRHJhdy5jYWxsKHRoaXMsIGN0eCk7XHJcbiAgICAgICAgICAgIC8vIE1lYW50IHRvIGRyYXcgZGVidWcgaW5mb3JtYXRpb24gYWJvdXQgYWN0b3JzXHJcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUodGhpcy5wb3MueCwgdGhpcy5wb3MueSk7XHJcbiAgICAgICAgICAgIHZhciBiYiA9IHRoaXMuZ2V0Qm91bmRzKCk7XHJcbiAgICAgICAgICAgIHZhciB3cCA9IHRoaXMuZ2V0V29ybGRQb3MoKTtcclxuICAgICAgICAgICAgYmIubGVmdCA9IGJiLmxlZnQgLSB3cC54O1xyXG4gICAgICAgICAgICBiYi5yaWdodCA9IGJiLnJpZ2h0IC0gd3AueDtcclxuICAgICAgICAgICAgYmIudG9wID0gYmIudG9wIC0gd3AueTtcclxuICAgICAgICAgICAgYmIuYm90dG9tID0gYmIuYm90dG9tIC0gd3AueTtcclxuICAgICAgICAgICAgLy8gQ3VycmVudGx5IGNvbGxpc2lvbiBwcmltaXRpdmVzIGNhbm5vdCByb3RhdGUgXHJcbiAgICAgICAgICAgIC8vIGN0eC5yb3RhdGUodGhpcy5yb3RhdGlvbik7XHJcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBDb2xvcl8xNi5Db2xvci5WaW9sZXQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gQ29sb3JfMTYuQ29sb3IuVmlvbGV0LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dCgnVHJpZ2dlcicsIDEwLCAxMCk7XHJcbiAgICAgICAgICAgIGJiLmRlYnVnRHJhdyhjdHgpO1xyXG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFRyaWdnZXI7XHJcbiAgICB9KEFjdG9yXzguQWN0b3IpKTtcclxuICAgIGV4cG9ydHMuVHJpZ2dlciA9IFRyaWdnZXI7XHJcbn0pO1xyXG5kZWZpbmUoXCJBY3Rpb25zL0luZGV4XCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiQWN0aW9ucy9BY3Rpb25Db250ZXh0XCIsIFwiQWN0aW9ucy9Sb3RhdGlvblR5cGVcIiwgXCJBY3Rpb25zL0FjdGlvblwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIEFjdGlvbkNvbnRleHRfMiwgUm90YXRpb25UeXBlXzEsIGFjdGlvbnMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIF9fZXhwb3J0KEFjdGlvbkNvbnRleHRfMik7XHJcbiAgICBfX2V4cG9ydChSb3RhdGlvblR5cGVfMSk7XHJcbiAgICBleHBvcnRzLkFjdGlvbnMgPSBhY3Rpb25zO1xyXG4gICAgLy8gbGVnYWN5IEludGVybmFsLkFjdGlvbnMgbmFtZXNwYWNlIHN1cHBvcnRcclxuICAgIGV4cG9ydHMuSW50ZXJuYWwgPSB7IEFjdGlvbnM6IGFjdGlvbnMgfTtcclxufSk7XHJcbmRlZmluZShcIkNvbGxpc2lvbi9EeW5hbWljVHJlZVwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIlBoeXNpY3NcIiwgXCJDb2xsaXNpb24vQm91bmRpbmdCb3hcIiwgXCJVdGlsL0xvZ1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIFBoeXNpY3NfOCwgQm91bmRpbmdCb3hfNSwgTG9nXzgpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEeW5hbWljIFRyZWUgTm9kZSB1c2VkIGZvciB0cmFja2luZyBib3VuZHMgd2l0aGluIHRoZSB0cmVlXHJcbiAgICAgKi9cclxuICAgIHZhciBUcmVlTm9kZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gVHJlZU5vZGUocGFyZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudCB8fCBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmJvdW5kcyA9IG5ldyBCb3VuZGluZ0JveF81LkJvdW5kaW5nQm94KCk7XHJcbiAgICAgICAgICAgIHRoaXMubGVmdCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMucmlnaHQgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFRyZWVOb2RlLnByb3RvdHlwZS5pc0xlYWYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoIXRoaXMubGVmdCAmJiAhdGhpcy5yaWdodCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gVHJlZU5vZGU7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5UcmVlTm9kZSA9IFRyZWVOb2RlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgRHluYW1pY1RyZWVzIHByb3ZpZGVzIGEgc3BhdGlhbCBwYXJ0aWlvbmluZyBkYXRhIHN0cnVjdHVyZSBmb3IgcXVpY2tseSBxdWVyeWluZyBmb3Igb3ZlcmxhcHBpbmcgYm91bmRpbmcgYm94ZXMgZm9yXHJcbiAgICAgKiBhbGwgdHJhY2tlZCBib2RpZXMuIFRoZSB3b3JzdCBjYXNlIHBlcmZvcm1hbmNlIG9mIHRoaXMgaXMgTyhuKmxvZyhuKSkgd2hlcmUgbiBpcyB0aGUgbnVtYmVyIG9mIGJvZGllcyBpbiB0aGUgdHJlZS5cclxuICAgICAqXHJcbiAgICAgKiBJbnRlcm5hbGx5IHRoZSBib3VuZGluZyBib3hlcyBhcmUgb3JnYW5pemVkIGFzIGEgYmFsYW5jZWQgYmluYXJ5IHRyZWUgb2YgYm91bmRpbmcgYm94ZXMsIHdoZXJlIHRoZSBsZWFmIG5vZGVzIGFyZSB0cmFja2VkIGJvZGllcy5cclxuICAgICAqIEV2ZXJ5IG5vbi1sZWFmIG5vZGUgaXMgYSBib3VuZGluZyBib3ggdGhhdCBjb250YWlucyBjaGlsZCBib3VuZGluZyBib3hlcy5cclxuICAgICAqL1xyXG4gICAgdmFyIER5bmFtaWNUcmVlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBEeW5hbWljVHJlZSh3b3JsZEJvdW5kcykge1xyXG4gICAgICAgICAgICBpZiAod29ybGRCb3VuZHMgPT09IHZvaWQgMCkgeyB3b3JsZEJvdW5kcyA9IG5ldyBCb3VuZGluZ0JveF81LkJvdW5kaW5nQm94KC1OdW1iZXIuTUFYX1ZBTFVFLCAtTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRSk7IH1cclxuICAgICAgICAgICAgdGhpcy53b3JsZEJvdW5kcyA9IHdvcmxkQm91bmRzO1xyXG4gICAgICAgICAgICB0aGlzLnJvb3QgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLm5vZGVzID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluc2VydHMgYSBub2RlIGludG8gdGhlIGR5bmFtaWMgdHJlZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIER5bmFtaWNUcmVlLnByb3RvdHlwZS5faW5zZXJ0ID0gZnVuY3Rpb24gKGxlYWYpIHtcclxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIG5vZGVzIGluIHRoZSB0cmVlLCBtYWtlIHRoaXMgdGhlIHJvb3QgbGVhZlxyXG4gICAgICAgICAgICBpZiAodGhpcy5yb290ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3QgPSBsZWFmO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yb290LnBhcmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gU2VhcmNoIHRoZSB0cmVlIGZvciBhIG5vZGUgdGhhdCBpcyBub3QgYSBsZWFmIGFuZCBmaW5kIHRoZSBiZXN0IHBsYWNlIHRvIGluc2VydFxyXG4gICAgICAgICAgICB2YXIgbGVhZkFBQkIgPSBsZWFmLmJvdW5kcztcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRSb290ID0gdGhpcy5yb290O1xyXG4gICAgICAgICAgICB3aGlsZSAoIWN1cnJlbnRSb290LmlzTGVhZigpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IGN1cnJlbnRSb290LmxlZnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmlnaHQgPSBjdXJyZW50Um9vdC5yaWdodDtcclxuICAgICAgICAgICAgICAgIHZhciBhcmVhID0gY3VycmVudFJvb3QuYm91bmRzLmdldFBlcmltZXRlcigpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbWJpbmVkQUFCQiA9IGN1cnJlbnRSb290LmJvdW5kcy5jb21iaW5lKGxlYWZBQUJCKTtcclxuICAgICAgICAgICAgICAgIHZhciBjb21iaW5lZEFyZWEgPSBjb21iaW5lZEFBQkIuZ2V0UGVyaW1ldGVyKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgY29zdCBoZXVyaXN0aWMgZm9yIGNyZWF0aW5nIGEgbmV3IHBhcmVudCBhbmQgbGVhZlxyXG4gICAgICAgICAgICAgICAgdmFyIGNvc3QgPSAyICogY29tYmluZWRBcmVhO1xyXG4gICAgICAgICAgICAgICAgLy8gTWluaW11bSBjb3N0IG9mIHB1c2hpbmcgdGhlIGxlYWYgZG93biB0aGUgdHJlZVxyXG4gICAgICAgICAgICAgICAgdmFyIGluaGVyaXRhbmNlQ29zdCA9IDIgKiAoY29tYmluZWRBcmVhIC0gYXJlYSk7XHJcbiAgICAgICAgICAgICAgICAvLyBDb3N0IG9mIGRlc2NlbmRpbmdcclxuICAgICAgICAgICAgICAgIHZhciBsZWZ0Q29zdCA9IDA7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVmdENvbWJpbmVkID0gbGVhZkFBQkIuY29tYmluZShsZWZ0LmJvdW5kcyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3QXJlYTtcclxuICAgICAgICAgICAgICAgIHZhciBvbGRBcmVhO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxlZnQuaXNMZWFmKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0Q29zdCA9IGxlZnRDb21iaW5lZC5nZXRQZXJpbWV0ZXIoKSArIGluaGVyaXRhbmNlQ29zdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG9sZEFyZWEgPSBsZWZ0LmJvdW5kcy5nZXRQZXJpbWV0ZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdBcmVhID0gbGVmdENvbWJpbmVkLmdldFBlcmltZXRlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnRDb3N0ID0gKG5ld0FyZWEgLSBvbGRBcmVhKSArIGluaGVyaXRhbmNlQ29zdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciByaWdodENvc3QgPSAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJpZ2h0Q29tYmluZWQgPSBsZWFmQUFCQi5jb21iaW5lKHJpZ2h0LmJvdW5kcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmlnaHQuaXNMZWFmKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByaWdodENvc3QgPSByaWdodENvbWJpbmVkLmdldFBlcmltZXRlcigpICsgaW5oZXJpdGFuY2VDb3N0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2xkQXJlYSA9IHJpZ2h0LmJvdW5kcy5nZXRQZXJpbWV0ZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdBcmVhID0gcmlnaHRDb21iaW5lZC5nZXRQZXJpbWV0ZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICByaWdodENvc3QgPSAobmV3QXJlYSAtIG9sZEFyZWEpICsgaW5oZXJpdGFuY2VDb3N0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gY29zdCBpcyBhY2NlcHRhYmxlXHJcbiAgICAgICAgICAgICAgICBpZiAoY29zdCA8IGxlZnRDb3N0ICYmIGNvc3QgPCByaWdodENvc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIERlc2NlbmQgdG8gdGhlIGRlcHRoc1xyXG4gICAgICAgICAgICAgICAgaWYgKGxlZnRDb3N0IDwgcmlnaHRDb3N0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFJvb3QgPSBsZWZ0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFJvb3QgPSByaWdodDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIG5ldyBwYXJlbnQgbm9kZSBhbmQgaW5zZXJ0IGludG8gdGhlIHRyZWVcclxuICAgICAgICAgICAgdmFyIG9sZFBhcmVudCA9IGN1cnJlbnRSb290LnBhcmVudDtcclxuICAgICAgICAgICAgdmFyIG5ld1BhcmVudCA9IG5ldyBUcmVlTm9kZShvbGRQYXJlbnQpO1xyXG4gICAgICAgICAgICBuZXdQYXJlbnQuYm91bmRzID0gbGVhZkFBQkIuY29tYmluZShjdXJyZW50Um9vdC5ib3VuZHMpO1xyXG4gICAgICAgICAgICBuZXdQYXJlbnQuaGVpZ2h0ID0gY3VycmVudFJvb3QuaGVpZ2h0ICsgMTtcclxuICAgICAgICAgICAgaWYgKG9sZFBhcmVudCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIHNpYmxpbmcgbm9kZSB3YXMgbm90IHRoZSByb290XHJcbiAgICAgICAgICAgICAgICBpZiAob2xkUGFyZW50LmxlZnQgPT09IGN1cnJlbnRSb290KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2xkUGFyZW50LmxlZnQgPSBuZXdQYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvbGRQYXJlbnQucmlnaHQgPSBuZXdQYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBuZXdQYXJlbnQubGVmdCA9IGN1cnJlbnRSb290O1xyXG4gICAgICAgICAgICAgICAgbmV3UGFyZW50LnJpZ2h0ID0gbGVhZjtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRSb290LnBhcmVudCA9IG5ld1BhcmVudDtcclxuICAgICAgICAgICAgICAgIGxlYWYucGFyZW50ID0gbmV3UGFyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIHNpYmxpbmcgbm9kZSB3YXMgdGhlIHJvb3RcclxuICAgICAgICAgICAgICAgIG5ld1BhcmVudC5sZWZ0ID0gY3VycmVudFJvb3Q7XHJcbiAgICAgICAgICAgICAgICBuZXdQYXJlbnQucmlnaHQgPSBsZWFmO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFJvb3QucGFyZW50ID0gbmV3UGFyZW50O1xyXG4gICAgICAgICAgICAgICAgbGVhZi5wYXJlbnQgPSBuZXdQYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3QgPSBuZXdQYXJlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gV2FsayB1cCB0aGUgdHJlZSBmaXhpbmcgaGVpZ2h0cyBhbmQgQUFCQnNcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnROb2RlID0gbGVhZi5wYXJlbnQ7XHJcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSB0aGlzLl9iYWxhbmNlKGN1cnJlbnROb2RlKTtcclxuICAgICAgICAgICAgICAgIGlmICghY3VycmVudE5vZGUubGVmdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGFyZW50IG9mIGN1cnJlbnQgbGVhZiBjYW5ub3QgaGF2ZSBhIG51bGwgbGVmdCBjaGlsZCcgKyBjdXJyZW50Tm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnROb2RlLnJpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJlbnQgb2YgY3VycmVudCBsZWFmIGNhbm5vdCBoYXZlIGEgbnVsbCByaWdodCBjaGlsZCcgKyBjdXJyZW50Tm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5oZWlnaHQgPSAxICsgTWF0aC5tYXgoY3VycmVudE5vZGUubGVmdC5oZWlnaHQsIGN1cnJlbnROb2RlLnJpZ2h0LmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5ib3VuZHMgPSBjdXJyZW50Tm9kZS5sZWZ0LmJvdW5kcy5jb21iaW5lKGN1cnJlbnROb2RlLnJpZ2h0LmJvdW5kcyk7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlcyBhIG5vZGUgZnJvbSB0aGUgZHluYW1pYyB0cmVlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLl9yZW1vdmUgPSBmdW5jdGlvbiAobGVhZikge1xyXG4gICAgICAgICAgICBpZiAobGVhZiA9PT0gdGhpcy5yb290KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3QgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBsZWFmLnBhcmVudDtcclxuICAgICAgICAgICAgdmFyIGdyYW5kUGFyZW50ID0gcGFyZW50LnBhcmVudDtcclxuICAgICAgICAgICAgdmFyIHNpYmxpbmc7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnQubGVmdCA9PT0gbGVhZikge1xyXG4gICAgICAgICAgICAgICAgc2libGluZyA9IHBhcmVudC5yaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNpYmxpbmcgPSBwYXJlbnQubGVmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZ3JhbmRQYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChncmFuZFBhcmVudC5sZWZ0ID09PSBwYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBncmFuZFBhcmVudC5sZWZ0ID0gc2libGluZztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGdyYW5kUGFyZW50LnJpZ2h0ID0gc2libGluZztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNpYmxpbmcucGFyZW50ID0gZ3JhbmRQYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudE5vZGUgPSBncmFuZFBhcmVudDtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlID0gdGhpcy5fYmFsYW5jZShjdXJyZW50Tm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUuYm91bmRzID0gY3VycmVudE5vZGUubGVmdC5ib3VuZHMuY29tYmluZShjdXJyZW50Tm9kZS5yaWdodC5ib3VuZHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLmhlaWdodCA9IDEgKyBNYXRoLm1heChjdXJyZW50Tm9kZS5sZWZ0LmhlaWdodCwgY3VycmVudE5vZGUucmlnaHQuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucm9vdCA9IHNpYmxpbmc7XHJcbiAgICAgICAgICAgICAgICBzaWJsaW5nLnBhcmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRyYWNrcyBhIGJvZHkgaW4gdGhlIGR5bmFtaWMgdHJlZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIER5bmFtaWNUcmVlLnByb3RvdHlwZS50cmFja0JvZHkgPSBmdW5jdGlvbiAoYm9keSkge1xyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5ldyBUcmVlTm9kZSgpO1xyXG4gICAgICAgICAgICBub2RlLmJvZHkgPSBib2R5O1xyXG4gICAgICAgICAgICBub2RlLmJvdW5kcyA9IGJvZHkuZ2V0Qm91bmRzKCk7XHJcbiAgICAgICAgICAgIG5vZGUuYm91bmRzLmxlZnQgLT0gMjtcclxuICAgICAgICAgICAgbm9kZS5ib3VuZHMudG9wIC09IDI7XHJcbiAgICAgICAgICAgIG5vZGUuYm91bmRzLnJpZ2h0ICs9IDI7XHJcbiAgICAgICAgICAgIG5vZGUuYm91bmRzLmJvdHRvbSArPSAyO1xyXG4gICAgICAgICAgICB0aGlzLm5vZGVzW2JvZHkuYWN0b3IuaWRdID0gbm9kZTtcclxuICAgICAgICAgICAgdGhpcy5faW5zZXJ0KG5vZGUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXBkYXRlcyB0aGUgZHluYW1pYyB0cmVlIGdpdmVuIHRoZSBjdXJyZW50IGJvdW5kcyBvZiBlYWNoIGJvZHkgYmVpbmcgdHJhY2tlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIER5bmFtaWNUcmVlLnByb3RvdHlwZS51cGRhdGVCb2R5ID0gZnVuY3Rpb24gKGJvZHkpIHtcclxuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGVzW2JvZHkuYWN0b3IuaWRdO1xyXG4gICAgICAgICAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYiA9IGJvZHkuZ2V0Qm91bmRzKCk7XHJcbiAgICAgICAgICAgIC8vIGlmIHRoZSBib2R5IGlzIG91dHNpZGUgdGhlIHdvcmxkIG5vIGxvbmdlciB1cGRhdGUgaXRcclxuICAgICAgICAgICAgaWYgKCF0aGlzLndvcmxkQm91bmRzLmNvbnRhaW5zKGIpKSB7XHJcbiAgICAgICAgICAgICAgICBMb2dfOC5Mb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKCdBY3RvciB3aXRoIGlkICcgKyBib2R5LmFjdG9yLmlkICtcclxuICAgICAgICAgICAgICAgICAgICAnIGlzIG91dHNpZGUgdGhlIHdvcmxkIGJvdW5kcyBhbmQgd2lsbCBubyBsb25nZXIgYmUgdHJhY2tlZCBmb3IgcGh5c2ljcycpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy51bnRyYWNrQm9keShib2R5KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobm9kZS5ib3VuZHMuY29udGFpbnMoYikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmUobm9kZSk7XHJcbiAgICAgICAgICAgIGIubGVmdCAtPSBQaHlzaWNzXzguUGh5c2ljcy5ib3VuZHNQYWRkaW5nO1xyXG4gICAgICAgICAgICBiLnRvcCAtPSBQaHlzaWNzXzguUGh5c2ljcy5ib3VuZHNQYWRkaW5nO1xyXG4gICAgICAgICAgICBiLnJpZ2h0ICs9IFBoeXNpY3NfOC5QaHlzaWNzLmJvdW5kc1BhZGRpbmc7XHJcbiAgICAgICAgICAgIGIuYm90dG9tICs9IFBoeXNpY3NfOC5QaHlzaWNzLmJvdW5kc1BhZGRpbmc7XHJcbiAgICAgICAgICAgIHZhciBtdWx0ZHggPSBib2R5LnZlbC54ICogUGh5c2ljc184LlBoeXNpY3MuZHluYW1pY1RyZWVWZWxvY2l0eU11bHRpcGx5ZXI7XHJcbiAgICAgICAgICAgIHZhciBtdWx0ZHkgPSBib2R5LnZlbC55ICogUGh5c2ljc184LlBoeXNpY3MuZHluYW1pY1RyZWVWZWxvY2l0eU11bHRpcGx5ZXI7XHJcbiAgICAgICAgICAgIGlmIChtdWx0ZHggPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBiLmxlZnQgKz0gbXVsdGR4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYi5yaWdodCArPSBtdWx0ZHg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG11bHRkeSA8IDApIHtcclxuICAgICAgICAgICAgICAgIGIudG9wICs9IG11bHRkeTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGIuYm90dG9tICs9IG11bHRkeTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBub2RlLmJvdW5kcyA9IGI7XHJcbiAgICAgICAgICAgIHRoaXMuX2luc2VydChub2RlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVbnRyYWNrcyBhIGJvZHkgZnJvbSB0aGUgZHluYW1pYyB0cmVlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLnVudHJhY2tCb2R5ID0gZnVuY3Rpb24gKGJvZHkpIHtcclxuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGVzW2JvZHkuYWN0b3IuaWRdO1xyXG4gICAgICAgICAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmUobm9kZSk7XHJcbiAgICAgICAgICAgIHRoaXMubm9kZXNbYm9keS5hY3Rvci5pZF0gPSBudWxsO1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5ub2Rlc1tib2R5LmFjdG9yLmlkXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJhbGFuY2VzIHRoZSB0cmVlIGFib3V0IGEgbm9kZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIER5bmFtaWNUcmVlLnByb3RvdHlwZS5fYmFsYW5jZSA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBiYWxhbmNlIGF0IG51bGwgbm9kZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChub2RlLmlzTGVhZigpIHx8IG5vZGUuaGVpZ2h0IDwgMikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGxlZnQgPSBub2RlLmxlZnQ7XHJcbiAgICAgICAgICAgIHZhciByaWdodCA9IG5vZGUucmlnaHQ7XHJcbiAgICAgICAgICAgIHZhciBhID0gbm9kZTtcclxuICAgICAgICAgICAgdmFyIGIgPSBsZWZ0O1xyXG4gICAgICAgICAgICB2YXIgYyA9IHJpZ2h0O1xyXG4gICAgICAgICAgICB2YXIgZCA9IGxlZnQubGVmdDtcclxuICAgICAgICAgICAgdmFyIGUgPSBsZWZ0LnJpZ2h0O1xyXG4gICAgICAgICAgICB2YXIgZiA9IHJpZ2h0LmxlZnQ7XHJcbiAgICAgICAgICAgIHZhciBnID0gcmlnaHQucmlnaHQ7XHJcbiAgICAgICAgICAgIHZhciBiYWxhbmNlID0gYy5oZWlnaHQgLSBiLmhlaWdodDtcclxuICAgICAgICAgICAgLy8gUm90YXRlIGMgbm9kZSB1cFxyXG4gICAgICAgICAgICBpZiAoYmFsYW5jZSA+IDEpIHtcclxuICAgICAgICAgICAgICAgIC8vIFN3YXAgdGhlIHJpZ2h0IG5vZGUgd2l0aCBpdCdzIHBhcmVudFxyXG4gICAgICAgICAgICAgICAgYy5sZWZ0ID0gYTtcclxuICAgICAgICAgICAgICAgIGMucGFyZW50ID0gYS5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICBhLnBhcmVudCA9IGM7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgb3JpZ2luYWwgbm9kZSdzIG9sZCBwYXJlbnQgc2hvdWxkIHBvaW50IHRvIHRoZSByaWdodCBub2RlXHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIG1lZ2EgY29uZnVzaW5nXHJcbiAgICAgICAgICAgICAgICBpZiAoYy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYy5wYXJlbnQubGVmdCA9PT0gYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjLnBhcmVudC5sZWZ0ID0gYztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMucGFyZW50LnJpZ2h0ID0gYztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvb3QgPSBjO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gUm90YXRlXHJcbiAgICAgICAgICAgICAgICBpZiAoZi5oZWlnaHQgPiBnLmhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGMucmlnaHQgPSBmO1xyXG4gICAgICAgICAgICAgICAgICAgIGEucmlnaHQgPSBnO1xyXG4gICAgICAgICAgICAgICAgICAgIGcucGFyZW50ID0gYTtcclxuICAgICAgICAgICAgICAgICAgICBhLmJvdW5kcyA9IGIuYm91bmRzLmNvbWJpbmUoZy5ib3VuZHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGMuYm91bmRzID0gYS5ib3VuZHMuY29tYmluZShmLmJvdW5kcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYS5oZWlnaHQgPSAxICsgTWF0aC5tYXgoYi5oZWlnaHQsIGcuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICBjLmhlaWdodCA9IDEgKyBNYXRoLm1heChhLmhlaWdodCwgZi5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYy5yaWdodCA9IGc7XHJcbiAgICAgICAgICAgICAgICAgICAgYS5yaWdodCA9IGY7XHJcbiAgICAgICAgICAgICAgICAgICAgZi5wYXJlbnQgPSBhO1xyXG4gICAgICAgICAgICAgICAgICAgIGEuYm91bmRzID0gYi5ib3VuZHMuY29tYmluZShmLmJvdW5kcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYy5ib3VuZHMgPSBhLmJvdW5kcy5jb21iaW5lKGcuYm91bmRzKTtcclxuICAgICAgICAgICAgICAgICAgICBhLmhlaWdodCA9IDEgKyBNYXRoLm1heChiLmhlaWdodCwgZi5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGMuaGVpZ2h0ID0gMSArIE1hdGgubWF4KGEuaGVpZ2h0LCBnLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBSb3RhdGUgbGVmdCBub2RlIHVwXHJcbiAgICAgICAgICAgIGlmIChiYWxhbmNlIDwgLTEpIHtcclxuICAgICAgICAgICAgICAgIC8vIHN3YXBcclxuICAgICAgICAgICAgICAgIGIubGVmdCA9IGE7XHJcbiAgICAgICAgICAgICAgICBiLnBhcmVudCA9IGEucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgYS5wYXJlbnQgPSBiO1xyXG4gICAgICAgICAgICAgICAgLy8gbm9kZSdzIG9sZCBwYXJlbnQgc2hvdWxkIHBvaW50IHRvIGJcclxuICAgICAgICAgICAgICAgIGlmIChiLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChiLnBhcmVudC5sZWZ0ID09PSBhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIucGFyZW50LmxlZnQgPSBiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGIucGFyZW50LnJpZ2h0ICE9PSBhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAnRXJyb3Igcm90YXRpbmcgRHluYW1pYyBUcmVlJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiLnBhcmVudC5yaWdodCA9IGI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290ID0gYjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHJvdGF0ZVxyXG4gICAgICAgICAgICAgICAgaWYgKGQuaGVpZ2h0ID4gZS5oZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBiLnJpZ2h0ID0gZDtcclxuICAgICAgICAgICAgICAgICAgICBhLmxlZnQgPSBlO1xyXG4gICAgICAgICAgICAgICAgICAgIGUucGFyZW50ID0gYTtcclxuICAgICAgICAgICAgICAgICAgICBhLmJvdW5kcyA9IGMuYm91bmRzLmNvbWJpbmUoZS5ib3VuZHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGIuYm91bmRzID0gYS5ib3VuZHMuY29tYmluZShkLmJvdW5kcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYS5oZWlnaHQgPSAxICsgTWF0aC5tYXgoYy5oZWlnaHQsIGUuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICBiLmhlaWdodCA9IDEgKyBNYXRoLm1heChhLmhlaWdodCwgZC5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYi5yaWdodCA9IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgYS5sZWZ0ID0gZDtcclxuICAgICAgICAgICAgICAgICAgICBkLnBhcmVudCA9IGE7XHJcbiAgICAgICAgICAgICAgICAgICAgYS5ib3VuZHMgPSBjLmJvdW5kcy5jb21iaW5lKGQuYm91bmRzKTtcclxuICAgICAgICAgICAgICAgICAgICBiLmJvdW5kcyA9IGEuYm91bmRzLmNvbWJpbmUoZS5ib3VuZHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGEuaGVpZ2h0ID0gMSArIE1hdGgubWF4KGMuaGVpZ2h0LCBkLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYi5oZWlnaHQgPSAxICsgTWF0aC5tYXgoYS5oZWlnaHQsIGUuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgaW50ZXJuYWwgaGVpZ2h0IG9mIHRoZSB0cmVlLCBzaG9ydGVyIHRyZWVzIGFyZSBiZXR0ZXIuIFBlcmZvcm1hbmNlIGRyb3BzIGFzIHRoZSB0cmVlIGdyb3dzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucm9vdCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5oZWlnaHQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBRdWVyaWVzIHRoZSBEeW5hbWljIEF4aXMgQWxpZ25lZCBUcmVlIGZvciBib2RpZXMgdGhhdCBjb3VsZCBiZSBjb2xsaWRpbmcgd2l0aCB0aGUgcHJvdmlkZWQgYm9keS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEluIHRoZSBxdWVyeSBjYWxsYmFjaywgaXQgd2lsbCBiZSBwYXNzZWQgYSBwb3RlbnRpYWwgY29sbGlkZXIuIFJldHVybmluZyB0cnVlIGZyb20gdGhpcyBjYWxsYmFjayBpbmRpY2F0ZXNcclxuICAgICAgICAgKiB0aGF0IHlvdSBhcmUgY29tcGxldGUgd2l0aCB5b3VyIHF1ZXJ5IGFuZCB5b3UgZG8gbm90IHdhbnQgdG8gY29udGludWUuIFJldHVybmluZyBmYWxzZSB3aWxsIGNvbnRpbnVlIHNlYXJjaGluZ1xyXG4gICAgICAgICAqIHRoZSB0cmVlIHVudGlsIGFsbCBwb3NzaWJsZSBjb2xsaWRlcnMgaGF2ZSBiZWVuIHJldHVybmVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIER5bmFtaWNUcmVlLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIChib2R5LCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICB2YXIgYm91bmRzID0gYm9keS5nZXRCb3VuZHMoKTtcclxuICAgICAgICAgICAgdmFyIGhlbHBlciA9IGZ1bmN0aW9uIChjdXJyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlICYmIGN1cnJlbnROb2RlLmJvdW5kcy5jb2xsaWRlcyhib3VuZHMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLmlzTGVhZigpICYmIGN1cnJlbnROb2RlLmJvZHkgIT09IGJvZHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrLmNhbGwoYm9keSwgY3VycmVudE5vZGUuYm9keSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVyKGN1cnJlbnROb2RlLmxlZnQpIHx8IGhlbHBlcihjdXJyZW50Tm9kZS5yaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBoZWxwZXIodGhpcy5yb290KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFF1ZXJpZXMgdGhlIER5bmFtaWMgQXhpcyBBbGlnbmVkIFRyZWUgZm9yIGJvZGllcyB0aGF0IGNvdWxkIGJlIGludGVyc2VjdGluZy4gQnkgZGVmYXVsdCB0aGUgcmF5Y2FzdCBxdWVyeSB1c2VzIGFuIGluZmluaXRlbHlcclxuICAgICAgICAgKiBsb25nIHJheSB0byB0ZXN0IHRoZSB0cmVlIHNwZWNpZmllZCBieSBgbWF4YC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEluIHRoZSBxdWVyeSBjYWxsYmFjaywgaXQgd2lsbCBiZSBwYXNzZWQgYSBwb3RlbnRpYWwgYm9keSB0aGF0IGludGVyc2VjdHMgd2l0aCB0aGUgcmFjYXN0LiBSZXR1cm5pbmcgdHJ1ZSBmcm9tIHRoaXNcclxuICAgICAgICAgKiBjYWxsYmFjayBpbmRpY2F0ZXMgdGhhdCB5b3VyIGFyZSBjb21wbGV0ZSB3aXRoIHlvdXIgcXVlcnkgYW5kIGRvIG5vdCB3YW50IHRvIGNvbnRpbnVlLiBSZXR1cm4gZmFsc2Ugd2lsbCBjb250aW51ZSBzZWFyY2hpbmdcclxuICAgICAgICAgKiB0aGUgdHJlZSB1bnRpbCBhbGwgcG9zc2libGUgYm9kaWVzIHRoYXQgd291bGQgaW50ZXJzZWN0IHdpdGggdGhlIHJheSBoYXZlIGJlZW4gcmV0dXJuZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLnJheUNhc3RRdWVyeSA9IGZ1bmN0aW9uIChyYXksIG1heCwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgaWYgKG1heCA9PT0gdm9pZCAwKSB7IG1heCA9IEluZmluaXR5OyB9XHJcbiAgICAgICAgICAgIHZhciBoZWxwZXIgPSBmdW5jdGlvbiAoY3VycmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZSAmJiBjdXJyZW50Tm9kZS5ib3VuZHMucmF5Q2FzdChyYXksIG1heCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUuaXNMZWFmKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrLmNhbGwocmF5LCBjdXJyZW50Tm9kZS5ib2R5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmF5IGhpdCBhIGxlYWYhIHJldHVybiB0aGUgYm9keVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJheSBoaXQgYnV0IG5vdCBhdCBhIGxlYWYsIHJlY3Vyc2UgZGVlcGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXIoY3VycmVudE5vZGUubGVmdCkgfHwgaGVscGVyKGN1cnJlbnROb2RlLnJpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIHJheSBtaXNzZWQgICAgICAgICBcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaGVscGVyKHRoaXMucm9vdCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBEeW5hbWljVHJlZS5wcm90b3R5cGUuZ2V0Tm9kZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBoZWxwZXIgPSBmdW5jdGlvbiAoY3VycmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbY3VycmVudE5vZGVdLmNvbmNhdChoZWxwZXIoY3VycmVudE5vZGUubGVmdCksIGhlbHBlcihjdXJyZW50Tm9kZS5yaWdodCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gaGVscGVyKHRoaXMucm9vdCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBEeW5hbWljVHJlZS5wcm90b3R5cGUuZGVidWdEcmF3ID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gICAgICAgICAgICAvLyBkcmF3IGFsbCB0aGUgbm9kZXMgaW4gdGhlIER5bmFtaWMgVHJlZVxyXG4gICAgICAgICAgICB2YXIgaGVscGVyID0gZnVuY3Rpb24gKGN1cnJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUuaXNMZWFmKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdncmVlbic7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ3doaXRlJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUuYm91bmRzLmRlYnVnRHJhdyhjdHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZS5sZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlbHBlcihjdXJyZW50Tm9kZS5sZWZ0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLnJpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlbHBlcihjdXJyZW50Tm9kZS5yaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBoZWxwZXIodGhpcy5yb290KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBEeW5hbWljVHJlZTtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkR5bmFtaWNUcmVlID0gRHluYW1pY1RyZWU7XHJcbn0pO1xyXG5kZWZpbmUoXCJDb2xsaXNpb24vSUNvbGxpc2lvblJlc29sdmVyXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbn0pO1xyXG5kZWZpbmUoXCJDb2xsaXNpb24vRHluYW1pY1RyZWVDb2xsaXNpb25Ccm9hZHBoYXNlXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiUGh5c2ljc1wiLCBcIkNvbGxpc2lvbi9EeW5hbWljVHJlZVwiLCBcIkNvbGxpc2lvbi9QYWlyXCIsIFwiQWxnZWJyYVwiLCBcIkFjdG9yXCIsIFwiVXRpbC9Mb2dcIiwgXCJFdmVudHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBQaHlzaWNzXzksIER5bmFtaWNUcmVlXzEsIFBhaXJfMiwgQWxnZWJyYV8xOCwgQWN0b3JfOSwgTG9nXzksIEV2ZW50c182KSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIHZhciBEeW5hbWljVHJlZUNvbGxpc2lvbkJyb2FkcGhhc2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIER5bmFtaWNUcmVlQ29sbGlzaW9uQnJvYWRwaGFzZSgpIHtcclxuICAgICAgICAgICAgdGhpcy5fZHluYW1pY0NvbGxpc2lvblRyZWUgPSBuZXcgRHluYW1pY1RyZWVfMS5EeW5hbWljVHJlZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9jb2xsaXNpb25IYXNoID0ge307XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbGxpc2lvblBhaXJDYWNoZSA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLl9sYXN0RnJhbWVQYWlycyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLl9sYXN0RnJhbWVQYWlyc0hhc2ggPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVHJhY2tzIGEgcGh5c2ljcyBib2R5IGZvciBjb2xsaXNpb25zXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHluYW1pY1RyZWVDb2xsaXNpb25Ccm9hZHBoYXNlLnByb3RvdHlwZS50cmFjayA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIExvZ185LkxvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4oJ0Nhbm5vdCB0cmFjayBudWxsIHBoeXNpY3MgYm9keScpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2R5bmFtaWNDb2xsaXNpb25UcmVlLnRyYWNrQm9keSh0YXJnZXQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVW50cmFja3MgYSBwaHlzaWNzIGJvZHlcclxuICAgICAgICAgKi9cclxuICAgICAgICBEeW5hbWljVHJlZUNvbGxpc2lvbkJyb2FkcGhhc2UucHJvdG90eXBlLnVudHJhY2sgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICBMb2dfOS5Mb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKCdDYW5ub3QgdW50cmFjayBhIG51bGwgcGh5c2ljcyBib2R5Jyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fZHluYW1pY0NvbGxpc2lvblRyZWUudW50cmFja0JvZHkodGFyZ2V0KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIER5bmFtaWNUcmVlQ29sbGlzaW9uQnJvYWRwaGFzZS5wcm90b3R5cGUuX2NhbkNvbGxpZGUgPSBmdW5jdGlvbiAoYWN0b3JBLCBhY3RvckIpIHtcclxuICAgICAgICAgICAgLy8gaWYgdGhlIGNvbGxpc2lvbiBwYWlyIGhhcyBiZWVuIGNhbGN1bGF0ZWQgYWxyZWFkeSBzaG9ydCBjaXJjdWl0XHJcbiAgICAgICAgICAgIHZhciBoYXNoID0gUGFpcl8yLlBhaXIuY2FsY3VsYXRlUGFpckhhc2goYWN0b3JBLmJvZHksIGFjdG9yQi5ib2R5KTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2NvbGxpc2lvbkhhc2hbaGFzaF0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gcGFpciBleGlzdHMgZWFzeSBleGl0IHJldHVybiBmYWxzZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGlmIGJvdGggYXJlIGZpeGVkIHNob3J0IGNpcmN1aXRcclxuICAgICAgICAgICAgaWYgKGFjdG9yQS5jb2xsaXNpb25UeXBlID09PSBBY3Rvcl85LkNvbGxpc2lvblR5cGUuRml4ZWQgJiYgYWN0b3JCLmNvbGxpc2lvblR5cGUgPT09IEFjdG9yXzkuQ29sbGlzaW9uVHlwZS5GaXhlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGlmIHRoZSBvdGhlciBpcyBwcmV2ZW50IGNvbGxpc2lvbiBvciBpcyBkZWFkIHNob3J0IGNpcmN1aXRcclxuICAgICAgICAgICAgaWYgKGFjdG9yQi5jb2xsaXNpb25UeXBlID09PSBBY3Rvcl85LkNvbGxpc2lvblR5cGUuUHJldmVudENvbGxpc2lvbiB8fCBhY3RvckIuaXNLaWxsZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHRoZXkgY2FuIGNvbGxpZGVcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZXRlY3RzIHBvdGVudGlhbCBjb2xsaXNpb24gcGFpcnMgaW4gYSBicm9hZHBoYXNlIGFwcHJvYWNoIHdpdGggdGhlIGR5bmFtaWMgYWFiYiB0cmVlIHN0cmF0ZWd5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHluYW1pY1RyZWVDb2xsaXNpb25Ccm9hZHBoYXNlLnByb3RvdHlwZS5icm9hZHBoYXNlID0gZnVuY3Rpb24gKHRhcmdldHMsIGRlbHRhLCBzdGF0cykge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgc2Vjb25kcyA9IGRlbHRhIC8gMTAwMDtcclxuICAgICAgICAgICAgLy8gVE9ETyBvcHRpbWl6YXRpb24gdXNlIG9ubHkgdGhlIGFjdG9ycyB0aGF0IGFyZSBtb3ZpbmcgdG8gc3RhcnQgXHJcbiAgICAgICAgICAgIC8vIFJldHJpZXZlIHRoZSBsaXN0IG9mIHBvdGVudGlhbCBjb2xsaWRlcnMsIGV4Y2x1ZGUga2lsbGVkLCBwcmV2ZW50ZWQsIGFuZCBzZWxmXHJcbiAgICAgICAgICAgIHZhciBwb3RlbnRpYWxDb2xsaWRlcnMgPSB0YXJnZXRzLmZpbHRlcihmdW5jdGlvbiAob3RoZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhb3RoZXIuaXNLaWxsZWQoKSAmJiBvdGhlci5jb2xsaXNpb25UeXBlICE9PSBBY3Rvcl85LkNvbGxpc2lvblR5cGUuUHJldmVudENvbGxpc2lvbjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIGNsZWFyIG9sZCBsaXN0IG9mIGNvbGxpc2lvbiBwYWlyc1xyXG4gICAgICAgICAgICB0aGlzLl9jb2xsaXNpb25QYWlyQ2FjaGUgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5fY29sbGlzaW9uSGFzaCA9IHt9O1xyXG4gICAgICAgICAgICAvLyBjaGVjayBmb3Igbm9ybWFsIGNvbGxpc2lvbiBwYWlyc1xyXG4gICAgICAgICAgICB2YXIgYWN0b3I7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBsID0gcG90ZW50aWFsQ29sbGlkZXJzLmxlbmd0aDsgaiA8IGw7IGorKykge1xyXG4gICAgICAgICAgICAgICAgYWN0b3IgPSBwb3RlbnRpYWxDb2xsaWRlcnNbal07XHJcbiAgICAgICAgICAgICAgICAvLyBRdWVyeSB0aGUgY29sbGlzaW9uIHRyZWUgZm9yIHBvdGVudGlhbCBjb2xsaWRlcnNcclxuICAgICAgICAgICAgICAgIHRoaXMuX2R5bmFtaWNDb2xsaXNpb25UcmVlLnF1ZXJ5KGFjdG9yLmJvZHksIGZ1bmN0aW9uIChvdGhlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fY2FuQ29sbGlkZShhY3Rvciwgb3RoZXIuYWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYWlyID0gbmV3IFBhaXJfMi5QYWlyKGFjdG9yLmJvZHksIG90aGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2NvbGxpc2lvbkhhc2hbcGFpci5pZF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fY29sbGlzaW9uUGFpckNhY2hlLnB1c2gocGFpcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFsd2F5cyByZXR1cm4gZmFsc2UsIHRvIHF1ZXJ5IHdob2xlIHRyZWUuIFJldHVybmluZyB0cnVlIGluIHRoZSBxdWVyeSBtZXRob2Qgc3RvcHMgc2VhcmNoaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHN0YXRzKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0cy5waHlzaWNzLnBhaXJzID0gdGhpcy5fY29sbGlzaW9uUGFpckNhY2hlLmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBDaGVjayBkeW5hbWljIHRyZWUgZm9yIGZhc3QgbW92aW5nIG9iamVjdHNcclxuICAgICAgICAgICAgLy8gRmFzdCBtb3Zpbmcgb2JqZWN0cyBhcmUgdGhvc2UgbW92aW5nIGF0IGxlYXN0IHRoZXJlIHNtYWxsZXN0IGJvdW5kIHBlciBmcmFtZVxyXG4gICAgICAgICAgICBpZiAoUGh5c2ljc185LlBoeXNpY3MuY2hlY2tGb3JGYXN0Qm9kaWVzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHBvdGVudGlhbENvbGxpZGVyc18xID0gcG90ZW50aWFsQ29sbGlkZXJzOyBfaSA8IHBvdGVudGlhbENvbGxpZGVyc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3RvciA9IHBvdGVudGlhbENvbGxpZGVyc18xW19pXTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIG5vbi1hY3RpdmUgb2JqZWN0cy4gRG9lcyBub3QgbWFrZSBzZW5zZSBvbiBvdGhlciBjb2xsaXNvbiB0eXBlc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rvci5jb2xsaXNpb25UeXBlICE9PSBBY3Rvcl85LkNvbGxpc2lvblR5cGUuQWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICA7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTWF4aW11bSB0cmF2ZWwgZGlzdGFuY2UgbmV4dCBmcmFtZVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB1cGRhdGVEaXN0YW5jZSA9IChhY3Rvci52ZWwubWFnbml0dWRlKCkgKiBzZWNvbmRzKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChhY3Rvci5hY2MubWFnbml0dWRlKCkgKiAuNSAqIHNlY29uZHMgKiBzZWNvbmRzKTsgLy8gYWNjIHRlcm1cclxuICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBtaW5pbXVtIGRpbWVuc2lvblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtaW5EaW1lbnNpb24gPSBNYXRoLm1pbihhY3Rvci5ib2R5LmdldEJvdW5kcygpLmdldEhlaWdodCgpLCBhY3Rvci5ib2R5LmdldEJvdW5kcygpLmdldFdpZHRoKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChQaHlzaWNzXzkuUGh5c2ljcy5kaXNhYmxlTWluaW11bVNwZWVkRm9yRmFzdEJvZHkgfHwgdXBkYXRlRGlzdGFuY2UgPiAobWluRGltZW5zaW9uIC8gMikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0cy5waHlzaWNzLmZhc3RCb2RpZXMrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFydCB3aXRoIHRoZSBvbGRQb3MgYmVjYXVzZSB0aGUgaW50ZWdyYXRpb24gZm9yIGFjdG9ycyBoYXMgYWxyZWFkeSBoYXBwZW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvYmplY3RzIHJlc3Rpbmcgb24gYSBzdXJmYWNlIG1heSBiZSBzbGlnaHRseSBwZW5hdHJhdGluZyBpbiB0aGUgY3VycmVudCBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXBkYXRlVmVjID0gYWN0b3IucG9zLnN1YihhY3Rvci5vbGRQb3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2VudGVyUG9pbnQgPSBhY3Rvci5ib2R5LmNvbGxpc2lvbkFyZWEuZ2V0Q2VudGVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmdXJ0aGVzdFBvaW50ID0gYWN0b3IuYm9keS5jb2xsaXNpb25BcmVhLmdldEZ1cnRoZXN0UG9pbnQoYWN0b3IudmVsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9yaWdpbiA9IGZ1cnRoZXN0UG9pbnQuc3ViKHVwZGF0ZVZlYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYXkgPSBuZXcgQWxnZWJyYV8xOC5SYXkob3JpZ2luLCBhY3Rvci52ZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBiYWNrIHRoZSByYXkgdXAgYnkgLTJ4IHN1cmZhY2VFcHNpbG9uIHRvIGFjY291bnQgZm9yIGZhc3QgbW92aW5nIG9iamVjdHMgc3RhcnRpbmcgb24gdGhlIHN1cmZhY2UgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJheS5wb3MgPSByYXkucG9zLmFkZChyYXkuZGlyLnNjYWxlKC0yICogUGh5c2ljc185LlBoeXNpY3Muc3VyZmFjZUVwc2lsb24pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1pbkJvZHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtaW5UcmFuc2xhdGUgPSBuZXcgQWxnZWJyYV8xOC5WZWN0b3IoSW5maW5pdHksIEluZmluaXR5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHluYW1pY0NvbGxpc2lvblRyZWUucmF5Q2FzdFF1ZXJ5KHJheSwgdXBkYXRlRGlzdGFuY2UgKyBQaHlzaWNzXzkuUGh5c2ljcy5zdXJmYWNlRXBzaWxvbiAqIDIsIGZ1bmN0aW9uIChvdGhlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFjdG9yLmJvZHkgIT09IG90aGVyICYmIG90aGVyLmNvbGxpc2lvbkFyZWEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGl0UG9pbnQgPSBvdGhlci5jb2xsaXNpb25BcmVhLnJheUNhc3QocmF5LCB1cGRhdGVEaXN0YW5jZSArIFBoeXNpY3NfOS5QaHlzaWNzLnN1cmZhY2VFcHNpbG9uICogMTApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoaXRQb2ludCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNsYXRlID0gaGl0UG9pbnQuc3ViKG9yaWdpbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc2xhdGUubWFnbml0dWRlKCkgPCBtaW5UcmFuc2xhdGUubWFnbml0dWRlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pblRyYW5zbGF0ZSA9IHRyYW5zbGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbkJvZHkgPSBvdGhlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtaW5Cb2R5ICYmIEFsZ2VicmFfMTguVmVjdG9yLmlzVmFsaWQobWluVHJhbnNsYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhaXIgPSBuZXcgUGFpcl8yLlBhaXIoYWN0b3IuYm9keSwgbWluQm9keSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2NvbGxpc2lvbkhhc2hbcGFpci5pZF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb2xsaXNpb25IYXNoW3BhaXIuaWRdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb2xsaXNpb25QYWlyQ2FjaGUucHVzaChwYWlyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgdGhlIGZhc3QgbW92aW5nIG9iamVjdCB0byB0aGUgb3RoZXIgYm9keVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byBwdXNoIGludG8gdGhlIHN1cmZhY2UgYnkgZXguUGh5c2ljcy5zdXJmYWNlRXBzaWxvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNoaWZ0ID0gY2VudGVyUG9pbnQuc3ViKGZ1cnRoZXN0UG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0b3IucG9zID0gb3JpZ2luLmFkZChzaGlmdCkuYWRkKG1pblRyYW5zbGF0ZSkuYWRkKHJheS5kaXIuc2NhbGUoMiAqIFBoeXNpY3NfOS5QaHlzaWNzLnN1cmZhY2VFcHNpbG9uKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rvci5ib2R5LmNvbGxpc2lvbkFyZWEucmVjYWxjKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0cy5waHlzaWNzLmZhc3RCb2R5Q29sbGlzaW9ucysrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHJldHVybiBjYWNoZVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sbGlzaW9uUGFpckNhY2hlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXBwbGllcyBuYXJyb3cgcGhhc2Ugb24gY29sbGlzaW9uIHBhaXJzIHRvIGZpbmQgYWN0dWFsIGFyZWEgaW50ZXJzZWN0aW9uc1xyXG4gICAgICAgICAqIEFkZHMgYWN0dWFsIGNvbGxpZGluZyBwYWlycyB0byBzdGF0cycgRnJhbWUgZGF0YVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIER5bmFtaWNUcmVlQ29sbGlzaW9uQnJvYWRwaGFzZS5wcm90b3R5cGUubmFycm93cGhhc2UgPSBmdW5jdGlvbiAocGFpcnMsIHN0YXRzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHBhaXJzW2ldLmNvbGxpZGUoKTtcclxuICAgICAgICAgICAgICAgIGlmIChzdGF0cyAmJiBwYWlyc1tpXS5jb2xsaXNpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0cy5waHlzaWNzLmNvbGxpc2lvbnMrKztcclxuICAgICAgICAgICAgICAgICAgICBzdGF0cy5waHlzaWNzLmNvbGxpZGVyc0hhc2hbcGFpcnNbaV0uaWRdID0gcGFpcnNbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHBhaXJzLmZpbHRlcihmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5jb2xsaXNpb247IH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGVyZm9ybSBjb2xsaXNpb24gcmVzb2x1dGlvbiBnaXZlbiBhIHN0cmF0ZWd5IChyaWdpZCBib2R5IG9yIGJveCkgYW5kIG1vdmUgb2JqZWN0cyBvdXQgb2YgaW50ZXJzZWN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIER5bmFtaWNUcmVlQ29sbGlzaW9uQnJvYWRwaGFzZS5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIChwYWlycywgZGVsdGEsIHN0cmF0ZWd5KSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgcGFpcnNfMSA9IHBhaXJzOyBfaSA8IHBhaXJzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFpciA9IHBhaXJzXzFbX2ldO1xyXG4gICAgICAgICAgICAgICAgcGFpci5yZXNvbHZlKHN0cmF0ZWd5KTtcclxuICAgICAgICAgICAgICAgIGlmIChwYWlyLmNvbGxpc2lvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhaXIuYm9keUEuYXBwbHlNdHYoKTtcclxuICAgICAgICAgICAgICAgICAgICBwYWlyLmJvZHlCLmFwcGx5TXR2KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdG9kbyBzdGlsbCBkb24ndCBsaWtlIHRoaXMsIHRoaXMgaXMgYSBzbWFsbCBpbnRlZ3JhdGlvbiBzdGVwIHRvIHJlc29sdmUgbmFycm93cGhhc2UgY29sbGlzaW9uc1xyXG4gICAgICAgICAgICAgICAgICAgIHBhaXIuYm9keUEuYWN0b3IuaW50ZWdyYXRlKGRlbHRhICogUGh5c2ljc185LlBoeXNpY3MuY29sbGlzaW9uU2hpZnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhaXIuYm9keUIuYWN0b3IuaW50ZWdyYXRlKGRlbHRhICogUGh5c2ljc185LlBoeXNpY3MuY29sbGlzaW9uU2hpZnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwYWlycy5maWx0ZXIoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAuY2FuQ29sbGlkZTsgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBEeW5hbWljVHJlZUNvbGxpc2lvbkJyb2FkcGhhc2UucHJvdG90eXBlLnJ1bkNvbGxpc2lvblN0YXJ0RW5kID0gZnVuY3Rpb24gKHBhaXJzKSB7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50RnJhbWVIYXNoID0ge307XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgcGFpcnNfMiA9IHBhaXJzOyBfaSA8IHBhaXJzXzIubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcCA9IHBhaXJzXzJbX2ldO1xyXG4gICAgICAgICAgICAgICAgLy8gbG9hZCBjdXJyZW50RnJhbWVIYXNoXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50RnJhbWVIYXNoW3AuaWRdID0gcDtcclxuICAgICAgICAgICAgICAgIC8vIGZpbmQgYWxsIG5ldyBjb2xsaXNpb25zXHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2xhc3RGcmFtZVBhaXJzSGFzaFtwLmlkXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3RvcjEgPSBwLmJvZHlBLmFjdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3RvcjIgPSBwLmJvZHlCLmFjdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdG9yMS5lbWl0KCdjb2xsaXNpb25zdGFydCcsIG5ldyBFdmVudHNfNi5Db2xsaXNpb25TdGFydEV2ZW50KGFjdG9yMSwgYWN0b3IyLCBwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0b3IyLmVtaXQoJ2NvbGxpc2lvbnN0YXJ0JywgbmV3IEV2ZW50c182LkNvbGxpc2lvblN0YXJ0RXZlbnQoYWN0b3IyLCBhY3RvcjEsIHApKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBmaW5kIGFsbCBvbGQgY29sbGlzaW9uc1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfYSA9IDAsIF9iID0gdGhpcy5fbGFzdEZyYW1lUGFpcnM7IF9hIDwgX2IubGVuZ3RoOyBfYSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcCA9IF9iW19hXTtcclxuICAgICAgICAgICAgICAgIGlmICghY3VycmVudEZyYW1lSGFzaFtwLmlkXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3RvcjEgPSBwLmJvZHlBLmFjdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3RvcjIgPSBwLmJvZHlCLmFjdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdG9yMS5lbWl0KCdjb2xsaXNpb25lbmQnLCBuZXcgRXZlbnRzXzYuQ29sbGlzaW9uRW5kRXZlbnQoYWN0b3IxLCBhY3RvcjIpKTtcclxuICAgICAgICAgICAgICAgICAgICBhY3RvcjIuZW1pdCgnY29sbGlzaW9uZW5kJywgbmV3IEV2ZW50c182LkNvbGxpc2lvbkVuZEV2ZW50KGFjdG9yMiwgYWN0b3IxKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcmVzZXQgdGhlIGxhc3QgZnJhbWUgY2FjaGVcclxuICAgICAgICAgICAgdGhpcy5fbGFzdEZyYW1lUGFpcnMgPSBwYWlycztcclxuICAgICAgICAgICAgdGhpcy5fbGFzdEZyYW1lUGFpcnNIYXNoID0gY3VycmVudEZyYW1lSGFzaDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwZGF0ZSB0aGUgZHluYW1pYyB0cmVlIHBvc2l0aW9uc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIER5bmFtaWNUcmVlQ29sbGlzaW9uQnJvYWRwaGFzZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHRhcmdldHMpIHtcclxuICAgICAgICAgICAgdmFyIHVwZGF0ZWQgPSAwLCBpID0gMCwgbGVuID0gdGFyZ2V0cy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZHluYW1pY0NvbGxpc2lvblRyZWUudXBkYXRlQm9keSh0YXJnZXRzW2ldLmJvZHkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVkO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBEeW5hbWljVHJlZUNvbGxpc2lvbkJyb2FkcGhhc2UucHJvdG90eXBlLmRlYnVnRHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICAgICAgICAgICAgaWYgKFBoeXNpY3NfOS5QaHlzaWNzLmJyb2FkcGhhc2VEZWJ1Zykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZHluYW1pY0NvbGxpc2lvblRyZWUuZGVidWdEcmF3KGN0eCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKFBoeXNpY3NfOS5QaHlzaWNzLnNob3dDb250YWN0cyB8fCBQaHlzaWNzXzkuUGh5c2ljcy5zaG93Q29sbGlzaW9uTm9ybWFscykge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuX2NvbGxpc2lvblBhaXJDYWNoZTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFpciA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgICAgICBwYWlyLmRlYnVnRHJhdyhjdHgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gRHluYW1pY1RyZWVDb2xsaXNpb25Ccm9hZHBoYXNlO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuRHluYW1pY1RyZWVDb2xsaXNpb25Ccm9hZHBoYXNlID0gRHluYW1pY1RyZWVDb2xsaXNpb25Ccm9hZHBoYXNlO1xyXG59KTtcclxuZGVmaW5lKFwiQ29sbGlzaW9uL0lQaHlzaWNzXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbn0pO1xyXG5kZWZpbmUoXCJDb2xsaXNpb24vTmFpdmVDb2xsaXNpb25Ccm9hZHBoYXNlXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiUGh5c2ljc1wiLCBcIkNvbGxpc2lvbi9Db2xsaXNpb25Db250YWN0XCIsIFwiQ29sbGlzaW9uL1BhaXJcIiwgXCJBY3RvclwiLCBcIkV2ZW50c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIFBoeXNpY3NfMTAsIENvbGxpc2lvbkNvbnRhY3RfMiwgUGFpcl8zLCBBY3Rvcl8xMCwgRXZlbnRzXzcpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgdmFyIE5haXZlQ29sbGlzaW9uQnJvYWRwaGFzZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gTmFpdmVDb2xsaXNpb25Ccm9hZHBoYXNlKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9sYXN0RnJhbWVQYWlycyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLl9sYXN0RnJhbWVQYWlyc0hhc2ggPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgTmFpdmVDb2xsaXNpb25Ccm9hZHBoYXNlLnByb3RvdHlwZS50cmFjayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gcGFzc1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgTmFpdmVDb2xsaXNpb25Ccm9hZHBoYXNlLnByb3RvdHlwZS51bnRyYWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBwYXNzXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZXRlY3RzIHBvdGVudGlhbCBjb2xsaXNpb24gcGFpcnMgaW4gYSBicm9hZHBoYXNlIGFwcHJvYWNoIHdpdGggdGhlIGR5bmFtaWMgYWFiYiB0cmVlIHN0cmF0ZWd5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTmFpdmVDb2xsaXNpb25Ccm9hZHBoYXNlLnByb3RvdHlwZS5icm9hZHBoYXNlID0gZnVuY3Rpb24gKHRhcmdldHMpIHtcclxuICAgICAgICAgICAgLy8gUmV0cmlldmUgdGhlIGxpc3Qgb2YgcG90ZW50aWFsIGNvbGxpZGVycywgZXhjbHVkZSBraWxsZWQsIHByZXZlbnRlZCwgYW5kIHNlbGZcclxuICAgICAgICAgICAgdmFyIHBvdGVudGlhbENvbGxpZGVycyA9IHRhcmdldHMuZmlsdGVyKGZ1bmN0aW9uIChvdGhlcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICFvdGhlci5pc0tpbGxlZCgpICYmIG90aGVyLmNvbGxpc2lvblR5cGUgIT09IEFjdG9yXzEwLkNvbGxpc2lvblR5cGUuUHJldmVudENvbGxpc2lvbjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHZhciBhY3RvcjE7XHJcbiAgICAgICAgICAgIHZhciBhY3RvcjI7XHJcbiAgICAgICAgICAgIHZhciBjb2xsaXNpb25QYWlycyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbCA9IHBvdGVudGlhbENvbGxpZGVycy5sZW5ndGg7IGogPCBsOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGFjdG9yMSA9IHBvdGVudGlhbENvbGxpZGVyc1tqXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBqICsgMTsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdG9yMiA9IHBvdGVudGlhbENvbGxpZGVyc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWluaW11bVRyYW5zbGF0aW9uVmVjdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtaW5pbXVtVHJhbnNsYXRpb25WZWN0b3IgPSBhY3RvcjEuY29sbGlkZXMoYWN0b3IyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFpciA9IG5ldyBQYWlyXzMuUGFpcihhY3RvcjEuYm9keSwgYWN0b3IyLmJvZHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWlyLmNvbGxpc2lvbiA9IG5ldyBDb2xsaXNpb25Db250YWN0XzIuQ29sbGlzaW9uQ29udGFjdChhY3RvcjEuY29sbGlzaW9uQXJlYSwgYWN0b3IyLmNvbGxpc2lvbkFyZWEsIG1pbmltdW1UcmFuc2xhdGlvblZlY3RvciwgYWN0b3IxLnBvcywgbWluaW11bVRyYW5zbGF0aW9uVmVjdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb2xsaXNpb25QYWlycy5zb21lKGZ1bmN0aW9uIChjcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNwLmlkID09PSBwYWlyLmlkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9uUGFpcnMucHVzaChwYWlyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY29sbGlzaW9uUGFpcnM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZGVudGlmeSBhY3R1YWwgY29sbGlzaW9ucyBmcm9tIHRob3NlIHBhaXJzLCBhbmQgY2FsY3VsYXRlIGNvbGxpc2lvbiBpbXB1bHNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTmFpdmVDb2xsaXNpb25Ccm9hZHBoYXNlLnByb3RvdHlwZS5uYXJyb3dwaGFzZSA9IGZ1bmN0aW9uIChwYWlycykge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFpcnM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBOYWl2ZUNvbGxpc2lvbkJyb2FkcGhhc2UucHJvdG90eXBlLnJ1bkNvbGxpc2lvblN0YXJ0RW5kID0gZnVuY3Rpb24gKHBhaXJzKSB7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50RnJhbWVIYXNoID0ge307XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgcGFpcnNfMyA9IHBhaXJzOyBfaSA8IHBhaXJzXzMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcCA9IHBhaXJzXzNbX2ldO1xyXG4gICAgICAgICAgICAgICAgLy8gbG9hZCBjdXJyZW50RnJhbWVIYXNoXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50RnJhbWVIYXNoW3AuaWRdID0gcDtcclxuICAgICAgICAgICAgICAgIC8vIGZpbmQgYWxsIG5ldyBjb2xsaXNpb25zXHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2xhc3RGcmFtZVBhaXJzSGFzaFtwLmlkXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3RvcjEgPSBwLmJvZHlBLmFjdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3RvcjIgPSBwLmJvZHlCLmFjdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdG9yMS5lbWl0KCdjb2xsaXNpb25zdGFydCcsIG5ldyBFdmVudHNfNy5Db2xsaXNpb25TdGFydEV2ZW50KGFjdG9yMSwgYWN0b3IyLCBwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0b3IyLmVtaXQoJ2NvbGxpc2lvbnN0YXJ0JywgbmV3IEV2ZW50c183LkNvbGxpc2lvblN0YXJ0RXZlbnQoYWN0b3IyLCBhY3RvcjEsIHApKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBmaW5kIGFsbCBvbGQgY29sbGlzaW9uc1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfYSA9IDAsIF9iID0gdGhpcy5fbGFzdEZyYW1lUGFpcnM7IF9hIDwgX2IubGVuZ3RoOyBfYSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcCA9IF9iW19hXTtcclxuICAgICAgICAgICAgICAgIGlmICghY3VycmVudEZyYW1lSGFzaFtwLmlkXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3RvcjEgPSBwLmJvZHlBLmFjdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3RvcjIgPSBwLmJvZHlCLmFjdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdG9yMS5lbWl0KCdjb2xsaXNpb25lbmQnLCBuZXcgRXZlbnRzXzcuQ29sbGlzaW9uRW5kRXZlbnQoYWN0b3IxLCBhY3RvcjIpKTtcclxuICAgICAgICAgICAgICAgICAgICBhY3RvcjIuZW1pdCgnY29sbGlzaW9uZW5kJywgbmV3IEV2ZW50c183LkNvbGxpc2lvbkVuZEV2ZW50KGFjdG9yMiwgYWN0b3IxKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcmVzZXQgdGhlIGxhc3QgZnJhbWUgY2FjaGVcclxuICAgICAgICAgICAgdGhpcy5fbGFzdEZyYW1lUGFpcnMgPSBwYWlycztcclxuICAgICAgICAgICAgdGhpcy5fbGFzdEZyYW1lUGFpcnNIYXNoID0gY3VycmVudEZyYW1lSGFzaDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlc29sdmUgdGhlIHBvc2l0aW9uIGFuZCB2ZWxvY2l0eSBvZiB0aGUgcGh5c2ljcyBib2RpZXNcclxuICAgICAgICAgKi9cclxuICAgICAgICBOYWl2ZUNvbGxpc2lvbkJyb2FkcGhhc2UucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAocGFpcnMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBwYWlyc180ID0gcGFpcnM7IF9pIDwgcGFpcnNfNC5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYWlyID0gcGFpcnNfNFtfaV07XHJcbiAgICAgICAgICAgICAgICBwYWlyLnJlc29sdmUoUGh5c2ljc18xMC5QaHlzaWNzLmNvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHBhaXJzLmZpbHRlcihmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5jYW5Db2xsaWRlOyB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIE5haXZlQ29sbGlzaW9uQnJvYWRwaGFzZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIE5haXZlQ29sbGlzaW9uQnJvYWRwaGFzZS5wcm90b3R5cGUuZGVidWdEcmF3ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gTmFpdmVDb2xsaXNpb25Ccm9hZHBoYXNlO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuTmFpdmVDb2xsaXNpb25Ccm9hZHBoYXNlID0gTmFpdmVDb2xsaXNpb25Ccm9hZHBoYXNlO1xyXG59KTtcclxuZGVmaW5lKFwiQ29sbGlzaW9uL0luZGV4XCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiQ29sbGlzaW9uL0JvZHlcIiwgXCJDb2xsaXNpb24vQm91bmRpbmdCb3hcIiwgXCJDb2xsaXNpb24vQ2lyY2xlQXJlYVwiLCBcIkNvbGxpc2lvbi9Db2xsaXNpb25Db250YWN0XCIsIFwiQ29sbGlzaW9uL0NvbGxpc2lvbkp1bXBUYWJsZVwiLCBcIkNvbGxpc2lvbi9EeW5hbWljVHJlZVwiLCBcIkNvbGxpc2lvbi9EeW5hbWljVHJlZUNvbGxpc2lvbkJyb2FkcGhhc2VcIiwgXCJDb2xsaXNpb24vRWRnZUFyZWFcIiwgXCJDb2xsaXNpb24vTmFpdmVDb2xsaXNpb25Ccm9hZHBoYXNlXCIsIFwiQ29sbGlzaW9uL1BhaXJcIiwgXCJDb2xsaXNpb24vUG9seWdvbkFyZWFcIiwgXCJDb2xsaXNpb24vU2lkZVwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIEJvZHlfMSwgQm91bmRpbmdCb3hfNiwgQ2lyY2xlQXJlYV80LCBDb2xsaXNpb25Db250YWN0XzMsIENvbGxpc2lvbkp1bXBUYWJsZV80LCBEeW5hbWljVHJlZV8yLCBEeW5hbWljVHJlZUNvbGxpc2lvbkJyb2FkcGhhc2VfMSwgRWRnZUFyZWFfNCwgTmFpdmVDb2xsaXNpb25Ccm9hZHBoYXNlXzEsIFBhaXJfNCwgUG9seWdvbkFyZWFfNiwgU2lkZV8zKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIGZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcclxuICAgICAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICBfX2V4cG9ydChCb2R5XzEpO1xyXG4gICAgX19leHBvcnQoQm91bmRpbmdCb3hfNik7XHJcbiAgICBfX2V4cG9ydChDaXJjbGVBcmVhXzQpO1xyXG4gICAgX19leHBvcnQoQ29sbGlzaW9uQ29udGFjdF8zKTtcclxuICAgIF9fZXhwb3J0KENvbGxpc2lvbkp1bXBUYWJsZV80KTtcclxuICAgIF9fZXhwb3J0KER5bmFtaWNUcmVlXzIpO1xyXG4gICAgX19leHBvcnQoRHluYW1pY1RyZWVDb2xsaXNpb25Ccm9hZHBoYXNlXzEpO1xyXG4gICAgX19leHBvcnQoRWRnZUFyZWFfNCk7XHJcbiAgICBfX2V4cG9ydChOYWl2ZUNvbGxpc2lvbkJyb2FkcGhhc2VfMSk7XHJcbiAgICBfX2V4cG9ydChQYWlyXzQpO1xyXG4gICAgX19leHBvcnQoUG9seWdvbkFyZWFfNik7XHJcbiAgICBfX2V4cG9ydChTaWRlXzMpO1xyXG59KTtcclxuZGVmaW5lKFwiRHJhd2luZy9Qb2x5Z29uXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiQWxnZWJyYVwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIEFsZ2VicmFfMTkpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgY2xvc2VkIHBvbHlnb24gZHJhd2luZyBnaXZlbiBhIGxpc3Qgb2YgW1tWZWN0b3JdXXMuXHJcbiAgICAgKlxyXG4gICAgICogQHdhcm5pbmcgVXNlIHNwYXJpbmdseSBhcyBQb2x5Z29ucyBhcmUgcGVyZm9ybWFuY2UgaW50ZW5zaXZlXHJcbiAgICAgKi9cclxuICAgIHZhciBQb2x5Z29uID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gcG9pbnRzICBUaGUgdmVjdG9ycyB0byB1c2UgdG8gYnVpbGQgdGhlIHBvbHlnb24gaW4gb3JkZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBQb2x5Z29uKHBvaW50cykge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIHdpZHRoIG9mIHRoZSBsaW5lcyBvZiB0aGUgcG9seWdvblxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5saW5lV2lkdGggPSA1O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHBvbHlnb24gaXMgZmlsbGVkIG9yIG5vdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuZmlsbGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3BvaW50cyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLmFuY2hvciA9IG5ldyBBbGdlYnJhXzE5LlZlY3RvcigwLCAwKTtcclxuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbiA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuc2NhbGUgPSBuZXcgQWxnZWJyYV8xOS5WZWN0b3IoMSwgMSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3BvaW50cyA9IHBvaW50cztcclxuICAgICAgICAgICAgdmFyIG1pblggPSB0aGlzLl9wb2ludHMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5taW4ocHJldiwgY3Vyci54KTtcclxuICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgICAgIHZhciBtYXhYID0gdGhpcy5fcG9pbnRzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3Vycikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHByZXYsIGN1cnIueCk7XHJcbiAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gbWF4WCAtIG1pblg7XHJcbiAgICAgICAgICAgIHZhciBtaW5ZID0gdGhpcy5fcG9pbnRzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3Vycikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKHByZXYsIGN1cnIueSk7XHJcbiAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgICAgICB2YXIgbWF4WSA9IHRoaXMuX3BvaW50cy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cnIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChwcmV2LCBjdXJyLnkpO1xyXG4gICAgICAgICAgICB9LCAwKTtcclxuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBtYXhZIC0gbWluWTtcclxuICAgICAgICAgICAgdGhpcy5uYXR1cmFsSGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XHJcbiAgICAgICAgICAgIHRoaXMubmF0dXJhbFdpZHRoID0gdGhpcy53aWR0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG5vdGltcGxlbWVudGVkIEVmZmVjdHMgYXJlIG5vdCBzdXBwb3J0ZWQgb24gYFBvbHlnb25gXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUG9seWdvbi5wcm90b3R5cGUuYWRkRWZmZWN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIG9uIHBvbHlnb25zXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbm90aW1wbGVtZW50ZWQgRWZmZWN0cyBhcmUgbm90IHN1cHBvcnRlZCBvbiBgUG9seWdvbmBcclxuICAgICAgICAgKi9cclxuICAgICAgICBQb2x5Z29uLnByb3RvdHlwZS5yZW1vdmVFZmZlY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgb24gcG9seWdvbnNcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBub3RpbXBsZW1lbnRlZCBFZmZlY3RzIGFyZSBub3Qgc3VwcG9ydGVkIG9uIGBQb2x5Z29uYFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBvbHlnb24ucHJvdG90eXBlLmNsZWFyRWZmZWN0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBvbiBwb2x5Z29uc1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUG9seWdvbi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vcGFzc1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUG9seWdvbi5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjdHgsIHgsIHkpIHtcclxuICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh4ICsgdGhpcy5hbmNob3IueCwgeSArIHRoaXMuYW5jaG9yLnkpO1xyXG4gICAgICAgICAgICBjdHguc2NhbGUodGhpcy5zY2FsZS54LCB0aGlzLnNjYWxlLnkpO1xyXG4gICAgICAgICAgICBjdHgucm90YXRlKHRoaXMucm90YXRpb24pO1xyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmxpbmVXaWR0aDtcclxuICAgICAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSBzdXBwbGllZCBwb2ludHMgYW5kIGNvbnN0cnVjdCBhICdwb2x5Z29uJ1xyXG4gICAgICAgICAgICB2YXIgZmlyc3RQb2ludCA9IHRoaXMuX3BvaW50c1swXTtcclxuICAgICAgICAgICAgY3R4Lm1vdmVUbyhmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSk7XHJcbiAgICAgICAgICAgIHZhciBpID0gMCwgbGVuID0gdGhpcy5fcG9pbnRzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8odGhpcy5fcG9pbnRzW2ldLngsIHRoaXMuX3BvaW50c1tpXS55KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdHgubGluZVRvKGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55KTtcclxuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5maWxsZWQpIHtcclxuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmZpbGxDb2xvci50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmxpbmVDb2xvci50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5mbGlwSG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLndpZHRoLCAwKTtcclxuICAgICAgICAgICAgICAgIGN0eC5zY2FsZSgtMSwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuZmxpcFZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKDAsIHRoaXMuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIGN0eC5zY2FsZSgxLCAtMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFBvbHlnb247XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5Qb2x5Z29uID0gUG9seWdvbjtcclxufSk7XHJcbmRlZmluZShcIkRyYXdpbmcvSW5kZXhcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJEcmF3aW5nL0FuaW1hdGlvblwiLCBcIkRyYXdpbmcvQ29sb3JcIiwgXCJEcmF3aW5nL1BvbHlnb25cIiwgXCJEcmF3aW5nL1Nwcml0ZVwiLCBcIkRyYXdpbmcvU3ByaXRlU2hlZXRcIiwgXCJEcmF3aW5nL1Nwcml0ZUVmZmVjdHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBBbmltYXRpb25fMiwgQ29sb3JfMTcsIFBvbHlnb25fMSwgU3ByaXRlXzMsIFNwcml0ZVNoZWV0XzEsIGVmZmVjdHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIGV4cG9ydHMuQW5pbWF0aW9uID0gQW5pbWF0aW9uXzIuQW5pbWF0aW9uO1xyXG4gICAgX19leHBvcnQoQ29sb3JfMTcpO1xyXG4gICAgX19leHBvcnQoUG9seWdvbl8xKTtcclxuICAgIGV4cG9ydHMuU3ByaXRlID0gU3ByaXRlXzMuU3ByaXRlO1xyXG4gICAgZXhwb3J0cy5TcHJpdGVTaGVldCA9IFNwcml0ZVNoZWV0XzEuU3ByaXRlU2hlZXQ7XHJcbiAgICBleHBvcnRzLlNwcml0ZUZvbnQgPSBTcHJpdGVTaGVldF8xLlNwcml0ZUZvbnQ7XHJcbiAgICBleHBvcnRzLkVmZmVjdHMgPSBlZmZlY3RzO1xyXG59KTtcclxuZGVmaW5lKFwiSW50ZXJmYWNlcy9JbmRleFwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG59KTtcclxuZGVmaW5lKFwiTWF0aC9QZXJsaW5Ob2lzZVwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIk1hdGgvUmFuZG9tXCIsIFwiRHJhd2luZy9Db2xvclwiLCBcIlV0aWwvVXRpbFwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIFJhbmRvbV8zLCBDb2xvcl8xOCwgVXRpbCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICBmdW5jdGlvbiBfbGVycCh0aW1lLCBhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIGEgKyB0aW1lICogKGIgLSBhKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIF9mYWRlKHQpIHtcclxuICAgICAgICByZXR1cm4gdCAqIHQgKiB0ICogKHQgKiAodCAqIDYgLSAxNSkgKyAxMCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyBwZXJsaW4gbm9pc2UgYmFzZWQgb24gdGhlIDIwMDIgU2lnZ3JhcGggcGFwZXIgaHR0cDovL21ybC5ueXUuZWR1L35wZXJsaW4vbm9pc2UvXHJcbiAgICAgKiBBbHNvIGh0dHBzOi8vZmxhZmxhMi5naXRodWIuaW8vMjAxNC8wOC8wOS9wZXJsaW5ub2lzZS5odG1sXHJcbiAgICAgKi9cclxuICAgIHZhciBQZXJsaW5HZW5lcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIFBlcmxpbkdlbmVyYXRvcihvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Blcm0gPSBbMTUxLCAxNjAsIDEzNywgOTEsIDkwLCAxNSwgMTMxLCAxMywgMjAxLCA5NSwgOTYsIDUzLCAxOTQsIDIzMywgNywgMjI1LFxyXG4gICAgICAgICAgICAgICAgMTQwLCAzNiwgMTAzLCAzMCwgNjksIDE0MiwgOCwgOTksIDM3LCAyNDAsIDIxLCAxMCwgMjMsIDE5MCwgNiwgMTQ4LCAyNDcsIDEyMCwgMjM0LCA3NSwgMCwgMjYsXHJcbiAgICAgICAgICAgICAgICAxOTcsIDYyLCA5NCwgMjUyLCAyMTksIDIwMywgMTE3LCAzNSwgMTEsIDMyLCA1NywgMTc3LCAzMywgODgsIDIzNywgMTQ5LCA1NiwgODcsIDE3NCwgMjAsIDEyNSwgMTM2LFxyXG4gICAgICAgICAgICAgICAgMTcxLCAxNjgsIDY4LCAxNzUsIDc0LCAxNjUsIDcxLCAxMzQsIDEzOSwgNDgsIDI3LCAxNjYsIDc3LCAxNDYsIDE1OCwgMjMxLCA4MywgMTExLCAyMjksIDEyMiwgNjAsXHJcbiAgICAgICAgICAgICAgICAyMTEsIDEzMywgMjMwLCAyMjAsIDEwNSwgOTIsIDQxLCA1NSwgNDYsIDI0NSwgNDAsIDI0NCwgMTAyLCAxNDMsIDU0LCA2NSwgMjUsIDYzLCAxNjEsIDEsIDIxNiwgODAsXHJcbiAgICAgICAgICAgICAgICA3MywgMjA5LCA3NiwgMTMyLCAxODcsIDIwOCwgODksIDE4LCAxNjksIDIwMCwgMTk2LCAxMzUsIDEzMCwgMTE2LCAxODgsIDE1OSwgODYsIDE2NCwgMTAwLCAxMDksIDE5OCxcclxuICAgICAgICAgICAgICAgIDE3MywgMTg2LCAzLCA2NCwgNTIsIDIxNywgMjI2LCAyNTAsIDEyNCwgMTIzLCA1LCAyMDIsIDM4LCAxNDcsIDExOCwgMTI2LCAyNTUsIDgyLCA4NSwgMjEyLCAyMDcsIDIwNixcclxuICAgICAgICAgICAgICAgIDU5LCAyMjcsIDQ3LCAxNiwgNTgsIDE3LCAxODIsIDE4OSwgMjgsIDQyLCAyMjMsIDE4MywgMTcwLCAyMTMsIDExOSwgMjQ4LCAxNTIsIDIsIDQ0LCAxNTQsIDE2MywgNzAsXHJcbiAgICAgICAgICAgICAgICAyMjEsIDE1MywgMTAxLCAxNTUsIDE2NywgNDMsIDE3MiwgOSwgMTI5LCAyMiwgMzksIDI1MywgMTksIDk4LCAxMDgsIDExMCwgNzksIDExMywgMjI0LCAyMzIsIDE3OCxcclxuICAgICAgICAgICAgICAgIDE4NSwgMTEyLCAxMDQsIDIxOCwgMjQ2LCA5NywgMjI4LCAyNTEsIDM0LCAyNDIsIDE5MywgMjM4LCAyMTAsIDE0NCwgMTIsIDE5MSwgMTc5LCAxNjIsIDI0MSwgODEsXHJcbiAgICAgICAgICAgICAgICA1MSwgMTQ1LCAyMzUsIDI0OSwgMTQsIDIzOSwgMTA3LCA0OSwgMTkyLCAyMTQsIDMxLCAxODEsIDE5OSwgMTA2LCAxNTcsIDE4NCwgODQsIDIwNCwgMTc2LCAxMTUsXHJcbiAgICAgICAgICAgICAgICAxMjEsIDUwLCA0NSwgMTI3LCA0LCAxNTAsIDI1NCwgMTM4LCAyMzYsIDIwNSwgOTMsIDIyMiwgMTE0LCA2NywgMjksIDI0LCA3MiwgMjQzLCAxNDEsIDEyOCwgMTk1LFxyXG4gICAgICAgICAgICAgICAgNzgsIDY2LCAyMTUsIDYxLCAxNTYsIDE4MF07XHJcbiAgICAgICAgICAgIHRoaXMuX3AgPSBuZXcgVWludDhBcnJheSg1MTIpO1xyXG4gICAgICAgICAgICB0aGlzLl9kZWZhdWx0UGVybGluT3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgIG9jdGF2ZXM6IDEsXHJcbiAgICAgICAgICAgICAgICBmcmVxdWVuY3k6IDEsXHJcbiAgICAgICAgICAgICAgICBhbXBsaXR1ZGU6IDEsXHJcbiAgICAgICAgICAgICAgICBwZXJzaXN0YW5jZTogLjVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgb3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHt9LCB0aGlzLl9kZWZhdWx0UGVybGluT3B0aW9ucywgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIHRoaXMucGVyc2lzdGFuY2UgPSBvcHRpb25zLnBlcnNpc3RhbmNlO1xyXG4gICAgICAgICAgICB0aGlzLmFtcGxpdHVkZSA9IG9wdGlvbnMuYW1wbGl0dWRlO1xyXG4gICAgICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG9wdGlvbnMuZnJlcXVlbmN5O1xyXG4gICAgICAgICAgICB0aGlzLm9jdGF2ZXMgPSBvcHRpb25zLm9jdGF2ZXM7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNlZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JhbmRvbSA9IG5ldyBSYW5kb21fMy5SYW5kb20ob3B0aW9ucy5zZWVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JhbmRvbSA9IG5ldyBSYW5kb21fMy5SYW5kb20oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9wZXJtID0gdGhpcy5fcmFuZG9tLnNodWZmbGUodGhpcy5fcGVybSk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNTEyOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BbaV0gPSB0aGlzLl9wZXJtW2kgJSAyNTZdICYgMHhGRjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBQZXJsaW5HZW5lcmF0b3IucHJvdG90eXBlLm5vaXNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYW1wID0gdGhpcy5hbXBsaXR1ZGU7XHJcbiAgICAgICAgICAgIHZhciBmcmVxID0gdGhpcy5mcmVxdWVuY3k7XHJcbiAgICAgICAgICAgIHZhciB0b3RhbCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBtYXhWYWx1ZSA9IDA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vY3RhdmVzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWwgKz0gdGhpcy5fbm9pc2UxZChhcmd1bWVudHNbMF0gKiBmcmVxKSAqIGFtcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbCArPSB0aGlzLl9ub2lzZTJkKGFyZ3VtZW50c1swXSAqIGZyZXEsIGFyZ3VtZW50c1sxXSAqIGZyZXEpICogYW1wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsICs9IHRoaXMuX25vaXNlM2QoYXJndW1lbnRzWzBdICogZnJlcSwgYXJndW1lbnRzWzFdICogZnJlcSwgYXJndW1lbnRzWzJdICogZnJlcSkgKiBhbXA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cyBmb3IgcGVybGluIG5vaXNlJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBtYXhWYWx1ZSArPSBhbXA7XHJcbiAgICAgICAgICAgICAgICBhbXAgKj0gdGhpcy5wZXJzaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGZyZXEgKj0gMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdG90YWwgLyBtYXhWYWx1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdlbmVyYXRlcyBhIGxpc3Qgc3RhcnRpbmcgYXQgMCBhbmQgZW5kaW5nIGF0IDEgb2YgY29udGlvdXMgcGVybGluIG5vaXNlLCBieSBkZWZhdWx0IHRoZSBzdGVwIGlzIDEvbGVuZ3RoO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUGVybGluR2VuZXJhdG9yLnByb3RvdHlwZS5zZXF1ZW5jZSA9IGZ1bmN0aW9uIChsZW5ndGgsIHN0ZXApIHtcclxuICAgICAgICAgICAgaWYgKCFzdGVwKSB7XHJcbiAgICAgICAgICAgICAgICBzdGVwID0gMSAvIGxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYXJyYXkgPSBuZXcgQXJyYXkobGVuZ3RoKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSB0aGlzLm5vaXNlKGkgKiBzdGVwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYXJyYXk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZW5lcmF0ZXMgYSAyRCBncmlkIG9mIHBlcmxpbiBub2lzZSBnaXZlbiBhIHN0ZXAgdmFsdWUgcGFja2VkIGludG8gYSAxRCBhcnJheSBpID0gKHggKyB5KndpZHRoKSxcclxuICAgICAgICAgKiBieSBkZWZhdWx0IHRoZSBzdGVwIHdpbGwgMS8obWluKGRpbWVuc2lvbikpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUGVybGluR2VuZXJhdG9yLnByb3RvdHlwZS5ncmlkID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQsIHN0ZXApIHtcclxuICAgICAgICAgICAgaWYgKCFzdGVwKSB7XHJcbiAgICAgICAgICAgICAgICBzdGVwID0gMSAvIChNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGFycmF5ID0gbmV3IEFycmF5KHdpZHRoICogaGVpZ2h0KTtcclxuICAgICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbeCArIHkgKiB3aWR0aF0gPSB0aGlzLm5vaXNlKHggKiBzdGVwLCB5ICogc3RlcCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUGVybGluR2VuZXJhdG9yLnByb3RvdHlwZS5fZ3JhZGllbnQzZCA9IGZ1bmN0aW9uIChoYXNoLCB4LCB5LCB6KSB7XHJcbiAgICAgICAgICAgIHZhciBoID0gaGFzaCAmIDB4RjtcclxuICAgICAgICAgICAgdmFyIHUgPSBoIDwgOCA/IHggOiB5O1xyXG4gICAgICAgICAgICB2YXIgdiA9IGggPCA0ID8geSA6ICgoaCA9PT0gMTIgfHwgaCA9PT0gMTQpID8geCA6IHopO1xyXG4gICAgICAgICAgICByZXR1cm4gKChoICYgMSkgPT09IDAgPyB1IDogLXUpICsgKChoICYgMikgPT09IDAgPyB2IDogLXYpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUGVybGluR2VuZXJhdG9yLnByb3RvdHlwZS5fZ3JhZGllbnQyZCA9IGZ1bmN0aW9uIChoYXNoLCB4LCB5KSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IChoYXNoICYgMSkgPT09IDAgPyB4IDogeTtcclxuICAgICAgICAgICAgcmV0dXJuIChoYXNoICYgMikgPT09IDAgPyAtdmFsdWUgOiB2YWx1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFBlcmxpbkdlbmVyYXRvci5wcm90b3R5cGUuX2dyYWRpZW50MWQgPSBmdW5jdGlvbiAoaGFzaCwgeCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKGhhc2ggJiAxKSA9PT0gMCA/IC14IDogeDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFBlcmxpbkdlbmVyYXRvci5wcm90b3R5cGUuX25vaXNlMWQgPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICB2YXIgaW50WCA9IE1hdGguZmxvb3IoeCkgJiAweEZGOyAvLyBmb3JjZSAwLTI1NSBpbnRlZ2VycyB0byBsb29rdXAgaW4gcGVybXV0YXRpb25cclxuICAgICAgICAgICAgeCAtPSBNYXRoLmZsb29yKHgpO1xyXG4gICAgICAgICAgICB2YXIgZmFkZVggPSBfZmFkZSh4KTtcclxuICAgICAgICAgICAgcmV0dXJuIChfbGVycChmYWRlWCwgdGhpcy5fZ3JhZGllbnQxZCh0aGlzLl9wW2ludFhdLCB4KSwgdGhpcy5fZ3JhZGllbnQxZCh0aGlzLl9wW2ludFggKyAxXSwgeCAtIDEpKSArIDEpIC8gMjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFBlcmxpbkdlbmVyYXRvci5wcm90b3R5cGUuX25vaXNlMmQgPSBmdW5jdGlvbiAoeCwgeSkge1xyXG4gICAgICAgICAgICB2YXIgaW50WCA9IE1hdGguZmxvb3IoeCkgJiAweEZGO1xyXG4gICAgICAgICAgICB2YXIgaW50WSA9IE1hdGguZmxvb3IoeSkgJiAweEZGO1xyXG4gICAgICAgICAgICB4IC09IE1hdGguZmxvb3IoeCk7XHJcbiAgICAgICAgICAgIHkgLT0gTWF0aC5mbG9vcih5KTtcclxuICAgICAgICAgICAgdmFyIGZhZGVYID0gX2ZhZGUoeCk7XHJcbiAgICAgICAgICAgIHZhciBmYWRlWSA9IF9mYWRlKHkpO1xyXG4gICAgICAgICAgICB2YXIgYSA9IHRoaXMuX3BbaW50WF0gKyBpbnRZO1xyXG4gICAgICAgICAgICB2YXIgYiA9IHRoaXMuX3BbaW50WCArIDFdICsgaW50WTtcclxuICAgICAgICAgICAgcmV0dXJuIChfbGVycChmYWRlWSwgX2xlcnAoZmFkZVgsIHRoaXMuX2dyYWRpZW50MmQodGhpcy5fcFthXSwgeCwgeSksIHRoaXMuX2dyYWRpZW50MmQodGhpcy5fcFtiXSwgeCAtIDEsIHkpKSwgX2xlcnAoZmFkZVgsIHRoaXMuX2dyYWRpZW50MmQodGhpcy5fcFthICsgMV0sIHgsIHkgLSAxKSwgdGhpcy5fZ3JhZGllbnQyZCh0aGlzLl9wW2IgKyAxXSwgeCAtIDEsIHkgLSAxKSkpICsgMSkgLyAyO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUGVybGluR2VuZXJhdG9yLnByb3RvdHlwZS5fbm9pc2UzZCA9IGZ1bmN0aW9uICh4LCB5LCB6KSB7XHJcbiAgICAgICAgICAgIHZhciBpbnRYID0gTWF0aC5mbG9vcih4KSAmIDB4RkY7XHJcbiAgICAgICAgICAgIHZhciBpbnRZID0gTWF0aC5mbG9vcih5KSAmIDB4RkY7XHJcbiAgICAgICAgICAgIHZhciBpbnRaID0gTWF0aC5mbG9vcih6KSAmIDB4RkY7XHJcbiAgICAgICAgICAgIHggLT0gTWF0aC5mbG9vcih4KTtcclxuICAgICAgICAgICAgeSAtPSBNYXRoLmZsb29yKHkpO1xyXG4gICAgICAgICAgICB6IC09IE1hdGguZmxvb3Ioeik7XHJcbiAgICAgICAgICAgIHZhciBmYWRlWCA9IF9mYWRlKHgpO1xyXG4gICAgICAgICAgICB2YXIgZmFkZVkgPSBfZmFkZSh5KTtcclxuICAgICAgICAgICAgdmFyIGZhZGVaID0gX2ZhZGUoeik7XHJcbiAgICAgICAgICAgIHZhciBhID0gdGhpcy5fcFtpbnRYXSArIGludFk7XHJcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy5fcFtpbnRYICsgMV0gKyBpbnRZO1xyXG4gICAgICAgICAgICB2YXIgYWEgPSB0aGlzLl9wW2FdICsgaW50WjtcclxuICAgICAgICAgICAgdmFyIGJhID0gdGhpcy5fcFtiXSArIGludFo7XHJcbiAgICAgICAgICAgIHZhciBhYiA9IHRoaXMuX3BbYSArIDFdICsgaW50WjtcclxuICAgICAgICAgICAgdmFyIGJiID0gdGhpcy5fcFtiICsgMV0gKyBpbnRaO1xyXG4gICAgICAgICAgICByZXR1cm4gKF9sZXJwKGZhZGVaLCBfbGVycChmYWRlWSwgX2xlcnAoZmFkZVgsIHRoaXMuX2dyYWRpZW50M2QodGhpcy5fcFthYV0sIHgsIHksIHopLCB0aGlzLl9ncmFkaWVudDNkKHRoaXMuX3BbYmFdLCB4IC0gMSwgeSwgeikpLCBfbGVycChmYWRlWCwgdGhpcy5fZ3JhZGllbnQzZCh0aGlzLl9wW2FiXSwgeCwgeSAtIDEsIHopLCB0aGlzLl9ncmFkaWVudDNkKHRoaXMuX3BbYmJdLCB4IC0gMSwgeSAtIDEsIHopKSksIF9sZXJwKGZhZGVZLCBfbGVycChmYWRlWCwgdGhpcy5fZ3JhZGllbnQzZCh0aGlzLl9wW2FhICsgMV0sIHgsIHksIHogLSAxKSwgdGhpcy5fZ3JhZGllbnQzZCh0aGlzLl9wW2JhICsgMV0sIHggLSAxLCB5LCB6IC0gMSkpLCBfbGVycChmYWRlWCwgdGhpcy5fZ3JhZGllbnQzZCh0aGlzLl9wW2FiICsgMV0sIHgsIHkgLSAxLCB6IC0gMSksIHRoaXMuX2dyYWRpZW50M2QodGhpcy5fcFtiYiArIDFdLCB4IC0gMSwgeSAtIDEsIHogLSAxKSkpKSArIDEpIC8gMjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBQZXJsaW5HZW5lcmF0b3I7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5QZXJsaW5HZW5lcmF0b3IgPSBQZXJsaW5HZW5lcmF0b3I7XHJcbiAgICAvKipcclxuICAgICAqIEEgaGVscGVyIHRvIGRyYXcgMkQgcGVybGluIG1hcHMgZ2l2ZW4gYSBwZXJsaW4gZ2VuZXJhdG9yIGFuZCBhIGZ1bmN0aW9uXHJcbiAgICAgKi9cclxuICAgIHZhciBQZXJsaW5EcmF3ZXIyRCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIGdlbmVyYXRvciAtIEFuIGV4aXN0aW5nIHBlcmxpbiBnZW5lcmF0b3JcclxuICAgICAgICAgKiBAcGFyYW0gY29sb3JGY24gLSBBIGNvbG9yIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSB2YWx1ZSBiZXR3ZWVuIFswLCAyNTVdIGRlcml2ZWQgZnJvbSB0aGUgcGVybGluIGdlbmVyYXRvciwgYW5kIHJldHVybnMgYSBjb2xvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIFBlcmxpbkRyYXdlcjJEKGdlbmVyYXRvciwgY29sb3JGY24pIHtcclxuICAgICAgICAgICAgdGhpcy5nZW5lcmF0b3IgPSBnZW5lcmF0b3I7XHJcbiAgICAgICAgICAgIHRoaXMuY29sb3JGY24gPSBjb2xvckZjbjtcclxuICAgICAgICAgICAgaWYgKCFjb2xvckZjbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb2xvckZjbiA9IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHZhbCA8IDEyNSA/IENvbG9yXzE4LkNvbG9yLkJsYWNrIDogQ29sb3JfMTguQ29sb3IuV2hpdGU7IH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhbiBpbWFnZSBvZiAyRCBwZXJsaW4gbm9pc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBQZXJsaW5EcmF3ZXIyRC5wcm90b3R5cGUuaW1hZ2UgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgICAgICB2YXIgaW1hZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcclxuICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgICAgICB0aGlzLmRyYXcoY3R4LCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICAgICAgaW1hZ2Uuc3JjID0gY2FudmFzLnRvRGF0YVVSTCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gaW1hZ2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIGRyYXdzIGEgMkQgcGVybGluIGdyaWQgb24gYSBjYW52YXMgY29udGV4dCwgbm90IHJlY29tbWVuZGVkIHRvIGJlIGNhbGxlZCBldmVyeSBmcmFtZSBkdWUgdG8gcGVyZm9ybWFuY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBQZXJsaW5EcmF3ZXIyRC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICAgICAgdmFyIGdyaWQgPSB0aGlzLmdlbmVyYXRvci5ncmlkKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICB2YXIgaW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBoZWlnaHQ7IGorKykge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3aWR0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IGdyaWRbaSArIHdpZHRoICogal07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBNYXRoLmZsb29yKHZhbCAqIDI1NSkgJiAweGZmO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwaXhlbCA9IChpICsgaiAqIGltYWdlRGF0YS53aWR0aCkgKiA0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IHRoaXMuY29sb3JGY24oYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VEYXRhLmRhdGFbcGl4ZWxdID0gY29sb3IucjtcclxuICAgICAgICAgICAgICAgICAgICBpbWFnZURhdGEuZGF0YVtwaXhlbCArIDFdID0gY29sb3IuZztcclxuICAgICAgICAgICAgICAgICAgICBpbWFnZURhdGEuZGF0YVtwaXhlbCArIDJdID0gY29sb3IuYjtcclxuICAgICAgICAgICAgICAgICAgICBpbWFnZURhdGEuZGF0YVtwaXhlbCArIDNdID0gTWF0aC5mbG9vcihjb2xvci5hICogMjU1KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdHgucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgeCwgeSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gUGVybGluRHJhd2VyMkQ7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5QZXJsaW5EcmF3ZXIyRCA9IFBlcmxpbkRyYXdlcjJEO1xyXG59KTtcclxuZGVmaW5lKFwiTWF0aC9JbmRleFwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIk1hdGgvUGVybGluTm9pc2VcIiwgXCJNYXRoL1JhbmRvbVwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIFBlcmxpbk5vaXNlXzEsIFJhbmRvbV80KSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIGZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcclxuICAgICAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICBfX2V4cG9ydChQZXJsaW5Ob2lzZV8xKTtcclxuICAgIF9fZXhwb3J0KFJhbmRvbV80KTtcclxufSk7XHJcbmRlZmluZShcIlBvc3RQcm9jZXNzaW5nL0lQb3N0UHJvY2Vzc29yXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbn0pO1xyXG5kZWZpbmUoXCJQb3N0UHJvY2Vzc2luZy9Db2xvckJsaW5kQ29ycmVjdG9yXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiVXRpbC9Mb2dcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBMb2dfMTApIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgdmFyIENvbG9yQmxpbmRuZXNzO1xyXG4gICAgKGZ1bmN0aW9uIChDb2xvckJsaW5kbmVzcykge1xyXG4gICAgICAgIENvbG9yQmxpbmRuZXNzW0NvbG9yQmxpbmRuZXNzW1wiUHJvdGFub3BlXCJdID0gMF0gPSBcIlByb3Rhbm9wZVwiO1xyXG4gICAgICAgIENvbG9yQmxpbmRuZXNzW0NvbG9yQmxpbmRuZXNzW1wiRGV1dGVyYW5vcGVcIl0gPSAxXSA9IFwiRGV1dGVyYW5vcGVcIjtcclxuICAgICAgICBDb2xvckJsaW5kbmVzc1tDb2xvckJsaW5kbmVzc1tcIlRyaXRhbm9wZVwiXSA9IDJdID0gXCJUcml0YW5vcGVcIjtcclxuICAgIH0pKENvbG9yQmxpbmRuZXNzID0gZXhwb3J0cy5Db2xvckJsaW5kbmVzcyB8fCAoZXhwb3J0cy5Db2xvckJsaW5kbmVzcyA9IHt9KSk7XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgcG9zdCBwcm9jZXNzb3IgY2FuIGNvcnJlY3QgY29sb3JzIGFuZCBzaW11bGF0ZSBjb2xvciBibGluZG5lc3MuXHJcbiAgICAgKiBJdCBpcyBwb3NzaWJsZSB0byB1c2UgdGhpcyBvbiBldmVyeSBnYW1lLCBidXQgdGhlIGdhbWUncyBwZXJmb3JtYW5jZVxyXG4gICAgICogd2lsbCBzdWZmZXIgbWVhc3VyYWJseS4gSXQncyBiZXR0ZXIgdG8gdXNlIGl0IGFzIGEgaGVscGZ1bCB0b29sIHdoaWxlIGRldmVsb3BpbmcgeW91ciBnYW1lLlxyXG4gICAgICogUmVtZW1iZXIsIHRoZSBiZXN0IHByYWN0aWNlIGlzIHRvIGRlc2lnbiB3aXRoIGNvbG9yIGJsaW5kbmVzcyBpbiBtaW5kLlxyXG4gICAgICpcclxuICAgICAqIFtbaW5jbHVkZTpDb2xvckJsaW5kLm1kXV1cclxuICAgICAqL1xyXG4gICAgdmFyIENvbG9yQmxpbmRDb3JyZWN0b3IgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIENvbG9yQmxpbmRDb3JyZWN0b3IoZW5naW5lLCBzaW11bGF0ZSwgY29sb3JNb2RlKSB7XHJcbiAgICAgICAgICAgIGlmIChzaW11bGF0ZSA9PT0gdm9pZCAwKSB7IHNpbXVsYXRlID0gZmFsc2U7IH1cclxuICAgICAgICAgICAgaWYgKGNvbG9yTW9kZSA9PT0gdm9pZCAwKSB7IGNvbG9yTW9kZSA9IENvbG9yQmxpbmRuZXNzLlByb3Rhbm9wZTsgfVxyXG4gICAgICAgICAgICB0aGlzLmVuZ2luZSA9IGVuZ2luZTtcclxuICAgICAgICAgICAgdGhpcy5zaW11bGF0ZSA9IHNpbXVsYXRlO1xyXG4gICAgICAgICAgICB0aGlzLmNvbG9yTW9kZSA9IGNvbG9yTW9kZTtcclxuICAgICAgICAgICAgdGhpcy5fdmVydGV4U2hhZGVyID0gJ2F0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb247JyArXHJcbiAgICAgICAgICAgICAgICAnYXR0cmlidXRlIHZlYzIgYV90ZXhDb29yZDsnICtcclxuICAgICAgICAgICAgICAgICd1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uOycgK1xyXG4gICAgICAgICAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2X3RleENvb3JkOycgK1xyXG4gICAgICAgICAgICAgICAgJ3ZvaWQgbWFpbigpIHsnICtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgdGhlIHJlY3RhbmdsZSBmcm9tIHBpeGVscyB0byAwLjAgdG8gMS4wXHJcbiAgICAgICAgICAgICAgICAndmVjMiB6ZXJvVG9PbmUgPSBhX3Bvc2l0aW9uIC8gdV9yZXNvbHV0aW9uOycgK1xyXG4gICAgICAgICAgICAgICAgLy8gY29udmVydCBmcm9tIDAtPjEgdG8gMC0+MlxyXG4gICAgICAgICAgICAgICAgJ3ZlYzIgemVyb1RvVHdvID0gemVyb1RvT25lICogMi4wOycgK1xyXG4gICAgICAgICAgICAgICAgLy8gY29udmVydCBmcm9tIDAtPjIgdG8gLTEtPisxIChjbGlwc3BhY2UpXHJcbiAgICAgICAgICAgICAgICAndmVjMiBjbGlwU3BhY2UgPSB6ZXJvVG9Ud28gLSAxLjA7JyArXHJcbiAgICAgICAgICAgICAgICAnZ2xfUG9zaXRpb24gPSB2ZWM0KGNsaXBTcGFjZSAqIHZlYzIoMSwgLTEpLCAwLCAxKTsnICtcclxuICAgICAgICAgICAgICAgIC8vIHBhc3MgdGhlIHRleENvb3JkIHRvIHRoZSBmcmFnbWVudCBzaGFkZXJcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBHUFUgd2lsbCBpbnRlcnBvbGF0ZSB0aGlzIHZhbHVlIGJldHdlZW4gcG9pbnRzLlxyXG4gICAgICAgICAgICAgICAgJ3ZfdGV4Q29vcmQgPSBhX3RleENvb3JkOycgK1xyXG4gICAgICAgICAgICAgICAgJ30nO1xyXG4gICAgICAgICAgICB0aGlzLl9mcmFnbWVudFNoYWRlciA9ICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnICtcclxuICAgICAgICAgICAgICAgIC8vIG91ciB0ZXh0dXJlXHJcbiAgICAgICAgICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTsnICtcclxuICAgICAgICAgICAgICAgIC8vIHRoZSB0ZXhDb29yZHMgcGFzc2VkIGluIGZyb20gdGhlIHZlcnRleCBzaGFkZXIuXHJcbiAgICAgICAgICAgICAgICAndmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7JyArXHJcbiAgICAgICAgICAgICAgICAvLyBDb2xvciBibGluZCBjb252ZXJzaW9uc1xyXG4gICAgICAgICAgICAgICAgLyonbWF0MyBtWzldID0nICtcclxuICAgICAgICAgICAgICAgICd7JyArXHJcbiAgICAgICAgICAgICAgICAgICAnbWF0MygxLjAsIDAuMCwgMC4wLCAgMC4wLCAxLjAsIDAuMCwgIDAuMCwgMC4wLCAxLjAgICksJyArIC8vIG5vcm1hbFxyXG4gICAgICAgICAgICAgICAgICAgJ21hdDMoMC41NjcsIDAuNDMzLCAwLjAsICAwLjU1OCwgMC40NDIsIDAuMCwgIDAuMCwgMC4yNDIsIDAuNzU4KSwnICsgLy8gcHJvdGFub3BpYVxyXG4gICAgICAgICAgICAgICAgICAgJ21hdDMoMC44MTcsIDAuMTgzLCAwLjAsICAwLjMzMywgMC42NjcsIDAuMCwgIDAuMCwgMC4xMjUsMC44NzUpLCcgKyAvLyBwcm90YW5vbWFseVxyXG4gICAgICAgICAgICAgICAgICAgJ21hdDMoMC42MjUsIDAuMzc1LCAwLjAsICAwLjcsIDAuMywgMC4wLCAgMC4wLCAwLjMsMC43ICApLCcgKyAvLyBkZXV0ZXJhbm9waWFcclxuICAgICAgICAgICAgICAgICAgICdtYXQzKDAuOCwgMC4yLCAwLjAsICAwLjI1OCwgMC43NDIsIDAuMCwgIDAuMCwgMC4xNDIsMC44NTgpLCcgKyAvLyBkZXV0ZXJhbm9tYWx5XHJcbiAgICAgICAgICAgICAgICAgICAnbWF0MygwLjk1LCAwLjA1LCAwLjAsICAwLjAsIDAuNDMzLCAwLjU2NywgIDAuMCwgMC40NzUsMC41MjUpLCcgKyAvLyB0cml0YW5vcGlhXHJcbiAgICAgICAgICAgICAgICAgICAnbWF0MygwLjk2NywgMC4wMzMsIDAuMCwgIDAuMCwgMC43MzMsIDAuMjY3LCAgMC4wLCAwLjE4MywwLjgxNyksJyArIC8vIHRyaXRhbm9tYWx5XHJcbiAgICAgICAgICAgICAgICAgICAnbWF0MygwLjI5OSwgMC41ODcsIDAuMTE0LCAgMC4yOTksIDAuNTg3LCAwLjExNCwgIDAuMjk5LCAwLjU4NywwLjExNCksJyArIC8vIGFjaHJvbWF0b3BzaWFcclxuICAgICAgICAgICAgICAgICAgICdtYXQzKDAuNjE4LCAwLjMyMCwgMC4wNjIsICAwLjE2MywgMC43NzUsIDAuMDYyLCAgMC4xNjMsIDAuMzIwLDAuNTE2KScgKyAgLy8gYWNocm9tYXRvbWFseVxyXG4gICAgICAgICAgICAgICAgJ307JyArKi9cclxuICAgICAgICAgICAgICAgICd2b2lkIG1haW4oKSB7JyArXHJcbiAgICAgICAgICAgICAgICAndmVjNCBvID0gIHRleHR1cmUyRCh1X2ltYWdlLCB2X3RleENvb3JkKTsnICtcclxuICAgICAgICAgICAgICAgIC8vIFJHQiB0byBMTVMgbWF0cml4IGNvbnZlcnNpb25cclxuICAgICAgICAgICAgICAgICdmbG9hdCBMID0gKDE3Ljg4MjQgKiBvLnIpICsgKDQzLjUxNjEgKiBvLmcpICsgKDQuMTE5MzUgKiBvLmIpOycgK1xyXG4gICAgICAgICAgICAgICAgJ2Zsb2F0IE0gPSAoMy40NTU2NSAqIG8ucikgKyAoMjcuMTU1NCAqIG8uZykgKyAoMy44NjcxNCAqIG8uYik7JyArXHJcbiAgICAgICAgICAgICAgICAnZmxvYXQgUyA9ICgwLjAyOTk1NjYgKiBvLnIpICsgKDAuMTg0MzA5ICogby5nKSArICgxLjQ2NzA5ICogby5iKTsnICtcclxuICAgICAgICAgICAgICAgIC8vIFNpbXVsYXRlIGNvbG9yIGJsaW5kbmVzc1xyXG4gICAgICAgICAgICAgICAgJy8vTU9ERSBDT0RFLy8nICtcclxuICAgICAgICAgICAgICAgIC8qIERldXRlcmFub3BlIGZvciB0ZXN0aW5nXHJcbiAgICAgICAgICAgICAgICAnZmxvYXQgbCA9IDEuMCAqIEwgKyAwLjAgKiBNICsgMC4wICogUzsnICtcclxuICAgICAgICAgICAgICAgICAgICAgICdmbG9hdCBtID0gMC40OTQyMDcgKiBMICsgMC4wICogTSArIDEuMjQ4MjcgKiBTOycgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgJ2Zsb2F0IHMgPSAwLjAgKiBMICsgMC4wICogTSArIDEuMCAqIFM7JyArKi9cclxuICAgICAgICAgICAgICAgIC8vIExNUyB0byBSR0IgbWF0cml4IGNvbnZlcnNpb25cclxuICAgICAgICAgICAgICAgICd2ZWM0IGVycm9yOycgK1xyXG4gICAgICAgICAgICAgICAgJ2Vycm9yLnIgPSAoMC4wODA5NDQ0NDc5ICogbCkgKyAoLTAuMTMwNTA0NDA5ICogbSkgKyAoMC4xMTY3MjEwNjYgKiBzKTsnICtcclxuICAgICAgICAgICAgICAgICdlcnJvci5nID0gKC0wLjAxMDI0ODUzMzUgKiBsKSArICgwLjA1NDAxOTMyNjYgKiBtKSArICgtMC4xMTM2MTQ3MDggKiBzKTsnICtcclxuICAgICAgICAgICAgICAgICdlcnJvci5iID0gKC0wLjAwMDM2NTI5NjkzOCAqIGwpICsgKC0wLjAwNDEyMTYxNDY5ICogbSkgKyAoMC42OTM1MTE0MDUgKiBzKTsnICtcclxuICAgICAgICAgICAgICAgICdlcnJvci5hID0gMS4wOycgK1xyXG4gICAgICAgICAgICAgICAgJ3ZlYzQgZGlmZiA9IG8gLSBlcnJvcjsnICtcclxuICAgICAgICAgICAgICAgICd2ZWM0IGNvcnJlY3Rpb247JyArXHJcbiAgICAgICAgICAgICAgICAnY29ycmVjdGlvbi5yID0gMC4wOycgK1xyXG4gICAgICAgICAgICAgICAgJ2NvcnJlY3Rpb24uZyA9ICAoZGlmZi5yICogMC43KSArIChkaWZmLmcgKiAxLjApOycgK1xyXG4gICAgICAgICAgICAgICAgJ2NvcnJlY3Rpb24uYiA9ICAoZGlmZi5yICogMC43KSArIChkaWZmLmIgKiAxLjApOycgK1xyXG4gICAgICAgICAgICAgICAgJ2NvcnJlY3Rpb24gPSBvICsgY29ycmVjdGlvbjsnICtcclxuICAgICAgICAgICAgICAgICdjb3JyZWN0aW9uLmEgPSBvLmE7JyArXHJcbiAgICAgICAgICAgICAgICAnLy9TSU1VTEFURS8vJyArXHJcbiAgICAgICAgICAgICAgICAnfSc7XHJcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsQ2FudmFzLndpZHRoID0gZW5naW5lLmRyYXdXaWR0aDtcclxuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxDYW52YXMuaGVpZ2h0ID0gZW5naW5lLmRyYXdIZWlnaHQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsID0gdGhpcy5faW50ZXJuYWxDYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCB7IHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgdGhpcy5fcHJvZ3JhbSA9IHRoaXMuX2dsLmNyZWF0ZVByb2dyYW0oKTtcclxuICAgICAgICAgICAgdmFyIGZyYWdtZW50U2hhZGVyID0gdGhpcy5fZ2V0U2hhZGVyKCdGcmFnbWVudCcsIHRoaXMuX2dldEZyYWdtZW50U2hhZGVyQnlNb2RlKGNvbG9yTW9kZSkpO1xyXG4gICAgICAgICAgICB2YXIgdmVydGV4dFNoYWRlciA9IHRoaXMuX2dldFNoYWRlcignVmVydGV4JywgdGhpcy5fdmVydGV4U2hhZGVyKTtcclxuICAgICAgICAgICAgdGhpcy5fZ2wuYXR0YWNoU2hhZGVyKHRoaXMuX3Byb2dyYW0sIHZlcnRleHRTaGFkZXIpO1xyXG4gICAgICAgICAgICB0aGlzLl9nbC5hdHRhY2hTaGFkZXIodGhpcy5fcHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xyXG4gICAgICAgICAgICB0aGlzLl9nbC5saW5rUHJvZ3JhbSh0aGlzLl9wcm9ncmFtKTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9nbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHRoaXMuX3Byb2dyYW0sIHRoaXMuX2dsLkxJTktfU1RBVFVTKSkge1xyXG4gICAgICAgICAgICAgICAgTG9nXzEwLkxvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKCdVbmFibGUgdG8gbGluayBzaGFkZXIgcHJvZ3JhbSEnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9nbC51c2VQcm9ncmFtKHRoaXMuX3Byb2dyYW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBDb2xvckJsaW5kQ29ycmVjdG9yLnByb3RvdHlwZS5fZ2V0RnJhZ21lbnRTaGFkZXJCeU1vZGUgPSBmdW5jdGlvbiAoY29sb3JNb2RlKSB7XHJcbiAgICAgICAgICAgIHZhciBjb2RlID0gJyc7XHJcbiAgICAgICAgICAgIGlmIChjb2xvck1vZGUgPT09IENvbG9yQmxpbmRuZXNzLlByb3Rhbm9wZSkge1xyXG4gICAgICAgICAgICAgICAgY29kZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgJ2Zsb2F0IGwgPSAwLjAgKiBMICsgMi4wMjM0NCAqIE0gKyAtMi41MjU4MSAqIFM7JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdmbG9hdCBtID0gMC4wICogTCArIDEuMCAqIE0gKyAwLjAgKiBTOycgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmxvYXQgcyA9IDAuMCAqIEwgKyAwLjAgKiBNICsgMS4wICogUzsnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbG9yTW9kZSA9PT0gQ29sb3JCbGluZG5lc3MuRGV1dGVyYW5vcGUpIHtcclxuICAgICAgICAgICAgICAgIGNvZGUgPVxyXG4gICAgICAgICAgICAgICAgICAgICdmbG9hdCBsID0gMS4wICogTCArIDAuMCAqIE0gKyAwLjAgKiBTOycgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmxvYXQgbSA9IDAuNDk0MjA3ICogTCArIDAuMCAqIE0gKyAxLjI0ODI3ICogUzsnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Zsb2F0IHMgPSAwLjAgKiBMICsgMC4wICogTSArIDEuMCAqIFM7JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjb2xvck1vZGUgPT09IENvbG9yQmxpbmRuZXNzLlRyaXRhbm9wZSkge1xyXG4gICAgICAgICAgICAgICAgY29kZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgJ2Zsb2F0IGwgPSAxLjAgKiBMICsgMC4wICogTSArIDAuMCAqIFM7JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdmbG9hdCBtID0gMC4wICogTCArIDEuMCAqIE0gKyAwLjAgKiBTOycgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmxvYXQgcyA9IC0wLjM5NTkxMyAqIEwgKyAwLjgwMTEwOSAqIE0gKyAwLjAgKiBTOyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuc2ltdWxhdGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZyYWdtZW50U2hhZGVyID0gdGhpcy5fZnJhZ21lbnRTaGFkZXIucmVwbGFjZSgnLy9TSU1VTEFURS8vJywgJ2dsX0ZyYWdDb2xvciA9IGVycm9yLnJnYmE7Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mcmFnbWVudFNoYWRlciA9IHRoaXMuX2ZyYWdtZW50U2hhZGVyLnJlcGxhY2UoJy8vU0lNVUxBVEUvLycsICdnbF9GcmFnQ29sb3IgPSBjb3JyZWN0aW9uLnJnYmE7Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZyYWdtZW50U2hhZGVyLnJlcGxhY2UoJy8vTU9ERSBDT0RFLy8nLCBjb2RlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIENvbG9yQmxpbmRDb3JyZWN0b3IucHJvdG90eXBlLl9zZXRSZWN0YW5nbGUgPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgICAgICB2YXIgeDEgPSB4O1xyXG4gICAgICAgICAgICB2YXIgeDIgPSB4ICsgd2lkdGg7XHJcbiAgICAgICAgICAgIHZhciB5MSA9IHk7XHJcbiAgICAgICAgICAgIHZhciB5MiA9IHkgKyBoZWlnaHQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLmJ1ZmZlckRhdGEodGhpcy5fZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KFtcclxuICAgICAgICAgICAgICAgIHgxLCB5MSxcclxuICAgICAgICAgICAgICAgIHgyLCB5MSxcclxuICAgICAgICAgICAgICAgIHgxLCB5MixcclxuICAgICAgICAgICAgICAgIHgxLCB5MixcclxuICAgICAgICAgICAgICAgIHgyLCB5MSxcclxuICAgICAgICAgICAgICAgIHgyLCB5MlxyXG4gICAgICAgICAgICBdKSwgdGhpcy5fZ2wuU1RBVElDX0RSQVcpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQ29sb3JCbGluZENvcnJlY3Rvci5wcm90b3R5cGUuX2dldFNoYWRlciA9IGZ1bmN0aW9uICh0eXBlLCBwcm9ncmFtKSB7XHJcbiAgICAgICAgICAgIHZhciBzaGFkZXI7XHJcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnRnJhZ21lbnQnKSB7XHJcbiAgICAgICAgICAgICAgICBzaGFkZXIgPSB0aGlzLl9nbC5jcmVhdGVTaGFkZXIodGhpcy5fZ2wuRlJBR01FTlRfU0hBREVSKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnVmVydGV4Jykge1xyXG4gICAgICAgICAgICAgICAgc2hhZGVyID0gdGhpcy5fZ2wuY3JlYXRlU2hhZGVyKHRoaXMuX2dsLlZFUlRFWF9TSEFERVIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgTG9nXzEwLkxvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKCdFcnJvciB1bmtub3duIHNoYWRlciB0eXBlJywgdHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgcHJvZ3JhbSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9nbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCB0aGlzLl9nbC5DT01QSUxFX1NUQVRVUykpIHtcclxuICAgICAgICAgICAgICAgIExvZ18xMC5Mb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcignVW5hYmxlIHRvIGNvbXBpbGUgc2hhZGVyIScsIHRoaXMuX2dsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc2hhZGVyO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQ29sb3JCbGluZENvcnJlY3Rvci5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uIChpbWFnZSwgb3V0KSB7XHJcbiAgICAgICAgICAgIC8vIGxvb2sgdXAgd2hlcmUgdGhlIHZlcnRleCBkYXRhIG5lZWRzIHRvIGdvLlxyXG4gICAgICAgICAgICB2YXIgcG9zaXRpb25Mb2NhdGlvbiA9IHRoaXMuX2dsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMuX3Byb2dyYW0sICdhX3Bvc2l0aW9uJyk7XHJcbiAgICAgICAgICAgIHZhciB0ZXhDb29yZExvY2F0aW9uID0gdGhpcy5fZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fcHJvZ3JhbSwgJ2FfdGV4Q29vcmQnKTtcclxuICAgICAgICAgICAgdmFyIHRleENvb3JkQnVmZmVyID0gdGhpcy5fZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLmJpbmRCdWZmZXIodGhpcy5fZ2wuQVJSQVlfQlVGRkVSLCB0ZXhDb29yZEJ1ZmZlcik7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLmJ1ZmZlckRhdGEodGhpcy5fZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KFtcclxuICAgICAgICAgICAgICAgIDAuMCwgMC4wLFxyXG4gICAgICAgICAgICAgICAgMS4wLCAwLjAsXHJcbiAgICAgICAgICAgICAgICAwLjAsIDEuMCxcclxuICAgICAgICAgICAgICAgIDAuMCwgMS4wLFxyXG4gICAgICAgICAgICAgICAgMS4wLCAwLjAsXHJcbiAgICAgICAgICAgICAgICAxLjAsIDEuMFxyXG4gICAgICAgICAgICBdKSwgdGhpcy5fZ2wuU1RBVElDX0RSQVcpO1xyXG4gICAgICAgICAgICB0aGlzLl9nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0ZXhDb29yZExvY2F0aW9uKTtcclxuICAgICAgICAgICAgdGhpcy5fZ2wudmVydGV4QXR0cmliUG9pbnRlcih0ZXhDb29yZExvY2F0aW9uLCAyLCB0aGlzLl9nbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xyXG4gICAgICAgICAgICAvLyBDcmVhdGUgYSB0ZXh0dXJlLlxyXG4gICAgICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuX2dsLmNyZWF0ZVRleHR1cmUoKTtcclxuICAgICAgICAgICAgdGhpcy5fZ2wuYmluZFRleHR1cmUodGhpcy5fZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XHJcbiAgICAgICAgICAgIC8vIFNldCB0aGUgcGFyYW1ldGVycyBzbyB3ZSBjYW4gcmVuZGVyIGFueSBzaXplIGltYWdlLlxyXG4gICAgICAgICAgICB0aGlzLl9nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuX2dsLlRFWFRVUkVfMkQsIHRoaXMuX2dsLlRFWFRVUkVfV1JBUF9TLCB0aGlzLl9nbC5DTEFNUF9UT19FREdFKTtcclxuICAgICAgICAgICAgdGhpcy5fZ2wudGV4UGFyYW1ldGVyaSh0aGlzLl9nbC5URVhUVVJFXzJELCB0aGlzLl9nbC5URVhUVVJFX1dSQVBfVCwgdGhpcy5fZ2wuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLnRleFBhcmFtZXRlcmkodGhpcy5fZ2wuVEVYVFVSRV8yRCwgdGhpcy5fZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0aGlzLl9nbC5ORUFSRVNUKTtcclxuICAgICAgICAgICAgdGhpcy5fZ2wudGV4UGFyYW1ldGVyaSh0aGlzLl9nbC5URVhUVVJFXzJELCB0aGlzLl9nbC5URVhUVVJFX01BR19GSUxURVIsIHRoaXMuX2dsLk5FQVJFU1QpO1xyXG4gICAgICAgICAgICAvLyBGbGlwIHRoZSB0ZXh0dXJlIHdoZW4gdW5wYWNraW5nIGludG8gdGhlIGdsIGNvbnRleHQsIGdsIHJlYWRzIHRleHR1cmVzIGluIHRoZSBvcHBvc2l0ZSBvcmRlciBhcyBldmVyeXRoaW5nIGVsc2UgOi9cclxuICAgICAgICAgICAgdGhpcy5fZ2wucGl4ZWxTdG9yZWkodGhpcy5fZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgMSk7XHJcbiAgICAgICAgICAgIC8vIFVwbG9hZCB0aGUgaW1hZ2UgaW50byB0aGUgdGV4dHVyZS5cclxuICAgICAgICAgICAgdGhpcy5fZ2wudGV4SW1hZ2UyRCh0aGlzLl9nbC5URVhUVVJFXzJELCAwLCB0aGlzLl9nbC5SR0JBLCB0aGlzLl9nbC5SR0JBLCB0aGlzLl9nbC5VTlNJR05FRF9CWVRFLCBpbWFnZSk7XHJcbiAgICAgICAgICAgIC8vIGxvb2t1cCB1bmlmb3Jtc1xyXG4gICAgICAgICAgICB2YXIgcmVzb2x1dGlvbkxvY2F0aW9uID0gdGhpcy5fZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3Byb2dyYW0sICd1X3Jlc29sdXRpb24nKTtcclxuICAgICAgICAgICAgLy8gc2V0IHRoZSByZXNvbHV0aW9uXHJcbiAgICAgICAgICAgIHRoaXMuX2dsLnVuaWZvcm0yZihyZXNvbHV0aW9uTG9jYXRpb24sIHRoaXMuX2ludGVybmFsQ2FudmFzLndpZHRoLCB0aGlzLl9pbnRlcm5hbENhbnZhcy5oZWlnaHQpO1xyXG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBidWZmZXIgZm9yIHRoZSBwb3NpdGlvbiBvZiB0aGUgcmVjdGFuZ2xlIGNvcm5lcnMuXHJcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbkJ1ZmZlciA9IHRoaXMuX2dsLmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAgICAgICAgICB0aGlzLl9nbC5iaW5kQnVmZmVyKHRoaXMuX2dsLkFSUkFZX0JVRkZFUiwgcG9zaXRpb25CdWZmZXIpO1xyXG4gICAgICAgICAgICB0aGlzLl9nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbkxvY2F0aW9uKTtcclxuICAgICAgICAgICAgdGhpcy5fZ2wudmVydGV4QXR0cmliUG9pbnRlcihwb3NpdGlvbkxvY2F0aW9uLCAyLCB0aGlzLl9nbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xyXG4gICAgICAgICAgICAvLyBTZXQgYSByZWN0YW5nbGUgdGhlIHNhbWUgc2l6ZSBhcyB0aGUgaW1hZ2UuXHJcbiAgICAgICAgICAgIHRoaXMuX3NldFJlY3RhbmdsZSgwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0KTtcclxuICAgICAgICAgICAgLy8gRHJhdyB0aGUgcmVjdGFuZ2xlLlxyXG4gICAgICAgICAgICB0aGlzLl9nbC5kcmF3QXJyYXlzKHRoaXMuX2dsLlRSSUFOR0xFUywgMCwgNik7XHJcbiAgICAgICAgICAgIC8vIEdyYWIgdHJhbmZvcm1lZCBpbWFnZSBmcm9tIGludGVybmFsIGNhbnZhc1xyXG4gICAgICAgICAgICB2YXIgcGl4ZWxEYXRhID0gbmV3IFVpbnQ4QXJyYXkoaW1hZ2Uud2lkdGggKiBpbWFnZS5oZWlnaHQgKiA0KTtcclxuICAgICAgICAgICAgdGhpcy5fZ2wucmVhZFBpeGVscygwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCB0aGlzLl9nbC5SR0JBLCB0aGlzLl9nbC5VTlNJR05FRF9CWVRFLCBwaXhlbERhdGEpO1xyXG4gICAgICAgICAgICBpbWFnZS5kYXRhLnNldChwaXhlbERhdGEpO1xyXG4gICAgICAgICAgICBvdXQucHV0SW1hZ2VEYXRhKGltYWdlLCAwLCAwKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBDb2xvckJsaW5kQ29ycmVjdG9yO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuQ29sb3JCbGluZENvcnJlY3RvciA9IENvbG9yQmxpbmRDb3JyZWN0b3I7XHJcbn0pO1xyXG5kZWZpbmUoXCJQb3N0UHJvY2Vzc2luZy9JbmRleFwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIlBvc3RQcm9jZXNzaW5nL0NvbG9yQmxpbmRDb3JyZWN0b3JcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBDb2xvckJsaW5kQ29ycmVjdG9yXzEpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIF9fZXhwb3J0KENvbG9yQmxpbmRDb3JyZWN0b3JfMSk7XHJcbn0pO1xyXG5kZWZpbmUoXCJSZXNvdXJjZXMvSW5kZXhcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJSZXNvdXJjZXMvUmVzb3VyY2VcIiwgXCJSZXNvdXJjZXMvU291bmRcIiwgXCJSZXNvdXJjZXMvVGV4dHVyZVwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIFJlc291cmNlXzIsIFNvdW5kXzIsIFRleHR1cmVfMykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBmdW5jdGlvbiBfX2V4cG9ydChtKSB7XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgX19leHBvcnQoUmVzb3VyY2VfMik7XHJcbiAgICBfX2V4cG9ydChTb3VuZF8yKTtcclxuICAgIF9fZXhwb3J0KFRleHR1cmVfMyk7XHJcbn0pO1xyXG5kZWZpbmUoXCJJbnB1dC9HYW1lcGFkXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiQ2xhc3NcIiwgXCJFdmVudHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBDbGFzc181LCBFdmVudHNfOCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEV4Y2FsaWJ1ciBsZXZlcmFnZXMgdGhlIEhUTUw1IEdhbWVwYWQgQVBJIFt3aGVyZSBpdCBpcyBzdXBwb3J0ZWRdKGh0dHA6Ly9jYW5pdXNlLmNvbS8jZmVhdD1nYW1lcGFkKVxyXG4gICAgICogdG8gcHJvdmlkZSBjb250cm9sbGVyIHN1cHBvcnQgZm9yIHlvdXIgZ2FtZXMuXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOkdhbWVwYWRzLm1kXV1cclxuICAgICAqL1xyXG4gICAgdmFyIEdhbWVwYWRzID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoR2FtZXBhZHMsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gR2FtZXBhZHMoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0byBwb2xsIGZvciBHYW1lcGFkIGlucHV0IChkZWZhdWx0OiBgZmFsc2VgKVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuZW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgR2FtZXBhZCBBUEkgaXMgc3VwcG9ydGVkXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5zdXBwb3J0ZWQgPSAhIW5hdmlnYXRvci5nZXRHYW1lcGFkcztcclxuICAgICAgICAgICAgX3RoaXMuX2dhbWVQYWRUaW1lU3RhbXBzID0gWzAsIDAsIDAsIDBdO1xyXG4gICAgICAgICAgICBfdGhpcy5fb2xkUGFkcyA9IFtdO1xyXG4gICAgICAgICAgICBfdGhpcy5fcGFkcyA9IFtdO1xyXG4gICAgICAgICAgICBfdGhpcy5faW5pdFN1Y2Nlc3MgPSBmYWxzZTtcclxuICAgICAgICAgICAgX3RoaXMuX25hdmlnYXRvciA9IG5hdmlnYXRvcjtcclxuICAgICAgICAgICAgX3RoaXMuX21pbmltdW1Db25maWd1cmF0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBHYW1lcGFkcy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnN1cHBvcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbml0U3VjY2Vzcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEluIENocm9tZSwgdGhpcyB3aWxsIHJldHVybiA0IHVuZGVmaW5lZCBpdGVtcyB1bnRpbCBhIGJ1dHRvbiBpcyBwcmVzc2VkXHJcbiAgICAgICAgICAgIC8vIEluIEZGLCB0aGlzIHdpbGwgbm90IHJldHVybiBhbnkgaXRlbXMgdW50aWwgYSBidXR0b24gaXMgcHJlc3NlZFxyXG4gICAgICAgICAgICB0aGlzLl9vbGRQYWRzID0gdGhpcy5fY2xvbmVQYWRzKHRoaXMuX25hdmlnYXRvci5nZXRHYW1lcGFkcygpKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX29sZFBhZHMubGVuZ3RoICYmIHRoaXMuX29sZFBhZHNbMF0pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRTdWNjZXNzID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgbWluaW11bSBnYW1lcGFkIGNvbmZpZ3VyYXRpb24sIGZvciBleGFtcGxlIHtheGlzOiA0LCBidXR0b25zOiA0fSBtZWFuc1xyXG4gICAgICAgICAqIHRoaXMgZ2FtZSByZXF1aXJlcyBhdCBtaW5pbXVtIDQgYXhpcyBpbnB1dHMgYW5kIDQgYnV0dG9ucywgdGhpcyBpcyBub3QgcmVzdHJpY3RpdmVcclxuICAgICAgICAgKiBhbGwgb3RoZXIgY29udHJvbGxlcnMgd2l0aCBtb3JlIGF4aXMgb3IgYnV0dG9ucyBhcmUgdmFsaWQgYXMgd2VsbC4gSWYgbm8gbWluaW11bVxyXG4gICAgICAgICAqIGNvbmZpZ3VyYXRpb24gaXMgc2V0IGFsbCBwYWRzIGFyZSB2YWxpZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBHYW1lcGFkcy5wcm90b3R5cGUuc2V0TWluaW11bUdhbWVwYWRDb25maWd1cmF0aW9uID0gZnVuY3Rpb24gKGNvbmZpZykge1xyXG4gICAgICAgICAgICB0aGlzLl9lbmFibGVBbmRVcGRhdGUoKTsgLy8gaWYgY29uZmlnIGlzIHVzZWQsIGltcGxpY2l0bHkgZW5hYmxlXHJcbiAgICAgICAgICAgIHRoaXMuX21pbmltdW1Db25maWd1cmF0aW9uID0gY29uZmlnO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hlbiBpbXBsaWNpdGx5IGVuYWJsZWQsIHNldCB0aGUgZW5hYmxlZCBmbGFnIGFuZCBydW4gYW4gdXBkYXRlIHNvIGluZm9ybWF0aW9uIGlzIHVwZGF0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBHYW1lcGFkcy5wcm90b3R5cGUuX2VuYWJsZUFuZFVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGVja3MgYSBuYXZpZ2F0b3IgZ2FtZXBhZCBhZ2FpbnN0IHRoZSBtaW5pbXVtIGNvbmZpZ3VyYXRpb24gaWYgcHJlc2VudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBHYW1lcGFkcy5wcm90b3R5cGUuX2lzR2FtZXBhZFZhbGlkID0gZnVuY3Rpb24gKHBhZCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX21pbmltdW1Db25maWd1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA7XHJcbiAgICAgICAgICAgIGlmICghcGFkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgO1xyXG4gICAgICAgICAgICB2YXIgYXhlc0xlbmd0aCA9IHBhZC5heGVzLmZpbHRlcihmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAodHlwZW9mIHZhbHVlICE9PSB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICB9KS5sZW5ndGg7XHJcbiAgICAgICAgICAgIHZhciBidXR0b25MZW5ndGggPSBwYWQuYnV0dG9ucy5maWx0ZXIoZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSAhPT0gdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgfSkubGVuZ3RoO1xyXG4gICAgICAgICAgICByZXR1cm4gYXhlc0xlbmd0aCA+PSB0aGlzLl9taW5pbXVtQ29uZmlndXJhdGlvbi5heGlzICYmXHJcbiAgICAgICAgICAgICAgICBidXR0b25MZW5ndGggPj0gdGhpcy5fbWluaW11bUNvbmZpZ3VyYXRpb24uYnV0dG9ucyAmJlxyXG4gICAgICAgICAgICAgICAgcGFkLmNvbm5lY3RlZDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEdhbWVwYWRzLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fZW5hYmxlQW5kVXBkYXRlKCk7IC8vIGltcGxpY2l0bHkgZW5hYmxlXHJcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgR2FtZXBhZHMucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fZW5hYmxlQW5kVXBkYXRlKCk7IC8vIGltcGxpY2l0bHkgZW5hYmxlXHJcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUub2ZmLmNhbGwodGhpcywgZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwZGF0ZXMgR2FtZXBhZCBzdGF0ZSBhbmQgcHVibGlzaGVzIEdhbWVwYWQgZXZlbnRzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgR2FtZXBhZHMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQgfHwgIXRoaXMuc3VwcG9ydGVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5pbml0KCk7XHJcbiAgICAgICAgICAgIHZhciBnYW1lcGFkcyA9IHRoaXMuX25hdmlnYXRvci5nZXRHYW1lcGFkcygpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdhbWVwYWRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWdhbWVwYWRzW2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdhbWVwYWQgPSB0aGlzLmF0KGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdhcyBjb25uZWN0ZWQsIGJ1dCBub3cgaXNuJ3QgZW1pdCB0aGUgZGlzY29ubmVjdCBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChnYW1lcGFkLmNvbm5lY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5lbWl0KCdkaXNjb25uZWN0JywgbmV3IEV2ZW50c184LkdhbWVwYWREaXNjb25uZWN0RXZlbnQoaSwgZ2FtZXBhZCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCBjb25uZWN0aW9uIHN0YXR1c1xyXG4gICAgICAgICAgICAgICAgICAgIGdhbWVwYWQuY29ubmVjdGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYXQoaSkuY29ubmVjdGVkICYmIHRoaXMuX2lzR2FtZXBhZFZhbGlkKGdhbWVwYWRzW2ldKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5lbWl0KCdjb25uZWN0JywgbmV3IEV2ZW50c184LkdhbWVwYWRDb25uZWN0RXZlbnQoaSwgdGhpcy5hdChpKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgY29ubmVjdGlvbiBzdGF0dXNcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0KGkpLmNvbm5lY3RlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICA7XHJcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHN1cHBvcnRlZCBpbiBDaHJvbWVcclxuICAgICAgICAgICAgICAgIGlmIChnYW1lcGFkc1tpXS50aW1lc3RhbXAgJiYgZ2FtZXBhZHNbaV0udGltZXN0YW1wID09PSB0aGlzLl9nYW1lUGFkVGltZVN0YW1wc1tpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fZ2FtZVBhZFRpbWVTdGFtcHNbaV0gPSBnYW1lcGFkc1tpXS50aW1lc3RhbXA7XHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgcmVmZXJlbmNlIHRvIG5hdmlnYXRvciBnYW1lcGFkXHJcbiAgICAgICAgICAgICAgICB0aGlzLmF0KGkpLm5hdmlnYXRvckdhbWVwYWQgPSBnYW1lcGFkc1tpXTtcclxuICAgICAgICAgICAgICAgIC8vIEJ1dHRvbnNcclxuICAgICAgICAgICAgICAgIHZhciBiLCBiaSwgYSwgYWksIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgZm9yIChiIGluIEJ1dHRvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBiaSA9IEJ1dHRvbnNbYl07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBiaSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdhbWVwYWRzW2ldLmJ1dHRvbnNbYmldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGdhbWVwYWRzW2ldLmJ1dHRvbnNbYmldLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl9vbGRQYWRzW2ldLmdldEJ1dHRvbihiaSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2FtZXBhZHNbaV0uYnV0dG9uc1tiaV0ucHJlc3NlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0KGkpLnVwZGF0ZUJ1dHRvbihiaSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0KGkpLmV2ZW50RGlzcGF0Y2hlci5lbWl0KCdidXR0b24nLCBuZXcgRXZlbnRzXzguR2FtZXBhZEJ1dHRvbkV2ZW50KGJpLCB2YWx1ZSwgdGhpcy5hdChpKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdChpKS51cGRhdGVCdXR0b24oYmksIDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIEF4ZXNcclxuICAgICAgICAgICAgICAgIGZvciAoYSBpbiBBeGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWkgPSBBeGVzW2FdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYWkgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZ2FtZXBhZHNbaV0uYXhlc1thaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fb2xkUGFkc1tpXS5nZXRBeGVzKGFpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdChpKS51cGRhdGVBeGVzKGFpLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0KGkpLmV2ZW50RGlzcGF0Y2hlci5lbWl0KCdheGlzJywgbmV3IEV2ZW50c184LkdhbWVwYWRBeGlzRXZlbnQoYWksIHZhbHVlLCB0aGlzLmF0KGkpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vbGRQYWRzW2ldID0gdGhpcy5fY2xvbmVQYWQoZ2FtZXBhZHNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTYWZlbHkgcmV0cmlldmVzIGEgR2FtZXBhZCBhdCBhIHNwZWNpZmljIGluZGV4IGFuZCBjcmVhdGVzIG9uZSBpZiBpdCBkb2Vzbid0IHlldCBleGlzdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEdhbWVwYWRzLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgICAgICB0aGlzLl9lbmFibGVBbmRVcGRhdGUoKTsgLy8gaW1wbGljaXRseSBlbmFibGUgZ2FtZXBhZHMgd2hlbiBhdCgpIGlzIGNhbGxlZCAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gdGhpcy5fcGFkcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB0aGVyZSBpcyBhIHBhZCB0byByZXRyaWV2ZVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX3BhZHMubGVuZ3RoIC0gMSwgbWF4ID0gaW5kZXg7IGkgPCBtYXg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhZHMucHVzaChuZXcgR2FtZXBhZCgpKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbGRQYWRzLnB1c2gobmV3IEdhbWVwYWQoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhZHNbaW5kZXhdO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIGxpc3Qgb2YgYWxsIHZhbGlkIGdhbWVwYWRzIHRoYXQgbWVldCB0aGUgbWluaW11bSBjb25maWd1cmF0aW9uIHJlcXVpcmVtZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEdhbWVwYWRzLnByb3RvdHlwZS5nZXRWYWxpZEdhbWVwYWRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9lbmFibGVBbmRVcGRhdGUoKTtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3BhZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc0dhbWVwYWRWYWxpZCh0aGlzLmF0KGkpLm5hdmlnYXRvckdhbWVwYWQpICYmIHRoaXMuYXQoaSkuY29ubmVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5hdChpKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIG51bWJlciBvZiBjb25uZWN0ZWQgZ2FtZXBhZHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBHYW1lcGFkcy5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYWRzLmZpbHRlcihmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5jb25uZWN0ZWQ7IH0pLmxlbmd0aDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEdhbWVwYWRzLnByb3RvdHlwZS5fY2xvbmVQYWRzID0gZnVuY3Rpb24gKHBhZHMpIHtcclxuICAgICAgICAgICAgdmFyIGFyciA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGFkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgYXJyLnB1c2godGhpcy5fY2xvbmVQYWQocGFkc1tpXSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBhcnI7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGYXN0ZXN0IHdheSB0byBjbG9uZSBhIGtub3duIG9iamVjdCBpcyB0byBkbyBpdCB5b3Vyc2VsZlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEdhbWVwYWRzLnByb3RvdHlwZS5fY2xvbmVQYWQgPSBmdW5jdGlvbiAocGFkKSB7XHJcbiAgICAgICAgICAgIHZhciBpLCBsZW47XHJcbiAgICAgICAgICAgIHZhciBjbG9uZWRQYWQgPSBuZXcgR2FtZXBhZCgpO1xyXG4gICAgICAgICAgICBpZiAoIXBhZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lZFBhZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBwYWQuYnV0dG9ucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhZC5idXR0b25zW2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkUGFkLnVwZGF0ZUJ1dHRvbihpLCBwYWQuYnV0dG9uc1tpXS52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcGFkLmF4ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNsb25lZFBhZC51cGRhdGVBeGVzKGksIHBhZC5heGVzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY2xvbmVkUGFkO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEdhbWVwYWRzO1xyXG4gICAgfShDbGFzc181LkNsYXNzKSk7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtaW5pbXVtIHZhbHVlIGFuIGF4aXMgaGFzIHRvIG1vdmUgYmVmb3JlIGNvbnNpZGVyaW5nIGl0IGEgY2hhbmdlXHJcbiAgICAgKi9cclxuICAgIEdhbWVwYWRzLk1pbkF4aXNNb3ZlVGhyZXNob2xkID0gMC4wNTtcclxuICAgIGV4cG9ydHMuR2FtZXBhZHMgPSBHYW1lcGFkcztcclxuICAgIC8qKlxyXG4gICAgICogR2FtZXBhZCBob2xkcyBzdGF0ZSBpbmZvcm1hdGlvbiBmb3IgYSBjb25uZWN0ZWQgY29udHJvbGxlci4gU2VlIFtbR2FtZXBhZHNdXVxyXG4gICAgICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gaGFuZGxpbmcgY29udHJvbGxlciBpbnB1dC5cclxuICAgICAqL1xyXG4gICAgdmFyIEdhbWVwYWQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhHYW1lcGFkLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIEdhbWVwYWQoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBfdGhpcy5fYnV0dG9ucyA9IG5ldyBBcnJheSgxNik7XHJcbiAgICAgICAgICAgIF90aGlzLl9heGVzID0gbmV3IEFycmF5KDQpO1xyXG4gICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IF90aGlzLl9idXR0b25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fYnV0dG9uc1tpXSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IF90aGlzLl9heGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fYXhlc1tpXSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgZ2l2ZW4gYnV0dG9uIGlzIHByZXNzZWRcclxuICAgICAgICAgKiBAcGFyYW0gYnV0dG9uICAgICBUaGUgYnV0dG9uIHRvIHF1ZXJ5XHJcbiAgICAgICAgICogQHBhcmFtIHRocmVzaG9sZCAgVGhlIHRocmVzaG9sZCBvdmVyIHdoaWNoIHRoZSBidXR0b24gaXMgY29uc2lkZXJlZCB0byBiZSBwcmVzc2VkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgR2FtZXBhZC5wcm90b3R5cGUuaXNCdXR0b25QcmVzc2VkID0gZnVuY3Rpb24gKGJ1dHRvbiwgdGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAgIGlmICh0aHJlc2hvbGQgPT09IHZvaWQgMCkgeyB0aHJlc2hvbGQgPSAxOyB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9idXR0b25zW2J1dHRvbl0gPj0gdGhyZXNob2xkO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgZ2l2ZW4gYnV0dG9uIHZhbHVlIGJldHdlZW4gMCBhbmQgMVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEdhbWVwYWQucHJvdG90eXBlLmdldEJ1dHRvbiA9IGZ1bmN0aW9uIChidXR0b24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J1dHRvbnNbYnV0dG9uXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGdpdmVuIGF4aXMgdmFsdWUgYmV0d2VlbiAtMSBhbmQgMS4gVmFsdWVzIGJlbG93XHJcbiAgICAgICAgICogW1tNaW5BeGlzTW92ZVRocmVzaG9sZF1dIGFyZSBjb25zaWRlcmVkIDAuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgR2FtZXBhZC5wcm90b3R5cGUuZ2V0QXhlcyA9IGZ1bmN0aW9uIChheGVzKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2F4ZXNbYXhlc107XHJcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh2YWx1ZSkgPCBHYW1lcGFkcy5NaW5BeGlzTW92ZVRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEdhbWVwYWQucHJvdG90eXBlLnVwZGF0ZUJ1dHRvbiA9IGZ1bmN0aW9uIChidXR0b25JbmRleCwgdmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fYnV0dG9uc1tidXR0b25JbmRleF0gPSB2YWx1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEdhbWVwYWQucHJvdG90eXBlLnVwZGF0ZUF4ZXMgPSBmdW5jdGlvbiAoYXhlc0luZGV4LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9heGVzW2F4ZXNJbmRleF0gPSB2YWx1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBHYW1lcGFkO1xyXG4gICAgfShDbGFzc181LkNsYXNzKSk7XHJcbiAgICBleHBvcnRzLkdhbWVwYWQgPSBHYW1lcGFkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHYW1lcGFkIEJ1dHRvbnMgZW51bWVyYXRpb25cclxuICAgICAqL1xyXG4gICAgdmFyIEJ1dHRvbnM7XHJcbiAgICAoZnVuY3Rpb24gKEJ1dHRvbnMpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGYWNlIDEgYnV0dG9uIChlLmcuIEEpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnV0dG9uc1tCdXR0b25zW1wiRmFjZTFcIl0gPSAwXSA9IFwiRmFjZTFcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGYWNlIDIgYnV0dG9uIChlLmcuIEIpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnV0dG9uc1tCdXR0b25zW1wiRmFjZTJcIl0gPSAxXSA9IFwiRmFjZTJcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGYWNlIDMgYnV0dG9uIChlLmcuIFgpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnV0dG9uc1tCdXR0b25zW1wiRmFjZTNcIl0gPSAyXSA9IFwiRmFjZTNcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGYWNlIDQgYnV0dG9uIChlLmcuIFkpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnV0dG9uc1tCdXR0b25zW1wiRmFjZTRcIl0gPSAzXSA9IFwiRmFjZTRcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMZWZ0IGJ1bXBlciBidXR0b25cclxuICAgICAgICAgKi9cclxuICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJMZWZ0QnVtcGVyXCJdID0gNF0gPSBcIkxlZnRCdW1wZXJcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSaWdodCBidW1wZXIgYnV0dG9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnV0dG9uc1tCdXR0b25zW1wiUmlnaHRCdW1wZXJcIl0gPSA1XSA9IFwiUmlnaHRCdW1wZXJcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMZWZ0IHRyaWdnZXIgYnV0dG9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnV0dG9uc1tCdXR0b25zW1wiTGVmdFRyaWdnZXJcIl0gPSA2XSA9IFwiTGVmdFRyaWdnZXJcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSaWdodCB0cmlnZ2VyIGJ1dHRvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ1dHRvbnNbQnV0dG9uc1tcIlJpZ2h0VHJpZ2dlclwiXSA9IDddID0gXCJSaWdodFRyaWdnZXJcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZWxlY3QgYnV0dG9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnV0dG9uc1tCdXR0b25zW1wiU2VsZWN0XCJdID0gOF0gPSBcIlNlbGVjdFwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN0YXJ0IGJ1dHRvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ1dHRvbnNbQnV0dG9uc1tcIlN0YXJ0XCJdID0gOV0gPSBcIlN0YXJ0XCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTGVmdCBhbmFsb2cgc3RpY2sgcHJlc3MgKGUuZy4gTDMpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnV0dG9uc1tCdXR0b25zW1wiTGVmdFN0aWNrXCJdID0gMTBdID0gXCJMZWZ0U3RpY2tcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSaWdodCBhbmFsb2cgc3RpY2sgcHJlc3MgKGUuZy4gUjMpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnV0dG9uc1tCdXR0b25zW1wiUmlnaHRTdGlja1wiXSA9IDExXSA9IFwiUmlnaHRTdGlja1wiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEQtcGFkIHVwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnV0dG9uc1tCdXR0b25zW1wiRHBhZFVwXCJdID0gMTJdID0gXCJEcGFkVXBcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBELXBhZCBkb3duXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnV0dG9uc1tCdXR0b25zW1wiRHBhZERvd25cIl0gPSAxM10gPSBcIkRwYWREb3duXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRC1wYWQgbGVmdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ1dHRvbnNbQnV0dG9uc1tcIkRwYWRMZWZ0XCJdID0gMTRdID0gXCJEcGFkTGVmdFwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEQtcGFkIHJpZ2h0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnV0dG9uc1tCdXR0b25zW1wiRHBhZFJpZ2h0XCJdID0gMTVdID0gXCJEcGFkUmlnaHRcIjtcclxuICAgIH0pKEJ1dHRvbnMgPSBleHBvcnRzLkJ1dHRvbnMgfHwgKGV4cG9ydHMuQnV0dG9ucyA9IHt9KSk7XHJcbiAgICAvKipcclxuICAgICAqIEdhbWVwYWQgQXhlcyBlbnVtZXJhdGlvblxyXG4gICAgICovXHJcbiAgICB2YXIgQXhlcztcclxuICAgIChmdW5jdGlvbiAoQXhlcykge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExlZnQgYW5hbG9ndWUgc3RpY2sgWCBkaXJlY3Rpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBBeGVzW0F4ZXNbXCJMZWZ0U3RpY2tYXCJdID0gMF0gPSBcIkxlZnRTdGlja1hcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMZWZ0IGFuYWxvZ3VlIHN0aWNrIFkgZGlyZWN0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQXhlc1tBeGVzW1wiTGVmdFN0aWNrWVwiXSA9IDFdID0gXCJMZWZ0U3RpY2tZXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmlnaHQgYW5hbG9ndWUgc3RpY2sgWCBkaXJlY3Rpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBBeGVzW0F4ZXNbXCJSaWdodFN0aWNrWFwiXSA9IDJdID0gXCJSaWdodFN0aWNrWFwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJpZ2h0IGFuYWxvZ3VlIHN0aWNrIFkgZGlyZWN0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQXhlc1tBeGVzW1wiUmlnaHRTdGlja1lcIl0gPSAzXSA9IFwiUmlnaHRTdGlja1lcIjtcclxuICAgIH0pKEF4ZXMgPSBleHBvcnRzLkF4ZXMgfHwgKGV4cG9ydHMuQXhlcyA9IHt9KSk7XHJcbn0pO1xyXG5kZWZpbmUoXCJJbnB1dC9Qb2ludGVyXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiRW5naW5lXCIsIFwiRXZlbnRzXCIsIFwiVUlBY3RvclwiLCBcIkFsZ2VicmFcIiwgXCJDbGFzc1wiLCBcIlV0aWwvVXRpbFwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIEVuZ2luZV8yLCBFdmVudHNfOSwgVUlBY3Rvcl8xLCBBbGdlYnJhXzIwLCBDbGFzc182LCBVdGlsKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHR5cGUgb2YgcG9pbnRlciBmb3IgYSBbW1BvaW50ZXJFdmVudF1dLlxyXG4gICAgICovXHJcbiAgICB2YXIgUG9pbnRlclR5cGU7XHJcbiAgICAoZnVuY3Rpb24gKFBvaW50ZXJUeXBlKSB7XHJcbiAgICAgICAgUG9pbnRlclR5cGVbUG9pbnRlclR5cGVbXCJUb3VjaFwiXSA9IDBdID0gXCJUb3VjaFwiO1xyXG4gICAgICAgIFBvaW50ZXJUeXBlW1BvaW50ZXJUeXBlW1wiTW91c2VcIl0gPSAxXSA9IFwiTW91c2VcIjtcclxuICAgICAgICBQb2ludGVyVHlwZVtQb2ludGVyVHlwZVtcIlBlblwiXSA9IDJdID0gXCJQZW5cIjtcclxuICAgICAgICBQb2ludGVyVHlwZVtQb2ludGVyVHlwZVtcIlVua25vd25cIl0gPSAzXSA9IFwiVW5rbm93blwiO1xyXG4gICAgfSkoUG9pbnRlclR5cGUgPSBleHBvcnRzLlBvaW50ZXJUeXBlIHx8IChleHBvcnRzLlBvaW50ZXJUeXBlID0ge30pKTtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1vdXNlIGJ1dHRvbiBiZWluZyBwcmVzc2VkLlxyXG4gICAgICovXHJcbiAgICB2YXIgUG9pbnRlckJ1dHRvbjtcclxuICAgIChmdW5jdGlvbiAoUG9pbnRlckJ1dHRvbikge1xyXG4gICAgICAgIFBvaW50ZXJCdXR0b25bUG9pbnRlckJ1dHRvbltcIkxlZnRcIl0gPSAwXSA9IFwiTGVmdFwiO1xyXG4gICAgICAgIFBvaW50ZXJCdXR0b25bUG9pbnRlckJ1dHRvbltcIk1pZGRsZVwiXSA9IDFdID0gXCJNaWRkbGVcIjtcclxuICAgICAgICBQb2ludGVyQnV0dG9uW1BvaW50ZXJCdXR0b25bXCJSaWdodFwiXSA9IDJdID0gXCJSaWdodFwiO1xyXG4gICAgICAgIFBvaW50ZXJCdXR0b25bUG9pbnRlckJ1dHRvbltcIlVua25vd25cIl0gPSAzXSA9IFwiVW5rbm93blwiO1xyXG4gICAgfSkoUG9pbnRlckJ1dHRvbiA9IGV4cG9ydHMuUG9pbnRlckJ1dHRvbiB8fCAoZXhwb3J0cy5Qb2ludGVyQnV0dG9uID0ge30pKTtcclxuICAgIHZhciBXaGVlbERlbHRhTW9kZTtcclxuICAgIChmdW5jdGlvbiAoV2hlZWxEZWx0YU1vZGUpIHtcclxuICAgICAgICBXaGVlbERlbHRhTW9kZVtXaGVlbERlbHRhTW9kZVtcIlBpeGVsXCJdID0gMF0gPSBcIlBpeGVsXCI7XHJcbiAgICAgICAgV2hlZWxEZWx0YU1vZGVbV2hlZWxEZWx0YU1vZGVbXCJMaW5lXCJdID0gMV0gPSBcIkxpbmVcIjtcclxuICAgICAgICBXaGVlbERlbHRhTW9kZVtXaGVlbERlbHRhTW9kZVtcIlBhZ2VcIl0gPSAyXSA9IFwiUGFnZVwiO1xyXG4gICAgfSkoV2hlZWxEZWx0YU1vZGUgPSBleHBvcnRzLldoZWVsRGVsdGFNb2RlIHx8IChleHBvcnRzLldoZWVsRGVsdGFNb2RlID0ge30pKTtcclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5lcyB0aGUgc2NvcGUgb2YgaGFuZGxpbmcgbW91c2UvdG91Y2ggZXZlbnRzLiBTZWUgW1tQb2ludGVyc11dIGZvciBtb3JlIGluZm9ybWF0aW9uLlxyXG4gICAgICovXHJcbiAgICB2YXIgUG9pbnRlclNjb3BlO1xyXG4gICAgKGZ1bmN0aW9uIChQb2ludGVyU2NvcGUpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIYW5kbGUgZXZlbnRzIG9uIHRoZSBgY2FudmFzYCBlbGVtZW50IG9ubHkuIEV2ZW50cyBvcmlnaW5hdGluZyBvdXRzaWRlIHRoZVxyXG4gICAgICAgICAqIGBjYW52YXNgIHdpbGwgbm90IGJlIGhhbmRsZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUG9pbnRlclNjb3BlW1BvaW50ZXJTY29wZVtcIkNhbnZhc1wiXSA9IDBdID0gXCJDYW52YXNcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIYW5kbGVzIGV2ZW50cyBvbiB0aGUgZW50aXJlIGRvY3VtZW50LiBBbGwgZXZlbnRzIHdpbGwgYmUgaGFuZGxlZCBieSBFeGNhbGlidXIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUG9pbnRlclNjb3BlW1BvaW50ZXJTY29wZVtcIkRvY3VtZW50XCJdID0gMV0gPSBcIkRvY3VtZW50XCI7XHJcbiAgICB9KShQb2ludGVyU2NvcGUgPSBleHBvcnRzLlBvaW50ZXJTY29wZSB8fCAoZXhwb3J0cy5Qb2ludGVyU2NvcGUgPSB7fSkpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIGNvbnN0YW50IHVzZWQgdG8gbm9ybWFsaXplIHdoZWVsIGV2ZW50cyBhY3Jvc3MgZGlmZmVyZW50IGJyb3dzZXJzXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBub3JtYWxpemF0aW9uIGZhY3RvciBpcyBwdWxsZWQgZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9FdmVudHMvd2hlZWwjTGlzdGVuaW5nX3RvX3RoaXNfZXZlbnRfYWNyb3NzX2Jyb3dzZXJcclxuICAgICAqL1xyXG4gICAgdmFyIFNjcm9sbFdoZWVsTm9ybWFsaXphdGlvbkZhY3RvciA9IC0xIC8gNDA7XHJcbiAgICAvKipcclxuICAgICAqIFBvaW50ZXIgZXZlbnRzXHJcbiAgICAgKlxyXG4gICAgICogUmVwcmVzZW50cyBhIG1vdXNlLCB0b3VjaCwgb3Igc3R5bHVzIGV2ZW50LiBTZWUgW1tQb2ludGVyc11dIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uXHJcbiAgICAgKiBoYW5kbGluZyBwb2ludGVyIGlucHV0LlxyXG4gICAgICpcclxuICAgICAqIEZvciBtb3VzZS1iYXNlZCBldmVudHMsIHlvdSBjYW4gaW5zcGVjdCBbW1BvaW50ZXJFdmVudC5idXR0b25dXSB0byBzZWUgd2hhdCBidXR0b24gd2FzIHByZXNzZWQuXHJcbiAgICAgKi9cclxuICAgIHZhciBQb2ludGVyRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhQb2ludGVyRXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHBhZ2VYICAgICAgICBUaGUgYHhgIGNvb3JkaW5hdGUgb2YgdGhlIGV2ZW50IChpbiBkb2N1bWVudCBjb29yZGluYXRlcylcclxuICAgICAgICAgKiBAcGFyYW0gcGFnZVkgICAgICAgIFRoZSBgeWAgY29vcmRpbmF0ZSBvZiB0aGUgZXZlbnQgKGluIGRvY3VtZW50IGNvb3JkaW5hdGVzKVxyXG4gICAgICAgICAqIEBwYXJhbSBzY3JlZW5YICAgICAgVGhlIGB4YCBjb29yZGluYXRlIG9mIHRoZSBldmVudCAoaW4gc2NyZWVuIGNvb3JkaW5hdGVzKVxyXG4gICAgICAgICAqIEBwYXJhbSBzY3JlZW5ZICAgICAgVGhlIGB5YCBjb29yZGluYXRlIG9mIHRoZSBldmVudCAoaW4gc2NyZWVuIGNvb3JkaW5hdGVzKVxyXG4gICAgICAgICAqIEBwYXJhbSBpbmRleCAgICAgICAgVGhlIGluZGV4IG9mIHRoZSBwb2ludGVyICh6ZXJvLWJhc2VkKVxyXG4gICAgICAgICAqIEBwYXJhbSBwb2ludGVyVHlwZSAgVGhlIHR5cGUgb2YgcG9pbnRlclxyXG4gICAgICAgICAqIEBwYXJhbSBidXR0b24gICAgICAgVGhlIGJ1dHRvbiBwcmVzc2VkIChpZiBbW1BvaW50ZXJUeXBlLk1vdXNlXV0pXHJcbiAgICAgICAgICogQHBhcmFtIGV2ICAgICAgICAgICBUaGUgcmF3IERPTSBldmVudCBiZWluZyBoYW5kbGVkXHJcbiAgICAgICAgICogQHBhcmFtIHBvcyAgICAgICAgICAoV2lsbCBiZSBhZGRlZCB0byBzaWduYXR1cmUgaW4gMC4xNC4wIHJlbGVhc2UpIFRoZSBwb3NpdGlvbiBvZiB0aGUgZXZlbnQgKGluIHdvcmxkIGNvb3JkaW5hdGVzKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIFBvaW50ZXJFdmVudCh4LCB5LCBwYWdlWCwgcGFnZVksIHNjcmVlblgsIHNjcmVlblksIGluZGV4LCBwb2ludGVyVHlwZSwgYnV0dG9uLCBldikge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy54ID0geDtcclxuICAgICAgICAgICAgX3RoaXMueSA9IHk7XHJcbiAgICAgICAgICAgIF90aGlzLnBhZ2VYID0gcGFnZVg7XHJcbiAgICAgICAgICAgIF90aGlzLnBhZ2VZID0gcGFnZVk7XHJcbiAgICAgICAgICAgIF90aGlzLnNjcmVlblggPSBzY3JlZW5YO1xyXG4gICAgICAgICAgICBfdGhpcy5zY3JlZW5ZID0gc2NyZWVuWTtcclxuICAgICAgICAgICAgX3RoaXMuaW5kZXggPSBpbmRleDtcclxuICAgICAgICAgICAgX3RoaXMucG9pbnRlclR5cGUgPSBwb2ludGVyVHlwZTtcclxuICAgICAgICAgICAgX3RoaXMuYnV0dG9uID0gYnV0dG9uO1xyXG4gICAgICAgICAgICBfdGhpcy5ldiA9IGV2O1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQb2ludGVyRXZlbnQucHJvdG90eXBlLCBcInBvc1wiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBbGdlYnJhXzIwLlZlY3Rvcih0aGlzLngsIHRoaXMueSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBQb2ludGVyRXZlbnQ7XHJcbiAgICB9KEV2ZW50c185LkdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5Qb2ludGVyRXZlbnQgPSBQb2ludGVyRXZlbnQ7XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFdoZWVsIEV2ZW50c1xyXG4gICAgICpcclxuICAgICAqIFJlcHJlc2VudHMgYSBtb3VzZSB3aGVlbCBldmVudC4gU2VlIFtbUG9pbnRlcnNdXSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvblxyXG4gICAgICogaGFuZGxpbmcgcG9pbnQgaW5wdXQuXHJcbiAgICAgKi9cclxuICAgIHZhciBXaGVlbEV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoV2hlZWxFdmVudCwgX3N1cGVyKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0geCAgICAgICAgICAgIFRoZSBgeGAgY29vcmRpbmF0ZSBvZiB0aGUgZXZlbnQgKGluIHdvcmxkIGNvb3JkaW5hdGVzKVxyXG4gICAgICAgICAqIEBwYXJhbSB5ICAgICAgICAgICAgVGhlIGB5YCBjb29yZGluYXRlIG9mIHRoZSBldmVudCAoaW4gd29ybGQgY29vcmRpbmF0ZXMpXHJcbiAgICAgICAgICogQHBhcmFtIHBhZ2VYICAgICAgICBUaGUgYHhgIGNvb3JkaW5hdGUgb2YgdGhlIGV2ZW50IChpbiBkb2N1bWVudCBjb29yZGluYXRlcylcclxuICAgICAgICAgKiBAcGFyYW0gcGFnZVkgICAgICAgIFRoZSBgeWAgY29vcmRpbmF0ZSBvZiB0aGUgZXZlbnQgKGluIGRvY3VtZW50IGNvb3JkaW5hdGVzKVxyXG4gICAgICAgICAqIEBwYXJhbSBzY3JlZW5YICAgICAgVGhlIGB4YCBjb29yZGluYXRlIG9mIHRoZSBldmVudCAoaW4gc2NyZWVuIGNvb3JkaW5hdGVzKVxyXG4gICAgICAgICAqIEBwYXJhbSBzY3JlZW5ZICAgICAgVGhlIGB5YCBjb29yZGluYXRlIG9mIHRoZSBldmVudCAoaW4gc2NyZWVuIGNvb3JkaW5hdGVzKVxyXG4gICAgICAgICAqIEBwYXJhbSBpbmRleCAgICAgICAgVGhlIGluZGV4IG9mIHRoZSBwb2ludGVyICh6ZXJvLWJhc2VkKVxyXG4gICAgICAgICAqIEBwYXJhbSBkZWx0YVggICAgICAgVGhlIHR5cGUgb2YgcG9pbnRlclxyXG4gICAgICAgICAqIEBwYXJhbSBkZWx0YVkgICAgICAgVGhlIHR5cGUgb2YgcG9pbnRlclxyXG4gICAgICAgICAqIEBwYXJhbSBkZWx0YVogICAgICAgVGhlIHR5cGUgb2YgcG9pbnRlclxyXG4gICAgICAgICAqIEBwYXJhbSBkZWx0YU1vZGUgICAgVGhlIHR5cGUgb2YgbW92ZW1lbnQgW1tXaGVlbERlbHRhTW9kZV1dXHJcbiAgICAgICAgICogQHBhcmFtIGV2ICAgICAgICAgICBUaGUgcmF3IERPTSBldmVudCBiZWluZyBoYW5kbGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gV2hlZWxFdmVudCh4LCB5LCBwYWdlWCwgcGFnZVksIHNjcmVlblgsIHNjcmVlblksIGluZGV4LCBkZWx0YVgsIGRlbHRhWSwgZGVsdGFaLCBkZWx0YU1vZGUsIGV2KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLnggPSB4O1xyXG4gICAgICAgICAgICBfdGhpcy55ID0geTtcclxuICAgICAgICAgICAgX3RoaXMucGFnZVggPSBwYWdlWDtcclxuICAgICAgICAgICAgX3RoaXMucGFnZVkgPSBwYWdlWTtcclxuICAgICAgICAgICAgX3RoaXMuc2NyZWVuWCA9IHNjcmVlblg7XHJcbiAgICAgICAgICAgIF90aGlzLnNjcmVlblkgPSBzY3JlZW5ZO1xyXG4gICAgICAgICAgICBfdGhpcy5pbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICBfdGhpcy5kZWx0YVggPSBkZWx0YVg7XHJcbiAgICAgICAgICAgIF90aGlzLmRlbHRhWSA9IGRlbHRhWTtcclxuICAgICAgICAgICAgX3RoaXMuZGVsdGFaID0gZGVsdGFaO1xyXG4gICAgICAgICAgICBfdGhpcy5kZWx0YU1vZGUgPSBkZWx0YU1vZGU7XHJcbiAgICAgICAgICAgIF90aGlzLmV2ID0gZXY7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFdoZWVsRXZlbnQ7XHJcbiAgICB9KEV2ZW50c185LkdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5XaGVlbEV2ZW50ID0gV2hlZWxFdmVudDtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlcyBwb2ludGVyIGV2ZW50cyAobW91c2UsIHRvdWNoLCBzdHlsdXMsIGV0Yy4pIGFuZCBub3JtYWxpemVzIHRvXHJcbiAgICAgKiBbVzNDIFBvaW50ZXIgRXZlbnRzXShodHRwOi8vd3d3LnczLm9yZy9UUi9wb2ludGVyZXZlbnRzLykuXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOlBvaW50ZXJzLm1kXV1cclxuICAgICAqL1xyXG4gICAgdmFyIFBvaW50ZXJzID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoUG9pbnRlcnMsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gUG9pbnRlcnMoZW5naW5lKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLl9wb2ludGVyRG93biA9IFtdO1xyXG4gICAgICAgICAgICBfdGhpcy5fcG9pbnRlclVwID0gW107XHJcbiAgICAgICAgICAgIF90aGlzLl9wb2ludGVyTW92ZSA9IFtdO1xyXG4gICAgICAgICAgICBfdGhpcy5fcG9pbnRlckNhbmNlbCA9IFtdO1xyXG4gICAgICAgICAgICBfdGhpcy5fd2hlZWwgPSBbXTtcclxuICAgICAgICAgICAgX3RoaXMuX3BvaW50ZXJzID0gW107XHJcbiAgICAgICAgICAgIF90aGlzLl9hY3RpdmVQb2ludGVycyA9IFtdO1xyXG4gICAgICAgICAgICBfdGhpcy5fZW5naW5lID0gZW5naW5lO1xyXG4gICAgICAgICAgICBfdGhpcy5fcG9pbnRlcnMucHVzaChuZXcgUG9pbnRlcigpKTtcclxuICAgICAgICAgICAgX3RoaXMuX2FjdGl2ZVBvaW50ZXJzID0gWy0xXTtcclxuICAgICAgICAgICAgX3RoaXMucHJpbWFyeSA9IF90aGlzLl9wb2ludGVyc1swXTtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBQb2ludGVycy5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgcG9pbnRlciBldmVudCBsaXN0ZW5lcnNcclxuICAgICAgICAgKi9cclxuICAgICAgICBQb2ludGVycy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IHRoaXMuX2VuZ2luZS5jYW52YXM7XHJcbiAgICAgICAgICAgIC8vIFRvdWNoIEV2ZW50c1xyXG4gICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX2hhbmRsZVRvdWNoRXZlbnQoJ2Rvd24nLCB0aGlzLl9wb2ludGVyRG93bikpO1xyXG4gICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9oYW5kbGVUb3VjaEV2ZW50KCd1cCcsIHRoaXMuX3BvaW50ZXJVcCkpO1xyXG4gICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5faGFuZGxlVG91Y2hFdmVudCgnbW92ZScsIHRoaXMuX3BvaW50ZXJNb3ZlKSk7XHJcbiAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMuX2hhbmRsZVRvdWNoRXZlbnQoJ2NhbmNlbCcsIHRoaXMuX3BvaW50ZXJDYW5jZWwpKTtcclxuICAgICAgICAgICAgLy8gVzNDIFBvaW50ZXIgRXZlbnRzXHJcbiAgICAgICAgICAgIC8vIEN1cnJlbnQ6IElFMTEsIElFMTBcclxuICAgICAgICAgICAgaWYgKHdpbmRvdy5Qb2ludGVyRXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIC8vIElFMTFcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VuZ2luZS5jYW52YXMuc3R5bGUudG91Y2hBY3Rpb24gPSAnbm9uZSc7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCB0aGlzLl9oYW5kbGVQb2ludGVyRXZlbnQoJ2Rvd24nLCB0aGlzLl9wb2ludGVyRG93bikpO1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIHRoaXMuX2hhbmRsZVBvaW50ZXJFdmVudCgndXAnLCB0aGlzLl9wb2ludGVyVXApKTtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIHRoaXMuX2hhbmRsZVBvaW50ZXJFdmVudCgnbW92ZScsIHRoaXMuX3BvaW50ZXJNb3ZlKSk7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmNhbmNlbCcsIHRoaXMuX2hhbmRsZVBvaW50ZXJFdmVudCgnY2FuY2VsJywgdGhpcy5fcG9pbnRlck1vdmUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh3aW5kb3cuTVNQb2ludGVyRXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIC8vIElFMTBcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VuZ2luZS5jYW52YXMuc3R5bGUubXNUb3VjaEFjdGlvbiA9ICdub25lJztcclxuICAgICAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdNU1BvaW50ZXJEb3duJywgdGhpcy5faGFuZGxlUG9pbnRlckV2ZW50KCdkb3duJywgdGhpcy5fcG9pbnRlckRvd24pKTtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdNU1BvaW50ZXJVcCcsIHRoaXMuX2hhbmRsZVBvaW50ZXJFdmVudCgndXAnLCB0aGlzLl9wb2ludGVyVXApKTtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdNU1BvaW50ZXJNb3ZlJywgdGhpcy5faGFuZGxlUG9pbnRlckV2ZW50KCdtb3ZlJywgdGhpcy5fcG9pbnRlck1vdmUpKTtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdNU1BvaW50ZXJDYW5jZWwnLCB0aGlzLl9oYW5kbGVQb2ludGVyRXZlbnQoJ2NhbmNlbCcsIHRoaXMuX3BvaW50ZXJNb3ZlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBNb3VzZSBFdmVudHNcclxuICAgICAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9oYW5kbGVNb3VzZUV2ZW50KCdkb3duJywgdGhpcy5fcG9pbnRlckRvd24pKTtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5faGFuZGxlTW91c2VFdmVudCgndXAnLCB0aGlzLl9wb2ludGVyVXApKTtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9oYW5kbGVNb3VzZUV2ZW50KCdtb3ZlJywgdGhpcy5fcG9pbnRlck1vdmUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBNRE4gTW91c2VXaGVlbEV2ZW50XHJcbiAgICAgICAgICAgIGlmICgnb253aGVlbCcgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpIHtcclxuICAgICAgICAgICAgICAgIC8vIE1vZGVybiBCcm93c2Vyc1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy5faGFuZGxlV2hlZWxFdmVudCgnd2hlZWwnLCB0aGlzLl93aGVlbCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGRvY3VtZW50Lm9ubW91c2V3aGVlbCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZWJraXQgYW5kIElFXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIHRoaXMuX2hhbmRsZVdoZWVsRXZlbnQoJ3doZWVsJywgdGhpcy5fd2hlZWwpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFJlbWFpbmluZyBicm93c2VyIGFuZCBvbGRlciBGaXJlZm94XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignTW96TW91c2VQaXhlbFNjcm9sbCcsIHRoaXMuX2hhbmRsZVdoZWVsRXZlbnQoJ3doZWVsJywgdGhpcy5fd2hlZWwpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgUG9pbnRlcnMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fcG9pbnRlclVwLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3BvaW50ZXJEb3duLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3BvaW50ZXJNb3ZlLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3BvaW50ZXJDYW5jZWwubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fd2hlZWwubGVuZ3RoID0gMDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNhZmVseSBnZXRzIGEgUG9pbnRlciBhdCBhIHNwZWNpZmljIGluZGV4IGFuZCBpbml0aWFsaXplcyBvbmUgaWYgaXQgZG9lc24ndCB5ZXQgZXhpc3RcclxuICAgICAgICAgKiBAcGFyYW0gaW5kZXggIFRoZSBwb2ludGVyIGluZGV4IHRvIHJldHJpZXZlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUG9pbnRlcnMucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSB0aGlzLl9wb2ludGVycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB0aGVyZSBpcyBhIHBvaW50ZXIgdG8gcmV0cmlldmVcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9wb2ludGVycy5sZW5ndGggLSAxLCBtYXggPSBpbmRleDsgaSA8IG1heDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9pbnRlcnMucHVzaChuZXcgUG9pbnRlcigpKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmVQb2ludGVycy5wdXNoKC0xKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcG9pbnRlcnNbaW5kZXhdO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IG51bWJlciBvZiBwb2ludGVycyBiZWluZyB3YXRjaGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUG9pbnRlcnMucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcG9pbnRlcnMubGVuZ3RoO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJvcG9nYXRlcyBldmVudHMgdG8gYWN0b3IgaWYgbmVjZXNzYXJ5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUG9pbnRlcnMucHJvdG90eXBlLnByb3BvZ2F0ZSA9IGZ1bmN0aW9uIChhY3Rvcikge1xyXG4gICAgICAgICAgICB2YXIgaXNVSUFjdG9yID0gYWN0b3IgaW5zdGFuY2VvZiBVSUFjdG9yXzEuVUlBY3RvcjtcclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9wb2ludGVyVXAubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFjdG9yLmNvbnRhaW5zKHRoaXMuX3BvaW50ZXJVcFtpXS54LCB0aGlzLl9wb2ludGVyVXBbaV0ueSwgIWlzVUlBY3RvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBhY3Rvci5ldmVudERpc3BhdGNoZXIuZW1pdCgncG9pbnRlcnVwJywgdGhpcy5fcG9pbnRlclVwW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgICAgbGVuID0gdGhpcy5fcG9pbnRlckRvd24ubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFjdG9yLmNvbnRhaW5zKHRoaXMuX3BvaW50ZXJEb3duW2ldLngsIHRoaXMuX3BvaW50ZXJEb3duW2ldLnksICFpc1VJQWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0b3IuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ3BvaW50ZXJkb3duJywgdGhpcy5fcG9pbnRlckRvd25baV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhY3Rvci5jYXB0dXJlUG9pbnRlci5jYXB0dXJlTW92ZUV2ZW50cykge1xyXG4gICAgICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICBsZW4gPSB0aGlzLl9wb2ludGVyTW92ZS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rvci5jb250YWlucyh0aGlzLl9wb2ludGVyTW92ZVtpXS54LCB0aGlzLl9wb2ludGVyTW92ZVtpXS55LCAhaXNVSUFjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rvci5ldmVudERpc3BhdGNoZXIuZW1pdCgncG9pbnRlcm1vdmUnLCB0aGlzLl9wb2ludGVyTW92ZVtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgICAgICBsZW4gPSB0aGlzLl9wb2ludGVyQ2FuY2VsLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChhY3Rvci5jb250YWlucyh0aGlzLl9wb2ludGVyQ2FuY2VsW2ldLngsIHRoaXMuX3BvaW50ZXJDYW5jZWxbaV0ueSwgIWlzVUlBY3RvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBhY3Rvci5ldmVudERpc3BhdGNoZXIuZW1pdCgncG9pbnRlcmNhbmNlbCcsIHRoaXMuX3BvaW50ZXJDYW5jZWxbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgICAgICBsZW4gPSB0aGlzLl93aGVlbC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWN0b3IuY29udGFpbnModGhpcy5fd2hlZWxbaV0ueCwgdGhpcy5fd2hlZWxbaV0ueSwgIWlzVUlBY3RvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBhY3Rvci5ldmVudERpc3BhdGNoZXIuZW1pdCgncG9pbnRlcndoZWVsJywgdGhpcy5fd2hlZWxbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQb2ludGVycy5wcm90b3R5cGUuX2hhbmRsZU1vdXNlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudEFycikge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIHZhciB4ID0gZS5wYWdlWCAtIFV0aWwuZ2V0UG9zaXRpb24oX3RoaXMuX2VuZ2luZS5jYW52YXMpLng7XHJcbiAgICAgICAgICAgICAgICB2YXIgeSA9IGUucGFnZVkgLSBVdGlsLmdldFBvc2l0aW9uKF90aGlzLl9lbmdpbmUuY2FudmFzKS55O1xyXG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkUG9pbnQgPSBfdGhpcy5fZW5naW5lLnNjcmVlblRvV29ybGRDb29yZGluYXRlcyhuZXcgQWxnZWJyYV8yMC5WZWN0b3IoeCwgeSkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBlID0gbmV3IFBvaW50ZXJFdmVudCh0cmFuc2Zvcm1lZFBvaW50LngsIHRyYW5zZm9ybWVkUG9pbnQueSwgZS5wYWdlWCwgZS5wYWdlWSwgeCwgeSwgMCwgUG9pbnRlclR5cGUuTW91c2UsIGUuYnV0dG9uLCBlKTtcclxuICAgICAgICAgICAgICAgIGV2ZW50QXJyLnB1c2gocGUpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuYXQoMCkuZXZlbnREaXNwYXRjaGVyLmVtaXQoZXZlbnROYW1lLCBwZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQb2ludGVycy5wcm90b3R5cGUuX2hhbmRsZVRvdWNoRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudEFycikge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlLmNoYW5nZWRUb3VjaGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gX3RoaXMuX3BvaW50ZXJzLmxlbmd0aCA+IDEgPyBfdGhpcy5fZ2V0UG9pbnRlckluZGV4KGUuY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcikgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0gZS5jaGFuZ2VkVG91Y2hlc1tpXS5wYWdlWCAtIFV0aWwuZ2V0UG9zaXRpb24oX3RoaXMuX2VuZ2luZS5jYW52YXMpLng7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSBlLmNoYW5nZWRUb3VjaGVzW2ldLnBhZ2VZIC0gVXRpbC5nZXRQb3NpdGlvbihfdGhpcy5fZW5naW5lLmNhbnZhcykueTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWRQb2ludCA9IF90aGlzLl9lbmdpbmUuc2NyZWVuVG9Xb3JsZENvb3JkaW5hdGVzKG5ldyBBbGdlYnJhXzIwLlZlY3Rvcih4LCB5KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBlID0gbmV3IFBvaW50ZXJFdmVudCh0cmFuc2Zvcm1lZFBvaW50LngsIHRyYW5zZm9ybWVkUG9pbnQueSwgZS5jaGFuZ2VkVG91Y2hlc1tpXS5wYWdlWCwgZS5jaGFuZ2VkVG91Y2hlc1tpXS5wYWdlWSwgeCwgeSwgaW5kZXgsIFBvaW50ZXJUeXBlLlRvdWNoLCBQb2ludGVyQnV0dG9uLlVua25vd24sIGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50QXJyLnB1c2gocGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0KGluZGV4KS5ldmVudERpc3BhdGNoZXIuZW1pdChldmVudE5hbWUsIHBlKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IHdpdGggbXVsdGktcG9pbnRlclxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fcG9pbnRlcnMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSAndXAnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgcG9pbnRlciBJRCBmcm9tIHBvb2wgd2hlbiBwb2ludGVyIGlzIGxpZnRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FjdGl2ZVBvaW50ZXJzW2luZGV4XSA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50TmFtZSA9PT0gJ2Rvd24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgcG9pbnRlciBJRCB0byBnaXZlbiBpbmRleFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FjdGl2ZVBvaW50ZXJzW2luZGV4XSA9IGUuY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFBvaW50ZXJzLnByb3RvdHlwZS5faGFuZGxlUG9pbnRlckV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgZXZlbnRBcnIpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGluZGV4IGZvciB0aGlzIHBvaW50ZXIgSUQgaWYgbXVsdGktcG9pbnRlciBpcyBhc2tlZCBmb3JcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IF90aGlzLl9wb2ludGVycy5sZW5ndGggPiAxID8gX3RoaXMuX2dldFBvaW50ZXJJbmRleChlLnBvaW50ZXJJZCkgOiAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB4ID0gZS5wYWdlWCAtIFV0aWwuZ2V0UG9zaXRpb24oX3RoaXMuX2VuZ2luZS5jYW52YXMpLng7XHJcbiAgICAgICAgICAgICAgICB2YXIgeSA9IGUucGFnZVkgLSBVdGlsLmdldFBvc2l0aW9uKF90aGlzLl9lbmdpbmUuY2FudmFzKS55O1xyXG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkUG9pbnQgPSBfdGhpcy5fZW5naW5lLnNjcmVlblRvV29ybGRDb29yZGluYXRlcyhuZXcgQWxnZWJyYV8yMC5WZWN0b3IoeCwgeSkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBlID0gbmV3IFBvaW50ZXJFdmVudCh0cmFuc2Zvcm1lZFBvaW50LngsIHRyYW5zZm9ybWVkUG9pbnQueSwgZS5wYWdlWCwgZS5wYWdlWSwgeCwgeSwgaW5kZXgsIF90aGlzLl9zdHJpbmdUb1BvaW50ZXJUeXBlKGUucG9pbnRlclR5cGUpLCBlLmJ1dHRvbiwgZSk7XHJcbiAgICAgICAgICAgICAgICBldmVudEFyci5wdXNoKHBlKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmF0KGluZGV4KS5ldmVudERpc3BhdGNoZXIuZW1pdChldmVudE5hbWUsIHBlKTtcclxuICAgICAgICAgICAgICAgIC8vIG9ubHkgd2l0aCBtdWx0aS1wb2ludGVyXHJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX3BvaW50ZXJzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSAndXAnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBwb2ludGVyIElEIGZyb20gcG9vbCB3aGVuIHBvaW50ZXIgaXMgbGlmdGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9hY3RpdmVQb2ludGVyc1tpbmRleF0gPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnROYW1lID09PSAnZG93bicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0IHBvaW50ZXIgSUQgdG8gZ2l2ZW4gaW5kZXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FjdGl2ZVBvaW50ZXJzW2luZGV4XSA9IGUucG9pbnRlcklkO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFBvaW50ZXJzLnByb3RvdHlwZS5faGFuZGxlV2hlZWxFdmVudCA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50QXJyKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gU2hvdWxkIHdlIHByZXZlbnQgcGFnZSBzY3JvbGwgYmVjYXVzZSBvZiB0aGlzIGV2ZW50XHJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2VuZ2luZS5wYWdlU2Nyb2xsUHJldmVudGlvbk1vZGUgPT09IEVuZ2luZV8yLlNjcm9sbFByZXZlbnRpb25Nb2RlLkFsbCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChfdGhpcy5fZW5naW5lLnBhZ2VTY3JvbGxQcmV2ZW50aW9uTW9kZSA9PT0gRW5naW5lXzIuU2Nyb2xsUHJldmVudGlvbk1vZGUuQ2FudmFzICYmIGUudGFyZ2V0ID09PSBfdGhpcy5fZW5naW5lLmNhbnZhcykpIHtcclxuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IGUucGFnZVggLSBVdGlsLmdldFBvc2l0aW9uKF90aGlzLl9lbmdpbmUuY2FudmFzKS54O1xyXG4gICAgICAgICAgICAgICAgdmFyIHkgPSBlLnBhZ2VZIC0gVXRpbC5nZXRQb3NpdGlvbihfdGhpcy5fZW5naW5lLmNhbnZhcykueTtcclxuICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZFBvaW50ID0gX3RoaXMuX2VuZ2luZS5zY3JlZW5Ub1dvcmxkQ29vcmRpbmF0ZXMobmV3IEFsZ2VicmFfMjAuVmVjdG9yKHgsIHkpKTtcclxuICAgICAgICAgICAgICAgIC8vIGRlbHRhWCwgZGVsdGFZLCBhbmQgZGVsdGFaIGFyZSB0aGUgc3RhbmRhcmQgbW9kZXJuIHByb3BlcnRpZXNcclxuICAgICAgICAgICAgICAgIC8vIHdoZWVsRGVsdGFYLCB3aGVlbERlbHRhWSwgYXJlIGxlZ2FjeSBwcm9wZXJ0aWVzIGluIHdlYmtpdCBicm93c2VycyBhbmQgb2xkZXIgSUVcclxuICAgICAgICAgICAgICAgIC8vIGUuZGV0YWlsIGlzIG9ubHkgdXNlZCBpbiBvcGVyYVxyXG4gICAgICAgICAgICAgICAgdmFyIGRlbHRhWCA9IGUuZGVsdGFYIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKGUud2hlZWxEZWx0YVggKiBTY3JvbGxXaGVlbE5vcm1hbGl6YXRpb25GYWN0b3IpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgMDtcclxuICAgICAgICAgICAgICAgIHZhciBkZWx0YVkgPSBlLmRlbHRhWSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChlLndoZWVsRGVsdGFZICogU2Nyb2xsV2hlZWxOb3JtYWxpemF0aW9uRmFjdG9yKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChlLndoZWVsRGVsdGEgKiBTY3JvbGxXaGVlbE5vcm1hbGl6YXRpb25GYWN0b3IpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgZS5kZXRhaWwgfHxcclxuICAgICAgICAgICAgICAgICAgICAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRlbHRhWiA9IGUuZGVsdGFaIHx8IDA7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVsdGFNb2RlID0gV2hlZWxEZWx0YU1vZGUuUGl4ZWw7XHJcbiAgICAgICAgICAgICAgICBpZiAoZS5kZWx0YU1vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5kZWx0YU1vZGUgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFNb2RlID0gV2hlZWxEZWx0YU1vZGUuTGluZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZS5kZWx0YU1vZGUgPT09IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFNb2RlID0gV2hlZWxEZWx0YU1vZGUuUGFnZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgd2UgPSBuZXcgV2hlZWxFdmVudCh0cmFuc2Zvcm1lZFBvaW50LngsIHRyYW5zZm9ybWVkUG9pbnQueSwgZS5wYWdlWCwgZS5wYWdlWSwgeCwgeSwgMCwgZGVsdGFYLCBkZWx0YVksIGRlbHRhWiwgZGVsdGFNb2RlLCBlKTtcclxuICAgICAgICAgICAgICAgIGV2ZW50QXJyLnB1c2god2UpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuYXQoMCkuZXZlbnREaXNwYXRjaGVyLmVtaXQoZXZlbnROYW1lLCB3ZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBpbmRleCBvZiB0aGUgcG9pbnRlciBzcGVjaWZpZWQgZm9yIHRoZSBnaXZlbiBwb2ludGVyIElEIG9yIGZpbmRzIHRoZSBuZXh0IGVtcHR5IHBvaW50ZXIgc2xvdCBhdmFpbGFibGUuXHJcbiAgICAgICAgICogVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIElFMTAvMTEgdXNlcyBpbmNyZW1lbnRpbmcgcG9pbnRlciBJRHMgc28gd2UgbmVlZCB0byBzdG9yZSBhIG1hcHBpbmcgb2YgSUQgPT4gaWR4XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUG9pbnRlcnMucHJvdG90eXBlLl9nZXRQb2ludGVySW5kZXggPSBmdW5jdGlvbiAocG9pbnRlcklkKSB7XHJcbiAgICAgICAgICAgIHZhciBpZHg7XHJcbiAgICAgICAgICAgIGlmICgoaWR4ID0gdGhpcy5fYWN0aXZlUG9pbnRlcnMuaW5kZXhPZihwb2ludGVySWQpKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaWR4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fYWN0aXZlUG9pbnRlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hY3RpdmVQb2ludGVyc1tpXSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpZ25vcmUgcG9pbnRlciBiZWNhdXNlIGdhbWUgaXNuJ3Qgd2F0Y2hpbmdcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUG9pbnRlcnMucHJvdG90eXBlLl9zdHJpbmdUb1BvaW50ZXJUeXBlID0gZnVuY3Rpb24gKHMpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChzKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICd0b3VjaCc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBvaW50ZXJUeXBlLlRvdWNoO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnbW91c2UnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQb2ludGVyVHlwZS5Nb3VzZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3Blbic6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBvaW50ZXJUeXBlLlBlbjtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBvaW50ZXJUeXBlLlVua25vd247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBQb2ludGVycztcclxuICAgIH0oQ2xhc3NfNi5DbGFzcykpO1xyXG4gICAgZXhwb3J0cy5Qb2ludGVycyA9IFBvaW50ZXJzO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYXB0dXJlcyBhbmQgZGlzcGF0Y2hlcyBQb2ludGVyRXZlbnRzXHJcbiAgICAgKi9cclxuICAgIHZhciBQb2ludGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoUG9pbnRlciwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBQb2ludGVyKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGxhc3QgcG9zaXRpb24gb24gdGhlIGRvY3VtZW50IHRoaXMgcG9pbnRlciB3YXMgYXQuIENhbiBiZSBgbnVsbGAgaWYgcG9pbnRlciB3YXMgbmV2ZXIgYWN0aXZlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMubGFzdFBhZ2VQb3MgPSBudWxsO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGxhc3QgcG9zaXRpb24gb24gdGhlIHNjcmVlbiB0aGlzIHBvaW50ZXIgd2FzIGF0LiBDYW4gYmUgYG51bGxgIGlmIHBvaW50ZXIgd2FzIG5ldmVyIGFjdGl2ZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmxhc3RTY3JlZW5Qb3MgPSBudWxsO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGxhc3QgcG9zaXRpb24gaW4gdGhlIGdhbWUgd29ybGQgY29vcmRpbmF0ZXMgdGhpcyBwb2ludGVyIHdhcyBhdC4gQ2FuIGJlIGBudWxsYCBpZiBwb2ludGVyIHdhcyBuZXZlciBhY3RpdmUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5sYXN0V29ybGRQb3MgPSBudWxsO1xyXG4gICAgICAgICAgICBfdGhpcy5vbignbW92ZScsIF90aGlzLl9vblBvaW50ZXJNb3ZlKTtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBQb2ludGVyLnByb3RvdHlwZS5fb25Qb2ludGVyTW92ZSA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICB0aGlzLmxhc3RXb3JsZFBvcyA9IG5ldyBBbGdlYnJhXzIwLlZlY3Rvcihldi54LCBldi55KTtcclxuICAgICAgICAgICAgdGhpcy5sYXN0UGFnZVBvcyA9IG5ldyBBbGdlYnJhXzIwLlZlY3Rvcihldi5wYWdlWCwgZXYucGFnZVkpO1xyXG4gICAgICAgICAgICB0aGlzLmxhc3RTY3JlZW5Qb3MgPSBuZXcgQWxnZWJyYV8yMC5WZWN0b3IoZXYuc2NyZWVuWCwgZXYuc2NyZWVuWSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gUG9pbnRlcjtcclxuICAgIH0oQ2xhc3NfNi5DbGFzcykpO1xyXG4gICAgZXhwb3J0cy5Qb2ludGVyID0gUG9pbnRlcjtcclxufSk7XHJcbmRlZmluZShcIklucHV0L0tleWJvYXJkXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiQ2xhc3NcIiwgXCJFdmVudHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBDbGFzc183LCBFdmVudHNfMTApIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFbnVtIHJlcHJlc2VudGluZyBpbnB1dCBrZXkgY29kZXNcclxuICAgICAqL1xyXG4gICAgdmFyIEtleXM7XHJcbiAgICAoZnVuY3Rpb24gKEtleXMpIHtcclxuICAgICAgICBLZXlzW0tleXNbXCJOdW0xXCJdID0gOTddID0gXCJOdW0xXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiTnVtMlwiXSA9IDk4XSA9IFwiTnVtMlwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIk51bTNcIl0gPSA5OV0gPSBcIk51bTNcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJOdW00XCJdID0gMTAwXSA9IFwiTnVtNFwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIk51bTVcIl0gPSAxMDFdID0gXCJOdW01XCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiTnVtNlwiXSA9IDEwMl0gPSBcIk51bTZcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJOdW03XCJdID0gMTAzXSA9IFwiTnVtN1wiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIk51bThcIl0gPSAxMDRdID0gXCJOdW04XCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiTnVtOVwiXSA9IDEwNV0gPSBcIk51bTlcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJOdW0wXCJdID0gOTZdID0gXCJOdW0wXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiTnVtbG9ja1wiXSA9IDE0NF0gPSBcIk51bWxvY2tcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJTZW1pY29sb25cIl0gPSAxODZdID0gXCJTZW1pY29sb25cIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJBXCJdID0gNjVdID0gXCJBXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiQlwiXSA9IDY2XSA9IFwiQlwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIkNcIl0gPSA2N10gPSBcIkNcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJEXCJdID0gNjhdID0gXCJEXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiRVwiXSA9IDY5XSA9IFwiRVwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIkZcIl0gPSA3MF0gPSBcIkZcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJHXCJdID0gNzFdID0gXCJHXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiSFwiXSA9IDcyXSA9IFwiSFwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIklcIl0gPSA3M10gPSBcIklcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJKXCJdID0gNzRdID0gXCJKXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiS1wiXSA9IDc1XSA9IFwiS1wiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIkxcIl0gPSA3Nl0gPSBcIkxcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJNXCJdID0gNzddID0gXCJNXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiTlwiXSA9IDc4XSA9IFwiTlwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIk9cIl0gPSA3OV0gPSBcIk9cIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJQXCJdID0gODBdID0gXCJQXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiUVwiXSA9IDgxXSA9IFwiUVwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIlJcIl0gPSA4Ml0gPSBcIlJcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJTXCJdID0gODNdID0gXCJTXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiVFwiXSA9IDg0XSA9IFwiVFwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIlVcIl0gPSA4NV0gPSBcIlVcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJWXCJdID0gODZdID0gXCJWXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiV1wiXSA9IDg3XSA9IFwiV1wiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIlhcIl0gPSA4OF0gPSBcIlhcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJZXCJdID0gODldID0gXCJZXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiWlwiXSA9IDkwXSA9IFwiWlwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIlNoaWZ0XCJdID0gMTZdID0gXCJTaGlmdFwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIkFsdFwiXSA9IDE4XSA9IFwiQWx0XCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiVXBcIl0gPSAzOF0gPSBcIlVwXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiRG93blwiXSA9IDQwXSA9IFwiRG93blwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIkxlZnRcIl0gPSAzN10gPSBcIkxlZnRcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJSaWdodFwiXSA9IDM5XSA9IFwiUmlnaHRcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJTcGFjZVwiXSA9IDMyXSA9IFwiU3BhY2VcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJFc2NcIl0gPSAyN10gPSBcIkVzY1wiO1xyXG4gICAgfSkoS2V5cyA9IGV4cG9ydHMuS2V5cyB8fCAoZXhwb3J0cy5LZXlzID0ge30pKTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRXZlbnQgdGhyb3duIG9uIGEgZ2FtZSBvYmplY3QgZm9yIGEga2V5IGV2ZW50XHJcbiAgICAgKi9cclxuICAgIHZhciBLZXlFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKEtleUV2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBrZXkgIFRoZSBrZXkgcmVzcG9uc2libGUgZm9yIHRocm93aW5nIHRoZSBldmVudFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIEtleUV2ZW50KGtleSkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5rZXkgPSBrZXk7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEtleUV2ZW50O1xyXG4gICAgfShFdmVudHNfMTAuR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLktleUV2ZW50ID0gS2V5RXZlbnQ7XHJcbiAgICAvKipcclxuICAgICAqIFByb3ZpZGVzIGtleWJvYXJkIHN1cHBvcnQgZm9yIEV4Y2FsaWJ1ci5cclxuICAgICAqXHJcbiAgICAgKiBbW2luY2x1ZGU6S2V5Ym9hcmQubWRdXVxyXG4gICAgICovXHJcbiAgICB2YXIgS2V5Ym9hcmQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhLZXlib2FyZCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBLZXlib2FyZCgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuX2tleXMgPSBbXTtcclxuICAgICAgICAgICAgX3RoaXMuX2tleXNVcCA9IFtdO1xyXG4gICAgICAgICAgICBfdGhpcy5fa2V5c0Rvd24gPSBbXTtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBLZXlib2FyZC5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5pdGlhbGl6ZSBLZXlib2FyZCBldmVudCBsaXN0ZW5lcnNcclxuICAgICAgICAgKi9cclxuICAgICAgICBLZXlib2FyZC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChnbG9iYWwpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgZ2xvYmFsID0gZ2xvYmFsIHx8IHdpbmRvdztcclxuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fa2V5cy5sZW5ndGggPSAwOyAvLyBlbXB0aWVzIGFycmF5IGVmZmljaWVudGx5XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyBrZXkgdXAgaXMgb24gd2luZG93IGJlY2F1c2UgY2FudmFzIGNhbm5vdCBoYXZlIGZvY3VzXHJcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvZGUgPSBfdGhpcy5fbm9ybWFsaXplS2V5Q29kZShldi5rZXlDb2RlKTtcclxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfdGhpcy5fa2V5cy5pbmRleE9mKGNvZGUpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2tleXMuc3BsaWNlKGtleSwgMSk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fa2V5c1VwLnB1c2goY29kZSk7XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5RXZlbnQgPSBuZXcgS2V5RXZlbnQoY29kZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBhbGlhcyB0aGUgb2xkIGFwaSwgd2UgbWF5IHdhbnQgdG8gZGVwcmVjYXRlIHRoaXMgaW4gdGhlIGZ1dHVyZVxyXG4gICAgICAgICAgICAgICAgX3RoaXMuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ3VwJywga2V5RXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ3JlbGVhc2UnLCBrZXlFdmVudCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyBrZXkgZG93biBpcyBvbiB3aW5kb3cgYmVjYXVzZSBjYW52YXMgY2Fubm90IGhhdmUgZm9jdXNcclxuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb2RlID0gX3RoaXMuX25vcm1hbGl6ZUtleUNvZGUoZXYua2V5Q29kZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2tleXMuaW5kZXhPZihjb2RlKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fa2V5cy5wdXNoKGNvZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9rZXlzRG93bi5wdXNoKGNvZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXlFdmVudCA9IG5ldyBLZXlFdmVudChjb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ldmVudERpc3BhdGNoZXIuZW1pdCgnZG93bicsIGtleUV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ldmVudERpc3BhdGNoZXIuZW1pdCgncHJlc3MnLCBrZXlFdmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgS2V5Ym9hcmQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gUmVzZXQga2V5c0Rvd24gYW5kIGtleXNVcCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGVcclxuICAgICAgICAgICAgdGhpcy5fa2V5c0Rvd24ubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fa2V5c1VwLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIC8vIEVtaXQgc3ludGhldGljIFwiaG9sZFwiIGV2ZW50XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fa2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIuZW1pdCgnaG9sZCcsIG5ldyBLZXlFdmVudCh0aGlzLl9rZXlzW2ldKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgbGlzdCBvZiBrZXlzIGJlaW5nIHByZXNzZWQgZG93blxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEtleWJvYXJkLnByb3RvdHlwZS5nZXRLZXlzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fa2V5cztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRlc3RzIGlmIGEgY2VydGFpbiBrZXkgd2FzIGp1c3QgcHJlc3NlZCB0aGlzIGZyYW1lLiBUaGlzIGlzIGNsZWFyZWQgYXQgdGhlIGVuZCBvZiB0aGUgdXBkYXRlIGZyYW1lLlxyXG4gICAgICAgICAqIEBwYXJhbSBrZXkgVGVzdCB3aGV0aGVyIGEga2V5IHdhcyBqdXN0IHByZXNzZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBLZXlib2FyZC5wcm90b3R5cGUud2FzUHJlc3NlZCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2tleXNEb3duLmluZGV4T2Yoa2V5KSA+IC0xO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVzdHMgaWYgYSBjZXJ0YWluIGtleSBpcyBoZWxkIGRvd24uIFRoaXMgaXMgcGVyc2lzdGVkIGJldHdlZW4gZnJhbWVzLlxyXG4gICAgICAgICAqIEBwYXJhbSBrZXkgIFRlc3Qgd2hldGhlciBhIGtleSBpcyBoZWxkIGRvd25cclxuICAgICAgICAgKi9cclxuICAgICAgICBLZXlib2FyZC5wcm90b3R5cGUuaXNIZWxkID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fa2V5cy5pbmRleE9mKGtleSkgPiAtMTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRlc3RzIGlmIGEgY2VydGFpbiBrZXkgd2FzIGp1c3QgcmVsZWFzZWQgdGhpcyBmcmFtZS4gVGhpcyBpcyBjbGVhcmVkIGF0IHRoZSBlbmQgb2YgdGhlIHVwZGF0ZSBmcmFtZS5cclxuICAgICAgICAgKiBAcGFyYW0ga2V5ICBUZXN0IHdoZXRoZXIgYSBrZXkgd2FzIGp1c3QgcmVsZWFzZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBLZXlib2FyZC5wcm90b3R5cGUud2FzUmVsZWFzZWQgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9rZXlzVXAuaW5kZXhPZihrZXkpID4gLTE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBOb3JtYWxpemVzIHNvbWUgYnJvd3NlciBldmVudCBrZXkgY29kZXMgdG8gbWFwIHRvIHN0YW5kYXJkIEV4Y2FsaWJ1ciBrZXkgY29kZXNcclxuICAgICAgICAgKiBAcGFyYW0gY29kZSBFdmVudCBrZXlDb2RlXHJcbiAgICAgICAgICogQHNlZSBodHRwOi8vdW5peHBhcGEuY29tL2pzL2tleS5odG1sXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgS2V5Ym9hcmQucHJvdG90eXBlLl9ub3JtYWxpemVLZXlDb2RlID0gZnVuY3Rpb24gKGNvZGUpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChjb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU5OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBLZXlzLlNlbWljb2xvbjtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBLZXlib2FyZDtcclxuICAgIH0oQ2xhc3NfNy5DbGFzcykpO1xyXG4gICAgZXhwb3J0cy5LZXlib2FyZCA9IEtleWJvYXJkO1xyXG59KTtcclxuZGVmaW5lKFwiSW5wdXQvSUVuZ2luZUlucHV0XCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbn0pO1xyXG4vKipcclxuICogUHJvdmlkZXMgc3VwcG9ydCBmb3IgbWljZSwga2V5Ym9hcmRzLCBhbmQgY29udHJvbGxlcnMuXHJcbiAqXHJcbiAqIFtbaW5jbHVkZTpJbnB1dC5tZF1dXHJcbiAqL1xyXG5kZWZpbmUoXCJJbnB1dC9JbmRleFwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIklucHV0L0dhbWVwYWRcIiwgXCJJbnB1dC9Qb2ludGVyXCIsIFwiSW5wdXQvS2V5Ym9hcmRcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBHYW1lcGFkXzEsIFBvaW50ZXJfMSwgS2V5Ym9hcmRfMSkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBmdW5jdGlvbiBfX2V4cG9ydChtKSB7XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZWRvY1xyXG4gICAgICovXHJcbiAgICBfX2V4cG9ydChHYW1lcGFkXzEpO1xyXG4gICAgX19leHBvcnQoUG9pbnRlcl8xKTtcclxuICAgIF9fZXhwb3J0KEtleWJvYXJkXzEpO1xyXG59KTtcclxuZGVmaW5lKFwiVXRpbC9JbmRleFwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIlV0aWwvVXRpbFwiLCBcIlV0aWwvRHJhd1V0aWxcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBVdGlsXzMsIGRyYXdVdGlsKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIGZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcclxuICAgICAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICBfX2V4cG9ydChVdGlsXzMpO1xyXG4gICAgZXhwb3J0cy5EcmF3VXRpbCA9IGRyYXdVdGlsO1xyXG59KTtcclxuZGVmaW5lKFwiVXRpbC9EZWNvcmF0b3JzXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiVXRpbC9Mb2dcIiwgXCJVdGlsL1V0aWxcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBMb2dfMTEsIFV0aWwpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBPYnNvbGV0ZSBkZWNvcmF0b3IgZm9yIG1hcmtpbmcgRXhjYWxpYnVyIG1ldGhvZHMgb2Jzb2xldGUsIHlvdSBjYW4gb3B0aW9uYWxseSBzcGVjaWZ5IGEgY3VzdG9tIG1lc3NhZ2UgYW5kL29yIGFsdGVybmF0ZSByZXBsYWNlbWVudFxyXG4gICAgICogbWV0aG9kIGRvIHRoZSBkZXByZWNhdGVkIG9uZS4gSW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL2pheXBoZWxwcy9jb3JlLWRlY29yYXRvcnMuanNcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gb2Jzb2xldGUob3B0aW9ucykge1xyXG4gICAgICAgIG9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7fSwgeyBtZXNzYWdlOiAnVGhpcyBtZXRob2Qgd2lsbCBiZSByZW1vdmVkIGluIGZ1dHVyZSB2ZXJzaW9ucyBvZiBFeGNhbGlidXIuJywgYWx0ZXJuYXRlTWV0aG9kOiBudWxsIH0sIG9wdGlvbnMpO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzY3JpcHRvcikge1xyXG4gICAgICAgICAgICBpZiAoISh0eXBlb2YgZGVzY3JpcHRvci52YWx1ZSA9PT0gJ2Z1bmN0aW9uJyB8fFxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIGRlc2NyaXB0b3IuZ2V0ID09PSAnZnVuY3Rpb24nIHx8XHJcbiAgICAgICAgICAgICAgICB0eXBlb2YgZGVzY3JpcHRvci5zZXQgPT09ICdmdW5jdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ09ubHkgZnVuY3Rpb25zL2dldHRlcnMvc2V0dGVycyBjYW4gYmUgbWFya2VkIGFzIG9ic29sZXRlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG1ldGhvZFNpZ25hdHVyZSA9IFwiXCIgKyAodGFyZ2V0Lm5hbWUgfHwgJycpICsgKHRhcmdldC5uYW1lID8gJy4nIDogJycpICsgcHJvcGVydHk7XHJcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbWV0aG9kU2lnbmF0dXJlICsgXCIgaXMgbWFya2VkIG9ic29sZXRlOiBcIiArIG9wdGlvbnMubWVzc2FnZSArXHJcbiAgICAgICAgICAgICAgICAob3B0aW9ucy5hbHRlcm5hdGVNZXRob2QgPyBcIiBVc2UgXCIgKyBvcHRpb25zLmFsdGVybmF0ZU1ldGhvZCArIFwiIGluc3RlYWRcIiA6ICcnKTtcclxuICAgICAgICAgICAgdmFyIG1ldGhvZCA9IFV0aWwuZXh0ZW5kKHt9LCBkZXNjcmlwdG9yKTtcclxuICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3IudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIG1ldGhvZC52YWx1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBMb2dfMTEuTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybihtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvci52YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtZXRob2Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3IuZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICBtZXRob2QuZ2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIExvZ18xMS5Mb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdG9yLmdldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGVzY3JpcHRvci5zZXQpIHtcclxuICAgICAgICAgICAgICAgIG1ldGhvZC5zZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgTG9nXzExLkxvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4obWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3Iuc2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBtZXRob2Q7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGV4cG9ydHMub2Jzb2xldGUgPSBvYnNvbGV0ZTtcclxufSk7XHJcbmRlZmluZShcIlV0aWwvRGV0ZWN0b3JcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJVdGlsL0xvZ1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIExvZ18xMikge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgaXMgdGhlIGxpc3Qgb2YgZmVhdHVyZXMgdGhhdCB3aWxsIGJlIHVzZWQgdG8gbG9nIHRoZSBzdXBwb3J0ZWRcclxuICAgICAqIGZlYXR1cmVzIHRvIHRoZSBjb25zb2xlIHdoZW4gRGV0ZWN0b3IubG9nQnJvd3NlckZlYXR1cmVzKCkgaXMgY2FsbGVkLlxyXG4gICAgICovXHJcbiAgICB2YXIgUkVQT1JURURfRkVBVFVSRVMgPSB7XHJcbiAgICAgICAgd2ViZ2w6ICdXZWJHTCcsXHJcbiAgICAgICAgd2ViYXVkaW86ICdXZWJBdWRpbycsXHJcbiAgICAgICAgZ2FtZXBhZGFwaTogJ0dhbWVwYWQgQVBJJ1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRXhjYWxpYnVyIGludGVybmFsIGZlYXR1cmUgZGV0ZWN0aW9uIGhlbHBlciBjbGFzc1xyXG4gICAgICovXHJcbiAgICB2YXIgRGV0ZWN0b3IgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIERldGVjdG9yKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9mZWF0dXJlcyA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuZmFpbGVkVGVzdHMgPSBbXTtcclxuICAgICAgICAgICAgLy8gY3JpdGljYWwgYnJvd3NlciBmZWF0dXJlcyByZXF1aXJlZCBmb3IgZXggdG8gcnVuXHJcbiAgICAgICAgICAgIHRoaXMuX2NyaXRpY2FsVGVzdHMgPSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUZXN0IGNhbnZhcy8yZCBjb250ZXh0IHN1cHBvcnRcclxuICAgICAgICAgICAgICAgIGNhbnZhc1N1cHBvcnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhIShlbGVtLmdldENvbnRleHQgJiYgZWxlbS5nZXRDb250ZXh0KCcyZCcpKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAvLyBUZXN0IGFycmF5IGJ1ZmZlciBzdXBwb3J0IGV4IHVzZXMgZm9yIGRvd25sb2FkaW5nIGJpbmFyeSBkYXRhXHJcbiAgICAgICAgICAgICAgICBhcnJheUJ1ZmZlclN1cHBvcnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsICcvJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHhoci5yZXNwb25zZVR5cGUgPT09ICdhcnJheWJ1ZmZlcic7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgLy8gVGVzdCBkYXRhIHVybHMgZXggdXNlcyBmb3Igc3ByaXRlc1xyXG4gICAgICAgICAgICAgICAgZGF0YVVybFN1cHBvcnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycpLmluZGV4T2YoJ2RhdGE6aW1hZ2UvcG5nJykgPT09IDA7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgLy8gVGVzdCBvYmplY3QgdXJsIHN1cHBvcnQgZm9yIGxvYWRpbmdcclxuICAgICAgICAgICAgICAgIG9iamVjdFVybFN1cHBvcnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCdVUkwnIGluIHdpbmRvdykgJiYgKCdyZXZva2VPYmplY3RVUkwnIGluIFVSTCkgJiYgKCdjcmVhdGVPYmplY3RVUkwnIGluIFVSTCk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgLy8gUkdCQSBzdXBwb3J0IGZvciBjb2xvcnNcclxuICAgICAgICAgICAgICAgIHJnYmFTdXBwb3J0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpLnN0eWxlO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLmNzc1RleHQgPSAnYmFja2dyb3VuZC1jb2xvcjpyZ2JhKDE1MCwyNTUsMTUwLC41KSc7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgnJyArIHN0eWxlLmJhY2tncm91bmRDb2xvcikuaW5kZXhPZigncmdiYScpID4gLTE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8vIHdhcm5pbmdzIGV4Y2FsaWJ1ciBwZXJmb3JtYW5jZSB3aWxsIGJlIGRlZ3JhZGVkXHJcbiAgICAgICAgICAgIHRoaXMuX3dhcm5pbmdUZXN0ID0ge1xyXG4gICAgICAgICAgICAgICAgd2ViQXVkaW9TdXBwb3J0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhKHdpbmRvdy5BdWRpb0NvbnRleHQgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cubW96QXVkaW9Db250ZXh0IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5tc0F1ZGlvQ29udGV4dCB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cub0F1ZGlvQ29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgd2ViZ2xTdXBwb3J0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gISEoZWxlbS5nZXRDb250ZXh0ICYmIGVsZW0uZ2V0Q29udGV4dCgnd2ViZ2wnKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuX2ZlYXR1cmVzID0gdGhpcy5fbG9hZEJyb3dzZXJGZWF0dXJlcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgbWFwIG9mIGN1cnJlbnRseSBzdXBwb3J0ZWQgYnJvd3NlciBmZWF0dXJlcy4gVGhpcyBtZXRob2RcclxuICAgICAgICAgKiB0cmVhdHMgdGhlIGZlYXR1cmVzIGFzIGEgc2luZ2xldG9uIGFuZCB3aWxsIG9ubHkgY2FsY3VsYXRlIGZlYXR1cmVcclxuICAgICAgICAgKiBzdXBwb3J0IGlmIGl0IGhhcyBub3QgcHJldmlvdXNseSBiZWVuIGRvbmUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRGV0ZWN0b3IucHJvdG90eXBlLmdldEJyb3dzZXJGZWF0dXJlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2ZlYXR1cmVzID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mZWF0dXJlcyA9IHRoaXMuX2xvYWRCcm93c2VyRmVhdHVyZXMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZmVhdHVyZXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXBvcnQgb24gbm9uLWNyaXRpY2FsIGJyb3dzZXIgc3VwcG9ydCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxyXG4gICAgICAgICAqIFVzZSBuYXRpdmUgYnJvd3NlciBjb25zb2xlIGNvbG9ycyBmb3IgdmlzaWJpbGl0eS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBEZXRlY3Rvci5wcm90b3R5cGUubG9nQnJvd3NlckZlYXR1cmVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbXNnID0gJyVjU1VQUE9SVEVEIEJST1dTRVIgRkVBVFVSRVNcXG49PT09PT09PT09PT09PT09PT09PT09PT09PSVjXFxuJztcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXHJcbiAgICAgICAgICAgICAgICAnZm9udC13ZWlnaHQ6IGJvbGQ7IGNvbG9yOiBuYXZ5JyxcclxuICAgICAgICAgICAgICAgICdmb250LXdlaWdodDogbm9ybWFsOyBjb2xvcjogaW5oZXJpdCdcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgdmFyIHN1cHBvcnRlZCA9IHRoaXMuZ2V0QnJvd3NlckZlYXR1cmVzKCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3Qua2V5cyhSRVBPUlRFRF9GRUFUVVJFUyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmVhdHVyZSA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgIGlmIChzdXBwb3J0ZWRbZmVhdHVyZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBtc2cgKz0gJyglY1xcdTI3MTMlYyknOyAvLyAo4pyTKVxyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaCgnZm9udC13ZWlnaHQ6IGJvbGQ7IGNvbG9yOiBncmVlbicpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaCgnZm9udC13ZWlnaHQ6IG5vcm1hbDsgY29sb3I6IGluaGVyaXQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG1zZyArPSAnKCVjXFx1MjcxNyVjKSc7IC8vICjinJcpXHJcbiAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKCdmb250LXdlaWdodDogYm9sZDsgY29sb3I6IHJlZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaCgnZm9udC13ZWlnaHQ6IG5vcm1hbDsgY29sb3I6IGluaGVyaXQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIDtcclxuICAgICAgICAgICAgICAgIG1zZyArPSAnICcgKyBSRVBPUlRFRF9GRUFUVVJFU1tmZWF0dXJlXSArICdcXG4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFyZ3MudW5zaGlmdChtc2cpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmdzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEV4ZWN1dGVzIHNldmVyYWwgSUlGRSdzIHRvIGdldCBhIGNvbnN0YW50IHJlZmVyZW5jZSB0byBzdXBwb3J0ZWRcclxuICAgICAgICAgKiBmZWF0dXJlcyB3aXRoaW4gdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGNvbnRleHQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRGV0ZWN0b3IucHJvdG90eXBlLl9sb2FkQnJvd3NlckZlYXR1cmVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgLy8gSUlGRSB0byBjaGVjayBjYW52YXMgc3VwcG9ydFxyXG4gICAgICAgICAgICAgICAgY2FudmFzOiAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fY3JpdGljYWxUZXN0cy5jYW52YXNTdXBwb3J0KCk7XHJcbiAgICAgICAgICAgICAgICB9KSgpLFxyXG4gICAgICAgICAgICAgICAgLy8gSUlGRSB0byBjaGVjayBhcnJheWJ1ZmZlciBzdXBwb3J0XHJcbiAgICAgICAgICAgICAgICBhcnJheWJ1ZmZlcjogKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2NyaXRpY2FsVGVzdHMuYXJyYXlCdWZmZXJTdXBwb3J0KCk7XHJcbiAgICAgICAgICAgICAgICB9KSgpLFxyXG4gICAgICAgICAgICAgICAgLy8gSUlGRSB0byBjaGVjayBkYXRhdXJsIHN1cHBvcnRcclxuICAgICAgICAgICAgICAgIGRhdGF1cmw6IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9jcml0aWNhbFRlc3RzLmRhdGFVcmxTdXBwb3J0KCk7XHJcbiAgICAgICAgICAgICAgICB9KSgpLFxyXG4gICAgICAgICAgICAgICAgLy8gSUlGRSB0byBjaGVjayBvYmplY3R1cmwgc3VwcG9ydFxyXG4gICAgICAgICAgICAgICAgb2JqZWN0dXJsOiAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fY3JpdGljYWxUZXN0cy5vYmplY3RVcmxTdXBwb3J0KCk7XHJcbiAgICAgICAgICAgICAgICB9KSgpLFxyXG4gICAgICAgICAgICAgICAgLy8gSUlGRSB0byBjaGVjayByZ2JhIHN1cHBvcnRcclxuICAgICAgICAgICAgICAgIHJnYmE6IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9jcml0aWNhbFRlc3RzLnJnYmFTdXBwb3J0KCk7XHJcbiAgICAgICAgICAgICAgICB9KSgpLFxyXG4gICAgICAgICAgICAgICAgLy8gSUlGRSB0byBjaGVjayB3ZWJhdWRpbyBzdXBwb3J0XHJcbiAgICAgICAgICAgICAgICB3ZWJhdWRpbzogKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX3dhcm5pbmdUZXN0LndlYkF1ZGlvU3VwcG9ydCgpO1xyXG4gICAgICAgICAgICAgICAgfSkoKSxcclxuICAgICAgICAgICAgICAgIC8vIElJRkUgdG8gY2hlY2sgd2ViZ2wgc3VwcG9ydFxyXG4gICAgICAgICAgICAgICAgd2ViZ2w6IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl93YXJuaW5nVGVzdC53ZWJnbFN1cHBvcnQoKTtcclxuICAgICAgICAgICAgICAgIH0pKCksXHJcbiAgICAgICAgICAgICAgICAvLyBJSUZFIHRvIGNoZWNrIGdhbWVwYWRhcGkgc3VwcG9ydFxyXG4gICAgICAgICAgICAgICAgZ2FtZXBhZGFwaTogKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gISFuYXZpZ2F0b3IuZ2V0R2FtZXBhZHM7XHJcbiAgICAgICAgICAgICAgICB9KSgpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICBEZXRlY3Rvci5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gQ3JpdGljYWwgdGVzdCB3aWxsIGZvciBleCBub3QgdG8gcnVuXHJcbiAgICAgICAgICAgIHZhciBmYWlsZWRDcml0aWNhbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBmb3IgKHZhciB0ZXN0IGluIHRoaXMuX2NyaXRpY2FsVGVzdHMpIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fY3JpdGljYWxUZXN0c1t0ZXN0XS5jYWxsKHRoaXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWlsZWRUZXN0cy5wdXNoKHRlc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIExvZ18xMi5Mb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcignQ3JpdGljYWwgYnJvd3NlciBmZWF0dXJlIG1pc3NpbmcsIEV4Y2FsaWJ1ciByZXF1aXJlczonLCB0ZXN0KTtcclxuICAgICAgICAgICAgICAgICAgICBmYWlsZWRDcml0aWNhbCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGZhaWxlZENyaXRpY2FsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gV2FybmluZyB0ZXN0cyBkbyBub3QgZm9yIGV4IHRvIHJldHVybiBmYWxzZSB0byBjb21wYXRpYmlsaXR5XHJcbiAgICAgICAgICAgIGZvciAodmFyIHdhcm5pbmcgaW4gdGhpcy5fd2FybmluZ1Rlc3QpIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fd2FybmluZ1Rlc3Rbd2FybmluZ10oKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIExvZ18xMi5Mb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKCdXYXJuaW5nIGJyb3dzZXIgZmVhdHVyZSBtaXNzaW5nLCBFeGNhbGlidXIgd2lsbCBoYXZlIHJlZHVjZWQgcGVyZm9ybWFuY2U6Jywgd2FybmluZyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gRGV0ZWN0b3I7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5EZXRlY3RvciA9IERldGVjdG9yO1xyXG59KTtcclxuZGVmaW5lKFwiVXRpbC9Tb3J0ZWRMaXN0XCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEEgc29ydGVkIGxpc3QgaW1wbGVtZW50YXRpb24uIE5PVEU6IHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IHNlbGYtYmFsYW5jaW5nXHJcbiAgICAgKi9cclxuICAgIHZhciBTb3J0ZWRMaXN0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBTb3J0ZWRMaXN0KGdldENvbXBhcmFibGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fZ2V0Q29tcGFyYWJsZSA9IGdldENvbXBhcmFibGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFNvcnRlZExpc3QucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZmluZCh0aGlzLl9yb290LCBlbGVtZW50KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNvcnRlZExpc3QucHJvdG90eXBlLl9maW5kID0gZnVuY3Rpb24gKG5vZGUsIGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2dldENvbXBhcmFibGUuY2FsbChlbGVtZW50KSA9PT0gbm9kZS5nZXRLZXkoKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuZ2V0RGF0YSgpLmluZGV4T2YoZWxlbWVudCkgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2dldENvbXBhcmFibGUuY2FsbChlbGVtZW50KSA8IG5vZGUuZ2V0S2V5KCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9maW5kKG5vZGUuZ2V0TGVmdCgpLCBlbGVtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9maW5kKG5vZGUuZ2V0UmlnaHQoKSwgZWxlbWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIHJldHVybnMgdGhlIGFycmF5IG9mIGVsZW1lbnRzIGF0IGEgc3BlY2lmaWMga2V5IHZhbHVlXHJcbiAgICAgICAgU29ydGVkTGlzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0KHRoaXMuX3Jvb3QsIGtleSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTb3J0ZWRMaXN0LnByb3RvdHlwZS5fZ2V0ID0gZnVuY3Rpb24gKG5vZGUsIGtleSkge1xyXG4gICAgICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBub2RlLmdldEtleSgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5nZXREYXRhKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5IDwgbm9kZS5nZXRLZXkoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldChub2RlLmdldExlZnQoKSwga2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXQobm9kZS5nZXRSaWdodCgpLCBrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTb3J0ZWRMaXN0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fcm9vdCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yb290ID0gbmV3IEJpbmFyeVRyZWVOb2RlKHRoaXMuX2dldENvbXBhcmFibGUuY2FsbChlbGVtZW50KSwgW2VsZW1lbnRdLCBudWxsLCBudWxsKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydCh0aGlzLl9yb290LCBlbGVtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgU29ydGVkTGlzdC5wcm90b3R5cGUuX2luc2VydCA9IGZ1bmN0aW9uIChub2RlLCBlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9nZXRDb21wYXJhYmxlLmNhbGwoZWxlbWVudCkgPT09IG5vZGUuZ2V0S2V5KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5nZXREYXRhKCkuaW5kZXhPZihlbGVtZW50KSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gdGhlIGVsZW1lbnQgd2UncmUgdHJ5aW5nIHRvIGluc2VydCBhbHJlYWR5IGV4aXN0c1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5nZXREYXRhKCkucHVzaChlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fZ2V0Q29tcGFyYWJsZS5jYWxsKGVsZW1lbnQpIDwgbm9kZS5nZXRLZXkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmdldExlZnQoKSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0TGVmdChuZXcgQmluYXJ5VHJlZU5vZGUodGhpcy5fZ2V0Q29tcGFyYWJsZS5jYWxsKGVsZW1lbnQpLCBbZWxlbWVudF0sIG51bGwsIG51bGwpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0KG5vZGUuZ2V0TGVmdCgpLCBlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5nZXRSaWdodCgpID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRSaWdodChuZXcgQmluYXJ5VHJlZU5vZGUodGhpcy5fZ2V0Q29tcGFyYWJsZS5jYWxsKGVsZW1lbnQpLCBbZWxlbWVudF0sIG51bGwsIG51bGwpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0KG5vZGUuZ2V0UmlnaHQoKSwgZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNvcnRlZExpc3QucHJvdG90eXBlLnJlbW92ZUJ5Q29tcGFyYWJsZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jvb3QgPSB0aGlzLl9yZW1vdmUodGhpcy5fcm9vdCwgZWxlbWVudCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTb3J0ZWRMaXN0LnByb3RvdHlwZS5fcmVtb3ZlID0gZnVuY3Rpb24gKG5vZGUsIGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fZ2V0Q29tcGFyYWJsZS5jYWxsKGVsZW1lbnQpID09PSBub2RlLmdldEtleSgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudEluZGV4ID0gbm9kZS5nZXREYXRhKCkuaW5kZXhPZihlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBub2RlIGNvbnRhaW5zIHRoZSBlbGVtZW50LCByZW1vdmUgdGhlIGVsZW1lbnRcclxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50SW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuZ2V0RGF0YSgpLnNwbGljZShlbGVtZW50SW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgcmVtb3ZlZCB0aGUgbGFzdCBlbGVtZW50IGF0IHRoaXMgbm9kZSwgcmVtb3ZlIHRoZSBub2RlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuZ2V0RGF0YSgpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgbm9kZSBpcyBhIGxlYWZcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuZ2V0TGVmdCgpID09IG51bGwgJiYgbm9kZS5nZXRSaWdodCgpID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUuZ2V0TGVmdCgpID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmdldFJpZ2h0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5nZXRSaWdodCgpID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmdldExlZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBub2RlIGhhcyAyIGNoaWxkcmVuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wID0gdGhpcy5fZmluZE1pbk5vZGUobm9kZS5nZXRSaWdodCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRLZXkodGVtcC5nZXRLZXkoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0RGF0YSh0ZW1wLmdldERhdGEoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0UmlnaHQodGhpcy5fY2xlYW51cChub2RlLmdldFJpZ2h0KCksIHRlbXApKTsgLy9cImNsZWFudXAgbm9kZXNcIiAobW92ZSB0aGVtIHVwIHJlY3Vyc2l2ZWx5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgcHJldmVudHMgdGhlIG5vZGUgZnJvbSBiZWluZyByZW1vdmVkIHNpbmNlIGl0IHN0aWxsIGNvbnRhaW5zIGVsZW1lbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9nZXRDb21wYXJhYmxlLmNhbGwoZWxlbWVudCkgPCBub2RlLmdldEtleSgpKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLnNldExlZnQodGhpcy5fcmVtb3ZlKG5vZGUuZ2V0TGVmdCgpLCBlbGVtZW50KSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5vZGUuc2V0UmlnaHQodGhpcy5fcmVtb3ZlKG5vZGUuZ2V0UmlnaHQoKSwgZWxlbWVudCkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBjYWxsZWQgb25jZSB3ZSBoYXZlIHN1Y2Nlc3NmdWxseSByZW1vdmVkIHRoZSBlbGVtZW50IHdlIHdhbnRlZCwgcmVjdXJzaXZlbHkgY29ycmVjdHMgdGhlIHBhcnQgb2YgdGhlIHRyZWUgYmVsb3cgdGhlIHJlbW92ZWQgbm9kZVxyXG4gICAgICAgIFNvcnRlZExpc3QucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24gKG5vZGUsIGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdmFyIGNvbXBhcmFibGUgPSBlbGVtZW50LmdldEtleSgpO1xyXG4gICAgICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjb21wYXJhYmxlID09PSBub2RlLmdldEtleSgpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgbm9kZSBpcyBhIGxlYWZcclxuICAgICAgICAgICAgICAgIGlmIChub2RlLmdldExlZnQoKSA9PSBudWxsICYmIG5vZGUuZ2V0UmlnaHQoKSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlLmdldExlZnQoKSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuZ2V0UmlnaHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUuZ2V0UmlnaHQoKSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuZ2V0TGVmdCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gaWYgbm9kZSBoYXMgMiBjaGlsZHJlblxyXG4gICAgICAgICAgICAgICAgdmFyIHRlbXAgPSB0aGlzLl9maW5kTWluTm9kZShub2RlLmdldFJpZ2h0KCkpO1xyXG4gICAgICAgICAgICAgICAgbm9kZS5zZXRLZXkodGVtcC5nZXRLZXkoKSk7XHJcbiAgICAgICAgICAgICAgICBub2RlLnNldERhdGEodGVtcC5nZXREYXRhKCkpO1xyXG4gICAgICAgICAgICAgICAgbm9kZS5zZXRSaWdodCh0aGlzLl9jbGVhbnVwKG5vZGUuZ2V0UmlnaHQoKSwgdGVtcCkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fZ2V0Q29tcGFyYWJsZS5jYWxsKGVsZW1lbnQpIDwgbm9kZS5nZXRLZXkoKSkge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5zZXRMZWZ0KHRoaXMuX2NsZWFudXAobm9kZS5nZXRMZWZ0KCksIGVsZW1lbnQpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5zZXRSaWdodCh0aGlzLl9jbGVhbnVwKG5vZGUuZ2V0UmlnaHQoKSwgZWxlbWVudCkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFNvcnRlZExpc3QucHJvdG90eXBlLl9maW5kTWluTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gbm9kZTtcclxuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQuZ2V0TGVmdCgpICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmdldExlZnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY3VycmVudDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNvcnRlZExpc3QucHJvdG90eXBlLmxpc3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2xpc3QodGhpcy5fcm9vdCwgcmVzdWx0cyk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgU29ydGVkTGlzdC5wcm90b3R5cGUuX2xpc3QgPSBmdW5jdGlvbiAodHJlZU5vZGUsIHJlc3VsdHMpIHtcclxuICAgICAgICAgICAgaWYgKHRyZWVOb2RlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xpc3QodHJlZU5vZGUuZ2V0TGVmdCgpLCByZXN1bHRzKTtcclxuICAgICAgICAgICAgICAgIHRyZWVOb2RlLmdldERhdGEoKS5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0KHRyZWVOb2RlLmdldFJpZ2h0KCksIHJlc3VsdHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gU29ydGVkTGlzdDtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLlNvcnRlZExpc3QgPSBTb3J0ZWRMaXN0O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIHRyZWUgbm9kZSBwYXJ0IG9mIFtbU29ydGVkTGlzdF1dXHJcbiAgICAgKi9cclxuICAgIHZhciBCaW5hcnlUcmVlTm9kZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gQmluYXJ5VHJlZU5vZGUoa2V5LCBkYXRhLCBsZWZ0LCByaWdodCkge1xyXG4gICAgICAgICAgICB0aGlzLl9rZXkgPSBrZXk7XHJcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xyXG4gICAgICAgICAgICB0aGlzLl9sZWZ0ID0gbGVmdDtcclxuICAgICAgICAgICAgdGhpcy5fcmlnaHQgPSByaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgQmluYXJ5VHJlZU5vZGUucHJvdG90eXBlLmdldEtleSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2tleTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEJpbmFyeVRyZWVOb2RlLnByb3RvdHlwZS5zZXRLZXkgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2tleSA9IGtleTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEJpbmFyeVRyZWVOb2RlLnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEJpbmFyeVRyZWVOb2RlLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBCaW5hcnlUcmVlTm9kZS5wcm90b3R5cGUuZ2V0TGVmdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xlZnQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBCaW5hcnlUcmVlTm9kZS5wcm90b3R5cGUuc2V0TGVmdCA9IGZ1bmN0aW9uIChsZWZ0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xlZnQgPSBsZWZ0O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQmluYXJ5VHJlZU5vZGUucHJvdG90eXBlLmdldFJpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmlnaHQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBCaW5hcnlUcmVlTm9kZS5wcm90b3R5cGUuc2V0UmlnaHQgPSBmdW5jdGlvbiAocmlnaHQpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmlnaHQgPSByaWdodDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBCaW5hcnlUcmVlTm9kZTtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkJpbmFyeVRyZWVOb2RlID0gQmluYXJ5VHJlZU5vZGU7XHJcbiAgICAvKipcclxuICAgICAqIE1vY2sgZWxlbWVudCBmb3IgdGVzdGluZ1xyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICB2YXIgTW9ja2VkRWxlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gTW9ja2VkRWxlbWVudChrZXkpIHtcclxuICAgICAgICAgICAgdGhpcy5fa2V5ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fa2V5ID0ga2V5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBNb2NrZWRFbGVtZW50LnByb3RvdHlwZS5nZXRUaGVLZXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9rZXk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBNb2NrZWRFbGVtZW50LnByb3RvdHlwZS5zZXRLZXkgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2tleSA9IGtleTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBNb2NrZWRFbGVtZW50O1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuTW9ja2VkRWxlbWVudCA9IE1vY2tlZEVsZW1lbnQ7XHJcbn0pO1xyXG5kZWZpbmUoXCJJbmRleFwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkFjdG9yXCIsIFwiQWxnZWJyYVwiLCBcIkNhbWVyYVwiLCBcIkNsYXNzXCIsIFwiQ29uZmlndXJhYmxlXCIsIFwiRGVidWdcIiwgXCJFbmdpbmVcIiwgXCJFdmVudERpc3BhdGNoZXJcIiwgXCJFdmVudHNcIiwgXCJHcm91cFwiLCBcIkxhYmVsXCIsIFwiTG9hZGVyXCIsIFwiUGFydGljbGVzXCIsIFwiUGh5c2ljc1wiLCBcIlByb21pc2VzXCIsIFwiU2NlbmVcIiwgXCJUaWxlTWFwXCIsIFwiVGltZXJcIiwgXCJUcmlnZ2VyXCIsIFwiVUlBY3RvclwiLCBcIkFjdGlvbnMvSW5kZXhcIiwgXCJDb2xsaXNpb24vSW5kZXhcIiwgXCJEcmF3aW5nL0luZGV4XCIsIFwiTWF0aC9JbmRleFwiLCBcIlBvc3RQcm9jZXNzaW5nL0luZGV4XCIsIFwiUmVzb3VyY2VzL0luZGV4XCIsIFwiRXZlbnRzXCIsIFwiSW5wdXQvSW5kZXhcIiwgXCJUcmFpdHMvSW5kZXhcIiwgXCJVdGlsL0luZGV4XCIsIFwiVXRpbC9EZWNvcmF0b3JzXCIsIFwiVXRpbC9EZXRlY3RvclwiLCBcIlV0aWwvQ3VsbGluZ0JveFwiLCBcIlV0aWwvRWFzaW5nRnVuY3Rpb25zXCIsIFwiVXRpbC9Mb2dcIiwgXCJVdGlsL1NvcnRlZExpc3RcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBBY3Rvcl8xMSwgQWxnZWJyYV8yMSwgQ2FtZXJhXzEsIENsYXNzXzgsIENvbmZpZ3VyYWJsZV83LCBEZWJ1Z18xLCBFbmdpbmVfMywgRXZlbnREaXNwYXRjaGVyXzIsIEV2ZW50c18xMSwgR3JvdXBfMSwgTGFiZWxfMiwgTG9hZGVyXzEsIFBhcnRpY2xlc18xLCBQaHlzaWNzXzExLCBQcm9taXNlc183LCBTY2VuZV8xLCBUaWxlTWFwXzEsIFRpbWVyXzEsIFRyaWdnZXJfMSwgVUlBY3Rvcl8yLCBJbmRleF8xLCBJbmRleF8yLCBJbmRleF8zLCBJbmRleF80LCBJbmRleF81LCBJbmRleF82LCBldmVudHMsIGlucHV0LCB0cmFpdHMsIHV0aWwsIERlY29yYXRvcnNfMSwgRGV0ZWN0b3JfMSwgQ3VsbGluZ0JveF8yLCBFYXNpbmdGdW5jdGlvbnNfMywgTG9nXzEzLCBTb3J0ZWRMaXN0XzEpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGN1cnJlbnQgRXhjYWxpYnVyIHZlcnNpb24gc3RyaW5nXHJcbiAgICAgKi9cclxuICAgIGV4cG9ydHMuRVhfVkVSU0lPTiA9ICcwLjE1LjAnO1xyXG4gICAgZXhwb3J0cy5BY3RvciA9IEFjdG9yXzExLkFjdG9yO1xyXG4gICAgZXhwb3J0cy5Db2xsaXNpb25UeXBlID0gQWN0b3JfMTEuQ29sbGlzaW9uVHlwZTtcclxuICAgIF9fZXhwb3J0KEFsZ2VicmFfMjEpO1xyXG4gICAgX19leHBvcnQoQ2FtZXJhXzEpO1xyXG4gICAgX19leHBvcnQoQ2xhc3NfOCk7XHJcbiAgICBfX2V4cG9ydChDb25maWd1cmFibGVfNyk7XHJcbiAgICBfX2V4cG9ydChEZWJ1Z18xKTtcclxuICAgIF9fZXhwb3J0KEVuZ2luZV8zKTtcclxuICAgIF9fZXhwb3J0KEV2ZW50RGlzcGF0Y2hlcl8yKTtcclxuICAgIF9fZXhwb3J0KEV2ZW50c18xMSk7XHJcbiAgICBfX2V4cG9ydChHcm91cF8xKTtcclxuICAgIGV4cG9ydHMuTGFiZWwgPSBMYWJlbF8yLkxhYmVsO1xyXG4gICAgZXhwb3J0cy5Gb250U3R5bGUgPSBMYWJlbF8yLkZvbnRTdHlsZTtcclxuICAgIGV4cG9ydHMuRm9udFVuaXQgPSBMYWJlbF8yLkZvbnRVbml0O1xyXG4gICAgZXhwb3J0cy5UZXh0QWxpZ24gPSBMYWJlbF8yLlRleHRBbGlnbjtcclxuICAgIGV4cG9ydHMuQmFzZUFsaWduID0gTGFiZWxfMi5CYXNlQWxpZ247XHJcbiAgICBfX2V4cG9ydChMb2FkZXJfMSk7XHJcbiAgICBleHBvcnRzLlBhcnRpY2xlID0gUGFydGljbGVzXzEuUGFydGljbGU7XHJcbiAgICBleHBvcnRzLlBhcnRpY2xlRW1pdHRlciA9IFBhcnRpY2xlc18xLlBhcnRpY2xlRW1pdHRlcjtcclxuICAgIGV4cG9ydHMuRW1pdHRlclR5cGUgPSBQYXJ0aWNsZXNfMS5FbWl0dGVyVHlwZTtcclxuICAgIF9fZXhwb3J0KFBoeXNpY3NfMTEpO1xyXG4gICAgX19leHBvcnQoUHJvbWlzZXNfNyk7XHJcbiAgICBfX2V4cG9ydChTY2VuZV8xKTtcclxuICAgIGV4cG9ydHMuVGlsZU1hcCA9IFRpbGVNYXBfMS5UaWxlTWFwO1xyXG4gICAgZXhwb3J0cy5DZWxsID0gVGlsZU1hcF8xLkNlbGw7XHJcbiAgICBleHBvcnRzLlRpbGVTcHJpdGUgPSBUaWxlTWFwXzEuVGlsZVNwcml0ZTtcclxuICAgIF9fZXhwb3J0KFRpbWVyXzEpO1xyXG4gICAgX19leHBvcnQoVHJpZ2dlcl8xKTtcclxuICAgIF9fZXhwb3J0KFVJQWN0b3JfMik7XHJcbiAgICBfX2V4cG9ydChJbmRleF8xKTtcclxuICAgIF9fZXhwb3J0KEluZGV4XzIpO1xyXG4gICAgX19leHBvcnQoSW5kZXhfMyk7XHJcbiAgICBfX2V4cG9ydChJbmRleF80KTtcclxuICAgIF9fZXhwb3J0KEluZGV4XzUpO1xyXG4gICAgX19leHBvcnQoSW5kZXhfNik7XHJcbiAgICBleHBvcnRzLkV2ZW50cyA9IGV2ZW50cztcclxuICAgIGV4cG9ydHMuSW5wdXQgPSBpbnB1dDtcclxuICAgIGV4cG9ydHMuVHJhaXRzID0gdHJhaXRzO1xyXG4gICAgZXhwb3J0cy5VdGlsID0gdXRpbDtcclxuICAgIF9fZXhwb3J0KERlY29yYXRvcnNfMSk7XHJcbiAgICBfX2V4cG9ydChEZXRlY3Rvcl8xKTtcclxuICAgIF9fZXhwb3J0KEN1bGxpbmdCb3hfMik7XHJcbiAgICBfX2V4cG9ydChFYXNpbmdGdW5jdGlvbnNfMyk7XHJcbiAgICBfX2V4cG9ydChMb2dfMTMpO1xyXG4gICAgX19leHBvcnQoU29ydGVkTGlzdF8xKTtcclxufSk7XHJcbmRlZmluZShcIkVuZ2luZVwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkluZGV4XCIsIFwiUHJvbWlzZXNcIiwgXCJBbGdlYnJhXCIsIFwiVUlBY3RvclwiLCBcIkFjdG9yXCIsIFwiVGltZXJcIiwgXCJUaWxlTWFwXCIsIFwiTG9hZGVyXCIsIFwiVXRpbC9EZXRlY3RvclwiLCBcIkV2ZW50c1wiLCBcIlV0aWwvTG9nXCIsIFwiRHJhd2luZy9Db2xvclwiLCBcIlNjZW5lXCIsIFwiRGVidWdcIiwgXCJDbGFzc1wiLCBcIklucHV0L0luZGV4XCIsIFwiVXRpbC9VdGlsXCIsIFwiQ29sbGlzaW9uL0JvdW5kaW5nQm94XCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgSW5kZXhfNywgUHJvbWlzZXNfOCwgQWxnZWJyYV8yMiwgVUlBY3Rvcl8zLCBBY3Rvcl8xMiwgVGltZXJfMiwgVGlsZU1hcF8yLCBMb2FkZXJfMiwgRGV0ZWN0b3JfMiwgRXZlbnRzXzEyLCBMb2dfMTQsIENvbG9yXzE5LCBTY2VuZV8yLCBEZWJ1Z18yLCBDbGFzc185LCBJbnB1dCwgVXRpbCwgQm91bmRpbmdCb3hfNykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEVudW0gcmVwcmVzZW50aW5nIHRoZSBkaWZmZXJlbnQgZGlzcGxheSBtb2RlcyBhdmFpbGFibGUgdG8gRXhjYWxpYnVyXHJcbiAgICAgKi9cclxuICAgIHZhciBEaXNwbGF5TW9kZTtcclxuICAgIChmdW5jdGlvbiAoRGlzcGxheU1vZGUpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTaG93IHRoZSBnYW1lIGFzIGZ1bGwgc2NyZWVuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRGlzcGxheU1vZGVbRGlzcGxheU1vZGVbXCJGdWxsU2NyZWVuXCJdID0gMF0gPSBcIkZ1bGxTY3JlZW5cIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTY2FsZSB0aGUgZ2FtZSB0byB0aGUgcGFyZW50IERPTSBjb250YWluZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBEaXNwbGF5TW9kZVtEaXNwbGF5TW9kZVtcIkNvbnRhaW5lclwiXSA9IDFdID0gXCJDb250YWluZXJcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTaG93IHRoZSBnYW1lIGFzIGEgZml4ZWQgc2l6ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERpc3BsYXlNb2RlW0Rpc3BsYXlNb2RlW1wiRml4ZWRcIl0gPSAyXSA9IFwiRml4ZWRcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbGxvdyB0aGUgZ2FtZSB0byBiZSBwb3NpdGlvbmVkIHdpdGggdGhlIFtbSUVuZ2luZU9wdGlvbnMucG9zaXRpb25dXSBvcHRpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBEaXNwbGF5TW9kZVtEaXNwbGF5TW9kZVtcIlBvc2l0aW9uXCJdID0gM10gPSBcIlBvc2l0aW9uXCI7XHJcbiAgICB9KShEaXNwbGF5TW9kZSA9IGV4cG9ydHMuRGlzcGxheU1vZGUgfHwgKGV4cG9ydHMuRGlzcGxheU1vZGUgPSB7fSkpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFbnVtIHJlcHJlc2VudGluZyB0aGUgZGlmZmVyZW50IG1vdXNld2hlZWwgZXZlbnQgYnViYmxlIHByZXZlbnRpb25cclxuICAgICAqL1xyXG4gICAgdmFyIFNjcm9sbFByZXZlbnRpb25Nb2RlO1xyXG4gICAgKGZ1bmN0aW9uIChTY3JvbGxQcmV2ZW50aW9uTW9kZSkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERvIG5vdCBwcmV2ZW50IGFueSBwYWdlIHNjcm9sbGluZ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNjcm9sbFByZXZlbnRpb25Nb2RlW1Njcm9sbFByZXZlbnRpb25Nb2RlW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJldmVudCBwYWdlIHNjcm9sbCBpZiBtb3VzZSBpcyBvdmVyIHRoZSBnYW1lIGNhbnZhc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNjcm9sbFByZXZlbnRpb25Nb2RlW1Njcm9sbFByZXZlbnRpb25Nb2RlW1wiQ2FudmFzXCJdID0gMV0gPSBcIkNhbnZhc1wiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByZXZlbnQgYWxsIHBhZ2Ugc2Nyb2xsaW5nIHZpYSBtb3VzZSB3aGVlbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNjcm9sbFByZXZlbnRpb25Nb2RlW1Njcm9sbFByZXZlbnRpb25Nb2RlW1wiQWxsXCJdID0gMl0gPSBcIkFsbFwiO1xyXG4gICAgfSkoU2Nyb2xsUHJldmVudGlvbk1vZGUgPSBleHBvcnRzLlNjcm9sbFByZXZlbnRpb25Nb2RlIHx8IChleHBvcnRzLlNjcm9sbFByZXZlbnRpb25Nb2RlID0ge30pKTtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIEV4Y2FsaWJ1ciBFbmdpbmVcclxuICAgICAqXHJcbiAgICAgKiBUaGUgW1tFbmdpbmVdXSBpcyB0aGUgbWFpbiBkcml2ZXIgZm9yIGEgZ2FtZS4gSXQgaXMgcmVzcG9uc2libGUgZm9yXHJcbiAgICAgKiBzdGFydGluZy9zdG9wcGluZyB0aGUgZ2FtZSwgbWFpbnRhaW5pbmcgc3RhdGUsIHRyYW5zbWl0dGluZyBldmVudHMsXHJcbiAgICAgKiBsb2FkaW5nIHJlc291cmNlcywgYW5kIG1hbmFnaW5nIHRoZSBzY2VuZS5cclxuICAgICAqXHJcbiAgICAgKiBbW2luY2x1ZGU6RW5naW5lLm1kXV1cclxuICAgICAqL1xyXG4gICAgdmFyIEVuZ2luZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKEVuZ2luZSwgX3N1cGVyKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IGdhbWUgdXNpbmcgdGhlIGdpdmVuIFtbSUVuZ2luZU9wdGlvbnNdXS4gQnkgZGVmYXVsdCwgaWYgbm8gb3B0aW9ucyBhcmUgcHJvdmlkZWQsXHJcbiAgICAgICAgICogdGhlIGdhbWUgd2lsbCBiZSByZW5kZXJlZCBmdWxsIHNjcmVlbiAodGFraW5nIHVwIGFsbCBhdmFpbGFibGUgYnJvd3NlciB3aW5kb3cgc3BhY2UpLlxyXG4gICAgICAgICAqIFlvdSBjYW4gY3VzdG9taXplIHRoZSBnYW1lIHJlbmRlcmluZyB0aHJvdWdoIFtbSUVuZ2luZU9wdGlvbnNdXS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEV4YW1wbGU6XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBgYGBqc1xyXG4gICAgICAgICAqIHZhciBnYW1lID0gbmV3IGV4LkVuZ2luZSh7XHJcbiAgICAgICAgICogICB3aWR0aDogMCwgLy8gdGhlIHdpZHRoIG9mIHRoZSBjYW52YXNcclxuICAgICAgICAgKiAgIGhlaWdodDogMCwgLy8gdGhlIGhlaWdodCBvZiB0aGUgY2FudmFzXHJcbiAgICAgICAgICogICBjYW52YXNFbGVtZW50SWQ6ICcnLCAvLyB0aGUgRE9NIGNhbnZhcyBlbGVtZW50IElELCBpZiB5b3UgYXJlIHByb3ZpZGluZyB5b3VyIG93blxyXG4gICAgICAgICAqICAgZGlzcGxheU1vZGU6IGV4LkRpc3BsYXlNb2RlLkZ1bGxTY3JlZW4sIC8vIHRoZSBkaXNwbGF5IG1vZGVcclxuICAgICAgICAgKiAgIHBvaW50ZXJTY29wZTogZXguSW5wdXQuUG9pbnRlclNjb3BlLkRvY3VtZW50LCAvLyB0aGUgc2NvcGUgb2YgY2FwdHVyaW5nIHBvaW50ZXIgKG1vdXNlL3RvdWNoKSBldmVudHNcclxuICAgICAgICAgKiAgIGJhY2tncm91bmRDb2xvcjogZXguQ29sb3IuZnJvbUhleCgnIzIxODVkMCcpIC8vIGJhY2tncm91bmQgY29sb3Igb2YgdGhlIGVuZ2luZVxyXG4gICAgICAgICAqIH0pO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogLy8gY2FsbCBnYW1lLnN0YXJ0LCB3aGljaCBpcyBhIFByb21pc2VcclxuICAgICAgICAgKiBnYW1lLnN0YXJ0KCkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICogICAvLyByZWFkeSwgc2V0LCBnbyFcclxuICAgICAgICAgKiB9KTtcclxuICAgICAgICAgKiBgYGBcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBFbmdpbmUob3B0aW9ucykge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5faGFzU3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQWNjZXNzIEV4Y2FsaWJ1ciBkZWJ1Z2dpbmcgZnVuY3Rpb25hbGl0eS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmRlYnVnID0gbmV3IERlYnVnXzIuRGVidWcoKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbGlzdCBvZiBwb3N0IHByb2Nlc3NvcnMgdG8gYXBwbHkgYXQgdGhlIGVuZCBvZiBkcmF3aW5nIGEgZnJhbWUgKHN1Y2ggYXMgW1tDb2xvckJsaW5kQ29ycmVjdG9yXV0pXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5wb3N0UHJvY2Vzc29ycyA9IFtdO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ29udGFpbnMgYWxsIHRoZSBzY2VuZXMgY3VycmVudGx5IHJlZ2lzdGVyZWQgd2l0aCBFeGNhbGlidXJcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLnNjZW5lcyA9IHt9O1xyXG4gICAgICAgICAgICBfdGhpcy5fYW5pbWF0aW9ucyA9IFtdO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGVuZ2luZSBpcyBzZXQgdG8gZnVsbHNjcmVlbiBvciBub3RcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmlzRnVsbHNjcmVlbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW5kaWNhdGVzIHRoZSBjdXJyZW50IFtbRGlzcGxheU1vZGVdXSBvZiB0aGUgZW5naW5lLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuZGlzcGxheU1vZGUgPSBEaXNwbGF5TW9kZS5GdWxsU2NyZWVuO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgYXVkaW8gc2hvdWxkIGJlIHBhdXNlZCB3aGVuIHRoZSBnYW1lIGlzIG5vIGxvbmdlciB2aXNpYmxlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMucGF1c2VBdWRpb1doZW5IaWRkZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGVuZ2luZSBzaG91bGQgZHJhdyB3aXRoIGRlYnVnIGluZm9ybWF0aW9uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5pc0RlYnVnID0gZmFsc2U7XHJcbiAgICAgICAgICAgIF90aGlzLmRlYnVnQ29sb3IgPSBuZXcgQ29sb3JfMTkuQ29sb3IoMjU1LCAyNTUsIDI1NSk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgYWN0aW9uIHRvIHRha2Ugd2hlbiBhIGZhdGFsIGV4Y2VwdGlvbiBpcyB0aHJvd25cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLm9uRmF0YWxFeGNlcHRpb24gPSBmdW5jdGlvbiAoZSkgeyBMb2dfMTQuTG9nZ2VyLmdldEluc3RhbmNlKCkuZmF0YWwoZSk7IH07XHJcbiAgICAgICAgICAgIF90aGlzLl9pc1Ntb290aGluZ0VuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBfdGhpcy5fdGltZXNjYWxlID0gMS4wO1xyXG4gICAgICAgICAgICBfdGhpcy5faXNMb2FkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7fSwgRW5naW5lLl9EZWZhdWx0RW5naW5lT3B0aW9ucywgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIC8vIENoZWNrIGNvbXBhdGliaWxpdHkgXHJcbiAgICAgICAgICAgIHZhciBkZXRlY3RvciA9IG5ldyBEZXRlY3Rvcl8yLkRldGVjdG9yKCk7XHJcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5zdXBwcmVzc01pbmltdW1Ccm93c2VyRmVhdHVyZURldGVjdGlvbiAmJiAhKF90aGlzLl9jb21wYXRpYmxlID0gZGV0ZWN0b3IudGVzdCgpKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW5uZXJUZXh0ID0gJ1NvcnJ5LCB5b3VyIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBhbGwgdGhlIGZlYXR1cmVzIG5lZWRlZCBmb3IgRXhjYWxpYnVyJztcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICBkZXRlY3Rvci5mYWlsZWRUZXN0cy5mb3JFYWNoKGZ1bmN0aW9uICh0ZXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlc3RNZXNzYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVzdE1lc3NhZ2UuaW5uZXJUZXh0ID0gJ0Jyb3dzZXIgZmVhdHVyZSBtaXNzaW5nICcgKyB0ZXN0O1xyXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGVzdE1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jYW52YXNFbGVtZW50SWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQob3B0aW9ucy5jYW52YXNFbGVtZW50SWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYW52YXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoY2FudmFzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fY29tcGF0aWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVXNlIG5hdGl2ZSBjb25zb2xlIEFQSSBmb3IgY29sb3IgZnVuXHJcbiAgICAgICAgICAgIGlmIChjb25zb2xlLmxvZyAmJiAhb3B0aW9ucy5zdXBwcmVzc0NvbnNvbGVCb290TWVzc2FnZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCIlY1Bvd2VyZWQgYnkgRXhjYWxpYnVyLmpzICh2XCIgKyBJbmRleF83LkVYX1ZFUlNJT04gKyBcIilcIiwgJ2JhY2tncm91bmQ6ICMxNzZCQUE7IGNvbG9yOiB3aGl0ZTsgYm9yZGVyLXJhZGl1czogNXB4OyBwYWRkaW5nOiAxNXB4OyBmb250LXNpemU6IDEuNWVtOyBsaW5lLWhlaWdodDogODBweDsnKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdcXG5cXFxyXG4gICAgICAvfCBfX19fX19fX19fX19fX19fXFxuXFxcclxuT3w9PT18KiA+X19fX19fX19fX19fX19fXz5cXG5cXFxyXG4gICAgICBcXFxcfCcpO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1Zpc2l0JywgJ2h0dHA6Ly9leGNhbGlidXJqcy5jb20nLCAnZm9yIG1vcmUgaW5mb3JtYXRpb24nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy5fbG9nZ2VyID0gTG9nXzE0LkxvZ2dlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgICAgICAvLyBJZiBkZWJ1ZyBpcyBlbmFibGVkLCBsZXQncyBsb2cgYnJvd3NlciBmZWF0dXJlcyB0byB0aGUgY29uc29sZS5cclxuICAgICAgICAgICAgaWYgKF90aGlzLl9sb2dnZXIuZGVmYXVsdExldmVsID09PSBMb2dfMTQuTG9nTGV2ZWwuRGVidWcpIHtcclxuICAgICAgICAgICAgICAgIGRldGVjdG9yLmxvZ0Jyb3dzZXJGZWF0dXJlcygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuZGVidWcoJ0J1aWxkaW5nIGVuZ2luZS4uLicpO1xyXG4gICAgICAgICAgICBfdGhpcy5jYW52YXNFbGVtZW50SWQgPSBvcHRpb25zLmNhbnZhc0VsZW1lbnRJZDtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2FudmFzRWxlbWVudElkKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmRlYnVnKCdVc2luZyBDYW52YXMgZWxlbWVudCBzcGVjaWZpZWQ6ICcgKyBvcHRpb25zLmNhbnZhc0VsZW1lbnRJZCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5jYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChvcHRpb25zLmNhbnZhc0VsZW1lbnRJZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmRlYnVnKCdVc2luZyBnZW5lcmF0ZWQgY2FudmFzIGVsZW1lbnQnKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLndpZHRoICYmIG9wdGlvbnMuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kaXNwbGF5TW9kZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGlzcGxheU1vZGUgPSBEaXNwbGF5TW9kZS5GaXhlZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuZGVidWcoJ0VuZ2luZSB2aWV3cG9ydCBpcyBzaXplICcgKyBvcHRpb25zLndpZHRoICsgJyB4ICcgKyBvcHRpb25zLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5jYW52YXMud2lkdGggPSBvcHRpb25zLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY2FudmFzLmhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFvcHRpb25zLmRpc3BsYXlNb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmRlYnVnKCdFbmdpbmUgdmlld3BvcnQgaXMgZnVsbHNjcmVlbicpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZGlzcGxheU1vZGUgPSBEaXNwbGF5TW9kZS5GdWxsU2NyZWVuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmJhY2tncm91bmRDb2xvcikge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuYmFja2dyb3VuZENvbG9yID0gb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IuY2xvbmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy5fbG9hZGVyID0gbmV3IExvYWRlcl8yLkxvYWRlcigpO1xyXG4gICAgICAgICAgICBfdGhpcy5faW5pdGlhbGl6ZShvcHRpb25zKTtcclxuICAgICAgICAgICAgX3RoaXMucm9vdFNjZW5lID0gX3RoaXMuY3VycmVudFNjZW5lID0gbmV3IFNjZW5lXzIuU2NlbmUoX3RoaXMpO1xyXG4gICAgICAgICAgICBfdGhpcy5hZGRTY2VuZSgncm9vdCcsIF90aGlzLnJvb3RTY2VuZSk7XHJcbiAgICAgICAgICAgIF90aGlzLmdvVG9TY2VuZSgncm9vdCcpO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbmdpbmUucHJvdG90eXBlLCBcImNhbnZhc1dpZHRoXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgZ2FtZSBjYW52YXMgaW4gcGl4ZWxzIChwaHlzaWNhbCB3aWR0aCBjb21wb25lbnQgb2YgdGhlXHJcbiAgICAgICAgICAgICAqIHJlc29sdXRpb24gb2YgdGhlIGNhbnZhcyBlbGVtZW50KVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYW52YXMud2lkdGg7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbmdpbmUucHJvdG90eXBlLCBcImhhbGZDYW52YXNXaWR0aFwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXR1cm5zIGhhbGYgd2lkdGggb2YgdGhlIGdhbWUgY2FudmFzIGluIHBpeGVscyAoaGFsZiBwaHlzaWNhbCB3aWR0aCBjb21wb25lbnQpXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy53aWR0aCAvIDI7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbmdpbmUucHJvdG90eXBlLCBcImNhbnZhc0hlaWdodFwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBnYW1lIGNhbnZhcyBpbiBwaXhlbHMsIChwaHlzaWNhbCBoZWlnaHQgY29tcG9uZW50IG9mXHJcbiAgICAgICAgICAgICAqIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBjYW52YXMgZWxlbWVudClcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLmhlaWdodDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVuZ2luZS5wcm90b3R5cGUsIFwiaGFsZkNhbnZhc0hlaWdodFwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXR1cm5zIGhhbGYgaGVpZ2h0IG9mIHRoZSBnYW1lIGNhbnZhcyBpbiBwaXhlbHMgKGhhbGYgcGh5c2ljYWwgaGVpZ2h0IGNvbXBvbmVudClcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLmhlaWdodCAvIDI7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbmdpbmUucHJvdG90eXBlLCBcImRyYXdXaWR0aFwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgZW5naW5lJ3MgdmlzaWJsZSBkcmF3aW5nIHN1cmZhY2UgaW4gcGl4ZWxzIGluY2x1ZGluZyB6b29tIGFuZCBkZXZpY2UgcGl4ZWwgcmF0aW8uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRTY2VuZSAmJiB0aGlzLmN1cnJlbnRTY2VuZS5jYW1lcmEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuY2FudmFzV2lkdGggLyB0aGlzLmN1cnJlbnRTY2VuZS5jYW1lcmEuZ2V0Wm9vbSgpKSAvIHRoaXMucGl4ZWxSYXRpbztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbnZhc1dpZHRoIC8gdGhpcy5waXhlbFJhdGlvO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW5naW5lLnByb3RvdHlwZSwgXCJoYWxmRHJhd1dpZHRoXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJldHVybnMgaGFsZiB0aGUgd2lkdGggb2YgdGhlIGVuZ2luZSdzIHZpc2libGUgZHJhd2luZyBzdXJmYWNlIGluIHBpeGVscyBpbmNsdWRpbmcgem9vbSBhbmQgZGV2aWNlIHBpeGVsIHJhdGlvLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kcmF3V2lkdGggLyAyO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW5naW5lLnByb3RvdHlwZSwgXCJkcmF3SGVpZ2h0XCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJldHVybnMgdGhlIGhlaWdodCBvZiB0aGUgZW5naW5lJ3MgdmlzaWJsZSBkcmF3aW5nIHN1cmZhY2UgaW4gcGl4ZWxzIGluY2x1ZGluZyB6b29tIGFuZCBkZXZpY2UgcGl4ZWwgcmF0aW8uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRTY2VuZSAmJiB0aGlzLmN1cnJlbnRTY2VuZS5jYW1lcmEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuY2FudmFzSGVpZ2h0IC8gdGhpcy5jdXJyZW50U2NlbmUuY2FtZXJhLmdldFpvb20oKSkgLyB0aGlzLnBpeGVsUmF0aW87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYW52YXNIZWlnaHQgLyB0aGlzLnBpeGVsUmF0aW87XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbmdpbmUucHJvdG90eXBlLCBcImhhbGZEcmF3SGVpZ2h0XCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJldHVybnMgaGFsZiB0aGUgaGVpZ2h0IG9mIHRoZSBlbmdpbmUncyB2aXNpYmxlIGRyYXdpbmcgc3VyZmFjZSBpbiBwaXhlbHMgaW5jbHVkaW5nIHpvb20gYW5kIGRldmljZSBwaXhlbCByYXRpby5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZHJhd0hlaWdodCAvIDI7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbmdpbmUucHJvdG90eXBlLCBcImlzSGlEcGlcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmV0dXJucyB3aGV0aGVyIGV4Y2FsaWJ1ciBkZXRlY3RzIHRoZSBjdXJyZW50IHNjcmVlbiB0byBiZSBIaURQSVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5waXhlbFJhdGlvICE9PSAxO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW5naW5lLnByb3RvdHlwZSwgXCJzdGF0c1wiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBY2Nlc3MgW1tzdGF0c11dIHRoYXQgaG9sZHMgZnJhbWUgc3RhdGlzdGljcy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVidWcuc3RhdHM7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbmdpbmUucHJvdG90eXBlLCBcInBpeGVsUmF0aW9cIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmV0dXJucyB0aGUgY2FsY3VsYXRlZCBwaXhlbCByYXRpb24gZm9yIHVzZSBpbiByZW5kZXJpbmdcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRldmljZVBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBpeGVsUmF0aW8gPSBkZXZpY2VQaXhlbFJhdGlvO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBpeGVsUmF0aW87XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIEJvdW5kaW5nQm94IG9mIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHNjcmVlblxyXG4gICAgICAgICAqIGFuZCB0aGUgYm90dG9tIHJpZ2h0IGNvcm5lciBvZiB0aGUgc2NyZWVuLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuZ2V0V29ybGRCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gdGhpcy5zY3JlZW5Ub1dvcmxkQ29vcmRpbmF0ZXMoQWxnZWJyYV8yMi5WZWN0b3IuWmVybykueDtcclxuICAgICAgICAgICAgdmFyIHRvcCA9IHRoaXMuc2NyZWVuVG9Xb3JsZENvb3JkaW5hdGVzKEFsZ2VicmFfMjIuVmVjdG9yLlplcm8pLnk7XHJcbiAgICAgICAgICAgIHZhciByaWdodCA9IGxlZnQgKyB0aGlzLmRyYXdXaWR0aDtcclxuICAgICAgICAgICAgdmFyIGJvdHRvbSA9IHRvcCArIHRoaXMuZHJhd0hlaWdodDtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveF83LkJvdW5kaW5nQm94KGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW5naW5lLnByb3RvdHlwZSwgXCJ0aW1lc2NhbGVcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgY3VycmVudCBlbmdpbmUgdGltZXNjYWxlIGZhY3RvciAoZGVmYXVsdCBpcyAxLjAgd2hpY2ggaXMgMToxIHRpbWUpXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90aW1lc2NhbGU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXRzIHRoZSBjdXJyZW50IGVuZ2luZSB0aW1lc2NhbGUgZmFjdG9yLiBVc2VmdWwgZm9yIGNyZWF0aW5nIHNsb3ctbW90aW9uIGVmZmVjdHMgb3IgZmFzdC1mb3J3YXJkIGVmZmVjdHNcclxuICAgICAgICAgICAgICogd2hlbiB1c2luZyB0aW1lLWJhc2VkIG1vdmVtZW50LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgTG9nXzE0LkxvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKCdDYW5ub3Qgc2V0IGVuZ2luZS50aW1lc2NhbGUgdG8gYSB2YWx1ZSBvZiAwIG9yIGxlc3MgdGhhbiAwLicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVzY2FsZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQbGF5cyBhIHNwcml0ZSBhbmltYXRpb24gb24gdGhlIHNjcmVlbiBhdCB0aGUgc3BlY2lmaWVkIGB4YCBhbmQgYHlgXHJcbiAgICAgICAgICogKGluIGdhbWUgY29vcmRpbmF0ZXMsIG5vdCBzY3JlZW4gcGl4ZWxzKS4gVGhlc2UgYW5pbWF0aW9ucyBwbGF5XHJcbiAgICAgICAgICogaW5kZXBlbmRlbnQgb2YgYWN0b3JzLCBhbmQgd2lsbCBiZSBjbGVhbmVkIHVwIGludGVybmFsbHkgYXMgc29vblxyXG4gICAgICAgICAqIGFzIHRoZXkgYXJlIGNvbXBsZXRlLiBOb3RlIGFuaW1hdGlvbnMgdGhhdCBsb29wIHdpbGwgbmV2ZXIgYmVcclxuICAgICAgICAgKiBjbGVhbmVkIHVwLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGFuaW1hdGlvbiAgQW5pbWF0aW9uIHRvIHBsYXlcclxuICAgICAgICAgKiBAcGFyYW0geCAgICAgICAgICB4IGdhbWUgY29vcmRpbmF0ZSB0byBwbGF5IHRoZSBhbmltYXRpb25cclxuICAgICAgICAgKiBAcGFyYW0geSAgICAgICAgICB5IGdhbWUgY29vcmRpbmF0ZSB0byBwbGF5IHRoZSBhbmltYXRpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBFbmdpbmUucHJvdG90eXBlLnBsYXlBbmltYXRpb24gPSBmdW5jdGlvbiAoYW5pbWF0aW9uLCB4LCB5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbnMucHVzaChuZXcgQW5pbWF0aW9uTm9kZShhbmltYXRpb24sIHgsIHkpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYSBbW1RpbGVNYXBdXSB0byB0aGUgW1tjdXJyZW50U2NlbmVdXSwgb25jZSB0aGlzIGlzIGRvbmUgdGhlIFRpbGVNYXBcclxuICAgICAgICAgKiB3aWxsIGJlIGRyYXduIGFuZCB1cGRhdGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuYWRkVGlsZU1hcCA9IGZ1bmN0aW9uICh0aWxlTWFwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLmFkZFRpbGVNYXAodGlsZU1hcCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGEgW1tUaWxlTWFwXV0gZnJvbSB0aGUgW1tjdXJyZW50U2NlbmVdXSwgaXQgd2lsbCBubyBsb25nZXIgYmUgZHJhd24gb3IgdXBkYXRlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBFbmdpbmUucHJvdG90eXBlLnJlbW92ZVRpbGVNYXAgPSBmdW5jdGlvbiAodGlsZU1hcCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5yZW1vdmVUaWxlTWFwKHRpbGVNYXApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhIFtbVGltZXJdXSB0byB0aGUgW1tjdXJyZW50U2NlbmVdXS5cclxuICAgICAgICAgKiBAcGFyYW0gdGltZXIgIFRoZSB0aW1lciB0byBhZGQgdG8gdGhlIFtbY3VycmVudFNjZW5lXV0uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5hZGRUaW1lciA9IGZ1bmN0aW9uICh0aW1lcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50U2NlbmUuYWRkVGltZXIodGltZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlcyBhIFtbVGltZXJdXSBmcm9tIHRoZSBbW2N1cnJlbnRTY2VuZV1dLlxyXG4gICAgICAgICAqIEBwYXJhbSB0aW1lciAgVGhlIHRpbWVyIHRvIHJlbW92ZSB0byB0aGUgW1tjdXJyZW50U2NlbmVdXS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBFbmdpbmUucHJvdG90eXBlLnJlbW92ZVRpbWVyID0gZnVuY3Rpb24gKHRpbWVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRTY2VuZS5yZW1vdmVUaW1lcih0aW1lcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgW1tTY2VuZV1dIHRvIHRoZSBlbmdpbmUsIHRoaW5rIG9mIHNjZW5lcyBpbiBFeGNhbGlidXIgYXMgeW91XHJcbiAgICAgICAgICogd291bGQgbGV2ZWxzIG9yIG1lbnVzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGtleSAgVGhlIG5hbWUgb2YgdGhlIHNjZW5lLCBtdXN0IGJlIHVuaXF1ZVxyXG4gICAgICAgICAqIEBwYXJhbSBzY2VuZSBUaGUgc2NlbmUgdG8gYWRkIHRvIHRoZSBlbmdpbmVcclxuICAgICAgICAgKi9cclxuICAgICAgICBFbmdpbmUucHJvdG90eXBlLmFkZFNjZW5lID0gZnVuY3Rpb24gKGtleSwgc2NlbmUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2NlbmVzW2tleV0pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKCdTY2VuZScsIGtleSwgJ2FscmVhZHkgZXhpc3RzIG92ZXJ3cml0aW5nJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zY2VuZXNba2V5XSA9IHNjZW5lO1xyXG4gICAgICAgICAgICBzY2VuZS5lbmdpbmUgPSB0aGlzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGludGVybmFsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5yZW1vdmVTY2VuZSA9IGZ1bmN0aW9uIChlbnRpdHkpIHtcclxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIFNjZW5lXzIuU2NlbmUpIHtcclxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBzY2VuZVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuc2NlbmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2NlbmVzLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2NlbmVzW2tleV0gPT09IGVudGl0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2NlbmVzW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbnRpdHkgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgc2NlbmVcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNjZW5lc1tlbnRpdHldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBFbmdpbmUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChlbnRpdHkpIHtcclxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIFVJQWN0b3JfMy5VSUFjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5hZGRVSUFjdG9yKGVudGl0eSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIEFjdG9yXzEyLkFjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRDaGlsZChlbnRpdHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBUaW1lcl8yLlRpbWVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFRpbWVyKGVudGl0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIFRpbGVNYXBfMi5UaWxlTWFwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFRpbGVNYXAoZW50aXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTY2VuZShhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGVudGl0eSkge1xyXG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgVUlBY3Rvcl8zLlVJQWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLnJlbW92ZVVJQWN0b3IoZW50aXR5KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgQWN0b3JfMTIuQWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUNoaWxkKGVudGl0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIFRpbWVyXzIuVGltZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlVGltZXIoZW50aXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgVGlsZU1hcF8yLlRpbGVNYXApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlVGlsZU1hcChlbnRpdHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBTY2VuZV8yLlNjZW5lKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVNjZW5lKGVudGl0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbnRpdHkgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVNjZW5lKGVudGl0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYW4gYWN0b3IgdG8gdGhlIFtbY3VycmVudFNjZW5lXV0gb2YgdGhlIGdhbWUuIFRoaXMgaXMgc3lub255bW91c1xyXG4gICAgICAgICAqIHRvIGNhbGxpbmcgYGVuZ2luZS5jdXJyZW50U2NlbmUuYWRkKGFjdG9yKWAuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBBY3RvcnMgY2FuIG9ubHkgYmUgZHJhd24gaWYgdGhleSBhcmUgYSBtZW1iZXIgb2YgYSBzY2VuZSwgYW5kIG9ubHlcclxuICAgICAgICAgKiB0aGUgW1tjdXJyZW50U2NlbmVdXSBtYXkgYmUgZHJhd24gb3IgdXBkYXRlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBhY3RvciAgVGhlIGFjdG9yIHRvIGFkZCB0byB0aGUgW1tjdXJyZW50U2NlbmVdXVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuX2FkZENoaWxkID0gZnVuY3Rpb24gKGFjdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLmFkZChhY3Rvcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGFuIGFjdG9yIGZyb20gdGhlIFtbY3VycmVudFNjZW5lXV0gb2YgdGhlIGdhbWUuIFRoaXMgaXMgc3lub255bW91c1xyXG4gICAgICAgICAqIHRvIGNhbGxpbmcgYGVuZ2luZS5jdXJyZW50U2NlbmUucmVtb3ZlKGFjdG9yKWAuXHJcbiAgICAgICAgICogQWN0b3JzIHRoYXQgYXJlIHJlbW92ZWQgZnJvbSBhIHNjZW5lIHdpbGwgbm8gbG9uZ2VyIGJlIGRyYXduIG9yIHVwZGF0ZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gYWN0b3IgIFRoZSBhY3RvciB0byByZW1vdmUgZnJvbSB0aGUgW1tjdXJyZW50U2NlbmVdXS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBFbmdpbmUucHJvdG90eXBlLl9yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIChhY3Rvcikge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5yZW1vdmUoYWN0b3IpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hhbmdlcyB0aGUgY3VycmVudGx5IHVwZGF0aW5nIGFuZCBkcmF3aW5nIHNjZW5lIHRvIGEgZGlmZmVyZW50LFxyXG4gICAgICAgICAqIG5hbWVkIHNjZW5lLiBDYWxscyB0aGUgW1tTY2VuZV1dIGxpZmVjeWNsZSBldmVudHMuXHJcbiAgICAgICAgICogQHBhcmFtIGtleSAgVGhlIGtleSBvZiB0aGUgc2NlbmUgdG8gdHJhbnNpdGlvbiB0by5cclxuICAgICAgICAgKi9cclxuICAgICAgICBFbmdpbmUucHJvdG90eXBlLmdvVG9TY2VuZSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2NlbmVzW2tleV0pIHtcclxuICAgICAgICAgICAgICAgIHZhciBvbGRTY2VuZSA9IHRoaXMuY3VycmVudFNjZW5lO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld1NjZW5lID0gdGhpcy5zY2VuZXNba2V5XTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZygnR29pbmcgdG8gc2NlbmU6Jywga2V5KTtcclxuICAgICAgICAgICAgICAgIC8vIG9ubHkgZGVhY3RpdmF0ZSB3aGVuIGluaXRpYWxpemVkXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50U2NlbmUuaXNJbml0aWFsaXplZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLm9uRGVhY3RpdmF0ZS5jYWxsKHRoaXMuY3VycmVudFNjZW5lKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5ldmVudERpc3BhdGNoZXIuZW1pdCgnZGVhY3RpdmF0ZScsIG5ldyBFdmVudHNfMTIuRGVhY3RpdmF0ZUV2ZW50KG5ld1NjZW5lLCB0aGlzLmN1cnJlbnRTY2VuZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gc2V0IGN1cnJlbnQgc2NlbmUgdG8gbmV3IG9uZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUgPSBuZXdTY2VuZTtcclxuICAgICAgICAgICAgICAgIC8vIGluaXRpYWxpemUgdGhlIGN1cnJlbnQgc2NlbmUgaWYgaGFzIG5vdCBiZWVuIGFscmVhZHlcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLl9pbml0aWFsaXplKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUub25BY3RpdmF0ZS5jYWxsKHRoaXMuY3VycmVudFNjZW5lKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLmV2ZW50RGlzcGF0Y2hlci5lbWl0KCdhY3RpdmF0ZScsIG5ldyBFdmVudHNfMTIuQWN0aXZhdGVFdmVudChvbGRTY2VuZSwgdGhpcy5jdXJyZW50U2NlbmUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcignU2NlbmUnLCBrZXksICdkb2VzIG5vdCBleGlzdCEnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVHJhbnNmb3JtcyB0aGUgY3VycmVudCB4LCB5IGZyb20gc2NyZWVuIGNvb3JkaW5hdGVzIHRvIHdvcmxkIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICogQHBhcmFtIHBvaW50ICBTY3JlZW4gY29vcmRpbmF0ZSB0byBjb252ZXJ0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5zY3JlZW5Ub1dvcmxkQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbiAocG9pbnQpIHtcclxuICAgICAgICAgICAgdmFyIG5ld1ggPSBwb2ludC54O1xyXG4gICAgICAgICAgICB2YXIgbmV3WSA9IHBvaW50Lnk7XHJcbiAgICAgICAgICAgIC8vIHRyYW5zZm9ybSBiYWNrIHRvIHdvcmxkIHNwYWNlXHJcbiAgICAgICAgICAgIG5ld1ggPSAobmV3WCAvIHRoaXMuY2FudmFzLmNsaWVudFdpZHRoKSAqIHRoaXMuZHJhd1dpZHRoO1xyXG4gICAgICAgICAgICBuZXdZID0gKG5ld1kgLyB0aGlzLmNhbnZhcy5jbGllbnRIZWlnaHQpICogdGhpcy5kcmF3SGVpZ2h0O1xyXG4gICAgICAgICAgICAvLyB0cmFuc2Zvcm0gYmFzZWQgb24gem9vbVxyXG4gICAgICAgICAgICBuZXdYID0gbmV3WCAtIHRoaXMuaGFsZkRyYXdXaWR0aDtcclxuICAgICAgICAgICAgbmV3WSA9IG5ld1kgLSB0aGlzLmhhbGZEcmF3SGVpZ2h0O1xyXG4gICAgICAgICAgICAvLyBzaGlmdCBieSBmb2N1c1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50U2NlbmUgJiYgdGhpcy5jdXJyZW50U2NlbmUuY2FtZXJhKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZm9jdXMgPSB0aGlzLmN1cnJlbnRTY2VuZS5jYW1lcmEuZ2V0Rm9jdXMoKTtcclxuICAgICAgICAgICAgICAgIG5ld1ggKz0gZm9jdXMueDtcclxuICAgICAgICAgICAgICAgIG5ld1kgKz0gZm9jdXMueTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFsZ2VicmFfMjIuVmVjdG9yKE1hdGguZmxvb3IobmV3WCksIE1hdGguZmxvb3IobmV3WSkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVHJhbnNmb3JtcyBhIHdvcmxkIGNvb3JkaW5hdGUsIHRvIGEgc2NyZWVuIGNvb3JkaW5hdGVcclxuICAgICAgICAgKiBAcGFyYW0gcG9pbnQgIFdvcmxkIGNvb3JkaW5hdGUgdG8gY29udmVydFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUud29ybGRUb1NjcmVlbkNvb3JkaW5hdGVzID0gZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgICAgICAgICAgIHZhciBzY3JlZW5YID0gcG9pbnQueDtcclxuICAgICAgICAgICAgdmFyIHNjcmVlblkgPSBwb2ludC55O1xyXG4gICAgICAgICAgICAvLyBzaGlmdCBieSBmb2N1c1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50U2NlbmUgJiYgdGhpcy5jdXJyZW50U2NlbmUuY2FtZXJhKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZm9jdXMgPSB0aGlzLmN1cnJlbnRTY2VuZS5jYW1lcmEuZ2V0Rm9jdXMoKTtcclxuICAgICAgICAgICAgICAgIHNjcmVlblggLT0gZm9jdXMueDtcclxuICAgICAgICAgICAgICAgIHNjcmVlblkgLT0gZm9jdXMueTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB0cmFuc2Zvcm0gYmFjayBvbiB6b29tXHJcbiAgICAgICAgICAgIHNjcmVlblggPSBzY3JlZW5YICsgdGhpcy5oYWxmRHJhd1dpZHRoO1xyXG4gICAgICAgICAgICBzY3JlZW5ZID0gc2NyZWVuWSArIHRoaXMuaGFsZkRyYXdIZWlnaHQ7XHJcbiAgICAgICAgICAgIC8vIHRyYW5zZm9ybSBiYWNrIHRvIHNjcmVlbiBzcGFjZVxyXG4gICAgICAgICAgICBzY3JlZW5YID0gKHNjcmVlblggKiB0aGlzLmNhbnZhcy5jbGllbnRXaWR0aCkgLyB0aGlzLmRyYXdXaWR0aDtcclxuICAgICAgICAgICAgc2NyZWVuWSA9IChzY3JlZW5ZICogdGhpcy5jYW52YXMuY2xpZW50SGVpZ2h0KSAvIHRoaXMuZHJhd0hlaWdodDtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbGdlYnJhXzIyLlZlY3RvcihNYXRoLmZsb29yKHNjcmVlblgpLCBNYXRoLmZsb29yKHNjcmVlblkpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIGludGVybmFsIGNhbnZhcyBoZWlnaHQgYmFzZWQgb24gdGhlIHNlbGVjdGVkIGRpc3BsYXkgbW9kZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBFbmdpbmUucHJvdG90eXBlLl9zZXRIZWlnaHRCeURpc3BsYXlNb2RlID0gZnVuY3Rpb24gKHBhcmVudCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kaXNwbGF5TW9kZSA9PT0gRGlzcGxheU1vZGUuQ29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHBhcmVudC5jbGllbnRXaWR0aDtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHBhcmVudC5jbGllbnRIZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuZGlzcGxheU1vZGUgPT09IERpc3BsYXlNb2RlLkZ1bGxTY3JlZW4pIHtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUubWFyZ2luID0gJzBweCc7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHBhcmVudC5pbm5lcldpZHRoO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gcGFyZW50LmlubmVySGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbml0aWFsaXplcyB0aGUgaW50ZXJuYWwgY2FudmFzLCByZW5kZXJpbmcgY29udGV4dCwgZGlzcGxheW1vZGUsIGFuZCBuYXRpdmUgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5faW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRpc3BsYXlNb2RlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXlNb2RlID0gb3B0aW9ucy5kaXNwbGF5TW9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5kaXNwbGF5TW9kZSA9PT0gRGlzcGxheU1vZGUuRnVsbFNjcmVlbiB8fCB0aGlzLmRpc3BsYXlNb2RlID09PSBEaXNwbGF5TW9kZS5Db250YWluZXIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSAodGhpcy5kaXNwbGF5TW9kZSA9PT0gRGlzcGxheU1vZGUuQ29udGFpbmVyID9cclxuICAgICAgICAgICAgICAgICAgICAodGhpcy5jYW52YXMucGFyZW50RWxlbWVudCB8fCBkb2N1bWVudC5ib2R5KSA6IHdpbmRvdyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRIZWlnaHRCeURpc3BsYXlNb2RlKHBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuZGVidWcoJ1ZpZXcgcG9ydCByZXNpemVkJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3NldEhlaWdodEJ5RGlzcGxheU1vZGUocGFyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmluZm8oJ3BhcmVudC5jbGllbnRIZWlnaHQgJyArIHBhcmVudC5jbGllbnRIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldEFudGlhbGlhc2luZyhfdGhpcy5faXNTbW9vdGhpbmdFbmFibGVkKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuZGlzcGxheU1vZGUgPT09IERpc3BsYXlNb2RlLlBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnRpYWxpemVEaXNwbGF5TW9kZVBvc2l0aW9uKG9wdGlvbnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGluaXRpYWxpemUgaW5wdXRzXHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXQgPSB7XHJcbiAgICAgICAgICAgICAgICBrZXlib2FyZDogbmV3IElucHV0LktleWJvYXJkKCksXHJcbiAgICAgICAgICAgICAgICBwb2ludGVyczogbmV3IElucHV0LlBvaW50ZXJzKHRoaXMpLFxyXG4gICAgICAgICAgICAgICAgZ2FtZXBhZHM6IG5ldyBJbnB1dC5HYW1lcGFkcygpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXQua2V5Ym9hcmQuaW5pdCgpO1xyXG4gICAgICAgICAgICB0aGlzLmlucHV0LnBvaW50ZXJzLmluaXQob3B0aW9ucyAmJiBvcHRpb25zLnBvaW50ZXJTY29wZSA9PT0gSW5wdXQuUG9pbnRlclNjb3BlLkRvY3VtZW50ID8gZG9jdW1lbnQgOiB0aGlzLmNhbnZhcyk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXQuZ2FtZXBhZHMuaW5pdCgpO1xyXG4gICAgICAgICAgICB0aGlzLnBhZ2VTY3JvbGxQcmV2ZW50aW9uTW9kZSA9IG9wdGlvbnMuc2Nyb2xsUHJldmVudGlvbk1vZGU7XHJcbiAgICAgICAgICAgIC8vIElzc3VlICMzODUgbWFrZSB1c2Ugb2YgdGhlIHZpc2liaWxpdHkgYXBpXHJcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0d1aWRlL1VzZXJfZXhwZXJpZW5jZS9Vc2luZ190aGVfUGFnZV9WaXNpYmlsaXR5X0FQSVxyXG4gICAgICAgICAgICB2YXIgaGlkZGVuLCB2aXNpYmlsaXR5Q2hhbmdlO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50LmhpZGRlbiAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIGhpZGRlbiA9ICdoaWRkZW4nO1xyXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eUNoYW5nZSA9ICd2aXNpYmlsaXR5Y2hhbmdlJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgnbXNIaWRkZW4nIGluIGRvY3VtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBoaWRkZW4gPSAnbXNIaWRkZW4nO1xyXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eUNoYW5nZSA9ICdtc3Zpc2liaWxpdHljaGFuZ2UnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCd3ZWJraXRIaWRkZW4nIGluIGRvY3VtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBoaWRkZW4gPSAnd2Via2l0SGlkZGVuJztcclxuICAgICAgICAgICAgICAgIHZpc2liaWxpdHlDaGFuZ2UgPSAnd2Via2l0dmlzaWJpbGl0eWNoYW5nZSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih2aXNpYmlsaXR5Q2hhbmdlLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnRbaGlkZGVuXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50RGlzcGF0Y2hlci5lbWl0KCdoaWRkZW4nLCBuZXcgRXZlbnRzXzEyLkhpZGRlbkV2ZW50KF90aGlzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci5kZWJ1ZygnV2luZG93IGhpZGRlbicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ3Zpc2libGUnLCBuZXcgRXZlbnRzXzEyLlZpc2libGVFdmVudChfdGhpcykpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuZGVidWcoJ1dpbmRvdyB2aXNpYmxlJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLmN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5zdXBwcmVzc0hpRFBJU2NhbGluZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZUhpRHBpKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF0aGlzLmNhbnZhc0VsZW1lbnRJZCkge1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmNhbnZhcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuX2ludGlhbGl6ZURpc3BsYXlNb2RlUG9zaXRpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMucG9zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGlzcGxheU1vZGUgb2YgUG9zaXRpb24gd2FzIHNlbGVjdGVkIGJ1dCBubyBwb3NpdGlvbiBvcHRpb24gd2FzIGdpdmVuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5wb3NpdGlvbiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3BlY2lmaWVkUG9zaXRpb24gPSBvcHRpb25zLnBvc2l0aW9uLnNwbGl0KCcgJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzcGVjaWZpZWRQb3NpdGlvblswXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd0b3AnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUudG9wID0gJzBweCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmJvdHRvbSA9ICcwcHgnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ21pZGRsZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS50b3AgPSAnNTAlJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXRZID0gLXRoaXMuaGFsZkRyYXdIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5tYXJnaW5Ub3AgPSBvZmZzZXRZLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBQb3NpdGlvbiBHaXZlbicpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3BlY2lmaWVkUG9zaXRpb25bMV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzcGVjaWZpZWRQb3NpdGlvblsxXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbGVmdCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUubGVmdCA9ICcwcHgnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLnJpZ2h0ID0gJzBweCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjZW50ZXInOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmxlZnQgPSAnNTAlJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0WCA9IC10aGlzLmhhbGZEcmF3V2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUubWFyZ2luTGVmdCA9IG9mZnNldFgudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFBvc2l0aW9uIEdpdmVuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5wb3NpdGlvbi50b3ApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIG9wdGlvbnMucG9zaXRpb24udG9wID09PSAnbnVtYmVyJyA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS50b3AgPSBvcHRpb25zLnBvc2l0aW9uLnRvcC50b1N0cmluZygpICsgJ3B4JyA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS50b3AgPSBvcHRpb25zLnBvc2l0aW9uLnRvcDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucG9zaXRpb24ucmlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIG9wdGlvbnMucG9zaXRpb24ucmlnaHQgPT09ICdudW1iZXInID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLnJpZ2h0ID0gb3B0aW9ucy5wb3NpdGlvbi5yaWdodC50b1N0cmluZygpICsgJ3B4JyA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5yaWdodCA9IG9wdGlvbnMucG9zaXRpb24ucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnBvc2l0aW9uLmJvdHRvbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygb3B0aW9ucy5wb3NpdGlvbi5ib3R0b20gPT09ICdudW1iZXInID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmJvdHRvbSA9IG9wdGlvbnMucG9zaXRpb24uYm90dG9tLnRvU3RyaW5nKCkgKyAncHgnIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmJvdHRvbSA9IG9wdGlvbnMucG9zaXRpb24uYm90dG9tO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5wb3NpdGlvbi5sZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBvcHRpb25zLnBvc2l0aW9uLmxlZnQgPT09ICdudW1iZXInID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmxlZnQgPSBvcHRpb25zLnBvc2l0aW9uLmxlZnQudG9TdHJpbmcoKSArICdweCcgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUubGVmdCA9IG9wdGlvbnMucG9zaXRpb24ubGVmdDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuX2luaXRpYWxpemVIaURwaSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gU2NhbGUgdGhlIGNhbnZhcyBpZiBuZWVkZWRcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNIaURwaSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9sZFdpZHRoID0gdGhpcy5jYW52YXMud2lkdGg7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2xkSGVpZ2h0ID0gdGhpcy5jYW52YXMuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSBvbGRXaWR0aCAqIHRoaXMucGl4ZWxSYXRpbztcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IG9sZEhlaWdodCAqIHRoaXMucGl4ZWxSYXRpbztcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLndpZHRoID0gb2xkV2lkdGggKyAncHgnO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUuaGVpZ2h0ID0gb2xkSGVpZ2h0ICsgJ3B4JztcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKFwiSGkgRFBJIHNjcmVlbiBkZXRlY3RlZCwgcmVzZXR0aW5nIGNhbnZhcyByZXNvbHV0aW9uIGZyb20gXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgKyBvbGRXaWR0aCArIFwieFwiICsgb2xkSGVpZ2h0ICsgXCIgdG8gXCIgKyB0aGlzLmNhbnZhcy53aWR0aCArIFwieFwiICsgdGhpcy5jYW52YXMuaGVpZ2h0ICsgXCIgXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY3NzIHNpemUgd2lsbCByZW1haW4gXCIgKyBvbGRXaWR0aCArIFwieFwiICsgb2xkSGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3R4LnNjYWxlKHRoaXMucGl4ZWxSYXRpbywgdGhpcy5waXhlbFJhdGlvKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKFwiQ2FudmFzIGRyYXdpbmcgY29udGV4dCB3YXMgc2NhbGVkIGJ5IFwiICsgdGhpcy5waXhlbFJhdGlvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyLCB0aGlzIHdpbGwgc2V0IHRoZSBhbnRpYWxpYXNpbmcgZmxhZyBvbiB0aGVcclxuICAgICAgICAgKiBjYW52YXMuIFNldCB0aGlzIHRvIGBmYWxzZWAgaWYgeW91IHdhbnQgYSAnamFnZ2VkJyBwaXhlbCBhcnQgbG9vayB0byB5b3VyXHJcbiAgICAgICAgICogaW1hZ2UgcmVzb3VyY2VzLlxyXG4gICAgICAgICAqIEBwYXJhbSBpc1Ntb290aCAgU2V0IHNtb290aGluZyB0byB0cnVlIG9yIGZhbHNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5zZXRBbnRpYWxpYXNpbmcgPSBmdW5jdGlvbiAoaXNTbW9vdGgpIHtcclxuICAgICAgICAgICAgdGhpcy5faXNTbW9vdGhpbmdFbmFibGVkID0gaXNTbW9vdGg7XHJcbiAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLmN0eDtcclxuICAgICAgICAgICAgY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGlzU21vb3RoO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gWyd3ZWJraXRJbWFnZVNtb290aGluZ0VuYWJsZWQnLCAnbW96SW1hZ2VTbW9vdGhpbmdFbmFibGVkJywgJ21zSW1hZ2VTbW9vdGhpbmdFbmFibGVkJ107IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc21vb3RoaW5nID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNtb290aGluZyBpbiBjdHgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHhbc21vb3RoaW5nXSA9IGlzU21vb3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybiB0aGUgY3VycmVudCBzbW9vdGhpbmcgc3RhdHVzIG9mIHRoZSBjYW52YXNcclxuICAgICAgICAgKi9cclxuICAgICAgICBFbmdpbmUucHJvdG90eXBlLmdldEFudGlhbGlhc2luZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCB8fFxyXG4gICAgICAgICAgICAgICAgdGhpcy5jdHgud2Via2l0SW1hZ2VTbW9vdGhpbmdFbmFibGVkIHx8XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN0eC5tb3pJbWFnZVNtb290aGluZ0VuYWJsZWQgfHxcclxuICAgICAgICAgICAgICAgIHRoaXMuY3R4Lm1zSW1hZ2VTbW9vdGhpbmdFbmFibGVkO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXBkYXRlcyB0aGUgZW50aXJlIHN0YXRlIG9mIHRoZSBnYW1lXHJcbiAgICAgICAgICogQHBhcmFtIGRlbHRhICBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdXBkYXRlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNMb2FkaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzdXNwZW5kIHVwZGF0ZXMgdW50aWxsIGxvYWRpbmcgaXMgZmluaXNoZWRcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRlci51cGRhdGUodGhpcywgZGVsdGEpO1xyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGlucHV0IGxpc3RlbmVyc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dC5rZXlib2FyZC51cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQucG9pbnRlcnMudXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0LmdhbWVwYWRzLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncHJldXBkYXRlJywgbmV3IEV2ZW50c18xMi5QcmVVcGRhdGVFdmVudCh0aGlzLCBkZWx0YSwgdGhpcykpO1xyXG4gICAgICAgICAgICAvLyBwcm9jZXNzIGVuZ2luZSBsZXZlbCBldmVudHNcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUudXBkYXRlKHRoaXMsIGRlbHRhKTtcclxuICAgICAgICAgICAgLy8gdXBkYXRlIGFuaW1hdGlvbnNcclxuICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9ucyA9IHRoaXMuX2FuaW1hdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gIWEuYW5pbWF0aW9uLmlzRG9uZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gVXBkYXRlIGlucHV0IGxpc3RlbmVyc1xyXG4gICAgICAgICAgICB0aGlzLmlucHV0LmtleWJvYXJkLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmlucHV0LnBvaW50ZXJzLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmlucHV0LmdhbWVwYWRzLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAvLyBQdWJsaXNoIHVwZGF0ZSBldmVudFxyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3Bvc3R1cGRhdGUnLCBuZXcgRXZlbnRzXzEyLlBvc3RVcGRhdGVFdmVudCh0aGlzLCBkZWx0YSwgdGhpcykpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRHJhd3MgdGhlIGVudGlyZSBnYW1lXHJcbiAgICAgICAgICogQHBhcmFtIGRlbHRhICBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgZHJhdy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBFbmdpbmUucHJvdG90eXBlLl9kcmF3ID0gZnVuY3Rpb24gKGRlbHRhKSB7XHJcbiAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLmN0eDtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdwcmVkcmF3JywgbmV3IEV2ZW50c18xMi5QcmVEcmF3RXZlbnQoY3R4LCBkZWx0YSwgdGhpcykpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNMb2FkaW5nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkZXIuZHJhdyhjdHgsIGRlbHRhKTtcclxuICAgICAgICAgICAgICAgIC8vIERyYXdpbmcgbm90aGluZyBlbHNlIHdoaWxlIGxvYWRpbmdcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuY2FudmFzV2lkdGgsIHRoaXMuY2FudmFzSGVpZ2h0KTtcclxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuYmFja2dyb3VuZENvbG9yLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB0aGlzLmNhbnZhc1dpZHRoLCB0aGlzLmNhbnZhc0hlaWdodCk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLmRyYXcodGhpcy5jdHgsIGRlbHRhKTtcclxuICAgICAgICAgICAgLy8gdG9kbyBuZWVkcyB0byBiZSBhIGJldHRlciB3YXkgb2YgZG9pbmcgdGhpc1xyXG4gICAgICAgICAgICB2YXIgYSA9IDAsIGxlbiA9IHRoaXMuX2FuaW1hdGlvbnMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGE7IGEgPCBsZW47IGErKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9uc1thXS5hbmltYXRpb24uZHJhdyhjdHgsIHRoaXMuX2FuaW1hdGlvbnNbYV0ueCwgdGhpcy5fYW5pbWF0aW9uc1thXS55KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBEcmF3IGRlYnVnIGluZm9ybWF0aW9uXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRGVidWcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3R4LmZvbnQgPSAnQ29uc29sYXMnO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gdGhpcy5kZWJ1Z0NvbG9yLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IHRoaXMuaW5wdXQua2V5Ym9hcmQuZ2V0S2V5cygpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBrZXlzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdHguZmlsbFRleHQoa2V5c1tqXS50b1N0cmluZygpICsgJyA6ICcgKyAoSW5wdXQuS2V5c1trZXlzW2pdXSA/IElucHV0LktleXNba2V5c1tqXV0gOiAnTm90IE1hcHBlZCcpLCAxMDAsIDEwICogaiArIDEwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuY3R4LmZpbGxUZXh0KCdGUFM6JyArIHRoaXMuc3RhdHMuY3VyckZyYW1lLmZwcy50b0ZpeGVkKDIpLnRvU3RyaW5nKCksIDEwLCAxMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUG9zdCBwcm9jZXNzaW5nXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wb3N0UHJvY2Vzc29ycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb3N0UHJvY2Vzc29yc1tpXS5wcm9jZXNzKHRoaXMuY3R4LmdldEltYWdlRGF0YSgwLCAwLCB0aGlzLmNhbnZhc1dpZHRoLCB0aGlzLmNhbnZhc0hlaWdodCksIHRoaXMuY3R4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3Bvc3RkcmF3JywgbmV3IEV2ZW50c18xMi5Qb3N0RHJhd0V2ZW50KGN0eCwgZGVsdGEsIHRoaXMpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN0YXJ0cyB0aGUgaW50ZXJuYWwgZ2FtZSBsb29wIGZvciBFeGNhbGlidXIgYWZ0ZXIgbG9hZGluZ1xyXG4gICAgICAgICAqIGFueSBwcm92aWRlZCBhc3NldHMuXHJcbiAgICAgICAgICogQHBhcmFtIGxvYWRlciAgT3B0aW9uYWwgW1tJTG9hZGVyXV0gdG8gdXNlIHRvIGxvYWQgcmVzb3VyY2VzLiBUaGUgZGVmYXVsdCBsb2FkZXIgaXMgW1tMb2FkZXJdXSwgb3ZlcnJpZGUgdG8gcHJvdmlkZSB5b3VyIG93blxyXG4gICAgICAgICAqIGN1c3RvbSBsb2FkZXIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9jb21wYXRpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlc184LlByb21pc2UoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnJlamVjdCgnRXhjYWxpYnVyIGlzIGluY29tcGF0aWJsZSB3aXRoIHlvdXIgYnJvd3NlcicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBsb2FkaW5nQ29tcGxldGU7XHJcbiAgICAgICAgICAgIGlmIChsb2FkZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRlciA9IGxvYWRlcjtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRlci53aXJlRW5naW5lKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgbG9hZGluZ0NvbXBsZXRlID0gdGhpcy5sb2FkKHRoaXMuX2xvYWRlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsb2FkaW5nQ29tcGxldGUgPSBQcm9taXNlc184LlByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxvYWRpbmdDb21wbGV0ZS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ3N0YXJ0JywgbmV3IEV2ZW50c18xMi5HYW1lU3RhcnRFdmVudChfdGhpcykpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9oYXNTdGFydGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9oYXNTdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZygnU3RhcnRpbmcgZ2FtZS4uLicpO1xyXG4gICAgICAgICAgICAgICAgRW5naW5lLmNyZWF0ZU1haW5Mb29wKHRoaXMsIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIERhdGUubm93KSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCdHYW1lIHN0YXJ0ZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIEdhbWUgYWxyZWFkeSBzdGFydGVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBsb2FkaW5nQ29tcGxldGU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBFbmdpbmUuY3JlYXRlTWFpbkxvb3AgPSBmdW5jdGlvbiAoZ2FtZSwgcmFmLCBub3dGbikge1xyXG4gICAgICAgICAgICB2YXIgbGFzdFRpbWUgPSBub3dGbigpO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gbWFpbmxvb3AoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWdhbWUuX2hhc1N0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGdhbWUuX3JlcXVlc3RJZCA9IHJhZihtYWlubG9vcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2FtZS5lbWl0KCdwcmVmcmFtZScsIG5ldyBFdmVudHNfMTIuUHJlRnJhbWVFdmVudChnYW1lLCBnYW1lLnN0YXRzLnByZXZGcmFtZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgdGltZSB0byBjYWxjdWxhdGUgdGltZS1lbGFwc2VkXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vdyA9IG5vd0ZuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsYXBzZWQgPSBNYXRoLmZsb29yKG5vdyAtIGxhc3RUaW1lKSB8fCAxO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc29sdmVzIGlzc3VlICMxMzggaWYgdGhlIGdhbWUgaGFzIGJlZW4gcGF1c2VkLCBvciBibHVycmVkIGZvciBcclxuICAgICAgICAgICAgICAgICAgICAvLyBtb3JlIHRoYW4gYSAyMDAgbWlsbGlzZWNvbmRzLCByZXNldCBlbGFwc2VkIHRpbWUgdG8gMS4gVGhpcyBpbXByb3ZlcyByZWxpYWJpbGl0eSBcclxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgcHJvdmlkZXMgbW9yZSBleHBlY3RlZCBiZWhhdmlvciB3aGVuIHRoZSBlbmdpbmUgY29tZXMgYmFja1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGludG8gZm9jdXNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxhcHNlZCA+IDIwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGFwc2VkID0gMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHRhID0gZWxhcHNlZCAqIGdhbWUudGltZXNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc2V0IGZyYW1lIHN0YXRzIChyZXVzZSBleGlzdGluZyBpbnN0YW5jZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lSWQgPSBnYW1lLnN0YXRzLnByZXZGcmFtZS5pZCArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2FtZS5zdGF0cy5wcmV2RnJhbWUucmVzZXQoZ2FtZS5zdGF0cy5jdXJyRnJhbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGdhbWUuc3RhdHMuY3VyckZyYW1lLnJlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2FtZS5zdGF0cy5jdXJyRnJhbWUuaWQgPSBmcmFtZUlkO1xyXG4gICAgICAgICAgICAgICAgICAgIGdhbWUuc3RhdHMuY3VyckZyYW1lLmRlbHRhID0gZGVsdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2FtZS5zdGF0cy5jdXJyRnJhbWUuZnBzID0gMS4wIC8gKGRlbHRhIC8gMTAwMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJlZm9yZVVwZGF0ZSA9IG5vd0ZuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2FtZS5fdXBkYXRlKGRlbHRhKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWZ0ZXJVcGRhdGUgPSBub3dGbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGdhbWUuX2RyYXcoZGVsdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhZnRlckRyYXcgPSBub3dGbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGdhbWUuc3RhdHMuY3VyckZyYW1lLmR1cmF0aW9uLnVwZGF0ZSA9IGFmdGVyVXBkYXRlIC0gYmVmb3JlVXBkYXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIGdhbWUuc3RhdHMuY3VyckZyYW1lLmR1cmF0aW9uLmRyYXcgPSBhZnRlckRyYXcgLSBhZnRlclVwZGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0VGltZSA9IG5vdztcclxuICAgICAgICAgICAgICAgICAgICBnYW1lLmVtaXQoJ3Bvc3RmcmFtZScsIG5ldyBFdmVudHNfMTIuUG9zdEZyYW1lRXZlbnQoZ2FtZSwgZ2FtZS5zdGF0cy5jdXJyRnJhbWUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKGdhbWUuX3JlcXVlc3RJZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2FtZS5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2FtZS5vbkZhdGFsRXhjZXB0aW9uKGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3RvcHMgRXhjYWxpYnVyJ3MgbWFpbiBsb29wLCB1c2VmdWwgZm9yIHBhdXNpbmcgdGhlIGdhbWUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faGFzU3RhcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdzdG9wJywgbmV3IEV2ZW50c18xMi5HYW1lU3RvcEV2ZW50KHRoaXMpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2hhc1N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZygnR2FtZSBzdG9wcGVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIEVuZ2luZSdzIFJ1bm5pbmcgc3RhdHVzLCBVc2VmdWwgZm9yIGNoZWNraW5nIHdoZXRoZXIgZW5naW5lIGlzIHJ1bm5pbmcgb3IgcGF1c2VkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhKHRoaXMuX2hhc1N0YXJ0ZWQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGFrZXMgYSBzY3JlZW4gc2hvdCBvZiB0aGUgY3VycmVudCB2aWV3cG9ydCBhbmQgcmV0dXJucyBpdCBhcyBhblxyXG4gICAgICAgICAqIEhUTUwgSW1hZ2UgRWxlbWVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBFbmdpbmUucHJvdG90eXBlLnNjcmVlbnNob3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgICAgICAgdmFyIHJhdyA9IHRoaXMuY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5zcmMgPSByYXc7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbm90aGVyIG9wdGlvbiBhdmFpbGFibGUgdG8geW91IHRvIGxvYWQgcmVzb3VyY2VzIGludG8gdGhlIGdhbWUuXHJcbiAgICAgICAgICogSW1tZWRpYXRlbHkgYWZ0ZXIgY2FsbGluZyB0aGlzIHRoZSBnYW1lIHdpbGwgcGF1c2UgYW5kIHRoZSBsb2FkaW5nIHNjcmVlblxyXG4gICAgICAgICAqIHdpbGwgYXBwZWFyLlxyXG4gICAgICAgICAqIEBwYXJhbSBsb2FkZXIgIFNvbWUgW1tJTG9hZGFibGVdXSBzdWNoIGFzIGEgW1tMb2FkZXJdXSBjb2xsZWN0aW9uLCBbW1NvdW5kXV0sIG9yIFtbVGV4dHVyZV1dLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGNvbXBsZXRlID0gbmV3IFByb21pc2VzXzguUHJvbWlzZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9pc0xvYWRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICBsb2FkZXIubG9hZCgpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2lzTG9hZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH0sIDUwMCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gY29tcGxldGU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gRW5naW5lO1xyXG4gICAgfShDbGFzc185LkNsYXNzKSk7XHJcbiAgICAvKipcclxuICAgICAqIERlZmF1bHQgW1tJRW5naW5lT3B0aW9uc11dXHJcbiAgICAgKi9cclxuICAgIEVuZ2luZS5fRGVmYXVsdEVuZ2luZU9wdGlvbnMgPSB7XHJcbiAgICAgICAgd2lkdGg6IDAsXHJcbiAgICAgICAgaGVpZ2h0OiAwLFxyXG4gICAgICAgIGNhbnZhc0VsZW1lbnRJZDogJycsXHJcbiAgICAgICAgcG9pbnRlclNjb3BlOiBJbnB1dC5Qb2ludGVyU2NvcGUuRG9jdW1lbnQsXHJcbiAgICAgICAgc3VwcHJlc3NDb25zb2xlQm9vdE1lc3NhZ2U6IG51bGwsXHJcbiAgICAgICAgc3VwcHJlc3NNaW5pbXVtQnJvd3NlckZlYXR1cmVEZXRlY3Rpb246IG51bGwsXHJcbiAgICAgICAgc3VwcHJlc3NIaURQSVNjYWxpbmc6IG51bGwsXHJcbiAgICAgICAgc2Nyb2xsUHJldmVudGlvbk1vZGU6IFNjcm9sbFByZXZlbnRpb25Nb2RlLkNhbnZhcyxcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IENvbG9yXzE5LkNvbG9yLmZyb21IZXgoJyMyMTg1ZDAnKSAvLyBFeGNhbGlidXIgYmx1ZVxyXG4gICAgfTtcclxuICAgIGV4cG9ydHMuRW5naW5lID0gRW5naW5lO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgdmFyIEFuaW1hdGlvbk5vZGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvbk5vZGUoYW5pbWF0aW9uLCB4LCB5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uID0gYW5pbWF0aW9uO1xyXG4gICAgICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gQW5pbWF0aW9uTm9kZTtcclxuICAgIH0oKSk7XHJcbn0pO1xyXG5kZWZpbmUoXCJVSUFjdG9yXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiQWxnZWJyYVwiLCBcIkFjdG9yXCIsIFwiVHJhaXRzL0luZGV4XCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgQWxnZWJyYV8yMywgQWN0b3JfMTMsIFRyYWl0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEhlbHBlciBbW0FjdG9yXV0gcHJpbWl0aXZlIGZvciBkcmF3aW5nIFVJJ3MsIG9wdGltaXplZCBmb3IgVUkgZHJhd2luZy4gRG9lc1xyXG4gICAgICogbm90IHBhcnRpY2lwYXRlIGluIGNvbGxpc2lvbnMuIERyYXduIG9uIHRvcCBvZiBhbGwgb3RoZXIgYWN0b3JzLlxyXG4gICAgICovXHJcbiAgICB2YXIgVUlBY3RvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFVJQWN0b3IsIF9zdXBlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHggICAgICAgVGhlIHN0YXJ0aW5nIHggY29vcmRpbmF0ZSBvZiB0aGUgYWN0b3JcclxuICAgICAgICAgKiBAcGFyYW0geSAgICAgICBUaGUgc3RhcnRpbmcgeSBjb29yZGluYXRlIG9mIHRoZSBhY3RvclxyXG4gICAgICAgICAqIEBwYXJhbSB3aWR0aCAgIFRoZSBzdGFydGluZyB3aWR0aCBvZiB0aGUgYWN0b3JcclxuICAgICAgICAgKiBAcGFyYW0gaGVpZ2h0ICBUaGUgc3RhcnRpbmcgaGVpZ2h0IG9mIHRoZSBhY3RvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIFVJQWN0b3IoeE9yQ29uZmlnLCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHhPckNvbmZpZyAhPT0gJ29iamVjdCcpKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHhPckNvbmZpZywgeSwgd2lkdGgsIGhlaWdodCkgfHwgdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgeE9yQ29uZmlnKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzLnRyYWl0cyA9IFtdO1xyXG4gICAgICAgICAgICBfdGhpcy50cmFpdHMucHVzaChuZXcgVHJhaXRzLkNhcHR1cmVQb2ludGVyKCkpO1xyXG4gICAgICAgICAgICBfdGhpcy5hbmNob3Iuc2V0VG8oMCwgMCk7XHJcbiAgICAgICAgICAgIF90aGlzLmNvbGxpc2lvblR5cGUgPSBBY3Rvcl8xMy5Db2xsaXNpb25UeXBlLlByZXZlbnRDb2xsaXNpb247XHJcbiAgICAgICAgICAgIF90aGlzLmVuYWJsZUNhcHR1cmVQb2ludGVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBVSUFjdG9yLnByb3RvdHlwZS5vbkluaXRpYWxpemUgPSBmdW5jdGlvbiAoZW5naW5lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZ2luZSA9IGVuZ2luZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFVJQWN0b3IucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKHgsIHksIHVzZVdvcmxkKSB7XHJcbiAgICAgICAgICAgIGlmICh1c2VXb3JsZCA9PT0gdm9pZCAwKSB7IHVzZVdvcmxkID0gdHJ1ZTsgfVxyXG4gICAgICAgICAgICBpZiAodXNlV29ybGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmNvbnRhaW5zLmNhbGwodGhpcywgeCwgeSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGNvb3JkcyA9IHRoaXMuX2VuZ2luZS53b3JsZFRvU2NyZWVuQ29vcmRpbmF0ZXMobmV3IEFsZ2VicmFfMjMuVmVjdG9yKHgsIHkpKTtcclxuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuY29udGFpbnMuY2FsbCh0aGlzLCBjb29yZHMueCwgY29vcmRzLnkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFVJQWN0b3I7XHJcbiAgICB9KEFjdG9yXzEzLkFjdG9yKSk7XHJcbiAgICBleHBvcnRzLlVJQWN0b3IgPSBVSUFjdG9yO1xyXG59KTtcclxuZGVmaW5lKFwiVXRpbC9BY3RvcnNcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJVSUFjdG9yXCIsIFwiTGFiZWxcIiwgXCJUcmlnZ2VyXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgVUlBY3Rvcl80LCBMYWJlbF8zLCBUcmlnZ2VyXzIpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgZnVuY3Rpb24gaXNWYW5pbGxhQWN0b3IoYWN0b3IpIHtcclxuICAgICAgICByZXR1cm4gIShhY3RvciBpbnN0YW5jZW9mIFVJQWN0b3JfNC5VSUFjdG9yKSAmJlxyXG4gICAgICAgICAgICAhKGFjdG9yIGluc3RhbmNlb2YgVHJpZ2dlcl8yLlRyaWdnZXIpICYmXHJcbiAgICAgICAgICAgICEoYWN0b3IgaW5zdGFuY2VvZiBMYWJlbF8zLkxhYmVsKTtcclxuICAgIH1cclxuICAgIGV4cG9ydHMuaXNWYW5pbGxhQWN0b3IgPSBpc1ZhbmlsbGFBY3RvcjtcclxuICAgIGZ1bmN0aW9uIGlzVUlBY3RvcihhY3Rvcikge1xyXG4gICAgICAgIHJldHVybiBhY3RvciBpbnN0YW5jZW9mIFVJQWN0b3JfNC5VSUFjdG9yO1xyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5pc1VJQWN0b3IgPSBpc1VJQWN0b3I7XHJcbn0pO1xyXG5kZWZpbmUoXCJTY2VuZVwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIlVJQWN0b3JcIiwgXCJQaHlzaWNzXCIsIFwiRXZlbnRzXCIsIFwiVXRpbC9Mb2dcIiwgXCJUaW1lclwiLCBcIkNvbGxpc2lvbi9EeW5hbWljVHJlZUNvbGxpc2lvbkJyb2FkcGhhc2VcIiwgXCJVdGlsL1NvcnRlZExpc3RcIiwgXCJHcm91cFwiLCBcIlRpbGVNYXBcIiwgXCJDYW1lcmFcIiwgXCJBY3RvclwiLCBcIkNsYXNzXCIsIFwiVXRpbC9VdGlsXCIsIFwiVXRpbC9BY3RvcnNcIiwgXCJUcmlnZ2VyXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgVUlBY3Rvcl81LCBQaHlzaWNzXzEyLCBFdmVudHNfMTMsIExvZ18xNSwgVGltZXJfMywgRHluYW1pY1RyZWVDb2xsaXNpb25Ccm9hZHBoYXNlXzIsIFNvcnRlZExpc3RfMiwgR3JvdXBfMiwgVGlsZU1hcF8zLCBDYW1lcmFfMiwgQWN0b3JfMTQsIENsYXNzXzEwLCBVdGlsLCBBY3RvclV0aWxzLCBUcmlnZ2VyXzMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBbW0FjdG9yfEFjdG9yc11dIGFyZSBjb21wb3NlZCB0b2dldGhlciBpbnRvIGdyb3VwaW5ncyBjYWxsZWQgU2NlbmVzIGluXHJcbiAgICAgKiBFeGNhbGlidXIuIFRoZSBtZXRhcGhvciBtb2RlbHMgdGhlIHNhbWUgaWRlYSBiZWhpbmQgcmVhbCB3b3JsZFxyXG4gICAgICogYWN0b3JzIGluIGEgc2NlbmUuIE9ubHkgYWN0b3JzIGluIHNjZW5lcyB3aWxsIGJlIHVwZGF0ZWQgYW5kIGRyYXduLlxyXG4gICAgICpcclxuICAgICAqIFR5cGljYWwgdXNhZ2VzIG9mIGEgc2NlbmUgaW5jbHVkZTogbGV2ZWxzLCBtZW51cywgbG9hZGluZyBzY3JlZW5zLCBldGMuXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOlNjZW5lcy5tZF1dXHJcbiAgICAgKi9cclxuICAgIHZhciBTY2VuZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFNjZW5lLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFNjZW5lKGVuZ2luZSkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGFjdG9ycyBpbiB0aGUgY3VycmVudCBzY2VuZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuYWN0b3JzID0gW107XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgdHJpZ2dlcnMgaW4gdGhlIGN1cnJlbnQgc2NlbmVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLnRyaWdnZXJzID0gW107XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgW1tUaWxlTWFwXV1zIGluIHRoZSBzY2VuZSwgaWYgYW55XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy50aWxlTWFwcyA9IFtdO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIFtbR3JvdXBdXXMgaW4gdGhlIHNjZW5lLCBpZiBhbnlcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmdyb3VwcyA9IHt9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIFtbVUlBY3Rvcl1dcyBpbiBhIHNjZW5lLCBpZiBhbnk7IHRoZXNlIGFyZSBkcmF3biBsYXN0XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy51aUFjdG9ycyA9IFtdO1xyXG4gICAgICAgICAgICBfdGhpcy5faXNJbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBfdGhpcy5fc29ydGVkRHJhd2luZ1RyZWUgPSBuZXcgU29ydGVkTGlzdF8yLlNvcnRlZExpc3QoQWN0b3JfMTQuQWN0b3IucHJvdG90eXBlLmdldFpJbmRleCk7XHJcbiAgICAgICAgICAgIF90aGlzLl9icm9hZHBoYXNlID0gbmV3IER5bmFtaWNUcmVlQ29sbGlzaW9uQnJvYWRwaGFzZV8yLkR5bmFtaWNUcmVlQ29sbGlzaW9uQnJvYWRwaGFzZSgpO1xyXG4gICAgICAgICAgICBfdGhpcy5fa2lsbFF1ZXVlID0gW107XHJcbiAgICAgICAgICAgIF90aGlzLl90cmlnZ2VyS2lsbFF1ZXVlID0gW107XHJcbiAgICAgICAgICAgIF90aGlzLl90aW1lcnMgPSBbXTtcclxuICAgICAgICAgICAgX3RoaXMuX2NhbmNlbFF1ZXVlID0gW107XHJcbiAgICAgICAgICAgIF90aGlzLl9sb2dnZXIgPSBMb2dfMTUuTG9nZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgICAgIF90aGlzLmNhbWVyYSA9IG5ldyBDYW1lcmFfMi5CYXNlQ2FtZXJhKCk7XHJcbiAgICAgICAgICAgIGlmIChlbmdpbmUpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmNhbWVyYS54ID0gZW5naW5lLmhhbGZEcmF3V2lkdGg7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5jYW1lcmEueSA9IGVuZ2luZS5oYWxmRHJhd0hlaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIGlzIGNhbGxlZCBiZWZvcmUgdGhlIGZpcnN0IHVwZGF0ZSBvZiB0aGUgW1tTY2VuZV1dLiBJbml0aWFsaXplcyBzY2VuZSBtZW1iZXJzIGxpa2UgdGhlIGNhbWVyYS4gVGhpcyBtZXRob2QgaXMgbWVhbnQgdG8gYmVcclxuICAgICAgICAgKiBvdmVycmlkZGVuLiBUaGlzIGlzIHdoZXJlIGluaXRpYWxpemF0aW9uIG9mIGNoaWxkIGFjdG9ycyBzaG91bGQgdGFrZSBwbGFjZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBTY2VuZS5wcm90b3R5cGUub25Jbml0aWFsaXplID0gZnVuY3Rpb24gKGVuZ2luZSkge1xyXG4gICAgICAgICAgICAvLyB3aWxsIGJlIG92ZXJyaWRkZW5cclxuICAgICAgICAgICAgaWYgKHRoaXMuY2FtZXJhKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbWVyYS54ID0gZW5naW5lLmhhbGZEcmF3V2lkdGg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbWVyYS55ID0gZW5naW5lLmhhbGZEcmF3SGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZygnU2NlbmUub25Jbml0aWFsaXplJywgdGhpcywgZW5naW5lKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhlIHNjZW5lIGlzIG1hZGUgYWN0aXZlIGFuZCBzdGFydGVkLiBJdCBpcyBtZWFudCB0byBiZSBvdmVycmlkZW4sXHJcbiAgICAgICAgICogdGhpcyBpcyB3aGVyZSB5b3Ugc2hvdWxkIHNldHVwIGFueSBET00gVUkgb3IgZXZlbnQgaGFuZGxlcnMgbmVlZGVkIGZvciB0aGUgc2NlbmUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2NlbmUucHJvdG90eXBlLm9uQWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIHdpbGwgYmUgb3ZlcnJpZGRlblxyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoJ1NjZW5lLm9uQWN0aXZhdGUnLCB0aGlzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhlIHNjZW5lIGlzIG1hZGUgdHJhbnNpdGlvbmVkIGF3YXkgZnJvbSBhbmQgc3RvcHBlZC4gSXQgaXMgbWVhbnQgdG8gYmUgb3ZlcnJpZGVuLFxyXG4gICAgICAgICAqIHRoaXMgaXMgd2hlcmUgeW91IHNob3VsZCBjbGVhbnVwIGFueSBET00gVUkgb3IgZXZlbnQgaGFuZGxlcnMgbmVlZGVkIGZvciB0aGUgc2NlbmUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2NlbmUucHJvdG90eXBlLm9uRGVhY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gd2lsbCBiZSBvdmVycmlkZGVuXHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZygnU2NlbmUub25EZWFjdGl2YXRlJywgdGhpcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbml0aWFsaXplcyBhY3RvcnMgaW4gdGhlIHNjZW5lXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2NlbmUucHJvdG90eXBlLl9pbml0aWFsaXplQ2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmFjdG9yczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgIGNoaWxkLl9pbml0aWFsaXplKHRoaXMuZW5naW5lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjZW5lLnByb3RvdHlwZSwgXCJpc0luaXRpYWxpemVkXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgd2hldGhlciBvciBub3QgdGhlIFtbU2NlbmVdXSBoYXMgYmVlbiBpbml0aWFsaXplZFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faXNJbml0aWFsaXplZDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgdGhlIHNjZW5lIGJlZm9yZSB0aGUgZmlyc3QgdXBkYXRlLCBtZWFudCB0byBiZSBjYWxsZWQgYnkgZW5naW5lIG5vdCBieSB1c2VycyBvZlxyXG4gICAgICAgICAqIEV4Y2FsaWJ1clxyXG4gICAgICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5faW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChlbmdpbmUpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzSW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub25Jbml0aWFsaXplLmNhbGwodGhpcywgZW5naW5lKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ2luaXRpYWxpemUnLCBuZXcgRXZlbnRzXzEzLkluaXRpYWxpemVFdmVudChlbmdpbmUsIHRoaXMpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVDaGlsZHJlbigpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faXNJbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwZGF0ZXMgYWxsIHRoZSBhY3RvcnMgYW5kIHRpbWVycyBpbiB0aGUgc2NlbmUuIENhbGxlZCBieSB0aGUgW1tFbmdpbmVdXS5cclxuICAgICAgICAgKiBAcGFyYW0gZW5naW5lICBSZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgRW5naW5lXHJcbiAgICAgICAgICogQHBhcmFtIGRlbHRhICAgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGxhc3QgdXBkYXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2NlbmUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChlbmdpbmUsIGRlbHRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncHJldXBkYXRlJywgbmV3IEV2ZW50c18xMy5QcmVVcGRhdGVFdmVudChlbmdpbmUsIGRlbHRhLCB0aGlzKSk7XHJcbiAgICAgICAgICAgIHZhciBpLCBsZW47XHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aW1lcnMgaW4gdGhlIGNhbmNlbCBxdWV1ZSBiZWZvcmUgdXBkYXRpbmcgdGhlbVxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9jYW5jZWxRdWV1ZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVUaW1lcih0aGlzLl9jYW5jZWxRdWV1ZVtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fY2FuY2VsUXVldWUubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgLy8gQ3ljbGUgdGhyb3VnaCB0aW1lcnMgdXBkYXRpbmcgdGltZXJzXHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl90aW1lcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGltZXIgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICB0aW1lci51cGRhdGUoZGVsdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDtcclxuICAgICAgICAgICAgLy8gQ3ljbGUgdGhyb3VnaCBhY3RvcnMgdXBkYXRpbmcgVUkgYWN0b3JzXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHRoaXMudWlBY3RvcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudWlBY3RvcnNbaV0udXBkYXRlKGVuZ2luZSwgZGVsdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEN5Y2xlIHRocm91Z2ggYWN0b3JzIHVwZGF0aW5nIHRpbGUgbWFwc1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLnRpbGVNYXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRpbGVNYXBzW2ldLnVwZGF0ZShlbmdpbmUsIGRlbHRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBDeWNsZSB0aHJvdWdoIGFjdG9ycyB1cGRhdGluZyBhY3RvcnNcclxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy5hY3RvcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWN0b3JzW2ldLnVwZGF0ZShlbmdpbmUsIGRlbHRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBDeWNsZSB0aHJvdWdoIHRyaWdnZXJzIHVwZGF0aW5nXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHRoaXMudHJpZ2dlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcnNbaV0udXBkYXRlKGVuZ2luZSwgZGVsdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbGxlY3RBY3RvclN0YXRzKGVuZ2luZSk7XHJcbiAgICAgICAgICAgIC8vIFJ1biB0aGUgYnJvYWRwaGFzZSBhbmQgbmFycm93cGhhc2VcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2Jyb2FkcGhhc2UgJiYgUGh5c2ljc18xMi5QaHlzaWNzLmVuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBiZWZvcmVCcm9hZHBoYXNlID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Jyb2FkcGhhc2UudXBkYXRlKHRoaXMuYWN0b3JzLCBkZWx0YSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFpcnMgPSB0aGlzLl9icm9hZHBoYXNlLmJyb2FkcGhhc2UodGhpcy5hY3RvcnMsIGRlbHRhLCBlbmdpbmUuc3RhdHMuY3VyckZyYW1lKTtcclxuICAgICAgICAgICAgICAgIHZhciBhZnRlckJyb2FkcGhhc2UgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJlZm9yZU5hcnJvd3BoYXNlID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgICAgIHZhciBpdGVyID0gUGh5c2ljc18xMi5QaHlzaWNzLmNvbGxpc2lvblBhc3NlcztcclxuICAgICAgICAgICAgICAgIHZhciBjb2xsaXNpb25EZWx0YSA9IGRlbHRhIC8gaXRlcjtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChpdGVyID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJ1biB0aGUgbmFycm93cGhhc2VcclxuICAgICAgICAgICAgICAgICAgICBwYWlycyA9IHRoaXMuX2Jyb2FkcGhhc2UubmFycm93cGhhc2UocGFpcnMsIGVuZ2luZS5zdGF0cy5jdXJyRnJhbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJ1biBjb2xsaXNpb24gcmVzb2x1dGlvbiBzdHJhdGVneVxyXG4gICAgICAgICAgICAgICAgICAgIHBhaXJzID0gdGhpcy5fYnJvYWRwaGFzZS5yZXNvbHZlKHBhaXJzLCBjb2xsaXNpb25EZWx0YSwgUGh5c2ljc18xMi5QaHlzaWNzLmNvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYnJvYWRwaGFzZS5ydW5Db2xsaXNpb25TdGFydEVuZChwYWlycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlci0tO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGFmdGVyTmFycm93cGhhc2UgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgZW5naW5lLnN0YXRzLmN1cnJGcmFtZS5waHlzaWNzLmJyb2FkcGhhc2UgPSBhZnRlckJyb2FkcGhhc2UgLSBiZWZvcmVCcm9hZHBoYXNlO1xyXG4gICAgICAgICAgICAgICAgZW5naW5lLnN0YXRzLmN1cnJGcmFtZS5waHlzaWNzLm5hcnJvd3BoYXNlID0gYWZ0ZXJOYXJyb3dwaGFzZSAtIGJlZm9yZU5hcnJvd3BoYXNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVuZ2luZS5zdGF0cy5jdXJyRnJhbWUuYWN0b3JzLmtpbGxlZCA9IHRoaXMuX2tpbGxRdWV1ZS5sZW5ndGggKyB0aGlzLl90cmlnZ2VyS2lsbFF1ZXVlLmxlbmd0aDtcclxuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc0tpbGxRdWV1ZSh0aGlzLl9raWxsUXVldWUsIHRoaXMuYWN0b3JzKTtcclxuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc0tpbGxRdWV1ZSh0aGlzLl90cmlnZ2VyS2lsbFF1ZXVlLCB0aGlzLnRyaWdnZXJzKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY2FtZXJhKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbWVyYS51cGRhdGUoZW5naW5lLCBkZWx0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdwb3N0dXBkYXRlJywgbmV3IEV2ZW50c18xMy5Qb3N0VXBkYXRlRXZlbnQoZW5naW5lLCBkZWx0YSwgdGhpcykpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgU2NlbmUucHJvdG90eXBlLl9wcm9jZXNzS2lsbFF1ZXVlID0gZnVuY3Rpb24gKGtpbGxRdWV1ZSwgY29sbGVjdGlvbikge1xyXG4gICAgICAgICAgICAvLyBSZW1vdmUgYWN0b3JzIGZyb20gc2NlbmUgZ3JhcGggYWZ0ZXIgYmVpbmcga2lsbGVkXHJcbiAgICAgICAgICAgIHZhciBhY3RvckluZGV4O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGtpbGxRdWV1ZV8xID0ga2lsbFF1ZXVlOyBfaSA8IGtpbGxRdWV1ZV8xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGtpbGxlZCA9IGtpbGxRdWV1ZV8xW19pXTtcclxuICAgICAgICAgICAgICAgIGFjdG9ySW5kZXggPSBjb2xsZWN0aW9uLmluZGV4T2Yoa2lsbGVkKTtcclxuICAgICAgICAgICAgICAgIGlmIChhY3RvckluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zb3J0ZWREcmF3aW5nVHJlZS5yZW1vdmVCeUNvbXBhcmFibGUoa2lsbGVkKTtcclxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLnNwbGljZShhY3RvckluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBraWxsUXVldWUubGVuZ3RoID0gMDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERyYXdzIGFsbCB0aGUgYWN0b3JzIGluIHRoZSBTY2VuZS4gQ2FsbGVkIGJ5IHRoZSBbW0VuZ2luZV1dLlxyXG4gICAgICAgICAqIEBwYXJhbSBjdHggICAgVGhlIGN1cnJlbnQgcmVuZGVyaW5nIGNvbnRleHRcclxuICAgICAgICAgKiBAcGFyYW0gZGVsdGEgIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBsYXN0IGRyYXdcclxuICAgICAgICAgKi9cclxuICAgICAgICBTY2VuZS5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjdHgsIGRlbHRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncHJlZHJhdycsIG5ldyBFdmVudHNfMTMuUHJlRHJhd0V2ZW50KGN0eCwgZGVsdGEsIHRoaXMpKTtcclxuICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY2FtZXJhKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbWVyYS5kcmF3KGN0eCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGksIGxlbjtcclxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy50aWxlTWFwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50aWxlTWFwc1tpXS5kcmF3KGN0eCwgZGVsdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBzb3J0ZWRDaGlsZHJlbiA9IHRoaXMuX3NvcnRlZERyYXdpbmdUcmVlLmxpc3QoKTtcclxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gc29ydGVkQ2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIC8vIG9ubHkgZHJhdyBhY3RvcnMgdGhhdCBhcmUgdmlzaWJsZSBhbmQgb24gc2NyZWVuXHJcbiAgICAgICAgICAgICAgICBpZiAoc29ydGVkQ2hpbGRyZW5baV0udmlzaWJsZSAmJiAhc29ydGVkQ2hpbGRyZW5baV0uaXNPZmZTY3JlZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBzb3J0ZWRDaGlsZHJlbltpXS5kcmF3KGN0eCwgZGVsdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVuZ2luZSAmJiB0aGlzLmVuZ2luZS5pc0RlYnVnKSB7XHJcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAneWVsbG93JztcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVidWdEcmF3KGN0eCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy51aUFjdG9ycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gb25seSBkcmF3IHVpIGFjdG9ycyB0aGF0IGFyZSB2aXNpYmxlIGFuZCBvbiBzY3JlZW5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnVpQWN0b3JzW2ldLnZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVpQWN0b3JzW2ldLmRyYXcoY3R4LCBkZWx0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuZW5naW5lICYmIHRoaXMuZW5naW5lLmlzRGVidWcpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHRoaXMudWlBY3RvcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVpQWN0b3JzW2ldLmRlYnVnRHJhdyhjdHgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncG9zdGRyYXcnLCBuZXcgRXZlbnRzXzEzLlBvc3REcmF3RXZlbnQoY3R4LCBkZWx0YSwgdGhpcykpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRHJhd3MgYWxsIHRoZSBhY3RvcnMnIGRlYnVnIGluZm9ybWF0aW9uIGluIHRoZSBTY2VuZS4gQ2FsbGVkIGJ5IHRoZSBbW0VuZ2luZV1dLlxyXG4gICAgICAgICAqIEBwYXJhbSBjdHggIFRoZSBjdXJyZW50IHJlbmRlcmluZyBjb250ZXh0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBTY2VuZS5wcm90b3R5cGUuZGVidWdEcmF3ID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3ByZWRlYnVnZHJhdycsIG5ldyBFdmVudHNfMTMuUHJlRGVidWdEcmF3RXZlbnQoY3R4LCB0aGlzKSk7XHJcbiAgICAgICAgICAgIHZhciBpLCBsZW47XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHRoaXMudGlsZU1hcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGlsZU1hcHNbaV0uZGVidWdEcmF3KGN0eCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy5hY3RvcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWN0b3JzW2ldLmRlYnVnRHJhdyhjdHgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHRoaXMudHJpZ2dlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcnNbaV0uZGVidWdEcmF3KGN0eCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fYnJvYWRwaGFzZS5kZWJ1Z0RyYXcoY3R4LCAyMCk7XHJcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhLmRlYnVnRHJhdyhjdHgpO1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3Bvc3RkZWJ1Z2RyYXcnLCBuZXcgRXZlbnRzXzEzLlBvc3REZWJ1Z0RyYXdFdmVudChjdHgsIHRoaXMpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrcyB3aGV0aGVyIGFuIGFjdG9yIGlzIGNvbnRhaW5lZCBpbiB0aGlzIHNjZW5lIG9yIG5vdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChhY3Rvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY3RvcnMuaW5kZXhPZihhY3RvcikgPiAtMTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZW50aXR5KSB7XHJcbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBBY3Rvcl8xNC5BY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgZW50aXR5LnVua2lsbCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBVSUFjdG9yXzUuVUlBY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFVdGlsLmNvbnRhaW5zKHRoaXMudWlBY3RvcnMsIGVudGl0eSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFVJQWN0b3IoZW50aXR5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgQWN0b3JfMTQuQWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIGlmICghVXRpbC5jb250YWlucyh0aGlzLmFjdG9ycywgZW50aXR5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZENoaWxkKGVudGl0eSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIFRpbWVyXzMuVGltZXIpIHtcclxuICAgICAgICAgICAgICAgIGlmICghVXRpbC5jb250YWlucyh0aGlzLl90aW1lcnMsIGVudGl0eSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFRpbWVyKGVudGl0eSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIFRpbGVNYXBfMy5UaWxlTWFwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIVV0aWwuY29udGFpbnModGhpcy50aWxlTWFwcywgZW50aXR5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkVGlsZU1hcChlbnRpdHkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTY2VuZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGVudGl0eSkge1xyXG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgVUlBY3Rvcl81LlVJQWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlVUlBY3RvcihlbnRpdHkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBBY3Rvcl8xNC5BY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYnJvYWRwaGFzZS51bnRyYWNrKGVudGl0eS5ib2R5KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUNoaWxkKGVudGl0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIFRpbWVyXzMuVGltZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlVGltZXIoZW50aXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgVGlsZU1hcF8zLlRpbGVNYXApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlVGlsZU1hcChlbnRpdHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIChhbnkpIGFjdG9yIHRvIGFjdCBhcyBhIHBpZWNlIG9mIFVJLCBtZWFuaW5nIGl0IGlzIGFsd2F5cyBwb3NpdGlvbmVkXHJcbiAgICAgICAgICogaW4gc2NyZWVuIGNvb3JkaW5hdGVzLiBVSSBhY3RvcnMgZG8gbm90IHBhcnRpY2lwYXRlIGluIGNvbGxpc2lvbnMuXHJcbiAgICAgICAgICogQHRvZG8gU2hvdWxkIHRoaXMgYmUgYFVJQWN0b3JgIG9ubHk/XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2NlbmUucHJvdG90eXBlLmFkZFVJQWN0b3IgPSBmdW5jdGlvbiAoYWN0b3IpIHtcclxuICAgICAgICAgICAgdGhpcy51aUFjdG9ycy5wdXNoKGFjdG9yKTtcclxuICAgICAgICAgICAgYWN0b3Iuc2NlbmUgPSB0aGlzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlcyBhbiBhY3RvciBhcyBhIHBpZWNlIG9mIFVJXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2NlbmUucHJvdG90eXBlLnJlbW92ZVVJQWN0b3IgPSBmdW5jdGlvbiAoYWN0b3IpIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy51aUFjdG9ycy5pbmRleE9mKGFjdG9yKTtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudWlBY3RvcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhbiBhY3RvciB0byB0aGUgc2NlbmUsIG9uY2UgdGhpcyBpcyBkb25lIHRoZSBhY3RvciB3aWxsIGJlIGRyYXduIGFuZCB1cGRhdGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5fYWRkQ2hpbGQgPSBmdW5jdGlvbiAoYWN0b3IpIHtcclxuICAgICAgICAgICAgdGhpcy5fYnJvYWRwaGFzZS50cmFjayhhY3Rvci5ib2R5KTtcclxuICAgICAgICAgICAgYWN0b3Iuc2NlbmUgPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAoYWN0b3IgaW5zdGFuY2VvZiBUcmlnZ2VyXzMuVHJpZ2dlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2Vycy5wdXNoKGFjdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWN0b3JzLnB1c2goYWN0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3NvcnRlZERyYXdpbmdUcmVlLmFkZChhY3Rvcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgW1tUaWxlTWFwXV0gdG8gdGhlIHNjZW5lLCBvbmNlIHRoaXMgaXMgZG9uZSB0aGUgVGlsZU1hcCB3aWxsIGJlIGRyYXduIGFuZCB1cGRhdGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5hZGRUaWxlTWFwID0gZnVuY3Rpb24gKHRpbGVNYXApIHtcclxuICAgICAgICAgICAgdGhpcy50aWxlTWFwcy5wdXNoKHRpbGVNYXApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlcyBhIFtbVGlsZU1hcF1dIGZyb20gdGhlIHNjZW5lLCBpdCB3aWxsIG5vIGxvbmdlciBiZSBkcmF3biBvciB1cGRhdGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5yZW1vdmVUaWxlTWFwID0gZnVuY3Rpb24gKHRpbGVNYXApIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy50aWxlTWFwcy5pbmRleE9mKHRpbGVNYXApO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50aWxlTWFwcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGFuIGFjdG9yIGZyb20gdGhlIHNjZW5lLCBpdCB3aWxsIG5vIGxvbmdlciBiZSBkcmF3biBvciB1cGRhdGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5fcmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiAoYWN0b3IpIHtcclxuICAgICAgICAgICAgdGhpcy5fYnJvYWRwaGFzZS51bnRyYWNrKGFjdG9yLmJvZHkpO1xyXG4gICAgICAgICAgICBpZiAoYWN0b3IgaW5zdGFuY2VvZiBUcmlnZ2VyXzMuVHJpZ2dlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdHJpZ2dlcktpbGxRdWV1ZS5wdXNoKGFjdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2tpbGxRdWV1ZS5wdXNoKGFjdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhY3Rvci5wYXJlbnQgPSBudWxsO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhIFtbVGltZXJdXSB0byB0aGUgc2NlbmVcclxuICAgICAgICAgKiBAcGFyYW0gdGltZXIgIFRoZSB0aW1lciB0byBhZGRcclxuICAgICAgICAgKi9cclxuICAgICAgICBTY2VuZS5wcm90b3R5cGUuYWRkVGltZXIgPSBmdW5jdGlvbiAodGltZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fdGltZXJzLnB1c2godGltZXIpO1xyXG4gICAgICAgICAgICB0aW1lci5zY2VuZSA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiB0aW1lcjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgYSBbW1RpbWVyXV0gZnJvbSB0aGUgc2NlbmUuXHJcbiAgICAgICAgICogQHdhcm5pbmcgQ2FuIGJlIGRhbmdlcm91cywgdXNlIFtbY2FuY2VsVGltZXJdXSBpbnN0ZWFkXHJcbiAgICAgICAgICogQHBhcmFtIHRpbWVyICBUaGUgdGltZXIgdG8gcmVtb3ZlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2NlbmUucHJvdG90eXBlLnJlbW92ZVRpbWVyID0gZnVuY3Rpb24gKHRpbWVyKSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5fdGltZXJzLmluZGV4T2YodGltZXIpO1xyXG4gICAgICAgICAgICBpZiAoaSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVycy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRpbWVyO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FuY2VscyBhIFtbVGltZXJdXSwgcmVtb3ZpbmcgaXQgZnJvbSB0aGUgc2NlbmUgbmljZWx5XHJcbiAgICAgICAgICogQHBhcmFtIHRpbWVyICBUaGUgdGltZXIgdG8gY2FuY2VsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2NlbmUucHJvdG90eXBlLmNhbmNlbFRpbWVyID0gZnVuY3Rpb24gKHRpbWVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbmNlbFF1ZXVlLnB1c2godGltZXIpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGltZXI7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZXN0cyB3aGV0aGVyIGEgW1tUaW1lcl1dIGlzIGFjdGl2ZSBpbiB0aGUgc2NlbmVcclxuICAgICAgICAgKi9cclxuICAgICAgICBTY2VuZS5wcm90b3R5cGUuaXNUaW1lckFjdGl2ZSA9IGZ1bmN0aW9uICh0aW1lcikge1xyXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuX3RpbWVycy5pbmRleE9mKHRpbWVyKSA+IC0xICYmICF0aW1lci5jb21wbGV0ZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGFuZCBhZGRzIGEgW1tHcm91cF1dIHRvIHRoZSBzY2VuZSB3aXRoIGEgbmFtZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5jcmVhdGVHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgR3JvdXBfMi5Hcm91cChuYW1lLCB0aGlzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBbW0dyb3VwXV0gYnkgbmFtZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5nZXRHcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdyb3Vwc1tuYW1lXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5yZW1vdmVHcm91cCA9IGZ1bmN0aW9uIChncm91cCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGdyb3VwID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZ3JvdXBzW2dyb3VwXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChncm91cCBpbnN0YW5jZW9mIEdyb3VwXzIuR3JvdXApIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmdyb3Vwc1tncm91cC5uYW1lXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcignSW52YWxpZCBhcmd1bWVudHMgdG8gcmVtb3ZlR3JvdXAnLCBncm91cCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgdGhlIGdpdmVuIGFjdG9yIGZyb20gdGhlIHNvcnRlZCBkcmF3aW5nIHRyZWVcclxuICAgICAgICAgKi9cclxuICAgICAgICBTY2VuZS5wcm90b3R5cGUuY2xlYW51cERyYXdUcmVlID0gZnVuY3Rpb24gKGFjdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NvcnRlZERyYXdpbmdUcmVlLnJlbW92ZUJ5Q29tcGFyYWJsZShhY3Rvcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGVzIHRoZSBnaXZlbiBhY3RvcidzIHBvc2l0aW9uIGluIHRoZSBzb3J0ZWQgZHJhd2luZyB0cmVlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2NlbmUucHJvdG90eXBlLnVwZGF0ZURyYXdUcmVlID0gZnVuY3Rpb24gKGFjdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NvcnRlZERyYXdpbmdUcmVlLmFkZChhY3Rvcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTY2VuZS5wcm90b3R5cGUuX2NvbGxlY3RBY3RvclN0YXRzID0gZnVuY3Rpb24gKGVuZ2luZSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy51aUFjdG9yczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdWkgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICBlbmdpbmUuc3RhdHMuY3VyckZyYW1lLmFjdG9ycy51aSsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSB0aGlzLmFjdG9yczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBhY3RvciA9IF9jW19iXTtcclxuICAgICAgICAgICAgICAgIGVuZ2luZS5zdGF0cy5jdXJyRnJhbWUuYWN0b3JzLmFsaXZlKys7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfZCA9IDAsIF9lID0gYWN0b3IuY2hpbGRyZW47IF9kIDwgX2UubGVuZ3RoOyBfZCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gX2VbX2RdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChBY3RvclV0aWxzLmlzVUlBY3RvcihjaGlsZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5naW5lLnN0YXRzLmN1cnJGcmFtZS5hY3RvcnMudWkrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZ2luZS5zdGF0cy5jdXJyRnJhbWUuYWN0b3JzLmFsaXZlKys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gU2NlbmU7XHJcbiAgICB9KENsYXNzXzEwLkNsYXNzKSk7XHJcbiAgICBleHBvcnRzLlNjZW5lID0gU2NlbmU7XHJcbn0pO1xyXG5kZWZpbmUoXCJFdmVudHNcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogQmFzZSBldmVudCB0eXBlIGluIEV4Y2FsaWJ1ciB0aGF0IGFsbCBvdGhlciBldmVudCB0eXBlcyBkZXJpdmUgZnJvbS4gTm90IGFsbCBldmVudCB0eXBlcyBhcmUgdGhyb3duIG9uIGFsbCBFeGNhbGlidXIgZ2FtZSBvYmplY3RzLFxyXG4gICAgICogc29tZSBldmVudHMgYXJlIHVuaXF1ZSB0byBhIHR5cGUsIG90aGVycyBhcmUgbm90LlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgdmFyIEdhbWVFdmVudCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gR2FtZUV2ZW50KCkge1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gR2FtZUV2ZW50O1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuR2FtZUV2ZW50ID0gR2FtZUV2ZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgJ2tpbGwnIGV2ZW50IGlzIGVtaXR0ZWQgb24gYWN0b3JzIHdoZW4gaXQgaXMga2lsbGVkLiBUaGUgdGFyZ2V0IGlzIHRoZSBhY3RvciB0aGF0IHdhcyBraWxsZWQuXHJcbiAgICAgKi9cclxuICAgIHZhciBLaWxsRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhLaWxsRXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gS2lsbEV2ZW50KHRhcmdldCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEtpbGxFdmVudDtcclxuICAgIH0oR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLktpbGxFdmVudCA9IEtpbGxFdmVudDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlICdzdGFydCcgZXZlbnQgaXMgZW1pdHRlZCBvbiBlbmdpbmUgd2hlbiBoYXMgc3RhcnRlZCBhbmQgaXMgcmVhZHkgZm9yIGludGVyYWN0aW9uLlxyXG4gICAgICovXHJcbiAgICB2YXIgR2FtZVN0YXJ0RXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhHYW1lU3RhcnRFdmVudCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBHYW1lU3RhcnRFdmVudCh0YXJnZXQpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBHYW1lU3RhcnRFdmVudDtcclxuICAgIH0oR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLkdhbWVTdGFydEV2ZW50ID0gR2FtZVN0YXJ0RXZlbnQ7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSAnc3RvcCcgZXZlbnQgaXMgZW1pdHRlZCBvbiBlbmdpbmUgd2hlbiBoYXMgYmVlbiBzdG9wcGVkIGFuZCB3aWxsIG5vIGxvbmdlciB0YWtlIGlucHV0LCB1cGRhdGUgb3IgZHJhdy5cclxuICAgICAqL1xyXG4gICAgdmFyIEdhbWVTdG9wRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhHYW1lU3RvcEV2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIEdhbWVTdG9wRXZlbnQodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gR2FtZVN0b3BFdmVudDtcclxuICAgIH0oR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLkdhbWVTdG9wRXZlbnQgPSBHYW1lU3RvcEV2ZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgJ3ByZWRyYXcnIGV2ZW50IGlzIGVtaXR0ZWQgb24gYWN0b3JzLCBzY2VuZXMsIGFuZCBlbmdpbmUgYmVmb3JlIGRyYXdpbmcgc3RhcnRzLiBBY3RvcnMnIHByZWRyYXcgaGFwcGVucyBpbnNpZGUgdGhlaXIgZ3JhcGhpY3NcclxuICAgICAqIHRyYW5zZm9ybSBzbyB0aGF0IGFsbCBkcmF3aW5nIHRha2VzIHBsYWNlIHdpdGggdGhlIGFjdG9yIGFzIHRoZSBvcmlnaW4uXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICB2YXIgUHJlRHJhd0V2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoUHJlRHJhd0V2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFByZURyYXdFdmVudChjdHgsIGRlbHRhLCB0YXJnZXQpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuY3R4ID0gY3R4O1xyXG4gICAgICAgICAgICBfdGhpcy5kZWx0YSA9IGRlbHRhO1xyXG4gICAgICAgICAgICBfdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFByZURyYXdFdmVudDtcclxuICAgIH0oR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLlByZURyYXdFdmVudCA9IFByZURyYXdFdmVudDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlICdwb3N0ZHJhdycgZXZlbnQgaXMgZW1pdHRlZCBvbiBhY3RvcnMsIHNjZW5lcywgYW5kIGVuZ2luZSBhZnRlciBkcmF3aW5nIGZpbmlzaGVzLiBBY3RvcnMnIHBvc3RkcmF3IGhhcHBlbnMgaW5zaWRlIHRoZWlyIGdyYXBoaWNzXHJcbiAgICAgKiB0cmFuc2Zvcm0gc28gdGhhdCBhbGwgZHJhd2luZyB0YWtlcyBwbGFjZSB3aXRoIHRoZSBhY3RvciBhcyB0aGUgb3JpZ2luLlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgdmFyIFBvc3REcmF3RXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhQb3N0RHJhd0V2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFBvc3REcmF3RXZlbnQoY3R4LCBkZWx0YSwgdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLmN0eCA9IGN0eDtcclxuICAgICAgICAgICAgX3RoaXMuZGVsdGEgPSBkZWx0YTtcclxuICAgICAgICAgICAgX3RoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQb3N0RHJhd0V2ZW50O1xyXG4gICAgfShHYW1lRXZlbnQpKTtcclxuICAgIGV4cG9ydHMuUG9zdERyYXdFdmVudCA9IFBvc3REcmF3RXZlbnQ7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSAncHJlZGVidWdkcmF3JyBldmVudCBpcyBlbWl0dGVkIG9uIGFjdG9ycywgc2NlbmVzLCBhbmQgZW5naW5lIGJlZm9yZSBkZWJ1ZyBkcmF3aW5nIHN0YXJ0cy5cclxuICAgICAqL1xyXG4gICAgdmFyIFByZURlYnVnRHJhd0V2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoUHJlRGVidWdEcmF3RXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gUHJlRGVidWdEcmF3RXZlbnQoY3R4LCB0YXJnZXQpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuY3R4ID0gY3R4O1xyXG4gICAgICAgICAgICBfdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFByZURlYnVnRHJhd0V2ZW50O1xyXG4gICAgfShHYW1lRXZlbnQpKTtcclxuICAgIGV4cG9ydHMuUHJlRGVidWdEcmF3RXZlbnQgPSBQcmVEZWJ1Z0RyYXdFdmVudDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlICdwb3N0ZGVidWdkcmF3JyBldmVudCBpcyBlbWl0dGVkIG9uIGFjdG9ycywgc2NlbmVzLCBhbmQgZW5naW5lIGFmdGVyIGRlYnVnIGRyYXdpbmcgc3RhcnRzLlxyXG4gICAgICovXHJcbiAgICB2YXIgUG9zdERlYnVnRHJhd0V2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoUG9zdERlYnVnRHJhd0V2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFBvc3REZWJ1Z0RyYXdFdmVudChjdHgsIHRhcmdldCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5jdHggPSBjdHg7XHJcbiAgICAgICAgICAgIF90aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUG9zdERlYnVnRHJhd0V2ZW50O1xyXG4gICAgfShHYW1lRXZlbnQpKTtcclxuICAgIGV4cG9ydHMuUG9zdERlYnVnRHJhd0V2ZW50ID0gUG9zdERlYnVnRHJhd0V2ZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgJ3ByZXVwZGF0ZScgZXZlbnQgaXMgZW1pdHRlZCBvbiBhY3RvcnMsIHNjZW5lcywgYW5kIGVuZ2luZSBiZWZvcmUgdGhlIHVwZGF0ZSBzdGFydHMuXHJcbiAgICAgKi9cclxuICAgIHZhciBQcmVVcGRhdGVFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFByZVVwZGF0ZUV2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFByZVVwZGF0ZUV2ZW50KGVuZ2luZSwgZGVsdGEsIHRhcmdldCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5lbmdpbmUgPSBlbmdpbmU7XHJcbiAgICAgICAgICAgIF90aGlzLmRlbHRhID0gZGVsdGE7XHJcbiAgICAgICAgICAgIF90aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUHJlVXBkYXRlRXZlbnQ7XHJcbiAgICB9KEdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5QcmVVcGRhdGVFdmVudCA9IFByZVVwZGF0ZUV2ZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgJ3Bvc3R1cGRhdGUnIGV2ZW50IGlzIGVtaXR0ZWQgb24gYWN0b3JzLCBzY2VuZXMsIGFuZCBlbmdpbmUgYWZ0ZXIgdGhlIHVwZGF0ZSBlbmRzLlxyXG4gICAgICovXHJcbiAgICB2YXIgUG9zdFVwZGF0ZUV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoUG9zdFVwZGF0ZUV2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFBvc3RVcGRhdGVFdmVudChlbmdpbmUsIGRlbHRhLCB0YXJnZXQpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuZW5naW5lID0gZW5naW5lO1xyXG4gICAgICAgICAgICBfdGhpcy5kZWx0YSA9IGRlbHRhO1xyXG4gICAgICAgICAgICBfdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFBvc3RVcGRhdGVFdmVudDtcclxuICAgIH0oR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLlBvc3RVcGRhdGVFdmVudCA9IFBvc3RVcGRhdGVFdmVudDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlICdwcmVmcmFtZScgZXZlbnQgaXMgZW1pdHRlZCBvbiB0aGUgZW5naW5lLCBiZWZvcmUgdGhlIGZyYW1lIGJlZ2lucy5cclxuICAgICAqL1xyXG4gICAgdmFyIFByZUZyYW1lRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhQcmVGcmFtZUV2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFByZUZyYW1lRXZlbnQoZW5naW5lLCBwcmV2U3RhdHMpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuZW5naW5lID0gZW5naW5lO1xyXG4gICAgICAgICAgICBfdGhpcy5wcmV2U3RhdHMgPSBwcmV2U3RhdHM7XHJcbiAgICAgICAgICAgIF90aGlzLnRhcmdldCA9IGVuZ2luZTtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUHJlRnJhbWVFdmVudDtcclxuICAgIH0oR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLlByZUZyYW1lRXZlbnQgPSBQcmVGcmFtZUV2ZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgJ3Bvc3RmcmFtZScgZXZlbnQgaXMgZW1pdHRlZCBvbiB0aGUgZW5naW5lLCBhZnRlciBhIGZyYW1lIGVuZHMuXHJcbiAgICAgKi9cclxuICAgIHZhciBQb3N0RnJhbWVFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFBvc3RGcmFtZUV2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFBvc3RGcmFtZUV2ZW50KGVuZ2luZSwgc3RhdHMpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuZW5naW5lID0gZW5naW5lO1xyXG4gICAgICAgICAgICBfdGhpcy5zdGF0cyA9IHN0YXRzO1xyXG4gICAgICAgICAgICBfdGhpcy50YXJnZXQgPSBlbmdpbmU7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFBvc3RGcmFtZUV2ZW50O1xyXG4gICAgfShHYW1lRXZlbnQpKTtcclxuICAgIGV4cG9ydHMuUG9zdEZyYW1lRXZlbnQgPSBQb3N0RnJhbWVFdmVudDtcclxuICAgIC8qKlxyXG4gICAgICogRXZlbnQgcmVjZWl2ZWQgd2hlbiBhIGdhbWVwYWQgaXMgY29ubmVjdGVkIHRvIEV4Y2FsaWJ1ci4gW1tHYW1lcGFkc11dIHJlY2VpdmVzIHRoaXMgZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIHZhciBHYW1lcGFkQ29ubmVjdEV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoR2FtZXBhZENvbm5lY3RFdmVudCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBHYW1lcGFkQ29ubmVjdEV2ZW50KGluZGV4LCBnYW1lcGFkKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgICAgIF90aGlzLmdhbWVwYWQgPSBnYW1lcGFkO1xyXG4gICAgICAgICAgICBfdGhpcy50YXJnZXQgPSBnYW1lcGFkO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBHYW1lcGFkQ29ubmVjdEV2ZW50O1xyXG4gICAgfShHYW1lRXZlbnQpKTtcclxuICAgIGV4cG9ydHMuR2FtZXBhZENvbm5lY3RFdmVudCA9IEdhbWVwYWRDb25uZWN0RXZlbnQ7XHJcbiAgICAvKipcclxuICAgICAqIEV2ZW50IHJlY2VpdmVkIHdoZW4gYSBnYW1lcGFkIGlzIGRpc2Nvbm5lY3RlZCBmcm9tIEV4Y2FsaWJ1ci4gW1tHYW1lcGFkc11dIHJlY2VpdmVzIHRoaXMgZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIHZhciBHYW1lcGFkRGlzY29ubmVjdEV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoR2FtZXBhZERpc2Nvbm5lY3RFdmVudCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBHYW1lcGFkRGlzY29ubmVjdEV2ZW50KGluZGV4LCBnYW1lcGFkKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgICAgIF90aGlzLmdhbWVwYWQgPSBnYW1lcGFkO1xyXG4gICAgICAgICAgICBfdGhpcy50YXJnZXQgPSBnYW1lcGFkO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBHYW1lcGFkRGlzY29ubmVjdEV2ZW50O1xyXG4gICAgfShHYW1lRXZlbnQpKTtcclxuICAgIGV4cG9ydHMuR2FtZXBhZERpc2Nvbm5lY3RFdmVudCA9IEdhbWVwYWREaXNjb25uZWN0RXZlbnQ7XHJcbiAgICAvKipcclxuICAgICAqIEdhbWVwYWQgYnV0dG9uIGV2ZW50LiBTZWUgW1tHYW1lcGFkc11dIGZvciBpbmZvcm1hdGlvbiBvbiByZXNwb25kaW5nIHRvIGNvbnRyb2xsZXIgaW5wdXQuIFtbR2FtZXBhZF1dIGluc3RhbmNlcyByZWNlaXZlIHRoaXMgZXZlbnQ7XHJcbiAgICAgKi9cclxuICAgIHZhciBHYW1lcGFkQnV0dG9uRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhHYW1lcGFkQnV0dG9uRXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIGJ1dHRvbiAgVGhlIEdhbWVwYWQgYnV0dG9uXHJcbiAgICAgICAgICogQHBhcmFtIHZhbHVlICAgQSBudW1lcmljIHZhbHVlIGJldHdlZW4gMCBhbmQgMVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIEdhbWVwYWRCdXR0b25FdmVudChidXR0b24sIHZhbHVlLCB0YXJnZXQpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuYnV0dG9uID0gYnV0dG9uO1xyXG4gICAgICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICBfdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEdhbWVwYWRCdXR0b25FdmVudDtcclxuICAgIH0oR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLkdhbWVwYWRCdXR0b25FdmVudCA9IEdhbWVwYWRCdXR0b25FdmVudDtcclxuICAgIC8qKlxyXG4gICAgICogR2FtZXBhZCBheGlzIGV2ZW50LiBTZWUgW1tHYW1lcGFkc11dIGZvciBpbmZvcm1hdGlvbiBvbiByZXNwb25kaW5nIHRvIGNvbnRyb2xsZXIgaW5wdXQuIFtbR2FtZXBhZF1dIGluc3RhbmNlcyByZWNlaXZlIHRoaXMgZXZlbnQ7XHJcbiAgICAgKi9cclxuICAgIHZhciBHYW1lcGFkQXhpc0V2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoR2FtZXBhZEF4aXNFdmVudCwgX3N1cGVyKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gYXhpcyAgVGhlIEdhbWVwYWQgYXhpc1xyXG4gICAgICAgICAqIEBwYXJhbSB2YWx1ZSBBIG51bWVyaWMgdmFsdWUgYmV0d2VlbiAtMSBhbmQgMVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIEdhbWVwYWRBeGlzRXZlbnQoYXhpcywgdmFsdWUsIHRhcmdldCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5heGlzID0gYXhpcztcclxuICAgICAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgX3RoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBHYW1lcGFkQXhpc0V2ZW50O1xyXG4gICAgfShHYW1lRXZlbnQpKTtcclxuICAgIGV4cG9ydHMuR2FtZXBhZEF4aXNFdmVudCA9IEdhbWVwYWRBeGlzRXZlbnQ7XHJcbiAgICAvKipcclxuICAgICAqIFN1YnNjcmliZSBldmVudCB0aHJvd24gd2hlbiBoYW5kbGVycyBmb3IgZXZlbnRzIG90aGVyIHRoYW4gc3Vic2NyaWJlIGFyZSBhZGRlZC4gTWV0YSBldmVudCB0aGF0IGlzIHJlY2VpdmVkIGJ5XHJcbiAgICAgKiBbW0V2ZW50RGlzcGF0Y2hlcnxldmVudCBkaXNwYXRjaGVyc11dLlxyXG4gICAgICovXHJcbiAgICB2YXIgU3Vic2NyaWJlRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhTdWJzY3JpYmVFdmVudCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBTdWJzY3JpYmVFdmVudCh0b3BpYywgaGFuZGxlcikge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy50b3BpYyA9IHRvcGljO1xyXG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gU3Vic2NyaWJlRXZlbnQ7XHJcbiAgICB9KEdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5TdWJzY3JpYmVFdmVudCA9IFN1YnNjcmliZUV2ZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBVbnN1YnNjcmliZSBldmVudCB0aHJvd24gd2hlbiBoYW5kbGVycyBmb3IgZXZlbnRzIG90aGVyIHRoYW4gdW5zdWJzY3JpYmUgYXJlIHJlbW92ZWQuIE1ldGEgZXZlbnQgdGhhdCBpcyByZWNlaXZlZCBieVxyXG4gICAgICogW1tFdmVudERpc3BhdGNoZXJ8ZXZlbnQgZGlzcGF0Y2hlcnNdXS5cclxuICAgICAqL1xyXG4gICAgdmFyIFVuc3Vic2NyaWJlRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhVbnN1YnNjcmliZUV2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFVuc3Vic2NyaWJlRXZlbnQodG9waWMsIGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMudG9waWMgPSB0b3BpYztcclxuICAgICAgICAgICAgX3RoaXMuaGFuZGxlciA9IGhhbmRsZXI7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFVuc3Vic2NyaWJlRXZlbnQ7XHJcbiAgICB9KEdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5VbnN1YnNjcmliZUV2ZW50ID0gVW5zdWJzY3JpYmVFdmVudDtcclxuICAgIC8qKlxyXG4gICAgICogRXZlbnQgcmVjZWl2ZWQgYnkgdGhlIFtbRW5naW5lXV0gd2hlbiB0aGUgYnJvd3NlciB3aW5kb3cgaXMgdmlzaWJsZSBvbiBhIHNjcmVlbi5cclxuICAgICAqL1xyXG4gICAgdmFyIFZpc2libGVFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFZpc2libGVFdmVudCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBWaXNpYmxlRXZlbnQodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gVmlzaWJsZUV2ZW50O1xyXG4gICAgfShHYW1lRXZlbnQpKTtcclxuICAgIGV4cG9ydHMuVmlzaWJsZUV2ZW50ID0gVmlzaWJsZUV2ZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBFdmVudCByZWNlaXZlZCBieSB0aGUgW1tFbmdpbmVdXSB3aGVuIHRoZSBicm93c2VyIHdpbmRvdyBpcyBoaWRkZW4gZnJvbSBhbGwgc2NyZWVucy5cclxuICAgICAqL1xyXG4gICAgdmFyIEhpZGRlbkV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoSGlkZGVuRXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gSGlkZGVuRXZlbnQodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gSGlkZGVuRXZlbnQ7XHJcbiAgICB9KEdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5IaWRkZW5FdmVudCA9IEhpZGRlbkV2ZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBFdmVudCB0aHJvd24gb24gYW4gW1tBY3RvcnxhY3Rvcl1dIHdoZW4gYSBjb2xsaXNpb24gd2lsbCBvY2N1ciB0aGlzIGZyYW1lIGlmIGl0IHJlc29sdmVzXHJcbiAgICAgKi9cclxuICAgIHZhciBQcmVDb2xsaXNpb25FdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFByZUNvbGxpc2lvbkV2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBhY3RvciAgICAgICAgIFRoZSBhY3RvciB0aGUgZXZlbnQgd2FzIHRocm93biBvblxyXG4gICAgICAgICAqIEBwYXJhbSBvdGhlciAgICAgICAgIFRoZSBhY3RvciB0aGF0IHdpbGwgY29sbGlkZWQgd2l0aCB0aGUgY3VycmVudCBhY3RvclxyXG4gICAgICAgICAqIEBwYXJhbSBzaWRlICAgICAgICAgIFRoZSBzaWRlIHRoYXQgd2lsbCBiZSBjb2xsaWRlZCB3aXRoIHRoZSBjdXJyZW50IGFjdG9yXHJcbiAgICAgICAgICogQHBhcmFtIGludGVyc2VjdGlvbiAgSW50ZXJzZWN0aW9uIHZlY3RvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIFByZUNvbGxpc2lvbkV2ZW50KGFjdG9yLCBvdGhlciwgc2lkZSwgaW50ZXJzZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLmFjdG9yID0gYWN0b3I7XHJcbiAgICAgICAgICAgIF90aGlzLm90aGVyID0gb3RoZXI7XHJcbiAgICAgICAgICAgIF90aGlzLnNpZGUgPSBzaWRlO1xyXG4gICAgICAgICAgICBfdGhpcy5pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb247XHJcbiAgICAgICAgICAgIF90aGlzLnRhcmdldCA9IGFjdG9yO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQcmVDb2xsaXNpb25FdmVudDtcclxuICAgIH0oR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLlByZUNvbGxpc2lvbkV2ZW50ID0gUHJlQ29sbGlzaW9uRXZlbnQ7XHJcbiAgICAvKipcclxuICAgICAqIEV2ZW50IHRocm93biBvbiBhbiBbW0FjdG9yfGFjdG9yXV0gd2hlbiBhIGNvbGxpc2lvbiBoYXMgYmVlbiByZXNvbHZlZCAoYm9keSByZWFjdGVkKSB0aGlzIGZyYW1lXHJcbiAgICAgKi9cclxuICAgIHZhciBQb3N0Q29sbGlzaW9uRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhQb3N0Q29sbGlzaW9uRXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIGFjdG9yICAgICAgICAgVGhlIGFjdG9yIHRoZSBldmVudCB3YXMgdGhyb3duIG9uXHJcbiAgICAgICAgICogQHBhcmFtIG90aGVyICAgICAgICAgVGhlIGFjdG9yIHRoYXQgZGlkIGNvbGxpZGUgd2l0aCB0aGUgY3VycmVudCBhY3RvclxyXG4gICAgICAgICAqIEBwYXJhbSBzaWRlICAgICAgICAgIFRoZSBzaWRlIHRoYXQgZGlkIGNvbGxpZGUgd2l0aCB0aGUgY3VycmVudCBhY3RvclxyXG4gICAgICAgICAqIEBwYXJhbSBpbnRlcnNlY3Rpb24gIEludGVyc2VjdGlvbiB2ZWN0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBQb3N0Q29sbGlzaW9uRXZlbnQoYWN0b3IsIG90aGVyLCBzaWRlLCBpbnRlcnNlY3Rpb24pIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuYWN0b3IgPSBhY3RvcjtcclxuICAgICAgICAgICAgX3RoaXMub3RoZXIgPSBvdGhlcjtcclxuICAgICAgICAgICAgX3RoaXMuc2lkZSA9IHNpZGU7XHJcbiAgICAgICAgICAgIF90aGlzLmludGVyc2VjdGlvbiA9IGludGVyc2VjdGlvbjtcclxuICAgICAgICAgICAgX3RoaXMudGFyZ2V0ID0gYWN0b3I7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFBvc3RDb2xsaXNpb25FdmVudDtcclxuICAgIH0oR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLlBvc3RDb2xsaXNpb25FdmVudCA9IFBvc3RDb2xsaXNpb25FdmVudDtcclxuICAgIC8qKlxyXG4gICAgICogRXZlbnQgdGhyb3duIHRoZSBmaXJzdCB0aW1lIGFuIFtbQWN0b3J8YWN0b3JdXSBjb2xsaWRlcyB3aXRoIGFub3RoZXIsIGFmdGVyIGFuIGFjdG9yIGlzIGluIGNvbnRhY3Qgbm9ybWFsIGNvbGxpc2lvbiBldmVudHMgYXJlIGZpcmVkLlxyXG4gICAgICovXHJcbiAgICB2YXIgQ29sbGlzaW9uU3RhcnRFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKENvbGxpc2lvblN0YXJ0RXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBDb2xsaXNpb25TdGFydEV2ZW50KGFjdG9yLCBvdGhlciwgcGFpcikge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5hY3RvciA9IGFjdG9yO1xyXG4gICAgICAgICAgICBfdGhpcy5vdGhlciA9IG90aGVyO1xyXG4gICAgICAgICAgICBfdGhpcy5wYWlyID0gcGFpcjtcclxuICAgICAgICAgICAgX3RoaXMudGFyZ2V0ID0gYWN0b3I7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIENvbGxpc2lvblN0YXJ0RXZlbnQ7XHJcbiAgICB9KEdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5Db2xsaXNpb25TdGFydEV2ZW50ID0gQ29sbGlzaW9uU3RhcnRFdmVudDtcclxuICAgIC8qKlxyXG4gICAgICogRXZlbnQgdGhyb3duIHdoZW4gdGhlIFtbQWN0b3J8YWN0b3JdXSBpcyBubyBsb25nZXIgY29sbGlkaW5nIHdpdGggYW5vdGhlclxyXG4gICAgICovXHJcbiAgICB2YXIgQ29sbGlzaW9uRW5kRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhDb2xsaXNpb25FbmRFdmVudCwgX3N1cGVyKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIENvbGxpc2lvbkVuZEV2ZW50KGFjdG9yLCBvdGhlcikge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5hY3RvciA9IGFjdG9yO1xyXG4gICAgICAgICAgICBfdGhpcy5vdGhlciA9IG90aGVyO1xyXG4gICAgICAgICAgICBfdGhpcy50YXJnZXQgPSBhY3RvcjtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gQ29sbGlzaW9uRW5kRXZlbnQ7XHJcbiAgICB9KEdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5Db2xsaXNpb25FbmRFdmVudCA9IENvbGxpc2lvbkVuZEV2ZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBFdmVudCB0aHJvd24gb24gYW4gW1tBY3Rvcl1dIGFuZCBhIFtbU2NlbmVdXSBvbmx5IG9uY2UgYmVmb3JlIHRoZSBmaXJzdCB1cGRhdGUgY2FsbFxyXG4gICAgICovXHJcbiAgICB2YXIgSW5pdGlhbGl6ZUV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoSW5pdGlhbGl6ZUV2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBlbmdpbmUgIFRoZSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZW5naW5lXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gSW5pdGlhbGl6ZUV2ZW50KGVuZ2luZSwgdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLmVuZ2luZSA9IGVuZ2luZTtcclxuICAgICAgICAgICAgX3RoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBJbml0aWFsaXplRXZlbnQ7XHJcbiAgICB9KEdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5Jbml0aWFsaXplRXZlbnQgPSBJbml0aWFsaXplRXZlbnQ7XHJcbiAgICAvKipcclxuICAgICAqIEV2ZW50IHRocm93biBvbiBhIFtbU2NlbmVdXSBvbiBhY3RpdmF0aW9uXHJcbiAgICAgKi9cclxuICAgIHZhciBBY3RpdmF0ZUV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoQWN0aXZhdGVFdmVudCwgX3N1cGVyKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gb2xkU2NlbmUgIFRoZSByZWZlcmVuY2UgdG8gdGhlIG9sZCBzY2VuZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIEFjdGl2YXRlRXZlbnQob2xkU2NlbmUsIHRhcmdldCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5vbGRTY2VuZSA9IG9sZFNjZW5lO1xyXG4gICAgICAgICAgICBfdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEFjdGl2YXRlRXZlbnQ7XHJcbiAgICB9KEdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5BY3RpdmF0ZUV2ZW50ID0gQWN0aXZhdGVFdmVudDtcclxuICAgIC8qKlxyXG4gICAgICogRXZlbnQgdGhyb3duIG9uIGEgW1tTY2VuZV1dIG9uIGRlYWN0aXZhdGlvblxyXG4gICAgICovXHJcbiAgICB2YXIgRGVhY3RpdmF0ZUV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoRGVhY3RpdmF0ZUV2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBuZXdTY2VuZSAgVGhlIHJlZmVyZW5jZSB0byB0aGUgbmV3IHNjZW5lXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gRGVhY3RpdmF0ZUV2ZW50KG5ld1NjZW5lLCB0YXJnZXQpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMubmV3U2NlbmUgPSBuZXdTY2VuZTtcclxuICAgICAgICAgICAgX3RoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBEZWFjdGl2YXRlRXZlbnQ7XHJcbiAgICB9KEdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5EZWFjdGl2YXRlRXZlbnQgPSBEZWFjdGl2YXRlRXZlbnQ7XHJcbiAgICAvKipcclxuICAgICAqIEV2ZW50IHRocm93biBvbiBhbiBbW0FjdG9yXV0gd2hlbiBpdCBjb21wbGV0ZWx5IGxlYXZlcyB0aGUgc2NyZWVuLlxyXG4gICAgICovXHJcbiAgICB2YXIgRXhpdFZpZXdQb3J0RXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhFeGl0Vmlld1BvcnRFdmVudCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBFeGl0Vmlld1BvcnRFdmVudCh0YXJnZXQpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBFeGl0Vmlld1BvcnRFdmVudDtcclxuICAgIH0oR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLkV4aXRWaWV3UG9ydEV2ZW50ID0gRXhpdFZpZXdQb3J0RXZlbnQ7XHJcbiAgICAvKipcclxuICAgICAqIEV2ZW50IHRocm93biBvbiBhbiBbW0FjdG9yXV0gd2hlbiBpdCBjb21wbGV0ZWx5IGxlYXZlcyB0aGUgc2NyZWVuLlxyXG4gICAgICovXHJcbiAgICB2YXIgRW50ZXJWaWV3UG9ydEV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoRW50ZXJWaWV3UG9ydEV2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIEVudGVyVmlld1BvcnRFdmVudCh0YXJnZXQpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBFbnRlclZpZXdQb3J0RXZlbnQ7XHJcbiAgICB9KEdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5FbnRlclZpZXdQb3J0RXZlbnQgPSBFbnRlclZpZXdQb3J0RXZlbnQ7XHJcbiAgICB2YXIgRW50ZXJUcmlnZ2VyRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhFbnRlclRyaWdnZXJFdmVudCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBFbnRlclRyaWdnZXJFdmVudCh0YXJnZXQsIGFjdG9yKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgX3RoaXMuYWN0b3IgPSBhY3RvcjtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gRW50ZXJUcmlnZ2VyRXZlbnQ7XHJcbiAgICB9KEdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5FbnRlclRyaWdnZXJFdmVudCA9IEVudGVyVHJpZ2dlckV2ZW50O1xyXG4gICAgdmFyIEV4aXRUcmlnZ2VyRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhFeGl0VHJpZ2dlckV2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIEV4aXRUcmlnZ2VyRXZlbnQodGFyZ2V0LCBhY3Rvcikge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIF90aGlzLmFjdG9yID0gYWN0b3I7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEV4aXRUcmlnZ2VyRXZlbnQ7XHJcbiAgICB9KEdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5FeGl0VHJpZ2dlckV2ZW50ID0gRXhpdFRyaWdnZXJFdmVudDtcclxufSk7XHJcbmRlZmluZShcIkNsYXNzXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiRXZlbnREaXNwYXRjaGVyXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgRXZlbnREaXNwYXRjaGVyXzMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFeGNhbGlidXIgYmFzZSBjbGFzcyB0aGF0IHByb3ZpZGVzIGJhc2ljIGZ1bmN0aW9uYWxpdHkgc3VjaCBhcyBbW0V2ZW50RGlzcGF0Y2hlcl1dXHJcbiAgICAgKiBhbmQgZXh0ZW5kaW5nIGFiaWxpdGllcyBmb3IgdmFuaWxsYSBKYXZhc2NyaXB0IHByb2plY3RzXHJcbiAgICAgKi9cclxuICAgIHZhciBDbGFzcyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gQ2xhc3MoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyID0gbmV3IEV2ZW50RGlzcGF0Y2hlcl8zLkV2ZW50RGlzcGF0Y2hlcih0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWxpYXMgZm9yIGBhZGRFdmVudExpc3RlbmVyYC4gWW91IGNhbiBsaXN0ZW4gZm9yIGEgdmFyaWV0eSBvZlxyXG4gICAgICAgICAqIGV2ZW50cyBvZmYgb2YgdGhlIGVuZ2luZTsgc2VlIHRoZSBldmVudHMgc2VjdGlvbiBiZWxvdyBmb3IgYSBjb21wbGV0ZSBsaXN0LlxyXG4gICAgICAgICAqIEBwYXJhbSBldmVudE5hbWUgIE5hbWUgb2YgdGhlIGV2ZW50IHRvIGxpc3RlbiBmb3JcclxuICAgICAgICAgKiBAcGFyYW0gaGFuZGxlciAgICBFdmVudCBoYW5kbGVyIGZvciB0aGUgdGhyb3duIGV2ZW50XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2xhc3MucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5vbihldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWxpYXMgZm9yIGByZW1vdmVFdmVudExpc3RlbmVyYC4gSWYgb25seSB0aGUgZXZlbnROYW1lIGlzIHNwZWNpZmllZFxyXG4gICAgICAgICAqIGl0IHdpbGwgcmVtb3ZlIGFsbCBoYW5kbGVycyByZWdpc3RlcmVkIGZvciB0aGF0IHNwZWNpZmljIGV2ZW50LiBJZiB0aGUgZXZlbnROYW1lXHJcbiAgICAgICAgICogYW5kIHRoZSBoYW5kbGVyIGluc3RhbmNlIGFyZSBzcGVjaWZpZWQgb25seSB0aGF0IGhhbmRsZXIgd2lsbCBiZSByZW1vdmVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGV2ZW50TmFtZSAgTmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIGZvclxyXG4gICAgICAgICAqIEBwYXJhbSBoYW5kbGVyICAgIEV2ZW50IGhhbmRsZXIgZm9yIHRoZSB0aHJvd24gZXZlbnRcclxuICAgICAgICAgKi9cclxuICAgICAgICBDbGFzcy5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5vZmYoZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVtaXRzIGEgbmV3IGV2ZW50XHJcbiAgICAgICAgICogQHBhcmFtIGV2ZW50TmFtZSAgIE5hbWUgb2YgdGhlIGV2ZW50IHRvIGVtaXRcclxuICAgICAgICAgKiBAcGFyYW0gZXZlbnRPYmplY3QgRGF0YSBhc3NvY2lhdGVkIHdpdGggdGhpcyBldmVudFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENsYXNzLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgZXZlbnRPYmplY3QpIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIuZW1pdChldmVudE5hbWUsIGV2ZW50T2JqZWN0KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE9uY2UgbGlzdGVucyB0byBhbiBldmVudCBvbmUgdGltZSwgdGhlbiB1bnN1YnNjcmliZXMgZnJvbSB0aGF0IGV2ZW50XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gZXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBzdWJzY3JpYmUgdG8gb25jZVxyXG4gICAgICAgICAqIEBwYXJhbSBoYW5kbGVyICAgVGhlIGhhbmRsZXIgb2YgdGhlIGV2ZW50IHRoYXQgd2lsbCBiZSBhdXRvIHVuc3Vic2NyaWJlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENsYXNzLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5vbmNlKGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBZb3UgbWF5IHdpc2ggdG8gZXh0ZW5kIG5hdGl2ZSBFeGNhbGlidXIgZnVuY3Rpb25hbGl0eSBpbiB2YW5pbGxhIEphdmFzY3JpcHQuXHJcbiAgICAgICAgICogQW55IG1ldGhvZCBvbiBhIGNsYXNzIGluaGVyaXRpbmcgW1tDbGFzc11dIG1heSBiZSBleHRlbmRlZCB0byBzdXBwb3J0XHJcbiAgICAgICAgICogYWRkaXRpb25hbCBmdW5jdGlvbmFsaXR5LiBJbiB0aGUgZXhhbXBsZSBiZWxvdyB3ZSBjcmVhdGUgYSBuZXcgdHlwZSBjYWxsZWQgYE15QWN0b3JgLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBgYGBqc1xyXG4gICAgICAgICAqIHZhciBNeUFjdG9yID0gQWN0b3IuZXh0ZW5kKHtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgKiAgICAgICB0aGlzLm5ld3Byb3AgPSAnc29tZXRoaW5nJztcclxuICAgICAgICAgKiAgICAgICBBY3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAqICAgIH0sXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICB1cGRhdGU6IGZ1bmN0aW9uKGVuZ2luZSwgZGVsdGEpIHtcclxuICAgICAgICAgKiAgICAgICAvLyBJbXBsZW1lbnQgY3VzdG9tIHVwZGF0ZVxyXG4gICAgICAgICAqICAgICAgIC8vIENhbGwgc3VwZXIgY29uc3RydWN0b3IgdXBkYXRlXHJcbiAgICAgICAgICogICAgICAgQWN0b3IucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMsIGVuZ2luZSwgZGVsdGEpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgICAgY29uc29sZS5sb2coXCJTb21ldGhpbmcgY29vbCFcIik7XHJcbiAgICAgICAgICogICAgfVxyXG4gICAgICAgICAqIH0pO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogdmFyIG15QWN0b3IgPSBuZXcgTXlBY3RvcigxMDAsIDEwMCwgMTAwLCAxMDAsIENvbG9yLkF6dXJlKTtcclxuICAgICAgICAgKiBgYGBcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEluIFR5cGVTY3JpcHQsIHlvdSBvbmx5IG5lZWQgdG8gdXNlIHRoZSBgZXh0ZW5kc2Agc3ludGF4LCB5b3UgZG8gbm90IG5lZWRcclxuICAgICAgICAgKiB0byB1c2UgdGhpcyBtZXRob2Qgb2YgZXh0ZW5zaW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIG1ldGhvZHMgQSBKU09OIG9iamVjdCBjb250YWluIGFueSBtZXRob2RzL3Byb3BlcnRpZXMgeW91IHdhbnQgdG8gZXh0ZW5kXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2xhc3MuZXh0ZW5kID0gZnVuY3Rpb24gKG1ldGhvZHMpIHtcclxuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZDtcclxuICAgICAgICAgICAgaWYgKG1ldGhvZHMgJiYgbWV0aG9kcy5oYXNPd25Qcm9wZXJ0eSgnY29uc3RydWN0b3InKSkge1xyXG4gICAgICAgICAgICAgICAgY2hpbGQgPSBtZXRob2RzLmNvbnN0cnVjdG9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY2hpbGQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBwYXJlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBVc2luZyBjb25zdHJ1Y3RvciBhbGxvd3MgSlMgdG8gbGF6aWx5IGluc3RhbnRpYXRlIHN1cGVyIGNsYXNzZXNcclxuICAgICAgICAgICAgdmFyIFN1cGVyID0gZnVuY3Rpb24gKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH07XHJcbiAgICAgICAgICAgIFN1cGVyLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XHJcbiAgICAgICAgICAgIGNoaWxkLnByb3RvdHlwZSA9IG5ldyBTdXBlcjtcclxuICAgICAgICAgICAgaWYgKG1ldGhvZHMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gbWV0aG9kcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2RzLmhhc093blByb3BlcnR5KHByb3ApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLnByb3RvdHlwZVtwcm9wXSA9IG1ldGhvZHNbcHJvcF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE1ha2Ugc3ViY2xhc3NlcyBleHRlbmRhYmxlXHJcbiAgICAgICAgICAgIGNoaWxkLmV4dGVuZCA9IENsYXNzLmV4dGVuZDtcclxuICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIENsYXNzO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuQ2xhc3MgPSBDbGFzcztcclxufSk7XHJcbmRlZmluZShcIkFjdG9yXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiUGh5c2ljc1wiLCBcIkNsYXNzXCIsIFwiQ29sbGlzaW9uL0JvdW5kaW5nQm94XCIsIFwiUmVzb3VyY2VzL1RleHR1cmVcIiwgXCJFdmVudHNcIiwgXCJEcmF3aW5nL0NvbG9yXCIsIFwiRHJhd2luZy9TcHJpdGVcIiwgXCJVdGlsL0xvZ1wiLCBcIkFjdGlvbnMvQWN0aW9uQ29udGV4dFwiLCBcIkFjdGlvbnMvQWN0aW9uXCIsIFwiQWxnZWJyYVwiLCBcIkNvbGxpc2lvbi9Cb2R5XCIsIFwiQ29sbGlzaW9uL1NpZGVcIiwgXCJDb25maWd1cmFibGVcIiwgXCJUcmFpdHMvSW5kZXhcIiwgXCJEcmF3aW5nL1Nwcml0ZUVmZmVjdHNcIiwgXCJVdGlsL1V0aWxcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBQaHlzaWNzXzEzLCBDbGFzc18xMSwgQm91bmRpbmdCb3hfOCwgVGV4dHVyZV80LCBFdmVudHNfMTQsIENvbG9yXzIwLCBTcHJpdGVfNCwgTG9nXzE2LCBBY3Rpb25Db250ZXh0XzMsIEFjdGlvbl8yLCBBbGdlYnJhXzI0LCBCb2R5XzIsIFNpZGVfNCwgQ29uZmlndXJhYmxlXzgsIFRyYWl0cywgRWZmZWN0cywgVXRpbCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEBoaWRkZW5cclxuICAgICAqL1xyXG4gICAgdmFyIEFjdG9ySW1wbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKEFjdG9ySW1wbCwgX3N1cGVyKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0geCAgICAgICBUaGUgc3RhcnRpbmcgeCBjb29yZGluYXRlIG9mIHRoZSBhY3RvclxyXG4gICAgICAgICAqIEBwYXJhbSB5ICAgICAgIFRoZSBzdGFydGluZyB5IGNvb3JkaW5hdGUgb2YgdGhlIGFjdG9yXHJcbiAgICAgICAgICogQHBhcmFtIHdpZHRoICAgVGhlIHN0YXJ0aW5nIHdpZHRoIG9mIHRoZSBhY3RvclxyXG4gICAgICAgICAqIEBwYXJhbSBoZWlnaHQgIFRoZSBzdGFydGluZyBoZWlnaHQgb2YgdGhlIGFjdG9yXHJcbiAgICAgICAgICogQHBhcmFtIGNvbG9yICAgVGhlIHN0YXJ0aW5nIGNvbG9yIG9mIHRoZSBhY3Rvci4gTGVhdmUgbnVsbCB0byBkcmF3IGEgdHJhbnNwYXJlbnQgYWN0b3IuIFRoZSBvcGFjaXR5IG9mIHRoZSBjb2xvciB3aWxsIGJlIHVzZWQgYXMgdGhlXHJcbiAgICAgICAgICogaW5pdGlhbCBbW29wYWNpdHldXS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBBY3RvckltcGwoeE9yQ29uZmlnLCB5LCB3aWR0aCwgaGVpZ2h0LCBjb2xvcikge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgYWN0b3JcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmlkID0gQWN0b3JJbXBsLm1heElkKys7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgcGh5c2ljcyBib2R5IHRoZSBpcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBhY3Rvci4gVGhlIGJvZHkgaXMgdGhlIGNvbnRhaW5lciBmb3IgYWxsIHBoeXNpY2FsIHByb3BlcnRpZXMsIGxpa2UgcG9zaXRpb24sIHZlbG9jaXR5LFxyXG4gICAgICAgICAgICAgKiBhY2NlbGVyYXRpb24sIG1hc3MsIGluZXJ0aWEsIGV0Yy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmJvZHkgPSBuZXcgQm9keV8yLkJvZHkoX3RoaXMpO1xyXG4gICAgICAgICAgICBfdGhpcy5faGVpZ2h0ID0gMDtcclxuICAgICAgICAgICAgX3RoaXMuX3dpZHRoID0gMDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBzY2FsZSB2ZWN0b3Igb2YgdGhlIGFjdG9yXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5zY2FsZSA9IG5ldyBBbGdlYnJhXzI0LlZlY3RvcigxLCAxKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSB4IHNjYWxhciB2ZWxvY2l0eSBvZiB0aGUgYWN0b3IgaW4gc2NhbGUvc2Vjb25kXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5zeCA9IDA7IC8vc2NhbGUvc2VjXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgeSBzY2FsYXIgdmVsb2NpdHkgb2YgdGhlIGFjdG9yIGluIHNjYWxlL3NlY29uZFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuc3kgPSAwOyAvL3NjYWxlL3NlY1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGFjdG9yIGlzIHBoeXNpY2FsbHkgaW4gdGhlIHZpZXdwb3J0XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5pc09mZlNjcmVlbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIHZpc2liaWxpdHkgb2YgYW4gYWN0b3JcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIG9wYWNpdHkgb2YgYW4gYWN0b3IuIFBhc3NpbmcgaW4gYSBjb2xvciBpbiB0aGUgW1tjb25zdHJ1Y3Rvcl1dIHdpbGwgdXNlIHRoZVxyXG4gICAgICAgICAgICAgKiBjb2xvcidzIG9wYWNpdHkuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5vcGFjaXR5ID0gMTtcclxuICAgICAgICAgICAgX3RoaXMucHJldmlvdXNPcGFjaXR5ID0gMTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENvbnZlbmllbmNlIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIGxvZ2dlclxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMubG9nZ2VyID0gTG9nXzE2LkxvZ2dlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIHNjZW5lIHRoYXQgdGhlIGFjdG9yIGlzIGluXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5zY2VuZSA9IG51bGw7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgcGFyZW50IG9mIHRoaXMgYWN0b3JcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLnBhcmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IFJlcGxhY2UgdGhpcyB3aXRoIHRoZSBuZXcgYWN0b3IgY29sbGVjdGlvbiBvbmNlIHotaW5kZXhpbmcgaXMgYnVpbHRcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBjaGlsZHJlbiBvZiB0aGlzIGFjdG9yXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5jaGlsZHJlbiA9IFtdO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBjdXJyZW50IGNvbGxpc2lvbiB0eXBlIG9mIHRoaXMgYWN0b3IuIEJ5XHJcbiAgICAgICAgICAgICAqIGRlZmF1bHQgaXQgaXMgKFtbQ29sbGlzaW9uVHlwZS5QcmV2ZW50Q29sbGlzaW9uXV0pLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuY29sbGlzaW9uVHlwZSA9IENvbGxpc2lvblR5cGUuUHJldmVudENvbGxpc2lvbjtcclxuICAgICAgICAgICAgX3RoaXMuY29sbGlzaW9uR3JvdXBzID0gW107XHJcbiAgICAgICAgICAgIF90aGlzLl9jb2xsaXNpb25IYW5kbGVycyA9IHt9O1xyXG4gICAgICAgICAgICBfdGhpcy5faXNJbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBfdGhpcy5mcmFtZXMgPSB7fTtcclxuICAgICAgICAgICAgX3RoaXMuX2VmZmVjdHNEaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQWNjZXNzIHRvIHRoZSBjdXJyZW50IGRyYXdpbmcgZm9yIHRoZSBhY3RvciwgdGhpcyBjYW4gYmVcclxuICAgICAgICAgICAgICogYW4gW1tBbmltYXRpb25dXSwgW1tTcHJpdGVdXSwgb3IgW1tQb2x5Z29uXV0uXHJcbiAgICAgICAgICAgICAqIFNldCBkcmF3aW5ncyB3aXRoIFtbc2V0RHJhd2luZ11dLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuY3VycmVudERyYXdpbmcgPSBudWxsO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogTW9kaWZ5IHRoZSBjdXJyZW50IGFjdG9yIHVwZGF0ZSBwaXBlbGluZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLnRyYWl0cyA9IFtdO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdG8gZW5hYmxlIHRoZSBbW0NhcHR1cmVQb2ludGVyXV0gdHJhaXQgdGhhdCBwcm9wYWdhdGVzXHJcbiAgICAgICAgICAgICAqIHBvaW50ZXIgZXZlbnRzIHRvIHRoaXMgYWN0b3JcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmVuYWJsZUNhcHR1cmVQb2ludGVyID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDb25maWd1cmF0aW9uIGZvciBbW0NhcHR1cmVQb2ludGVyXV0gdHJhaXRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmNhcHR1cmVQb2ludGVyID0ge1xyXG4gICAgICAgICAgICAgICAgY2FwdHVyZU1vdmVFdmVudHM6IGZhbHNlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIF90aGlzLl96SW5kZXggPSAwO1xyXG4gICAgICAgICAgICBfdGhpcy5faXNLaWxsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgX3RoaXMuX29wYWNpdHlGeCA9IG5ldyBFZmZlY3RzLk9wYWNpdHkoX3RoaXMub3BhY2l0eSk7XHJcbiAgICAgICAgICAgIGlmICh4T3JDb25maWcgJiYgdHlwZW9mIHhPckNvbmZpZyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb25maWcgPSB4T3JDb25maWc7XHJcbiAgICAgICAgICAgICAgICB4T3JDb25maWcgPSBjb25maWcucG9zID8gY29uZmlnLnBvcy54IDogY29uZmlnLng7XHJcbiAgICAgICAgICAgICAgICB5ID0gY29uZmlnLnBvcyA/IGNvbmZpZy5wb3MueSA6IGNvbmZpZy55O1xyXG4gICAgICAgICAgICAgICAgd2lkdGggPSBjb25maWcud2lkdGg7XHJcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBjb25maWcuaGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzLnBvcy54ID0geE9yQ29uZmlnIHx8IDA7XHJcbiAgICAgICAgICAgIF90aGlzLnBvcy55ID0geSB8fCAwO1xyXG4gICAgICAgICAgICBfdGhpcy5fd2lkdGggPSB3aWR0aCB8fCAwO1xyXG4gICAgICAgICAgICBfdGhpcy5faGVpZ2h0ID0gaGVpZ2h0IHx8IDA7XHJcbiAgICAgICAgICAgIGlmIChjb2xvcikge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY29sb3IgPSBjb2xvcjtcclxuICAgICAgICAgICAgICAgIC8vIHNldCBkZWZhdWx0IG9wYWNpdHkgb2YgYW4gYWN0b3IgdG8gdGhlIGNvbG9yXHJcbiAgICAgICAgICAgICAgICBfdGhpcy5vcGFjaXR5ID0gY29sb3IuYTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBCdWlsZCBkZWZhdWx0IHBpcGVsaW5lXHJcbiAgICAgICAgICAgIC8vdGhpcy50cmFpdHMucHVzaChuZXcgZXguVHJhaXRzLkV1bGVyTW92ZW1lbnQoKSk7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IFRpbGVNYXBzIHNob3VsZCBiZSBjb252ZXJ0ZWQgdG8gYSBjb2xsaXNpb24gYXJlYVxyXG4gICAgICAgICAgICBfdGhpcy50cmFpdHMucHVzaChuZXcgVHJhaXRzLlRpbGVNYXBDb2xsaXNpb25EZXRlY3Rpb24oKSk7XHJcbiAgICAgICAgICAgIF90aGlzLnRyYWl0cy5wdXNoKG5ldyBUcmFpdHMuT2Zmc2NyZWVuQ3VsbGluZygpKTtcclxuICAgICAgICAgICAgX3RoaXMudHJhaXRzLnB1c2gobmV3IFRyYWl0cy5DYXB0dXJlUG9pbnRlcigpKTtcclxuICAgICAgICAgICAgLy8gQnVpbGQgdGhlIGFjdGlvbiBxdWV1ZVxyXG4gICAgICAgICAgICBfdGhpcy5hY3Rpb25RdWV1ZSA9IG5ldyBBY3Rpb25fMi5BY3Rpb25RdWV1ZShfdGhpcyk7XHJcbiAgICAgICAgICAgIF90aGlzLmFjdGlvbnMgPSBuZXcgQWN0aW9uQ29udGV4dF8zLkFjdGlvbkNvbnRleHQoX3RoaXMpO1xyXG4gICAgICAgICAgICAvLyBkZWZhdWx0IGFuY2hvciBpcyBpbiB0aGUgbWlkZGxlXHJcbiAgICAgICAgICAgIF90aGlzLmFuY2hvciA9IG5ldyBBbGdlYnJhXzI0LlZlY3RvciguNSwgLjUpO1xyXG4gICAgICAgICAgICAvLyBJbml0aWFsaXplIGRlZmF1bHQgY29sbGlzaW9uIGFyZWEgdG8gYmUgYm94XHJcbiAgICAgICAgICAgIF90aGlzLmJvZHkudXNlQm94Q29sbGlzaW9uKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdG9ySW1wbC5wcm90b3R5cGUsIFwiY29sbGlzaW9uQXJlYVwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBjb2xsaXNpb24gYXJlYSBzaGFwZSB0byB1c2UgZm9yIGNvbGxpc2lvbiBwb3NzaWJsZSBvcHRpb25zIGFyZSBbQ2lyY2xlQXJlYXxjaXJjbGVzXSwgW1BvbHlnb25BcmVhfHBvbHlnb25zXSwgYW5kXHJcbiAgICAgICAgICAgICAqIFtFZGdlQXJlYXxlZGdlc10uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJvZHkuY29sbGlzaW9uQXJlYTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIGNvbGxpc2lvbiBhcmVhIHNoYXBlIHRvIHVzZSBmb3IgY29sbGlzaW9uIHBvc3NpYmxlIG9wdGlvbnMgYXJlIFtDaXJjbGVBcmVhfGNpcmNsZXNdLCBbUG9seWdvbkFyZWF8cG9seWdvbnNdLCBhbmRcclxuICAgICAgICAgICAgICogW0VkZ2VBcmVhfGVkZ2VzXS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGFyZWEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYm9keS5jb2xsaXNpb25BcmVhID0gYXJlYTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdG9ySW1wbC5wcm90b3R5cGUsIFwieFwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSB4IHBvc2l0aW9uIG9mIHRoZSBhY3RvciByZWxhdGl2ZSB0byBpdCdzIHBhcmVudCAoaWYgYW55KVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5LnBvcy54O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0cyB0aGUgeCBwb3NpdGlvbiBvZiB0aGUgYWN0b3IgcmVsYXRpdmUgdG8gaXQncyBwYXJlbnQgKGlmIGFueSlcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHRoZVgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYm9keS5wb3MueCA9IHRoZVg7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3RvckltcGwucHJvdG90eXBlLCBcInlcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgeSBwb3NpdGlvbiBvZiB0aGUgYWN0b3IgcmVsYXRpdmUgdG8gaXQncyBwYXJlbnQgKGlmIGFueSlcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5wb3MueTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHMgdGhlIHkgcG9zaXRpb24gb2YgdGhlIGFjdG9yIHJlbGF0aXZlIHRvIGl0J3MgcGFyZW50IChpZiBhbnkpXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0aGVZKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvZHkucG9zLnkgPSB0aGVZO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0b3JJbXBsLnByb3RvdHlwZSwgXCJwb3NcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgcG9zaXRpb24gdmVjdG9yIG9mIHRoZSBhY3RvciBpbiBwaXhlbHNcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5wb3M7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXRzIHRoZSBwb3NpdGlvbiB2ZWN0b3Igb2YgdGhlIGFjdG9yIGluIHBpeGVsc1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodGhlUG9zKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvZHkucG9zLnNldFRvKHRoZVBvcy54LCB0aGVQb3MueSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3RvckltcGwucHJvdG90eXBlLCBcIm9sZFBvc1wiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBwb3NpdGlvbiB2ZWN0b3Igb2YgdGhlIGFjdG9yIGZyb20gdGhlIGxhc3QgZnJhbWVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5vbGRQb3M7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXRzIHRoZSBwb3NpdGlvbiB2ZWN0b3Igb2YgdGhlIGFjdG9yIGluIHRoZSBsYXN0IGZyYW1lXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0aGVQb3MpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYm9keS5vbGRQb3Muc2V0VG8odGhlUG9zLngsIHRoZVBvcy55KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdG9ySW1wbC5wcm90b3R5cGUsIFwidmVsXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIHZlbG9jaXR5IHZlY3RvciBvZiB0aGUgYWN0b3IgaW4gcGl4ZWxzL3NlY1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5LnZlbDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHMgdGhlIHZlbG9jaXR5IHZlY3RvciBvZiB0aGUgYWN0b3IgaW4gcGl4ZWxzL3NlY1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodGhlVmVsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvZHkudmVsLnNldFRvKHRoZVZlbC54LCB0aGVWZWwueSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3RvckltcGwucHJvdG90eXBlLCBcIm9sZFZlbFwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSB2ZWxvY2l0eSB2ZWN0b3Igb2YgdGhlIGFjdG9yIGZyb20gdGhlIGxhc3QgZnJhbWVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5vbGRWZWw7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXRzIHRoZSB2ZWxvY2l0eSB2ZWN0b3Igb2YgdGhlIGFjdG9yIGZyb20gdGhlIGxhc3QgZnJhbWVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHRoZVZlbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5Lm9sZFZlbC5zZXRUbyh0aGVWZWwueCwgdGhlVmVsLnkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0b3JJbXBsLnByb3RvdHlwZSwgXCJhY2NcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgYWNjZWxlcmF0aW9uIHZlY3RvciBvZiB0aGUgYWN0b3IgaW4gcGl4ZWxzL3NlY29uZC9zZWNvbmQuIEFuIGFjY2VsZXJhdGlvbiBwb2ludGluZyBkb3duIHN1Y2ggYXMgKDAsIDEwMCkgbWF5IGJlXHJcbiAgICAgICAgICAgICAqIHVzZWZ1bCB0byBzaW11bGF0ZSBhIGdyYXZpdGF0aW9uYWwgZWZmZWN0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5LmFjYztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHMgdGhlIGFjY2VsZXJhdGlvbiB2ZWN0b3Igb2YgdGVoIGFjdG9yIGluIHBpeGVscy9zZWNvbmQvc2Vjb25kXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0aGVBY2MpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYm9keS5hY2Muc2V0VG8odGhlQWNjLngsIHRoZUFjYy55KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdG9ySW1wbC5wcm90b3R5cGUsIFwicm90YXRpb25cIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgcm90YXRpb24gb2YgdGhlIGFjdG9yIGluIHJhZGlhbnMuIDEgcmFkaWFuID0gMTgwL1BJIERlZ3JlZXMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJvZHkucm90YXRpb247XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXRzIHRoZSByb3RhdGlvbiBvZiB0aGUgYWN0b3IgaW4gcmFkaWFucy4gMSByYWRpYW4gPSAxODAvUEkgRGVncmVlcy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHRoZUFuZ2xlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvZHkucm90YXRpb24gPSB0aGVBbmdsZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdG9ySW1wbC5wcm90b3R5cGUsIFwicnhcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgcm90YXRpb25hbCB2ZWxvY2l0eSBvZiB0aGUgYWN0b3IgaW4gcmFkaWFucy9zZWNvbmRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5yeDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHMgdGhlIHJvdGF0aW9uYWwgdmVsb2NpdHkgb2YgdGhlIGFjdG9yIGluIHJhZGlhbnMvc2VjXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChhbmd1bGFyVmVsb2NpdHkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYm9keS5yeCA9IGFuZ3VsYXJWZWxvY2l0eTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdG9ySW1wbC5wcm90b3R5cGUsIFwidG9ycXVlXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIGN1cnJlbnQgdG9ycXVlIGFwcGxpZWQgdG8gdGhlIGFjdG9yLiBUb3JxdWUgY2FuIGJlIHRob3VnaHQgb2YgYXMgcm90YXRpb25hbCBmb3JjZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5LnRvcnF1ZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHMgdGhlIGN1cnJlbnQgdG9ycXVlIGFwcGxpZWQgdG8gdGhlIGFjdG9yLiBUb3JxdWUgY2FuIGJlIHRob3VnaHQgb2YgYXMgcm90YXRpb25hbCBmb3JjZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodGhlVG9ycXVlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvZHkudG9ycXVlID0gdGhlVG9ycXVlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0b3JJbXBsLnByb3RvdHlwZSwgXCJtYXNzXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldCB0aGUgY3VycmVudCBtYXNzIG9mIHRoZSBhY3RvciwgbWFzcyBjYW4gYmUgdGhvdWdodCBvZiBhcyB0aGUgcmVzaXN0YW5jZSB0byBhY2NlbGVyYXRpb24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJvZHkubWFzcztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHMgdGhlIG1hc3Mgb2YgdGhlIGFjdG9yLCBtYXNzIGNhbiBiZSB0aG91Z2h0IG9mIGFzIHRoZSByZXNpc3RhbmNlIHRvIGFjY2VsZXJhdGlvbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHRoZU1hc3MpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYm9keS5tYXNzID0gdGhlTWFzcztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdG9ySW1wbC5wcm90b3R5cGUsIFwibW9pXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIGN1cnJlbnQgbW9tZW50IG9mIGluZXJ0aWEsIG1vaSBjYW4gYmUgdGhvdWdodCBvZiBhcyB0aGUgcmVzaXN0YW5jZSB0byByb3RhdGlvbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5tb2k7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXRzIHRoZSBjdXJyZW50IG1vbWVudCBvZiBpbmVydGlhLCBtb2kgY2FuIGJlIHRob3VnaHQgb2YgYXMgdGhlIHJlc2lzdGFuY2UgdG8gcm90YXRpb24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0aGVNb2kpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYm9keS5tb2kgPSB0aGVNb2k7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3RvckltcGwucHJvdG90eXBlLCBcImZyaWN0aW9uXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIGNvZWZmaWNpZW50IG9mIGZyaWN0aW9uIG9uIHRoaXMgYWN0b3IsIHRoaXMgY2FuIGJlIHRob3VnaHQgb2YgYXMgaG93IHN0aWNreSBvciBzbGlwcGVyeSBhbiBvYmplY3QgaXMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJvZHkuZnJpY3Rpb247XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXRzIHRoZSBjb2VmZmljaWVudCBvZiBmcmljdGlvbiBvZiB0aGlzIGFjdG9yLCB0aGlzIGNhbiB2ZSB0aG91Z2h0IG9mIGFzIGhvdyBzdGljayBvciBzbGlwcGVyeSBhbiBvYmplY3QgaXMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0aGVGcmljdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5LmZyaWN0aW9uID0gdGhlRnJpY3Rpb247XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3RvckltcGwucHJvdG90eXBlLCBcInJlc3RpdHV0aW9uXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIGNvZWZmaWNpZW50IG9mIHJlc3RpdHV0aW9uIG9mIHRoaXMgYWN0b3IsIHJlcHJlc2VudHMgdGhlIGFtb3VudCBvZiBlbmVyZ3kgcHJlc2VydmVkIGFmdGVyIGNvbGxpc2lvbi4gVGhpbmsgb2YgdGhpc1xyXG4gICAgICAgICAgICAgKiBhcyBib3VuY2luZXNzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5LnJlc3RpdHV0aW9uO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0cyB0aGUgY29lZmZpY2llbnQgb2YgcmVzdGl0dXRpb24gb2YgdGhpcyBhY3RvciwgcmVwcmVzZW50cyB0aGUgYW1vdW50IG9mIGVuZXJneSBwcmVzZXJ2ZWQgYWZ0ZXIgY29sbGlzaW9uLiBUaGluayBvZiB0aGlzXHJcbiAgICAgICAgICAgICAqIGFzIGJvdW5jaW5lc3MuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0aGVSZXN0aXR1dGlvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5LnJlc3RpdHV0aW9uID0gdGhlUmVzdGl0dXRpb247XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3RvckltcGwucHJvdG90eXBlLCBcImNvbG9yXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHMgdGhlIGNvbG9yIG9mIHRoZSBhY3Rvci4gQSByZWN0YW5nbGUgb2YgdGhpcyBjb2xvciB3aWxsIGJlXHJcbiAgICAgICAgICAgICAqIGRyYXduIGlmIG5vIFtbSURyYXdhYmxlXV0gaXMgc3BlY2lmaWVkIGFzIHRoZSBhY3RvcnMgZHJhd2luZy5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogVGhlIGRlZmF1bHQgaXMgYG51bGxgIHdoaWNoIHByZXZlbnRzIGEgcmVjdGFuZ2xlIGZyb20gYmVpbmcgZHJhd24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2xvcjtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY29sb3IgPSB2LmNsb25lKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgaXMgY2FsbGVkIGJlZm9yZSB0aGUgZmlyc3QgdXBkYXRlIG9mIHRoZSBhY3Rvci4gVGhpcyBtZXRob2QgaXMgbWVhbnQgdG8gYmVcclxuICAgICAgICAgKiBvdmVycmlkZGVuLiBUaGlzIGlzIHdoZXJlIGluaXRpYWxpemF0aW9uIG9mIGNoaWxkIGFjdG9ycyBzaG91bGQgdGFrZSBwbGFjZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLm9uSW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChfZW5naW5lKSB7XHJcbiAgICAgICAgICAgIC8vIE92ZXJyaWRlIG1lXHJcbiAgICAgICAgfTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0b3JJbXBsLnByb3RvdHlwZSwgXCJpc0luaXRpYWxpemVkXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgd2V0aGVyIHRoZSBhY3RvciBpcyBJbml0aWFsaXplZFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faXNJbml0aWFsaXplZDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgdGhpcyBhY3RvciBhbmQgYWxsIGl0J3MgY2hpbGQgYWN0b3JzLCBtZWFudCB0byBiZSBjYWxsZWQgYnkgdGhlIFNjZW5lIGJlZm9yZSBmaXJzdCB1cGRhdGUgbm90IGJ5IHVzZXJzIG9mIEV4Y2FsaWJ1ci5cclxuICAgICAgICAgKiBAaW50ZXJuYWxcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLl9pbml0aWFsaXplID0gZnVuY3Rpb24gKGVuZ2luZSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkluaXRpYWxpemUoZW5naW5lKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ2luaXRpYWxpemUnLCBuZXcgRXZlbnRzXzE0LkluaXRpYWxpemVFdmVudChlbmdpbmUsIHRoaXMpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmNoaWxkcmVuOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgY2hpbGQuX2luaXRpYWxpemUoZW5naW5lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS5fY2hlY2tGb3JQb2ludGVyT3B0SW4gPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XHJcbiAgICAgICAgICAgIGlmIChldmVudE5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBub3JtYWxpemVkID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZCA9PT0gJ3BvaW50ZXJ1cCcgfHwgbm9ybWFsaXplZCA9PT0gJ3BvaW50ZXJkb3duJyB8fCBub3JtYWxpemVkID09PSAncG9pbnRlcm1vdmUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmFibGVDYXB0dXJlUG9pbnRlciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWQgPT09ICdwb2ludGVybW92ZScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYXB0dXJlUG9pbnRlci5jYXB0dXJlTW92ZUV2ZW50cyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgICAgICB0aGlzLl9jaGVja0ZvclBvaW50ZXJPcHRJbihldmVudE5hbWUpO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5vbihldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgICAgICB0aGlzLl9jaGVja0ZvclBvaW50ZXJPcHRJbihldmVudE5hbWUpO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5vbmNlKGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiB0aGUgY3VycmVudCBhY3RvciBpcyBhIG1lbWJlciBvZiB0aGUgc2NlbmUsIHRoaXMgd2lsbCByZW1vdmVcclxuICAgICAgICAgKiBpdCBmcm9tIHRoZSBzY2VuZSBncmFwaC4gSXQgd2lsbCBubyBsb25nZXIgYmUgZHJhd24gb3IgdXBkYXRlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLmtpbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNjZW5lKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2tpbGwnLCBuZXcgRXZlbnRzXzE0LktpbGxFdmVudCh0aGlzKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLnJlbW92ZSh0aGlzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2lzS2lsbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ0Nhbm5vdCBraWxsIGFjdG9yLCBpdCB3YXMgbmV2ZXIgYWRkZWQgdG8gdGhlIFNjZW5lJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIHRoZSBjdXJyZW50IGFjdG9yIGlzIGtpbGxlZCwgaXQgd2lsbCBub3cgbm90IGJlIGtpbGxlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLnVua2lsbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5faXNLaWxsZWQgPSBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluZGljYXRlcyB3ZXRoZXIgdGhlIGFjdG9yIGhhcyBiZWVuIGtpbGxlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLmlzS2lsbGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNLaWxsZWQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgY2hpbGQgYWN0b3IgdG8gdGhpcyBhY3Rvci4gQWxsIG1vdmVtZW50IG9mIHRoZSBjaGlsZCBhY3RvciB3aWxsIGJlXHJcbiAgICAgICAgICogcmVsYXRpdmUgdG8gdGhlIHBhcmVudCBhY3Rvci4gTWVhbmluZyBpZiB0aGUgcGFyZW50IG1vdmVzIHRoZSBjaGlsZCB3aWxsXHJcbiAgICAgICAgICogbW92ZSB3aXRoIGl0LlxyXG4gICAgICAgICAqIEBwYXJhbSBhY3RvciBUaGUgY2hpbGQgYWN0b3IgdG8gYWRkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoYWN0b3IpIHtcclxuICAgICAgICAgICAgYWN0b3IuY29sbGlzaW9uVHlwZSA9IENvbGxpc2lvblR5cGUuUHJldmVudENvbGxpc2lvbjtcclxuICAgICAgICAgICAgaWYgKFV0aWwuYWRkSXRlbVRvQXJyYXkoYWN0b3IsIHRoaXMuY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgICAgICBhY3Rvci5wYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGEgY2hpbGQgYWN0b3IgZnJvbSB0aGlzIGFjdG9yLlxyXG4gICAgICAgICAqIEBwYXJhbSBhY3RvciBUaGUgY2hpbGQgYWN0b3IgdG8gcmVtb3ZlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoYWN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKFV0aWwucmVtb3ZlSXRlbUZyb21BcnJheShhY3RvciwgdGhpcy5jaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgICAgIGFjdG9yLnBhcmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUuc2V0RHJhd2luZyA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAga2V5ID0ga2V5LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnREcmF3aW5nICE9PSB0aGlzLmZyYW1lc1trZXldKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mcmFtZXNba2V5XSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmFtZXNba2V5XS5yZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudERyYXdpbmcgPSB0aGlzLmZyYW1lc1trZXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgTG9nXzE2LkxvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKCd0aGUgc3BlY2lmaWVkIGRyYXdpbmcga2V5IFxcJycgKyBrZXkgKyAnXFwnIGRvZXMgbm90IGV4aXN0Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUuYWRkRHJhd2luZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzW2FyZ3VtZW50c1swXV0gPSBhcmd1bWVudHNbMV07XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY3VycmVudERyYXdpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnREcmF3aW5nID0gYXJndW1lbnRzWzFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fZWZmZWN0c0RpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBTcHJpdGVfNC5TcHJpdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZERyYXdpbmcoJ2RlZmF1bHQnLCBhcmd1bWVudHNbMF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIFRleHR1cmVfNC5UZXh0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGREcmF3aW5nKCdkZWZhdWx0JywgYXJndW1lbnRzWzBdLmFzU3ByaXRlKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0b3JJbXBsLnByb3RvdHlwZSwgXCJ6XCIsIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRaSW5kZXgoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3Wikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRaSW5kZXgobmV3Wik7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIHotaW5kZXggb2YgYW4gYWN0b3IuIFRoZSB6LWluZGV4IGRldGVybWluZXMgdGhlIHJlbGF0aXZlIG9yZGVyIGFuIGFjdG9yIGlzIGRyYXduIGluLlxyXG4gICAgICAgICAqIEFjdG9ycyB3aXRoIGEgaGlnaGVyIHotaW5kZXggYXJlIGRyYXduIG9uIHRvcCBvZiBhY3RvcnMgd2l0aCBhIGxvd2VyIHotaW5kZXhcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLmdldFpJbmRleCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3pJbmRleDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIHotaW5kZXggb2YgYW4gYWN0b3IgYW5kIHVwZGF0ZXMgaXQgaW4gdGhlIGRyYXdpbmcgbGlzdCBmb3IgdGhlIHNjZW5lLlxyXG4gICAgICAgICAqIFRoZSB6LWluZGV4IGRldGVybWluZXMgdGhlIHJlbGF0aXZlIG9yZGVyIGFuIGFjdG9yIGlzIGRyYXduIGluLlxyXG4gICAgICAgICAqIEFjdG9ycyB3aXRoIGEgaGlnaGVyIHotaW5kZXggYXJlIGRyYXduIG9uIHRvcCBvZiBhY3RvcnMgd2l0aCBhIGxvd2VyIHotaW5kZXhcclxuICAgICAgICAgKiBAcGFyYW0gbmV3SW5kZXggbmV3IHotaW5kZXggdG8gYXNzaWduXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS5zZXRaSW5kZXggPSBmdW5jdGlvbiAobmV3SW5kZXgpIHtcclxuICAgICAgICAgICAgdGhpcy5zY2VuZS5jbGVhbnVwRHJhd1RyZWUodGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuX3pJbmRleCA9IG5ld0luZGV4O1xyXG4gICAgICAgICAgICB0aGlzLnNjZW5lLnVwZGF0ZURyYXdUcmVlKHRoaXMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhbiBhY3RvciB0byBhIGNvbGxpc2lvbiBncm91cC4gQWN0b3JzIHdpdGggbm8gbmFtZWQgY29sbGlzaW9uIGdyb3VwcyBhcmVcclxuICAgICAgICAgKiBjb25zaWRlcmVkIHRvIGJlIGluIGV2ZXJ5IGNvbGxpc2lvbiBncm91cC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIE9uY2UgaW4gYSBjb2xsaXNpb24gZ3JvdXAocykgYWN0b3JzIHdpbGwgb25seSBjb2xsaWRlIHdpdGggb3RoZXIgYWN0b3JzIGluXHJcbiAgICAgICAgICogdGhhdCBncm91cC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBjb2xsaXNpb24gZ3JvdXBcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLmFkZENvbGxpc2lvbkdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25Hcm91cHMucHVzaChuYW1lKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgYW4gYWN0b3IgZnJvbSBhIGNvbGxpc2lvbiBncm91cC5cclxuICAgICAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgY29sbGlzaW9uIGdyb3VwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS5yZW1vdmVDb2xsaXNpb25Hcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuY29sbGlzaW9uR3JvdXBzLmluZGV4T2YobmFtZSk7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uR3JvdXBzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCB0aGUgY2VudGVyIHBvaW50IG9mIGFuIGFjdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS5nZXRDZW50ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWxnZWJyYV8yNC5WZWN0b3IodGhpcy5wb3MueCArIHRoaXMuZ2V0V2lkdGgoKSAvIDIgLSB0aGlzLmFuY2hvci54ICogdGhpcy5nZXRXaWR0aCgpLCB0aGlzLnBvcy55ICsgdGhpcy5nZXRIZWlnaHQoKSAvIDIgLSB0aGlzLmFuY2hvci55ICogdGhpcy5nZXRIZWlnaHQoKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBjYWxjdWxhdGVkIHdpZHRoIG9mIGFuIGFjdG9yLCBmYWN0b3JpbmcgaW4gc2NhbGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGggKiB0aGlzLmdldEdsb2JhbFNjYWxlKCkueDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIHdpZHRoIG9mIGFuIGFjdG9yLCBmYWN0b3JpbmcgaW4gdGhlIGN1cnJlbnQgc2NhbGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLnNldFdpZHRoID0gZnVuY3Rpb24gKHdpZHRoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGggLyB0aGlzLnNjYWxlLng7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBjYWxjdWxhdGVkIGhlaWdodCBvZiBhbiBhY3RvciwgZmFjdG9yaW5nIGluIHNjYWxlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQgKiB0aGlzLmdldEdsb2JhbFNjYWxlKCkueTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIGhlaWdodCBvZiBhbiBhY3RvciwgZmFjdG9yaW5nIGluIHRoZSBjdXJyZW50IHNjYWxlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS5zZXRIZWlnaHQgPSBmdW5jdGlvbiAoaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodCAvIHRoaXMuc2NhbGUueTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGxlZnQgZWRnZSBvZiB0aGUgYWN0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLmdldExlZnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEJvdW5kcygpLmxlZnQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSByaWdodCBlZGdlIG9mIHRoZSBhY3RvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUuZ2V0UmlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEJvdW5kcygpLnJpZ2h0O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgdG9wIGVkZ2Ugb2YgdGhlIGFjdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS5nZXRUb3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEJvdW5kcygpLnRvcDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGJvdHRvbSBlZGdlIG9mIHRoZSBhY3RvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUuZ2V0Qm90dG9tID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRCb3VuZHMoKS5ib3R0b207XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoaXMgYWN0b3IncyByb3RhdGlvbiB0YWtpbmcgaW50byBhY2NvdW50IGFueSBwYXJlbnQgcmVsYXRpb25zaGlwc1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMgUm90YXRpb24gYW5nbGUgaW4gcmFkaWFuc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUuZ2V0V29ybGRSb3RhdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucm90YXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm90YXRpb24gKyB0aGlzLnBhcmVudC5nZXRXb3JsZFJvdGF0aW9uKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIGFuIGFjdG9yJ3Mgd29ybGQgcG9zaXRpb24gdGFraW5nIGludG8gYWNjb3VudCBwYXJlbnQgcmVsYXRpb25zaGlwcywgc2NhbGluZywgcm90YXRpb24sIGFuZCB0cmFuc2xhdGlvblxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMgUG9zaXRpb24gaW4gd29ybGQgY29vcmRpbmF0ZXNcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLmdldFdvcmxkUG9zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wb3MuY2xvbmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjb2xsZWN0IHBhcmVudHMgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIHBhcmVudHMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIHJvb3QgPSB0aGlzO1xyXG4gICAgICAgICAgICBwYXJlbnRzLnB1c2godGhpcyk7XHJcbiAgICAgICAgICAgIC8vIGZpbmQgcGFyZW50c1xyXG4gICAgICAgICAgICB3aGlsZSAocm9vdC5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJvb3QgPSByb290LnBhcmVudDtcclxuICAgICAgICAgICAgICAgIHBhcmVudHMucHVzaChyb290KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgcG9zaXRpb24gICAgICAgXHJcbiAgICAgICAgICAgIHZhciB4ID0gcGFyZW50cy5yZWR1Y2VSaWdodChmdW5jdGlvbiAocHgsIHApIHtcclxuICAgICAgICAgICAgICAgIGlmIChwLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBweCArIChwLnBvcy54ICogcC5nZXRHbG9iYWxTY2FsZSgpLngpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHB4ICsgcC5wb3MueDtcclxuICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgICAgIHZhciB5ID0gcGFyZW50cy5yZWR1Y2VSaWdodChmdW5jdGlvbiAocHksIHApIHtcclxuICAgICAgICAgICAgICAgIGlmIChwLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBweSArIChwLnBvcy55ICogcC5nZXRHbG9iYWxTY2FsZSgpLnkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHB5ICsgcC5wb3MueTtcclxuICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgICAgIC8vIHJvdGF0ZSBhcm91bmQgcm9vdCBhbmNob3JcclxuICAgICAgICAgICAgdmFyIHJhID0gcm9vdC5nZXRXb3JsZFBvcygpOyAvLyAxMCwgMTBcclxuICAgICAgICAgICAgdmFyIHIgPSB0aGlzLmdldFdvcmxkUm90YXRpb24oKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbGdlYnJhXzI0LlZlY3Rvcih4LCB5KS5yb3RhdGUociwgcmEpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgZ2xvYmFsIHNjYWxlIG9mIHRoZSBBY3RvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUuZ2V0R2xvYmFsU2NhbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWxnZWJyYV8yNC5WZWN0b3IodGhpcy5zY2FsZS54LCB0aGlzLnNjYWxlLnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnRTY2FsZSA9IHRoaXMucGFyZW50LmdldEdsb2JhbFNjYWxlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWxnZWJyYV8yNC5WZWN0b3IodGhpcy5zY2FsZS54ICogcGFyZW50U2NhbGUueCwgdGhpcy5zY2FsZS55ICogcGFyZW50U2NhbGUueSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBhY3RvcidzIFtbQm91bmRpbmdCb3hdXSBjYWxjdWxhdGVkIGZvciB0aGlzIGluc3RhbnQgaW4gd29ybGQgc3BhY2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIHRvZG8gY2FjaGUgYm91bmRpbmcgYm94XHJcbiAgICAgICAgICAgIHZhciBhbmNob3IgPSB0aGlzLl9nZXRDYWxjdWxhdGVkQW5jaG9yKCk7XHJcbiAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLmdldFdvcmxkUG9zKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3hfOC5Cb3VuZGluZ0JveChwb3MueCAtIGFuY2hvci54LCBwb3MueSAtIGFuY2hvci55LCBwb3MueCArIHRoaXMuZ2V0V2lkdGgoKSAtIGFuY2hvci54LCBwb3MueSArIHRoaXMuZ2V0SGVpZ2h0KCkgLSBhbmNob3IueSkucm90YXRlKHRoaXMucm90YXRpb24sIHBvcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBhY3RvcidzIFtbQm91bmRpbmdCb3hdXSByZWxhdGl2ZSB0byB0aGUgYWN0b3JzIHBvc2l0aW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUuZ2V0UmVsYXRpdmVCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIHRvZG8gY2FjaGUgYm91bmRpbmcgYm94XHJcbiAgICAgICAgICAgIHZhciBhbmNob3IgPSB0aGlzLl9nZXRDYWxjdWxhdGVkQW5jaG9yKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3hfOC5Cb3VuZGluZ0JveCgtYW5jaG9yLngsIC1hbmNob3IueSwgdGhpcy5nZXRXaWR0aCgpIC0gYW5jaG9yLngsIHRoaXMuZ2V0SGVpZ2h0KCkgLSBhbmNob3IueSkucm90YXRlKHRoaXMucm90YXRpb24pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVzdHMgd2hldGhlciB0aGUgeC95IHNwZWNpZmllZCBhcmUgY29udGFpbmVkIGluIHRoZSBhY3RvclxyXG4gICAgICAgICAqIEBwYXJhbSB4ICBYIGNvb3JkaW5hdGUgdG8gdGVzdCAoaW4gd29ybGQgY29vcmRpbmF0ZXMpXHJcbiAgICAgICAgICogQHBhcmFtIHkgIFkgY29vcmRpbmF0ZSB0byB0ZXN0IChpbiB3b3JsZCBjb29yZGluYXRlcylcclxuICAgICAgICAgKiBAcGFyYW0gcmVjdXJzZSBjaGVja3Mgd2hldGhlciB0aGUgeC95IGFyZSBjb250YWluZWQgaW4gYW55IGNoaWxkIGFjdG9ycyAoaWYgdGhleSBleGlzdCkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uICh4LCB5LCByZWN1cnNlKSB7XHJcbiAgICAgICAgICAgIGlmIChyZWN1cnNlID09PSB2b2lkIDApIHsgcmVjdXJzZSA9IGZhbHNlOyB9XHJcbiAgICAgICAgICAgIHZhciBjb250YWlubWVudCA9IHRoaXMuZ2V0Qm91bmRzKCkuY29udGFpbnMobmV3IEFsZ2VicmFfMjQuVmVjdG9yKHgsIHkpKTtcclxuICAgICAgICAgICAgaWYgKHJlY3Vyc2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb250YWlubWVudCB8fCB0aGlzLmNoaWxkcmVuLnNvbWUoZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmNvbnRhaW5zKHgsIHksIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5tZW50O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgc2lkZSBvZiB0aGUgY29sbGlzaW9uIGJhc2VkIG9uIHRoZSBpbnRlcnNlY3Rpb25cclxuICAgICAgICAgKiBAcGFyYW0gaW50ZXJzZWN0IFRoZSBkaXNwbGFjZW1lbnQgdmVjdG9yIHJldHVybmVkIGJ5IGEgY29sbGlzaW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS5nZXRTaWRlRnJvbUludGVyc2VjdCA9IGZ1bmN0aW9uIChpbnRlcnNlY3QpIHtcclxuICAgICAgICAgICAgaWYgKGludGVyc2VjdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGludGVyc2VjdC54KSA+IE1hdGguYWJzKGludGVyc2VjdC55KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnRlcnNlY3QueCA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNpZGVfNC5TaWRlLlJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU2lkZV80LlNpZGUuTGVmdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnRlcnNlY3QueSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNpZGVfNC5TaWRlLkJvdHRvbTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNpZGVfNC5TaWRlLlRvcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gU2lkZV80LlNpZGUuTm9uZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRlc3Qgd2hldGhlciB0aGUgYWN0b3IgaGFzIGNvbGxpZGVkIHdpdGggYW5vdGhlciBhY3RvciwgcmV0dXJucyB0aGUgc2lkZSBvZiB0aGUgY3VycmVudCBhY3RvciB0aGF0IGNvbGxpZGVkLlxyXG4gICAgICAgICAqIEBwYXJhbSBhY3RvciBUaGUgb3RoZXIgYWN0b3IgdG8gdGVzdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUuY29sbGlkZXNXaXRoU2lkZSA9IGZ1bmN0aW9uIChhY3Rvcikge1xyXG4gICAgICAgICAgICB2YXIgc2VwYXJhdGlvblZlY3RvciA9IHRoaXMuY29sbGlkZXMoYWN0b3IpO1xyXG4gICAgICAgICAgICBpZiAoIXNlcGFyYXRpb25WZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBTaWRlXzQuU2lkZS5Ob25lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhzZXBhcmF0aW9uVmVjdG9yLngpID4gTWF0aC5hYnMoc2VwYXJhdGlvblZlY3Rvci55KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucG9zLnggPCBhY3Rvci5wb3MueCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTaWRlXzQuU2lkZS5SaWdodDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTaWRlXzQuU2lkZS5MZWZ0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucG9zLnkgPCBhY3Rvci5wb3MueSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTaWRlXzQuU2lkZS5Cb3R0b207XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU2lkZV80LlNpZGUuVG9wO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZXN0IHdoZXRoZXIgdGhlIGFjdG9yIGhhcyBjb2xsaWRlZCB3aXRoIGFub3RoZXIgYWN0b3IsIHJldHVybnMgdGhlIGludGVyc2VjdGlvbiB2ZWN0b3Igb24gY29sbGlzaW9uLiBSZXR1cm5zXHJcbiAgICAgICAgICogYG51bGxgIHdoZW4gdGhlcmUgaXMgbm8gY29sbGlzaW9uO1xyXG4gICAgICAgICAqIEBwYXJhbSBhY3RvciBUaGUgb3RoZXIgYWN0b3IgdG8gdGVzdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUuY29sbGlkZXMgPSBmdW5jdGlvbiAoYWN0b3IpIHtcclxuICAgICAgICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCk7XHJcbiAgICAgICAgICAgIHZhciBvdGhlckJvdW5kcyA9IGFjdG9yLmdldEJvdW5kcygpO1xyXG4gICAgICAgICAgICB2YXIgaW50ZXJzZWN0ID0gYm91bmRzLmNvbGxpZGVzKG90aGVyQm91bmRzKTtcclxuICAgICAgICAgICAgcmV0dXJuIGludGVyc2VjdDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlZ2lzdGVyIGEgaGFuZGxlciB0byBmaXJlIHdoZW4gdGhpcyBhY3RvciBjb2xsaWRlcyB3aXRoIGFub3RoZXIgaW4gYSBzcGVjaWZpZWQgZ3JvdXBcclxuICAgICAgICAgKiBAcGFyYW0gZ3JvdXAgVGhlIGdyb3VwIG5hbWUgdG8gbGlzdGVuIGZvclxyXG4gICAgICAgICAqIEBwYXJhbSBmdW5jIFRoZSBjYWxsYmFjayB0byBmaXJlIG9uIGNvbGxpc2lvbiB3aXRoIGFub3RoZXIgYWN0b3IgZnJvbSB0aGUgZ3JvdXAuIFRoZSBjYWxsYmFjayBpcyBwYXNzZWQgdGhlIG90aGVyIGFjdG9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUub25Db2xsaWRlc1dpdGggPSBmdW5jdGlvbiAoZ3JvdXAsIGZ1bmMpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9jb2xsaXNpb25IYW5kbGVyc1tncm91cF0pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxpc2lvbkhhbmRsZXJzW2dyb3VwXSA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbGxpc2lvbkhhbmRsZXJzW2dyb3VwXS5wdXNoKGZ1bmMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS5nZXRDb2xsaXNpb25IYW5kbGVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbGxpc2lvbkhhbmRsZXJzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlcyBhbGwgY29sbGlzaW9uIGhhbmRsZXJzIGZvciB0aGlzIGdyb3VwIG9uIHRoaXMgYWN0b3JcclxuICAgICAgICAgKiBAcGFyYW0gZ3JvdXAgR3JvdXAgdG8gcmVtb3ZlIGFsbCBoYW5kbGVycyBmb3Igb24gdGhpcyBhY3Rvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLnJlbW92ZUNvbGxpZGVzV2l0aCA9IGZ1bmN0aW9uIChncm91cCkge1xyXG4gICAgICAgICAgICB0aGlzLl9jb2xsaXNpb25IYW5kbGVyc1tncm91cF0gPSBbXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHdvIGFjdG9ycyBhcmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBkaXN0YW5jZSBzcGVjaWZpZWQgZnJvbSBlYWNoIG90aGVyXHJcbiAgICAgICAgICogQHBhcmFtIGFjdG9yICAgICBBY3RvciB0byB0ZXN0XHJcbiAgICAgICAgICogQHBhcmFtIGRpc3RhbmNlICBEaXN0YW5jZSBpbiBwaXhlbHMgdG8gdGVzdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUud2l0aGluID0gZnVuY3Rpb24gKGFjdG9yLCBkaXN0YW5jZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMucG9zLnggLSBhY3Rvci5wb3MueCwgMikgKyBNYXRoLnBvdyh0aGlzLnBvcy55IC0gYWN0b3IucG9zLnksIDIpKSA8PSBkaXN0YW5jZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUuX2dldENhbGN1bGF0ZWRBbmNob3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWxnZWJyYV8yNC5WZWN0b3IodGhpcy5nZXRXaWR0aCgpICogdGhpcy5hbmNob3IueCwgdGhpcy5nZXRIZWlnaHQoKSAqIHRoaXMuYW5jaG9yLnkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS5fcmVhcHBseUVmZmVjdHMgPSBmdW5jdGlvbiAoZHJhd2luZykge1xyXG4gICAgICAgICAgICBkcmF3aW5nLnJlbW92ZUVmZmVjdCh0aGlzLl9vcGFjaXR5RngpO1xyXG4gICAgICAgICAgICBkcmF3aW5nLmFkZEVmZmVjdCh0aGlzLl9vcGFjaXR5RngpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGVyZm9ybSBldWxlciBpbnRlZ3JhdGlvbiBhdCB0aGUgc3BlY2lmaWVkIHRpbWUgc3RlcFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUuaW50ZWdyYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBwbGFjZW1lbnRzIGJhc2VkIG9uIGxpbmVhciBhbGdlYnJhXHJcbiAgICAgICAgICAgIHZhciBzZWNvbmRzID0gZGVsdGEgLyAxMDAwO1xyXG4gICAgICAgICAgICB2YXIgdG90YWxBY2MgPSB0aGlzLmFjYy5jbG9uZSgpO1xyXG4gICAgICAgICAgICAvLyBPbmx5IGFjdGl2ZSB2YW5pbGxhIGFjdG9ycyBhcmUgYWZmZWN0ZWQgYnkgZ2xvYmFsIGFjY2VsZXJhdGlvblxyXG4gICAgICAgICAgICBpZiAodGhpcy5jb2xsaXNpb25UeXBlID09PSBDb2xsaXNpb25UeXBlLkFjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgdG90YWxBY2MuYWRkRXF1YWwoUGh5c2ljc18xMy5QaHlzaWNzLmFjYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy52ZWwuYWRkRXF1YWwodG90YWxBY2Muc2NhbGUoc2Vjb25kcykpO1xyXG4gICAgICAgICAgICB0aGlzLnBvcy5hZGRFcXVhbCh0aGlzLnZlbC5zY2FsZShzZWNvbmRzKSkuYWRkRXF1YWwodG90YWxBY2Muc2NhbGUoMC41ICogc2Vjb25kcyAqIHNlY29uZHMpKTtcclxuICAgICAgICAgICAgdGhpcy5yeCArPSB0aGlzLnRvcnF1ZSAqICgxLjAgLyB0aGlzLm1vaSkgKiBzZWNvbmRzO1xyXG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uICs9IHRoaXMucnggKiBzZWNvbmRzO1xyXG4gICAgICAgICAgICB0aGlzLnNjYWxlLnggKz0gdGhpcy5zeCAqIGRlbHRhIC8gMTAwMDtcclxuICAgICAgICAgICAgdGhpcy5zY2FsZS55ICs9IHRoaXMuc3kgKiBkZWx0YSAvIDEwMDA7XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBwaHlzaWNzIGJvZHlcclxuICAgICAgICAgICAgdGhpcy5ib2R5LnVwZGF0ZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FsbGVkIGJ5IHRoZSBFbmdpbmUsIHVwZGF0ZXMgdGhlIHN0YXRlIG9mIHRoZSBhY3RvclxyXG4gICAgICAgICAqIEBwYXJhbSBlbmdpbmUgVGhlIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBnYW1lIGVuZ2luZVxyXG4gICAgICAgICAqIEBwYXJhbSBkZWx0YSAgVGhlIHRpbWUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB1cGRhdGUgaW4gbWlsbGlzZWNvbmRzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZW5naW5lLCBkZWx0YSkge1xyXG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplKGVuZ2luZSk7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncHJldXBkYXRlJywgbmV3IEV2ZW50c18xNC5QcmVVcGRhdGVFdmVudChlbmdpbmUsIGRlbHRhLCB0aGlzKSk7XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBhY3Rpb24gcXVldWVcclxuICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZS51cGRhdGUoZGVsdGEpO1xyXG4gICAgICAgICAgICAvLyBVcGRhdGUgY29sb3Igb25seSBvcGFjaXR5XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbG9yLmEgPSB0aGlzLm9wYWNpdHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIGNoYW5naW5nIG9wYWNpdHlcclxuICAgICAgICAgICAgaWYgKHRoaXMucHJldmlvdXNPcGFjaXR5ICE9PSB0aGlzLm9wYWNpdHkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXNPcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fb3BhY2l0eUZ4Lm9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lZmZlY3RzRGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIENhcHR1cmUgb2xkIHZhbHVlcyBiZWZvcmUgaW50ZWdyYXRpb24gc3RlcCB1cGRhdGVzIHRoZW1cclxuICAgICAgICAgICAgdGhpcy5vbGRWZWwuc2V0VG8odGhpcy52ZWwueCwgdGhpcy52ZWwueSk7XHJcbiAgICAgICAgICAgIHRoaXMub2xkUG9zLnNldFRvKHRoaXMucG9zLngsIHRoaXMucG9zLnkpO1xyXG4gICAgICAgICAgICAvLyBSdW4gRXVsZXIgaW50ZWdyYXRpb25cclxuICAgICAgICAgICAgdGhpcy5pbnRlZ3JhdGUoZGVsdGEpO1xyXG4gICAgICAgICAgICAvLyBVcGRhdGUgYWN0b3IgcGlwZWxpbmUgKG1vdmVtZW50LCBjb2xsaXNpb24gZGV0ZWN0aW9uLCBldmVudCBwcm9wYWdhdGlvbiwgb2Zmc2NyZWVuIGN1bGxpbmcpXHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnRyYWl0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciB0cmFpdCA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgIHRyYWl0LnVwZGF0ZSh0aGlzLCBlbmdpbmUsIGRlbHRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgY2hpbGQgYWN0b3JzXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS51cGRhdGUoZW5naW5lLCBkZWx0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdwb3N0dXBkYXRlJywgbmV3IEV2ZW50c18xNC5Qb3N0VXBkYXRlRXZlbnQoZW5naW5lLCBkZWx0YSwgdGhpcykpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FsbGVkIGJ5IHRoZSBFbmdpbmUsIGRyYXdzIHRoZSBhY3RvciB0byB0aGUgc2NyZWVuXHJcbiAgICAgICAgICogQHBhcmFtIGN0eCAgIFRoZSByZW5kZXJpbmcgY29udGV4dFxyXG4gICAgICAgICAqIEBwYXJhbSBkZWx0YSBUaGUgdGltZSBzaW5jZSB0aGUgbGFzdCBkcmF3IGluIG1pbGxpc2Vjb25kc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjdHgsIGRlbHRhKSB7XHJcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUodGhpcy5wb3MueCwgdGhpcy5wb3MueSk7XHJcbiAgICAgICAgICAgIGN0eC5yb3RhdGUodGhpcy5yb3RhdGlvbik7XHJcbiAgICAgICAgICAgIGN0eC5zY2FsZSh0aGlzLnNjYWxlLngsIHRoaXMuc2NhbGUueSk7XHJcbiAgICAgICAgICAgIC8vIHRyYW5zbGF0ZSBjYW52YXMgYnkgYW5jaG9yIG9mZnNldFxyXG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKC0odGhpcy5fd2lkdGggKiB0aGlzLmFuY2hvci54KSwgLSh0aGlzLl9oZWlnaHQgKiB0aGlzLmFuY2hvci55KSk7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncHJlZHJhdycsIG5ldyBFdmVudHNfMTQuUHJlRHJhd0V2ZW50KGN0eCwgZGVsdGEsIHRoaXMpKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudERyYXdpbmcpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkcmF3aW5nID0gdGhpcy5jdXJyZW50RHJhd2luZztcclxuICAgICAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXhjYWxpYnVyanMvRXhjYWxpYnVyL3B1bGwvNjE5IGZvciBkaXNjdXNzaW9uIG9uIHRoaXMgZm9ybXVsYSAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRYID0gKHRoaXMuX3dpZHRoIC0gZHJhd2luZy5uYXR1cmFsV2lkdGggKiBkcmF3aW5nLnNjYWxlLngpICogdGhpcy5hbmNob3IueDtcclxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRZID0gKHRoaXMuX2hlaWdodCAtIGRyYXdpbmcubmF0dXJhbEhlaWdodCAqIGRyYXdpbmcuc2NhbGUueSkgKiB0aGlzLmFuY2hvci55O1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2VmZmVjdHNEaXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYXBwbHlFZmZlY3RzKHRoaXMuY3VycmVudERyYXdpbmcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VmZmVjdHNEaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50RHJhd2luZy5kcmF3KGN0eCwgb2Zmc2V0WCwgb2Zmc2V0WSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb2xvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmNvbG9yLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgIC8vIERyYXcgY2hpbGQgYWN0b3JzXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV0udmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0uZHJhdyhjdHgsIGRlbHRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3Bvc3RkcmF3JywgbmV3IEV2ZW50c18xNC5Qb3N0RHJhd0V2ZW50KGN0eCwgZGVsdGEsIHRoaXMpKTtcclxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGxlZCBieSB0aGUgRW5naW5lLCBkcmF3cyB0aGUgYWN0b3JzIGRlYnVnZ2luZyB0byB0aGUgc2NyZWVuXHJcbiAgICAgICAgICogQHBhcmFtIGN0eCBUaGUgcmVuZGVyaW5nIGNvbnRleHRcclxuICAgICAgICAgKi9cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUuZGVidWdEcmF3ID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3ByZWRlYnVnZHJhdycsIG5ldyBFdmVudHNfMTQuUHJlRGVidWdEcmF3RXZlbnQoY3R4LCB0aGlzKSk7XHJcbiAgICAgICAgICAgIHRoaXMuYm9keS5kZWJ1Z0RyYXcoY3R4KTtcclxuICAgICAgICAgICAgLy8gRHJhdyBhY3RvciBib3VuZGluZyBib3hcclxuICAgICAgICAgICAgdmFyIGJiID0gdGhpcy5nZXRCb3VuZHMoKTtcclxuICAgICAgICAgICAgYmIuZGVidWdEcmF3KGN0eCk7XHJcbiAgICAgICAgICAgIC8vIERyYXcgYWN0b3IgSWRcclxuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KCdpZDogJyArIHRoaXMuaWQsIGJiLmxlZnQgKyAzLCBiYi50b3AgKyAxMCk7XHJcbiAgICAgICAgICAgIC8vIERyYXcgYWN0b3IgYW5jaG9yIFZlY3RvclxyXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gQ29sb3JfMjAuQ29sb3IuWWVsbG93LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgY3R4LmFyYyh0aGlzLmdldFdvcmxkUG9zKCkueCwgdGhpcy5nZXRXb3JsZFBvcygpLnksIDMsIDAsIE1hdGguUEkgKiAyKTtcclxuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgICAgICAgICAvLyBDdWxsaW5nIEJveCBkZWJ1ZyBkcmF3XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy50cmFpdHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWl0c1tqXSBpbnN0YW5jZW9mIFRyYWl0cy5PZmZzY3JlZW5DdWxsaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFpdHNbal0uY3VsbGluZ0JveC5kZWJ1Z0RyYXcoY3R4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBVbml0IENpcmNsZSBkZWJ1ZyBkcmF3XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IENvbG9yXzIwLkNvbG9yLlllbGxvdy50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIHZhciByYWRpdXMgPSBNYXRoLm1pbih0aGlzLmdldFdpZHRoKCksIHRoaXMuZ2V0SGVpZ2h0KCkpO1xyXG4gICAgICAgICAgICBjdHguYXJjKHRoaXMuZ2V0V29ybGRQb3MoKS54LCB0aGlzLmdldFdvcmxkUG9zKCkueSwgcmFkaXVzLCAwLCBNYXRoLlBJICogMik7XHJcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgICAgICB2YXIgdGlja3MgPSB7XHJcbiAgICAgICAgICAgICAgICAnMCBQaSc6IDAsXHJcbiAgICAgICAgICAgICAgICAnUGkvMic6IE1hdGguUEkgLyAyLFxyXG4gICAgICAgICAgICAgICAgJ1BpJzogTWF0aC5QSSxcclxuICAgICAgICAgICAgICAgICczLzIgUGknOiAzICogTWF0aC5QSSAvIDJcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIG9sZEZvbnQgPSBjdHguZm9udDtcclxuICAgICAgICAgICAgZm9yICh2YXIgdGljayBpbiB0aWNrcykge1xyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IENvbG9yXzIwLkNvbG9yLlllbGxvdy50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgY3R4LmZvbnQgPSAnMTRweCc7XHJcbiAgICAgICAgICAgICAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XHJcbiAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQodGljaywgdGhpcy5nZXRXb3JsZFBvcygpLnggKyBNYXRoLmNvcyh0aWNrc1t0aWNrXSkgKiAocmFkaXVzICsgMTApLCB0aGlzLmdldFdvcmxkUG9zKCkueSArIE1hdGguc2luKHRpY2tzW3RpY2tdKSAqIChyYWRpdXMgKyAxMCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN0eC5mb250ID0gb2xkRm9udDtcclxuICAgICAgICAgICAgLy8gRHJhdyBjaGlsZCBhY3RvcnNcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLmRlYnVnRHJhdyhjdHgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncG9zdGRlYnVnZHJhdycsIG5ldyBFdmVudHNfMTQuUG9zdERlYnVnRHJhd0V2ZW50KGN0eCwgdGhpcykpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEFjdG9ySW1wbDtcclxuICAgIH0oQ2xhc3NfMTEuQ2xhc3MpKTtcclxuICAgIC8qKlxyXG4gICAgICogSW5kaWNhdGVzIHRoZSBuZXh0IGlkIHRvIGJlIHNldFxyXG4gICAgICovXHJcbiAgICBBY3RvckltcGwubWF4SWQgPSAwO1xyXG4gICAgZXhwb3J0cy5BY3RvckltcGwgPSBBY3RvckltcGw7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtb3N0IGltcG9ydGFudCBwcmltaXRpdmUgaW4gRXhjYWxpYnVyIGlzIGFuIGBBY3RvcmAuIEFueXRoaW5nIHRoYXRcclxuICAgICAqIGNhbiBtb3ZlIG9uIHRoZSBzY3JlZW4sIGNvbGxpZGUgd2l0aCBhbm90aGVyIGBBY3RvcmAsIHJlc3BvbmQgdG8gZXZlbnRzLFxyXG4gICAgICogb3IgaW50ZXJhY3Qgd2l0aCB0aGUgY3VycmVudCBzY2VuZSwgbXVzdCBiZSBhbiBhY3Rvci4gQW4gYEFjdG9yYCAqKm11c3QqKlxyXG4gICAgICogYmUgcGFydCBvZiBhIFtbU2NlbmVdXSBmb3IgaXQgdG8gYmUgZHJhd24gdG8gdGhlIHNjcmVlbi5cclxuICAgICAqXHJcbiAgICAgKiBbW2luY2x1ZGU6QWN0b3JzLm1kXV1cclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOkNvbnN0cnVjdG9ycy5tZF1dXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICB2YXIgQWN0b3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhBY3RvciwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBBY3Rvcih4T3JDb25maWcsIHksIHdpZHRoLCBoZWlnaHQsIGNvbG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB4T3JDb25maWcsIHksIHdpZHRoLCBoZWlnaHQsIGNvbG9yKSB8fCB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gQWN0b3I7XHJcbiAgICB9KENvbmZpZ3VyYWJsZV84LkNvbmZpZ3VyYWJsZShBY3RvckltcGwpKSk7XHJcbiAgICBleHBvcnRzLkFjdG9yID0gQWN0b3I7XHJcbiAgICAvKipcclxuICAgICAqIEFuIGVudW0gdGhhdCBkZXNjcmliZXMgdGhlIHR5cGVzIG9mIGNvbGxpc2lvbnMgYWN0b3JzIGNhbiBwYXJ0aWNpcGF0ZSBpblxyXG4gICAgICovXHJcbiAgICB2YXIgQ29sbGlzaW9uVHlwZTtcclxuICAgIChmdW5jdGlvbiAoQ29sbGlzaW9uVHlwZSkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFjdG9ycyB3aXRoIHRoZSBgUHJldmVudENvbGxpc2lvbmAgc2V0dGluZyBkbyBub3QgcGFydGljaXBhdGUgaW4gYW55XHJcbiAgICAgICAgICogY29sbGlzaW9ucyBhbmQgZG8gbm90IHJhaXNlIGNvbGxpc2lvbiBldmVudHMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sbGlzaW9uVHlwZVtDb2xsaXNpb25UeXBlW1wiUHJldmVudENvbGxpc2lvblwiXSA9IDBdID0gXCJQcmV2ZW50Q29sbGlzaW9uXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWN0b3JzIHdpdGggdGhlIGBQYXNzaXZlYCBzZXR0aW5nIG9ubHkgcmFpc2UgY29sbGlzaW9uIGV2ZW50cywgYnV0IGFyZSBub3RcclxuICAgICAgICAgKiBpbmZsdWVuY2VkIG9yIG1vdmVkIGJ5IG90aGVyIGFjdG9ycyBhbmQgZG8gbm90IGluZmx1ZW5jZSBvciBtb3ZlIG90aGVyIGFjdG9ycy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xsaXNpb25UeXBlW0NvbGxpc2lvblR5cGVbXCJQYXNzaXZlXCJdID0gMV0gPSBcIlBhc3NpdmVcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBY3RvcnMgd2l0aCB0aGUgYEFjdGl2ZWAgc2V0dGluZyByYWlzZSBjb2xsaXNpb24gZXZlbnRzIGFuZCBwYXJ0aWNpcGF0ZVxyXG4gICAgICAgICAqIGluIGNvbGxpc2lvbnMgd2l0aCBvdGhlciBhY3RvcnMgYW5kIHdpbGwgYmUgcHVzaCBvciBtb3ZlZCBieSBhY3RvcnMgc2hhcmluZ1xyXG4gICAgICAgICAqIHRoZSBgQWN0aXZlYCBvciBgRml4ZWRgIHNldHRpbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sbGlzaW9uVHlwZVtDb2xsaXNpb25UeXBlW1wiQWN0aXZlXCJdID0gMl0gPSBcIkFjdGl2ZVwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFjdG9ycyB3aXRoIHRoZSBgRml4ZWRgIHNldHRpbmcgcmFpc2UgY29sbGlzaW9uIGV2ZW50cyBhbmQgcGFydGljaXBhdGUgaW5cclxuICAgICAgICAgKiBjb2xsaXNpb25zIHdpdGggb3RoZXIgYWN0b3JzLiBBY3RvcnMgd2l0aCB0aGUgYEZpeGVkYCBzZXR0aW5nIHdpbGwgbm90IGJlXHJcbiAgICAgICAgICogcHVzaGVkIG9yIG1vdmVkIGJ5IG90aGVyIGFjdG9ycyBzaGFyaW5nIHRoZSBgRml4ZWRgLiBUaGluayBvZiBGaXhlZFxyXG4gICAgICAgICAqIGFjdG9ycyBhcyBcImltbW92YWJsZS9vbnN0b3BwYWJsZVwiIG9iamVjdHMuIElmIHR3byBgRml4ZWRgIGFjdG9ycyBtZWV0IHRoZXkgd2lsbFxyXG4gICAgICAgICAqIG5vdCBiZSBwdXNoZWQgb3IgbW92ZWQgYnkgZWFjaCBvdGhlciwgdGhleSB3aWxsIG5vdCBpbnRlcmFjdCBleGNlcHQgdG8gdGhyb3dcclxuICAgICAgICAgKiBjb2xsaXNpb24gZXZlbnRzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbGxpc2lvblR5cGVbQ29sbGlzaW9uVHlwZVtcIkZpeGVkXCJdID0gM10gPSBcIkZpeGVkXCI7XHJcbiAgICB9KShDb2xsaXNpb25UeXBlID0gZXhwb3J0cy5Db2xsaXNpb25UeXBlIHx8IChleHBvcnRzLkNvbGxpc2lvblR5cGUgPSB7fSkpO1xyXG59KTtcclxuZGVmaW5lKFwiQWN0aW9ucy9BY3Rpb25cIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJBY3Rpb25zL1JvdGF0aW9uVHlwZVwiLCBcIkFsZ2VicmFcIiwgXCJVdGlsL0xvZ1wiLCBcIlV0aWwvVXRpbFwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIFJvdGF0aW9uVHlwZV8yLCBBbGdlYnJhXzI1LCBMb2dfMTcsIFV0aWwpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgdmFyIEVhc2VUbyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gRWFzZVRvKGFjdG9yLCB4LCB5LCBkdXJhdGlvbiwgZWFzaW5nRmNuKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0b3IgPSBhY3RvcjtcclxuICAgICAgICAgICAgdGhpcy5lYXNpbmdGY24gPSBlYXNpbmdGY247XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRMZXJwVGltZSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2xlcnBEdXJhdGlvbiA9IDEgKiAxMDAwOyAvLyAxIHNlY29uZFxyXG4gICAgICAgICAgICB0aGlzLl9sZXJwU3RhcnQgPSBuZXcgQWxnZWJyYV8yNS5WZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2xlcnBFbmQgPSBuZXcgQWxnZWJyYV8yNS5WZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9sZXJwRHVyYXRpb24gPSBkdXJhdGlvbjtcclxuICAgICAgICAgICAgdGhpcy5fbGVycEVuZCA9IG5ldyBBbGdlYnJhXzI1LlZlY3Rvcih4LCB5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgRWFzZVRvLnByb3RvdHlwZS5faW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fbGVycFN0YXJ0ID0gbmV3IEFsZ2VicmFfMjUuVmVjdG9yKHRoaXMuYWN0b3IucG9zLngsIHRoaXMuYWN0b3IucG9zLnkpO1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50TGVycFRpbWUgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IHRoaXMuX2xlcnBTdGFydC5kaXN0YW5jZSh0aGlzLl9sZXJwRW5kKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEVhc2VUby5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbmV3WCA9IHRoaXMuYWN0b3IucG9zLng7XHJcbiAgICAgICAgICAgIHZhciBuZXdZID0gdGhpcy5hY3Rvci5wb3MueTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRMZXJwVGltZSA8IHRoaXMuX2xlcnBEdXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xlcnBFbmQueCA8IHRoaXMuX2xlcnBTdGFydC54KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3WCA9IHRoaXMuX2xlcnBTdGFydC54IC0gKHRoaXMuZWFzaW5nRmNuKHRoaXMuX2N1cnJlbnRMZXJwVGltZSwgdGhpcy5fbGVycEVuZC54LCB0aGlzLl9sZXJwU3RhcnQueCwgdGhpcy5fbGVycER1cmF0aW9uKSAtIHRoaXMuX2xlcnBFbmQueCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdYID0gdGhpcy5lYXNpbmdGY24odGhpcy5fY3VycmVudExlcnBUaW1lLCB0aGlzLl9sZXJwU3RhcnQueCwgdGhpcy5fbGVycEVuZC54LCB0aGlzLl9sZXJwRHVyYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xlcnBFbmQueSA8IHRoaXMuX2xlcnBTdGFydC55KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3WSA9IHRoaXMuX2xlcnBTdGFydC55IC0gKHRoaXMuZWFzaW5nRmNuKHRoaXMuX2N1cnJlbnRMZXJwVGltZSwgdGhpcy5fbGVycEVuZC55LCB0aGlzLl9sZXJwU3RhcnQueSwgdGhpcy5fbGVycER1cmF0aW9uKSAtIHRoaXMuX2xlcnBFbmQueSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdZID0gdGhpcy5lYXNpbmdGY24odGhpcy5fY3VycmVudExlcnBUaW1lLCB0aGlzLl9sZXJwU3RhcnQueSwgdGhpcy5fbGVycEVuZC55LCB0aGlzLl9sZXJwRHVyYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5wb3MueCA9IG5ld1g7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnBvcy55ID0gbmV3WTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRMZXJwVGltZSArPSBkZWx0YTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IucG9zLnggPSB0aGlzLl9sZXJwRW5kLng7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnBvcy55ID0gdGhpcy5fbGVycEVuZC55O1xyXG4gICAgICAgICAgICAgICAgLy90aGlzLl9sZXJwU3RhcnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgLy90aGlzLl9sZXJwRW5kID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIC8vdGhpcy5fY3VycmVudExlcnBUaW1lID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgRWFzZVRvLnByb3RvdHlwZS5pc0NvbXBsZXRlID0gZnVuY3Rpb24gKGFjdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8IChuZXcgQWxnZWJyYV8yNS5WZWN0b3IoYWN0b3IucG9zLngsIGFjdG9yLnBvcy55KSkuZGlzdGFuY2UodGhpcy5fbGVycFN0YXJ0KSA+PSB0aGlzLl9kaXN0YW5jZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEVhc2VUby5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBFYXNlVG8ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEVhc2VUbztcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkVhc2VUbyA9IEVhc2VUbztcclxuICAgIHZhciBNb3ZlVG8gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIE1vdmVUbyhhY3RvciwgZGVzdHgsIGRlc3R5LCBzcGVlZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IgPSBhY3RvcjtcclxuICAgICAgICAgICAgdGhpcy5fZW5kID0gbmV3IEFsZ2VicmFfMjUuVmVjdG9yKGRlc3R4LCBkZXN0eSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3NwZWVkID0gc3BlZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE1vdmVUby5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKF9kZWx0YSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnQgPSBuZXcgQWxnZWJyYV8yNS5WZWN0b3IodGhpcy5fYWN0b3IucG9zLngsIHRoaXMuX2FjdG9yLnBvcy55KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gdGhpcy5fc3RhcnQuZGlzdGFuY2UodGhpcy5fZW5kKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RpciA9IHRoaXMuX2VuZC5zdWIodGhpcy5fc3RhcnQpLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBtID0gdGhpcy5fZGlyLnNjYWxlKHRoaXMuX3NwZWVkKTtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IudmVsLnggPSBtLng7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yLnZlbC55ID0gbS55O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0NvbXBsZXRlKHRoaXMuX2FjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3IucG9zLnggPSB0aGlzLl9lbmQueDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnBvcy55ID0gdGhpcy5fZW5kLnk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci52ZWwueSA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci52ZWwueCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIE1vdmVUby5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uIChhY3Rvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZCB8fCAobmV3IEFsZ2VicmFfMjUuVmVjdG9yKGFjdG9yLnBvcy54LCBhY3Rvci5wb3MueSkpLmRpc3RhbmNlKHRoaXMuX3N0YXJ0KSA+PSB0aGlzLl9kaXN0YW5jZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIE1vdmVUby5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IudmVsLnkgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rvci52ZWwueCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgTW92ZVRvLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIE1vdmVUbztcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLk1vdmVUbyA9IE1vdmVUbztcclxuICAgIHZhciBNb3ZlQnkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIE1vdmVCeShhY3RvciwgZGVzdHgsIGRlc3R5LCB0aW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RvciA9IGFjdG9yO1xyXG4gICAgICAgICAgICB0aGlzLl9lbmQgPSBuZXcgQWxnZWJyYV8yNS5WZWN0b3IoZGVzdHgsIGRlc3R5KTtcclxuICAgICAgICAgICAgaWYgKHRpbWUgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgTG9nXzE3LkxvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKCdBdHRlbXB0ZWQgdG8gbW92ZUJ5IHRpbWUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHplcm8gOiAnICsgdGltZSk7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBtb3ZlIGluIHRpbWUgPD0gMCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3RpbWUgPSB0aW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBNb3ZlQnkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChfZGVsdGEpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ID0gbmV3IEFsZ2VicmFfMjUuVmVjdG9yKHRoaXMuX2FjdG9yLnBvcy54LCB0aGlzLl9hY3Rvci5wb3MueSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IHRoaXMuX3N0YXJ0LmRpc3RhbmNlKHRoaXMuX2VuZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXIgPSB0aGlzLl9lbmQuc3ViKHRoaXMuX3N0YXJ0KS5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NwZWVkID0gdGhpcy5fZGlzdGFuY2UgLyAodGhpcy5fdGltZSAvIDEwMDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBtID0gdGhpcy5fZGlyLnNjYWxlKHRoaXMuX3NwZWVkKTtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IudmVsLnggPSBtLng7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yLnZlbC55ID0gbS55O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0NvbXBsZXRlKHRoaXMuX2FjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3IucG9zLnggPSB0aGlzLl9lbmQueDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnBvcy55ID0gdGhpcy5fZW5kLnk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci52ZWwueSA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci52ZWwueCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIE1vdmVCeS5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uIChhY3Rvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZCB8fCAobmV3IEFsZ2VicmFfMjUuVmVjdG9yKGFjdG9yLnBvcy54LCBhY3Rvci5wb3MueSkpLmRpc3RhbmNlKHRoaXMuX3N0YXJ0KSA+PSB0aGlzLl9kaXN0YW5jZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIE1vdmVCeS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IudmVsLnkgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rvci52ZWwueCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgTW92ZUJ5LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIE1vdmVCeTtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLk1vdmVCeSA9IE1vdmVCeTtcclxuICAgIHZhciBGb2xsb3cgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIEZvbGxvdyhhY3RvciwgYWN0b3JUb0ZvbGxvdywgZm9sbG93RGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yID0gYWN0b3I7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yVG9Gb2xsb3cgPSBhY3RvclRvRm9sbG93O1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gbmV3IEFsZ2VicmFfMjUuVmVjdG9yKHRoaXMuX2FjdG9yLnBvcy54LCB0aGlzLl9hY3Rvci5wb3MueSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZCA9IG5ldyBBbGdlYnJhXzI1LlZlY3RvcihhY3RvclRvRm9sbG93LnBvcy54LCBhY3RvclRvRm9sbG93LnBvcy55KTtcclxuICAgICAgICAgICAgdGhpcy5fbWF4aW11bURpc3RhbmNlID0gKGZvbGxvd0Rpc3RhbmNlICE9PSB1bmRlZmluZWQpID8gZm9sbG93RGlzdGFuY2UgOiB0aGlzLl9jdXJyZW50LmRpc3RhbmNlKHRoaXMuX2VuZCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3NwZWVkID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgRm9sbG93LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoX2RlbHRhKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXN0YW5jZUJldHdlZW4gPSB0aGlzLl9jdXJyZW50LmRpc3RhbmNlKHRoaXMuX2VuZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXIgPSB0aGlzLl9lbmQuc3ViKHRoaXMuX2N1cnJlbnQpLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBhY3RvclRvRm9sbG93U3BlZWQgPSBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy5fYWN0b3JUb0ZvbGxvdy52ZWwueCwgMikgKyBNYXRoLnBvdyh0aGlzLl9hY3RvclRvRm9sbG93LnZlbC55LCAyKSk7XHJcbiAgICAgICAgICAgIGlmIChhY3RvclRvRm9sbG93U3BlZWQgIT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NwZWVkID0gYWN0b3JUb0ZvbGxvd1NwZWVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQueCA9IHRoaXMuX2FjdG9yLnBvcy54O1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50LnkgPSB0aGlzLl9hY3Rvci5wb3MueTtcclxuICAgICAgICAgICAgdGhpcy5fZW5kLnggPSB0aGlzLl9hY3RvclRvRm9sbG93LnBvcy54O1xyXG4gICAgICAgICAgICB0aGlzLl9lbmQueSA9IHRoaXMuX2FjdG9yVG9Gb2xsb3cucG9zLnk7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlQmV0d2VlbiA9IHRoaXMuX2N1cnJlbnQuZGlzdGFuY2UodGhpcy5fZW5kKTtcclxuICAgICAgICAgICAgdGhpcy5fZGlyID0gdGhpcy5fZW5kLnN1Yih0aGlzLl9jdXJyZW50KS5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2Rpc3RhbmNlQmV0d2VlbiA+PSB0aGlzLl9tYXhpbXVtRGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtID0gdGhpcy5fZGlyLnNjYWxlKHRoaXMuX3NwZWVkKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnZlbC54ID0gbS54O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3IudmVsLnkgPSBtLnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci52ZWwueCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci52ZWwueSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPIHRoaXMgc2hvdWxkIG5ldmVyIG9jY3VyXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci5wb3MueCA9IHRoaXMuX2VuZC54O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3IucG9zLnkgPSB0aGlzLl9lbmQueTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnZlbC55ID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnZlbC54ID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgRm9sbG93LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rvci52ZWwueSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yLnZlbC54ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBGb2xsb3cucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIHRoZSBhY3RvciBmb2xsb3dpbmcgc2hvdWxkIG5ldmVyIHN0b3AgdW5sZXNzIHNwZWNpZmllZCB0byBkbyBzb1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEZvbGxvdy5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBGb2xsb3c7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5Gb2xsb3cgPSBGb2xsb3c7XHJcbiAgICB2YXIgTWVldCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gTWVldChhY3RvciwgYWN0b3JUb01lZXQsIHNwZWVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9zcGVlZFdhc1NwZWNpZmllZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RvciA9IGFjdG9yO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RvclRvTWVldCA9IGFjdG9yVG9NZWV0O1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gbmV3IEFsZ2VicmFfMjUuVmVjdG9yKHRoaXMuX2FjdG9yLnBvcy54LCB0aGlzLl9hY3Rvci5wb3MueSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZCA9IG5ldyBBbGdlYnJhXzI1LlZlY3RvcihhY3RvclRvTWVldC5wb3MueCwgYWN0b3JUb01lZXQucG9zLnkpO1xyXG4gICAgICAgICAgICB0aGlzLl9zcGVlZCA9IHNwZWVkIHx8IDA7XHJcbiAgICAgICAgICAgIGlmIChzcGVlZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGVlZFdhc1NwZWNpZmllZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgTWVldC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKF9kZWx0YSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2VCZXR3ZWVuID0gdGhpcy5fY3VycmVudC5kaXN0YW5jZSh0aGlzLl9lbmQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlyID0gdGhpcy5fZW5kLnN1Yih0aGlzLl9jdXJyZW50KS5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYWN0b3JUb01lZXRTcGVlZCA9IE1hdGguc3FydChNYXRoLnBvdyh0aGlzLl9hY3RvclRvTWVldC52ZWwueCwgMikgKyBNYXRoLnBvdyh0aGlzLl9hY3RvclRvTWVldC52ZWwueSwgMikpO1xyXG4gICAgICAgICAgICBpZiAoKGFjdG9yVG9NZWV0U3BlZWQgIT09IDApICYmICghdGhpcy5fc3BlZWRXYXNTcGVjaWZpZWQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGVlZCA9IGFjdG9yVG9NZWV0U3BlZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudC54ID0gdGhpcy5fYWN0b3IucG9zLng7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQueSA9IHRoaXMuX2FjdG9yLnBvcy55O1xyXG4gICAgICAgICAgICB0aGlzLl9lbmQueCA9IHRoaXMuX2FjdG9yVG9NZWV0LnBvcy54O1xyXG4gICAgICAgICAgICB0aGlzLl9lbmQueSA9IHRoaXMuX2FjdG9yVG9NZWV0LnBvcy55O1xyXG4gICAgICAgICAgICB0aGlzLl9kaXN0YW5jZUJldHdlZW4gPSB0aGlzLl9jdXJyZW50LmRpc3RhbmNlKHRoaXMuX2VuZCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2RpciA9IHRoaXMuX2VuZC5zdWIodGhpcy5fY3VycmVudCkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgIHZhciBtID0gdGhpcy5fZGlyLnNjYWxlKHRoaXMuX3NwZWVkKTtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IudmVsLnggPSBtLng7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yLnZlbC55ID0gbS55O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0NvbXBsZXRlKCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnBvcy54ID0gdGhpcy5fZW5kLng7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci5wb3MueSA9IHRoaXMuX2VuZC55O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3IudmVsLnkgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3IudmVsLnggPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBNZWV0LnByb3RvdHlwZS5pc0NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZCB8fCAodGhpcy5fZGlzdGFuY2VCZXR3ZWVuIDw9IDEpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgTWVldC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IudmVsLnkgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rvci52ZWwueCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgTWVldC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBNZWV0O1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuTWVldCA9IE1lZXQ7XHJcbiAgICB2YXIgUm90YXRlVG8gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIFJvdGF0ZVRvKGFjdG9yLCBhbmdsZVJhZGlhbnMsIHNwZWVkLCByb3RhdGlvblR5cGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yID0gYWN0b3I7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZCA9IGFuZ2xlUmFkaWFucztcclxuICAgICAgICAgICAgdGhpcy5fc3BlZWQgPSBzcGVlZDtcclxuICAgICAgICAgICAgdGhpcy5fcm90YXRpb25UeXBlID0gcm90YXRpb25UeXBlIHx8IFJvdGF0aW9uVHlwZV8yLlJvdGF0aW9uVHlwZS5TaG9ydGVzdFBhdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFJvdGF0ZVRvLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoX2RlbHRhKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydCA9IHRoaXMuX2FjdG9yLnJvdGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlMSA9IE1hdGguYWJzKHRoaXMuX2VuZCAtIHRoaXMuX3N0YXJ0KTtcclxuICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZTIgPSBVdGlsLlR3b1BJIC0gZGlzdGFuY2UxO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlMSA+IGRpc3RhbmNlMikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0RGlzdGFuY2UgPSBkaXN0YW5jZTI7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9uZ0Rpc3RhbmNlID0gZGlzdGFuY2UxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2hvcnREaXN0YW5jZSA9IGRpc3RhbmNlMTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb25nRGlzdGFuY2UgPSBkaXN0YW5jZTI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydGVzdFBhdGhJc1Bvc2l0aXZlID0gKHRoaXMuX3N0YXJ0IC0gdGhpcy5fZW5kICsgVXRpbC5Ud29QSSkgJSBVdGlsLlR3b1BJID49IE1hdGguUEk7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3JvdGF0aW9uVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUm90YXRpb25UeXBlXzIuUm90YXRpb25UeXBlLlNob3J0ZXN0UGF0aDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9zaG9ydERpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fc2hvcnRlc3RQYXRoSXNQb3NpdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUm90YXRpb25UeXBlXzIuUm90YXRpb25UeXBlLkxvbmdlc3RQYXRoOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IHRoaXMuX2xvbmdEaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Nob3J0ZXN0UGF0aElzUG9zaXRpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFJvdGF0aW9uVHlwZV8yLlJvdGF0aW9uVHlwZS5DbG9ja3dpc2U6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zaG9ydGVzdFBhdGhJc1Bvc2l0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IHRoaXMuX3Nob3J0RGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IHRoaXMuX2xvbmdEaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFJvdGF0aW9uVHlwZV8yLlJvdGF0aW9uVHlwZS5Db3VudGVyQ2xvY2t3aXNlOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9zaG9ydGVzdFBhdGhJc1Bvc2l0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IHRoaXMuX3Nob3J0RGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IHRoaXMuX2xvbmdEaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9hY3Rvci5yeCA9IHRoaXMuX2RpcmVjdGlvbiAqIHRoaXMuX3NwZWVkO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0NvbXBsZXRlKCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnJvdGF0aW9uID0gdGhpcy5fZW5kO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3IucnggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFJvdGF0ZVRvLnByb3RvdHlwZS5pc0NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZGlzdGFuY2VUcmF2ZWxsZWQgPSBNYXRoLmFicyh0aGlzLl9hY3Rvci5yb3RhdGlvbiAtIHRoaXMuX3N0YXJ0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgKGRpc3RhbmNlVHJhdmVsbGVkID49IE1hdGguYWJzKHRoaXMuX2Rpc3RhbmNlKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBSb3RhdGVUby5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IucnggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFJvdGF0ZVRvLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFJvdGF0ZVRvO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuUm90YXRlVG8gPSBSb3RhdGVUbztcclxuICAgIHZhciBSb3RhdGVCeSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gUm90YXRlQnkoYWN0b3IsIGFuZ2xlUmFkaWFucywgdGltZSwgcm90YXRpb25UeXBlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RvciA9IGFjdG9yO1xyXG4gICAgICAgICAgICB0aGlzLl9lbmQgPSBhbmdsZVJhZGlhbnM7XHJcbiAgICAgICAgICAgIHRoaXMuX3RpbWUgPSB0aW1lO1xyXG4gICAgICAgICAgICB0aGlzLl9yb3RhdGlvblR5cGUgPSByb3RhdGlvblR5cGUgfHwgUm90YXRpb25UeXBlXzIuUm90YXRpb25UeXBlLlNob3J0ZXN0UGF0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgUm90YXRlQnkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChfZGVsdGEpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ID0gdGhpcy5fYWN0b3Iucm90YXRpb247XHJcbiAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UxID0gTWF0aC5hYnModGhpcy5fZW5kIC0gdGhpcy5fc3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlMiA9IFV0aWwuVHdvUEkgLSBkaXN0YW5jZTE7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UxID4gZGlzdGFuY2UyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2hvcnREaXN0YW5jZSA9IGRpc3RhbmNlMjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb25nRGlzdGFuY2UgPSBkaXN0YW5jZTE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydERpc3RhbmNlID0gZGlzdGFuY2UxO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdEaXN0YW5jZSA9IGRpc3RhbmNlMjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0ZXN0UGF0aElzUG9zaXRpdmUgPSAodGhpcy5fc3RhcnQgLSB0aGlzLl9lbmQgKyBVdGlsLlR3b1BJKSAlIFV0aWwuVHdvUEkgPj0gTWF0aC5QSTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcm90YXRpb25UeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBSb3RhdGlvblR5cGVfMi5Sb3RhdGlvblR5cGUuU2hvcnRlc3RQYXRoOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IHRoaXMuX3Nob3J0RGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zaG9ydGVzdFBhdGhJc1Bvc2l0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBSb3RhdGlvblR5cGVfMi5Sb3RhdGlvblR5cGUuTG9uZ2VzdFBhdGg6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gdGhpcy5fbG9uZ0Rpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fc2hvcnRlc3RQYXRoSXNQb3NpdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUm90YXRpb25UeXBlXzIuUm90YXRpb25UeXBlLkNsb2Nrd2lzZTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Nob3J0RGlzdGFuY2UgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9zaG9ydERpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9sb25nRGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBSb3RhdGlvblR5cGVfMi5Sb3RhdGlvblR5cGUuQ291bnRlckNsb2Nrd2lzZTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zaG9ydERpc3RhbmNlIDw9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gdGhpcy5fc2hvcnREaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gdGhpcy5fbG9uZ0Rpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3BlZWQgPSBNYXRoLmFicyh0aGlzLl9kaXN0YW5jZSAvIHRoaXMuX3RpbWUgKiAxMDAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9hY3Rvci5yeCA9IHRoaXMuX2RpcmVjdGlvbiAqIHRoaXMuX3NwZWVkO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0NvbXBsZXRlKCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnJvdGF0aW9uID0gdGhpcy5fZW5kO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3IucnggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFJvdGF0ZUJ5LnByb3RvdHlwZS5pc0NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZGlzdGFuY2VUcmF2ZWxsZWQgPSBNYXRoLmFicyh0aGlzLl9hY3Rvci5yb3RhdGlvbiAtIHRoaXMuX3N0YXJ0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgKGRpc3RhbmNlVHJhdmVsbGVkID49IE1hdGguYWJzKHRoaXMuX2Rpc3RhbmNlKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBSb3RhdGVCeS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IucnggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFJvdGF0ZUJ5LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFJvdGF0ZUJ5O1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuUm90YXRlQnkgPSBSb3RhdGVCeTtcclxuICAgIHZhciBTY2FsZVRvID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBTY2FsZVRvKGFjdG9yLCBzY2FsZVgsIHNjYWxlWSwgc3BlZWRYLCBzcGVlZFkpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yID0gYWN0b3I7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZFggPSBzY2FsZVg7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZFkgPSBzY2FsZVk7XHJcbiAgICAgICAgICAgIHRoaXMuX3NwZWVkWCA9IHNwZWVkWDtcclxuICAgICAgICAgICAgdGhpcy5fc3BlZWRZID0gc3BlZWRZO1xyXG4gICAgICAgIH1cclxuICAgICAgICBTY2FsZVRvLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoX2RlbHRhKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydFggPSB0aGlzLl9hY3Rvci5zY2FsZS54O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRZID0gdGhpcy5fYWN0b3Iuc2NhbGUueTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlWCA9IE1hdGguYWJzKHRoaXMuX2VuZFggLSB0aGlzLl9zdGFydFgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2VZID0gTWF0aC5hYnModGhpcy5fZW5kWSAtIHRoaXMuX3N0YXJ0WSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCEoTWF0aC5hYnModGhpcy5fYWN0b3Iuc2NhbGUueCAtIHRoaXMuX3N0YXJ0WCkgPj0gdGhpcy5fZGlzdGFuY2VYKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRpcmVjdGlvblggPSB0aGlzLl9lbmRZIDwgdGhpcy5fc3RhcnRZID8gLTEgOiAxO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3Iuc3ggPSB0aGlzLl9zcGVlZFggKiBkaXJlY3Rpb25YO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3Iuc3ggPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghKE1hdGguYWJzKHRoaXMuX2FjdG9yLnNjYWxlLnkgLSB0aGlzLl9zdGFydFkpID49IHRoaXMuX2Rpc3RhbmNlWSkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkaXJlY3Rpb25ZID0gdGhpcy5fZW5kWSA8IHRoaXMuX3N0YXJ0WSA/IC0xIDogMTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnN5ID0gdGhpcy5fc3BlZWRZICogZGlyZWN0aW9uWTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnN5ID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0NvbXBsZXRlKCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnNjYWxlLnggPSB0aGlzLl9lbmRYO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3Iuc2NhbGUueSA9IHRoaXMuX2VuZFk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci5zeCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci5zeSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFNjYWxlVG8ucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8ICgoTWF0aC5hYnModGhpcy5fYWN0b3Iuc2NhbGUueSAtIHRoaXMuX3N0YXJ0WCkgPj0gdGhpcy5fZGlzdGFuY2VYKSAmJlxyXG4gICAgICAgICAgICAgICAgKE1hdGguYWJzKHRoaXMuX2FjdG9yLnNjYWxlLnkgLSB0aGlzLl9zdGFydFkpID49IHRoaXMuX2Rpc3RhbmNlWSkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgU2NhbGVUby5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3Iuc3ggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rvci5zeSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgU2NhbGVUby5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBTY2FsZVRvO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuU2NhbGVUbyA9IFNjYWxlVG87XHJcbiAgICB2YXIgU2NhbGVCeSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gU2NhbGVCeShhY3Rvciwgc2NhbGVYLCBzY2FsZVksIHRpbWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yID0gYWN0b3I7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZFggPSBzY2FsZVg7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZFkgPSBzY2FsZVk7XHJcbiAgICAgICAgICAgIHRoaXMuX3NwZWVkWCA9ICh0aGlzLl9lbmRYIC0gdGhpcy5fYWN0b3Iuc2NhbGUueCkgLyB0aW1lICogMTAwMDtcclxuICAgICAgICAgICAgdGhpcy5fc3BlZWRZID0gKHRoaXMuX2VuZFkgLSB0aGlzLl9hY3Rvci5zY2FsZS55KSAvIHRpbWUgKiAxMDAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBTY2FsZUJ5LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoX2RlbHRhKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydFggPSB0aGlzLl9hY3Rvci5zY2FsZS54O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRZID0gdGhpcy5fYWN0b3Iuc2NhbGUueTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlWCA9IE1hdGguYWJzKHRoaXMuX2VuZFggLSB0aGlzLl9zdGFydFgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2VZID0gTWF0aC5hYnModGhpcy5fZW5kWSAtIHRoaXMuX3N0YXJ0WSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGRpcmVjdGlvblggPSB0aGlzLl9lbmRYIDwgdGhpcy5fc3RhcnRYID8gLTEgOiAxO1xyXG4gICAgICAgICAgICB2YXIgZGlyZWN0aW9uWSA9IHRoaXMuX2VuZFkgPCB0aGlzLl9zdGFydFkgPyAtMSA6IDE7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yLnN4ID0gdGhpcy5fc3BlZWRYICogZGlyZWN0aW9uWDtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3Iuc3kgPSB0aGlzLl9zcGVlZFkgKiBkaXJlY3Rpb25ZO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0NvbXBsZXRlKCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnNjYWxlLnggPSB0aGlzLl9lbmRYO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3Iuc2NhbGUueSA9IHRoaXMuX2VuZFk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci5zeCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci5zeSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFNjYWxlQnkucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8ICgoTWF0aC5hYnModGhpcy5fYWN0b3Iuc2NhbGUueCAtIHRoaXMuX3N0YXJ0WCkgPj0gdGhpcy5fZGlzdGFuY2VYKSAmJlxyXG4gICAgICAgICAgICAgICAgKE1hdGguYWJzKHRoaXMuX2FjdG9yLnNjYWxlLnkgLSB0aGlzLl9zdGFydFkpID49IHRoaXMuX2Rpc3RhbmNlWSkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgU2NhbGVCeS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3Iuc3ggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rvci5zeSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgU2NhbGVCeS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBTY2FsZUJ5O1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuU2NhbGVCeSA9IFNjYWxlQnk7XHJcbiAgICB2YXIgRGVsYXkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIERlbGF5KGFjdG9yLCBkZWxheSkge1xyXG4gICAgICAgICAgICB0aGlzLl9lbGFwc2VkVGltZSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RvciA9IGFjdG9yO1xyXG4gICAgICAgICAgICB0aGlzLl9kZWxheSA9IGRlbGF5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBEZWxheS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy54ID0gdGhpcy5fYWN0b3IucG9zLng7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHRoaXMuX2FjdG9yLnBvcy55O1xyXG4gICAgICAgICAgICB0aGlzLl9lbGFwc2VkVGltZSArPSBkZWx0YTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIERlbGF5LnByb3RvdHlwZS5pc0NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZCB8fCAodGhpcy5fZWxhcHNlZFRpbWUgPj0gdGhpcy5fZGVsYXkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRGVsYXkucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRGVsYXkucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9lbGFwc2VkVGltZSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBEZWxheTtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkRlbGF5ID0gRGVsYXk7XHJcbiAgICB2YXIgQmxpbmsgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIEJsaW5rKGFjdG9yLCB0aW1lVmlzaWJsZSwgdGltZU5vdFZpc2libGUsIG51bUJsaW5rcykge1xyXG4gICAgICAgICAgICBpZiAobnVtQmxpbmtzID09PSB2b2lkIDApIHsgbnVtQmxpbmtzID0gMTsgfVxyXG4gICAgICAgICAgICB0aGlzLl90aW1lVmlzaWJsZSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3RpbWVOb3RWaXNpYmxlID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fZWxhcHNlZFRpbWUgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl90b3RhbFRpbWUgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IgPSBhY3RvcjtcclxuICAgICAgICAgICAgdGhpcy5fdGltZVZpc2libGUgPSB0aW1lVmlzaWJsZTtcclxuICAgICAgICAgICAgdGhpcy5fdGltZU5vdFZpc2libGUgPSB0aW1lTm90VmlzaWJsZTtcclxuICAgICAgICAgICAgdGhpcy5fZHVyYXRpb24gPSAodGltZVZpc2libGUgKyB0aW1lTm90VmlzaWJsZSkgKiBudW1CbGlua3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEJsaW5rLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9lbGFwc2VkVGltZSArPSBkZWx0YTtcclxuICAgICAgICAgICAgdGhpcy5fdG90YWxUaW1lICs9IGRlbHRhO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fYWN0b3IudmlzaWJsZSAmJiB0aGlzLl9lbGFwc2VkVGltZSA+PSB0aGlzLl90aW1lVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3IudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZWxhcHNlZFRpbWUgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fYWN0b3IudmlzaWJsZSAmJiB0aGlzLl9lbGFwc2VkVGltZSA+PSB0aGlzLl90aW1lTm90VmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3IudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lbGFwc2VkVGltZSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgQmxpbmsucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8ICh0aGlzLl90b3RhbFRpbWUgPj0gdGhpcy5fZHVyYXRpb24pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQmxpbmsucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEJsaW5rLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9lbGFwc2VkVGltZSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3RvdGFsVGltZSA9IDA7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gQmxpbms7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5CbGluayA9IEJsaW5rO1xyXG4gICAgdmFyIEZhZGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIEZhZGUoYWN0b3IsIGVuZE9wYWNpdHksIHNwZWVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX211bHRpcGxpZXIgPSAxO1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IgPSBhY3RvcjtcclxuICAgICAgICAgICAgdGhpcy5fZW5kT3BhY2l0eSA9IGVuZE9wYWNpdHk7XHJcbiAgICAgICAgICAgIHRoaXMuX3NwZWVkID0gc3BlZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEZhZGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIGRpcmVjdGlvbiB3aGVuIHdlIHN0YXJ0XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZW5kT3BhY2l0eSA8IHRoaXMuX2FjdG9yLm9wYWNpdHkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tdWx0aXBsaWVyID0gLTE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tdWx0aXBsaWVyID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5fc3BlZWQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci5vcGFjaXR5ICs9IHRoaXMuX211bHRpcGxpZXIgKiAoTWF0aC5hYnModGhpcy5fYWN0b3Iub3BhY2l0eSAtIHRoaXMuX2VuZE9wYWNpdHkpICogZGVsdGEpIC8gdGhpcy5fc3BlZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fc3BlZWQgLT0gZGVsdGE7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ29tcGxldGUoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3Iub3BhY2l0eSA9IHRoaXMuX2VuZE9wYWNpdHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgTG9nXzE3LkxvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdbQWN0aW9uIGZhZGVdIEFjdG9yIG9wYWNpdHk6JywgdGhpcy5fYWN0b3Iub3BhY2l0eSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBGYWRlLnByb3RvdHlwZS5pc0NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZCB8fCAoTWF0aC5hYnModGhpcy5fYWN0b3Iub3BhY2l0eSAtIHRoaXMuX2VuZE9wYWNpdHkpIDwgMC4wNSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBGYWRlLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEZhZGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gRmFkZTtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkZhZGUgPSBGYWRlO1xyXG4gICAgdmFyIERpZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gRGllKGFjdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IgPSBhY3RvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgRGllLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoX2RlbHRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yLmFjdGlvblF1ZXVlLmNsZWFyQWN0aW9ucygpO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rvci5raWxsKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRGllLnByb3RvdHlwZS5pc0NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIERpZS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuOyB9O1xyXG4gICAgICAgIERpZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybjsgfTtcclxuICAgICAgICByZXR1cm4gRGllO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuRGllID0gRGllO1xyXG4gICAgdmFyIENhbGxNZXRob2QgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIENhbGxNZXRob2QoYWN0b3IsIG1ldGhvZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9tZXRob2QgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RvciA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhc0JlZW5DYWxsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IgPSBhY3RvcjtcclxuICAgICAgICAgICAgdGhpcy5fbWV0aG9kID0gbWV0aG9kO1xyXG4gICAgICAgIH1cclxuICAgICAgICBDYWxsTWV0aG9kLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoX2RlbHRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21ldGhvZC5jYWxsKHRoaXMuX2FjdG9yKTtcclxuICAgICAgICAgICAgdGhpcy5faGFzQmVlbkNhbGxlZCA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDYWxsTWV0aG9kLnByb3RvdHlwZS5pc0NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faGFzQmVlbkNhbGxlZDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIENhbGxNZXRob2QucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9oYXNCZWVuQ2FsbGVkID0gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDYWxsTWV0aG9kLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9oYXNCZWVuQ2FsbGVkID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBDYWxsTWV0aG9kO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuQ2FsbE1ldGhvZCA9IENhbGxNZXRob2Q7XHJcbiAgICB2YXIgUmVwZWF0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBSZXBlYXQoYWN0b3IsIHJlcGVhdCwgYWN0aW9ucykge1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yID0gYWN0b3I7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvblF1ZXVlID0gbmV3IEFjdGlvblF1ZXVlKGFjdG9yKTtcclxuICAgICAgICAgICAgdGhpcy5fcmVwZWF0ID0gcmVwZWF0O1xyXG4gICAgICAgICAgICB0aGlzLl9vcmlnaW5hbFJlcGVhdCA9IHJlcGVhdDtcclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSBhY3Rpb25zLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGFjdGlvbnNbaV0ucmVzZXQoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGlvblF1ZXVlLmFkZChhY3Rpb25zW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFJlcGVhdC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IHRoaXMuX2FjdG9yLnBvcy54O1xyXG4gICAgICAgICAgICB0aGlzLnkgPSB0aGlzLl9hY3Rvci5wb3MueTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9hY3Rpb25RdWV1ZS5oYXNOZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGlvblF1ZXVlLnJlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBlYXQtLTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25RdWV1ZS51cGRhdGUoZGVsdGEpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUmVwZWF0LnByb3RvdHlwZS5pc0NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZCB8fCAodGhpcy5fcmVwZWF0IDw9IDApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUmVwZWF0LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFJlcGVhdC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcGVhdCA9IHRoaXMuX29yaWdpbmFsUmVwZWF0O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFJlcGVhdDtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLlJlcGVhdCA9IFJlcGVhdDtcclxuICAgIHZhciBSZXBlYXRGb3JldmVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBSZXBlYXRGb3JldmVyKGFjdG9yLCBhY3Rpb25zKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IgPSBhY3RvcjtcclxuICAgICAgICAgICAgdGhpcy5fYWN0aW9uUXVldWUgPSBuZXcgQWN0aW9uUXVldWUoYWN0b3IpO1xyXG4gICAgICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IGFjdGlvbnMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgYWN0aW9uc1tpXS5yZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aW9uUXVldWUuYWRkKGFjdGlvbnNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDtcclxuICAgICAgICB9XHJcbiAgICAgICAgUmVwZWF0Rm9yZXZlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IHRoaXMuX2FjdG9yLnBvcy54O1xyXG4gICAgICAgICAgICB0aGlzLnkgPSB0aGlzLl9hY3Rvci5wb3MueTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3N0b3BwZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2FjdGlvblF1ZXVlLmhhc05leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aW9uUXVldWUucmVzZXQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25RdWV1ZS51cGRhdGUoZGVsdGEpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUmVwZWF0Rm9yZXZlci5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBSZXBlYXRGb3JldmVyLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fYWN0aW9uUXVldWUuY2xlYXJBY3Rpb25zKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBSZXBlYXRGb3JldmVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuOyB9O1xyXG4gICAgICAgIHJldHVybiBSZXBlYXRGb3JldmVyO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuUmVwZWF0Rm9yZXZlciA9IFJlcGVhdEZvcmV2ZXI7XHJcbiAgICAvKipcclxuICAgICAqIEFjdGlvbiBRdWV1ZXNcclxuICAgICAqXHJcbiAgICAgKiBBY3Rpb24gcXVldWVzIGFyZSBwYXJ0IG9mIHRoZSBbW0FjdGlvbkNvbnRleHR8QWN0aW9uIEFQSV1dIGFuZFxyXG4gICAgICogc3RvcmUgdGhlIGxpc3Qgb2YgYWN0aW9ucyB0byBiZSBleGVjdXRlZCBmb3IgYW4gW1tBY3Rvcl1dLlxyXG4gICAgICpcclxuICAgICAqIEFjdG9ycyBpbXBsZW1lbnQgW1tBY3Rvci5hY3Rpb25zXV0gd2hpY2ggY2FuIGJlIG1hbmlwdWxhdGVkIGJ5XHJcbiAgICAgKiBhZHZhbmNlZCB1c2VycyB0byBhZGp1c3QgdGhlIGFjdGlvbnMgY3VycmVudGx5IGJlaW5nIGV4ZWN1dGVkIGluIHRoZVxyXG4gICAgICogcXVldWUuXHJcbiAgICAgKi9cclxuICAgIHZhciBBY3Rpb25RdWV1ZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gQWN0aW9uUXVldWUoYWN0b3IpIHtcclxuICAgICAgICAgICAgdGhpcy5fYWN0aW9ucyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLl9jb21wbGV0ZWRBY3Rpb25zID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yID0gYWN0b3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEFjdGlvblF1ZXVlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbnMucHVzaChhY3Rpb24pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQWN0aW9uUXVldWUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fYWN0aW9ucy5pbmRleE9mKGFjdGlvbik7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEFjdGlvblF1ZXVlLnByb3RvdHlwZS5jbGVhckFjdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbnMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fY29tcGxldGVkQWN0aW9ucy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudEFjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudEFjdGlvbi5zdG9wKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEFjdGlvblF1ZXVlLnByb3RvdHlwZS5nZXRBY3Rpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWN0aW9ucy5jb25jYXQodGhpcy5fY29tcGxldGVkQWN0aW9ucyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBY3Rpb25RdWV1ZS5wcm90b3R5cGUuaGFzTmV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGlvbnMubGVuZ3RoID4gMDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEFjdGlvblF1ZXVlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fYWN0aW9ucyA9IHRoaXMuZ2V0QWN0aW9ucygpO1xyXG4gICAgICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX2FjdGlvbnMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aW9uc1tpXS5yZXNldCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbXBsZXRlZEFjdGlvbnMgPSBbXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEFjdGlvblF1ZXVlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2FjdGlvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudEFjdGlvbiA9IHRoaXMuX2FjdGlvbnNbMF07XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50QWN0aW9uLnVwZGF0ZShkZWx0YSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudEFjdGlvbi5pc0NvbXBsZXRlKHRoaXMuX2FjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbXBsZXRlZEFjdGlvbnMucHVzaCh0aGlzLl9hY3Rpb25zLnNoaWZ0KCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gQWN0aW9uUXVldWU7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5BY3Rpb25RdWV1ZSA9IEFjdGlvblF1ZXVlO1xyXG59KTtcclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICB3aW5kb3cgPSB7IGF1ZGlvQ29udGV4dDogZnVuY3Rpb24gKCkgeyByZXR1cm47IH0gfTtcclxufVxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcclxuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPVxyXG4gICAgICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcclxuICAgICAgICAgICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoY2FsbGJhY2spIHsgd2luZG93LnNldEludGVydmFsKGNhbGxiYWNrLCAxMDAwIC8gNjApOyB9O1xyXG59XHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKSB7XHJcbiAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPVxyXG4gICAgICAgIHdpbmRvdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZSB8fFxyXG4gICAgICAgICAgICB3aW5kb3cubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XHJcbn1cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICF3aW5kb3cuQXVkaW9Db250ZXh0KSB7XHJcbiAgICB3aW5kb3cuQXVkaW9Db250ZXh0ID0gd2luZG93LkF1ZGlvQ29udGV4dCB8fFxyXG4gICAgICAgIHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQgfHxcclxuICAgICAgICB3aW5kb3cubW96QXVkaW9Db250ZXh0IHx8XHJcbiAgICAgICAgd2luZG93Lm1zQXVkaW9Db250ZXh0IHx8XHJcbiAgICAgICAgd2luZG93Lm9BdWRpb0NvbnRleHQ7XHJcbn1cclxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICF3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbykge1xyXG4gICAgd2luZG93LmRldmljZVBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xyXG59XHJcbi8vIFBvbHlmaWxsIGZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZm9yRWFjaFxyXG4vLyBQcm9kdWN0aW9uIHN0ZXBzIG9mIEVDTUEtMjYyLCBFZGl0aW9uIDUsIDE1LjQuNC4xOFxyXG4vLyBSZWZlcmVuY2U6IGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuNC40LjE4XHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbmlmICghQXJyYXkucHJvdG90eXBlLmZvckVhY2gpIHtcclxuICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0aGlzQXJnKSB7XHJcbiAgICAgICAgdmFyIFQsIGs7XHJcbiAgICAgICAgaWYgKHRoaXMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0aGlzIGlzIG51bGwgb3Igbm90IGRlZmluZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gMS4gTGV0IE8gYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIFRvT2JqZWN0IHBhc3NpbmcgdGhlIHx0aGlzfCB2YWx1ZSBhcyB0aGUgYXJndW1lbnQuIFxyXG4gICAgICAgIHZhciBPID0gT2JqZWN0KHRoaXMpO1xyXG4gICAgICAgIC8vIDIuIExldCBsZW5WYWx1ZSBiZSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIEdldCBpbnRlcm5hbCBtZXRob2Qgb2YgTyB3aXRoIHRoZSBhcmd1bWVudCBcImxlbmd0aFwiLlxyXG4gICAgICAgIC8vIDMuIExldCBsZW4gYmUgVG9VaW50MzIobGVuVmFsdWUpLlxyXG4gICAgICAgIHZhciBsZW4gPSBPLmxlbmd0aCA+Pj4gMDtcclxuICAgICAgICAvLyA0LiBJZiBJc0NhbGxhYmxlKGNhbGxiYWNrKSBpcyBmYWxzZSwgdGhyb3cgYSBUeXBlRXJyb3IgZXhjZXB0aW9uLlxyXG4gICAgICAgIC8vIFNlZTogaHR0cDovL2VzNS5naXRodWIuY29tLyN4OS4xMVxyXG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjYWxsYmFjayArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNS4gSWYgdGhpc0FyZyB3YXMgc3VwcGxpZWQsIGxldCBUIGJlIHRoaXNBcmc7IGVsc2UgbGV0IFQgYmUgdW5kZWZpbmVkLlxyXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICBUID0gdGhpc0FyZztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNi4gTGV0IGsgYmUgMFxyXG4gICAgICAgIGsgPSAwO1xyXG4gICAgICAgIC8vIDcuIFJlcGVhdCwgd2hpbGUgayA8IGxlblxyXG4gICAgICAgIHdoaWxlIChrIDwgbGVuKSB7XHJcbiAgICAgICAgICAgIHZhciBrVmFsdWU7XHJcbiAgICAgICAgICAgIC8vIGEuIExldCBQayBiZSBUb1N0cmluZyhrKS5cclxuICAgICAgICAgICAgLy8gICBUaGlzIGlzIGltcGxpY2l0IGZvciBMSFMgb3BlcmFuZHMgb2YgdGhlIGluIG9wZXJhdG9yXHJcbiAgICAgICAgICAgIC8vIGIuIExldCBrUHJlc2VudCBiZSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIEhhc1Byb3BlcnR5IGludGVybmFsIG1ldGhvZCBvZiBPIHdpdGggYXJndW1lbnQgUGsuXHJcbiAgICAgICAgICAgIC8vICAgVGhpcyBzdGVwIGNhbiBiZSBjb21iaW5lZCB3aXRoIGNcclxuICAgICAgICAgICAgLy8gYy4gSWYga1ByZXNlbnQgaXMgdHJ1ZSwgdGhlblxyXG4gICAgICAgICAgICBpZiAoayBpbiBPKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpLiBMZXQga1ZhbHVlIGJlIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgR2V0IGludGVybmFsIG1ldGhvZCBvZiBPIHdpdGggYXJndW1lbnQgUGsuXHJcbiAgICAgICAgICAgICAgICBrVmFsdWUgPSBPW2tdO1xyXG4gICAgICAgICAgICAgICAgLy8gaWkuIENhbGwgdGhlIENhbGwgaW50ZXJuYWwgbWV0aG9kIG9mIGNhbGxiYWNrIHdpdGggVCBhcyB0aGUgdGhpcyB2YWx1ZSBhbmRcclxuICAgICAgICAgICAgICAgIC8vIGFyZ3VtZW50IGxpc3QgY29udGFpbmluZyBrVmFsdWUsIGssIGFuZCBPLlxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChULCBrVmFsdWUsIGssIE8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGQuIEluY3JlYXNlIGsgYnkgMS5cclxuICAgICAgICAgICAgaysrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA4LiByZXR1cm4gdW5kZWZpbmVkXHJcbiAgICB9O1xyXG59XHJcbi8vIFBvbHlmaWxsIGZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc29tZVxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5pZiAoIUFycmF5LnByb3RvdHlwZS5zb21lKSB7XHJcbiAgICBBcnJheS5wcm90b3R5cGUuc29tZSA9IGZ1bmN0aW9uIChmdW4gLyosIHRoaXNBcmcgKi8pIHtcclxuICAgICAgICAndXNlIHN0cmljdCc7XHJcbiAgICAgICAgaWYgKHRoaXMgPT09IHZvaWQgMCB8fCB0aGlzID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHQgPSBPYmplY3QodGhpcyk7XHJcbiAgICAgICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xyXG4gICAgICAgIGlmICh0eXBlb2YgZnVuICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRoaXNBcmcgPSBhcmd1bWVudHMubGVuZ3RoID49IDIgPyBhcmd1bWVudHNbMV0gOiB2b2lkIDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoaSBpbiB0ICYmIGZ1bi5jYWxsKHRoaXNBcmcsIHRbaV0sIGksIHQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG59XHJcbi8vIFBvbHlmaWxsIGZyb20gIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL2JpbmQjUG9seWZpbGxcclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuaWYgKCFGdW5jdGlvbi5wcm90b3R5cGUuYmluZCkge1xyXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAob1RoaXMpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgLy8gY2xvc2VzdCB0aGluZyBwb3NzaWJsZSB0byB0aGUgRUNNQVNjcmlwdCA1XHJcbiAgICAgICAgICAgIC8vIGludGVybmFsIElzQ2FsbGFibGUgZnVuY3Rpb25cclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgLSB3aGF0IGlzIHRyeWluZyB0byBiZSBib3VuZCBpcyBub3QgY2FsbGFibGUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGFBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSwgZlRvQmluZCA9IHRoaXMsIGZOT1AgPSBmdW5jdGlvbiAoKSB7IHJldHVybjsgfSwgZkJvdW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZlRvQmluZC5hcHBseSh0aGlzIGluc3RhbmNlb2YgZk5PUCAmJiBvVGhpc1xyXG4gICAgICAgICAgICAgICAgPyB0aGlzXHJcbiAgICAgICAgICAgICAgICA6IG9UaGlzLCBhQXJncy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgZk5PUC5wcm90b3R5cGUgPSB0aGlzLnByb3RvdHlwZTtcclxuICAgICAgICBmQm91bmQucHJvdG90eXBlID0gbmV3IGZOT1AoKTtcclxuICAgICAgICByZXR1cm4gZkJvdW5kO1xyXG4gICAgfTtcclxufVxyXG4gICAgLy9UaGUgbW9kdWxlcyBmb3IgeW91ciBwcm9qZWN0IHdpbGwgYmUgaW5saW5lZCBhYm92ZVxyXG4gICAgLy90aGlzIHNuaXBwZXQuIEFzayBhbG1vbmQgdG8gc3luY2hyb25vdXNseSByZXF1aXJlIHRoZVxyXG4gICAgLy9tb2R1bGUgdmFsdWUgZm9yICdtYWluJyBoZXJlIGFuZCByZXR1cm4gaXQgYXMgdGhlXHJcbiAgICAvL3ZhbHVlIHRvIHVzZSBmb3IgdGhlIHB1YmxpYyBBUEkgZm9yIHRoZSBidWlsdCBmaWxlLlxyXG4gICAgcmV0dXJuIHJlcXVpcmUoJ0luZGV4Jyk7XHJcbn0pKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhjYWxpYnVyLmpzLm1hcCIsImltcG9ydCAqIGFzIGV4IGZyb20gJ2V4Y2FsaWJ1cic7XHJcbmltcG9ydCB7IFJlc291cmNlIH0gZnJvbSAnLi4vLi4vcmVzb3VyY2UnO1xyXG5pbXBvcnQgeyBHYW1lU2V0dGluZ3MgfSBmcm9tICcuLi8uLi9nYW1lc2V0dGluZ3MnO1xyXG5pbXBvcnQgeyBHYW1lU2NlbmUgfSBmcm9tICcuLi8uLi9zY2VuZXMvZ2FtZVNjZW5lL2dhbWVzY2VuZSc7XHJcblxyXG5jb25zdCBvYmpTcHJpdGVzID0gW1Jlc291cmNlLkNoZW1pY2FsUGxhbnQsIFJlc291cmNlLlJhZGlvVG93ZXJdO1xyXG5cclxuY2xhc3MgQmFja2dyb3VuZE9iamVjdCBleHRlbmRzIGV4LkFjdG9yIHtcclxuICAgIHByb3RlY3RlZCBnYW1lU2NlbmU6IEdhbWVTY2VuZTtcclxuXHJcblxyXG4gICAgY29uc3RydWN0b3Ioc2NlbmU6IEdhbWVTY2VuZSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IDEuMSpHYW1lU2V0dGluZ3MuV0lEVEggKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBHYW1lU2V0dGluZ3MuQkdfVkFSSUFCSUxJVFkpO1xyXG4gICAgICAgIHRoaXMueSA9IEdhbWVTZXR0aW5ncy5IRUlHSFQgLSBHYW1lU2V0dGluZ3MuR1JPVU5EX0hFSUdIVDtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgcmFuZGkgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBvYmpTcHJpdGVzLmxlbmd0aCk7XHJcblxyXG4gICAgICAgIHRoaXMuYW5jaG9yLnNldFRvKDAsIDApO1xyXG5cclxuICAgICAgICB2YXIgc3ByaXRlID0gb2JqU3ByaXRlc1tyYW5kaV0uYXNTcHJpdGUoKTtcclxuICAgICAgICBzcHJpdGUuYW5jaG9yLnNldFRvKDAsIDEpO1xyXG4gICAgICAgIHRoaXMuYWRkRHJhd2luZyhzcHJpdGUpO1xyXG5cclxuICAgICAgICB0aGlzLnNldEhlaWdodChzcHJpdGUuaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLnNldFdpZHRoKHNwcml0ZS53aWR0aCk7XHJcblxyXG4gICAgICAgIHRoaXMuZ2FtZVNjZW5lID0gc2NlbmU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uSW5pdGlhbGl6ZShlbmdpbmU6IGV4LkVuZ2luZSkge1xyXG4gICAgICAgIC8vIGRvIHN0dWZmXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHVwZGF0ZShlbmdpbmU6IGV4LkVuZ2luZSwgZGVsdGE6IG51bWJlcikge1xyXG4gICAgICBzdXBlci51cGRhdGUoZW5naW5lLCBkZWx0YSk7IC8vIGNhbGwgYmFzZSB1cGRhdGUgbG9naWNcclxuXHJcbiAgICAgIGlmKHRoaXMuZ2FtZVNjZW5lLmdhbWVPdmVyIHx8ICF0aGlzLmdhbWVTY2VuZS5nYW1lU3RhcnRlZClcclxuICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIHRoaXMueCAtPSBHYW1lU2V0dGluZ3MuQkdfSFNQRUVEICogZGVsdGEvMTAwMDtcclxuXHJcbiAgICAgICAgaWYodGhpcy54IDwgLUdhbWVTZXR0aW5ncy5XSURUSC8yKSB7XHJcbiAgICAgICAgICAgIHRoaXMua2lsbCgpO1xyXG4gICAgICAgIH1cclxuICAgfVxyXG59XHJcblxyXG5leHBvcnQgeyBCYWNrZ3JvdW5kT2JqZWN0IH07IiwiaW1wb3J0ICogYXMgZXggZnJvbSAnZXhjYWxpYnVyJztcclxuaW1wb3J0IHsgUmVzb3VyY2UgfSBmcm9tICcuLi8uLi9yZXNvdXJjZSc7XHJcbmltcG9ydCB7IEdhbWVTZXR0aW5ncyB9IGZyb20gJy4uLy4uL2dhbWVzZXR0aW5ncyc7XHJcbmltcG9ydCB7IEdhbWVTY2VuZSB9IGZyb20gJy4uLy4uL3NjZW5lcy9nYW1lU2NlbmUvZ2FtZXNjZW5lJztcclxuXHJcbmNvbnN0IHBlc3RTcHJpdGVzID0gW1Jlc291cmNlLlJuZHAsIFJlc291cmNlLlNtcnR4LCBSZXNvdXJjZS5JbnNjdFdhc3AsIFJlc291cmNlLkNob2dvXTtcclxuXHJcbmNsYXNzIFBlc3RpY2lkZSBleHRlbmRzIGV4LkFjdG9yIHtcclxuICAgIHByb3RlY3RlZCB0b3BQYXJ0OiBleC5BY3RvcjtcclxuICAgIHByb3RlY3RlZCBib3R0b21QYXJ0OiBleC5BY3RvcjtcclxuICAgIHByb3RlY3RlZCBnYW1lU2NlbmU6IEdhbWVTY2VuZTtcclxuICAgIHByb3RlY3RlZCBwYXNzZWQ6IGJvb2xlYW47XHJcblxyXG4gICAgY29uc3RydWN0b3IoeGk6IG51bWJlciwgeWk6IG51bWJlciwgeVNwYWNlOiBudW1iZXIsIHNjZW5lOiBHYW1lU2NlbmUpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG5cclxuICAgICAgICB0aGlzLnggPSB4aTtcclxuICAgICAgICB0aGlzLnNldFdpZHRoKDAuOCpHYW1lU2V0dGluZ3MuUEVTVF9XSURUSCk7XHJcbiAgICAgICAgdGhpcy5zZXRIZWlnaHQoeVNwYWNlICsgMiAqIEdhbWVTZXR0aW5ncy5QRVNUX0hFSUdIVCk7XHJcblxyXG4gICAgICAgIHZhciByYW5kaTtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIHJhbmRpID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcGVzdFNwcml0ZXMubGVuZ3RoKTtcclxuICAgICAgICB9IHdoaWxlKHJhbmRpID09IHNjZW5lLmxhc3RQZXN0KTtcclxuICAgICAgICBzY2VuZS5sYXN0UGVzdCA9IHJhbmRpO1xyXG5cclxuICAgICAgICB0aGlzLnRvcFBhcnQgPSBuZXcgZXguQWN0b3IoKTtcclxuICAgICAgICB2YXIgdG9wU3ByaXRlID0gbmV3IGV4LlNwcml0ZShwZXN0U3ByaXRlc1tyYW5kaV0sIDAsIDAsIEdhbWVTZXR0aW5ncy5QRVNUX1dJRFRILCBHYW1lU2V0dGluZ3MuUEVTVF9IRUlHSFQpO1xyXG4gICAgICAgIHRvcFNwcml0ZS5mbGlwVmVydGljYWwgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMudG9wUGFydC5hZGREcmF3aW5nKHRvcFNwcml0ZSk7XHJcbiAgICAgICAgdGhpcy50b3BQYXJ0LnggPSAwO1xyXG4gICAgICAgIHRoaXMudG9wUGFydC55ID0geWkgLSAoR2FtZVNldHRpbmdzLlBFU1RfSEVJR0hUICsgeVNwYWNlKSAvIDI7XHJcbiAgICAgICAgdGhpcy50b3BQYXJ0LnNldFdpZHRoKEdhbWVTZXR0aW5ncy5QRVNUX1dJRFRIKTtcclxuICAgICAgICB0aGlzLnRvcFBhcnQuc2V0SGVpZ2h0KEdhbWVTZXR0aW5ncy5QRVNUX0hFSUdIVCk7XHJcbiAgICAgICAgdGhpcy5hZGQodGhpcy50b3BQYXJ0KTtcclxuXHJcbiAgICAgICAgdGhpcy5ib3R0b21QYXJ0ID0gbmV3IGV4LkFjdG9yKCk7XHJcbiAgICAgICAgdmFyIGJvdHRvbVNwcml0ZSA9IG5ldyBleC5TcHJpdGUocGVzdFNwcml0ZXNbcmFuZGldLCAwLCAwLCBHYW1lU2V0dGluZ3MuUEVTVF9XSURUSCwgR2FtZVNldHRpbmdzLlBFU1RfSEVJR0hUKTtcclxuICAgICAgICAvL2JvdHRvbVNwcml0ZS5mbGlwVmVydGljYWwgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmJvdHRvbVBhcnQuYWRkRHJhd2luZyhib3R0b21TcHJpdGUpO1xyXG4gICAgICAgIHRoaXMuYm90dG9tUGFydC54ID0gMDtcclxuICAgICAgICB0aGlzLmJvdHRvbVBhcnQueSA9IHlpICsgKEdhbWVTZXR0aW5ncy5QRVNUX0hFSUdIVCArIHlTcGFjZSkgLyAyO1xyXG4gICAgICAgIHRoaXMuYm90dG9tUGFydC5zZXRXaWR0aChHYW1lU2V0dGluZ3MuUEVTVF9XSURUSCk7XHJcbiAgICAgICAgdGhpcy5ib3R0b21QYXJ0LnNldEhlaWdodChHYW1lU2V0dGluZ3MuUEVTVF9IRUlHSFQpO1xyXG4gICAgICAgIHRoaXMuYWRkKHRoaXMuYm90dG9tUGFydCk7XHJcblxyXG4gICAgICAgIHRoaXMuZ2FtZVNjZW5lID0gc2NlbmU7XHJcbiAgICAgICAgdGhpcy5wYXNzZWQgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25Jbml0aWFsaXplKGVuZ2luZTogZXguRW5naW5lKSB7XHJcbiAgICAgICAgLy8gZG8gc3R1ZmZcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdXBkYXRlKGVuZ2luZTogZXguRW5naW5lLCBkZWx0YTogbnVtYmVyKSB7XHJcbiAgICAgIHN1cGVyLnVwZGF0ZShlbmdpbmUsIGRlbHRhKTsgLy8gY2FsbCBiYXNlIHVwZGF0ZSBsb2dpY1xyXG5cclxuICAgICAgaWYodGhpcy5nYW1lU2NlbmUuZ2FtZU92ZXIgfHwgIXRoaXMuZ2FtZVNjZW5lLmdhbWVTdGFydGVkKVxyXG4gICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgdGhpcy54IC09IEdhbWVTZXR0aW5ncy5IU1BFRUQgKiBkZWx0YS8xMDAwO1xyXG5cclxuICAgICAgaWYodGhpcy50b3BQYXJ0LmNvbGxpZGVzKHRoaXMuZ2FtZVNjZW5lLnBsYXllcikgIT0gbnVsbCB8fCB0aGlzLmJvdHRvbVBhcnQuY29sbGlkZXModGhpcy5nYW1lU2NlbmUucGxheWVyKSAhPSBudWxsKVxyXG4gICAgICAgICB0aGlzLmdhbWVTY2VuZS5zZXRHYW1lT3ZlcigpO1xyXG5cclxuICAgICAgaWYodGhpcy54IDwgR2FtZVNldHRpbmdzLlBFU1RfV0lEVEgvMikge1xyXG4gICAgICAgICAgaWYoIXRoaXMucGFzc2VkKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5wYXNzZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgIHRoaXMuZ2FtZVNjZW5lLnNjb3JlKys7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYodGhpcy54IDwgLUdhbWVTZXR0aW5ncy5QRVNUX1dJRFRILzIpIHtcclxuICAgICAgICAgICAgICB0aGlzLmtpbGwoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICB9XHJcbn1cclxuXHJcbmV4cG9ydCB7IFBlc3RpY2lkZSB9OyIsImltcG9ydCAqIGFzIGV4IGZyb20gJ2V4Y2FsaWJ1cic7XHJcbmltcG9ydCB7IFJlc291cmNlIH0gZnJvbSAnLi4vLi4vcmVzb3VyY2UnO1xyXG5pbXBvcnQgeyBHYW1lU2V0dGluZ3MgfSBmcm9tICcuLi8uLi9nYW1lc2V0dGluZ3MnO1xyXG5pbXBvcnQgeyBHYW1lU2NlbmUgfSBmcm9tICcuLi8uLi9zY2VuZXMvZ2FtZVNjZW5lL2dhbWVzY2VuZSc7XHJcblxyXG5jbGFzcyBQbGF5ZXIgZXh0ZW5kcyBleC5BY3RvciB7XHJcbiAgICBwdWJsaWMgeXBvczogbnVtYmVyO1xyXG4gICAgcHVibGljIHlzcGVlZDogbnVtYmVyO1xyXG4gICAgcHVibGljIHlhY2M6IG51bWJlcjtcclxuICAgIHByb3RlY3RlZCBwcmVzc2VkOiBib29sZWFuO1xyXG4gICAgcHVibGljIGZsYXBBbmltYXRpb246IGV4LkFuaW1hdGlvbjtcclxuICAgIC8vcHJpdmF0ZSBnYW1lU3RhcnRlZDogYm9vbGVhbjtcclxuICAgIHByb3RlY3RlZCBnYW1lU2NlbmU6IEdhbWVTY2VuZTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihzY2VuZTogR2FtZVNjZW5lKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy5zZXRXaWR0aCg0Mik7XHJcbiAgICAgICAgdGhpcy5zZXRIZWlnaHQoMzIpO1xyXG4gICAgICAgIHRoaXMueCA9IDEwMDtcclxuXHJcbiAgICAgICAgdGhpcy55cG9zID0gR2FtZVNldHRpbmdzLkhFSUdIVC8yO1xyXG4gICAgICAgIHRoaXMueXNwZWVkID0gMDtcclxuICAgICAgICB0aGlzLnlhY2MgPSBHYW1lU2V0dGluZ3MuR1JBVklUWTtcclxuICAgICAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnkgPSB0aGlzLnlwb3M7XHJcblxyXG4gICAgICAgIC8vdGhpcy5nYW1lU3RhcnRlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICB0aGlzLmdhbWVTY2VuZSA9IHNjZW5lO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvbkluaXRpYWxpemUoZW5naW5lOiBleC5FbmdpbmUpIHtcclxuICAgICAgICB0aGlzLmFkZERyYXdpbmcoXCJpZGxlXCIsIG5ldyBleC5TcHJpdGUoUmVzb3VyY2UuVHhQbGF5ZXIsIDAsIDAsIDY0LCA2NCkpO1xyXG4gICAgICAgIHRoaXMuc2V0RHJhd2luZyhcImlkbGVcIik7XHJcblxyXG4gICAgICAgIGNvbnN0IHBsYXllcklkbGVTaGVldCA9IG5ldyBleC5TcHJpdGVTaGVldChSZXNvdXJjZS5UeFBsYXllciwgMTYsIDEsIDY0LCA2NCk7XHJcbiAgICAgICAgdGhpcy5mbGFwQW5pbWF0aW9uID0gcGxheWVySWRsZVNoZWV0LmdldEFuaW1hdGlvbkJldHdlZW4oZW5naW5lLCAxLCAxNiwgMyk7XHJcbiAgICAgICAgdGhpcy5mbGFwQW5pbWF0aW9uLmxvb3AgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmFkZERyYXdpbmcoXCJmbGFwXCIsIHRoaXMuZmxhcEFuaW1hdGlvbik7XHJcblxyXG4gICAgICAgIGVuZ2luZS5pbnB1dC5wb2ludGVycy5wcmltYXJ5Lm9uKFwiZG93blwiLCB0aGlzLm9uUHJlc3MpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvblByZXNzID0gKCkgPT4ge1xyXG4gICAgICAgIC8vdGhpcy5nYW1lU3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5wcmVzc2VkID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVzZXQgPSAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy55cG9zID0gR2FtZVNldHRpbmdzLkhFSUdIVC8yO1xyXG4gICAgICAgIHRoaXMueXNwZWVkID0gMDtcclxuICAgICAgICB0aGlzLnlhY2MgPSBHYW1lU2V0dGluZ3MuR1JBVklUWTtcclxuICAgICAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnkgPSB0aGlzLnlwb3M7XHJcbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IDA7XHJcblxyXG4gICAgICAgIC8vdGhpcy5nYW1lU3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB1cGRhdGUoZW5naW5lOiBleC5FbmdpbmUsIGRlbHRhOiBudW1iZXIpIHtcclxuICAgICAgc3VwZXIudXBkYXRlKGVuZ2luZSwgZGVsdGEpOyAvLyBjYWxsIGJhc2UgdXBkYXRlIGxvZ2ljXHJcblxyXG4gICAgICBpZih0aGlzLmdhbWVTY2VuZS5nYW1lT3ZlciB8fCAhdGhpcy5nYW1lU2NlbmUuZ2FtZVN0YXJ0ZWQpXHJcbiAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBpZih0aGlzLnByZXNzZWQpIHtcclxuICAgICAgICAgIHRoaXMueXNwZWVkID0gR2FtZVNldHRpbmdzLkZPUkNFO1xyXG4gICAgICAgICAgdGhpcy5zZXREcmF3aW5nKFwiZmxhcFwiKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlXHJcbiAgICAgICAgICB0aGlzLnlzcGVlZCA9IEdhbWVTZXR0aW5ncy5HUkFWSVRZICsgKHRoaXMueXNwZWVkIC0gR2FtZVNldHRpbmdzLkdSQVZJVFkpICogKE1hdGguZXhwKC1kZWx0YS8oMTAwMCpHYW1lU2V0dGluZ3MuSU5FUlRJQSkpKTtcclxuXHJcbiAgICAgIHRoaXMueXBvcyArPSB0aGlzLnlzcGVlZCAqIGRlbHRhLzEwMDA7XHJcbiAgICAgIHRoaXMueSA9IHRoaXMueXBvcztcclxuICAgICAgLy90aGlzLnJvdGF0aW9uID0gTWF0aC5tYXgoLTAuMywgTWF0aC5taW4oMC4zLCBNYXRoLmF0YW4yKHRoaXMueXNwZWVkLCBHYW1lU2V0dGluZ3MuSFNQRUVEKS8yKSk7XHJcbiAgICAgIHRoaXMucm90YXRpb24gPSB0aGlzLnlzcGVlZCA8IDMwMCA/IC0wLjMgOiAodGhpcy55c3BlZWQgPiA2MDAgPyAwLjMgOiAtMC45ICsgMC4wMDIgKiB0aGlzLnlzcGVlZCk7XHJcblxyXG4gICAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgIGlmKHRoaXMuZmxhcEFuaW1hdGlvbi5pc0RvbmUoKSlcclxuICAgICAgICAgIHRoaXMuc2V0RHJhd2luZyhcImlkbGVcIik7XHJcblxyXG5cclxuICAgICAgaWYodGhpcy5jb2xsaWRlcyh0aGlzLmdhbWVTY2VuZS5ncm91bmQpICE9IG51bGwpXHJcbiAgICAgICAgIHRoaXMuZ2FtZVNjZW5lLnNldEdhbWVPdmVyKCk7XHJcbiAgIH1cclxufVxyXG5cclxuZXhwb3J0IHsgUGxheWVyIH07IiwiZXhwb3J0IG5hbWVzcGFjZSBDb21tdW5pY2F0aW9uIHtcclxuICAgIGV4cG9ydCBmdW5jdGlvbiBsb2FkUmVxdWVzdCAoKSB7XHJcbiAgICAgICAgdmFyIG1zZyA9IHsgbWVzc2FnZVR5cGU6IFwiTE9BRF9SRVFVRVNUXCIgfTtcclxuICAgICAgICB3aW5kb3cucGFyZW50LnBvc3RNZXNzYWdlKG1zZywgXCIqXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGV4cG9ydCBmdW5jdGlvbiBwb3N0U2NvcmUgKG5ld1Njb3JlOiBudW1iZXIpIHtcclxuICAgICAgICB2YXIgbXNnID0ge21lc3NhZ2VUeXBlOiBcIlNDT1JFXCIsIHNjb3JlOiBuZXdTY29yZX07XHJcbiAgICAgICAgd2luZG93LnBhcmVudC5wb3N0TWVzc2FnZShtc2csIFwiKlwiKTtcclxuICAgIH1cclxuXHJcbiAgICBleHBvcnQgZnVuY3Rpb24gcG9zdFNldHRpbmdzICh3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcikge1xyXG4gICAgICAgIHZhciBtc2cgPSB7bWVzc2FnZVR5cGU6IFwiU0VUVElOR1wiLCBvcHRpb25zOiB7XCJ3aWR0aFwiOiB3aWR0aCwgXCJoZWlnaHRcIjogaGVpZ2h0fX07XHJcbiAgICAgICAgd2luZG93LnBhcmVudC5wb3N0TWVzc2FnZShtc2csIFwiKlwiKTtcclxuICAgIH1cclxuXHJcbiAgICBleHBvcnQgZnVuY3Rpb24gcG9zdEdhbWVTdGF0ZSAoaGlnaFNjb3JlOiBudW1iZXIpIHtcclxuICAgICAgICB2YXIgbXNnID0geyBtZXNzYWdlVHlwZTogXCJTQVZFXCIsIGdhbWVTdGF0ZTogeyBiZXN0U2NvcmU6IGhpZ2hTY29yZSB9IH07XHJcbiAgICAgICAgd2luZG93LnBhcmVudC5wb3N0TWVzc2FnZShtc2csIFwiKlwiKTtcclxuICAgIH1cclxufSIsImV4cG9ydCBuYW1lc3BhY2UgR2FtZVNldHRpbmdzIHtcclxuICAgIGV4cG9ydCBjb25zdCBXSURUSCA9IDgwMDtcclxuICAgIGV4cG9ydCBjb25zdCBIRUlHSFQgPSA2MDA7XHJcblxyXG4gICAgZXhwb3J0IGNvbnN0IEdSQVZJVFkgPSA4MDA7XHJcbiAgICBleHBvcnQgY29uc3QgRk9SQ0UgPSAtODAwO1xyXG4gICAgZXhwb3J0IGNvbnN0IElORVJUSUEgPSAwLjM7XHJcbiAgICBleHBvcnQgY29uc3QgSFNQRUVEID0gMjAwO1xyXG5cclxuICAgIGV4cG9ydCBjb25zdCBUSU1FX0lOVEVSVkFMID0gMS41O1xyXG4gICAgZXhwb3J0IGNvbnN0IFZBUklBQklMSVRZID0gMTAwO1xyXG4gICAgZXhwb3J0IGNvbnN0IE1BWF9TUEFDRSA9IDE4MDtcclxuICAgIGV4cG9ydCBjb25zdCBNSU5fU1BBQ0UgPSAxMDA7XHJcbiAgICBleHBvcnQgY29uc3QgU0NPUkVfTUFYX0RJRkYgPSAxMDA7XHJcbiAgICBleHBvcnQgY29uc3QgU1RBUlRfVl9MSU1JVCA9IDAuMjtcclxuICAgIGV4cG9ydCBjb25zdCBFTkRfVl9MSU1JVCA9IDE7XHJcblxyXG4gICAgZXhwb3J0IGNvbnN0IEJHX1RJTUVfSU5URVJWQUwgPSAzMDtcclxuICAgIGV4cG9ydCBjb25zdCBCR19IU1BFRUQgPSA4MDtcclxuICAgIGV4cG9ydCBjb25zdCBCR19WQVJJQUJJTElUWSA9IDMwMDtcclxuXHJcbiAgICBleHBvcnQgY29uc3QgR1JPVU5EX0hFSUdIVCA9IDY0O1xyXG4gICAgZXhwb3J0IGNvbnN0IFBFU1RfSEVJR0hUID0gNTEyO1xyXG4gICAgZXhwb3J0IGNvbnN0IFBFU1RfV0lEVEggPSA2NDtcclxufSIsImltcG9ydCAqIGFzIGV4IGZyb20gJ2V4Y2FsaWJ1cic7XHJcbmltcG9ydCB7IEdhbWVTY2VuZSB9IGZyb20gJy4vc2NlbmVzL2dhbWVTY2VuZS9nYW1lc2NlbmUnO1xyXG5pbXBvcnQgeyBQbGF5ZXIgfSBmcm9tICcuL2FjdG9ycy9wbGF5ZXIvcGxheWVyJztcclxuaW1wb3J0IHsgUmVzb3VyY2UgfSBmcm9tICcuL3Jlc291cmNlJztcclxuaW1wb3J0IHsgR2FtZVNldHRpbmdzIH0gZnJvbSAnLi9nYW1lc2V0dGluZ3MnO1xyXG5pbXBvcnQgeyBDb21tdW5pY2F0aW9uIH0gZnJvbSAnLi9jb21tdW5pY2F0aW9uJztcclxuXHJcbmNsYXNzIEdhbWUgZXh0ZW5kcyBleC5FbmdpbmUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoeyB3aWR0aDogR2FtZVNldHRpbmdzLldJRFRILFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBHYW1lU2V0dGluZ3MuSEVJR0hULFxyXG4gICAgICAgICAgICAgICAgZGlzcGxheU1vZGU6IGV4LkRpc3BsYXlNb2RlLkZpeGVkLFxyXG4gICAgICAgICAgICAgICAgcG9pbnRlclNjb3BlOiBleC5JbnB1dC5Qb2ludGVyU2NvcGUuQ2FudmFzIH0pO1xyXG4gICAgICAgIENvbW11bmljYXRpb24ucG9zdFNldHRpbmdzKEdhbWVTZXR0aW5ncy5XSURUSCwgR2FtZVNldHRpbmdzLkhFSUdIVCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXJ0KGxvYWRlcj86IGV4LklMb2FkZXIpIHtcclxuICAgICAgICByZXR1cm4gc3VwZXIuc3RhcnQobG9hZGVyKTtcclxuICAgIH1cclxufVxyXG5cclxudmFyIGxvYWRlciA9IG5ldyBleC5Mb2FkZXIoKTtcclxuZm9yKHZhciByZXNvdXJjZSBpbiBSZXNvdXJjZSl7XHJcbiAgICBsb2FkZXIuYWRkUmVzb3VyY2UoUmVzb3VyY2VbcmVzb3VyY2VdKTtcclxufVxyXG5cclxuY29uc3QgZ2FtZSA9IG5ldyBHYW1lKCk7XHJcbmNvbnN0IGdhbWVTY2VuZSA9IG5ldyBHYW1lU2NlbmUoKTtcclxuXHJcbmdhbWUuYWRkKCdnYW1lU2NlbmUnLCBnYW1lU2NlbmUpO1xyXG5cclxuZ2FtZS5zdGFydChsb2FkZXIpLnRoZW4oKCkgPT4ge1xyXG4gICAgZ2FtZS5nb1RvU2NlbmUoJ2dhbWVTY2VuZScpO1xyXG59KTtcclxuIiwiaW1wb3J0ICogYXMgZXggZnJvbSAnZXhjYWxpYnVyJztcclxuXHJcbi8vIEltYWdlIGFuZCBzb3VuZCByZXNvdXJjZXMgdG8gYmUgbG9hZGVkXHJcbnZhciBSZXNvdXJjZSA9IHtcclxuXHRCYWNrZ3JvdW5kOiBuZXcgZXguVGV4dHVyZShcImFzc2V0cy9iYWNrZ3JvdW5kLnBuZ1wiKSxcclxuXHJcbiAgICBUeFBsYXllcjogbmV3IGV4LlRleHR1cmUoXCJhc3NldHMvYmVlLnBuZ1wiKSxcclxuICAgIEdyb3VuZDogbmV3IGV4LlRleHR1cmUoXCJhc3NldHMvZ3JvdW5kLnBuZ1wiKSxcclxuXHJcbiAgICBSbmRwOiBuZXcgZXguVGV4dHVyZShcImFzc2V0cy9ybmRwLnBuZ1wiKSxcclxuICAgIFNtcnR4OiBuZXcgZXguVGV4dHVyZShcImFzc2V0cy9zbXJ0eC5wbmdcIiksXHJcbiAgICBJbnNjdFdhc3A6IG5ldyBleC5UZXh0dXJlKFwiYXNzZXRzL2luc2N0X3dhc3AucG5nXCIpLFxyXG4gICAgQ2hvZ286IG5ldyBleC5UZXh0dXJlKFwiYXNzZXRzL2Nob2dvLnBuZ1wiKSxcclxuXHJcbiAgICBDaGVtaWNhbFBsYW50OiBuZXcgZXguVGV4dHVyZShcImFzc2V0cy9jaGVtaWNhbF9wbGFudC5wbmdcIiksXHJcbiAgICBSYWRpb1Rvd2VyOiBuZXcgZXguVGV4dHVyZShcImFzc2V0cy9yYWRpb190b3dlci5wbmdcIilcclxufVxyXG5cclxuZXhwb3J0IHsgUmVzb3VyY2UgfTsiLCJpbXBvcnQgKiBhcyBleCBmcm9tICdleGNhbGlidXInO1xyXG5pbXBvcnQgeyBSZXNvdXJjZSB9IGZyb20gJy4uLy4uL3Jlc291cmNlJztcclxuaW1wb3J0IHsgUGxheWVyIH0gZnJvbSAnLi4vLi4vYWN0b3JzL3BsYXllci9wbGF5ZXInO1xyXG5pbXBvcnQgeyBQZXN0aWNpZGUgfSBmcm9tICcuLi8uLi9hY3RvcnMvb2JzdGFjbGVzL3Blc3RpY2lkZSc7XHJcbmltcG9ydCB7IEJhY2tncm91bmRPYmplY3QgfSBmcm9tICcuLi8uLi9hY3RvcnMvZGVjb3IvYmFja2dyb3VuZE9iamVjdCc7XHJcbmltcG9ydCB7IEdhbWVTZXR0aW5ncyB9IGZyb20gJy4uLy4uL2dhbWVzZXR0aW5ncyc7XHJcbmltcG9ydCB7IENvbW11bmljYXRpb24gfSBmcm9tICcuLi8uLi9jb21tdW5pY2F0aW9uJztcclxuLy9pbXBvcnQgeyBJbnB1dCB9IGZyb20gJ2V4Y2FsaWJ1cic7XHJcblxyXG5cclxuY2xhc3MgR2FtZVNjZW5lIGV4dGVuZHMgZXguU2NlbmUge1xyXG4gICAgcHVibGljIHNjb3JlOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgYmVzdFNjb3JlOiBudW1iZXI7XHJcblxyXG4gICAgcHVibGljIHBsYXllcjogUGxheWVyO1xyXG4gICAgcHJvdGVjdGVkIGNlbnRlckxhYmVsOiBleC5MYWJlbDtcclxuICAgIHByb3RlY3RlZCByZXN0YXJ0TGFiZWw6IGV4LkxhYmVsO1xyXG4gICAgcHJvdGVjdGVkIHNjb3JlTGFiZWw6IGV4LkxhYmVsO1xyXG4gICAgcHJvdGVjdGVkIGJlc3RTY29yZUxhYmVsOiBleC5MYWJlbDtcclxuXHJcbiAgICBwcm90ZWN0ZWQgbGFzdE9ic3RhY2xlVGltZTogbnVtYmVyO1xyXG4gICAgcHJvdGVjdGVkIGxhc3RPYnN0YWNsZVk6IG51bWJlcjtcclxuICAgIHB1YmxpYyBsYXN0UGVzdDogbnVtYmVyO1xyXG4gICAgcHJvdGVjdGVkIGxhc3RCYWNrZ3JvdW5kVGltZTogbnVtYmVyO1xyXG5cclxuICAgIHB1YmxpYyBnYW1lU3RhcnRlZDogYm9vbGVhbjtcclxuICAgIHB1YmxpYyBnYW1lT3ZlcjogYm9vbGVhbjtcclxuICAgIHB1YmxpYyByZXNldFNjZW5lOiBib29sZWFuO1xyXG4gICAgcHVibGljIGNhblJlc3RhcnQ6IGJvb2xlYW47XHJcblxyXG4gICAgcHVibGljIGdyb3VuZDogZXguQWN0b3I7XHJcblxyXG4gICAgcHVibGljIG9uSW5pdGlhbGl6ZShlbmdpbmU6IGV4LkVuZ2luZSkge1xyXG4gICAgICAgIHRoaXMuc2NvcmUgPSAwO1xyXG4gICAgICAgIHRoaXMuYmVzdFNjb3JlID0gMDtcclxuXHJcbiAgICAgICAgdmFyIGJhY2tncm91bmQgPSBuZXcgZXguQWN0b3IoKTtcclxuICAgICAgICBiYWNrZ3JvdW5kLmFkZERyYXdpbmcoUmVzb3VyY2UuQmFja2dyb3VuZC5hc1Nwcml0ZSgpKTtcclxuICAgICAgICB0aGlzLmFkZChiYWNrZ3JvdW5kKTtcclxuICAgICAgICBiYWNrZ3JvdW5kLnggPSBHYW1lU2V0dGluZ3MuV0lEVEgvMjtcclxuICAgICAgICBiYWNrZ3JvdW5kLnkgPSBHYW1lU2V0dGluZ3MuSEVJR0hULzI7XHJcbiAgICAgICAgYmFja2dyb3VuZC56ID0gLTEwO1xyXG5cclxuICAgICAgICB0aGlzLnBsYXllciA9IG5ldyBQbGF5ZXIodGhpcyk7XHJcbiAgICAgICAgdGhpcy5hZGQodGhpcy5wbGF5ZXIpO1xyXG4gICAgICAgIHRoaXMucGxheWVyLnogPSA3O1xyXG5cclxuICAgICAgICB0aGlzLmxhc3RPYnN0YWNsZVRpbWUgPSBHYW1lU2V0dGluZ3MuVElNRV9JTlRFUlZBTDtcclxuICAgICAgICB0aGlzLmxhc3RPYnN0YWNsZVkgPSBHYW1lU2V0dGluZ3MuSEVJR0hULzI7XHJcbiAgICAgICAgdGhpcy5sYXN0UGVzdCA9IC0xO1xyXG4gICAgICAgIHRoaXMubGFzdEJhY2tncm91bmRUaW1lID0gR2FtZVNldHRpbmdzLkJHX1RJTUVfSU5URVJWQUw7XHJcblxyXG4gICAgICAgIHRoaXMuY2VudGVyTGFiZWwgPSBuZXcgZXguTGFiZWwoXCJDbGljayB0byBzdGFydCBmbGFwcGluZy5cIiwgR2FtZVNldHRpbmdzLldJRFRILzIsIEdhbWVTZXR0aW5ncy5IRUlHSFQvMiwgXCJBcmlhbFwiKTtcclxuICAgICAgICB0aGlzLmNlbnRlckxhYmVsLnRleHRBbGlnbiA9IGV4LlRleHRBbGlnbi5DZW50ZXI7XHJcbiAgICAgICAgdGhpcy5jZW50ZXJMYWJlbC5iYXNlQWxpZ24gPSBleC5CYXNlQWxpZ24uTWlkZGxlO1xyXG4gICAgICAgIHRoaXMuY2VudGVyTGFiZWwuZm9udFNpemUgPSA0MjtcclxuICAgICAgICB0aGlzLmNlbnRlckxhYmVsLmNvbG9yID0gZXguQ29sb3IuV2hpdGU7XHJcbiAgICAgICAgdGhpcy5hZGQodGhpcy5jZW50ZXJMYWJlbCk7XHJcbiAgICAgICAgdGhpcy5jZW50ZXJMYWJlbC56ID0gMTA7XHJcblxyXG4gICAgICAgIHRoaXMucmVzdGFydExhYmVsID0gbmV3IGV4LkxhYmVsKFwiY2xpY2sgdG8gcmVzdGFydFwiLCBHYW1lU2V0dGluZ3MuV0lEVEgvMiwgR2FtZVNldHRpbmdzLkhFSUdIVC8yICsgMzIsIFwiQXJpYWxcIik7XHJcbiAgICAgICAgdGhpcy5yZXN0YXJ0TGFiZWwudGV4dEFsaWduID0gZXguVGV4dEFsaWduLkNlbnRlcjtcclxuICAgICAgICB0aGlzLnJlc3RhcnRMYWJlbC5iYXNlQWxpZ24gPSBleC5CYXNlQWxpZ24uVG9wO1xyXG4gICAgICAgIHRoaXMucmVzdGFydExhYmVsLmZvbnRTaXplID0gMjg7XHJcbiAgICAgICAgdGhpcy5yZXN0YXJ0TGFiZWwuY29sb3IgPSBleC5Db2xvci5XaGl0ZTtcclxuICAgICAgICB0aGlzLmFkZCh0aGlzLnJlc3RhcnRMYWJlbCk7XHJcbiAgICAgICAgdGhpcy5yZXN0YXJ0TGFiZWwueiA9IDEwO1xyXG4gICAgICAgIHRoaXMucmVzdGFydExhYmVsLnZpc2libGUgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdGhpcy5zY29yZUxhYmVsID0gbmV3IGV4LkxhYmVsKFwiMFwiLCAzMiwgMzIsIFwiQXJpYWxcIik7XHJcbiAgICAgICAgdGhpcy5zY29yZUxhYmVsLnRleHRBbGlnbiA9IGV4LlRleHRBbGlnbi5MZWZ0O1xyXG4gICAgICAgIHRoaXMuc2NvcmVMYWJlbC5iYXNlQWxpZ24gPSBleC5CYXNlQWxpZ24uVG9wO1xyXG4gICAgICAgIHRoaXMuc2NvcmVMYWJlbC5mb250U2l6ZSA9IDQyO1xyXG4gICAgICAgIHRoaXMuc2NvcmVMYWJlbC5jb2xvciA9IGV4LkNvbG9yLldoaXRlO1xyXG4gICAgICAgIHRoaXMuYWRkKHRoaXMuc2NvcmVMYWJlbCk7XHJcbiAgICAgICAgdGhpcy5zY29yZUxhYmVsLnogPSAxMDtcclxuXHJcbiAgICAgICAgdGhpcy5iZXN0U2NvcmVMYWJlbCA9IG5ldyBleC5MYWJlbChcIkJlc3Q6IDBcIiwgR2FtZVNldHRpbmdzLldJRFRILTMyLCAzMiwgXCJBcmlhbFwiKTtcclxuICAgICAgICB0aGlzLmJlc3RTY29yZUxhYmVsLnRleHRBbGlnbiA9IGV4LlRleHRBbGlnbi5SaWdodDtcclxuICAgICAgICB0aGlzLmJlc3RTY29yZUxhYmVsLmJhc2VBbGlnbiA9IGV4LkJhc2VBbGlnbi5Ub3A7XHJcbiAgICAgICAgdGhpcy5iZXN0U2NvcmVMYWJlbC5mb250U2l6ZSA9IDQyO1xyXG4gICAgICAgIHRoaXMuYmVzdFNjb3JlTGFiZWwuY29sb3IgPSBleC5Db2xvci5XaGl0ZTtcclxuICAgICAgICB0aGlzLmFkZCh0aGlzLmJlc3RTY29yZUxhYmVsKTtcclxuICAgICAgICB0aGlzLmJlc3RTY29yZUxhYmVsLnogPSAxMDtcclxuXHJcbiAgICAgICAgdGhpcy5nYW1lU3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZ2FtZU92ZXIgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnJlc2V0U2NlbmUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNhblJlc3RhcnQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdGhpcy5ncm91bmQgPSBuZXcgZXguQWN0b3IoKTtcclxuICAgICAgICB0aGlzLmdyb3VuZC5hZGREcmF3aW5nKFJlc291cmNlLkdyb3VuZC5hc1Nwcml0ZSgpKTtcclxuICAgICAgICB0aGlzLmdyb3VuZC54ID0gR2FtZVNldHRpbmdzLldJRFRILzI7XHJcbiAgICAgICAgdGhpcy5ncm91bmQueSA9IEdhbWVTZXR0aW5ncy5IRUlHSFQgLSBHYW1lU2V0dGluZ3MuR1JPVU5EX0hFSUdIVC8yO1xyXG4gICAgICAgIHRoaXMuZ3JvdW5kLnNldFdpZHRoKEdhbWVTZXR0aW5ncy5XSURUSCk7XHJcbiAgICAgICAgdGhpcy5ncm91bmQuc2V0SGVpZ2h0KEdhbWVTZXR0aW5ncy5HUk9VTkRfSEVJR0hUKTtcclxuICAgICAgICB0aGlzLmFkZCh0aGlzLmdyb3VuZCk7XHJcbiAgICAgICAgdGhpcy5ncm91bmQueiA9IDU7XHJcblxyXG4gICAgICAgIGVuZ2luZS5pbnB1dC5wb2ludGVycy5wcmltYXJ5Lm9uKFwiZG93blwiLCB0aGlzLm9uUHJlc3MpO1xyXG4gICAgICAgIC8vZW5naW5lLmlucHV0LmtleWJvYXJkLm9uKFwicHJlc3NcIiwgKGV2dDogSW5wdXQuS2V5RXZlbnQpID0+IHsgaWYoZXZ0LmtleSA9PSBJbnB1dC5LZXlzLlNwYWNlKSB0aGlzLm9uU3BhY2UoKSB9KTtcclxuXHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMucmVjZWl2ZU1lc3NhZ2UsIGZhbHNlKTtcclxuICAgICAgICBDb21tdW5pY2F0aW9uLmxvYWRSZXF1ZXN0KCk7XHJcblxyXG4gICAgICAgIHRoaXMuY2FtZXJhLnBvcyA9IG5ldyBleC5WZWN0b3IoR2FtZVNldHRpbmdzLldJRFRILzIsIEdhbWVTZXR0aW5ncy5IRUlHSFQvMik7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uUHJlc3MgPSAoKSA9PiB7XHJcbiAgICAgICAgaWYoIXRoaXMuZ2FtZVN0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5nYW1lU3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuY2VudGVyTGFiZWwudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodGhpcy5nYW1lT3ZlciAmJiB0aGlzLmNhblJlc3RhcnQpXHJcbiAgICAgICAgICAgIHRoaXMucmVzZXRTY2VuZSA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlY2VpdmVNZXNzYWdlID0gKGV2ZW50OiBhbnkpID0+IHtcclxuICAgICAgICBpZihldmVudC5kYXRhLm1lc3NhZ2VUeXBlID09IFwiTE9BRFwiKSB7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJyZWNlaXZlZCBtZXNzYWdlXCIpO1xyXG4gICAgICAgICAgICB0aGlzLmJlc3RTY29yZSA9IE1hdGgubWF4KHRoaXMuYmVzdFNjb3JlLCBldmVudC5kYXRhLmdhbWVTdGF0ZS5iZXN0U2NvcmUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgcHVibGljIHVwZGF0ZShlbmdpbmU6IGV4LkVuZ2luZSwgZGVsdGE6IG51bWJlcikge1xyXG4gICAgICAgIHN1cGVyLnVwZGF0ZShlbmdpbmUsIGRlbHRhKTtcclxuXHJcbiAgICAgICAgdGhpcy5iZXN0U2NvcmVMYWJlbC50ZXh0ID0gXCJCZXN0OiBcIiArIHRoaXMuYmVzdFNjb3JlO1xyXG5cclxuICAgICAgICBpZih0aGlzLmdhbWVPdmVyICYmICF0aGlzLmNhblJlc3RhcnQpIHtcclxuICAgICAgICAgICAgdGhpcy5sYXN0T2JzdGFjbGVUaW1lICs9IGRlbHRhLzEwMDA7XHJcbiAgICAgICAgICAgIGlmKHRoaXMubGFzdE9ic3RhY2xlVGltZSA+IDEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FuUmVzdGFydCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3RhcnRMYWJlbC52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodGhpcy5yZXNldFNjZW5lKSB7XHJcbiAgICAgICAgICAgIGZvcih2YXIgYWMgaW4gdGhpcy5hY3RvcnMpIHtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuYWN0b3JzW2FjXSBpbnN0YW5jZW9mIFBlc3RpY2lkZSB8fCB0aGlzLmFjdG9yc1thY10gaW5zdGFuY2VvZiBCYWNrZ3JvdW5kT2JqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RvcnNbYWNdLmtpbGwoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5wbGF5ZXIucmVzZXQoKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc2NvcmUgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLnJlc3RhcnRMYWJlbC52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuY2VudGVyTGFiZWwudGV4dCA9IFwiQ2xpY2sgdG8gc3RhcnQgZmxhcHBpbmcuXCI7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmdhbWVTdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZU92ZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5jYW5SZXN0YXJ0ID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmxhc3RPYnN0YWNsZVRpbWUgPSBHYW1lU2V0dGluZ3MuVElNRV9JTlRFUlZBTDtcclxuICAgICAgICAgICAgdGhpcy5sYXN0T2JzdGFjbGVZID0gR2FtZVNldHRpbmdzLkhFSUdIVC8yO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5sYXN0QmFja2dyb3VuZFRpbWUgPSBHYW1lU2V0dGluZ3MuQkdfVElNRV9JTlRFUlZBTDtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucmVzZXRTY2VuZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZWxzZSBpZih0aGlzLmdhbWVPdmVyIHx8ICF0aGlzLmdhbWVTdGFydGVkKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgLy9zdXBlci51cGRhdGUoZW5naW5lLCBkZWx0YSk7IC8vIGNhbGwgYmFzZSB1cGRhdGUgbG9naWNcclxuXHJcbiAgICAgICAgICAgIHRoaXMubGFzdE9ic3RhY2xlVGltZSArPSBkZWx0YS8xMDAwO1xyXG4gICAgICAgICAgICB0aGlzLmxhc3RCYWNrZ3JvdW5kVGltZSArPSBkZWx0YS8xMDAwO1xyXG5cclxuICAgICAgICAgICAgaWYodGhpcy5sYXN0T2JzdGFjbGVUaW1lID4gR2FtZVNldHRpbmdzLlRJTUVfSU5URVJWQUwpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwb3N4ID0gR2FtZVNldHRpbmdzLldJRFRIICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogR2FtZVNldHRpbmdzLlZBUklBQklMSVRZKTtcclxuICAgICAgICAgICAgICAgIHZhciBzcGFjZVkgPSBNYXRoLmZsb29yKEdhbWVTZXR0aW5ncy5NQVhfU1BBQ0UgLSAoR2FtZVNldHRpbmdzLk1BWF9TUEFDRSAtIEdhbWVTZXR0aW5ncy5NSU5fU1BBQ0UpIC8gR2FtZVNldHRpbmdzLlNDT1JFX01BWF9ESUZGKTtcclxuICAgICAgICAgICAgICAgIHZhciBwb3N5O1xyXG4gICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc3kgPSBNYXRoLmZsb29yKHNwYWNlWSArIE1hdGgucmFuZG9tKCkgKiAoR2FtZVNldHRpbmdzLkhFSUdIVCAtIEdhbWVTZXR0aW5ncy5HUk9VTkRfSEVJR0hUIC0gMipzcGFjZVkpKVxyXG4gICAgICAgICAgICAgICAgfSB3aGlsZShNYXRoLmFicyhwb3N5IC0gdGhpcy5sYXN0T2JzdGFjbGVZKSA+IChHYW1lU2V0dGluZ3MuU1RBUlRfVl9MSU1JVCArIChHYW1lU2V0dGluZ3MuRU5EX1ZfTElNSVQgLSBHYW1lU2V0dGluZ3MuU1RBUlRfVl9MSU1JVCkgKiB0aGlzLnNjb3JlIC8gR2FtZVNldHRpbmdzLlNDT1JFX01BWF9ESUZGKSAqIEdhbWVTZXR0aW5ncy5IRUlHSFQpO1xyXG4gICAgICAgICAgICAgICAgLy9hbGVydChwb3N4ICsgXCIgXCIgKyBwb3N5ICsgXCIgXCIgKyBzcGFjZVkpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkKG5ldyBQZXN0aWNpZGUocG9zeCwgcG9zeSwgc3BhY2VZLCB0aGlzKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RPYnN0YWNsZVkgPSBwb3N5O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0T2JzdGFjbGVUaW1lID0gMDtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIGlmKHRoaXMubGFzdEJhY2tncm91bmRUaW1lID4gR2FtZVNldHRpbmdzLkJHX1RJTUVfSU5URVJWQUwpIHtcclxuICAgICAgICAgICAgICAgIHZhciBiZyA9IG5ldyBCYWNrZ3JvdW5kT2JqZWN0KHRoaXMpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChiZyk7XHJcbiAgICAgICAgICAgICAgICBiZy56ID0gLTNcclxuICAgICAgICAgICAgICAgIHRoaXMubGFzdEJhY2tncm91bmRUaW1lID0gMDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5zY29yZUxhYmVsLnRleHQgPSB0aGlzLnNjb3JlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXRHYW1lT3ZlciA9ICgpID0+IHtcclxuICAgICAgICB0aGlzLmdhbWVPdmVyID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmNlbnRlckxhYmVsLnRleHQgPSBcIkdhbWUgT3ZlclwiXHJcbiAgICAgICAgdGhpcy5jZW50ZXJMYWJlbC52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmxhc3RPYnN0YWNsZVRpbWUgPSAwO1xyXG5cclxuICAgICAgICBpZih0aGlzLnNjb3JlID4gdGhpcy5iZXN0U2NvcmUpIHtcclxuICAgICAgICAgICAgdGhpcy5iZXN0U2NvcmUgPSB0aGlzLnNjb3JlO1xyXG4gICAgICAgICAgICBDb21tdW5pY2F0aW9uLnBvc3RHYW1lU3RhdGUodGhpcy5iZXN0U2NvcmUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgQ29tbXVuaWNhdGlvbi5wb3N0U2NvcmUodGhpcy5zY29yZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uQWN0aXZhdGUoKSB7fVxyXG4gICAgcHVibGljIG9uRGVhY3RpdmF0ZSgpIHt9XHJcbn1cclxuXHJcbmV4cG9ydCB7IEdhbWVTY2VuZSB9OyJdLCJzb3VyY2VSb290IjoiIn0=