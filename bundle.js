/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/excalibur/dist/excalibur.js":
/*!**************************************************!*\
  !*** ./node_modules/excalibur/dist/excalibur.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;/*! excalibur - v0.15.0 - 2018-02-17
* https://github.com/excaliburjs/Excalibur
* Copyright (c) 2018 Excalibur.js <https://github.com/excaliburjs/Excalibur/graphs/contributors>; Licensed BSD-2-Clause
* @preserve */
(function (root, factory) {
    if (true) {
        // AMD. Register as an anonymous module.
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function (b) {
            return (root.ex = factory(b));
        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function () {
    //almond, and your modules will be inlined here
/**
 * @license almond 0.3.3 Copyright jQuery Foundation and other contributors.
 * Released under MIT license, http://github.com/requirejs/almond/LICENSE
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice,
        jsSuffixRegExp = /\.js$/;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap, lastIndex,
            foundI, foundStarMap, starI, i, j, part, normalizedBaseParts,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name) {
            name = name.split('/');
            lastIndex = name.length - 1;

            // If wanting node ID compatibility, strip .js from end
            // of IDs. Have to do this here, and not in nameToUrl
            // because node allows either .js or non .js to map
            // to same file.
            if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
            }

            // Starts with a '.' so need the baseName
            if (name[0].charAt(0) === '.' && baseParts) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that 'directory' and not name of the baseName's
                //module. For instance, baseName of 'one/two/three', maps to
                //'one/two/three.js', but we want the directory, 'one/two' for
                //this normalization.
                normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                name = normalizedBaseParts.concat(name);
            }

            //start trimDots
            for (i = 0; i < name.length; i++) {
                part = name[i];
                if (part === '.') {
                    name.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    // If at the start, or previous value is still ..,
                    // keep them so that when converted to a path it may
                    // still work when converted to a path, even though
                    // as an ID it is less than ideal. In larger point
                    // releases, may be better to just kick out an error.
                    if (i === 0 || (i === 1 && name[2] === '..') || name[i - 1] === '..') {
                        continue;
                    } else if (i > 0) {
                        name.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
            //end trimDots

            name = name.join('/');
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            var args = aps.call(arguments, 0);

            //If first arg is not require('string'), and there is only
            //one arg, it is the array form without a callback. Insert
            //a null so that the following concat is correct.
            if (typeof args[0] !== 'string' && args.length === 1) {
                args.push(null);
            }
            return req.apply(undef, args.concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    //Creates a parts array for a relName where first part is plugin ID,
    //second part is resource ID. Assumes relName has already been normalized.
    function makeRelParts(relName) {
        return relName ? splitPrefix(relName) : [];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relParts) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0],
            relResourceName = relParts[1];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relResourceName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relResourceName));
            } else {
                name = normalize(name, relResourceName);
            }
        } else {
            name = normalize(name, relResourceName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i, relParts,
            args = [],
            callbackType = typeof callback,
            usingExports;

        //Use name if no relName
        relName = relName || name;
        relParts = makeRelParts(relName);

        //Call the callback to define the module, if necessary.
        if (callbackType === 'undefined' || callbackType === 'function') {
            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relParts);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback ? callback.apply(defined[name], args) : undefined;

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, makeRelParts(callback)).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (config.deps) {
                req(config.deps, config.callback);
            }
            if (!callback) {
                return;
            }

            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        return req(cfg);
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {
        if (typeof name !== 'string') {
            throw new Error('See almond README: incorrect module build, no module name');
        }

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());
/*! excalibur - v0.15.0 - 2018-02-17
* https://github.com/excaliburjs/Excalibur
* Copyright (c) 2018 Excalibur.js <https://github.com/excaliburjs/Excalibur/graphs/contributors>; Licensed BSD-2-Clause
* @preserve */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define("Actions/RotationType", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * An enum that describes the strategies that rotation actions can use
     */
    var RotationType;
    (function (RotationType) {
        /**
         * Rotation via `ShortestPath` will use the smallest angle
         * between the starting and ending points. This strategy is the default behavior.
         */
        RotationType[RotationType["ShortestPath"] = 0] = "ShortestPath";
        /**
         * Rotation via `LongestPath` will use the largest angle
         * between the starting and ending points.
         */
        RotationType[RotationType["LongestPath"] = 1] = "LongestPath";
        /**
         * Rotation via `Clockwise` will travel in a clockwise direction,
         * regardless of the starting and ending points.
         */
        RotationType[RotationType["Clockwise"] = 2] = "Clockwise";
        /**
         * Rotation via `CounterClockwise` will travel in a counterclockwise direction,
         * regardless of the starting and ending points.
         */
        RotationType[RotationType["CounterClockwise"] = 3] = "CounterClockwise";
    })(RotationType = exports.RotationType || (exports.RotationType = {}));
});
define("Algebra", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A 2D vector on a plane.
     */
    var Vector = (function () {
        /**
         * @param x  X component of the Vector
         * @param y  Y component of the Vector
         */
        function Vector(x, y) {
            this.x = x;
            this.y = y;
        }
        /**
         * Returns a vector of unit length in the direction of the specified angle in Radians.
         * @param angle The angle to generate the vector
         */
        Vector.fromAngle = function (angle) {
            return new Vector(Math.cos(angle), Math.sin(angle));
        };
        /**
         * Checks if vector is not null, undefined, or if any of its components are NaN or Infinity.
         */
        Vector.isValid = function (vec) {
            if (vec === null || vec === undefined) {
                return false;
            }
            if (isNaN(vec.x) || isNaN(vec.y)) {
                return false;
            }
            if (vec.x === Infinity ||
                vec.y === Infinity ||
                vec.x === -Infinity ||
                vec.y === Infinity) {
                return false;
            }
            return true;
        };
        /**
         * Calculates distance between two Vectors
         * @param vec1
         * @param vec2
         */
        Vector.distance = function (vec1, vec2) {
            return Math.sqrt(Math.pow(vec1.x - vec2.x, 2) + Math.pow(vec1.y - vec2.y, 2));
        };
        /**
         * Sets the x and y components at once
         */
        Vector.prototype.setTo = function (x, y) {
            this.x = x;
            this.y = y;
        };
        /**
         * Compares this point against another and tests for equality
         * @param point  The other point to compare to
         */
        Vector.prototype.equals = function (vector, tolerance) {
            if (tolerance === void 0) { tolerance = .001; }
            return Math.abs(this.x - vector.x) <= tolerance && Math.abs(this.y - vector.y) <= tolerance;
        };
        /**
         * The distance to another vector. If no other Vector is specified, this will return the [[magnitude]].
         * @param v  The other vector. Leave blank to use origin vector.
         */
        Vector.prototype.distance = function (v) {
            if (!v) {
                v = Vector.Zero;
            }
            return Math.sqrt(Math.pow(this.x - v.x, 2) + Math.pow(this.y - v.y, 2));
        };
        /**
         * The magnitude (size) of the Vector
         */
        Vector.prototype.magnitude = function () {
            return this.distance();
        };
        /**
         * Normalizes a vector to have a magnitude of 1.
         */
        Vector.prototype.normalize = function () {
            var d = this.distance();
            if (d > 0) {
                return new Vector(this.x / d, this.y / d);
            }
            else {
                return new Vector(0, 1);
            }
        };
        /**
         * Returns the average (midpoint) between the current point and the specified
         */
        Vector.prototype.average = function (vec) {
            return this.add(vec).scale(.5);
        };
        /**
         * Scales a vector's by a factor of size
         * @param size  The factor to scale the magnitude by
         */
        Vector.prototype.scale = function (size) {
            return new Vector(this.x * size, this.y * size);
        };
        /**
         * Adds one vector to another
         * @param v The vector to add
         */
        Vector.prototype.add = function (v) {
            return new Vector(this.x + v.x, this.y + v.y);
        };
        /**
         * Subtracts a vector from another, if you subract vector `B.sub(A)` the resulting vector points from A -> B
         * @param v The vector to subtract
         */
        Vector.prototype.sub = function (v) {
            return new Vector(this.x - v.x, this.y - v.y);
        };
        /**
         * Adds one vector to this one modifying the original
         * @param v The vector to add
         */
        Vector.prototype.addEqual = function (v) {
            this.x += v.x;
            this.y += v.y;
            return this;
        };
        /**
         * Subtracts a vector from this one modifying the original
         * @parallel v The vector to subtract
         */
        Vector.prototype.subEqual = function (v) {
            this.x -= v.x;
            this.y -= v.y;
            return this;
        };
        /**
         * Scales this vector by a factor of size and modifies the original
         */
        Vector.prototype.scaleEqual = function (size) {
            this.x *= size;
            this.y *= size;
            return this;
        };
        /**
         * Performs a dot product with another vector
         * @param v  The vector to dot
         */
        Vector.prototype.dot = function (v) {
            return this.x * v.x + this.y * v.y;
        };
        Vector.prototype.cross = function (v) {
            if (v instanceof Vector) {
                return this.x * v.y - this.y * v.x;
            }
            else if (typeof v === 'number') {
                return new Vector(v * this.y, -v * this.x);
            }
        };
        /**
         * Returns the perpendicular vector to this one
         */
        Vector.prototype.perpendicular = function () {
            return new Vector(this.y, -this.x);
        };
        /**
         * Returns the normal vector to this one, same as the perpendicular of length 1
         */
        Vector.prototype.normal = function () {
            return this.perpendicular().normalize();
        };
        /**
         * Negate the current vector
         */
        Vector.prototype.negate = function () {
            return this.scale(-1);
        };
        /**
         * Returns the angle of this vector.
         */
        Vector.prototype.toAngle = function () {
            return Math.atan2(this.y, this.x);
        };
        /**
         * Rotates the current vector around a point by a certain number of
         * degrees in radians
         */
        Vector.prototype.rotate = function (angle, anchor) {
            if (!anchor) {
                anchor = new Vector(0, 0);
            }
            var sinAngle = Math.sin(angle);
            var cosAngle = Math.cos(angle);
            var x = cosAngle * (this.x - anchor.x) - sinAngle * (this.y - anchor.y) + anchor.x;
            var y = sinAngle * (this.x - anchor.x) + cosAngle * (this.y - anchor.y) + anchor.y;
            return new Vector(x, y);
        };
        /**
         * Creates new vector that has the same values as the previous.
         */
        Vector.prototype.clone = function () {
            return new Vector(this.x, this.y);
        };
        /**
         * Returns a string repesentation of the vector.
         */
        Vector.prototype.toString = function () {
            return "(" + this.x + ", " + this.y + ")";
        };
        return Vector;
    }());
    /**
     * A (0, 0) vector
     */
    Vector.Zero = new Vector(0, 0);
    /**
     * A (1, 1) vector
     */
    Vector.One = new Vector(1, 1);
    /**
     * A (0.5, 0.5) vector
     */
    Vector.Half = new Vector(0.5, 0.5);
    /**
     * A unit vector pointing up (0, -1)
     */
    Vector.Up = new Vector(0, -1);
    /**
     * A unit vector pointing down (0, 1)
     */
    Vector.Down = new Vector(0, 1);
    /**
     * A unit vector pointing left (-1, 0)
     */
    Vector.Left = new Vector(-1, 0);
    /**
     * A unit vector pointing right (1, 0)
     */
    Vector.Right = new Vector(1, 0);
    exports.Vector = Vector;
    /**
     * A 2D ray that can be cast into the scene to do collision detection
     */
    var Ray = (function () {
        /**
         * @param pos The starting position for the ray
         * @param dir The vector indicating the direction of the ray
         */
        function Ray(pos, dir) {
            this.pos = pos;
            this.dir = dir.normalize();
        }
        /**
         * Tests a whether this ray intersects with a line segment. Returns a number greater than or equal to 0 on success.
         * This number indicates the mathematical intersection time.
         * @param line  The line to test
         */
        Ray.prototype.intersect = function (line) {
            var numerator = line.begin.sub(this.pos);
            // Test is line and ray are parallel and non intersecting
            if (this.dir.cross(line.getSlope()) === 0 && numerator.cross(this.dir) !== 0) {
                return -1;
            }
            // Lines are parallel
            var divisor = (this.dir.cross(line.getSlope()));
            if (divisor === 0) {
                return -1;
            }
            var t = numerator.cross(line.getSlope()) / divisor;
            if (t >= 0) {
                var u = (numerator.cross(this.dir) / divisor) / line.getLength();
                if (u >= 0 && u <= 1) {
                    return t;
                }
            }
            return -1;
        };
        /**
         * Returns the point of intersection given the intersection time
         */
        Ray.prototype.getPoint = function (time) {
            return this.pos.add(this.dir.scale(time));
        };
        return Ray;
    }());
    exports.Ray = Ray;
    /**
     * A 2D line segment
     */
    var Line = (function () {
        /**
         * @param begin  The starting point of the line segment
         * @param end  The ending point of the line segment
         */
        function Line(begin, end) {
            this.begin = begin;
            this.end = end;
        }
        Object.defineProperty(Line.prototype, "slope", {
            /**
             * Gets the raw slope (m) of the line. Will return (+/-)Infinity for vertical lines.
             */
            get: function () {
                return (this.end.y - this.begin.y) / (this.end.x - this.begin.x);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Line.prototype, "intercept", {
            /**
             * Gets the Y-intercept (b) of the line. Will return (+/-)Infinity if there is no intercept.
             */
            get: function () {
                return this.begin.y - (this.slope * this.begin.x);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Gets the normal of the line
         */
        Line.prototype.normal = function () {
            return this.end.sub(this.begin).normal();
        };
        /**
         * Returns the slope of the line in the form of a vector
         */
        Line.prototype.getSlope = function () {
            var begin = this.begin;
            var end = this.end;
            var distance = begin.distance(end);
            return end.sub(begin).scale(1 / distance);
        };
        /**
         * Returns the length of the line segment in pixels
         */
        Line.prototype.getLength = function () {
            var begin = this.begin;
            var end = this.end;
            var distance = begin.distance(end);
            return distance;
        };
        /**
         * Find the perpendicular distance from the line to a point
         * https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
         * @param point
         */
        Line.prototype.distanceToPoint = function (point) {
            var x0 = point.x;
            var y0 = point.y;
            var l = this.getLength();
            var dy = this.end.y - this.begin.y;
            var dx = this.end.x - this.begin.x;
            var distance = Math.abs(dy * x0 - dx * y0 + this.end.x * this.begin.y - this.end.y * this.begin.x) / l;
            return distance;
        };
        /**
         * Finds a point on the line given only an X or a Y value. Given an X value, the function returns
         * a new point with the calculated Y value and vice-versa.
         *
         * @param x The known X value of the target point
         * @param y The known Y value of the target point
         * @returns A new point with the other calculated axis value
         */
        Line.prototype.findPoint = function (x, y) {
            if (x === void 0) { x = null; }
            if (y === void 0) { y = null; }
            var m = this.slope;
            var b = this.intercept;
            if (x !== null) {
                return new Vector(x, (m * x) + b);
            }
            else if (y !== null) {
                return new Vector((y - b) / m, y);
            }
            else {
                throw new Error('You must provide an X or a Y value');
            }
        };
        /**
         * @see http://stackoverflow.com/a/11908158/109458
         */
        Line.prototype.hasPoint = function () {
            var currPoint;
            var threshold = 0;
            if (typeof arguments[0] === 'number' &&
                typeof arguments[1] === 'number') {
                currPoint = new Vector(arguments[0], arguments[1]);
                threshold = arguments[2] || 0;
            }
            else if (arguments[0] instanceof Vector) {
                currPoint = arguments[0];
                threshold = arguments[1] || 0;
            }
            else {
                throw 'Could not determine the arguments for Vector.hasPoint';
            }
            var dxc = currPoint.x - this.begin.x;
            var dyc = currPoint.y - this.begin.y;
            var dx1 = this.end.x - this.begin.x;
            var dy1 = this.end.y - this.begin.y;
            var cross = dxc * dy1 - dyc * dx1;
            // check whether point lines on the line
            if (Math.abs(cross) > threshold) {
                return false;
            }
            // check whether point lies in-between start and end
            if (Math.abs(dx1) >= Math.abs(dy1)) {
                return dx1 > 0
                    ? this.begin.x <= currPoint.x && currPoint.x <= this.end.x
                    : this.end.x <= currPoint.x && currPoint.x <= this.begin.x;
            }
            else {
                return dy1 > 0
                    ? this.begin.y <= currPoint.y && currPoint.y <= this.end.y
                    : this.end.y <= currPoint.y && currPoint.y <= this.begin.y;
            }
        };
        return Line;
    }());
    exports.Line = Line;
    /**
     * A 1 dimensional projection on an axis, used to test overlaps
     */
    var Projection = (function () {
        function Projection(min, max) {
            this.min = min;
            this.max = max;
        }
        Projection.prototype.overlaps = function (projection) {
            return this.max > projection.min && projection.max > this.min;
        };
        Projection.prototype.getOverlap = function (projection) {
            if (this.overlaps(projection)) {
                if (this.max > projection.max) {
                    return projection.max - this.min;
                }
                else {
                    return this.max - projection.min;
                }
            }
            return 0;
        };
        return Projection;
    }());
    exports.Projection = Projection;
});
define("Physics", ["require", "exports", "Algebra"], function (require, exports, Algebra_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Possible collision resolution strategies
     *
     * The default is [[CollisionResolutionStrategy.Box]] which performs simple axis aligned arcade style physics.
     *
     * More advanced rigid body physics are enabled by setting [[CollisionResolutionStrategy.RigidBody]] which allows for complicated
     * simulated physical interactions.
     */
    var CollisionResolutionStrategy;
    (function (CollisionResolutionStrategy) {
        CollisionResolutionStrategy[CollisionResolutionStrategy["Box"] = 0] = "Box";
        CollisionResolutionStrategy[CollisionResolutionStrategy["RigidBody"] = 1] = "RigidBody";
    })(CollisionResolutionStrategy = exports.CollisionResolutionStrategy || (exports.CollisionResolutionStrategy = {}));
    /**
     * Possible broadphase collision pair identification strategies
     *
     * The default strategy is [[BroadphaseStrategy.DynamicAABBTree]] which uses a binary tree of axis-aligned bounding boxes to identify
     * potential collision pairs which is O(nlog(n)) faster. The other possible strategy is the [[BroadphaseStrategy.Naive]] strategy
     * which loops over every object for every object in the scene to identify collision pairs which is O(n^2) slower.
     */
    var BroadphaseStrategy;
    (function (BroadphaseStrategy) {
        BroadphaseStrategy[BroadphaseStrategy["Naive"] = 0] = "Naive";
        BroadphaseStrategy[BroadphaseStrategy["DynamicAABBTree"] = 1] = "DynamicAABBTree";
    })(BroadphaseStrategy = exports.BroadphaseStrategy || (exports.BroadphaseStrategy = {}));
    /**
     * Possible numerical integrators for position and velocity
     */
    var Integrator;
    (function (Integrator) {
        Integrator[Integrator["Euler"] = 0] = "Euler";
    })(Integrator = exports.Integrator || (exports.Integrator = {}));
    /**
     * The [[Physics]] object is the global configuration object for all Excalibur physics.
     *
     * [[include:Physics.md]]
     */
    /* istanbul ignore next */
    var Physics = (function () {
        function Physics() {
        }
        /**
         * Configures Excalibur to use box physics. Box physics which performs simple axis aligned arcade style physics.
         */
        Physics.useBoxPhysics = function () {
            Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Box;
        };
        /**
         * Configures Excalibur to use rigid body physics. Rigid body physics allows for complicated
         * simulated physical interactions.
         */
        Physics.useRigidBodyPhysics = function () {
            Physics.collisionResolutionStrategy = CollisionResolutionStrategy.RigidBody;
        };
        return Physics;
    }());
    /**
     * Global acceleration that is applied to all vanilla actors (it wont effect [[Label|labels]], [[UIActor|ui actors]], or
     * [[Trigger|triggers]] in Excalibur that have an [[CollisionType.Active|active]] collision type).
     *
     *
     * This is a great way to globally simulate effects like gravity.
     */
    Physics.acc = new Algebra_1.Vector(0, 0);
    /**
     * Globally switches all Excalibur physics behavior on or off.
     */
    Physics.enabled = true;
    /**
     * Gets or sets the number of collision passes for Excalibur to perform on physics bodies.
     *
     * Reducing collision passes may cause things not to collide as expected in your game, but may increase performance.
     *
     * More passes can improve the visual quality of collisions when many objects are on the screen. This can reduce jitter, improve the
     * collision resolution of fast move objects, or the stability of large numbers of objects stacked together.
     *
     * Fewer passes will improve the performance of the game at the cost of collision quality, more passes will improve quality at the
     * cost of performance.
     *
     * The default is set to 5 passes which is a good start.
     */
    Physics.collisionPasses = 5;
    /**
     * Gets or sets the broadphase pair identification strategy.
     *
     * The default strategy is [[BroadphaseStrategy.DynamicAABBTree]] which uses a binary tree of axis-aligned bounding boxes to identify
     * potential collision pairs which is O(nlog(n)) faster. The other possible strategy is the [[BroadphaseStrategy.Naive]] strategy
     * which loops over every object for every object in the scene to identify collision pairs which is O(n^2) slower.
     */
    Physics.broadphaseStrategy = BroadphaseStrategy.DynamicAABBTree;
    /**
     * Globally switches the debug information for the broadphase strategy
     */
    Physics.broadphaseDebug = false;
    /**
     * Show the normals as a result of collision on the screen.
     */
    Physics.showCollisionNormals = false;
    /**
     * Show the position, velocity, and acceleration as graphical vectors.
     */
    Physics.showMotionVectors = false;
    /**
     * Show the axis-aligned bounding boxes of the collision bodies on the screen.
     */
    Physics.showBounds = false;
    /**
     * Show the bounding collision area shapes
     */
    Physics.showArea = false;
    /**
     * Show points of collision interpreted by excalibur as a result of collision.
     */
    Physics.showContacts = false;
    /**
     * Show the surface normals of the collision areas.
     */
    Physics.showNormals = false;
    /**
     * Gets or sets the global collision resolution strategy (narrowphase).
     *
     * The default is [[CollisionResolutionStrategy.Box]] which performs simple axis aligned arcade style physics.
     *
     * More advanced rigid body physics are enabled by setting [[CollisionResolutionStrategy.RigidBody]] which allows for complicated
     * simulated physical interactions.
     */
    Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Box;
    /**
     * The default mass to use if none is specified
     */
    Physics.defaultMass = 10;
    /**
     * Gets or sets the position and velocity positional integrator, currently only Euler is supported.
     */
    Physics.integrator = Integrator.Euler;
    /**
     * Number of steps to use in integration. A higher number improves the positional accuracy over time. This can be useful to increase
     * if you have fast moving objects in your simulation or you have a large number of objects and need to increase stability.
     */
    Physics.integrationSteps = 1;
    /**
     * Gets or sets whether rotation is allowed in a RigidBody collision resolution
     */
    Physics.allowRigidBodyRotation = true;
    /**
     * Small value to help collision passes settle themselves after the narrowphase.
     */
    Physics.collisionShift = .001;
    /**
     * Factor to add to the RigidBody BoundingBox, bounding box (dimensions += vel * dynamicTreeVelocityMultiplyer);
     */
    Physics.dynamicTreeVelocityMultiplyer = 2;
    /**
     * Pad RigidBody BoundingBox by a constant amount
     */
    Physics.boundsPadding = 5;
    /**
     * Surface epsilon is used to help deal with surface penatration
     */
    Physics.surfaceEpsilon = .1;
    /**
     * Enable fast moving body checking, this enables checking for collision pairs via raycast for fast moving objects to prevent
     * bodies from tunneling through one another.
     */
    Physics.checkForFastBodies = true;
    /**
     * Disable minimum fast moving body raycast, by default if ex.Physics.checkForFastBodies = true Excalibur will only check if the
     * body is moving at least half of its minimum diminension in an update. If ex.Physics.disableMinimumSpeedForFastBody is set to true,
     * Excalibur will always perform the fast body raycast regardless of speed.
     */
    Physics.disableMinimumSpeedForFastBody = false;
    exports.Physics = Physics;
});
define("Util/EasingFunctions", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Standard easing functions for motion in Excalibur, defined on a domain of [0, duration] and a range from [+startValue,+endValue]
     * Given a time, the function will return a value from positive startValue to positive endValue.
     *
     * ```js
     * function Linear (t) {
     *    return t * t;
     * }
     *
     * // accelerating from zero velocity
     * function EaseInQuad (t) {
     *    return t * t;
     * }
     *
     * // decelerating to zero velocity
     * function EaseOutQuad (t) {
     *    return t * (2 - t);
     * }
     *
     * // acceleration until halfway, then deceleration
     * function EaseInOutQuad (t) {
     *    return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
     * }
     *
     * // accelerating from zero velocity
     * function EaseInCubic (t) {
     *    return t * t * t;
     * }
     *
     * // decelerating to zero velocity
     * function EaseOutCubic (t) {
     *    return (--t) * t * t + 1;
     * }
     *
     * // acceleration until halfway, then deceleration
     * function EaseInOutCubic (t) {
     *    return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
     * }
     * ```
     */
    var EasingFunctions = (function () {
        function EasingFunctions() {
        }
        return EasingFunctions;
    }());
    EasingFunctions.Linear = function (currentTime, startValue, endValue, duration) {
        endValue = (endValue - startValue);
        return endValue * currentTime / duration + startValue;
    };
    EasingFunctions.EaseInQuad = function (currentTime, startValue, endValue, duration) {
        endValue = (endValue - startValue);
        currentTime /= duration;
        return endValue * currentTime * currentTime + startValue;
    };
    EasingFunctions.EaseOutQuad = function (currentTime, startValue, endValue, duration) {
        endValue = (endValue - startValue);
        currentTime /= duration;
        return -endValue * currentTime * (currentTime - 2) + startValue;
    };
    EasingFunctions.EaseInOutQuad = function (currentTime, startValue, endValue, duration) {
        endValue = (endValue - startValue);
        currentTime /= duration / 2;
        if (currentTime < 1) {
            return endValue / 2 * currentTime * currentTime + startValue;
        }
        currentTime--;
        return -endValue / 2 * (currentTime * (currentTime - 2) - 1) + startValue;
    };
    EasingFunctions.EaseInCubic = function (currentTime, startValue, endValue, duration) {
        endValue = (endValue - startValue);
        currentTime /= duration;
        return endValue * currentTime * currentTime * currentTime + startValue;
    };
    EasingFunctions.EaseOutCubic = function (currentTime, startValue, endValue, duration) {
        endValue = (endValue - startValue);
        currentTime /= duration;
        currentTime--;
        return endValue * (currentTime * currentTime * currentTime + 1) + startValue;
    };
    EasingFunctions.EaseInOutCubic = function (currentTime, startValue, endValue, duration) {
        endValue = (endValue - startValue);
        currentTime /= duration / 2;
        if (currentTime < 1) {
            return endValue / 2 * currentTime * currentTime * currentTime + startValue;
        }
        currentTime -= 2;
        return endValue / 2 * (currentTime * currentTime * currentTime + 2) + startValue;
    };
    exports.EasingFunctions = EasingFunctions;
});
// Promises/A+ Spec http://promises-aplus.github.io/promises-spec/
define("Promises", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Valid states for a promise to be in
     */
    var PromiseState;
    (function (PromiseState) {
        PromiseState[PromiseState["Resolved"] = 0] = "Resolved";
        PromiseState[PromiseState["Rejected"] = 1] = "Rejected";
        PromiseState[PromiseState["Pending"] = 2] = "Pending";
    })(PromiseState = exports.PromiseState || (exports.PromiseState = {}));
    /**
     * Promises are used to do asynchronous work and they are useful for
     * creating a chain of actions. In Excalibur they are used for loading,
     * sounds, animation, actions, and more.
     *
     * [[include:Promises.md]]
     */
    var Promise = (function () {
        function Promise() {
            this._state = PromiseState.Pending;
            this._successCallbacks = [];
            this._rejectCallback = function () { return; };
        }
        /**
         * Create and resolve a Promise with an optional value
         * @param value  An optional value to wrap in a resolved promise
         */
        Promise.resolve = function (value) {
            var promise = (new Promise()).resolve(value);
            return promise;
        };
        /**
         * Create and reject a Promise with an optional value
         * @param value  An optional value to wrap in a rejected promise
         */
        Promise.reject = function (value) {
            var promise = (new Promise()).reject(value);
            return promise;
        };
        Promise.join = function () {
            var promises = [];
            if (arguments.length > 0 && !Array.isArray(arguments[0])) {
                for (var _i = 0; _i < arguments.length; _i++) {
                    promises[_i - 0] = arguments[_i];
                }
            }
            else if (arguments.length === 1 && Array.isArray(arguments[0])) {
                promises = arguments[0];
            }
            var joinedPromise = new Promise();
            if (!promises || !promises.length) {
                return joinedPromise.resolve();
            }
            var total = promises.length;
            var successes = 0;
            var rejects = 0;
            var errors = [];
            promises.forEach(function (p) {
                p.then(function () {
                    successes += 1;
                    if (successes === total) {
                        joinedPromise.resolve();
                    }
                    else if (successes + rejects + errors.length === total) {
                        joinedPromise.reject(errors);
                    }
                }, function () {
                    rejects += 1;
                    if (successes + rejects + errors.length === total) {
                        joinedPromise.reject(errors);
                    }
                }).error(function (e) {
                    errors.push(e);
                    if ((errors.length + successes + rejects) === total) {
                        joinedPromise.reject(errors);
                    }
                });
            });
            return joinedPromise;
        };
        /**
         * Chain success and reject callbacks after the promise is resolved
         * @param successCallback  Call on resolution of promise
         * @param rejectCallback   Call on rejection of promise
         */
        Promise.prototype.then = function (successCallback, rejectCallback) {
            if (successCallback) {
                this._successCallbacks.push(successCallback);
                // If the promise is already resovled call immediately
                if (this.state() === PromiseState.Resolved) {
                    try {
                        successCallback.call(this, this._value);
                    }
                    catch (e) {
                        this._handleError(e);
                    }
                }
            }
            if (rejectCallback) {
                this._rejectCallback = rejectCallback;
                // If the promise is already rejected call immediately
                if (this.state() === PromiseState.Rejected) {
                    try {
                        rejectCallback.call(this, this._value);
                    }
                    catch (e) {
                        this._handleError(e);
                    }
                }
            }
            return this;
        };
        /**
         * Add an error callback to the promise
         * @param errorCallback  Call if there was an error in a callback
         */
        Promise.prototype.error = function (errorCallback) {
            if (errorCallback) {
                this._errorCallback = errorCallback;
            }
            return this;
        };
        /**
         * Resolve the promise and pass an option value to the success callbacks
         * @param value  Value to pass to the success callbacks
         */
        Promise.prototype.resolve = function (value) {
            var _this = this;
            if (this._state === PromiseState.Pending) {
                this._value = value;
                try {
                    this._state = PromiseState.Resolved;
                    this._successCallbacks.forEach(function (cb) {
                        cb.call(_this, _this._value);
                    });
                }
                catch (e) {
                    this._handleError(e);
                }
            }
            else {
                throw new Error('Cannot resolve a promise that is not in a pending state!');
            }
            return this;
        };
        /**
         * Reject the promise and pass an option value to the reject callbacks
         * @param value  Value to pass to the reject callbacks
         */
        Promise.prototype.reject = function (value) {
            if (this._state === PromiseState.Pending) {
                this._value = value;
                try {
                    this._state = PromiseState.Rejected;
                    this._rejectCallback.call(this, this._value);
                }
                catch (e) {
                    this._handleError(e);
                }
            }
            else {
                throw new Error('Cannot reject a promise that is not in a pending state!');
            }
            return this;
        };
        /**
         * Inspect the current state of a promise
         */
        Promise.prototype.state = function () {
            return this._state;
        };
        Promise.prototype._handleError = function (e) {
            if (this._errorCallback) {
                this._errorCallback.call(this, e);
            }
            else {
                // rethrow error
                throw e;
            }
        };
        return Promise;
    }());
    exports.Promise = Promise;
});
/**
 * Pseudo-Random Utility
 *
 * A pseudo-random utility to add seeded random support for help in
 * generating things like terrain or reproducible randomness. Uses the
 * [Mersenne Twister](https://en.wikipedia.org/wiki/Mersenne_Twister) algorithm.
 *
 * [[include:Random.md]]
 */
define("Math/Random", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * 32-bit mask
     */
    var BITMASK32 = 0xFFFFFFFF;
    /**
     * Pseudo-random number generator following the Mersenne_Twister algorithm. Given a seed this generator will produce the same sequence
     * of numbers each time it is called.
     * See https://en.wikipedia.org/wiki/Mersenne_Twister for more details.
     * Uses the MT19937-32 (2002) implementation documented here http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html
     *
     * Api inspired by http://chancejs.com/# https://github.com/chancejs/chancejs
     */
    var Random = (function () {
        /**
         * If no seed is specified, the Date.now() is used
         */
        function Random(seed) {
            this.seed = seed;
            // Separation point of one one word, the number of bits in the lower bitmask 0 <= r <= w-1
            this._lowerMask = 0x7FFFFFFF; // 31 bits same as _r
            this._upperMask = 0x80000000; // 34 high bits
            // Word size, 64 bits
            this._w = 32;
            // Degree of recurrance
            this._n = 624;
            // Middle word, an offset used in the recurrance defining the series x, 1<=m<n
            this._m = 397;
            // coefficients of teh rational normal form twist matrix
            this._a = 0x9908B0DF;
            // tempering bit shifts and masks
            this._u = 11;
            this._s = 7;
            this._b = 0x9d2c5680;
            this._t = 15;
            this._c = 0xefc60000;
            this._l = 18;
            this._f = 1812433253;
            this._mt = new Array(this._n);
            // need to mask to support higher bit machines
            this._mt[0] = (seed || Date.now()) >>> 0;
            for (var i = 1; i < this._n; i++) {
                var s = this._mt[i - 1] ^ (this._mt[i - 1] >>> (this._w - 2));
                // numbers are bigger than the JS max safe int, add in 16-bit chunks to prevent IEEE rounding errors on high bits         
                this._mt[i] = (((this._f * ((s & 0xFFFF0000) >>> 16)) << 16) + (this._f * (s & 0xFFFF)) + i) >>> 0;
            }
            this._index = this._n;
        }
        /**
         * Apply the twist
         */
        Random.prototype._twist = function () {
            var mag01 = [0x0, this._a];
            var y = 0;
            for (var i = 0; i < this._n - this._m; i++) {
                y = (this._mt[i] & this._upperMask) | (this._mt[i + 1] & this._lowerMask);
                this._mt[i] = this._mt[i + this._m] ^ (y >>> 1) ^ mag01[y & 0x1] & BITMASK32;
            }
            for (; i < this._n - 1; i++) {
                y = (this._mt[i] & this._upperMask) | (this._mt[i + 1] & this._lowerMask);
                this._mt[i] = this._mt[i + (this._m - this._n)] ^ (y >>> 1) ^ mag01[y & 0x1] & BITMASK32;
            }
            y = (this._mt[this._n - 1] & this._upperMask) | (this._mt[0] & this._lowerMask);
            this._mt[this._n - 1] = this._mt[this._m - 1] ^ (y >>> 1) ^ mag01[y & 0x1] & BITMASK32;
            this._index = 0;
        };
        /**
         * Return next 32 bit integer number in sequence
         */
        Random.prototype.nextInt = function () {
            if (this._index >= this._n) {
                this._twist();
            }
            var y = this._mt[this._index++];
            y ^= y >>> this._u;
            y ^= ((y << this._s) & this._b);
            y ^= ((y << this._t) & this._c);
            y ^= (y >>> this._l);
            return y >>> 0;
        };
        /**
         * Return a random floating point number between [0, 1)
         */
        Random.prototype.next = function () {
            return this.nextInt() * (1.0 / 4294967296.0); // divided by 2^32
        };
        /**
         * Return a random floating point in range [min, max) min is included, max is not included
         */
        Random.prototype.floating = function (min, max) {
            return (max - min) * this.next() + min;
        };
        /**
         * Return a random integer in range [min, max] min is included, max is included.
         * Implemented with rejection sampling, see https://medium.com/@betable/tifu-by-using-math-random-f1c308c4fd9d#.i13tdiu5a
         */
        Random.prototype.integer = function (min, max) {
            return Math.floor((max - min + 1) * this.next() + min);
        };
        /**
         * Returns true or false randomly with 50/50 odds by default.
         * By default the likelihood of returning a true is .5 (50%).
         * @param likelihood takes values between [0, 1]
         */
        Random.prototype.bool = function (likelihood) {
            if (likelihood === void 0) { likelihood = .5; }
            return this.next() <= likelihood;
        };
        /**
         * Returns one element from an array at random
         */
        Random.prototype.pickOne = function (array) {
            return array[this.integer(0, array.length - 1)];
        };
        /**
         * Returns a new array random picking elements from the original
         * @param array Original array to pick from
         * @param numPicks can be any positive number
         * @param allowDuplicates indicates whether the returned set is allowed duplicates (it does not mean there will always be duplicates
         * just that it is possible)
         */
        Random.prototype.pickSet = function (array, numPicks, allowDuplicates) {
            if (allowDuplicates === void 0) { allowDuplicates = false; }
            if (allowDuplicates) {
                return this._pickSetWithDuplicates(array, numPicks);
            }
            else {
                return this._pickSetWithoutDuplicates(array, numPicks);
            }
        };
        /**
         * Returns a new array randomly picking elements in the original (not reused)
         * @param numPicks must be less than or equal to the number of elements in the array.
         */
        Random.prototype._pickSetWithoutDuplicates = function (array, numPicks) {
            if (numPicks > array.length || numPicks < 0) {
                throw new Error('Invalid number of elements to pick, must pick a value 0 < n <= length');
            }
            if (numPicks === array.length) {
                return array;
            }
            var result = new Array(numPicks);
            var currentPick = 0;
            var tempArray = array.slice(0);
            while (currentPick < numPicks) {
                var index = this.integer(0, tempArray.length - 1);
                result[currentPick++] = tempArray[index];
                tempArray.splice(index, 1);
            }
            return result;
        };
        /**
         * Returns a new array random picking elements from the original allowing duplicates
         * @param numPicks can be any positive number
         */
        Random.prototype._pickSetWithDuplicates = function (array, numPicks) {
            // Typescript numbers are all floating point, so do we add check for int? (or floor the input?)
            if (numPicks < 0) {
                throw new Error('Invalid number of elements to pick, must pick a value 0 <= n < MAX_INT');
            }
            var result = new Array(numPicks);
            for (var i = 0; i < numPicks; i++) {
                result.push(this.pickOne(array));
            }
            return result;
        };
        /**
         * Returns a new array that has its elements shuffled. Using the Fisher/Yates method
         * https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
         */
        Random.prototype.shuffle = function (array) {
            var tempArray = array.slice(0);
            var swap = null;
            for (var i = 0; i < tempArray.length - 2; i++) {
                var randomIndex = this.integer(i, tempArray.length - 1);
                swap = tempArray[i];
                tempArray[i] = tempArray[randomIndex];
                tempArray[randomIndex] = swap;
            }
            return tempArray;
        };
        /**
         * Generate a list of random integer numbers
         * @param length the length of the final array
         * @param min the minimum integer number to generate inclusive
         * @param max the maximum integer number to generate inclusive
         */
        Random.prototype.range = function (length, min, max) {
            var result = new Array(length);
            for (var i = 0; i < length; i++) {
                result[i] = this.integer(min, max);
            }
            return result;
        };
        /**
         * Returns the result of a d4 dice roll
         */
        Random.prototype.d4 = function () {
            return this.integer(1, 4);
        };
        /**
         * Returns the result of a d6 dice roll
         */
        Random.prototype.d6 = function () {
            return this.integer(1, 6);
        };
        /**
         * Returns the result of a d8 dice roll
         */
        Random.prototype.d8 = function () {
            return this.integer(1, 8);
        };
        /**
         * Returns the result of a d10 dice roll
         */
        Random.prototype.d10 = function () {
            return this.integer(1, 10);
        };
        /**
         * Returns the result of a d12 dice roll
         */
        Random.prototype.d12 = function () {
            return this.integer(1, 12);
        };
        /**
         * Returns the result of a d20 dice roll
         */
        Random.prototype.d20 = function () {
            return this.integer(1, 20);
        };
        return Random;
    }());
    exports.Random = Random;
});
define("Collision/Side", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * An enum that describes the sides of an Actor for collision
     */
    var Side;
    (function (Side) {
        Side[Side["None"] = 0] = "None";
        Side[Side["Top"] = 1] = "Top";
        Side[Side["Bottom"] = 2] = "Bottom";
        Side[Side["Left"] = 3] = "Left";
        Side[Side["Right"] = 4] = "Right";
    })(Side = exports.Side || (exports.Side = {}));
});
define("Util/Util", ["require", "exports", "Algebra", "Math/Random", "Collision/Side"], function (require, exports, Algebra_2, Random_1, Side_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Two PI constant
     */
    exports.TwoPI = Math.PI * 2;
    /**
     * Merges one or more objects into a single target object
     *
     * @returns Merged object with properties from other objects
     * @credit https://gomakethings.com/vanilla-javascript-version-of-jquery-extend/
     */
    function extend() {
        var extended = {};
        var deep = false;
        var i = 0;
        var length = arguments.length;
        // Check if a deep merge
        if (Object.prototype.toString.call(arguments[0]) === '[object Boolean]') {
            deep = arguments[0];
            i++;
        }
        // Merge the object into the extended object
        var assignExists = typeof Object.assign === 'function';
        var merge = null;
        if (!assignExists) {
            merge = function (obj) {
                for (var prop in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, prop)) {
                        // If deep merge and property is an object, merge properties
                        if (deep && Object.prototype.toString.call(obj[prop]) === '[object Object]') {
                            extended[prop] = extend(true, extended[prop], obj[prop]);
                        }
                        else {
                            extended[prop] = obj[prop];
                        }
                    }
                }
            };
        }
        else {
            merge = Object.assign;
        }
        // Loop through each object and conduct a merge
        for (; i < length; i++) {
            var obj = arguments[i];
            if (!assignExists) {
                merge(obj);
            }
            else {
                merge(extended, obj);
            }
        }
        return extended;
    }
    exports.extend = extend;
    function base64Encode(inputStr) {
        var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
        var outputStr = '';
        var i = 0;
        while (i < inputStr.length) {
            //all three "& 0xff" added below are there to fix a known bug
            //with bytes returned by xhr.responseText
            var byte1 = inputStr.charCodeAt(i++) & 0xff;
            var byte2 = inputStr.charCodeAt(i++) & 0xff;
            var byte3 = inputStr.charCodeAt(i++) & 0xff;
            var enc1 = byte1 >> 2;
            var enc2 = ((byte1 & 3) << 4) | (byte2 >> 4);
            var enc3, enc4;
            if (isNaN(byte2)) {
                enc3 = enc4 = 64;
            }
            else {
                enc3 = ((byte2 & 15) << 2) | (byte3 >> 6);
                if (isNaN(byte3)) {
                    enc4 = 64;
                }
                else {
                    enc4 = byte3 & 63;
                }
            }
            outputStr += b64.charAt(enc1) + b64.charAt(enc2) + b64.charAt(enc3) + b64.charAt(enc4);
        }
        return outputStr;
    }
    exports.base64Encode = base64Encode;
    /**
     * Clamps a value between a min and max inclusive
     */
    function clamp(val, min, max) {
        return Math.min(Math.max(min, val), max);
    }
    exports.clamp = clamp;
    function randomInRange(min, max, random) {
        if (random === void 0) { random = new Random_1.Random(); }
        return random ? random.floating(min, max) : min + Math.random() * (max - min);
    }
    exports.randomInRange = randomInRange;
    function randomIntInRange(min, max, random) {
        if (random === void 0) { random = new Random_1.Random(); }
        return random ? random.integer(min, max) : Math.round(randomInRange(min, max));
    }
    exports.randomIntInRange = randomIntInRange;
    function canonicalizeAngle(angle) {
        var tmpAngle = angle;
        if (angle > exports.TwoPI) {
            while (tmpAngle > exports.TwoPI) {
                tmpAngle -= exports.TwoPI;
            }
        }
        if (angle < 0) {
            while (tmpAngle < 0) {
                tmpAngle += exports.TwoPI;
            }
        }
        return tmpAngle;
    }
    exports.canonicalizeAngle = canonicalizeAngle;
    function toDegrees(radians) {
        return 180 / Math.PI * radians;
    }
    exports.toDegrees = toDegrees;
    function toRadians(degrees) {
        return degrees / 180 * Math.PI;
    }
    exports.toRadians = toRadians;
    function getPosition(el) {
        var oLeft = 0, oTop = 0;
        var calcOffsetLeft = function (parent) {
            oLeft += parent.offsetLeft;
            if (parent.offsetParent) {
                calcOffsetLeft(parent.offsetParent);
            }
        };
        var calcOffsetTop = function (parent) {
            oTop += parent.offsetTop;
            if (parent.offsetParent) {
                calcOffsetTop(parent.offsetParent);
            }
        };
        calcOffsetLeft(el);
        calcOffsetTop(el);
        return new Algebra_2.Vector(oLeft, oTop);
    }
    exports.getPosition = getPosition;
    function addItemToArray(item, array) {
        if (array.indexOf(item) === -1) {
            array.push(item);
            return true;
        }
        return false;
    }
    exports.addItemToArray = addItemToArray;
    function removeItemFromArray(item, array) {
        var index = -1;
        if ((index = array.indexOf(item)) > -1) {
            array.splice(index, 1);
            return true;
        }
        return false;
    }
    exports.removeItemFromArray = removeItemFromArray;
    function contains(array, obj) {
        for (var i = 0; i < array.length; i++) {
            if (array[i] === obj) {
                return true;
            }
        }
        return false;
    }
    exports.contains = contains;
    function getOppositeSide(side) {
        if (side === Side_1.Side.Top) {
            return Side_1.Side.Bottom;
        }
        if (side === Side_1.Side.Bottom) {
            return Side_1.Side.Top;
        }
        if (side === Side_1.Side.Left) {
            return Side_1.Side.Right;
        }
        if (side === Side_1.Side.Right) {
            return Side_1.Side.Left;
        }
        return Side_1.Side.None;
    }
    exports.getOppositeSide = getOppositeSide;
    function getSideFromVector(direction) {
        var directions = [Algebra_2.Vector.Left, Algebra_2.Vector.Right, Algebra_2.Vector.Up, Algebra_2.Vector.Down];
        var directionEnum = [Side_1.Side.Left, Side_1.Side.Right, Side_1.Side.Top, Side_1.Side.Bottom];
        var max = -Number.MAX_VALUE;
        var maxIndex = -1;
        for (var i = 0; i < directions.length; i++) {
            if (directions[i].dot(direction) > max) {
                max = directions[i].dot(direction);
                maxIndex = i;
            }
        }
        return directionEnum[maxIndex];
    }
    exports.getSideFromVector = getSideFromVector;
    /**
     * Excalibur's dynamically resizing collection
     */
    var Collection = (function () {
        /**
         * @param initialSize  Initial size of the internal backing array
         */
        function Collection(initialSize) {
            if (initialSize === void 0) { initialSize = Collection.DefaultSize; }
            this._internalArray = null;
            this._endPointer = 0;
            this._internalArray = new Array(initialSize);
        }
        Collection.prototype._resize = function () {
            var newSize = this._internalArray.length * 2;
            var newArray = new Array(newSize);
            var count = this.count();
            for (var i = 0; i < count; i++) {
                newArray[i] = this._internalArray[i];
            }
            delete this._internalArray;
            this._internalArray = newArray;
        };
        /**
         * Push elements to the end of the collection
         */
        Collection.prototype.push = function (element) {
            if (this._endPointer === this._internalArray.length) {
                this._resize();
            }
            return this._internalArray[this._endPointer++] = element;
        };
        /**
         * Removes elements from the end of the collection
         */
        Collection.prototype.pop = function () {
            this._endPointer = this._endPointer - 1 < 0 ? 0 : this._endPointer - 1;
            return this._internalArray[this._endPointer];
        };
        /**
         * Returns the count of the collection
         */
        Collection.prototype.count = function () {
            return this._endPointer;
        };
        /**
         * Empties the collection
         */
        Collection.prototype.clear = function () {
            this._endPointer = 0;
        };
        /**
         * Returns the size of the internal backing array
         */
        Collection.prototype.internalSize = function () {
            return this._internalArray.length;
        };
        /**
         * Returns an element at a specific index
         * @param index  Index of element to retrieve
         */
        Collection.prototype.elementAt = function (index) {
            if (index >= this.count()) {
                //Logger.getInstance().error('Invalid parameter: ' + index);
                throw new Error('Invalid index ' + index);
            }
            return this._internalArray[index];
        };
        /**
         * Inserts an element at a specific index
         * @param index  Index to insert the element
         * @param value  Element to insert
         */
        Collection.prototype.insert = function (index, value) {
            if (index >= this.count()) {
                this._resize();
            }
            return this._internalArray[index] = value;
        };
        /**
         * Removes an element at a specific index
         * @param index  Index of element to remove
         */
        Collection.prototype.remove = function (index) {
            var count = this.count();
            if (count === 0) {
                //Logger.getInstance().error('Invalid parameter: ' + index);
                throw new Error('Invalid parameter ' + index);
            }
            // O(n) Shift
            var removed = this._internalArray[index];
            for (var i = index; i < count; i++) {
                this._internalArray[i] = this._internalArray[i + 1];
            }
            this._endPointer--;
            return removed;
        };
        /**
         * Removes an element by reference
         * @param element  Element to retrieve
         */
        Collection.prototype.removeElement = function (element) {
            var index = this._internalArray.indexOf(element);
            this.remove(index);
        };
        /**
         * Returns a array representing the collection
         */
        Collection.prototype.toArray = function () {
            return this._internalArray.slice(0, this._endPointer);
        };
        /**
         * Iterate over every element in the collection
         * @param func  Callback to call for each element passing a reference to the element and its index, returned values are ignored
         */
        Collection.prototype.forEach = function (func) {
            var i = 0, count = this.count();
            for (i; i < count; i++) {
                func.call(this, this._internalArray[i], i);
            }
        };
        /**
         * Mutate every element in the collection
         * @param func  Callback to call for each element passing a reference to the element and its index, any values returned mutate
         * the collection
         */
        Collection.prototype.map = function (func) {
            var count = this.count();
            for (var i = 0; i < count; i++) {
                this._internalArray[i] = func.call(this, this._internalArray[i], i);
            }
        };
        return Collection;
    }());
    /**
     * Default collection size
     */
    Collection.DefaultSize = 200;
    exports.Collection = Collection;
});
define("Camera", ["require", "exports", "Util/EasingFunctions", "Promises", "Algebra", "Util/Util"], function (require, exports, EasingFunctions_1, Promises_1, Algebra_3, Util_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Container to house convenience strategy methods
     * @internal
     */
    var StrategyContainer = (function () {
        function StrategyContainer(camera) {
            this.camera = camera;
        }
        /**
         * Creates and adds the [[LockCameraToActorStrategy]] on the current camera.
         * @param actor The actor to lock the camera to
         */
        StrategyContainer.prototype.lockToActor = function (actor) {
            this.camera.addStrategy(new LockCameraToActorStrategy(actor));
        };
        /**
         * Creates and adds the [[LockCameraToActorAxisStrategy]] on the current camera
         * @param actor The actor to lock the camera to
         * @param axis The axis to follow the actor on
         */
        StrategyContainer.prototype.lockToActorAxis = function (actor, axis) {
            this.camera.addStrategy(new LockCameraToActorAxisStrategy(actor, axis));
        };
        /**
         * Creates and adds the [[ElasticToActorStrategy]] on the current camera
         * If cameraElasticity < cameraFriction < 1.0, the behavior will be a dampened spring that will slowly end at the target without bouncing
         * If cameraFriction < cameraElasticity < 1.0, the behavior will be an oscillationg spring that will over
         * correct and bounce around the target
         *
         * @param target Target actor to elastically follow
         * @param cameraElasticity [0 - 1.0] The higher the elasticity the more force that will drive the camera towards the target
         * @param cameraFriction [0 - 1.0] The higher the friction the more that the camera will resist motion towards the target
         */
        StrategyContainer.prototype.elasticToActor = function (actor, cameraElasticity, cameraFriction) {
            this.camera.addStrategy(new ElasticToActorStrategy(actor, cameraElasticity, cameraFriction));
        };
        /**
         * Creates and adds the [[RadiusAroundActorStrategy]] on the current camera
         * @param target Target actor to follow when it is "radius" pixels away
         * @param radius Number of pixels away before the camera will follow
         */
        StrategyContainer.prototype.radiusAroundActor = function (actor, radius) {
            this.camera.addStrategy(new RadiusAroundActorStrategy(actor, radius));
        };
        return StrategyContainer;
    }());
    exports.StrategyContainer = StrategyContainer;
    /**
     * Camera axis enum
     */
    var Axis;
    (function (Axis) {
        Axis[Axis["X"] = 0] = "X";
        Axis[Axis["Y"] = 1] = "Y";
    })(Axis = exports.Axis || (exports.Axis = {}));
    /**
     * Lock a camera to the exact x/y postition of an actor.
     */
    var LockCameraToActorStrategy = (function () {
        function LockCameraToActorStrategy(target) {
            this.target = target;
            this.action = function (target, _cam, _eng, _delta) {
                var center = target.getCenter();
                return center;
            };
        }
        return LockCameraToActorStrategy;
    }());
    exports.LockCameraToActorStrategy = LockCameraToActorStrategy;
    /**
     * Lock a camera to a specific axis around an actor.
     */
    var LockCameraToActorAxisStrategy = (function () {
        function LockCameraToActorAxisStrategy(target, axis) {
            var _this = this;
            this.target = target;
            this.axis = axis;
            this.action = function (target, cam, _eng, _delta) {
                var center = target.getCenter();
                var currentFocus = cam.getFocus();
                if (_this.axis === Axis.X) {
                    return new Algebra_3.Vector(center.x, currentFocus.y);
                }
                else {
                    return new Algebra_3.Vector(currentFocus.x, center.y);
                }
            };
        }
        return LockCameraToActorAxisStrategy;
    }());
    exports.LockCameraToActorAxisStrategy = LockCameraToActorAxisStrategy;
    /**
     * Using [Hook's law](https://en.wikipedia.org/wiki/Hooke's_law), elastically move the camera towards the target actor.
     */
    var ElasticToActorStrategy = (function () {
        /**
         * If cameraElasticity < cameraFriction < 1.0, the behavior will be a dampened spring that will slowly end at the target without bouncing
         * If cameraFriction < cameraElasticity < 1.0, the behavior will be an oscillationg spring that will over
         * correct and bounce around the target
         *
         * @param target Target actor to elastically follow
         * @param cameraElasticity [0 - 1.0] The higher the elasticity the more force that will drive the camera towards the target
         * @param cameraFriction [0 - 1.0] The higher the friction the more that the camera will resist motion towards the target
         */
        function ElasticToActorStrategy(target, cameraElasticity, cameraFriction) {
            var _this = this;
            this.target = target;
            this.cameraElasticity = cameraElasticity;
            this.cameraFriction = cameraFriction;
            this.action = function (target, cam, _eng, _delta) {
                var position = target.getCenter();
                var focus = cam.getFocus();
                var cameraVel = new Algebra_3.Vector(cam.dx, cam.dy);
                // Calculate the strech vector, using the spring equation
                // F = kX
                // https://en.wikipedia.org/wiki/Hooke's_law
                // Apply to the current camera velocity
                var stretch = position.sub(focus).scale(_this.cameraElasticity); // stretch is X
                cameraVel = cameraVel.add(stretch);
                // Calculate the friction (-1 to apply a force in the opposition of motion)
                // Apply to the current camera velocity
                var friction = cameraVel.scale(-1).scale(_this.cameraFriction);
                cameraVel = cameraVel.add(friction);
                // Update position by velocity deltas
                focus = focus.add(cameraVel);
                return focus;
            };
        }
        return ElasticToActorStrategy;
    }());
    exports.ElasticToActorStrategy = ElasticToActorStrategy;
    var RadiusAroundActorStrategy = (function () {
        /**
         *
         * @param target Target actor to follow when it is "radius" pixels away
         * @param radius Number of pixels away before the camera will follow
         */
        function RadiusAroundActorStrategy(target, radius) {
            var _this = this;
            this.target = target;
            this.radius = radius;
            this.action = function (target, cam, _eng, _delta) {
                var position = target.getCenter();
                var focus = cam.getFocus();
                var direction = position.sub(focus);
                var distance = direction.magnitude();
                if (distance >= _this.radius) {
                    var offset = distance - _this.radius;
                    return focus.add(direction.normalize().scale(offset));
                }
                return focus;
            };
        }
        return RadiusAroundActorStrategy;
    }());
    exports.RadiusAroundActorStrategy = RadiusAroundActorStrategy;
    /**
     * Cameras
     *
     * [[BaseCamera]] is the base class for all Excalibur cameras. Cameras are used
     * to move around your game and set focus. They are used to determine
     * what is "off screen" and can be used to scale the game.
     *
     * [[include:Cameras.md]]
     */
    var BaseCamera = (function () {
        function BaseCamera() {
            this._cameraStrategies = [];
            this.strategy = new StrategyContainer(this);
            // camera physical quantities
            this.z = 1;
            this.dx = 0;
            this.dy = 0;
            this.dz = 0;
            this.ax = 0;
            this.ay = 0;
            this.az = 0;
            this.rotation = 0;
            this.rx = 0;
            this._x = 0;
            this._y = 0;
            this._cameraMoving = false;
            this._currentLerpTime = 0;
            this._lerpDuration = 1000; // 1 second   
            this._lerpStart = null;
            this._lerpEnd = null;
            //camera effects
            this._isShaking = false;
            this._shakeMagnitudeX = 0;
            this._shakeMagnitudeY = 0;
            this._shakeDuration = 0;
            this._elapsedShakeTime = 0;
            this._xShake = 0;
            this._yShake = 0;
            this._isZooming = false;
            this._maxZoomScale = 1;
            this._zoomIncrement = 0.01;
            this._easing = EasingFunctions_1.EasingFunctions.EaseInOutCubic;
        }
        Object.defineProperty(BaseCamera.prototype, "x", {
            /**
             * Get the camera's x position
             */
            get: function () {
                return this._x;
            },
            /**
             * Set the camera's x position (cannot be set when following an [[Actor]] or when moving)
             */
            set: function (value) {
                if (!this._follow && !this._cameraMoving) {
                    this._x = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseCamera.prototype, "y", {
            /**
             * Get the camera's y position
             */
            get: function () {
                return this._y;
            },
            /**
             * Set the camera's y position (cannot be set when following an [[Actor]] or when moving)
             */
            set: function (value) {
                if (!this._follow && !this._cameraMoving) {
                    this._y = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseCamera.prototype, "pos", {
            /**
             * Get the camera's position as a vector
             */
            get: function () {
                return new Algebra_3.Vector(this.x, this.y);
            },
            /**
             * Set the cameras position
             */
            set: function (value) {
                this.x = value.x;
                this.y = value.y;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseCamera.prototype, "vel", {
            /**
             * Get the camera's velocity as a vector
             */
            get: function () {
                return new Algebra_3.Vector(this.dx, this.dy);
            },
            /**
             * Set the camera's velocity
             */
            set: function (value) {
                this.dx = value.x;
                this.dy = value.y;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns the focal point of the camera, a new point giving the x and y position of the camera
         */
        BaseCamera.prototype.getFocus = function () {
            return new Algebra_3.Vector(this.x, this.y);
        };
        /**
         * This moves the camera focal point to the specified position using specified easing function. Cannot move when following an Actor.
         *
         * @param pos The target position to move to
         * @param duration The duration in milliseconds the move should last
         * @param [easingFn] An optional easing function ([[ex.EasingFunctions.EaseInOutCubic]] by default)
         * @returns A [[Promise]] that resolves when movement is finished, including if it's interrupted.
         *          The [[Promise]] value is the [[Vector]] of the target position. It will be rejected if a move cannot be made.
         */
        BaseCamera.prototype.move = function (pos, duration, easingFn) {
            if (easingFn === void 0) { easingFn = EasingFunctions_1.EasingFunctions.EaseInOutCubic; }
            if (typeof easingFn !== 'function') {
                throw 'Please specify an EasingFunction';
            }
            // cannot move when following an actor
            if (this._follow) {
                return new Promises_1.Promise().reject(pos);
            }
            // resolve existing promise, if any
            if (this._lerpPromise && this._lerpPromise.state() === Promises_1.PromiseState.Pending) {
                this._lerpPromise.resolve(pos);
            }
            this._lerpPromise = new Promises_1.Promise();
            this._lerpStart = this.getFocus().clone();
            this._lerpDuration = duration;
            this._lerpEnd = pos;
            this._currentLerpTime = 0;
            this._cameraMoving = true;
            this._easing = easingFn;
            return this._lerpPromise;
        };
        /**
         * Sets the camera to shake at the specified magnitudes for the specified duration
         * @param magnitudeX  The x magnitude of the shake
         * @param magnitudeY  The y magnitude of the shake
         * @param duration    The duration of the shake in milliseconds
         */
        BaseCamera.prototype.shake = function (magnitudeX, magnitudeY, duration) {
            this._isShaking = true;
            this._shakeMagnitudeX = magnitudeX;
            this._shakeMagnitudeY = magnitudeY;
            this._shakeDuration = duration;
        };
        /**
         * Zooms the camera in or out by the specified scale over the specified duration.
         * If no duration is specified, it take effect immediately.
         * @param scale    The scale of the zoom
         * @param duration The duration of the zoom in milliseconds
         */
        BaseCamera.prototype.zoom = function (scale, duration) {
            if (duration === void 0) { duration = 0; }
            this._zoomPromise = new Promises_1.Promise();
            if (duration) {
                this._isZooming = true;
                this._maxZoomScale = scale;
                this._zoomIncrement = (scale - this.z) / duration;
            }
            else {
                this._isZooming = false;
                this.z = scale;
                this._zoomPromise.resolve(true);
            }
            return this._zoomPromise;
        };
        /**
         * Gets the current zoom scale
         */
        BaseCamera.prototype.getZoom = function () {
            return this.z;
        };
        /**
         * Adds a new camera strategy to this camera
         * @param cameraStrategy Instance of an [[ICameraStrategy]]
         */
        BaseCamera.prototype.addStrategy = function (cameraStrategy) {
            this._cameraStrategies.push(cameraStrategy);
        };
        /**
         * Removes a camera strategy by reference
         * @param cameraStrategy Instance of an [[ICameraStrategy]]
         */
        BaseCamera.prototype.removeStrategy = function (cameraStrategy) {
            Util_1.removeItemFromArray(cameraStrategy, this._cameraStrategies);
        };
        /**
         * Clears all camera strategies from the camera
         */
        BaseCamera.prototype.clearAllStrategies = function () {
            this._cameraStrategies.length = 0;
        };
        BaseCamera.prototype.update = function (_engine, delta) {
            // Update placements based on linear algebra
            this._x += this.dx * delta / 1000;
            this._y += this.dy * delta / 1000;
            this.z += this.dz * delta / 1000;
            this.dx += this.ax * delta / 1000;
            this.dy += this.ay * delta / 1000;
            this.dz += this.az * delta / 1000;
            this.rotation += this.rx * delta / 1000;
            if (this._isZooming) {
                var newZoom = this.z + this._zoomIncrement * delta;
                this.z = newZoom;
                if (this._zoomIncrement > 0) {
                    if (newZoom >= this._maxZoomScale) {
                        this._isZooming = false;
                        this.z = this._maxZoomScale;
                        this._zoomPromise.resolve(true);
                    }
                }
                else {
                    if (newZoom <= this._maxZoomScale) {
                        this._isZooming = false;
                        this.z = this._maxZoomScale;
                        this._zoomPromise.resolve(true);
                    }
                }
            }
            if (this._cameraMoving) {
                if (this._currentLerpTime < this._lerpDuration) {
                    if (this._lerpEnd.x < this._lerpStart.x) {
                        this._x = this._lerpStart.x - (this._easing(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x);
                    }
                    else {
                        this._x = this._easing(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration);
                    }
                    if (this._lerpEnd.y < this._lerpStart.y) {
                        this._y = this._lerpStart.y - (this._easing(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y);
                    }
                    else {
                        this._y = this._easing(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);
                    }
                    this._currentLerpTime += delta;
                }
                else {
                    this._x = this._lerpEnd.x;
                    this._y = this._lerpEnd.y;
                    this._lerpPromise.resolve(this._lerpEnd);
                    this._lerpStart = null;
                    this._lerpEnd = null;
                    this._currentLerpTime = 0;
                    this._cameraMoving = false;
                }
            }
            if (this._isDoneShaking()) {
                this._isShaking = false;
                this._elapsedShakeTime = 0;
                this._shakeMagnitudeX = 0;
                this._shakeMagnitudeY = 0;
                this._shakeDuration = 0;
                this._xShake = 0;
                this._yShake = 0;
            }
            else {
                this._elapsedShakeTime += delta;
                this._xShake = (Math.random() * this._shakeMagnitudeX | 0) + 1;
                this._yShake = (Math.random() * this._shakeMagnitudeY | 0) + 1;
            }
            for (var _i = 0, _a = this._cameraStrategies; _i < _a.length; _i++) {
                var s = _a[_i];
                this.pos = s.action.call(s, s.target, this, _engine, delta);
            }
        };
        /**
         * Applies the relevant transformations to the game canvas to "move" or apply effects to the Camera
         * @param ctx    Canvas context to apply transformations
         * @param delta  The number of milliseconds since the last update
         */
        BaseCamera.prototype.draw = function (ctx) {
            var focus = this.getFocus();
            var canvasWidth = ctx.canvas.width;
            var canvasHeight = ctx.canvas.height;
            var pixelRatio = window.devicePixelRatio;
            var zoom = this.getZoom();
            var newCanvasWidth = (canvasWidth / zoom) / pixelRatio;
            var newCanvasHeight = (canvasHeight / zoom) / pixelRatio;
            ctx.scale(zoom, zoom);
            ctx.translate(-focus.x + newCanvasWidth / 2 + this._xShake, -focus.y + newCanvasHeight / 2 + this._yShake);
        };
        BaseCamera.prototype.debugDraw = function (ctx) {
            var focus = this.getFocus();
            ctx.fillStyle = 'red';
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(focus.x, focus.y, 15, 0, Math.PI * 2);
            ctx.closePath();
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(focus.x, focus.y, 5, 0, Math.PI * 2);
            ctx.closePath();
            ctx.stroke();
        };
        BaseCamera.prototype._isDoneShaking = function () {
            return !(this._isShaking) || (this._elapsedShakeTime >= this._shakeDuration);
        };
        return BaseCamera;
    }());
    exports.BaseCamera = BaseCamera;
});
define("Configurable", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function Configurable(base) {
        return (function (_super) {
            __extends(class_1, _super);
            function class_1() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var _this = _super.apply(this, args) || this;
                //get the number of arguments that aren't undefined. TS passes a value to all parameters
                //of whatever ctor is the implementation, so args.length doesn't work here.
                var size = args.filter(function (value) { return value !== undefined; }).length;
                if (size === 1 && args[0] && typeof args[0] === 'object' && !(args[0] instanceof Array)) {
                    _this.assign(args[0]);
                }
                return _this;
            }
            class_1.prototype.assign = function (props) {
                //set the value of every property that was passed in,
                //if the constructor previously set this value, it will be overridden here
                for (var k in props) {
                    if (typeof this[k] !== 'function') {
                        this[k] = props[k];
                    }
                }
            };
            return class_1;
        }(base));
    }
    exports.Configurable = Configurable;
});
define("DebugFlags", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Drawing/Color", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Provides standard colors (e.g. [[Color.Black]])
     * but you can also create custom colors using RGB, HSL, or Hex. Also provides
     * useful color operations like [[Color.lighten]], [[Color.darken]], and more.
     *
     * [[include:Colors.md]]
     */
    var Color = (function () {
        /**
         * Creates a new instance of Color from an r, g, b, a
         *
         * @param r  The red component of color (0-255)
         * @param g  The green component of color (0-255)
         * @param b  The blue component of color (0-255)
         * @param a  The alpha component of color (0-1.0)
         */
        function Color(r, g, b, a) {
            this.r = r;
            this.g = g;
            this.b = b;
            this.a = (a != null ? a : 1);
        }
        /**
         * Creates a new instance of Color from an r, g, b, a
         *
         * @param r  The red component of color (0-255)
         * @param g  The green component of color (0-255)
         * @param b  The blue component of color (0-255)
         * @param a  The alpha component of color (0-1.0)
         */
        Color.fromRGB = function (r, g, b, a) {
            return new Color(r, g, b, a);
        };
        /**
         * Creates a new inscance of Color from a hex string
         *
         * @param hex  CSS color string of the form #ffffff, the alpha component is optional
         */
        Color.fromHex = function (hex) {
            var hexRegEx = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i;
            var match = null;
            if (match = hex.match(hexRegEx)) {
                var r = parseInt(match[1], 16);
                var g = parseInt(match[2], 16);
                var b = parseInt(match[3], 16);
                var a = 1;
                if (match[4]) {
                    a = parseInt(match[4], 16) / 255;
                }
                return new Color(r, g, b, a);
            }
            else {
                throw new Error('Invalid hex string: ' + hex);
            }
        };
        /**
         * Creats a new instance of Color from hsla values
         *
         * @param h  Hue is represented [0-1]
         * @param s  Saturation is represented [0-1]
         * @param l  Luminance is represented [0-1]
         * @param a  Alpha is represented [0-1]
         */
        Color.fromHSL = function (h, s, l, a) {
            if (a === void 0) { a = 1.0; }
            var temp = new HSLColor(h, s, l, a);
            return temp.toRGBA();
        };
        /**
         * Lightens the current color by a specified amount
         *
         * @param factor  The amount to lighten by [0-1]
         */
        Color.prototype.lighten = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            var temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
            temp.l += (temp.l * factor);
            return temp.toRGBA();
        };
        /**
         * Darkens the current color by a specified amount
         *
         * @param factor  The amount to darken by [0-1]
         */
        Color.prototype.darken = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            var temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
            temp.l -= (temp.l * factor);
            return temp.toRGBA();
        };
        /**
         * Saturates the current color by a specified amount
         *
         * @param factor  The amount to saturate by [0-1]
         */
        Color.prototype.saturate = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            var temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
            temp.s += (temp.s * factor);
            return temp.toRGBA();
        };
        /**
         * Desaturates the current color by a specified amount
         *
         * @param factor  The amount to desaturate by [0-1]
         */
        Color.prototype.desaturate = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            var temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
            temp.s -= (temp.s * factor);
            return temp.toRGBA();
        };
        /**
         * Multiplies a color by another, results in a darker color
         *
         * @param color  The other color
         */
        Color.prototype.mulitiply = function (color) {
            var newR = ((color.r / 255 * this.r / 255) * 255);
            var newG = ((color.g / 255 * this.g / 255) * 255);
            var newB = ((color.b / 255 * this.b / 255) * 255);
            var newA = (color.a * this.a);
            return new Color(newR, newG, newB, newA);
        };
        /**
         * Screens a color by another, results in a lighter color
         *
         * @param color  The other color
         */
        Color.prototype.screen = function (color) {
            var color1 = color.invert();
            var color2 = color.invert();
            return color1.mulitiply(color2).invert();
        };
        /**
         * Inverts the current color
         */
        Color.prototype.invert = function () {
            return new Color(255 - this.r, 255 - this.g, 255 - this.b, 1.0 - this.a);
        };
        /**
         * Averages the current color with another
         *
         * @param color  The other color
         */
        Color.prototype.average = function (color) {
            var newR = (color.r + this.r) / 2;
            var newG = (color.g + this.g) / 2;
            var newB = (color.b + this.b) / 2;
            var newA = (color.a + this.a) / 2;
            return new Color(newR, newG, newB, newA);
        };
        /**
         * Returns a CSS string representation of a color.
         *
         * @param format Color representation, accepts: rgb, hsl, or hex
         */
        Color.prototype.toString = function (format) {
            if (format === void 0) { format = 'rgb'; }
            switch (format) {
                case 'rgb':
                    return this.toRGBA();
                case 'hsl':
                    return this.toHSLA();
                case 'hex':
                    return this.toHex();
                default:
                    throw new Error('Invalid Color format');
            }
        };
        /**
         * Returns Hex Value of a color component
         * @param c color component
         * @see https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
         */
        Color.prototype._componentToHex = function (c) {
            var hex = c.toString(16);
            return hex.length === 1 ? '0' + hex : hex;
        };
        /**
         * Return Hex representation of a color.
         */
        Color.prototype.toHex = function () {
            return '#' + this._componentToHex(this.r) + this._componentToHex(this.g) + this._componentToHex(this.b);
        };
        /**
         * Return RGBA representation of a color.
         */
        Color.prototype.toRGBA = function () {
            var result = String(this.r.toFixed(0)) + ', ' + String(this.g.toFixed(0)) + ', ' + String(this.b.toFixed(0));
            if (this.a !== undefined || this.a !== null) {
                return 'rgba(' + result + ', ' + String(this.a) + ')';
            }
            return 'rgb(' + result + ')';
        };
        /**
         * Return HSLA representation of a color.
         */
        Color.prototype.toHSLA = function () {
            return HSLColor.fromRGBA(this.r, this.g, this.b, this.a).toString();
        };
        /**
         * Returns a CSS string representation of a color.
         */
        Color.prototype.fillStyle = function () {
            return this.toString();
        };
        /**
         * Returns a clone of the current color.
         */
        Color.prototype.clone = function () {
            return new Color(this.r, this.g, this.b, this.a);
        };
        return Color;
    }());
    /**
     * Black (#000000)
     */
    Color.Black = Color.fromHex('#000000');
    /**
     * White (#FFFFFF)
     */
    Color.White = Color.fromHex('#FFFFFF');
    /**
     * Gray (#808080)
     */
    Color.Gray = Color.fromHex('#808080');
    /**
     * Light gray (#D3D3D3)
     */
    Color.LightGray = Color.fromHex('#D3D3D3');
    /**
     * Dark gray (#A9A9A9)
     */
    Color.DarkGray = Color.fromHex('#A9A9A9');
    /**
     * Yellow (#FFFF00)
     */
    Color.Yellow = Color.fromHex('#FFFF00');
    /**
     * Orange (#FFA500)
     */
    Color.Orange = Color.fromHex('#FFA500');
    /**
     * Red (#FF0000)
     */
    Color.Red = Color.fromHex('#FF0000');
    /**
     * Vermillion (#FF5B31)
     */
    Color.Vermillion = Color.fromHex('#FF5B31');
    /**
     * Rose (#FF007F)
     */
    Color.Rose = Color.fromHex('#FF007F');
    /**
     * Magenta (#FF00FF)
     */
    Color.Magenta = Color.fromHex('#FF00FF');
    /**
     * Violet (#7F00FF)
     */
    Color.Violet = Color.fromHex('#7F00FF');
    /**
     * Blue (#0000FF)
     */
    Color.Blue = Color.fromHex('#0000FF');
    /**
     * Azure (#007FFF)
     */
    Color.Azure = Color.fromHex('#007FFF');
    /**
     * Cyan (#00FFFF)
     */
    Color.Cyan = Color.fromHex('#00FFFF');
    /**
     * Viridian (#59978F)
     */
    Color.Viridian = Color.fromHex('#59978F');
    /**
     * Green (#00FF00)
     */
    Color.Green = Color.fromHex('#00FF00');
    /**
     * Chartreuse (#7FFF00)
     */
    Color.Chartreuse = Color.fromHex('#7FFF00');
    /**
     * Transparent (#FFFFFF00)
     */
    Color.Transparent = Color.fromHex('#FFFFFF00');
    exports.Color = Color;
    /**
     * Internal HSL Color representation
     *
     * http://en.wikipedia.org/wiki/HSL_and_HSV
     * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
     */
    var HSLColor = (function () {
        function HSLColor(h, s, l, a) {
            this.h = h;
            this.s = s;
            this.l = l;
            this.a = a;
        }
        HSLColor.hue2rgb = function (p, q, t) {
            if (t < 0) {
                t += 1;
            }
            if (t > 1) {
                t -= 1;
            }
            if (t < 1 / 6) {
                return p + (q - p) * 6 * t;
            }
            if (t < 1 / 2) {
                return q;
            }
            if (t < 2 / 3) {
                return p + (q - p) * (2 / 3 - t) * 6;
            }
            return p;
        };
        HSLColor.fromRGBA = function (r, g, b, a) {
            r /= 255;
            g /= 255;
            b /= 255;
            var max = Math.max(r, g, b), min = Math.min(r, g, b);
            var h, s, l = (max + min) / 2;
            if (max === min) {
                h = s = 0; // achromatic
            }
            else {
                var d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r:
                        h = (g - b) / d + (g < b ? 6 : 0);
                        break;
                    case g:
                        h = (b - r) / d + 2;
                        break;
                    case b:
                        h = (r - g) / d + 4;
                        break;
                }
                h /= 6;
            }
            return new HSLColor(h, s, l, a);
        };
        HSLColor.prototype.toRGBA = function () {
            var r, g, b;
            if (this.s === 0) {
                r = g = b = this.l; // achromatic
            }
            else {
                var q = this.l < 0.5 ? this.l * (1 + this.s) : this.l + this.s - this.l * this.s;
                var p = 2 * this.l - q;
                r = HSLColor.hue2rgb(p, q, this.h + 1 / 3);
                g = HSLColor.hue2rgb(p, q, this.h);
                b = HSLColor.hue2rgb(p, q, this.h - 1 / 3);
            }
            return new Color(r * 255, g * 255, b * 255, this.a);
        };
        HSLColor.prototype.toString = function () {
            var h = this.h.toFixed(0), s = this.s.toFixed(0), l = this.l.toFixed(0), a = this.a.toFixed(0);
            return "hsla(" + h + ", " + s + ", " + l + ", " + a + ")";
        };
        return HSLColor;
    }());
});
define("Collision/CollisionContact", ["require", "exports", "Actor", "Algebra", "Physics", "Events", "Util/Util"], function (require, exports, Actor_1, Algebra_4, Physics_1, Events_1, Util) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Collision contacts are used internally by Excalibur to resolve collision between actors. This
     * Pair prevents collisions from being evaluated more than one time
     */
    var CollisionContact = (function () {
        function CollisionContact(bodyA, bodyB, mtv, point, normal) {
            this.bodyA = bodyA;
            this.bodyB = bodyB;
            this.mtv = mtv;
            this.point = point;
            this.normal = normal;
        }
        CollisionContact.prototype.resolve = function (strategy) {
            if (strategy === Physics_1.CollisionResolutionStrategy.RigidBody) {
                this._resolveRigidBodyCollision();
            }
            else if (strategy === Physics_1.CollisionResolutionStrategy.Box) {
                this._resolveBoxCollision();
            }
            else {
                throw new Error('Unknown collision resolution strategy');
            }
        };
        CollisionContact.prototype._applyBoxImpulse = function (bodyA, bodyB, mtv) {
            if (bodyA.collisionType === Actor_1.CollisionType.Active &&
                bodyB.collisionType !== Actor_1.CollisionType.Passive) {
                // Resolve overlaps
                if (bodyA.collisionType === Actor_1.CollisionType.Active &&
                    bodyB.collisionType === Actor_1.CollisionType.Active) {
                    // split overlaps if both are Active
                    mtv = mtv.scale(.5);
                }
                // Apply mtv
                bodyA.pos.y += mtv.y;
                bodyA.pos.x += mtv.x;
                // non-zero intersection on the y axis
                if (this.mtv.x !== 0) {
                    var velX = 0;
                    // both bodies are traveling in the same direction (negative or positive)
                    if (bodyA.vel.x < 0 && bodyB.vel.x < 0) {
                        velX = Math.min(bodyA.vel.x, bodyB.vel.x);
                    }
                    else if (bodyA.vel.x > 0 && bodyB.vel.x > 0) {
                        velX = Math.max(bodyA.vel.x, bodyB.vel.x);
                    }
                    else if (bodyB.collisionType === Actor_1.CollisionType.Fixed) {
                        // bodies are traveling in opposite directions
                        if (bodyA.pos.sub(bodyB.pos).dot(bodyA.vel) > 0) {
                            velX = bodyA.vel.x;
                        }
                        else {
                            // bodyA is heading towards b
                            velX = bodyB.vel.x;
                        }
                    }
                    bodyA.vel.x = velX;
                }
                if (this.mtv.y !== 0) {
                    var velY = 0;
                    // both bodies are traveling in the same direction (negative or positive)
                    if (bodyA.vel.y < 0 && bodyB.vel.y < 0) {
                        velY = Math.min(bodyA.vel.y, bodyB.vel.y);
                    }
                    else if (bodyA.vel.y > 0 && bodyB.vel.y > 0) {
                        velY = Math.max(bodyA.vel.y, bodyB.vel.y);
                    }
                    else if (bodyB.collisionType === Actor_1.CollisionType.Fixed) {
                        // bodies are traveling in opposite directions
                        if (bodyA.pos.sub(bodyB.pos).dot(bodyA.vel) > 0) {
                            velY = bodyA.vel.y;
                        }
                        else {
                            // bodyA is heading towards b
                            velY = bodyB.vel.y;
                        }
                    }
                    bodyA.vel.y = velY;
                }
                bodyA.emit('postcollision', new Events_1.PostCollisionEvent(bodyA, bodyB, Util.getSideFromVector(mtv), mtv));
            }
        };
        CollisionContact.prototype._resolveBoxCollision = function () {
            var bodyA = this.bodyA.body.actor;
            var bodyB = this.bodyB.body.actor;
            var side = Util.getSideFromVector(this.mtv);
            var mtv = this.mtv.negate();
            // Publish collision events on both participants
            bodyA.emit('precollision', new Events_1.PreCollisionEvent(bodyA, bodyB, side, mtv));
            bodyB.emit('precollision', new Events_1.PreCollisionEvent(bodyB, bodyA, Util.getOppositeSide(side), mtv.negate()));
            this._applyBoxImpulse(bodyA, bodyB, mtv);
            this._applyBoxImpulse(bodyB, bodyA, mtv.negate());
        };
        CollisionContact.prototype._resolveRigidBodyCollision = function () {
            // perform collison on bounding areas
            var bodyA = this.bodyA.body;
            var bodyB = this.bodyB.body;
            var mtv = this.mtv; // normal pointing away from bodyA
            var normal = this.normal; // normal pointing away from bodyA
            if (bodyA.actor === bodyB.actor) {
                return;
            }
            // Publish collision events on both participants
            var side = Util.getSideFromVector(this.mtv);
            bodyA.actor.emit('precollision', new Events_1.PreCollisionEvent(this.bodyA.body.actor, this.bodyB.body.actor, side, this.mtv));
            bodyB.actor.emit('precollision', new Events_1.PreCollisionEvent(this.bodyB.body.actor, this.bodyA.body.actor, Util.getOppositeSide(side), this.mtv.negate()));
            // If any of the participants are passive then short circuit
            if (bodyA.actor.collisionType === Actor_1.CollisionType.Passive ||
                bodyB.actor.collisionType === Actor_1.CollisionType.Passive) {
                return;
            }
            var invMassA = bodyA.actor.collisionType === Actor_1.CollisionType.Fixed ? 0 : 1 / bodyA.mass;
            var invMassB = bodyB.actor.collisionType === Actor_1.CollisionType.Fixed ? 0 : 1 / bodyB.mass;
            var invMoiA = bodyA.actor.collisionType === Actor_1.CollisionType.Fixed ? 0 : 1 / bodyA.moi;
            var invMoiB = bodyB.actor.collisionType === Actor_1.CollisionType.Fixed ? 0 : 1 / bodyB.moi;
            // average restitution more relistic
            var coefRestitution = Math.min(bodyA.restitution, bodyB.restitution);
            var coefFriction = Math.min(bodyA.friction, bodyB.friction);
            normal = normal.normalize();
            var tangent = normal.normal().normalize();
            var ra = this.point.sub(this.bodyA.getCenter()); // point relative to bodyA position
            var rb = this.point.sub(this.bodyB.getCenter()); /// point relative to bodyB
            // Relative velocity in linear terms
            // Angular to linear velocity formula -> omega = v/r
            var rv = bodyB.vel.add(rb.cross(-bodyB.rx)).sub(bodyA.vel.sub(ra.cross(bodyA.rx)));
            var rvNormal = rv.dot(normal);
            var rvTangent = rv.dot(tangent);
            var raTangent = ra.dot(tangent);
            var raNormal = ra.dot(normal);
            var rbTangent = rb.dot(tangent);
            var rbNormal = rb.dot(normal);
            // If objects are moving away ignore
            if (rvNormal > 0) {
                return;
            }
            // Collision impulse formula from Chris Hecker
            // https://en.wikipedia.org/wiki/Collision_response
            var impulse = -((1 + coefRestitution) * rvNormal) /
                ((invMassA + invMassB) + invMoiA * raTangent * raTangent + invMoiB * rbTangent * rbTangent);
            if (bodyA.actor.collisionType === Actor_1.CollisionType.Fixed) {
                bodyB.vel = bodyB.vel.add(normal.scale(impulse * invMassB));
                if (Physics_1.Physics.allowRigidBodyRotation) {
                    bodyB.rx -= impulse * invMoiB * -rb.cross(normal);
                }
                bodyB.addMtv(mtv);
            }
            else if (bodyB.actor.collisionType === Actor_1.CollisionType.Fixed) {
                bodyA.vel = bodyA.vel.sub(normal.scale(impulse * invMassA));
                if (Physics_1.Physics.allowRigidBodyRotation) {
                    bodyA.rx += impulse * invMoiA * -ra.cross(normal);
                }
                bodyA.addMtv(mtv.negate());
            }
            else {
                bodyB.vel = bodyB.vel.add(normal.scale(impulse * invMassB));
                bodyA.vel = bodyA.vel.sub(normal.scale(impulse * invMassA));
                if (Physics_1.Physics.allowRigidBodyRotation) {
                    bodyB.rx -= impulse * invMoiB * -rb.cross(normal);
                    bodyA.rx += impulse * invMoiA * -ra.cross(normal);
                }
                // Split the mtv in half for the two bodies, potentially we could do something smarter here
                bodyB.addMtv(mtv.scale(.5));
                bodyA.addMtv(mtv.scale(-.5));
            }
            // Friction portion of impulse
            if (coefFriction && rvTangent) {
                // Columb model of friction, formula for impulse due to friction from  
                // https://en.wikipedia.org/wiki/Collision_response
                // tangent force exerted by body on another in contact
                var t = rv.sub(normal.scale(rv.dot(normal))).normalize();
                // impulse in the direction of tangent force
                var jt = rv.dot(t) / (invMassA + invMassB + raNormal * raNormal * invMoiA + rbNormal * rbNormal * invMoiB);
                var frictionImpulse = new Algebra_4.Vector(0, 0);
                if (Math.abs(jt) <= impulse * coefFriction) {
                    frictionImpulse = t.scale(jt).negate();
                }
                else {
                    frictionImpulse = t.scale(-impulse * coefFriction);
                }
                if (bodyA.actor.collisionType === Actor_1.CollisionType.Fixed) {
                    // apply frictional impulse
                    bodyB.vel = bodyB.vel.add(frictionImpulse.scale(invMassB));
                    if (Physics_1.Physics.allowRigidBodyRotation) {
                        bodyB.rx += frictionImpulse.dot(t) * invMoiB * rb.cross(t);
                    }
                }
                else if (bodyB.actor.collisionType === Actor_1.CollisionType.Fixed) {
                    // apply frictional impulse
                    bodyA.vel = bodyA.vel.sub(frictionImpulse.scale(invMassA));
                    if (Physics_1.Physics.allowRigidBodyRotation) {
                        bodyA.rx -= frictionImpulse.dot(t) * invMoiA * ra.cross(t);
                    }
                }
                else {
                    // apply frictional impulse
                    bodyB.vel = bodyB.vel.add(frictionImpulse.scale(invMassB));
                    bodyA.vel = bodyA.vel.sub(frictionImpulse.scale(invMassA));
                    // apply frictional impulse
                    if (Physics_1.Physics.allowRigidBodyRotation) {
                        bodyB.rx += frictionImpulse.dot(t) * invMoiB * rb.cross(t);
                        bodyA.rx -= frictionImpulse.dot(t) * invMoiA * ra.cross(t);
                    }
                }
            }
            bodyA.actor.emit('postcollision', new Events_1.PostCollisionEvent(this.bodyA.body.actor, this.bodyB.body.actor, side, this.mtv));
            bodyB.actor.emit('postcollision', new Events_1.PostCollisionEvent(this.bodyB.body.actor, this.bodyA.body.actor, Util.getOppositeSide(side), this.mtv.negate()));
        };
        return CollisionContact;
    }());
    exports.CollisionContact = CollisionContact;
});
define("Collision/ICollisionArea", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Collision/CircleArea", ["require", "exports", "Collision/BoundingBox", "Collision/PolygonArea", "Collision/EdgeArea", "Collision/CollisionJumpTable", "Algebra", "Physics", "Drawing/Color"], function (require, exports, BoundingBox_1, PolygonArea_1, EdgeArea_1, CollisionJumpTable_1, Algebra_5, Physics_2, Color_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * This is a circle collision area for the excalibur rigid body physics simulation
     */
    var CircleArea = (function () {
        function CircleArea(options) {
            /**
             * This is the center position of the circle, relative to the body position
             */
            this.pos = Algebra_5.Vector.Zero.clone();
            this.pos = options.pos || Algebra_5.Vector.Zero.clone();
            this.radius = options.radius || 0;
            this.body = options.body || null;
        }
        /**
         * Get the center of the collision area in world coordinates
         */
        CircleArea.prototype.getCenter = function () {
            if (this.body) {
                return this.pos.add(this.body.pos);
            }
            return this.pos;
        };
        /**
         * Tests if a point is contained in this collision area
         */
        CircleArea.prototype.contains = function (point) {
            var distance = this.body.pos.distance(point);
            if (distance <= this.radius) {
                return true;
            }
            return false;
        };
        /**
         * Casts a ray at the CircleArea and returns the nearest point of collision
         * @param ray
         */
        CircleArea.prototype.rayCast = function (ray, max) {
            if (max === void 0) { max = Infinity; }
            //https://en.wikipedia.org/wiki/Line%E2%80%93sphere_intersection
            var c = this.getCenter();
            var dir = ray.dir;
            var orig = ray.pos;
            var discriminant = Math.sqrt(Math.pow(dir.dot(orig.sub(c)), 2) -
                Math.pow(orig.sub(c).distance(), 2) +
                Math.pow(this.radius, 2));
            if (discriminant < 0) {
                // no intersection
                return null;
            }
            else {
                var toi = 0;
                if (discriminant === 0) {
                    toi = -dir.dot(orig.sub(c));
                    if (toi > 0 && toi < max) {
                        return ray.getPoint(toi);
                    }
                    return null;
                }
                else {
                    var toi1 = -dir.dot(orig.sub(c)) + discriminant;
                    var toi2 = -dir.dot(orig.sub(c)) - discriminant;
                    var mintoi = Math.min(toi1, toi2);
                    if (mintoi <= max) {
                        return ray.getPoint(mintoi);
                    }
                    return null;
                }
            }
        };
        /**
         * @inheritdoc
         */
        CircleArea.prototype.collide = function (area) {
            if (area instanceof CircleArea) {
                return CollisionJumpTable_1.CollisionJumpTable.CollideCircleCircle(this, area);
            }
            else if (area instanceof PolygonArea_1.PolygonArea) {
                return CollisionJumpTable_1.CollisionJumpTable.CollideCirclePolygon(this, area);
            }
            else if (area instanceof EdgeArea_1.EdgeArea) {
                return CollisionJumpTable_1.CollisionJumpTable.CollideCircleEdge(this, area);
            }
            else {
                throw new Error("Circle could not collide with unknown ICollisionArea " + typeof area);
            }
        };
        /**
         * Find the point on the shape furthest in the direction specified
         */
        CircleArea.prototype.getFurthestPoint = function (direction) {
            return this.getCenter().add(direction.normalize().scale(this.radius));
        };
        /**
         * Get the axis aligned bounding box for the circle area
         */
        CircleArea.prototype.getBounds = function () {
            return new BoundingBox_1.BoundingBox(this.pos.x + this.body.pos.x - this.radius, this.pos.y + this.body.pos.y - this.radius, this.pos.x + this.body.pos.x + this.radius, this.pos.y + this.body.pos.y + this.radius);
        };
        /**
         * Get axis not implemented on circles, since there are infinite axis in a circle
         */
        CircleArea.prototype.getAxes = function () {
            return null;
        };
        /**
         * Returns the moment of inertia of a circle given it's mass
         * https://en.wikipedia.org/wiki/List_of_moments_of_inertia
         */
        CircleArea.prototype.getMomentOfInertia = function () {
            var mass = this.body ? this.body.mass : Physics_2.Physics.defaultMass;
            return (mass * this.radius * this.radius) / 2;
        };
        /**
         * Tests the separating axis theorem for circles against polygons
         */
        CircleArea.prototype.testSeparatingAxisTheorem = function (polygon) {
            var axes = polygon.getAxes();
            var pc = polygon.getCenter();
            // Special SAT with circles
            var closestPointOnPoly = polygon.getFurthestPoint(this.pos.sub(pc));
            axes.push(this.pos.sub(closestPointOnPoly).normalize());
            var minOverlap = Number.MAX_VALUE;
            var minAxis = null;
            var minIndex = -1;
            for (var i = 0; i < axes.length; i++) {
                var proj1 = polygon.project(axes[i]);
                var proj2 = this.project(axes[i]);
                var overlap = proj1.getOverlap(proj2);
                if (overlap <= 0) {
                    return null;
                }
                else {
                    if (overlap < minOverlap) {
                        minOverlap = overlap;
                        minAxis = axes[i];
                        minIndex = i;
                    }
                }
            }
            if (minIndex < 0) {
                return null;
            }
            return minAxis.normalize().scale(minOverlap);
        };
        /* istanbul ignore next */
        CircleArea.prototype.recalc = function () {
            // circles don't cache
        };
        /**
         * Project the circle along a specified axis
         */
        CircleArea.prototype.project = function (axis) {
            var scalars = [];
            var point = this.getCenter();
            var dotProduct = point.dot(axis);
            scalars.push(dotProduct);
            scalars.push(dotProduct + this.radius);
            scalars.push(dotProduct - this.radius);
            return new Algebra_5.Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));
        };
        /* istanbul ignore next */
        CircleArea.prototype.debugDraw = function (ctx, color) {
            if (color === void 0) { color = Color_1.Color.Green.clone(); }
            var pos = this.body ? this.body.pos.add(this.pos) : this.pos;
            var rotation = this.body ? this.body.rotation : 0;
            ctx.beginPath();
            ctx.strokeStyle = color.toString();
            ctx.arc(pos.x, pos.y, this.radius, 0, Math.PI * 2);
            ctx.closePath();
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(pos.x, pos.y);
            ctx.lineTo(Math.cos(rotation) * this.radius + pos.x, Math.sin(rotation) * this.radius + pos.y);
            ctx.closePath();
            ctx.stroke();
        };
        return CircleArea;
    }());
    exports.CircleArea = CircleArea;
});
define("Collision/CollisionJumpTable", ["require", "exports", "Collision/CollisionContact", "Collision/PolygonArea"], function (require, exports, CollisionContact_1, PolygonArea_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CollisionJumpTable = {
        CollideCircleCircle: function (circleA, circleB) {
            var radius = circleA.radius + circleB.radius;
            var circleAPos = circleA.body.pos.add(circleA.pos);
            var circleBPos = circleB.body.pos.add(circleB.pos);
            if (circleAPos.distance(circleBPos) > radius) {
                return null;
            }
            var axisOfCollision = circleBPos.sub(circleAPos).normalize();
            var mvt = axisOfCollision.scale(radius - circleBPos.distance(circleAPos));
            var pointOfCollision = circleA.getFurthestPoint(axisOfCollision);
            return new CollisionContact_1.CollisionContact(circleA, circleB, mvt, pointOfCollision, axisOfCollision);
        },
        CollideCirclePolygon: function (circle, polygon) {
            var minAxis = circle.testSeparatingAxisTheorem(polygon);
            if (!minAxis) {
                return null;
            }
            // make sure that the minAxis is pointing away from circle
            var samedir = minAxis.dot(polygon.getCenter().sub(circle.getCenter()));
            minAxis = samedir < 0 ? minAxis.negate() : minAxis;
            var verts = [];
            var point1 = polygon.getFurthestPoint(minAxis.negate());
            var point2 = circle.getFurthestPoint(minAxis); //.add(cc);
            if (circle.contains(point1)) {
                verts.push(point1);
            }
            if (polygon.contains(point2)) {
                verts.push(point2);
            }
            if (verts.length === 0) {
                return null;
            }
            return new CollisionContact_1.CollisionContact(circle, polygon, minAxis, verts.length === 2 ? verts[0].average(verts[1]) : verts[0], minAxis.normalize());
        },
        CollideCircleEdge: function (circle, edge) {
            // center of the circle
            var cc = circle.getCenter();
            // vector in the direction of the edge
            var e = edge.end.sub(edge.begin);
            // amount of overlap with the circle's center along the edge direction
            var u = e.dot(edge.end.sub(cc));
            var v = e.dot(cc.sub(edge.begin));
            // Potential region A collision (circle is on the left side of the edge, before the beginning)
            if (v <= 0) {
                var da = edge.begin.sub(cc);
                var dda = da.dot(da); // quick and dirty way of calc'n distance in r^2 terms saves some sqrts
                // save some sqrts
                if (dda > circle.radius * circle.radius) {
                    return null; // no collision
                }
                return new CollisionContact_1.CollisionContact(circle, edge, da.normalize().scale(circle.radius - Math.sqrt(dda)), edge.begin, da.normalize());
            }
            // Potential region B collision (circle is on the right side of the edge, after the end)
            if (u <= 0) {
                var db = edge.end.sub(cc);
                var ddb = db.dot(db);
                if (ddb > circle.radius * circle.radius) {
                    return null;
                }
                return new CollisionContact_1.CollisionContact(circle, edge, db.normalize().scale(circle.radius - Math.sqrt(ddb)), edge.end, db.normalize());
            }
            // Otherwise potential region AB collision (circle is in the middle of the edge between the beginning and end)
            var den = e.dot(e);
            var pointOnEdge = (edge.begin.scale(u).add(edge.end.scale(v))).scale(1 / den);
            var d = cc.sub(pointOnEdge);
            var dd = d.dot(d);
            if (dd > circle.radius * circle.radius) {
                return null; // no collision
            }
            var n = e.perpendicular();
            // flip correct direction
            if (n.dot(cc.sub(edge.begin)) < 0) {
                n.x = -n.x;
                n.y = -n.y;
            }
            n = n.normalize();
            var mvt = n.scale(Math.abs(circle.radius - Math.sqrt(dd)));
            return new CollisionContact_1.CollisionContact(circle, edge, mvt.negate(), pointOnEdge, n.negate());
        },
        CollideEdgeEdge: function () {
            // Edge-edge collision doesn't make sense
            return null;
        },
        CollidePolygonEdge: function (polygon, edge) {
            // 3 cases:
            // (1) Polygon lands on the full face
            // (2) Polygon lands on the right point
            // (3) Polygon lands on the left point
            var e = edge.end.sub(edge.begin);
            var edgeNormal = e.normal();
            if (polygon.contains(edge.begin)) {
                var _a = polygon.getClosestFace(edge.begin), mtv = _a.distance, face = _a.face;
                if (mtv) {
                    return new CollisionContact_1.CollisionContact(polygon, edge, mtv.negate(), edge.begin.add(mtv.negate()), face.normal().negate());
                }
            }
            if (polygon.contains(edge.end)) {
                var _b = polygon.getClosestFace(edge.end), mtv = _b.distance, face = _b.face;
                if (mtv) {
                    return new CollisionContact_1.CollisionContact(polygon, edge, mtv.negate(), edge.end.add(mtv.negate()), face.normal().negate());
                }
            }
            var pc = polygon.getCenter();
            var ec = edge.getCenter();
            var dir = ec.sub(pc).normalize();
            // build a temporary polygon from the edge to use SAT
            var linePoly = new PolygonArea_2.PolygonArea({
                points: [
                    edge.begin,
                    edge.end,
                    edge.end.add(dir.scale(30)),
                    edge.begin.add(dir.scale(30))
                ]
            });
            var minAxis = polygon.testSeparatingAxisTheorem(linePoly);
            // no minAxis, no overlap, no collision
            if (!minAxis) {
                return null;
            }
            // flip the normal and axis to always have positive collisions
            edgeNormal = edgeNormal.dot(dir) < 0 ? edgeNormal.negate() : edgeNormal;
            minAxis = minAxis.dot(dir) < 0 ? minAxis.negate() : minAxis;
            return new CollisionContact_1.CollisionContact(polygon, edge, minAxis, polygon.getFurthestPoint(edgeNormal), edgeNormal);
        },
        CollidePolygonPolygon: function (polyA, polyB) {
            // do a SAT test to find a min axis if it exists
            var minAxis = polyA.testSeparatingAxisTheorem(polyB);
            // no overlap, no collision return null
            if (!minAxis) {
                return null;
            }
            // make sure that minAxis is pointing from A -> B
            var sameDir = minAxis.dot(polyB.getCenter().sub(polyA.getCenter()));
            minAxis = sameDir < 0 ? minAxis.negate() : minAxis;
            // find rough point of collision
            // todo this could be better
            var verts = [];
            var pointA = polyA.getFurthestPoint(minAxis);
            var pointB = polyB.getFurthestPoint(minAxis.negate());
            if (polyB.contains(pointA)) {
                verts.push(pointA);
            }
            if (polyA.contains(pointB)) {
                verts.push(pointB);
            }
            // no candidates, pick something
            if (verts.length === 0) {
                verts.push(pointB);
            }
            var contact = verts.length === 2 ? verts[0].add(verts[1]).scale(.5) : verts[0];
            return new CollisionContact_1.CollisionContact(polyA, polyB, minAxis, contact, minAxis.normalize());
        }
    };
});
define("Collision/PolygonArea", ["require", "exports", "Drawing/Color", "Physics", "Collision/BoundingBox", "Collision/EdgeArea", "Collision/CollisionJumpTable", "Collision/CircleArea", "Algebra"], function (require, exports, Color_2, Physics_3, BoundingBox_2, EdgeArea_2, CollisionJumpTable_2, CircleArea_1, Algebra_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Polygon collision area for detecting collisions for actors, or independently
     */
    var PolygonArea = (function () {
        function PolygonArea(options) {
            this._transformedPoints = [];
            this._axes = [];
            this._sides = [];
            this.pos = options.pos || Algebra_6.Vector.Zero.clone();
            var winding = !!options.clockwiseWinding;
            this.points = (winding ? options.points.reverse() : options.points) || [];
            this.body = options.body || null;
            // calculate initial transformation
            this._calculateTransformation();
        }
        /**
         * Get the center of the collision area in world coordinates
         */
        PolygonArea.prototype.getCenter = function () {
            if (this.body) {
                return this.body.pos.add(this.pos);
            }
            return this.pos;
        };
        /**
         * Calculates the underlying transformation from the body relative space to world space
         */
        PolygonArea.prototype._calculateTransformation = function () {
            var pos = this.body ? this.body.pos.add(this.pos) : this.pos;
            var angle = this.body ? this.body.rotation : 0;
            var len = this.points.length;
            this._transformedPoints.length = 0; // clear out old transform
            for (var i = 0; i < len; i++) {
                this._transformedPoints[i] = this.points[i].rotate(angle).add(pos);
            }
        };
        /**
         * Gets the points that make up the polygon in world space, from actor relative space (if specified)
         */
        PolygonArea.prototype.getTransformedPoints = function () {
            if (!this._transformedPoints.length) {
                this._calculateTransformation();
            }
            ;
            return this._transformedPoints;
        };
        /**
         * Gets the sides of the polygon in world space
         */
        PolygonArea.prototype.getSides = function () {
            if (this._sides.length) {
                return this._sides;
            }
            var lines = [];
            var points = this.getTransformedPoints();
            var len = points.length;
            for (var i = 0; i < len; i++) {
                lines.push(new Algebra_6.Line(points[i], points[(i - 1 + len) % len]));
            }
            this._sides = lines;
            return this._sides;
        };
        PolygonArea.prototype.recalc = function () {
            this._sides.length = 0;
            this._axes.length = 0;
            this._transformedPoints.length = 0;
            this.getTransformedPoints();
            this.getAxes();
            this.getSides();
        };
        /**
         * Tests if a point is contained in this collision area in world space
         */
        PolygonArea.prototype.contains = function (point) {
            // Always cast to the right, as long as we cast in a consitent fixed direction we
            // will be fine
            var testRay = new Algebra_6.Ray(point, new Algebra_6.Vector(1, 0));
            var intersectCount = this.getSides().reduce(function (accum, side) {
                if (testRay.intersect(side) >= 0) {
                    return accum + 1;
                }
                return accum;
            }, 0);
            if (intersectCount % 2 === 0) {
                return false;
            }
            return true;
        };
        /**
         * Returns a collision contact if the 2 collision areas collide, otherwise collide will
         * return null.
         * @param area
         */
        PolygonArea.prototype.collide = function (area) {
            if (area instanceof CircleArea_1.CircleArea) {
                return CollisionJumpTable_2.CollisionJumpTable.CollideCirclePolygon(area, this);
            }
            else if (area instanceof PolygonArea) {
                return CollisionJumpTable_2.CollisionJumpTable.CollidePolygonPolygon(this, area);
            }
            else if (area instanceof EdgeArea_2.EdgeArea) {
                return CollisionJumpTable_2.CollisionJumpTable.CollidePolygonEdge(this, area);
            }
            else {
                throw new Error("Polygon could not collide with unknown ICollisionArea " + typeof area);
            }
        };
        /**
         * Find the point on the shape furthest in the direction specified
         */
        PolygonArea.prototype.getFurthestPoint = function (direction) {
            var pts = this.getTransformedPoints();
            var furthestPoint = null;
            var maxDistance = -Number.MAX_VALUE;
            for (var i = 0; i < pts.length; i++) {
                var distance = direction.dot(pts[i]);
                if (distance > maxDistance) {
                    maxDistance = distance;
                    furthestPoint = pts[i];
                }
            }
            return furthestPoint;
        };
        /**
         * Finds the closes face to the point using perpendicular distance
         * @param point point to test against polygon
         */
        PolygonArea.prototype.getClosestFace = function (point) {
            var sides = this.getSides();
            var min = Number.POSITIVE_INFINITY;
            var faceIndex = -1;
            var distance = -1;
            for (var i = 0; i < sides.length; i++) {
                var dist = sides[i].distanceToPoint(point);
                if (dist < min) {
                    min = dist;
                    faceIndex = i;
                    distance = dist;
                }
            }
            if (faceIndex !== -1) {
                return {
                    distance: sides[faceIndex].normal().scale(distance),
                    face: sides[faceIndex]
                };
            }
            return null;
        };
        /**
         * Get the axis aligned bounding box for the polygon area
         */
        PolygonArea.prototype.getBounds = function () {
            // todo there is a faster way to do this
            var points = this.getTransformedPoints();
            var minX = points.reduce(function (prev, curr) {
                return Math.min(prev, curr.x);
            }, 999999999);
            var maxX = points.reduce(function (prev, curr) {
                return Math.max(prev, curr.x);
            }, -99999999);
            var minY = points.reduce(function (prev, curr) {
                return Math.min(prev, curr.y);
            }, 9999999999);
            var maxY = points.reduce(function (prev, curr) {
                return Math.max(prev, curr.y);
            }, -9999999999);
            return new BoundingBox_2.BoundingBox(minX, minY, maxX, maxY);
        };
        /**
         * Get the moment of inertia for an arbitrary polygon
         * https://en.wikipedia.org/wiki/List_of_moments_of_inertia
         */
        PolygonArea.prototype.getMomentOfInertia = function () {
            var mass = this.body ? this.body.mass : Physics_3.Physics.defaultMass;
            var numerator = 0;
            var denominator = 0;
            for (var i = 0; i < this.points.length; i++) {
                var iplusone = (i + 1) % this.points.length;
                var crossTerm = this.points[iplusone].cross(this.points[i]);
                numerator += crossTerm * (this.points[i].dot(this.points[i]) +
                    this.points[i].dot(this.points[iplusone]) +
                    this.points[iplusone].dot(this.points[iplusone]));
                denominator += crossTerm;
            }
            return (mass / 6) * (numerator / denominator);
        };
        /**
         * Casts a ray into the polygon and returns a vector representing the point of contact (in world space) or null if no collision.
         */
        PolygonArea.prototype.rayCast = function (ray, max) {
            if (max === void 0) { max = Infinity; }
            // find the minimum contact time greater than 0
            // contact times less than 0 are behind the ray and we don't want those
            var sides = this.getSides();
            var len = sides.length;
            var minContactTime = Number.MAX_VALUE;
            var contactIndex = -1;
            for (var i = 0; i < len; i++) {
                var contactTime = ray.intersect(sides[i]);
                if (contactTime >= 0 && contactTime < minContactTime && contactTime <= max) {
                    minContactTime = contactTime;
                    contactIndex = i;
                }
            }
            // contact was found
            if (contactIndex >= 0) {
                return ray.getPoint(minContactTime);
            }
            // no contact found
            return null;
        };
        /**
         * Get the axis associated with the edge
         */
        PolygonArea.prototype.getAxes = function () {
            if (this._axes.length) {
                return this._axes;
            }
            var axes = [];
            var points = this.getTransformedPoints();
            var len = points.length;
            for (var i = 0; i < len; i++) {
                axes.push(points[i].sub(points[(i + 1) % len]).normal());
            }
            this._axes = axes;
            return this._axes;
        };
        /**
         * Perform Separating Axis test against another polygon, returns null if no overlap in polys
         * Reference http://www.dyn4j.org/2010/01/sat/
         */
        PolygonArea.prototype.testSeparatingAxisTheorem = function (other) {
            var poly1 = this;
            var poly2 = other;
            var axes = poly1.getAxes().concat(poly2.getAxes());
            var minOverlap = Number.MAX_VALUE;
            var minAxis = null;
            var minIndex = -1;
            for (var i = 0; i < axes.length; i++) {
                var proj1 = poly1.project(axes[i]);
                var proj2 = poly2.project(axes[i]);
                var overlap = proj1.getOverlap(proj2);
                if (overlap <= 0) {
                    return null;
                }
                else {
                    if (overlap < minOverlap) {
                        minOverlap = overlap;
                        minAxis = axes[i];
                        minIndex = i;
                    }
                }
            }
            // Sanity check
            if (minIndex === -1) {
                return null;
            }
            return minAxis.normalize().scale(minOverlap);
        };
        /**
         * Project the edges of the polygon along a specified axis
         */
        PolygonArea.prototype.project = function (axis) {
            var points = this.getTransformedPoints();
            var len = points.length;
            var min = Number.MAX_VALUE;
            var max = -Number.MAX_VALUE;
            for (var i = 0; i < len; i++) {
                var scalar = points[i].dot(axis);
                min = Math.min(min, scalar);
                max = Math.max(max, scalar);
            }
            return new Algebra_6.Projection(min, max);
        };
        /* istanbul ignore next */
        PolygonArea.prototype.debugDraw = function (ctx, color) {
            if (color === void 0) { color = Color_2.Color.Red.clone(); }
            ctx.beginPath();
            ctx.strokeStyle = color.toString();
            // Iterate through the supplied points and construct a 'polygon'
            var firstPoint = this.getTransformedPoints()[0];
            ctx.moveTo(firstPoint.x, firstPoint.y);
            this.getTransformedPoints().forEach(function (point) {
                ctx.lineTo(point.x, point.y);
            });
            ctx.lineTo(firstPoint.x, firstPoint.y);
            ctx.closePath();
            ctx.stroke();
        };
        return PolygonArea;
    }());
    exports.PolygonArea = PolygonArea;
});
define("Collision/BoundingBox", ["require", "exports", "Collision/PolygonArea", "Algebra", "Drawing/Color"], function (require, exports, PolygonArea_3, Algebra_7, Color_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Axis Aligned collision primitive for Excalibur.
     */
    var BoundingBox = (function () {
        /**
         * @param left    x coordinate of the left edge
         * @param top     y coordinate of the top edge
         * @param right   x coordinate of the right edge
         * @param bottom  y coordinate of the bottom edge
         */
        function BoundingBox(left, top, right, bottom) {
            if (left === void 0) { left = 0; }
            if (top === void 0) { top = 0; }
            if (right === void 0) { right = 0; }
            if (bottom === void 0) { bottom = 0; }
            this.left = left;
            this.top = top;
            this.right = right;
            this.bottom = bottom;
        }
        BoundingBox.fromPoints = function (points) {
            var minX = Infinity;
            var minY = Infinity;
            var maxX = -Infinity;
            var maxY = -Infinity;
            for (var i = 0; i < points.length; i++) {
                if (points[i].x < minX) {
                    minX = points[i].x;
                }
                if (points[i].x > maxX) {
                    maxX = points[i].x;
                }
                if (points[i].y < minY) {
                    minY = points[i].y;
                }
                if (points[i].y > maxY) {
                    maxY = points[i].y;
                }
            }
            return new BoundingBox(minX, minY, maxX, maxY);
        };
        /**
         * Returns the calculated width of the bounding box
         */
        BoundingBox.prototype.getWidth = function () {
            return this.right - this.left;
        };
        /**
         * Returns the calculated height of the bounding box
         */
        BoundingBox.prototype.getHeight = function () {
            return this.bottom - this.top;
        };
        /**
         * Rotates a bounding box by and angle and around a point, if no point is specified (0, 0) is used by default
         */
        BoundingBox.prototype.rotate = function (angle, point) {
            if (point === void 0) { point = Algebra_7.Vector.Zero.clone(); }
            var points = this.getPoints().map(function (p) { return p.rotate(angle, point); });
            return BoundingBox.fromPoints(points);
        };
        /**
         * Returns the perimeter of the bounding box
         */
        BoundingBox.prototype.getPerimeter = function () {
            var wx = this.getWidth();
            var wy = this.getHeight();
            return 2 * (wx + wy);
        };
        BoundingBox.prototype.getPoints = function () {
            var results = [];
            results.push(new Algebra_7.Vector(this.left, this.top));
            results.push(new Algebra_7.Vector(this.right, this.top));
            results.push(new Algebra_7.Vector(this.right, this.bottom));
            results.push(new Algebra_7.Vector(this.left, this.bottom));
            return results;
        };
        /**
         * Creates a Polygon collision area from the points of the bounding box
         */
        BoundingBox.prototype.toPolygon = function (actor) {
            return new PolygonArea_3.PolygonArea({
                body: actor ? actor.body : null,
                points: this.getPoints(),
                pos: Algebra_7.Vector.Zero.clone()
            });
        };
        /**
         * Determines whether a ray intersects with a bounding box
         */
        BoundingBox.prototype.rayCast = function (ray, farClipDistance) {
            if (farClipDistance === void 0) { farClipDistance = Infinity; }
            // algorithm from https://tavianator.com/fast-branchless-raybounding-box-intersections/ 
            var tmin = -Infinity;
            var tmax = +Infinity;
            var xinv = ray.dir.x === 0 ? Number.MAX_VALUE : (1 / ray.dir.x);
            var yinv = ray.dir.y === 0 ? Number.MAX_VALUE : (1 / ray.dir.y);
            var tx1 = (this.left - ray.pos.x) * xinv;
            var tx2 = (this.right - ray.pos.x) * xinv;
            tmin = Math.min(tx1, tx2);
            tmax = Math.max(tx1, tx2);
            var ty1 = (this.top - ray.pos.y) * yinv;
            var ty2 = (this.bottom - ray.pos.y) * yinv;
            tmin = Math.max(tmin, Math.min(ty1, ty2));
            tmax = Math.min(tmax, Math.max(ty1, ty2));
            return tmax >= Math.max(0, tmin) && tmin < farClipDistance;
        };
        BoundingBox.prototype.rayCastTime = function (ray, farClipDistance) {
            if (farClipDistance === void 0) { farClipDistance = Infinity; }
            // algorithm from https://tavianator.com/fast-branchless-raybounding-box-intersections/ 
            var tmin = -Infinity;
            var tmax = +Infinity;
            var xinv = ray.dir.x === 0 ? Number.MAX_VALUE : (1 / ray.dir.x);
            var yinv = ray.dir.y === 0 ? Number.MAX_VALUE : (1 / ray.dir.y);
            var tx1 = (this.left - ray.pos.x) * xinv;
            var tx2 = (this.right - ray.pos.x) * xinv;
            tmin = Math.min(tx1, tx2);
            tmax = Math.max(tx1, tx2);
            var ty1 = (this.top - ray.pos.y) * yinv;
            var ty2 = (this.bottom - ray.pos.y) * yinv;
            tmin = Math.max(tmin, Math.min(ty1, ty2));
            tmax = Math.min(tmax, Math.max(ty1, ty2));
            if (tmax >= Math.max(0, tmin) && tmin < farClipDistance) {
                return tmin;
            }
            return -1;
        };
        BoundingBox.prototype.contains = function (val) {
            if (val instanceof Algebra_7.Vector) {
                return (this.left <= val.x && this.top <= val.y && this.bottom >= val.y && this.right >= val.x);
            }
            else if (val instanceof BoundingBox) {
                if (this.left < val.left &&
                    this.top < val.top &&
                    val.bottom < this.bottom &&
                    val.right < this.right) {
                    return true;
                }
                return false;
            }
            return false;
        };
        /**
         * Combines this bounding box and another together returning a new bounding box
         * @param other  The bounding box to combine
         */
        BoundingBox.prototype.combine = function (other) {
            var compositeBB = new BoundingBox(Math.min(this.left, other.left), Math.min(this.top, other.top), Math.max(this.right, other.right), Math.max(this.bottom, other.bottom));
            return compositeBB;
        };
        /**
         * Test wether this bounding box collides with another returning,
         * the intersection vector that can be used to resolve the collision. If there
         * is no collision null is returned.
         * @param collidable  Other collidable to test
         */
        BoundingBox.prototype.collides = function (collidable) {
            if (collidable instanceof BoundingBox) {
                var other = collidable;
                var totalBoundingBox = this.combine(other);
                // If the total bounding box is less than the sum of the 2 bounds then there is collision
                if (totalBoundingBox.getWidth() < other.getWidth() + this.getWidth() &&
                    totalBoundingBox.getHeight() < other.getHeight() + this.getHeight()) {
                    // collision
                    var overlapX = 0;
                    if (this.right >= other.left && this.right <= other.right) {
                        overlapX = other.left - this.right;
                    }
                    else {
                        overlapX = other.right - this.left;
                    }
                    var overlapY = 0;
                    if (this.top <= other.bottom && this.top >= other.top) {
                        overlapY = other.bottom - this.top;
                    }
                    else {
                        overlapY = other.top - this.bottom;
                    }
                    if (Math.abs(overlapX) < Math.abs(overlapY)) {
                        return new Algebra_7.Vector(overlapX, 0);
                    }
                    else {
                        return new Algebra_7.Vector(0, overlapY);
                    }
                }
                else {
                    return null;
                }
            }
            return null;
        };
        /* istanbul ignore next */
        BoundingBox.prototype.debugDraw = function (ctx, color) {
            if (color === void 0) { color = Color_3.Color.Yellow; }
            ctx.strokeStyle = color.toString();
            ctx.strokeRect(this.left, this.top, this.getWidth(), this.getHeight());
        };
        return BoundingBox;
    }());
    exports.BoundingBox = BoundingBox;
});
define("Collision/EdgeArea", ["require", "exports", "Collision/BoundingBox", "Collision/CollisionJumpTable", "Collision/CircleArea", "Collision/PolygonArea", "Algebra", "Physics", "Drawing/Color"], function (require, exports, BoundingBox_3, CollisionJumpTable_3, CircleArea_2, PolygonArea_4, Algebra_8, Physics_4, Color_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var EdgeArea = (function () {
        function EdgeArea(options) {
            this.begin = options.begin || Algebra_8.Vector.Zero.clone();
            this.end = options.end || Algebra_8.Vector.Zero.clone();
            this.body = options.body || null;
            this.pos = this.getCenter();
        }
        /**
         * Get the center of the collision area in world coordinates
         */
        EdgeArea.prototype.getCenter = function () {
            var pos = this.begin.average(this.end).add(this._getBodyPos());
            return pos;
        };
        EdgeArea.prototype._getBodyPos = function () {
            var bodyPos = Algebra_8.Vector.Zero.clone();
            if (this.body.pos) {
                bodyPos = this.body.pos;
            }
            return bodyPos;
        };
        EdgeArea.prototype._getTransformedBegin = function () {
            var angle = this.body ? this.body.rotation : 0;
            return this.begin.rotate(angle).add(this._getBodyPos());
        };
        EdgeArea.prototype._getTransformedEnd = function () {
            var angle = this.body ? this.body.rotation : 0;
            return this.end.rotate(angle).add(this._getBodyPos());
        };
        /**
         * Returns the slope of the line in the form of a vector
         */
        EdgeArea.prototype.getSlope = function () {
            var begin = this._getTransformedBegin();
            var end = this._getTransformedEnd();
            var distance = begin.distance(end);
            return end.sub(begin).scale(1 / distance);
        };
        /**
         * Returns the length of the line segment in pixels
         */
        EdgeArea.prototype.getLength = function () {
            var begin = this._getTransformedBegin();
            var end = this._getTransformedEnd();
            var distance = begin.distance(end);
            return distance;
        };
        /**
         * Tests if a point is contained in this collision area
         */
        EdgeArea.prototype.contains = function () {
            return false;
        };
        /**
         * @inheritdoc
         */
        EdgeArea.prototype.rayCast = function (ray, max) {
            if (max === void 0) { max = Infinity; }
            var numerator = this._getTransformedBegin().sub(ray.pos);
            // Test is line and ray are parallel and non intersecting
            if (ray.dir.cross(this.getSlope()) === 0 && numerator.cross(ray.dir) !== 0) {
                return null;
            }
            // Lines are parallel
            var divisor = (ray.dir.cross(this.getSlope()));
            if (divisor === 0) {
                return null;
            }
            var t = numerator.cross(this.getSlope()) / divisor;
            if (t >= 0 && t <= max) {
                var u = (numerator.cross(ray.dir) / divisor) / this.getLength();
                if (u >= 0 && u <= 1) {
                    return ray.getPoint(t);
                }
            }
            return null;
        };
        /**
         * @inheritdoc
         */
        EdgeArea.prototype.collide = function (area) {
            if (area instanceof CircleArea_2.CircleArea) {
                return CollisionJumpTable_3.CollisionJumpTable.CollideCircleEdge(area, this);
            }
            else if (area instanceof PolygonArea_4.PolygonArea) {
                return CollisionJumpTable_3.CollisionJumpTable.CollidePolygonEdge(area, this);
            }
            else if (area instanceof EdgeArea) {
                return CollisionJumpTable_3.CollisionJumpTable.CollideEdgeEdge();
            }
            else {
                throw new Error("Edge could not collide with unknown ICollisionArea " + typeof area);
            }
        };
        /**
         * Find the point on the shape furthest in the direction specified
         */
        EdgeArea.prototype.getFurthestPoint = function (direction) {
            var transformedBegin = this._getTransformedBegin();
            var transformedEnd = this._getTransformedEnd();
            if (direction.dot(transformedBegin) > 0) {
                return transformedBegin;
            }
            else {
                return transformedEnd;
            }
        };
        /**
         * Get the axis aligned bounding box for the circle area
         */
        EdgeArea.prototype.getBounds = function () {
            var transformedBegin = this._getTransformedBegin();
            var transformedEnd = this._getTransformedEnd();
            return new BoundingBox_3.BoundingBox(Math.min(transformedBegin.x, transformedEnd.x), Math.min(transformedBegin.y, transformedEnd.y), Math.max(transformedBegin.x, transformedEnd.x), Math.max(transformedBegin.y, transformedEnd.y));
        };
        /**
         * Get the axis associated with the edge
         */
        EdgeArea.prototype.getAxes = function () {
            var e = this._getTransformedEnd().sub(this._getTransformedBegin());
            var edgeNormal = e.normal();
            var axes = [];
            axes.push(edgeNormal);
            axes.push(edgeNormal.negate());
            axes.push(edgeNormal.normal());
            axes.push(edgeNormal.normal().negate());
            return axes;
        };
        /**
         * Get the moment of inertia for an edge
         * https://en.wikipedia.org/wiki/List_of_moments_of_inertia
         */
        EdgeArea.prototype.getMomentOfInertia = function () {
            var mass = this.body ? this.body.mass : Physics_4.Physics.defaultMass;
            var length = this.end.sub(this.begin).distance() / 2;
            return mass * length * length;
        };
        /**
         * @inheritdoc
         */
        EdgeArea.prototype.recalc = function () {
            // edges don't have any cached data
        };
        /**
         * Project the edge along a specified axis
         */
        EdgeArea.prototype.project = function (axis) {
            var scalars = [];
            var points = [this._getTransformedBegin(), this._getTransformedEnd()];
            var len = points.length;
            for (var i = 0; i < len; i++) {
                scalars.push(points[i].dot(axis));
            }
            return new Algebra_8.Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));
        };
        /* istanbul ignore next */
        EdgeArea.prototype.debugDraw = function (ctx, color) {
            if (color === void 0) { color = Color_4.Color.Red.clone(); }
            ctx.strokeStyle = color.toString();
            ctx.beginPath();
            ctx.moveTo(this.begin.x, this.begin.y);
            ctx.lineTo(this.end.x, this.end.y);
            ctx.closePath();
            ctx.stroke();
        };
        return EdgeArea;
    }());
    exports.EdgeArea = EdgeArea;
});
define("Util/DrawUtil", ["require", "exports", "Drawing/Color"], function (require, exports, Color_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Draw a line on canvas context
     *
     * @param ctx The canvas context
     * @param color The color of the line
     * @param x1 The start x coordinate
     * @param y1 The start y coordinate
     * @param x2 The ending x coordinate
     * @param y2 The ending y coordinate
     * @param thickness The line thickness
     * @param cap The [[LineCapStyle]] (butt, round, or square)
     */
    /* istanbul ignore next */
    function line(ctx, color, x1, y1, x2, y2, thickness, cap) {
        if (color === void 0) { color = Color_5.Color.Red.clone(); }
        if (thickness === void 0) { thickness = 1; }
        if (cap === void 0) { cap = 'butt'; }
        ctx.beginPath();
        ctx.lineWidth = thickness;
        ctx.lineCap = cap;
        ctx.strokeStyle = color.toString();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.closePath();
        ctx.stroke();
    }
    exports.line = line;
    /**
     * Draw the vector as a point onto the canvas.
     */
    /* istanbul ignore next */
    function point(ctx, color, point) {
        if (color === void 0) { color = Color_5.Color.Red.clone(); }
        ctx.beginPath();
        ctx.strokeStyle = color.toString();
        ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
        ctx.closePath();
        ctx.stroke();
    }
    exports.point = point;
    /**
     * Draw the vector as a line onto the canvas starting a origin point.
     */
    /* istanbul ignore next */
    function vector(ctx, color, origin, vector, scale) {
        if (scale === void 0) { scale = 1.0; }
        var c = color ? color.toString() : 'blue';
        var v = vector.scale(scale);
        ctx.beginPath();
        ctx.strokeStyle = c;
        ctx.moveTo(origin.x, origin.y);
        ctx.lineTo(origin.x + v.x, origin.y + v.y);
        ctx.closePath();
        ctx.stroke();
    }
    exports.vector = vector;
    /**
     * Draw a round rectangle on a canvas context
     *
     * @param ctx The canvas context
     * @param x The top-left x coordinate
     * @param y The top-left y coordinate
     * @param width The width of the rectangle
     * @param height The height of the rectangle
     * @param radius The border radius of the rectangle
     * @param fill The [[Color]] to fill rectangle with
     * @param stroke The [[Color]] to stroke rectangle with
     */
    function roundRect(ctx, x, y, width, height, radius, stroke, fill) {
        if (radius === void 0) { radius = 5; }
        if (stroke === void 0) { stroke = Color_5.Color.White; }
        if (fill === void 0) { fill = null; }
        var br;
        if (typeof radius === 'number') {
            br = { tl: radius, tr: radius, br: radius, bl: radius };
        }
        else {
            var defaultRadius = { tl: 0, tr: 0, br: 0, bl: 0 };
            for (var prop in defaultRadius) {
                if (defaultRadius.hasOwnProperty(prop)) {
                    var side = prop;
                    br[side] = radius[side] || defaultRadius[side];
                }
            }
        }
        ctx.beginPath();
        ctx.moveTo(x + br.tl, y);
        ctx.lineTo(x + width - br.tr, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + br.tr);
        ctx.lineTo(x + width, y + height - br.br);
        ctx.quadraticCurveTo(x + width, y + height, x + width - br.br, y + height);
        ctx.lineTo(x + br.bl, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - br.bl);
        ctx.lineTo(x, y + br.tl);
        ctx.quadraticCurveTo(x, y, x + br.tl, y);
        ctx.closePath();
        if (fill) {
            ctx.fillStyle = fill.toString();
            ctx.fill();
        }
        if (stroke) {
            ctx.strokeStyle = stroke.toString();
            ctx.stroke();
        }
    }
    exports.roundRect = roundRect;
    function circle(ctx, x, y, radius, stroke, fill) {
        if (stroke === void 0) { stroke = Color_5.Color.White; }
        if (fill === void 0) { fill = null; }
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.closePath();
        if (fill) {
            ctx.fillStyle = fill.toString();
            ctx.fill();
        }
        if (stroke) {
            ctx.strokeStyle = stroke.toString();
            ctx.stroke();
        }
    }
    exports.circle = circle;
});
define("Collision/Body", ["require", "exports", "Physics", "Collision/EdgeArea", "Collision/CircleArea", "Collision/PolygonArea", "Collision/Pair", "Algebra", "Drawing/Color", "Util/DrawUtil"], function (require, exports, Physics_5, EdgeArea_3, CircleArea_3, PolygonArea_5, Pair_1, Algebra_9, Color_6, DrawUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Body = (function () {
        /**
         * Constructs a new physics body associated with an actor
         */
        function Body(actor) {
            this.actor = actor;
            /**
             * [[ICollisionArea|Collision area]] of this physics body, defines the shape for rigid body collision
             */
            this.collisionArea = null;
            /**
             * The (x, y) position of the actor this will be in the middle of the actor if the
             * [[Actor.anchor]] is set to (0.5, 0.5) which is default.
             * If you want the (x, y) position to be the top left of the actor specify an anchor of (0, 0).
             */
            this.pos = new Algebra_9.Vector(0, 0);
            /**
             * The position of the actor last frame (x, y) in pixels
             */
            this.oldPos = new Algebra_9.Vector(0, 0);
            /**
             * The current velocity vector (vx, vy) of the actor in pixels/second
             */
            this.vel = new Algebra_9.Vector(0, 0);
            /**
             * The velocity of the actor last frame (vx, vy) in pixels/second
             */
            this.oldVel = new Algebra_9.Vector(0, 0);
            /**
             * The curret acceleration vector (ax, ay) of the actor in pixels/second/second. An acceleration pointing down such as (0, 100) may
             * be useful to simulate a gravitational effect.
             */
            this.acc = new Algebra_9.Vector(0, 0);
            /**
             * The current torque applied to the actor
             */
            this.torque = 0;
            /**
             * The current mass of the actor, mass can be thought of as the resistance to acceleration.
             */
            this.mass = 1.0;
            /**
             * The current moment of inertia, moi can be thought of as the resistance to rotation.
             */
            this.moi = 1000;
            /**
             * The current "motion" of the actor, used to calculated sleep in the physics simulation
             */
            this.motion = 10;
            /**
             * The coefficient of friction on this actor
             */
            this.friction = .99;
            /**
             * The coefficient of restitution of this actor, represents the amount of energy preserved after collision
             */
            this.restitution = .2;
            /**
             * The rotation of the actor in radians
             */
            this.rotation = 0; // radians
            /**
             * The rotational velocity of the actor in radians/second
             */
            this.rx = 0; //radians/sec
            this._totalMtv = Algebra_9.Vector.Zero.clone();
        }
        /**
         * Add minimum translation vectors accumulated during the current frame to resolve collisions.
         */
        Body.prototype.addMtv = function (mtv) {
            this._totalMtv.addEqual(mtv);
        };
        /**
         * Applies the accumulated translation vectors to the actors position
         */
        Body.prototype.applyMtv = function () {
            this.pos.addEqual(this._totalMtv);
            this._totalMtv.setTo(0, 0);
        };
        /**
         * Returns the body's [[BoundingBox]] calculated for this instant in world space.
         */
        Body.prototype.getBounds = function () {
            if (Physics_5.Physics.collisionResolutionStrategy === Physics_5.CollisionResolutionStrategy.Box) {
                return this.actor.getBounds();
            }
            else {
                return this.collisionArea.getBounds();
            }
        };
        /**
         * Returns the actor's [[BoundingBox]] relative to the actors position.
         */
        Body.prototype.getRelativeBounds = function () {
            if (Physics_5.Physics.collisionResolutionStrategy === Physics_5.CollisionResolutionStrategy.Box) {
                return this.actor.getRelativeBounds();
            }
            else {
                return this.actor.getRelativeBounds();
            }
        };
        /**
         * Updates the collision area geometry and internal caches
         */
        Body.prototype.update = function () {
            if (this.collisionArea) {
                this.collisionArea.recalc();
            }
        };
        /**
         * Sets up a box collision area based on the current bounds of the associated actor of this physics body.
         *
         * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
         */
        Body.prototype.useBoxCollision = function (center) {
            if (center === void 0) { center = Algebra_9.Vector.Zero.clone(); }
            this.collisionArea = new PolygonArea_5.PolygonArea({
                body: this,
                points: this.actor.getRelativeBounds().getPoints(),
                pos: center // position relative to actor
            });
            // in case of a nan moi, coalesce to a safe default
            this.moi = this.collisionArea.getMomentOfInertia() || this.moi;
        };
        /**
         * Sets up a polygon collision area based on a list of of points relative to the anchor of the associated actor of this physics body.
         *
         * Only [convex polygon](https://en.wikipedia.org/wiki/Convex_polygon) definitions are supported.
         *
         * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
         */
        Body.prototype.usePolygonCollision = function (points, center) {
            if (center === void 0) { center = Algebra_9.Vector.Zero.clone(); }
            this.collisionArea = new PolygonArea_5.PolygonArea({
                body: this,
                points: points,
                pos: center // position relative to actor
            });
            // in case of a nan moi, collesce to a safe default
            this.moi = this.collisionArea.getMomentOfInertia() || this.moi;
        };
        /**
         * Sets up a [[CircleArea|circle collision area]] with a specified radius in pixels.
         *
         * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
         */
        Body.prototype.useCircleCollision = function (radius, center) {
            if (center === void 0) { center = Algebra_9.Vector.Zero.clone(); }
            if (!radius) {
                radius = this.actor.getWidth() / 2;
            }
            this.collisionArea = new CircleArea_3.CircleArea({
                body: this,
                radius: radius,
                pos: center
            });
            this.moi = this.collisionArea.getMomentOfInertia() || this.moi;
        };
        /**
         * Sets up an [[EdgeArea|edge collision]] with a start point and an end point relative to the anchor of the associated actor
         * of this physics body.
         *
         * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
         */
        Body.prototype.useEdgeCollision = function (begin, end) {
            this.collisionArea = new EdgeArea_3.EdgeArea({
                begin: begin,
                end: end,
                body: this
            });
            this.moi = this.collisionArea.getMomentOfInertia() || this.moi;
        };
        /* istanbul ignore next */
        Body.prototype.debugDraw = function (ctx) {
            // Draw motion vectors
            if (Physics_5.Physics.showMotionVectors) {
                DrawUtil.vector(ctx, Color_6.Color.Yellow, this.pos, (this.acc.add(Physics_5.Physics.acc)));
                DrawUtil.vector(ctx, Color_6.Color.Red, this.pos, (this.vel));
                DrawUtil.point(ctx, Color_6.Color.Red, this.pos);
            }
            if (Physics_5.Physics.showBounds) {
                this.getBounds().debugDraw(ctx, Color_6.Color.Yellow);
            }
            if (Physics_5.Physics.showArea) {
                this.collisionArea.debugDraw(ctx, Color_6.Color.Green);
            }
        };
        /**
         * Returns a boolean indicating whether this body collided with
         * or was in stationary contact with
         * the body of the other [[Actor]]
         */
        Body.prototype.touching = function (other) {
            var pair = new Pair_1.Pair(this, other.body);
            pair.collide();
            if (pair.collision) {
                return true;
            }
            return false;
        };
        return Body;
    }());
    exports.Body = Body;
});
define("Collision/Pair", ["require", "exports", "Physics", "Drawing/Color", "Actor", "Util/DrawUtil"], function (require, exports, Physics_6, Color_7, Actor_2, DrawUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Models a potential collision between 2 bodies
     */
    var Pair = (function () {
        function Pair(bodyA, bodyB) {
            this.bodyA = bodyA;
            this.bodyB = bodyB;
            this.id = null;
            this.collision = null;
            this.id = Pair.calculatePairHash(bodyA, bodyB);
        }
        Object.defineProperty(Pair.prototype, "canCollide", {
            /**
             * Returns whether or not it is possible for the pairs to collide
             */
            get: function () {
                var actorA = this.bodyA.actor;
                var actorB = this.bodyB.actor;
                // if both are fixed short circuit
                if (actorA.collisionType === Actor_2.CollisionType.Fixed && actorB.collisionType === Actor_2.CollisionType.Fixed) {
                    return false;
                }
                // if the other is prevent collision or is dead short circuit
                if (actorB.collisionType === Actor_2.CollisionType.PreventCollision || actorB.isKilled()) {
                    return false;
                }
                return true;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Runs the collison intersection logic on the members of this pair
         */
        Pair.prototype.collide = function () {
            this.collision = this.bodyA.collisionArea.collide(this.bodyB.collisionArea);
        };
        /**
         * Resovles the collision body position and velocity if a collision occured
         */
        Pair.prototype.resolve = function (strategy) {
            if (this.collision) {
                this.collision.resolve(strategy);
            }
        };
        /**
         * Calculates the unique pair hash id for this collision pair
         */
        Pair.calculatePairHash = function (bodyA, bodyB) {
            if (bodyA.actor.id < bodyB.actor.id) {
                return "#" + bodyA.actor.id + "+" + bodyB.actor.id;
            }
            else {
                return "#" + bodyB.actor.id + "+" + bodyA.actor.id;
            }
        };
        /* istanbul ignore next */
        Pair.prototype.debugDraw = function (ctx) {
            if (this.collision) {
                if (Physics_6.Physics.showContacts) {
                    DrawUtil.point(ctx, Color_7.Color.Red, this.collision.point);
                }
                if (Physics_6.Physics.showCollisionNormals) {
                    DrawUtil.vector(ctx, Color_7.Color.Cyan, this.collision.point, this.collision.normal, 30);
                }
            }
        };
        return Pair;
    }());
    exports.Pair = Pair;
});
define("Debug", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Debug statistics and flags for Excalibur. If polling these values, it would be
     * best to do so on the `postupdate` event for [[Engine]], after all values have been
     * updated during a frame.
     */
    var Debug = (function () {
        function Debug() {
            /**
             * Performance statistics
             */
            this.stats = {
                /**
                 * Current frame statistics. Engine reuses this instance, use [[FrameStats.clone]] to copy frame stats.
                 * Best accessed on [[postframe]] event. See [[IFrameStats]]
                 */
                currFrame: new FrameStats(),
                /**
                 * Previous frame statistics. Engine reuses this instance, use [[FrameStats.clone]] to copy frame stats.
                 * Best accessed on [[preframe]] event. Best inspected on engine event `preframe`. See [[IFrameStats]]
                 */
                prevFrame: new FrameStats()
            };
        }
        return Debug;
    }());
    exports.Debug = Debug;
    /**
     * Implementation of a frame's stats. Meant to have values copied via [[FrameStats.reset]], avoid
     * creating instances of this every frame.
     */
    var FrameStats = (function () {
        function FrameStats() {
            this._id = 0;
            this._delta = 0;
            this._fps = 0;
            this._actorStats = {
                alive: 0,
                killed: 0,
                ui: 0,
                get remaining() {
                    return this.alive - this.killed;
                },
                get total() {
                    return this.remaining + this.ui;
                }
            };
            this._durationStats = {
                update: 0,
                draw: 0,
                get total() {
                    return this.update + this.draw;
                }
            };
            this._physicsStats = new PhysicsStats();
        }
        /**
         * Zero out values or clone other IFrameStat stats. Allows instance reuse.
         *
         * @param [otherStats] Optional stats to clone
         */
        FrameStats.prototype.reset = function (otherStats) {
            if (otherStats) {
                this.id = otherStats.id;
                this.delta = otherStats.delta;
                this.fps = otherStats.fps;
                this.actors.alive = otherStats.actors.alive;
                this.actors.killed = otherStats.actors.killed;
                this.actors.ui = otherStats.actors.ui;
                this.duration.update = otherStats.duration.update;
                this.duration.draw = otherStats.duration.draw;
                this._physicsStats.reset(otherStats.physics);
            }
            else {
                this.id = this.delta = this.fps = 0;
                this.actors.alive = this.actors.killed = this.actors.ui = 0;
                this.duration.update = this.duration.draw = 0;
                this._physicsStats.reset();
            }
        };
        /**
         * Provides a clone of this instance.
         */
        FrameStats.prototype.clone = function () {
            var fs = new FrameStats();
            fs.reset(this);
            return fs;
        };
        Object.defineProperty(FrameStats.prototype, "id", {
            /**
             * Gets the frame's id
             */
            get: function () {
                return this._id;
            },
            /**
             * Sets the frame's id
             */
            set: function (value) {
                this._id = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FrameStats.prototype, "delta", {
            /**
             * Gets the frame's delta (time since last frame)
             */
            get: function () {
                return this._delta;
            },
            /**
             * Sets the frame's delta (time since last frame). Internal use only.
             * @internal
             */
            set: function (value) {
                this._delta = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FrameStats.prototype, "fps", {
            /**
             * Gets the frame's frames-per-second (FPS)
             */
            get: function () {
                return this._fps;
            },
            /**
             * Sets the frame's frames-per-second (FPS). Internal use only.
             * @internal
             */
            set: function (value) {
                this._fps = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FrameStats.prototype, "actors", {
            /**
             * Gets the frame's actor statistics
             */
            get: function () {
                return this._actorStats;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FrameStats.prototype, "duration", {
            /**
             * Gets the frame's duration statistics
             */
            get: function () {
                return this._durationStats;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FrameStats.prototype, "physics", {
            /**
             * Gets the frame's physics statistics
             */
            get: function () {
                return this._physicsStats;
            },
            enumerable: true,
            configurable: true
        });
        return FrameStats;
    }());
    exports.FrameStats = FrameStats;
    var PhysicsStats = (function () {
        function PhysicsStats() {
            this._pairs = 0;
            this._collisions = 0;
            this._collidersHash = {};
            this._fastBodies = 0;
            this._fastBodyCollisions = 0;
            this._broadphase = 0;
            this._narrowphase = 0;
        }
        /**
         * Zero out values or clone other IPhysicsStats stats. Allows instance reuse.
         *
         * @param [otherStats] Optional stats to clone
         */
        PhysicsStats.prototype.reset = function (otherStats) {
            if (otherStats) {
                this.pairs = otherStats.pairs;
                this.collisions = otherStats.collisions;
                this.collidersHash = otherStats.collidersHash;
                this.fastBodies = otherStats.fastBodies;
                this.fastBodyCollisions = otherStats.fastBodyCollisions;
                this.broadphase = otherStats.broadphase;
                this.narrowphase = otherStats.narrowphase;
            }
            else {
                this.pairs = this.collisions = this.fastBodies = 0;
                this.fastBodyCollisions = this.broadphase = this.narrowphase = 0;
                this.collidersHash = {};
            }
        };
        /**
         * Provides a clone of this instance.
         */
        PhysicsStats.prototype.clone = function () {
            var ps = new PhysicsStats();
            ps.reset(this);
            return ps;
        };
        Object.defineProperty(PhysicsStats.prototype, "pairs", {
            get: function () {
                return this._pairs;
            },
            set: function (value) {
                this._pairs = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PhysicsStats.prototype, "collisions", {
            get: function () {
                return this._collisions;
            },
            set: function (value) {
                this._collisions = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PhysicsStats.prototype, "collidersHash", {
            get: function () {
                return this._collidersHash;
            },
            set: function (colliders) {
                this._collidersHash = colliders;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PhysicsStats.prototype, "fastBodies", {
            get: function () {
                return this._fastBodies;
            },
            set: function (value) {
                this._fastBodies = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PhysicsStats.prototype, "fastBodyCollisions", {
            get: function () {
                return this._fastBodyCollisions;
            },
            set: function (value) {
                this._fastBodyCollisions = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PhysicsStats.prototype, "broadphase", {
            get: function () {
                return this._broadphase;
            },
            set: function (value) {
                this._broadphase = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PhysicsStats.prototype, "narrowphase", {
            get: function () {
                return this._narrowphase;
            },
            set: function (value) {
                this._narrowphase = value;
            },
            enumerable: true,
            configurable: true
        });
        return PhysicsStats;
    }());
    exports.PhysicsStats = PhysicsStats;
});
define("Interfaces/IEvented", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("EventDispatcher", ["require", "exports", "Events"], function (require, exports, Events_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Excalibur's internal event dispatcher implementation.
     * Callbacks are fired immediately after an event is published.
     * Typically you will use [[Class.eventDispatcher]] since most classes in
     * Excalibur inherit from [[Class]]. You will rarely create an `EventDispatcher`
     * yourself.
     *
     * [[include:Events.md]]
     */
    var EventDispatcher = (function () {
        /**
         * @param target  The object that will be the recipient of events from this event dispatcher
         */
        function EventDispatcher(target) {
            this._handlers = {};
            this._wiredEventDispatchers = [];
            this._target = target;
        }
        /**
         * Emits an event for target
         * @param eventName  The name of the event to publish
         * @param event      Optionally pass an event data object to the handler
         */
        EventDispatcher.prototype.emit = function (eventName, event) {
            if (!eventName) {
                // key not mapped
                return;
            }
            eventName = eventName.toLowerCase();
            var target = this._target;
            if (!event) {
                event = new Events_2.GameEvent();
            }
            event.target = target;
            var i, len;
            if (this._handlers[eventName]) {
                i = 0;
                len = this._handlers[eventName].length;
                for (i; i < len; i++) {
                    this._handlers[eventName][i].call(target, event);
                }
            }
            i = 0;
            len = this._wiredEventDispatchers.length;
            for (i; i < len; i++) {
                this._wiredEventDispatchers[i].emit(eventName, event);
            }
        };
        /**
         * Subscribe an event handler to a particular event name, multiple handlers per event name are allowed.
         * @param eventName  The name of the event to subscribe to
         * @param handler    The handler callback to fire on this event
         */
        EventDispatcher.prototype.on = function (eventName, handler) {
            eventName = eventName.toLowerCase();
            if (!this._handlers[eventName]) {
                this._handlers[eventName] = [];
            }
            this._handlers[eventName].push(handler);
            // meta event handlers
            if (eventName !== 'unsubscribe' && eventName !== 'subscribe') {
                this.emit('subscribe', new Events_2.SubscribeEvent(eventName, handler));
            }
        };
        /**
         * Unsubscribe an event handler(s) from an event. If a specific handler
         * is specified for an event, only that handler will be unsubscribed.
         * Otherwise all handlers will be unsubscribed for that event.
         *
         * @param eventName  The name of the event to unsubscribe
         * @param handler    Optionally the specific handler to unsubscribe
         *
         */
        EventDispatcher.prototype.off = function (eventName, handler) {
            eventName = eventName.toLowerCase();
            var eventHandlers = this._handlers[eventName];
            if (eventHandlers) {
                // if no explicit handler is give with the event name clear all handlers
                if (!handler) {
                    this._handlers[eventName].length = 0;
                }
                else {
                    var index = eventHandlers.indexOf(handler);
                    this._handlers[eventName].splice(index, 1);
                }
            }
            // meta event handlers
            if (eventName !== 'unsubscribe' && eventName !== 'subscribe') {
                this.emit('unsubscribe', new Events_2.UnsubscribeEvent(eventName, handler));
            }
        };
        /**
         * Once listens to an event one time, then unsubscribes from that event
         *
         * @param eventName The name of the event to subscribe to once
         * @param handler   The handler of the event that will be auto unsubscribed
         */
        EventDispatcher.prototype.once = function (eventName, handler) {
            var _this = this;
            var metaHandler = function (event) {
                var ev = event || new Events_2.GameEvent();
                ev.target = ev.target || _this._target;
                _this.off(eventName, handler);
                handler.call(ev.target, ev);
            };
            this.on(eventName, metaHandler);
        };
        /**
         * Wires this event dispatcher to also recieve events from another
         */
        EventDispatcher.prototype.wire = function (eventDispatcher) {
            eventDispatcher._wiredEventDispatchers.push(this);
        };
        /**
         * Unwires this event dispatcher from another
         */
        EventDispatcher.prototype.unwire = function (eventDispatcher) {
            var index = eventDispatcher._wiredEventDispatchers.indexOf(this);
            if (index > -1) {
                eventDispatcher._wiredEventDispatchers.splice(index, 1);
            }
        };
        return EventDispatcher;
    }());
    exports.EventDispatcher = EventDispatcher;
});
define("Actions/ActionContext", ["require", "exports", "Actions/Action", "Promises", "Util/EasingFunctions"], function (require, exports, Actions, Promises_2, EasingFunctions_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The fluent Action API allows you to perform "actions" on
     * [[Actor|Actors]] such as following, moving, rotating, and
     * more. You can implement your own actions by implementing
     * the [[IAction]] interface.
     *
     * [[include:Actions.md]]
     */
    var ActionContext = (function () {
        function ActionContext() {
            this._actors = [];
            this._queues = [];
            if (arguments !== null) {
                this._actors = Array.prototype.slice.call(arguments, 0);
                this._queues = this._actors.map(function (a) {
                    return a.actionQueue;
                });
            }
        }
        /**
         * Clears all queued actions from the Actor
         */
        ActionContext.prototype.clearActions = function () {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].clearActions();
            }
        };
        ActionContext.prototype.addActorToContext = function (actor) {
            this._actors.push(actor);
            // if we run into problems replace the line below with:
            this._queues.push(actor.actionQueue);
        };
        ActionContext.prototype.removeActorFromContext = function (actor) {
            var index = this._actors.indexOf(actor);
            if (index > -1) {
                this._actors.splice(index, 1);
                this._queues.splice(index, 1);
            }
        };
        /**
         * This method will move an actor to the specified `x` and `y` position over the
         * specified duration using a given [[EasingFunctions]] and return back the actor. This
         * method is part of the actor 'Action' fluent API allowing action chaining.
         * @param x         The x location to move the actor to
         * @param y         The y location to move the actor to
         * @param duration  The time it should take the actor to move to the new location in milliseconds
         * @param easingFcn Use [[EasingFunctions]] or a custom function to use to calculate position
         */
        ActionContext.prototype.easeTo = function (x, y, duration, easingFcn) {
            if (easingFcn === void 0) { easingFcn = EasingFunctions_2.EasingFunctions.Linear; }
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.EaseTo(this._actors[i], x, y, duration, easingFcn));
            }
            return this;
        };
        /**
         * This method will move an actor to the specified x and y position at the
         * speed specified (in pixels per second) and return back the actor. This
         * method is part of the actor 'Action' fluent API allowing action chaining.
         * @param x      The x location to move the actor to
         * @param y      The y location to move the actor to
         * @param speed  The speed in pixels per second to move
         */
        ActionContext.prototype.moveTo = function (x, y, speed) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.MoveTo(this._actors[i], x, y, speed));
            }
            return this;
        };
        /**
         * This method will move an actor to the specified x and y position by a
         * certain time (in milliseconds). This method is part of the actor
         * 'Action' fluent API allowing action chaining.
         * @param x     The x location to move the actor to
         * @param y     The y location to move the actor to
         * @param time  The time it should take the actor to move to the new location in milliseconds
         */
        ActionContext.prototype.moveBy = function (x, y, time) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.MoveBy(this._actors[i], x, y, time));
            }
            return this;
        };
        /**
         * This method will rotate an actor to the specified angle at the speed
         * specified (in radians per second) and return back the actor. This
         * method is part of the actor 'Action' fluent API allowing action chaining.
         * @param angleRadians  The angle to rotate to in radians
         * @param speed         The angular velocity of the rotation specified in radians per second
         * @param rotationType  The [[RotationType]] to use for this rotation
         */
        ActionContext.prototype.rotateTo = function (angleRadians, speed, rotationType) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.RotateTo(this._actors[i], angleRadians, speed, rotationType));
            }
            return this;
        };
        /**
         * This method will rotate an actor to the specified angle by a certain
         * time (in milliseconds) and return back the actor. This method is part
         * of the actor 'Action' fluent API allowing action chaining.
         * @param angleRadians  The angle to rotate to in radians
         * @param time          The time it should take the actor to complete the rotation in milliseconds
         * @param rotationType  The [[RotationType]] to use for this rotation
         */
        ActionContext.prototype.rotateBy = function (angleRadians, time, rotationType) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.RotateBy(this._actors[i], angleRadians, time, rotationType));
            }
            return this;
        };
        /**
         * This method will scale an actor to the specified size at the speed
         * specified (in magnitude increase per second) and return back the
         * actor. This method is part of the actor 'Action' fluent API allowing
         * action chaining.
         * @param sizeX   The scaling factor to apply on X axis
         * @param sizeY   The scaling factor to apply on Y axis
         * @param speedX  The speed of scaling specified in magnitude increase per second on X axis
         * @param speedY  The speed of scaling specified in magnitude increase per second on Y axis
         */
        ActionContext.prototype.scaleTo = function (sizeX, sizeY, speedX, speedY) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.ScaleTo(this._actors[i], sizeX, sizeY, speedX, speedY));
            }
            return this;
        };
        /**
         * This method will scale an actor to the specified size by a certain time
         * (in milliseconds) and return back the actor. This method is part of the
         * actor 'Action' fluent API allowing action chaining.
         * @param sizeX   The scaling factor to apply on X axis
         * @param sizeY   The scaling factor to apply on Y axis
         * @param time    The time it should take to complete the scaling in milliseconds
         */
        ActionContext.prototype.scaleBy = function (sizeX, sizeY, time) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.ScaleBy(this._actors[i], sizeX, sizeY, time));
            }
            return this;
        };
        /**
         * This method will cause an actor to blink (become visible and not
         * visible). Optionally, you may specify the number of blinks. Specify the amount of time
         * the actor should be visible per blink, and the amount of time not visible.
         * This method is part of the actor 'Action' fluent API allowing action chaining.
         * @param timeVisible     The amount of time to stay visible per blink in milliseconds
         * @param timeNotVisible  The amount of time to stay not visible per blink in milliseconds
         * @param numBlinks       The number of times to blink
         */
        ActionContext.prototype.blink = function (timeVisible, timeNotVisible, numBlinks) {
            if (numBlinks === void 0) { numBlinks = 1; }
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.Blink(this._actors[i], timeVisible, timeNotVisible, numBlinks));
            }
            return this;
        };
        /**
         * This method will cause an actor's opacity to change from its current value
         * to the provided value by a specified time (in milliseconds). This method is
         * part of the actor 'Action' fluent API allowing action chaining.
         * @param opacity  The ending opacity
         * @param time     The time it should take to fade the actor (in milliseconds)
         */
        ActionContext.prototype.fade = function (opacity, time) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.Fade(this._actors[i], opacity, time));
            }
            return this;
        };
        /**
         * This method will delay the next action from executing for a certain
         * amount of time (in milliseconds). This method is part of the actor
         * 'Action' fluent API allowing action chaining.
         * @param time  The amount of time to delay the next action in the queue from executing in milliseconds
         */
        ActionContext.prototype.delay = function (time) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.Delay(this._actors[i], time));
            }
            return this;
        };
        /**
         * This method will add an action to the queue that will remove the actor from the
         * scene once it has completed its previous actions. Any actions on the
         * action queue after this action will not be executed.
         */
        ActionContext.prototype.die = function () {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.Die(this._actors[i]));
            }
            return this;
        };
        /**
         * This method allows you to call an arbitrary method as the next action in the
         * action queue. This is useful if you want to execute code in after a specific
         * action, i.e An actor arrives at a destination after traversing a path
         */
        ActionContext.prototype.callMethod = function (method) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.CallMethod(this._actors[i], method));
            }
            return this;
        };
        /**
         * This method will cause the actor to repeat all of the previously
         * called actions a certain number of times. If the number of repeats
         * is not specified it will repeat forever. This method is part of
         * the actor 'Action' fluent API allowing action chaining
         * @param times  The number of times to repeat all the previous actions in the action queue. If nothing is specified the actions
         * will repeat forever
         */
        ActionContext.prototype.repeat = function (times) {
            if (!times) {
                this.repeatForever();
                return this;
            }
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.Repeat(this._actors[i], times, this._actors[i].actionQueue.getActions()));
            }
            return this;
        };
        /**
         * This method will cause the actor to repeat all of the previously
         * called actions forever. This method is part of the actor 'Action'
         * fluent API allowing action chaining.
         */
        ActionContext.prototype.repeatForever = function () {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.RepeatForever(this._actors[i], this._actors[i].actionQueue.getActions()));
            }
            return this;
        };
        /**
         * This method will cause the actor to follow another at a specified distance
         * @param actor           The actor to follow
         * @param followDistance  The distance to maintain when following, if not specified the actor will follow at the current distance.
         */
        ActionContext.prototype.follow = function (actor, followDistance) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                if (followDistance === undefined) {
                    this._queues[i].add(new Actions.Follow(this._actors[i], actor));
                }
                else {
                    this._queues[i].add(new Actions.Follow(this._actors[i], actor, followDistance));
                }
            }
            return this;
        };
        /**
         * This method will cause the actor to move towards another until they
         * collide "meet" at a specified speed.
         * @param actor  The actor to meet
         * @param speed  The speed in pixels per second to move, if not specified it will match the speed of the other actor
         */
        ActionContext.prototype.meet = function (actor, speed) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                if (speed === undefined) {
                    this._queues[i].add(new Actions.Meet(this._actors[i], actor));
                }
                else {
                    this._queues[i].add(new Actions.Meet(this._actors[i], actor, speed));
                }
            }
            return this;
        };
        /**
         * Returns a promise that resolves when the current action queue up to now
         * is finished.
         */
        ActionContext.prototype.asPromise = function () {
            var _this = this;
            var promises = this._queues.map(function (q, i) {
                var temp = new Promises_2.Promise();
                q.add(new Actions.CallMethod(_this._actors[i], function () {
                    temp.resolve();
                }));
                return temp;
            });
            return Promises_2.Promise.join.apply(this, promises);
        };
        return ActionContext;
    }());
    exports.ActionContext = ActionContext;
});
define("Util/Log", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Logging level that Excalibur will tag
     */
    var LogLevel;
    (function (LogLevel) {
        LogLevel[LogLevel["Debug"] = 0] = "Debug";
        LogLevel[LogLevel["Info"] = 1] = "Info";
        LogLevel[LogLevel["Warn"] = 2] = "Warn";
        LogLevel[LogLevel["Error"] = 3] = "Error";
        LogLevel[LogLevel["Fatal"] = 4] = "Fatal";
    })(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
    /**
     * Static singleton that represents the logging facility for Excalibur.
     * Excalibur comes built-in with a [[ConsoleAppender]] and [[ScreenAppender]].
     * Derive from [[IAppender]] to create your own logging appenders.
     *
     * [[include:Logger.md]]
     */
    var Logger = (function () {
        function Logger() {
            this._appenders = [];
            /**
             * Gets or sets the default logging level. Excalibur will only log
             * messages if equal to or above this level. Default: [[LogLevel.Info]]
             */
            this.defaultLevel = LogLevel.Info;
            if (Logger._instance) {
                throw new Error('Logger is a singleton');
            }
            Logger._instance = this;
            // Default console appender
            Logger._instance.addAppender(new ConsoleAppender());
            return Logger._instance;
        }
        /**
         * Gets the current static instance of Logger
         */
        Logger.getInstance = function () {
            if (Logger._instance == null) {
                Logger._instance = new Logger();
            }
            return Logger._instance;
        };
        /**
         * Adds a new [[IAppender]] to the list of appenders to write to
         */
        Logger.prototype.addAppender = function (appender) {
            this._appenders.push(appender);
        };
        /**
         * Clears all appenders from the logger
         */
        Logger.prototype.clearAppenders = function () {
            this._appenders.length = 0;
        };
        /**
         * Logs a message at a given LogLevel
         * @param level  The LogLevel`to log the message at
         * @param args   An array of arguments to write to an appender
         */
        Logger.prototype._log = function (level, args) {
            if (level == null) {
                level = this.defaultLevel;
            }
            var i = 0, len = this._appenders.length;
            for (i; i < len; i++) {
                if (level >= this.defaultLevel) {
                    this._appenders[i].log(level, args);
                }
            }
        };
        /**
         * Writes a log message at the [[LogLevel.Debug]] level
         * @param args  Accepts any number of arguments
         */
        Logger.prototype.debug = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            this._log(LogLevel.Debug, args);
        };
        /**
         * Writes a log message at the [[LogLevel.Info]] level
         * @param args  Accepts any number of arguments
         */
        Logger.prototype.info = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            this._log(LogLevel.Info, args);
        };
        /**
         * Writes a log message at the [[LogLevel.Warn]] level
         * @param args  Accepts any number of arguments
         */
        Logger.prototype.warn = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            this._log(LogLevel.Warn, args);
        };
        /**
         * Writes a log message at the [[LogLevel.Error]] level
         * @param args  Accepts any number of arguments
         */
        Logger.prototype.error = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            this._log(LogLevel.Error, args);
        };
        /**
         * Writes a log message at the [[LogLevel.Fatal]] level
         * @param args  Accepts any number of arguments
         */
        Logger.prototype.fatal = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            this._log(LogLevel.Fatal, args);
        };
        return Logger;
    }());
    Logger._instance = null;
    exports.Logger = Logger;
    /**
     * Console appender for browsers (i.e. `console.log`)
     */
    var ConsoleAppender = (function () {
        function ConsoleAppender() {
        }
        /**
         * Logs a message at the given [[LogLevel]]
         * @param level  Level to log at
         * @param args   Arguments to log
         */
        ConsoleAppender.prototype.log = function (level, args) {
            // Check for console support
            if (!console && !console.log && console.warn && console.error) {
                // todo maybe do something better than nothing
                return;
            }
            // Create a new console args array
            var consoleArgs = [];
            consoleArgs.unshift.apply(consoleArgs, args);
            consoleArgs.unshift('[' + LogLevel[level] + '] : ');
            if (level < LogLevel.Warn) {
                // Call .log for Debug/Info
                if (console.log.apply) {
                    // this is required on some older browsers that don't support apply on console.log :(
                    console.log.apply(console, consoleArgs);
                }
                else {
                    console.log(consoleArgs.join(' '));
                }
            }
            else if (level < LogLevel.Error) {
                // Call .warn for Warn
                if (console.warn.apply) {
                    console.warn.apply(console, consoleArgs);
                }
                else {
                    console.warn(consoleArgs.join(' '));
                }
            }
            else {
                // Call .error for Error/Fatal
                if (console.error.apply) {
                    console.error.apply(console, consoleArgs);
                }
                else {
                    console.error(consoleArgs.join(' '));
                }
            }
        };
        return ConsoleAppender;
    }());
    exports.ConsoleAppender = ConsoleAppender;
    /**
     * On-screen (canvas) appender
     */
    var ScreenAppender = (function () {
        /**
         * @param width   Width of the screen appender in pixels
         * @param height  Height of the screen appender in pixels
         */
        function ScreenAppender(width, height) {
            // @todo Clean this up
            this._messages = [];
            this._canvas = document.createElement('canvas');
            this._canvas.width = width || window.innerWidth;
            this._canvas.height = height || window.innerHeight;
            this._canvas.style.position = 'absolute';
            this._ctx = this._canvas.getContext('2d');
            document.body.appendChild(this._canvas);
        }
        /**
         * Logs a message at the given [[LogLevel]]
         * @param level  Level to log at
         * @param args   Arguments to log
         */
        ScreenAppender.prototype.log = function (level, args) {
            var message = args.join(',');
            this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
            this._messages.unshift('[' + LogLevel[level] + '] : ' + message);
            var pos = 10;
            var opacity = 1.0;
            for (var i = 0; i < this._messages.length; i++) {
                this._ctx.fillStyle = 'rgba(255,255,255,' + opacity.toFixed(2) + ')';
                this._ctx.fillText(this._messages[i], 200, pos);
                pos += 10;
                opacity = opacity > 0 ? opacity - .05 : 0;
            }
        };
        return ScreenAppender;
    }());
    exports.ScreenAppender = ScreenAppender;
});
define("Actions/IActionable", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Group", ["require", "exports", "Algebra", "Actions/ActionContext", "Actor", "Util/Log", "Class"], function (require, exports, Algebra_10, ActionContext_1, Actor_3, Log_1, Class_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Groups are used for logically grouping Actors so they can be acted upon
     * in bulk.
     *
     * [[include:Groups.md]]
     */
    var Group = (function (_super) {
        __extends(Group, _super);
        function Group(name, scene) {
            var _this = _super.call(this) || this;
            _this.name = name;
            _this.scene = scene;
            _this._logger = Log_1.Logger.getInstance();
            _this._members = [];
            _this.actions = new ActionContext_1.ActionContext();
            if (scene == null) {
                _this._logger.error('Invalid constructor arguments passed to Group: ', name, ', scene must not be null!');
            }
            else {
                var existingGroup = scene.groups[name];
                if (existingGroup) {
                    _this._logger.warn('Group with name', name, 'already exists. This new group will replace it.');
                }
                scene.groups[name] = _this;
            }
            return _this;
        }
        Group.prototype.add = function (actorOrActors) {
            if (actorOrActors instanceof Actor_3.Actor) {
                actorOrActors = [].concat(actorOrActors);
            }
            var i = 0, len = actorOrActors.length, groupIdx;
            for (i; i < len; i++) {
                groupIdx = this.getMembers().indexOf(actorOrActors[i]);
                if (groupIdx === -1) {
                    this._members.push(actorOrActors[i]);
                    this.scene.add(actorOrActors[i]);
                    this.actions.addActorToContext(actorOrActors[i]);
                    this.eventDispatcher.wire(actorOrActors[i].eventDispatcher);
                }
            }
        };
        Group.prototype.remove = function (actor) {
            var index = this._members.indexOf(actor);
            if (index > -1) {
                this._members.splice(index, 1);
                this.actions.removeActorFromContext(actor);
                this.eventDispatcher.unwire(actor.eventDispatcher);
            }
        };
        Group.prototype.move = function (args) {
            var i = 0, members = this.getMembers(), len = members.length;
            if (arguments.length === 1 && args instanceof Algebra_10.Vector) {
                for (i; i < len; i++) {
                    members[i].pos.x += args.x;
                    members[i].pos.y += args.y;
                }
            }
            else if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
                var x = arguments[0];
                var y = arguments[1];
                for (i; i < len; i++) {
                    members[i].pos.x += x;
                    members[i].pos.y += y;
                }
            }
            else {
                this._logger.error('Invalid arguments passed to group move', this.name, 'args:', arguments);
            }
        };
        Group.prototype.rotate = function (angle) {
            if (typeof angle !== 'number') {
                this._logger.error('Invalid arguments passed to group rotate', this.name, 'args:', arguments);
                return;
            }
            for (var _i = 0, _a = this.getMembers(); _i < _a.length; _i++) {
                var member = _a[_i];
                member.rotation += angle;
            }
        };
        Group.prototype.on = function (eventName, handler) {
            this.eventDispatcher.on(eventName, handler);
        };
        Group.prototype.off = function (eventName, handler) {
            this.eventDispatcher.off(eventName, handler);
        };
        Group.prototype.emit = function (topic, event) {
            this.eventDispatcher.emit(topic, event);
        };
        Group.prototype.contains = function (actor) {
            return this.getMembers().indexOf(actor) > -1;
        };
        Group.prototype.getMembers = function () {
            return this._members;
        };
        Group.prototype.getRandomMember = function () {
            return this._members[Math.floor(Math.random() * this._members.length)];
        };
        Group.prototype.getBounds = function () {
            return this.getMembers().map(function (a) { return a.getBounds(); }).reduce(function (prev, curr) {
                return prev.combine(curr);
            });
        };
        return Group;
    }(Class_1.Class));
    exports.Group = Group;
});
/**
 * These effects can be applied to any bitmap image but are mainly used
 * for [[Sprite]] effects or [[Animation]] effects.
 *
 * [[include:SpriteEffects.md]]
 */
define("Drawing/SpriteEffects", ["require", "exports", "Drawing/Color"], function (require, exports, Color_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Applies the "Grayscale" effect to a sprite, removing color information.
     */
    var Grayscale = (function () {
        function Grayscale() {
        }
        Grayscale.prototype.updatePixel = function (x, y, imageData) {
            var firstPixel = (x + y * imageData.width) * 4;
            var pixel = imageData.data;
            var avg = (pixel[firstPixel + 0] + pixel[firstPixel + 1] + pixel[firstPixel + 2]) / 3;
            pixel[firstPixel + 0] = avg;
            pixel[firstPixel + 1] = avg;
            pixel[firstPixel + 2] = avg;
        };
        return Grayscale;
    }());
    exports.Grayscale = Grayscale;
    /**
     * Applies the "Invert" effect to a sprite, inverting the pixel colors.
     */
    var Invert = (function () {
        function Invert() {
        }
        Invert.prototype.updatePixel = function (x, y, imageData) {
            var firstPixel = (x + y * imageData.width) * 4;
            var pixel = imageData.data;
            pixel[firstPixel + 0] = 255 - pixel[firstPixel + 0];
            pixel[firstPixel + 1] = 255 - pixel[firstPixel + 1];
            pixel[firstPixel + 2] = 255 - pixel[firstPixel + 2];
        };
        return Invert;
    }());
    exports.Invert = Invert;
    /**
     * Applies the "Opacity" effect to a sprite, setting the alpha of all pixels to a given value.
     */
    var Opacity = (function () {
        /**
         * @param opacity  The new opacity of the sprite from 0-1.0
         */
        function Opacity(opacity) {
            this.opacity = opacity;
        }
        Opacity.prototype.updatePixel = function (x, y, imageData) {
            var firstPixel = (x + y * imageData.width) * 4;
            var pixel = imageData.data;
            if (pixel[firstPixel + 3] !== 0) {
                pixel[firstPixel + 3] = Math.round(this.opacity * pixel[firstPixel + 3]);
            }
        };
        return Opacity;
    }());
    exports.Opacity = Opacity;
    /**
     * Applies the "Colorize" effect to a sprite, changing the color channels of all the pixels to an
     * average of the original color and the provided color
     */
    var Colorize = (function () {
        /**
         * @param color  The color to apply to the sprite
         */
        function Colorize(color) {
            this.color = color;
        }
        Colorize.prototype.updatePixel = function (x, y, imageData) {
            var firstPixel = (x + y * imageData.width) * 4;
            var pixel = imageData.data;
            if (pixel[firstPixel + 3] !== 0) {
                pixel[firstPixel + 0] = (pixel[firstPixel + 0] + this.color.r) / 2;
                pixel[firstPixel + 1] = (pixel[firstPixel + 1] + this.color.g) / 2;
                pixel[firstPixel + 2] = (pixel[firstPixel + 2] + this.color.b) / 2;
            }
        };
        return Colorize;
    }());
    exports.Colorize = Colorize;
    /**
     * Applies the "Lighten" effect to a sprite, changes the lightness of the color according to HSL
     */
    var Lighten = (function () {
        /**
         * @param factor  The factor of the effect between 0-1
         */
        function Lighten(factor) {
            if (factor === void 0) { factor = 0.1; }
            this.factor = factor;
        }
        Lighten.prototype.updatePixel = function (x, y, imageData) {
            var firstPixel = (x + y * imageData.width) * 4;
            var pixel = imageData.data;
            var color = Color_8.Color.fromRGB(pixel[firstPixel + 0], pixel[firstPixel + 1], pixel[firstPixel + 2], pixel[firstPixel + 3]).lighten(this.factor);
            pixel[firstPixel + 0] = color.r;
            pixel[firstPixel + 1] = color.g;
            pixel[firstPixel + 2] = color.b;
            pixel[firstPixel + 3] = color.a;
        };
        return Lighten;
    }());
    exports.Lighten = Lighten;
    /**
     * Applies the "Darken" effect to a sprite, changes the darkness of the color according to HSL
     */
    var Darken = (function () {
        /**
         * @param factor  The factor of the effect between 0-1
         */
        function Darken(factor) {
            if (factor === void 0) { factor = 0.1; }
            this.factor = factor;
        }
        Darken.prototype.updatePixel = function (x, y, imageData) {
            var firstPixel = (x + y * imageData.width) * 4;
            var pixel = imageData.data;
            var color = Color_8.Color.fromRGB(pixel[firstPixel + 0], pixel[firstPixel + 1], pixel[firstPixel + 2], pixel[firstPixel + 3]).darken(this.factor);
            pixel[firstPixel + 0] = color.r;
            pixel[firstPixel + 1] = color.g;
            pixel[firstPixel + 2] = color.b;
            pixel[firstPixel + 3] = color.a;
        };
        return Darken;
    }());
    exports.Darken = Darken;
    /**
     * Applies the "Saturate" effect to a sprite, saturates the color according to HSL
     */
    var Saturate = (function () {
        /**
         * @param factor  The factor of the effect between 0-1
         */
        function Saturate(factor) {
            if (factor === void 0) { factor = 0.1; }
            this.factor = factor;
        }
        Saturate.prototype.updatePixel = function (x, y, imageData) {
            var firstPixel = (x + y * imageData.width) * 4;
            var pixel = imageData.data;
            var color = Color_8.Color.fromRGB(pixel[firstPixel + 0], pixel[firstPixel + 1], pixel[firstPixel + 2], pixel[firstPixel + 3]).saturate(this.factor);
            pixel[firstPixel + 0] = color.r;
            pixel[firstPixel + 1] = color.g;
            pixel[firstPixel + 2] = color.b;
            pixel[firstPixel + 3] = color.a;
        };
        return Saturate;
    }());
    exports.Saturate = Saturate;
    /**
     * Applies the "Desaturate" effect to a sprite, desaturates the color according to HSL
     */
    var Desaturate = (function () {
        /**
         * @param factor  The factor of the effect between 0-1
         */
        function Desaturate(factor) {
            if (factor === void 0) { factor = 0.1; }
            this.factor = factor;
        }
        Desaturate.prototype.updatePixel = function (x, y, imageData) {
            var firstPixel = (x + y * imageData.width) * 4;
            var pixel = imageData.data;
            var color = Color_8.Color.fromRGB(pixel[firstPixel + 0], pixel[firstPixel + 1], pixel[firstPixel + 2], pixel[firstPixel + 3]).desaturate(this.factor);
            pixel[firstPixel + 0] = color.r;
            pixel[firstPixel + 1] = color.g;
            pixel[firstPixel + 2] = color.b;
            pixel[firstPixel + 3] = color.a;
        };
        return Desaturate;
    }());
    exports.Desaturate = Desaturate;
    /**
     * Applies the "Fill" effect to a sprite, changing the color channels of all non-transparent pixels to match
     * a given color
     */
    var Fill = (function () {
        /**
         * @param color  The color to apply to the sprite
         */
        function Fill(color) {
            this.color = color;
        }
        Fill.prototype.updatePixel = function (x, y, imageData) {
            var firstPixel = (x + y * imageData.width) * 4;
            var pixel = imageData.data;
            if (pixel[firstPixel + 3] !== 0) {
                pixel[firstPixel + 0] = this.color.r;
                pixel[firstPixel + 1] = this.color.g;
                pixel[firstPixel + 2] = this.color.b;
            }
        };
        return Fill;
    }());
    exports.Fill = Fill;
});
define("Interfaces/IDrawable", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Interfaces/ILoadable", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Resources/Resource", ["require", "exports", "Class", "Promises", "Util/Log"], function (require, exports, Class_2, Promises_3, Log_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The [[Resource]] type allows games built in Excalibur to load generic resources.
     * For any type of remote resource it is recommended to use [[Resource]] for preloading.
     *
     * [[include:Resources.md]]
     */
    var Resource = (function (_super) {
        __extends(Resource, _super);
        /**
         * @param path          Path to the remote resource
         * @param responseType  The type to expect as a response: "" | "arraybuffer" | "blob" | "document" | "json" | "text";
         * @param bustCache     Whether or not to cache-bust requests
         */
        function Resource(path, responseType, bustCache) {
            if (bustCache === void 0) { bustCache = true; }
            var _this = _super.call(this) || this;
            _this.path = path;
            _this.responseType = responseType;
            _this.bustCache = bustCache;
            _this.data = null;
            _this.logger = Log_2.Logger.getInstance();
            _this.onprogress = function () { return; };
            _this.oncomplete = function () { return; };
            _this.onerror = function () { return; };
            return _this;
        }
        /**
         * Returns true if the Resource is completely loaded and is ready
         * to be drawn.
         */
        Resource.prototype.isLoaded = function () {
            return this.data !== null;
        };
        Resource.prototype.wireEngine = function (_engine) {
            // override me
        };
        Resource.prototype._cacheBust = function (uri) {
            var query = /\?\w*=\w*/;
            if (query.test(uri)) {
                uri += ('&__=' + Date.now());
            }
            else {
                uri += ('?__=' + Date.now());
            }
            return uri;
        };
        Resource.prototype._start = function () {
            this.logger.debug('Started loading resource ' + this.path);
        };
        /**
         * Begin loading the resource and returns a promise to be resolved on completion
         */
        Resource.prototype.load = function () {
            var _this = this;
            var complete = new Promises_3.Promise();
            // Exit early if we already have data
            if (this.data !== null) {
                this.logger.debug('Already have data for resource', this.path);
                complete.resolve(this.data);
                this.oncomplete();
                return complete;
            }
            var request = new XMLHttpRequest();
            request.open('GET', this.bustCache ? this._cacheBust(this.path) : this.path, true);
            request.responseType = this.responseType;
            request.onloadstart = function () { _this._start(); };
            request.onprogress = this.onprogress;
            request.onerror = this.onerror;
            request.onload = function () {
                // XHR on file:// success status is 0, such as with PhantomJS
                if (request.status !== 0 && request.status !== 200) {
                    _this.logger.error('Failed to load resource ', _this.path, ' server responded with error code', request.status);
                    _this.onerror(request.response);
                    complete.resolve(request.response);
                    return;
                }
                _this.data = _this.processData(request.response);
                _this.oncomplete();
                _this.logger.debug('Completed loading resource', _this.path);
                complete.resolve(_this.data);
            };
            request.send();
            return complete;
        };
        /**
         * Returns the loaded data once the resource is loaded
         */
        Resource.prototype.getData = function () {
            return this.data;
        };
        /**
         * Sets the data for this resource directly
         */
        Resource.prototype.setData = function (data) {
            this.data = this.processData(data);
        };
        /**
         * This method is meant to be overriden to handle any additional
         * processing. Such as decoding downloaded audio bits.
         */
        Resource.prototype.processData = function (data) {
            // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseType
            // Blob requires an object url
            if (this.responseType === 'blob') {
                return URL.createObjectURL(data);
            }
            return data;
        };
        return Resource;
    }(Class_2.Class));
    exports.Resource = Resource;
});
define("Resources/Texture", ["require", "exports", "Resources/Resource", "Promises", "Drawing/Sprite"], function (require, exports, Resource_1, Promises_4, Sprite_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The [[Texture]] object allows games built in Excalibur to load image resources.
     * [[Texture]] is an [[ILoadable]] which means it can be passed to a [[Loader]]
     * to pre-load before starting a level or game.
     *
     * [[include:Textures.md]]
     */
    var Texture = (function (_super) {
        __extends(Texture, _super);
        /**
         * @param path       Path to the image resource
         * @param bustCache  Optionally load texture with cache busting
         */
        function Texture(path, bustCache) {
            if (bustCache === void 0) { bustCache = true; }
            var _this = _super.call(this, path, 'blob', bustCache) || this;
            _this.path = path;
            _this.bustCache = bustCache;
            /**
             * A [[Promise]] that resolves when the Texture is loaded.
             */
            _this.loaded = new Promises_4.Promise();
            _this._isLoaded = false;
            _this._sprite = null;
            _this._sprite = new Sprite_1.Sprite(_this, 0, 0, 0, 0);
            return _this;
        }
        /**
         * Returns true if the Texture is completely loaded and is ready
         * to be drawn.
         */
        Texture.prototype.isLoaded = function () {
            return this._isLoaded;
        };
        /**
         * Begins loading the texture and returns a promise to be resolved on completion
         */
        Texture.prototype.load = function () {
            var _this = this;
            var complete = new Promises_4.Promise();
            var loaded = _super.prototype.load.call(this);
            loaded.then(function () {
                _this.image = new Image();
                _this.image.addEventListener('load', function () {
                    _this._isLoaded = true;
                    _this.width = _this._sprite.swidth = _this._sprite.naturalWidth = _this._sprite.width = _this.image.naturalWidth;
                    _this.height = _this._sprite.sheight = _this._sprite.naturalHeight = _this._sprite.height = _this.image.naturalHeight;
                    _this.loaded.resolve(_this.image);
                    complete.resolve(_this.image);
                });
                _this.image.src = _super.prototype.getData.call(_this);
            }, function () {
                complete.reject('Error loading texture.');
            });
            return complete;
        };
        Texture.prototype.asSprite = function () {
            return this._sprite;
        };
        return Texture;
    }(Resource_1.Resource));
    exports.Texture = Texture;
});
define("Drawing/Sprite", ["require", "exports", "Drawing/SpriteEffects", "Drawing/Color", "Resources/Texture", "Algebra", "Util/Log", "Util/Util", "Configurable"], function (require, exports, Effects, Color_9, Texture_1, Algebra_11, Log_3, Util_2, Configurable_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @hidden
     */
    var SpriteImpl = (function () {
        /**
         * @param image   The backing image texture to build the Sprite
         * @param sx      The x position of the sprite
         * @param sy      The y position of the sprite
         * @param swidth  The width of the sprite in pixels
         * @param sheight The height of the sprite in pixels
         */
        function SpriteImpl(imageOrConfig, sx, sy, swidth, sheight) {
            var _this = this;
            this.rotation = 0.0;
            this.anchor = new Algebra_11.Vector(0.0, 0.0);
            this.scale = new Algebra_11.Vector(1, 1);
            this.logger = Log_3.Logger.getInstance();
            /**
             * Draws the sprite flipped vertically
             */
            this.flipVertical = false;
            /**
             * Draws the sprite flipped horizontally
             */
            this.flipHorizontal = false;
            this.width = 0;
            this.height = 0;
            this.effects = [];
            this.sx = 0;
            this.sy = 0;
            this.swidth = 0;
            this.sheight = 0;
            this.naturalWidth = 0;
            this.naturalHeight = 0;
            this._spriteCanvas = null;
            this._spriteCtx = null;
            this._pixelData = null;
            this._pixelsLoaded = false;
            this._dirtyEffect = false;
            if (sx < 0 || sy < 0 || swidth < 0 || sheight < 0) {
                this.logger.error('Sprite cannot have any negative dimensions x:', sx, 'y:', sy, 'width:', swidth, 'height:', sheight);
            }
            var image = imageOrConfig;
            if (imageOrConfig && !(imageOrConfig instanceof Texture_1.Texture)) {
                sx = imageOrConfig.sx;
                sy = imageOrConfig.sy;
                swidth = imageOrConfig.swidth;
                sheight = imageOrConfig.sheight;
                image = imageOrConfig.image;
            }
            this.sx = sx || 0;
            this.sy = sy || 0;
            this.swidth = swidth || 0;
            this.sheight = sheight || 0;
            this._texture = image;
            this._spriteCanvas = document.createElement('canvas');
            this._spriteCanvas.width = swidth;
            this._spriteCanvas.height = sheight;
            this._spriteCtx = this._spriteCanvas.getContext('2d');
            this._texture.loaded.then(function () {
                _this._spriteCanvas.width = _this._spriteCanvas.width || _this._texture.image.naturalWidth;
                _this._spriteCanvas.height = _this._spriteCanvas.height || _this._texture.image.naturalHeight;
                _this._loadPixels();
                _this._dirtyEffect = true;
            }).error(function (e) {
                _this.logger.error('Error loading texture ', _this._texture.path, e);
            });
            this.width = swidth;
            this.height = sheight;
            this.naturalWidth = swidth;
            this.naturalHeight = sheight;
        }
        SpriteImpl.prototype._loadPixels = function () {
            if (this._texture.isLoaded() && !this._pixelsLoaded) {
                var naturalWidth = this._texture.image.naturalWidth || 0;
                var naturalHeight = this._texture.image.naturalHeight || 0;
                if (this.swidth > naturalWidth) {
                    this.logger.warn('The sprite width', this.swidth, 'exceeds the width', naturalWidth, 'of the backing texture', this._texture.path);
                }
                if (this.sheight > naturalHeight) {
                    this.logger.warn('The sprite height', this.sheight, 'exceeds the height', naturalHeight, 'of the backing texture', this._texture.path);
                }
                this._spriteCtx.drawImage(this._texture.image, Util_2.clamp(this.sx, 0, naturalWidth), Util_2.clamp(this.sy, 0, naturalHeight), Util_2.clamp(this.swidth, 0, naturalWidth), Util_2.clamp(this.sheight, 0, naturalHeight), 0, 0, this.swidth, this.sheight);
                this._pixelsLoaded = true;
            }
        };
        /**
         * Applies the [[Opacity]] effect to a sprite, setting the alpha of all pixels to a given value
         */
        SpriteImpl.prototype.opacity = function (value) {
            this.addEffect(new Effects.Opacity(value));
        };
        /**
         * Applies the [[Grayscale]] effect to a sprite, removing color information.
         */
        SpriteImpl.prototype.grayscale = function () {
            this.addEffect(new Effects.Grayscale());
        };
        /**
         * Applies the [[Invert]] effect to a sprite, inverting the pixel colors.
         */
        SpriteImpl.prototype.invert = function () {
            this.addEffect(new Effects.Invert());
        };
        /**
         * Applies the [[Fill]] effect to a sprite, changing the color channels of all non-transparent pixels to match a given color
         */
        SpriteImpl.prototype.fill = function (color) {
            this.addEffect(new Effects.Fill(color));
        };
        /**
         * Applies the [[Colorize]] effect to a sprite, changing the color channels of all pixels to be the average of the original color
         * and the provided color.
         */
        SpriteImpl.prototype.colorize = function (color) {
            this.addEffect(new Effects.Colorize(color));
        };
        /**
         * Applies the [[Lighten]] effect to a sprite, changes the lightness of the color according to HSL
         */
        SpriteImpl.prototype.lighten = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            this.addEffect(new Effects.Lighten(factor));
        };
        /**
         * Applies the [[Darken]] effect to a sprite, changes the darkness of the color according to HSL
         */
        SpriteImpl.prototype.darken = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            this.addEffect(new Effects.Darken(factor));
        };
        /**
         * Applies the [[Saturate]] effect to a sprite, saturates the color according to HSL
         */
        SpriteImpl.prototype.saturate = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            this.addEffect(new Effects.Saturate(factor));
        };
        /**
         * Applies the [[Desaturate]] effect to a sprite, desaturates the color according to HSL
         */
        SpriteImpl.prototype.desaturate = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            this.addEffect(new Effects.Desaturate(factor));
        };
        /**
         * Adds a new [[ISpriteEffect]] to this drawing.
         * @param effect  Effect to add to the this drawing
         */
        SpriteImpl.prototype.addEffect = function (effect) {
            this.effects.push(effect);
            // We must check if the texture and the backing sprite pixels are loaded as well before 
            // an effect can be applied
            if (!this._texture.isLoaded() || !this._pixelsLoaded) {
                this._dirtyEffect = true;
            }
            else {
                this._applyEffects();
            }
        };
        SpriteImpl.prototype.removeEffect = function (param) {
            var indexToRemove = -1;
            if (typeof param === 'number') {
                indexToRemove = param;
            }
            else {
                indexToRemove = this.effects.indexOf(param);
            }
            // bounds check
            if (indexToRemove < 0 || indexToRemove >= this.effects.length) {
                return;
            }
            this.effects.splice(indexToRemove, 1);
            // We must check if the texture and the backing sprite pixels are loaded as well before 
            // an effect can be applied
            if (!this._texture.isLoaded() || !this._pixelsLoaded) {
                this._dirtyEffect = true;
            }
            else {
                this._applyEffects();
            }
        };
        SpriteImpl.prototype._applyEffects = function () {
            var naturalWidth = this._texture.image.naturalWidth || 0;
            var naturalHeight = this._texture.image.naturalHeight || 0;
            this._spriteCtx.clearRect(0, 0, this.swidth, this.sheight);
            this._spriteCtx.drawImage(this._texture.image, Util_2.clamp(this.sx, 0, naturalWidth), Util_2.clamp(this.sy, 0, naturalHeight), Util_2.clamp(this.swidth, 0, naturalWidth), Util_2.clamp(this.sheight, 0, naturalHeight), 0, 0, this.swidth, this.sheight);
            this._pixelData = this._spriteCtx.getImageData(0, 0, this.swidth, this.sheight);
            var i = 0, x = 0, y = 0, len = this.effects.length;
            for (i; i < len; i++) {
                y = 0;
                for (y; y < this.sheight; y++) {
                    x = 0;
                    for (x; x < this.swidth; x++) {
                        this.effects[i].updatePixel(x, y, this._pixelData);
                    }
                }
            }
            this._spriteCtx.clearRect(0, 0, this.swidth, this.sheight);
            this._spriteCtx.putImageData(this._pixelData, 0, 0);
            this._dirtyEffect = false;
        };
        /**
         * Clears all effects from the drawing and return it to its original state.
         */
        SpriteImpl.prototype.clearEffects = function () {
            this.effects.length = 0;
            this._applyEffects();
        };
        /**
         * Resets the internal state of the drawing (if any)
         */
        SpriteImpl.prototype.reset = function () {
            // do nothing
        };
        SpriteImpl.prototype.debugDraw = function (ctx, x, y) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(this.rotation);
            var scaledSWidth = this.width * this.scale.x;
            var scaledSHeight = this.height * this.scale.y;
            var xpoint = (scaledSWidth) * this.anchor.x;
            var ypoint = (scaledSHeight) * this.anchor.y;
            ctx.strokeStyle = Color_9.Color.Black.toString();
            ctx.strokeRect(-xpoint, -ypoint, scaledSWidth, scaledSHeight);
            ctx.restore();
        };
        /**
         * Draws the sprite appropriately to the 2D rendering context, at an x and y coordinate.
         * @param ctx  The 2D rendering context
         * @param x    The x coordinate of where to draw
         * @param y    The y coordinate of where to draw
         */
        SpriteImpl.prototype.draw = function (ctx, x, y) {
            if (this._dirtyEffect) {
                this._applyEffects();
            }
            // calculating current dimensions
            this.width = this.naturalWidth * this.scale.x;
            this.height = this.naturalHeight * this.scale.y;
            ctx.save();
            var xpoint = this.width * this.anchor.x;
            var ypoint = this.height * this.anchor.y;
            ctx.translate(x, y);
            ctx.rotate(this.rotation);
            var scaledSWidth = this.swidth * this.scale.x;
            var scaledSHeight = this.sheight * this.scale.y;
            // todo cache flipped sprites
            if (this.flipHorizontal) {
                ctx.translate(scaledSWidth, 0);
                ctx.scale(-1, 1);
            }
            if (this.flipVertical) {
                ctx.translate(0, scaledSHeight);
                ctx.scale(1, -1);
            }
            ctx.drawImage(this._spriteCanvas, 0, 0, this.swidth, this.sheight, -xpoint, -ypoint, scaledSWidth, scaledSHeight);
            ctx.restore();
        };
        /**
         * Produces a copy of the current sprite
         */
        SpriteImpl.prototype.clone = function () {
            var result = new Sprite(this._texture, this.sx, this.sy, this.swidth, this.sheight);
            result.scale = this.scale.clone();
            result.rotation = this.rotation;
            result.flipHorizontal = this.flipHorizontal;
            result.flipVertical = this.flipVertical;
            var i = 0, len = this.effects.length;
            for (i; i < len; i++) {
                result.addEffect(this.effects[i]);
            }
            return result;
        };
        return SpriteImpl;
    }());
    exports.SpriteImpl = SpriteImpl;
    /**
     * A [[Sprite]] is one of the main drawing primitives. It is responsible for drawing
     * images or parts of images from a [[Texture]] resource to the screen.
     *
     * [[include:Sprites.md]]
     */
    var Sprite = (function (_super) {
        __extends(Sprite, _super);
        function Sprite(imageOrConfig, sx, sy, swidth, sheight) {
            return _super.call(this, imageOrConfig, sx, sy, swidth, sheight) || this;
        }
        return Sprite;
    }(Configurable_1.Configurable(SpriteImpl)));
    exports.Sprite = Sprite;
});
define("Drawing/Animation", ["require", "exports", "Drawing/SpriteEffects", "Algebra", "Engine", "Util/Util", "Configurable"], function (require, exports, Effects, Algebra_12, Engine_1, Util, Configurable_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @hidden
     */
    var AnimationImpl = (function () {
        /**
         * Typically you will use a [[SpriteSheet]] to generate an [[Animation]].
         *
         * @param engine  Reference to the current game engine
         * @param images  An array of sprites to create the frames for the animation
         * @param speed   The number in milliseconds to display each frame in the animation
         * @param loop    Indicates whether the animation should loop after it is completed
         */
        function AnimationImpl(engineOrConfig, sprites, speed, loop) {
            /**
             * The sprite frames to play, in order. See [[SpriteSheet.getAnimationForAll]] to quickly
             * generate an [[Animation]].
             */
            this.sprites = [];
            /**
             * Current frame index being shown
             */
            this.currentFrame = 0;
            this._oldTime = Date.now();
            this.anchor = new Algebra_12.Vector(0.0, 0.0);
            this.rotation = 0.0;
            this.scale = new Algebra_12.Vector(1, 1);
            /**
             * Indicates whether the animation should loop after it is completed
             */
            this.loop = true;
            /**
             * Indicates the frame index the animation should freeze on for a non-looping
             * animation. By default it is the last frame.
             */
            this.freezeFrame = -1;
            /**
             * Flip each frame vertically. Sets [[Sprite.flipVertical]].
             */
            this.flipVertical = false;
            /**
             * Flip each frame horizontally. Sets [[Sprite.flipHorizontal]].
             */
            this.flipHorizontal = false;
            this.width = 0;
            this.height = 0;
            this.naturalWidth = 0;
            this.naturalHeight = 0;
            var engine = engineOrConfig;
            if (engineOrConfig && !(engineOrConfig instanceof Engine_1.Engine)) {
                var config = engineOrConfig;
                engine = config.engine;
                sprites = config.sprites;
                speed = config.speed;
                loop = config.loop;
            }
            this.sprites = sprites;
            this.speed = speed;
            this._engine = engine;
            if (loop != null) {
                this.loop = loop;
            }
            if (sprites && sprites[0]) {
                this.height = sprites[0] ? sprites[0].height : 0;
                this.width = sprites[0] ? sprites[0].width : 0;
                this.naturalWidth = sprites[0] ? sprites[0].naturalWidth : 0;
                this.naturalHeight = sprites[0] ? sprites[0].naturalHeight : 0;
                this.freezeFrame = sprites.length - 1;
            }
        }
        /**
         * Applies the opacity effect to a sprite, setting the alpha of all pixels to a given value
         */
        AnimationImpl.prototype.opacity = function (value) {
            this.addEffect(new Effects.Opacity(value));
        };
        /**
         * Applies the grayscale effect to a sprite, removing color information.
         */
        AnimationImpl.prototype.grayscale = function () {
            this.addEffect(new Effects.Grayscale());
        };
        /**
         * Applies the invert effect to a sprite, inverting the pixel colors.
         */
        AnimationImpl.prototype.invert = function () {
            this.addEffect(new Effects.Invert());
        };
        /**
         * Applies the fill effect to a sprite, changing the color channels of all non-transparent pixels to match a given color
         */
        AnimationImpl.prototype.fill = function (color) {
            this.addEffect(new Effects.Fill(color));
        };
        /**
         * Applies the colorize effect to a sprite, changing the color channels of all pixels to be the average of the original color and the
         * provided color.
         */
        AnimationImpl.prototype.colorize = function (color) {
            this.addEffect(new Effects.Colorize(color));
        };
        /**
         * Applies the lighten effect to a sprite, changes the lightness of the color according to hsl
         */
        AnimationImpl.prototype.lighten = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            this.addEffect(new Effects.Lighten(factor));
        };
        /**
         * Applies the darken effect to a sprite, changes the darkness of the color according to hsl
         */
        AnimationImpl.prototype.darken = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            this.addEffect(new Effects.Darken(factor));
        };
        /**
         * Applies the saturate effect to a sprite, saturates the color according to hsl
         */
        AnimationImpl.prototype.saturate = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            this.addEffect(new Effects.Saturate(factor));
        };
        /**
         * Applies the desaturate effect to a sprite, desaturates the color according to hsl
         */
        AnimationImpl.prototype.desaturate = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            this.addEffect(new Effects.Desaturate(factor));
        };
        /**
         * Add a [[ISpriteEffect]] manually
         */
        AnimationImpl.prototype.addEffect = function (effect) {
            for (var i in this.sprites) {
                this.sprites[i].addEffect(effect);
            }
        };
        AnimationImpl.prototype.removeEffect = function (param) {
            for (var i in this.sprites) {
                this.sprites[i].removeEffect(param);
            }
        };
        /**
         * Clear all sprite effects
         */
        AnimationImpl.prototype.clearEffects = function () {
            for (var i in this.sprites) {
                this.sprites[i].clearEffects();
            }
        };
        AnimationImpl.prototype._setAnchor = function (point) {
            //if (!this.anchor.equals(point)) {
            for (var i in this.sprites) {
                this.sprites[i].anchor.setTo(point.x, point.y);
            }
            //}
        };
        AnimationImpl.prototype._setRotation = function (radians) {
            //if (this.rotation !== radians) {
            for (var i in this.sprites) {
                this.sprites[i].rotation = radians;
            }
            //}
        };
        AnimationImpl.prototype._setScale = function (scale) {
            //if (!this.scale.equals(scale)) {
            for (var i in this.sprites) {
                this.sprites[i].scale = scale;
            }
            //}
        };
        /**
         * Resets the animation to first frame.
         */
        AnimationImpl.prototype.reset = function () {
            this.currentFrame = 0;
        };
        /**
         * Indicates whether the animation is complete, animations that loop are never complete.
         */
        AnimationImpl.prototype.isDone = function () {
            return (!this.loop && this.currentFrame >= this.sprites.length);
        };
        /**
         * Not meant to be called by game developers. Ticks the animation forward internally and
         * calculates whether to change to the frame.
         * @internal
         */
        AnimationImpl.prototype.tick = function () {
            var time = Date.now();
            if ((time - this._oldTime) > this.speed) {
                this.currentFrame = (this.loop ? (this.currentFrame + 1) % this.sprites.length : this.currentFrame + 1);
                this._oldTime = time;
            }
        };
        AnimationImpl.prototype._updateValues = function () {
            this._setAnchor(this.anchor);
            this._setRotation(this.rotation);
            this._setScale(this.scale);
        };
        /**
         * Skips ahead a specified number of frames in the animation
         * @param frames  Frames to skip ahead
         */
        AnimationImpl.prototype.skip = function (frames) {
            this.currentFrame = (this.currentFrame + frames) % this.sprites.length;
        };
        AnimationImpl.prototype.draw = function (ctx, x, y) {
            this.tick();
            this._updateValues();
            var currSprite;
            if (this.currentFrame < this.sprites.length) {
                currSprite = this.sprites[this.currentFrame];
                if (this.flipVertical) {
                    currSprite.flipVertical = this.flipVertical;
                }
                if (this.flipHorizontal) {
                    currSprite.flipHorizontal = this.flipHorizontal;
                }
                currSprite.draw(ctx, x, y);
            }
            if (this.freezeFrame !== -1 && this.currentFrame >= this.sprites.length) {
                currSprite = this.sprites[Util.clamp(this.freezeFrame, 0, this.sprites.length - 1)];
                currSprite.draw(ctx, x, y);
            }
            // add the calculated width
            if (currSprite) {
                this.width = currSprite.width;
                this.height = currSprite.height;
            }
        };
        /**
         * Plays an animation at an arbitrary location in the game.
         * @param x  The x position in the game to play
         * @param y  The y position in the game to play
         */
        AnimationImpl.prototype.play = function (x, y) {
            this.reset();
            this._engine.playAnimation(this, x, y);
        };
        return AnimationImpl;
    }());
    exports.AnimationImpl = AnimationImpl;
    /**
     * Animations allow you to display a series of images one after another,
     * creating the illusion of change. Generally these images will come from a [[SpriteSheet]] source.
     *
     * [[include:Animations.md]]
     */
    var Animation = (function (_super) {
        __extends(Animation, _super);
        function Animation(engineOrConfig, images, speed, loop) {
            return _super.call(this, engineOrConfig, images, speed, loop) || this;
        }
        return Animation;
    }(Configurable_2.Configurable(AnimationImpl)));
    exports.Animation = Animation;
});
define("Drawing/SpriteSheet", ["require", "exports", "Drawing/Sprite", "Drawing/Animation", "Drawing/Color", "Drawing/SpriteEffects", "Resources/Texture", "Util/Log", "Label", "Configurable"], function (require, exports, Sprite_2, Animation_1, Color_10, Effects, Texture_2, Log_4, Label_1, Configurable_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @hidden
     */
    var SpriteSheetImpl = (function () {
        /**
         * @param image     The backing image texture to build the SpriteSheet
         * @param columns   The number of columns in the image texture
         * @param rows      The number of rows in the image texture
         * @param spWidth   The width of each individual sprite in pixels
         * @param spHeight  The height of each individual sprite in pixels
         */
        function SpriteSheetImpl(imageOrConfigOrSprites, columns, rows, spWidth, spHeight) {
            this.sprites = [];
            this.image = null;
            this.columns = 0;
            this.rows = 0;
            var loadFromImage = false;
            if (imageOrConfigOrSprites instanceof Array) {
                this.sprites = imageOrConfigOrSprites;
            }
            else {
                if (imageOrConfigOrSprites && !(imageOrConfigOrSprites instanceof Texture_2.Texture)) {
                    this.columns = imageOrConfigOrSprites.columns;
                    this.rows = imageOrConfigOrSprites.rows;
                    this.spWidth = imageOrConfigOrSprites.spWidth;
                    this.spHeight = imageOrConfigOrSprites.spHeight;
                    this.image = imageOrConfigOrSprites.image;
                }
                else {
                    this.image = imageOrConfigOrSprites;
                    this.columns = columns;
                    this.rows = rows;
                    this.spWidth = spWidth;
                    this.spHeight = spHeight;
                }
                this.sprites = new Array(this.columns * this.rows);
                loadFromImage = true;
            }
            // TODO: Inspect actual image dimensions with preloading
            /*if(spWidth * columns > this.internalImage.naturalWidth){
               throw new Error("SpriteSheet specified is wider than image width");
            }
      
            if(spHeight * rows > this.internalImage.naturalHeight){
               throw new Error("SpriteSheet specified is higher than image height");
            }*/
            if (loadFromImage) {
                var i = 0;
                var j = 0;
                for (i = 0; i < this.rows; i++) {
                    for (j = 0; j < this.columns; j++) {
                        this.sprites[j + i * this.columns] = new Sprite_2.Sprite(this.image, j * this.spWidth, i * this.spHeight, this.spWidth, this.spHeight);
                    }
                }
            }
        }
        /**
         * Create an animation from the this SpriteSheet by listing out the
         * sprite indices. Sprites are organized in row major order in the SpriteSheet.
         * @param engine   Reference to the current game [[Engine]]
         * @param indices  An array of sprite indices to use in the animation
         * @param speed    The number in milliseconds to display each frame in the animation
         */
        SpriteSheetImpl.prototype.getAnimationByIndices = function (engine, indices, speed) {
            var _this = this;
            var images = indices.map(function (index) {
                return _this.sprites[index];
            });
            images = images.map(function (i) {
                return i.clone();
            });
            return new Animation_1.Animation(engine, images, speed);
        };
        /**
         * Create an animation from the this SpriteSheet by specifing the range of
         * images with the beginning (inclusive) and ending (exclusive) index
         * For example `getAnimationBetween(engine, 0, 5, 200)` returns an animation with 5 frames.
         * @param engine      Reference to the current game Engine
         * @param beginIndex  The index to start taking frames (inclusive)
         * @param endIndex    The index to stop taking frames (exclusive)
         * @param speed       The number in milliseconds to display each frame in the animation
         */
        SpriteSheetImpl.prototype.getAnimationBetween = function (engine, beginIndex, endIndex, speed) {
            var images = this.sprites.slice(beginIndex, endIndex);
            images = images.map(function (i) {
                return i.clone();
            });
            return new Animation_1.Animation(engine, images, speed);
        };
        /**
         * Treat the entire SpriteSheet as one animation, organizing the frames in
         * row major order.
         * @param engine  Reference to the current game [[Engine]]
         * @param speed   The number in milliseconds to display each frame the animation
         */
        SpriteSheetImpl.prototype.getAnimationForAll = function (engine, speed) {
            var sprites = this.sprites.map(function (i) {
                return i.clone();
            });
            return new Animation_1.Animation(engine, sprites, speed);
        };
        /**
         * Retreive a specific sprite from the SpriteSheet by its index. Sprites are organized
         * in row major order in the SpriteSheet.
         * @param index  The index of the sprite
         */
        SpriteSheetImpl.prototype.getSprite = function (index) {
            if (index >= 0 && index < this.sprites.length) {
                return this.sprites[index];
            }
            else {
                throw new Error('Invalid index: ' + index);
            }
        };
        return SpriteSheetImpl;
    }());
    exports.SpriteSheetImpl = SpriteSheetImpl;
    /**
     * Sprite sheets are a useful mechanism for slicing up image resources into
     * separate sprites or for generating in game animations. [[Sprite|Sprites]] are organized
     * in row major order in the [[SpriteSheet]].
     *
     * [[include:SpriteSheets.md]]
     */
    var SpriteSheet = (function (_super) {
        __extends(SpriteSheet, _super);
        function SpriteSheet(imageOrConfigOrSprites, columns, rows, spWidth, spHeight) {
            return _super.call(this, imageOrConfigOrSprites, columns, rows, spWidth, spHeight) || this;
        }
        return SpriteSheet;
    }(Configurable_3.Configurable(SpriteSheetImpl)));
    exports.SpriteSheet = SpriteSheet;
    var SpriteFontImpl = (function (_super) {
        __extends(SpriteFontImpl, _super);
        /**
         * @param image           The backing image texture to build the SpriteFont
         * @param alphabet        A string representing all the characters in the image, in row major order.
         * @param caseInsensitive  Indicate whether this font takes case into account
         * @param columns         The number of columns of characters in the image
         * @param rows            The number of rows of characters in the image
         * @param spWidth         The width of each character in pixels
         * @param spHeight        The height of each character in pixels
         */
        function SpriteFontImpl(imageOrConfig, alphabet, caseInsensitive, columns, rows, spWidth, spHeight) {
            var _this = _super.call(this, imageOrConfig instanceof Texture_2.Texture ? { image: imageOrConfig, spWidth: spWidth,
                spHeight: spHeight, rows: rows, columns: columns } : imageOrConfig) || this;
            _this._currentColor = Color_10.Color.Black.clone();
            _this._currentOpacity = 1.0;
            _this._sprites = {};
            // text shadow
            _this._textShadowOn = false;
            _this._textShadowDirty = true;
            _this._textShadowColor = Color_10.Color.Black.clone();
            _this._textShadowSprites = {};
            _this._shadowOffsetX = 5;
            _this._shadowOffsetY = 5;
            if (imageOrConfig && !(imageOrConfig instanceof Texture_2.Texture)) {
                alphabet = imageOrConfig.alphabet;
                caseInsensitive = imageOrConfig.caseInsensitive;
            }
            _this._alphabet = alphabet;
            _this._caseInsensitive = caseInsensitive;
            _this._sprites = _this.getTextSprites();
            return _this;
        }
        /**
         * Returns a dictionary that maps each character in the alphabet to the appropriate [[Sprite]].
         */
        SpriteFontImpl.prototype.getTextSprites = function () {
            var lookup = {};
            for (var i = 0; i < this._alphabet.length; i++) {
                var char = this._alphabet[i];
                if (this._caseInsensitive) {
                    char = char.toLowerCase();
                }
                lookup[char] = this.sprites[i].clone();
            }
            return lookup;
        };
        /**
         * Sets the text shadow for sprite fonts
         * @param offsetX      The x offset in pixels to place the shadow
         * @param offsetY      The y offset in pixels to place the shadow
         * @param shadowColor  The color of the text shadow
         */
        SpriteFontImpl.prototype.setTextShadow = function (offsetX, offsetY, shadowColor) {
            this._textShadowOn = true;
            this._shadowOffsetX = offsetX;
            this._shadowOffsetY = offsetY;
            this._textShadowColor = shadowColor.clone();
            this._textShadowDirty = true;
            for (var character in this._sprites) {
                this._textShadowSprites[character] = this._sprites[character].clone();
            }
        };
        /**
         * Toggles text shadows on or off
         */
        SpriteFontImpl.prototype.useTextShadow = function (on) {
            this._textShadowOn = on;
            if (on) {
                this.setTextShadow(5, 5, this._textShadowColor);
            }
        };
        /**
         * Draws the current sprite font
         */
        SpriteFontImpl.prototype.draw = function (ctx, text, x, y, options) {
            options = this._parseOptions(options);
            if (this._currentColor.toString() !== options.color.toString() || this._currentOpacity !== options.opacity) {
                this._currentOpacity = options.opacity;
                this._currentColor = options.color;
                for (var char in this._sprites) {
                    this._sprites[char].clearEffects();
                    this._sprites[char].fill(options.color);
                    this._sprites[char].opacity(options.opacity);
                }
            }
            if (this._textShadowOn && this._textShadowDirty && this._textShadowColor) {
                for (var characterShadow in this._textShadowSprites) {
                    this._textShadowSprites[characterShadow].clearEffects();
                    this._textShadowSprites[characterShadow].addEffect(new Effects.Fill(this._textShadowColor.clone()));
                }
                this._textShadowDirty = false;
            }
            // find the current length of text in pixels
            var sprite = this.sprites[0];
            // find the current height fo the text in pixels
            var height = sprite.sheight;
            // calculate appropriate scale for font size
            var scale = options.fontSize / height;
            var length = (text.length * sprite.swidth * scale) + (text.length * options.letterSpacing);
            var currX = x;
            if (options.textAlign === Label_1.TextAlign.Left || options.textAlign === Label_1.TextAlign.Start) {
                currX = x;
            }
            else if (options.textAlign === Label_1.TextAlign.Right || options.textAlign === Label_1.TextAlign.End) {
                currX = x - length;
            }
            else if (options.textAlign === Label_1.TextAlign.Center) {
                currX = x - length / 2;
            }
            var currY = y - height * scale;
            if (options.baseAlign === Label_1.BaseAlign.Top || options.baseAlign === Label_1.BaseAlign.Hanging) {
                currY = y;
            }
            else if (options.baseAlign === Label_1.BaseAlign.Ideographic ||
                options.baseAlign === Label_1.BaseAlign.Bottom ||
                options.baseAlign === Label_1.BaseAlign.Alphabetic) {
                currY = y - height * scale;
            }
            else if (options.baseAlign === Label_1.BaseAlign.Middle) {
                currY = y - (height * scale) / 2;
            }
            for (var i = 0; i < text.length; i++) {
                var character = text[i];
                if (this._caseInsensitive) {
                    character = character.toLowerCase();
                }
                try {
                    // if text shadow
                    if (this._textShadowOn) {
                        this._textShadowSprites[character].scale.x = scale;
                        this._textShadowSprites[character].scale.y = scale;
                        this._textShadowSprites[character].draw(ctx, currX + this._shadowOffsetX, currY + this._shadowOffsetY);
                    }
                    var charSprite = this._sprites[character];
                    charSprite.scale.x = scale;
                    charSprite.scale.y = scale;
                    charSprite.draw(ctx, currX, currY);
                    currX += (charSprite.width + options.letterSpacing);
                }
                catch (e) {
                    Log_4.Logger.getInstance().error("SpriteFont Error drawing char " + character);
                }
            }
        };
        SpriteFontImpl.prototype._parseOptions = function (options) {
            return {
                fontSize: options.fontSize || 10,
                letterSpacing: options.letterSpacing || 0,
                color: options.color || Color_10.Color.Black.clone(),
                textAlign: typeof options.textAlign === undefined ? Label_1.TextAlign.Left : options.textAlign,
                baseAlign: typeof options.baseAlign === undefined ? Label_1.BaseAlign.Bottom : options.baseAlign,
                maxWidth: options.maxWidth || -1,
                opacity: options.opacity || 0
            };
        };
        return SpriteFontImpl;
    }(SpriteSheet));
    exports.SpriteFontImpl = SpriteFontImpl;
    /**
     * Sprite fonts are a used in conjunction with a [[Label]] to specify
     * a particular bitmap as a font. Note that some font features are not
     * supported by Sprite fonts.
     *
     * [[include:SpriteFonts.md]]
     */
    var SpriteFont = (function (_super) {
        __extends(SpriteFont, _super);
        function SpriteFont(imageOrConfig, alphabet, caseInsensitive, columns, rows, spWidth, spHeight) {
            return _super.call(this, imageOrConfig, alphabet, caseInsensitive, columns, rows, spWidth, spHeight) || this;
        }
        return SpriteFont;
    }(Configurable_3.Configurable(SpriteFontImpl)));
    exports.SpriteFont = SpriteFont;
});
define("Label", ["require", "exports", "Drawing/Color", "Actor", "Configurable"], function (require, exports, Color_11, Actor_4, Configurable_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Enum representing the different font size units
     * https://developer.mozilla.org/en-US/docs/Web/CSS/font-size
     */
    var FontUnit;
    (function (FontUnit) {
        /**
         * Em is a scalable unit, 1 em is equal to the current font size of the current element, parent elements can effect em values
         */
        FontUnit[FontUnit["Em"] = 0] = "Em";
        /**
         * Rem is similar to the Em, it is a scalable unit. 1 rem is eqaul to the font size of the root element
         */
        FontUnit[FontUnit["Rem"] = 1] = "Rem";
        /**
         * Pixel is a unit of length in screen pixels
         */
        FontUnit[FontUnit["Px"] = 2] = "Px";
        /**
         * Point is a physical unit length (1/72 of an inch)
         */
        FontUnit[FontUnit["Pt"] = 3] = "Pt";
        /**
         * Percent is a scalable unit similar to Em, the only difference is the Em units scale faster when Text-Size stuff
         */
        FontUnit[FontUnit["Percent"] = 4] = "Percent";
    })(FontUnit = exports.FontUnit || (exports.FontUnit = {}));
    /**
     * Enum representing the different horizontal text alignments
     */
    var TextAlign;
    (function (TextAlign) {
        /**
         * The text is left-aligned.
         */
        TextAlign[TextAlign["Left"] = 0] = "Left";
        /**
         * The text is right-aligned.
         */
        TextAlign[TextAlign["Right"] = 1] = "Right";
        /**
         * The text is centered.
         */
        TextAlign[TextAlign["Center"] = 2] = "Center";
        /**
         * The text is aligned at the normal start of the line (left-aligned for left-to-right locales,
         * right-aligned for right-to-left locales).
         */
        TextAlign[TextAlign["Start"] = 3] = "Start";
        /**
         * The text is aligned at the normal end of the line (right-aligned for left-to-right locales,
         * left-aligned for right-to-left locales).
         */
        TextAlign[TextAlign["End"] = 4] = "End";
    })(TextAlign = exports.TextAlign || (exports.TextAlign = {}));
    /**
     * Enum representing the different baseline text alignments
     */
    var BaseAlign;
    (function (BaseAlign) {
        /**
         * The text baseline is the top of the em square.
         */
        BaseAlign[BaseAlign["Top"] = 0] = "Top";
        /**
         * The text baseline is the hanging baseline.  Currently unsupported; this will act like
         * alphabetic.
         */
        BaseAlign[BaseAlign["Hanging"] = 1] = "Hanging";
        /**
         * The text baseline is the middle of the em square.
         */
        BaseAlign[BaseAlign["Middle"] = 2] = "Middle";
        /**
         * The text baseline is the normal alphabetic baseline.
         */
        BaseAlign[BaseAlign["Alphabetic"] = 3] = "Alphabetic";
        /**
         * The text baseline is the ideographic baseline; this is the bottom of
         * the body of the characters, if the main body of characters protrudes
         * beneath the alphabetic baseline.  Currently unsupported; this will
         * act like alphabetic.
         */
        BaseAlign[BaseAlign["Ideographic"] = 4] = "Ideographic";
        /**
         * The text baseline is the bottom of the bounding box.  This differs
         * from the ideographic baseline in that the ideographic baseline
         * doesn't consider descenders.
         */
        BaseAlign[BaseAlign["Bottom"] = 5] = "Bottom";
    })(BaseAlign = exports.BaseAlign || (exports.BaseAlign = {}));
    /**
     * Enum representing the different possible font styles
     */
    var FontStyle;
    (function (FontStyle) {
        FontStyle[FontStyle["Normal"] = 0] = "Normal";
        FontStyle[FontStyle["Italic"] = 1] = "Italic";
        FontStyle[FontStyle["Oblique"] = 2] = "Oblique";
    })(FontStyle = exports.FontStyle || (exports.FontStyle = {}));
    /**
     * @hidden
     */
    var LabelImpl = (function (_super) {
        __extends(LabelImpl, _super);
        /**
         * @param text        The text of the label
         * @param x           The x position of the label
         * @param y           The y position of the label
         * @param fontFamily  Use any valid CSS font string for the label's font. Web fonts are supported. Default is `10px sans-serif`.
         * @param spriteFont  Use an Excalibur sprite font for the label's font, if a SpriteFont is provided it will take precedence
         * over a css font.
         */
        function LabelImpl(textOrConfig, x, y, fontFamily, spriteFont) {
            var _this = _super.call(this, textOrConfig && typeof textOrConfig === 'object' ? {
                x: textOrConfig.x,
                y: textOrConfig.y
            } : { x: x, y: y }) || this;
            /**
             * Sets or gets the bold property of the label's text, by default it's false
             */
            _this.bold = false;
            /**
             * The font size in the selected units, default is 10 (default units is pixel)
             */
            _this.fontSize = 10;
            /**
             * The font style for this label, the default is [[FontStyle.Normal]]
             */
            _this.fontStyle = FontStyle.Normal;
            /**
             * The css units for a font size such as px, pt, em (SpriteFont only support px), by default is 'px';
             */
            _this.fontUnit = FontUnit.Px;
            /**
             * Gets or sets the horizontal text alignment property for the label.
             */
            _this.textAlign = TextAlign.Left;
            /**
             * Gets or sets the baseline alignment property for the label.
             */
            _this.baseAlign = BaseAlign.Bottom;
            /**
             * Gets or sets the letter spacing on a Label. Only supported with Sprite Fonts.
             */
            _this.letterSpacing = 0; //px
            /**
             * Whether or not the [[SpriteFont]] will be case-sensitive when matching characters.
             */
            _this.caseInsensitive = true;
            var text = '';
            if (textOrConfig && typeof textOrConfig === 'object') {
                fontFamily = textOrConfig.fontFamily;
                spriteFont = textOrConfig.spriteFont;
                text = textOrConfig.text;
            }
            else {
                text = textOrConfig;
            }
            _this.text = text || '';
            _this.color = Color_11.Color.Black.clone();
            _this.spriteFont = spriteFont;
            _this.collisionType = Actor_4.CollisionType.PreventCollision;
            _this.fontFamily = fontFamily || 'sans-serif'; // coalesce to default canvas font
            _this._textShadowOn = false;
            _this._shadowOffsetX = 0;
            _this._shadowOffsetY = 0;
            if (spriteFont) {
                //this._textSprites = spriteFont.getTextSprites();
            }
            return _this;
        }
        /**
         * Returns the width of the text in the label (in pixels);
         * @param ctx  Rendering context to measure the string with
         */
        LabelImpl.prototype.getTextWidth = function (ctx) {
            var oldFont = ctx.font;
            ctx.font = this._fontString;
            var width = ctx.measureText(this.text).width;
            ctx.font = oldFont;
            return width;
        };
        // TypeScript doesn't support string enums :(
        LabelImpl.prototype._lookupFontUnit = function (fontUnit) {
            switch (fontUnit) {
                case FontUnit.Em:
                    return 'em';
                case FontUnit.Rem:
                    return 'rem';
                case FontUnit.Pt:
                    return 'pt';
                case FontUnit.Px:
                    return 'px';
                case FontUnit.Percent:
                    return '%';
                default:
                    return 'px';
            }
        };
        LabelImpl.prototype._lookupTextAlign = function (textAlign) {
            switch (textAlign) {
                case TextAlign.Left:
                    return 'left';
                case TextAlign.Right:
                    return 'right';
                case TextAlign.Center:
                    return 'center';
                case TextAlign.End:
                    return 'end';
                case TextAlign.Start:
                    return 'start';
                default:
                    return 'start';
            }
        };
        LabelImpl.prototype._lookupBaseAlign = function (baseAlign) {
            switch (baseAlign) {
                case BaseAlign.Alphabetic:
                    return 'alphabetic';
                case BaseAlign.Bottom:
                    return 'bottom';
                case BaseAlign.Hanging:
                    return 'hangin';
                case BaseAlign.Ideographic:
                    return 'ideographic';
                case BaseAlign.Middle:
                    return 'middle';
                case BaseAlign.Top:
                    return 'top';
                default:
                    return 'alphabetic';
            }
        };
        LabelImpl.prototype._lookupFontStyle = function (fontStyle) {
            var boldstring = this.bold ? ' bold' : '';
            switch (fontStyle) {
                case FontStyle.Italic:
                    return 'italic' + boldstring;
                case FontStyle.Normal:
                    return 'normal' + boldstring;
                case FontStyle.Oblique:
                    return 'oblique' + boldstring;
                default:
                    return 'normal' + boldstring;
            }
        };
        /**
         * Sets the text shadow for sprite fonts
         * @param offsetX      The x offset in pixels to place the shadow
         * @param offsetY      The y offset in pixels to place the shadow
         * @param shadowColor  The color of the text shadow
         */
        LabelImpl.prototype.setTextShadow = function (offsetX, offsetY, shadowColor) {
            this.spriteFont.setTextShadow(offsetX, offsetY, shadowColor);
        };
        /**
         * Toggles text shadows on or off, only applies when using sprite fonts
         */
        LabelImpl.prototype.useTextShadow = function (on) {
            this.spriteFont.useTextShadow(on);
        };
        /**
         * Clears the current text shadow
         */
        LabelImpl.prototype.clearTextShadow = function () {
            this._textShadowOn = false;
            this._shadowOffsetX = 0;
            this._shadowOffsetY = 0;
        };
        LabelImpl.prototype.update = function (engine, delta) {
            _super.prototype.update.call(this, engine, delta);
        };
        LabelImpl.prototype.draw = function (ctx, delta) {
            ctx.save();
            ctx.translate(this.pos.x, this.pos.y);
            ctx.scale(this.scale.x, this.scale.y);
            ctx.rotate(this.rotation);
            if (this._textShadowOn) {
                ctx.save();
                ctx.translate(this._shadowOffsetX, this._shadowOffsetY);
                this._fontDraw(ctx);
                ctx.restore();
            }
            this._fontDraw(ctx);
            _super.prototype.draw.call(this, ctx, delta);
            ctx.restore();
        };
        LabelImpl.prototype._fontDraw = function (ctx) {
            if (this.spriteFont) {
                this.spriteFont.draw(ctx, this.text, 0, 0, {
                    color: this.color.clone(),
                    baseAlign: this.baseAlign,
                    textAlign: this.textAlign,
                    fontSize: this.fontSize,
                    letterSpacing: this.letterSpacing,
                    opacity: this.opacity
                });
            }
            else {
                var oldAlign = ctx.textAlign;
                var oldTextBaseline = ctx.textBaseline;
                ctx.textAlign = this._lookupTextAlign(this.textAlign);
                ctx.textBaseline = this._lookupBaseAlign(this.baseAlign);
                if (this.color) {
                    this.color.a = this.opacity;
                }
                ctx.fillStyle = this.color.toString();
                ctx.font = this._fontString;
                if (this.maxWidth) {
                    ctx.fillText(this.text, 0, 0, this.maxWidth);
                }
                else {
                    ctx.fillText(this.text, 0, 0);
                }
                ctx.textAlign = oldAlign;
                ctx.textBaseline = oldTextBaseline;
            }
        };
        Object.defineProperty(LabelImpl.prototype, "_fontString", {
            get: function () {
                return this._lookupFontStyle(this.fontStyle) + " " + this.fontSize + this._lookupFontUnit(this.fontUnit) + " " + this.fontFamily;
            },
            enumerable: true,
            configurable: true
        });
        LabelImpl.prototype.debugDraw = function (ctx) {
            _super.prototype.debugDraw.call(this, ctx);
        };
        return LabelImpl;
    }(Actor_4.Actor));
    exports.LabelImpl = LabelImpl;
    /**
     * Labels are the way to draw small amounts of text to the screen. They are
     * actors and inherit all of the benefits and capabilities.
     *
     * [[include:Labels.md]]
     */
    var Label = (function (_super) {
        __extends(Label, _super);
        function Label(textOrConfig, x, y, fontFamily, spriteFont) {
            return _super.call(this, textOrConfig, x, y, fontFamily, spriteFont) || this;
        }
        return Label;
    }(Configurable_4.Configurable(LabelImpl)));
    exports.Label = Label;
});
define("Interfaces/IAudio", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Interfaces/IAudioImplementation", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Resources/Sound", ["require", "exports", "Util/Log", "Util/Util", "Promises"], function (require, exports, Log_5, Util, Promises_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // set up audio context reference
    // when we introduce multi-tracking, we may need to move this to a factory method
    if (window.AudioContext) {
        var audioContext = new window.AudioContext();
    }
    /**
     * An audio implementation for HTML5 audio.
     */
    var AudioTag = (function () {
        function AudioTag() {
            this.responseType = 'blob';
        }
        /**
         * Transforms raw Blob data into a object URL for use in audio tag
         */
        AudioTag.prototype.processData = function (data) {
            var url = URL.createObjectURL(data);
            return Promises_5.Promise.resolve(url);
        };
        /**
         * Creates a new instance of an audio tag referencing the provided audio URL
         */
        AudioTag.prototype.createInstance = function (url) {
            return new AudioTagInstance(url);
        };
        return AudioTag;
    }());
    exports.AudioTag = AudioTag;
    /**
     * An audio implementation for Web Audio API.
     */
    var WebAudio = (function () {
        function WebAudio() {
            this._logger = Log_5.Logger.getInstance();
            this.responseType = 'arraybuffer';
        }
        /**
         * Processes raw arraybuffer data and decodes into WebAudio buffer (async).
         */
        WebAudio.prototype.processData = function (data) {
            var _this = this;
            var complete = new Promises_5.Promise();
            audioContext.decodeAudioData(data, function (buffer) {
                complete.resolve(buffer);
            }, function () {
                _this._logger.error('Unable to decode ' +
                    ' this browser may not fully support this format, or the file may be corrupt, ' +
                    'if this is an mp3 try removing id3 tags and album art from the file.');
                complete.resolve(undefined);
            });
            return complete;
        };
        /**
         * Creates a new WebAudio AudioBufferSourceNode to play a sound instance
         */
        WebAudio.prototype.createInstance = function (buffer) {
            return new WebAudioInstance(buffer);
        };
        /**
         * Play an empty sound to unlock Safari WebAudio context. Call this function
         * right after a user interaction event. Typically used by [[PauseAfterLoader]]
         * @source https://paulbakaus.com/tutorials/html5/web-audio-on-ios/
         */
        WebAudio.unlock = function () {
            if (WebAudio._unlocked || !audioContext) {
                return;
            }
            // create empty buffer and play it
            var buffer = audioContext.createBuffer(1, 1, 22050);
            var source = audioContext.createBufferSource();
            var ended = false;
            source.buffer = buffer;
            source.connect(audioContext.destination);
            source.onended = function () { return ended = true; };
            if (source.noteOn) {
                // deprecated
                source.noteOn(0);
            }
            else {
                source.start(0);
            }
            // by checking the play state after some time, we know if we're really unlocked
            setTimeout(function () {
                if (source.playbackState) {
                    var legacySource = source;
                    if (legacySource.playbackState === legacySource.PLAYING_STATE ||
                        legacySource.playbackState === legacySource.FINISHED_STATE) {
                        WebAudio._unlocked = true;
                    }
                }
                else {
                    if (audioContext.currentTime > 0 || ended) {
                        WebAudio._unlocked = true;
                    }
                }
            }, 0);
        };
        WebAudio.isUnlocked = function () {
            return this._unlocked;
        };
        return WebAudio;
    }());
    WebAudio._unlocked = false;
    exports.WebAudio = WebAudio;
    /**
     * Factory method that gets the audio implementation to use
     */
    function getAudioImplementation() {
        if (window.AudioContext) {
            return new WebAudio();
        }
        else {
            return new AudioTag();
        }
    }
    exports.getAudioImplementation = getAudioImplementation;
    ;
    /**
     * The [[Sound]] object allows games built in Excalibur to load audio
     * components, from soundtracks to sound effects. [[Sound]] is an [[ILoadable]]
     * which means it can be passed to a [[Loader]] to pre-load before a game or level.
     *
     * [[include:Sounds.md]]
     */
    var Sound = (function () {
        /**
         * @param paths A list of audio sources (clip.wav, clip.mp3, clip.ogg) for this audio clip. This is done for browser compatibility.
         */
        function Sound() {
            var paths = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                paths[_i] = arguments[_i];
            }
            this._logger = Log_5.Logger.getInstance();
            this._data = null;
            this._tracks = [];
            this._isLoaded = false;
            this._isPaused = false;
            this._loop = false;
            this._volume = 1.0;
            this.onprogress = function () { return; };
            this.oncomplete = function () { return; };
            this.onerror = function () { return; };
            this._wasPlayingOnHidden = false;
            /* Chrome : MP3, WAV, Ogg
               * Firefox : WAV, Ogg,
               * IE : MP3, WAV coming soon
               * Safari MP3, WAV, Ogg
               */
            this.path = '';
            for (var _a = 0, paths_1 = paths; _a < paths_1.length; _a++) {
                var path = paths_1[_a];
                if (Sound.canPlayFile(path)) {
                    this.path = path;
                    break;
                }
            }
            if (!this.path) {
                this._logger.warn('This browser does not support any of the audio files specified:', paths.join(', '));
                this._logger.warn('Attempting to use', paths[0]);
                this.path = paths[0]; // select the first specified
            }
            this.sound = getAudioImplementation();
        }
        /**
         * Whether or not the browser can play this file as HTML5 Audio
         */
        Sound.canPlayFile = function (file) {
            try {
                var a = new Audio();
                var filetype = /.*\.([A-Za-z0-9]+)$/;
                var type = file.match(filetype)[1];
                if (a.canPlayType('audio/' + type)) {
                    return true;
                }
                else {
                    return false;
                }
            }
            catch (e) {
                Log_5.Logger.getInstance().warn('Cannot determine audio support, assuming no support for the Audio Tag', e);
                return false;
            }
        };
        Sound.prototype.wireEngine = function (engine) {
            var _this = this;
            if (engine) {
                this._engine = engine;
                this._engine.on('hidden', function () {
                    if (engine.pauseAudioWhenHidden && _this.isPlaying()) {
                        _this._wasPlayingOnHidden = true;
                        _this.pause();
                    }
                });
                this._engine.on('visible', function () {
                    if (engine.pauseAudioWhenHidden && _this._wasPlayingOnHidden) {
                        _this.play();
                        _this._wasPlayingOnHidden = false;
                    }
                });
            }
        };
        /**
         * Returns how many instances of the sound are currently playing
         */
        Sound.prototype.instanceCount = function () {
            return this._tracks.length;
        };
        /**
         * Sets the volume of the sound clip
         * @param volume  A volume value between 0-1.0
         */
        Sound.prototype.setVolume = function (volume) {
            this._volume = volume;
            for (var _i = 0, _a = this._tracks; _i < _a.length; _i++) {
                var track = _a[_i];
                track.setVolume(volume);
            }
            this._logger.debug('Set volume for all instances of sound', this.path, 'to', volume);
        };
        /**
         * Indicates whether the clip should loop when complete
         * @param loop  Set the looping flag
         */
        Sound.prototype.setLoop = function (loop) {
            this._loop = loop;
            for (var _i = 0, _a = this._tracks; _i < _a.length; _i++) {
                var track = _a[_i];
                track.setLoop(loop);
            }
            this._logger.debug('Set loop for all instances of sound', this.path, 'to', loop);
        };
        /**
         * Whether or not the sound is playing right now
         */
        Sound.prototype.isPlaying = function () {
            return this._tracks.some(function (t) { return t.isPlaying(); });
        };
        /**
         * Play the sound, returns a promise that resolves when the sound is done playing
         * An optional volume argument can be passed in to play the sound. Max volume is 1.0
         */
        Sound.prototype.play = function (volume) {
            var _this = this;
            if (this._isLoaded) {
                var resumed = [];
                // ensure we resume *current* tracks (if paused)
                for (var _i = 0, _a = this._tracks; _i < _a.length; _i++) {
                    var track = _a[_i];
                    resumed.push(track.play());
                }
                // when paused, don't start playing new track
                if (this._isPaused) {
                    this._isPaused = false;
                    this._logger.debug('Resuming paused instances for sound', this.path, this._tracks);
                    // resolve when resumed tracks are done
                    return Promises_5.Promise.join(resumed);
                }
                // push a new track
                var newTrack = this.sound.createInstance(this._data);
                newTrack.setLoop(this._loop);
                if (volume) {
                    newTrack.setVolume(Util.clamp(volume, 0.0, 1.0));
                }
                else {
                    newTrack.setVolume(this._volume);
                }
                this._tracks.push(newTrack);
                this._logger.debug('Playing new instance for sound', this.path);
                return newTrack.play().then(function () {
                    // when done, remove track
                    _this._tracks.splice(_this._tracks.indexOf(newTrack), 1);
                    return true;
                });
            }
            else {
                return Promises_5.Promise.resolve(true);
            }
        };
        /**
         * Stop the sound, and do not rewind
         */
        Sound.prototype.pause = function () {
            for (var _i = 0, _a = this._tracks; _i < _a.length; _i++) {
                var track = _a[_i];
                track.pause();
            }
            this._isPaused = true;
            this._logger.debug('Paused all instances of sound', this.path);
        };
        /**
         * Stop the sound and rewind
         */
        Sound.prototype.stop = function () {
            this._isPaused = false;
            var tracks = this._tracks.concat([]);
            for (var _i = 0, tracks_1 = tracks; _i < tracks_1.length; _i++) {
                var track = tracks_1[_i];
                track.stop();
            }
            this._logger.debug('Stopped all instances of sound', this.path);
        };
        /**
         * Returns true if the sound is loaded
         */
        Sound.prototype.isLoaded = function () {
            return this._isLoaded;
        };
        /**
         * Begins loading the sound and returns a promise to be resolved on completion
         */
        Sound.prototype.load = function () {
            var _this = this;
            var complete = new Promises_5.Promise();
            if (!!this.getData()) {
                this._logger.debug('Already have data for audio resource', this.path);
                complete.resolve(this.sound);
                this.oncomplete();
                return complete;
            }
            this._logger.debug('Started loading sound', this.path);
            try {
                this._fetchResource(function (request) {
                    if (request.status !== 200) {
                        _this._logger.error('Failed to load audio resource ', _this.path, ' server responded with error code', request.status);
                        _this.onerror(request.response);
                        complete.resolve(null);
                        return;
                    }
                    // load sound
                    _this.setData(request.response).then(function () {
                        _this.oncomplete();
                        _this._logger.debug('Completed loading sound', _this.path);
                        complete.resolve(_this.sound);
                    }, function (e) { return complete.resolve(e); });
                });
            }
            catch (e) {
                this._logger.error('Error loading sound! If this is a cross origin error, \
            you must host your sound with your html and javascript.');
                this.onerror(e);
                complete.resolve(e);
            }
            return complete;
        };
        /* istanbul ignore next */
        Sound.prototype._fetchResource = function (onload) {
            var request = new XMLHttpRequest();
            request.open('GET', this.path, true);
            request.responseType = this.sound.responseType;
            request.onprogress = this.onprogress;
            request.onerror = this.onerror;
            request.onload = function () { return onload(request); };
            request.send();
        };
        /**
         * Gets the raw sound data (e.g. blob URL or AudioBuffer)
         */
        Sound.prototype.getData = function () {
            return this._data;
        };
        /**
         * Sets raw sound data and returns a Promise that is resolved when sound data is processed
         *
         * @param data The XHR data for the sound implementation to process (Blob or ArrayBuffer)
         */
        Sound.prototype.setData = function (data) {
            var _this = this;
            return this.sound.processData(data).then(function (data) {
                _this._isLoaded = true;
                _this._data = _this.processData(data);
                return data;
            });
        };
        /**
         * Set the raw sound data (e.g. blob URL or AudioBuffer)
         */
        Sound.prototype.processData = function (data) {
            return data;
        };
        return Sound;
    }());
    exports.Sound = Sound;
    /**
     * Internal class representing a HTML5 audio instance
     */
    /* istanbul ignore next */
    var AudioTagInstance = (function () {
        function AudioTagInstance(src) {
            this._isPlaying = false;
            this._isPaused = false;
            this._loop = false;
            this._audioElement = new Audio(src);
        }
        AudioTagInstance.prototype.isPlaying = function () {
            return this._isPlaying;
        };
        Object.defineProperty(AudioTagInstance.prototype, "loop", {
            get: function () {
                return this._loop;
            },
            enumerable: true,
            configurable: true
        });
        AudioTagInstance.prototype.setLoop = function (value) {
            this._loop = value;
            this._audioElement.loop = value;
            this._wireUpOnEnded();
        };
        AudioTagInstance.prototype.setVolume = function (value) {
            this._audioElement.volume = Util.clamp(value, 0, 1.0);
        };
        AudioTagInstance.prototype.play = function () {
            if (this._isPaused) {
                this._resume();
            }
            else if (!this._isPlaying) {
                this._start();
            }
            return this._playingPromise;
        };
        AudioTagInstance.prototype._start = function () {
            this._audioElement.load();
            this._audioElement.loop = this._loop;
            this._audioElement.play();
            this._isPlaying = true;
            this._isPaused = false;
            this._playingPromise = new Promises_5.Promise();
            this._wireUpOnEnded();
        };
        AudioTagInstance.prototype._resume = function () {
            if (!this._isPaused) {
                return;
            }
            this._audioElement.play();
            this._isPaused = false;
            this._isPlaying = true;
            this._wireUpOnEnded();
        };
        AudioTagInstance.prototype.pause = function () {
            if (!this._isPlaying) {
                return;
            }
            this._audioElement.pause();
            this._isPaused = true;
            this._isPlaying = false;
        };
        AudioTagInstance.prototype.stop = function () {
            if (!this._isPlaying) {
                return;
            }
            this._audioElement.pause();
            this._audioElement.currentTime = 0;
            this._handleOnEnded();
        };
        AudioTagInstance.prototype._wireUpOnEnded = function () {
            var _this = this;
            if (!this._loop) {
                this._audioElement.onended = function () { return _this._handleOnEnded(); };
            }
        };
        AudioTagInstance.prototype._handleOnEnded = function () {
            this._isPlaying = false;
            this._isPaused = false;
            this._playingPromise.resolve(true);
        };
        return AudioTagInstance;
    }());
    /**
     * Internal class representing a Web Audio AudioBufferSourceNode instance
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API
     */
    /* istanbul ignore next */
    var WebAudioInstance = (function () {
        function WebAudioInstance(_buffer) {
            this._buffer = _buffer;
            this._volumeNode = audioContext.createGain();
            this._isPlaying = false;
            this._isPaused = false;
            this._loop = false;
            /**
             * Current playback offset (in seconds)
             */
            this._currentOffset = 0;
        }
        WebAudioInstance.prototype.isPlaying = function () {
            return this._isPlaying;
        };
        WebAudioInstance.prototype.setVolume = function (value) {
            if (this._volumeNode.gain.setTargetAtTime) {
                this._volumeNode.gain.setTargetAtTime(Util.clamp(value, 0, 1.0), audioContext.currentTime, 0);
            }
            else {
                this._volumeNode.gain.value = Util.clamp(value, 0, 1.0);
            }
        };
        WebAudioInstance.prototype.setLoop = function (value) {
            this._loop = value;
            if (this._bufferSource) {
                this._bufferSource.loop = value;
                this._wireUpOnEnded();
            }
        };
        WebAudioInstance.prototype.play = function () {
            if (this._isPaused) {
                this._resume();
            }
            else if (!this._isPlaying) {
                this._start();
            }
            return this._playingPromise;
        };
        WebAudioInstance.prototype._start = function () {
            this._volumeNode.connect(audioContext.destination);
            this._createBufferSource();
            this._bufferSource.start(0, 0);
            this._startTime = new Date().getTime();
            this._currentOffset = 0;
            this._isPlaying = true;
            this._isPaused = false;
            this._playingPromise = new Promises_5.Promise();
            this._wireUpOnEnded();
        };
        WebAudioInstance.prototype._resume = function () {
            if (!this._isPaused) {
                return;
            }
            // a buffer source can only be started once
            // so we need to dispose of the previous instance before
            // "resuming" the next one
            this._bufferSource.onended = null; // dispose of any previous event handler
            this._createBufferSource();
            var duration = (1 / this._bufferSource.playbackRate.value) * this._buffer.duration;
            this._bufferSource.start(0, this._currentOffset % duration);
            this._isPaused = false;
            this._isPlaying = true;
            this._wireUpOnEnded();
        };
        WebAudioInstance.prototype._createBufferSource = function () {
            this._bufferSource = audioContext.createBufferSource();
            this._bufferSource.buffer = this._buffer;
            this._bufferSource.loop = this._loop;
            this._bufferSource.playbackRate.value = 1.0;
            this._bufferSource.connect(this._volumeNode);
        };
        WebAudioInstance.prototype.pause = function () {
            if (!this._isPlaying) {
                return;
            }
            this._bufferSource.stop(0);
            // Playback rate will be a scale factor of how fast/slow the audio is being played
            // default is 1.0
            // we need to invert it to get the time scale
            var pbRate = 1 / (this._bufferSource.playbackRate.value || 1.0);
            this._currentOffset = ((new Date().getTime() - this._startTime) * pbRate) / 1000; // in seconds
            this._isPaused = true;
            this._isPlaying = false;
        };
        WebAudioInstance.prototype.stop = function () {
            if (!this._isPlaying) {
                return;
            }
            this._bufferSource.stop(0);
            // handler will not be wired up if we were looping
            if (!this._bufferSource.onended) {
                this._handleOnEnded();
            }
            this._currentOffset = 0;
            this._isPlaying = false;
            this._isPaused = false;
        };
        WebAudioInstance.prototype._wireUpOnEnded = function () {
            var _this = this;
            if (!this._loop) {
                this._bufferSource.onended = function () { return _this._handleOnEnded(); };
            }
        };
        WebAudioInstance.prototype._handleOnEnded = function () {
            // pausing calls stop(0) which triggers onended event
            // so we don't "resolve" yet (when we resume we'll try again)
            if (!this._isPaused) {
                this._isPlaying = false;
                this._playingPromise.resolve(true);
            }
        };
        return WebAudioInstance;
    }());
});
define("Interfaces/ILoader", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Loader", ["require", "exports", "Drawing/Color", "Resources/Sound", "Util/Log", "Promises", "Class", "Util/DrawUtil"], function (require, exports, Color_12, Sound_1, Log_6, Promises_6, Class_3, DrawUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Pre-loading assets
     *
     * The loader provides a mechanism to preload multiple resources at
     * one time. The loader must be passed to the engine in order to
     * trigger the loading progress bar.
     *
     * The [[Loader]] itself implements [[ILoadable]] so you can load loaders.
     *
     * ## Example: Pre-loading resources for a game
     *
     * ```js
     * // create a loader
     * var loader = new ex.Loader();
     *
     * // create a resource dictionary (best practice is to keep a separate file)
     * var resources = {
     *   TextureGround: new ex.Texture("/images/textures/ground.png"),
     *   SoundDeath: new ex.Sound("/sound/death.wav", "/sound/death.mp3")
     * };
     *
     * // loop through dictionary and add to loader
     * for (var loadable in resources) {
     *   if (resources.hasOwnProperty(loadable)) {
     *     loader.addResource(resources[loadable]);
     *   }
     * }
     *
     * // start game
     * game.start(loader).then(function () {
     *   console.log("Game started!");
     * });
     * ```
     */
    var Loader = (function (_super) {
        __extends(Loader, _super);
        /**
         * @param loadables  Optionally provide the list of resources you want to load at constructor time
         */
        function Loader(loadables) {
            var _this = _super.call(this) || this;
            _this._resourceList = [];
            _this._index = 0;
            _this._resourceCount = 0;
            _this._numLoaded = 0;
            _this._progressCounts = {};
            _this._totalCounts = {};
            // logo drawing stuff
            /* tslint:disable:max-line-length */
            // base64 string encoding of the excalibur logo (logo-white.png)
            _this.logo = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAdQAAAB2CAYAAABxhGI9AAAACXBIWXMAAAsSAAALEgHS3X78AAAKnUlEQVR42u3dP2wjSx0H8N8hJIonIRmJjsq0SBR+BQ1dcqKhe0lD77SvSwpKkJKGPulpktfRIMUdEqKIqV57rpAokM4dbSiyq7ONPTP7x39ifz7SFbnEnp3xer47O7uzH15fXwMA6OYHmgAABCoACFQAEKgAgEAFAIEKAAIVAAQqACBQAUCgAoBABQCBCgAIVAAQqAAgUAFAoAIAAhUABCoACFQAEKgAgECFLbmOiNeFf2PbAyz68Pr6qhUgbRwR92v+/zwiJrYHMEKFMmcN///UtgcQqFBk1PD/97U9Qx8VCFSgu4EmAIEKAAIVAAQqACBQ4Z25jojP8eX+0WtNAgIVaOY+Im5j+eKh24h41jQgUIEyZ7F5NaPU7wCBCiwYd/w9cOB+qAlgJ3KLLow0EV198803RWvJfvfddx+0lhEqHKu5JgAjVCBvlhmFzjQRXUekHz9+TP79y8uLRjNChXfvoePvAYEKxNtj1e42/O5JoIJABcrdRMRVLM+X3kTEpaaB988cKuzWg9EobTWdMx0Oly8uN4dqhAoARqgnaN3arHfqu7OyH8ItKLVB/P+CEfMTHyGPY3npx1m8zWGDEeoBfUk/xdti57dr/r1Wv2+6EPow3tZ5rRdS72s1neuF97xvWd+XTH0/V+UMttDWqbI/r2nrxfp+jv2uSjSO7S+OXy/A/3lN+9xX5T5HxEUPZZ0tfB71+w57eJ/HFu+z+jkv1u92YX9fbI/HhX3JA9rp5MPr66tWaG9UfUGbrHIzi7cLUyYFf/tpTady03EEeL8mUJ6i7MKYNvWNqr4Pe2jradXO60LrvPAz2PQ5RPX684ah8dxD+2zantnCgVipSVV+m/tgB9W2DDq2Sx/vM95wcHhZhWVJm8yrv58cSgfTdc70+++/X/r522+/tUKSEepBqo+om4ZLPerMjUwuNnQCtx1GWJtee1FwdD5uWd86xLs8UaVt2aNEO1/saZ/Z5rYMW4zq6v34rGV9Bg3q2eZ9SkeNm9qwyUh30OPIHYFKx5FG03C7znSOqYBq+qW/zpQ3anH037TNHluG6f0WPsPhHvab4QFty7ogOeuxDYcNy2/zu2214WNYWxmBurNO8bGn97pNBOO8xy/9uCorZZ4I2r4C7aJgO7ZV9iE49Dm6NvOWx+pWE9CUq3zbdTp9doz38TbXtzqH9RT5CyWe422OaZoZGeZCabrhPQY9HjwsjpTvCg4YtlE2+Ta/j2bzn8fqrDqgm+6yUHOmAvWUjAtGhbNYvsBknDnqH1Qhc7VmxHgeb/NbudA5j/UXlYwif2p6luhAc9teu1npiHKnDs8if6tCm7JLX3NKpgttXe9ruc9mHMd7a83iwdxF5vt8tutARaCeklRnNK9C8WnNF7geJQ4T4XG3JhSnVdilQrG+yOnrlVHfsEGYzhNBn7Lu6tS7+HJafJQ4EMiNlNqWXZ9WPvVgnVYHG5M1ByDXkT6leX2EgTqJtyt45yv7S2qO3sEZjZhDLXeR+YKdJ0Zdk8QocvH9N732KrNtq+FZ/zzIHABcJrYpd+Xv14lOd5ap76SgrduW/VTQ1qcQpqnbgu4ifZvUMNpd9XuoZmvCtPaQ2Y/BCHVLgbrJTeRPDdVf6pfMKDU2fOkHmVFFfXr3MsouLsnNvV5kRoe5+s431PeuoKPqWnaurY/ZPBEeqwceN4l96iwO6H7Mjq4y7VGPVNe10VaZMzVCPVWpI/Z6FZbcv5fMqGCU+dLfFGzj58jP8+bCdJCo7yzKTwdOF0bu9Ug7V4c+yz7FJfYeGoysUss0HssIdVZwYLDujMqlESoCdTtGsZtbHnJBeNdDSJSs0jTKdMJN1HNX54Wv7bvsU9NkVJVa13dX+/wuArV0X/l5RHyo/lnfF4G6p6DrS0kHdtXhy35TGErDPYZUn2WfWqDOo/lVqdMD2O/hKJhD7S/odukymq9s02QN4EEPR/zbaOumZc+r15zK1Zqznl9jsfiemTM1QmV3HUuTkedlg9HIQzRbUD93dfC+2tpj2fIHEH2+RqCCQH13gZq7hWXTNpVu19OB1fc9nQ0AKOKUb5lU0P1kDyOneoWk0lOZ9cIP0x7qu8+2BhCoR2wYu1+e7DmaXzBSsu5vaX1ne2zrpmUPTmxf7PM1Dm4y/vC7ny7Nif7+z/9ZmtM0Z3panPLtPmra9f16bcK0Dpbnwk43Vd/RHtu6zfNQTy1QBy3aqG2g9nVmxml+BOoJyT3NpWmn9xhfFnu4bvDa+44BXhqqfdf3uUF9+yz77AT31Yue2mjecYQ62NLfgkA9ghHqLNEhNem4H1c6vdyDxhf/bpz5m4coW/c39wi6VH2bPtHlcaV9cvXts+zxCe6rTeqc2ndL7uGd93QwM9bFcAzMoZZ7SgTBbWx+asui61h/iq1+RmjqdbnQXQ3T1DNQ63V/U9ucqm/pMzPb1rePsk/1iTOjgvatR4W3Lc8ULB78pELyrnAfeTcj1NU509/86mfJ33/8+Mf00a05UyPUEw7UVCeWG/WNEiExyHRMt5ltW30izUPk18ytt7lNfc8i//DvtvXto+ySA5BjljsLUF8lPkqMPEtW1JomDsiGBZ9Byb4NAvUITSN9GuwsIj6t6UTOqk7jJREkmzqli8xIs96udSO20sX0H1vW92IL9e1a9rgqVyf91gbPsTy9UD9n9lOkT8k+RfkFR5PMNqxOcdSf32PBvg3vilO+zdxE+okx9Wm0ph36XYsRZCpMF993GOk5qvqB3Dct6jvssb67KvuUNJ3frw92bhr8/STSF0JdRPMLpUCgnsgo9S76PZ246ZFk1wWvK5m3vVoYvW1Sz7nN91jfXbQ1ZQc7TW6HeaoOalypG/8/p/rP1aNAc6ZHzSnfdqPUPhdy2PQw6Nz9gSVhuhiqueUHR3uu7y7K3rdDX4u46ZrPbUa0IFBZ0seKQ3XQTRt2vm3W/a2DbNKys++rvm3ep6+y1x2UdP3bWU9lzra47U1GmlctX/sQ23t+aOlByLTh/4NAPaCRxtcdO5HLSJ/6vNtCwGx67VPmPbvWd1q9frKHtp4kAqRJ2HR9j762JfX3bZ//elPtj13PPDx1+D5tqk/Xi6NO8SHz7MmH19dXrdBNfVFP6T2PT1UHNit87/t4m5+aRH+nQBdvqyhZDKJLfZs8h7XPsqdV2ZOV+tanKB8aln0dyxdAXbV4j4gvt4oMOrbP6vbU73NW7TMlbdTnPrWpfqXfh9HKZ9vke7KuTeZRNtXRSe6+1FV//ce/ln5eXfsXgcqXzr6+9261M3moOoa7E6nvTZTfy7iNsmfb7kjfgXGsvxe0vihsEts9HTquPpt1q1vtahu2TqAiUAEEKj0zhwoARqgAu/OnX/442WH+9xc/Wvr58re/Tr7f41/+ZsRqhAoACFQAEKgAcHjMoQJskJsz/eqrr5Z+vvr7v5fmQFevAl5lztQIFQAQqAAgUAHgIJlDBdhgdQ41N2eKESoAIFABQKACwFEwhwoARqgAIFABQKACAAIVAAQqAAhUABCoAIBABQCBCgACFQAEKgAgUAFAoAKAQAUAgQoACFQAEKgAIFABQKACAAIVAAQqAAhUABCoAIBABQCBCgACFQAQqAAgUAFAoAKAQAUAlvwPcFDns1DsH4sAAAAASUVORK5CYII=';
            /* tslint:enable:max-line-length */
            _this.logoWidth = 468;
            _this.logoHeight = 118;
            _this.backgroundColor = '#176BAA';
            _this.getData = function () { return; };
            _this.setData = function () { return; };
            _this.processData = function () { return; };
            _this.onprogress = function (e) {
                Log_6.Logger.getInstance().debug('[ex.Loader] Loading ' + (100 * e.loaded / e.total).toFixed(0));
                return;
            };
            _this.oncomplete = function () { return; };
            _this.onerror = function () { return; };
            if (loadables) {
                _this.addResources(loadables);
            }
            return _this;
        }
        Object.defineProperty(Loader.prototype, "_image", {
            get: function () {
                if (!this._imageElement) {
                    this._imageElement = new Image();
                    this._imageElement.src = this.logo;
                }
                return this._imageElement;
            },
            enumerable: true,
            configurable: true
        });
        ;
        Loader.prototype.wireEngine = function (engine) {
            this._engine = engine;
        };
        /**
         * Add a resource to the loader to load
         * @param loadable  Resource to add
         */
        Loader.prototype.addResource = function (loadable) {
            var key = this._index++;
            this._resourceList.push(loadable);
            this._progressCounts[key] = 0;
            this._totalCounts[key] = 1;
            this._resourceCount++;
        };
        /**
         * Add a list of resources to the loader to load
         * @param loadables  The list of resources to load
         */
        Loader.prototype.addResources = function (loadables) {
            var i = 0, len = loadables.length;
            for (i; i < len; i++) {
                this.addResource(loadables[i]);
            }
        };
        /**
         * Returns true if the loader has completely loaded all resources
         */
        Loader.prototype.isLoaded = function () {
            return this._numLoaded === this._resourceCount;
        };
        /**
         * Begin loading all of the supplied resources, returning a promise
         * that resolves when loading of all is complete
         */
        Loader.prototype.load = function () {
            var _this = this;
            var complete = new Promises_6.Promise();
            var me = this;
            if (this._resourceList.length === 0) {
                me.oncomplete.call(me);
                return complete.resolve();
            }
            var progressArray = new Array(this._resourceList.length);
            var progressChunks = this._resourceList.length;
            this._resourceList.forEach(function (r, i) {
                if (_this._engine) {
                    r.wireEngine(_this._engine);
                }
                r.onprogress = function (e) {
                    var total = e.total;
                    var loaded = e.loaded;
                    progressArray[i] = { loaded: ((loaded / total) * (100 / progressChunks)), total: 100 };
                    var progressResult = progressArray.reduce(function (accum, next) {
                        return { loaded: (accum.loaded + next.loaded), total: 100 };
                    }, { loaded: 0, total: 100 });
                    me.onprogress.call(me, progressResult);
                };
                r.oncomplete = r.onerror = function () {
                    me._numLoaded++;
                    if (me._numLoaded === me._resourceCount) {
                        me.oncomplete.call(me);
                        complete.resolve();
                    }
                };
            });
            function loadNext(list, index) {
                if (!list[index]) {
                    return;
                }
                list[index].load().then(function () {
                    loadNext(list, index + 1);
                });
            }
            loadNext(this._resourceList, 0);
            return complete;
        };
        /**
         * Loader draw function. Draws the default Excalibur loading screen.
         * Override `logo`, `logoWidth`, `logoHeight` and `backgroundColor` properties
         * to customize the drawing, or just override entire method.
         */
        Loader.prototype.draw = function (ctx) {
            var canvasHeight = this._engine.canvasHeight / window.devicePixelRatio;
            var canvasWidth = this._engine.canvasWidth / window.devicePixelRatio;
            ctx.fillStyle = this.backgroundColor;
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            var y = canvasHeight / 2;
            var width = Math.min(this.logoWidth, canvasWidth * 0.75);
            var x = (canvasWidth / 2) - (width / 2);
            var imageHeight = Math.floor(width * (this.logoHeight / this.logoWidth)); // OG height/width factor
            var oldAntialias = this._engine.getAntialiasing();
            this._engine.setAntialiasing(true);
            ctx.drawImage(this._image, 0, 0, this.logoWidth, this.logoHeight, x, y - imageHeight - 20, width, imageHeight);
            // loading box
            ctx.lineWidth = 2;
            DrawUtil.roundRect(ctx, x, y, width, 20, 10);
            var progress = width * (this._numLoaded / this._resourceCount);
            var margin = 5;
            var progressWidth = progress - margin * 2;
            var height = 20 - margin * 2;
            DrawUtil.roundRect(ctx, x + margin, y + margin, progressWidth > 0 ? progressWidth : 0, height, 5, null, Color_12.Color.White);
            this._engine.setAntialiasing(oldAntialias);
        };
        /**
         * Perform any calculations or logic in the `update` method. The default `Loader` does not
         * do anything in this method so it is safe to override.
         */
        Loader.prototype.update = function (_engine, _delta) {
            // overridable update
        };
        return Loader;
    }(Class_3.Class));
    exports.Loader = Loader;
    /**
     * A [[Loader]] that pauses after loading to allow user
     * to proceed to play the game. Typically you will
     * want to use this loader for iOS to allow sounds
     * to play after loading (Apple Safari requires user
     * interaction to allow sounds, even for games)
     *
     * **Note:** Because Loader is not part of a Scene, you must
     * call `update` and `draw` manually on "child" objects.
     *
     * ## Implementing a Trigger
     *
     * The `PauseAfterLoader` requires an element to act as the trigger button
     * to start the game.
     *
     * For example, let's create an `<a>` tag to be our trigger and call it `tap-to-play`.
     *
     * ```html
     * <div id="wrapper">
     *    <canvas id="game"></canvas>
     *    <a id="tap-to-play" href='javascript:void(0);'>Tap to Play</a>
     * </div>
     * ```
     *
     * We've put it inside a wrapper to position it properly over the game canvas.
     *
     * Now let's add some CSS to style it (insert into `<head>`):
     *
     * ```html
     * <style>
     *     #wrapper {
     *         position: relative;
     *         width: 500px;
     *         height: 500px;
     *     }
     *     #tap-to-play {
     *         display: none;
     *         font-size: 24px;
     *         font-family: sans-serif;
     *         text-align: center;
     *         border: 3px solid white;
     *         position: absolute;
     *         color: white;
     *         width: 200px;
     *         height: 50px;
     *         line-height: 50px;
     *         text-decoration: none;
     *         left: 147px;
     *         top: 80%;
     *     }
     * </style>
     * ```
     *
     * Now we can create a `PauseAfterLoader` with a reference to our trigger button:
     *
     * ```ts
     * var loader = new ex.PauseAfterLoader('tap-to-play', [...]);
     * ```
     *
     * ## Use PauseAfterLoader for iOS
     *
     * The primary use case for pausing before starting the game is to
     * pass Apple's requirement of user interaction. The Web Audio context
     * in Safari is disabled by default until user interaction.
     *
     * Therefore, you can use this snippet to only use PauseAfterLoader when
     * iOS is detected (see [this thread](http://stackoverflow.com/questions/9038625/detect-if-device-is-ios)
     * for more techniques).
     *
     * ```ts
     * var iOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !(<any>window).MSStream;
     * var loader: ex.Loader = iOS ? new ex.PauseAfterLoader('tap-to-play') : new ex.Loader();
     *
     * loader.addResource(...);
     * ```
     */
    var PauseAfterLoader = (function (_super) {
        __extends(PauseAfterLoader, _super);
        function PauseAfterLoader(triggerElementId, loadables) {
            var _this = _super.call(this, loadables) || this;
            _this._handleOnTrigger = function () {
                if (_this._waitPromise.state() !== Promises_6.PromiseState.Pending) {
                    return false;
                }
                // unlock Safari WebAudio context
                Sound_1.WebAudio.unlock();
                // continue to play game
                _this._waitPromise.resolve(_this._loadedValue);
                // hide DOM element
                _this._playTrigger.style.display = 'none';
                return false;
            };
            _this._playTrigger = document.getElementById(triggerElementId);
            _this._playTrigger.addEventListener('click', _this._handleOnTrigger);
            return _this;
        }
        PauseAfterLoader.prototype.load = function () {
            var _this = this;
            this._waitPromise = new Promises_6.Promise();
            // wait until user indicates to proceed before finishing load
            _super.prototype.load.call(this).then(function (value) {
                _this._loadedValue = value;
                // show element
                _this._playTrigger.style.display = 'block';
            }, function (value) {
                _this._waitPromise.reject(value);
            });
            return this._waitPromise;
        };
        return PauseAfterLoader;
    }(Loader));
    exports.PauseAfterLoader = PauseAfterLoader;
});
define("Interfaces/IActorTrait", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Traits/CapturePointer", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Propogates pointer events to the actor
     */
    var CapturePointer = (function () {
        function CapturePointer() {
        }
        CapturePointer.prototype.update = function (actor, engine) {
            if (!actor.enableCapturePointer) {
                return;
            }
            if (actor.isKilled()) {
                return;
            }
            engine.input.pointers.propogate(actor);
        };
        return CapturePointer;
    }());
    exports.CapturePointer = CapturePointer;
});
define("Traits/EulerMovement", ["require", "exports", "Physics", "Actor"], function (require, exports, Physics_7, Actor_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var EulerMovement = (function () {
        function EulerMovement() {
        }
        EulerMovement.prototype.update = function (actor, _engine, delta) {
            // Update placements based on linear algebra
            var seconds = delta / 1000;
            var totalAcc = actor.acc.clone();
            // Only active vanilla actors are affected by global acceleration
            if (actor.collisionType === Actor_5.CollisionType.Active) {
                totalAcc.addEqual(Physics_7.Physics.acc);
            }
            actor.oldVel = actor.vel;
            actor.vel.addEqual(totalAcc.scale(seconds));
            actor.pos.addEqual(actor.vel.scale(seconds)).addEqual(totalAcc.scale(0.5 * seconds * seconds));
            actor.rx += actor.torque * (1.0 / actor.moi) * seconds;
            actor.rotation += actor.rx * seconds;
            actor.scale.x += actor.sx * delta / 1000;
            actor.scale.y += actor.sy * delta / 1000;
        };
        return EulerMovement;
    }());
    exports.EulerMovement = EulerMovement;
});
define("Util/CullingBox", ["require", "exports", "Algebra", "Drawing/Color"], function (require, exports, Algebra_13, Color_13) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CullingBox = (function () {
        function CullingBox() {
            this._topLeft = new Algebra_13.Vector(0, 0);
            this._topRight = new Algebra_13.Vector(0, 0);
            this._bottomLeft = new Algebra_13.Vector(0, 0);
            this._bottomRight = new Algebra_13.Vector(0, 0);
        }
        CullingBox.prototype.isSpriteOffScreen = function (actor, engine) {
            var drawingWidth = actor.currentDrawing.width;
            var drawingHeight = actor.currentDrawing.height;
            var rotation = actor.rotation;
            var anchor = actor.getCenter();
            var worldPos = actor.getWorldPos();
            this._topLeft.x = worldPos.x - (drawingWidth / 2);
            this._topLeft.y = worldPos.y - (drawingHeight / 2);
            this._topLeft = this._topLeft.rotate(rotation, anchor);
            this._topRight.x = worldPos.x + (drawingWidth / 2);
            this._topRight.y = worldPos.y - (drawingHeight / 2);
            this._topRight = this._topRight.rotate(rotation, anchor);
            this._bottomLeft.x = worldPos.x - (drawingWidth / 2);
            this._bottomLeft.y = worldPos.y + (drawingHeight / 2);
            this._bottomLeft = this._bottomLeft.rotate(rotation, anchor);
            this._bottomRight.x = worldPos.x + (drawingWidth / 2);
            this._bottomRight.y = worldPos.y + (drawingHeight / 2);
            this._bottomRight = this._bottomRight.rotate(rotation, anchor);
            ///
            var topLeftScreen = engine.worldToScreenCoordinates(this._topLeft);
            var topRightScreen = engine.worldToScreenCoordinates(this._topRight);
            var bottomLeftScreen = engine.worldToScreenCoordinates(this._bottomLeft);
            var bottomRightScreen = engine.worldToScreenCoordinates(this._bottomRight);
            this._xCoords = [];
            this._yCoords = [];
            this._xCoords.push(topLeftScreen.x, topRightScreen.x, bottomLeftScreen.x, bottomRightScreen.x);
            this._yCoords.push(topLeftScreen.y, topRightScreen.y, bottomLeftScreen.y, bottomRightScreen.y);
            this._xMin = Math.min.apply(null, this._xCoords);
            this._yMin = Math.min.apply(null, this._yCoords);
            this._xMax = Math.max.apply(null, this._xCoords);
            this._yMax = Math.max.apply(null, this._yCoords);
            var minWorld = engine.screenToWorldCoordinates(new Algebra_13.Vector(this._xMin, this._yMin));
            var maxWorld = engine.screenToWorldCoordinates(new Algebra_13.Vector(this._xMax, this._yMax));
            this._xMinWorld = minWorld.x;
            this._yMinWorld = minWorld.y;
            this._xMaxWorld = maxWorld.x;
            this._yMaxWorld = maxWorld.y;
            var boundingPoints = [
                new Algebra_13.Vector(this._xMin, this._yMin),
                new Algebra_13.Vector(this._xMax, this._yMin),
                new Algebra_13.Vector(this._xMin, this._yMax),
                new Algebra_13.Vector(this._xMax, this._yMax)
            ]; // bottomright
            // sprite can be wider than canvas screen (and still visible within canvas)
            // top or bottom of sprite must be within canvas
            if (boundingPoints[0].x < 0 && boundingPoints[1].x > engine.canvas.clientWidth &&
                (boundingPoints[0].y > 0 || boundingPoints[2].y < engine.canvas.clientHeight)) {
                return false;
            }
            // sprite can be taller than canvas screen (and still visible within canvas)
            // left or right of sprite must be within canvas
            if (boundingPoints[0].y < 0 && boundingPoints[2].y > engine.canvas.clientHeight &&
                (boundingPoints[1].x > 0 || boundingPoints[0].x < engine.canvas.clientWidth)) {
                return false;
            }
            // otherwise if any corner is visible, we're not offscreen
            for (var i = 0; i < boundingPoints.length; i++) {
                if (boundingPoints[i].x > 0 &&
                    boundingPoints[i].y > 0 &&
                    boundingPoints[i].x < engine.canvas.clientWidth &&
                    boundingPoints[i].y < engine.canvas.clientHeight) {
                    return false;
                }
            }
            return true;
        };
        CullingBox.prototype.debugDraw = function (ctx) {
            // bounding rectangle
            ctx.beginPath();
            ctx.strokeStyle = Color_13.Color.White.toString();
            ctx.rect(this._xMinWorld, this._yMinWorld, this._xMaxWorld - this._xMinWorld, this._yMaxWorld - this._yMinWorld);
            ctx.stroke();
            ctx.fillStyle = Color_13.Color.Red.toString();
            ctx.beginPath();
            ctx.arc(this._topLeft.x, this._topLeft.y, 5, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = Color_13.Color.Green.toString();
            ctx.beginPath();
            ctx.arc(this._topRight.x, this._topRight.y, 5, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = Color_13.Color.Blue.toString();
            ctx.beginPath();
            ctx.arc(this._bottomLeft.x, this._bottomLeft.y, 5, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = Color_13.Color.Magenta.toString();
            ctx.beginPath();
            ctx.arc(this._bottomRight.x, this._bottomRight.y, 5, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fill();
        };
        return CullingBox;
    }());
    exports.CullingBox = CullingBox;
});
define("Traits/OffscreenCulling", ["require", "exports", "Util/CullingBox", "Algebra", "Events"], function (require, exports, CullingBox_1, Algebra_14, Events_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var OffscreenCulling = (function () {
        function OffscreenCulling() {
            this.cullingBox = new CullingBox_1.CullingBox();
        }
        OffscreenCulling.prototype.update = function (actor, engine) {
            var eventDispatcher = actor.eventDispatcher;
            var anchor = actor.anchor;
            var globalScale = actor.getGlobalScale();
            var width = globalScale.x * actor.getWidth() / actor.scale.x;
            var height = globalScale.y * actor.getHeight() / actor.scale.y;
            var worldPos = actor.getWorldPos();
            var actorScreenCoords = engine.worldToScreenCoordinates(new Algebra_14.Vector(worldPos.x - anchor.x * width, worldPos.y - anchor.y * height));
            var zoom = 1.0;
            if (actor.scene && actor.scene.camera) {
                zoom = Math.abs(actor.scene.camera.getZoom());
            }
            var isSpriteOffScreen = true;
            if (actor.currentDrawing != null) {
                isSpriteOffScreen = this.cullingBox.isSpriteOffScreen(actor, engine);
            }
            if (!actor.isOffScreen) {
                if ((actorScreenCoords.x + width * zoom < 0 ||
                    actorScreenCoords.y + height * zoom < 0 ||
                    actorScreenCoords.x > engine.canvasWidth ||
                    actorScreenCoords.y > engine.canvasHeight) &&
                    isSpriteOffScreen) {
                    eventDispatcher.emit('exitviewport', new Events_3.ExitViewPortEvent(actor));
                    actor.isOffScreen = true;
                }
            }
            else {
                if ((actorScreenCoords.x + width * zoom > 0 &&
                    actorScreenCoords.y + height * zoom > 0 &&
                    actorScreenCoords.x < engine.canvasWidth &&
                    actorScreenCoords.y < engine.canvasHeight) ||
                    !isSpriteOffScreen) {
                    eventDispatcher.emit('enterviewport', new Events_3.EnterViewPortEvent(actor));
                    actor.isOffScreen = false;
                }
            }
        };
        return OffscreenCulling;
    }());
    exports.OffscreenCulling = OffscreenCulling;
});
define("Traits/TileMapCollisionDetection", ["require", "exports", "Actor", "Collision/Side", "Events"], function (require, exports, Actor_6, Side_2, Events_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TileMapCollisionDetection = (function () {
        function TileMapCollisionDetection() {
        }
        TileMapCollisionDetection.prototype.update = function (actor, engine) {
            var eventDispatcher = actor.eventDispatcher;
            if (actor.collisionType !== Actor_6.CollisionType.PreventCollision && engine.currentScene && engine.currentScene.tileMaps) {
                for (var j = 0; j < engine.currentScene.tileMaps.length; j++) {
                    var map = engine.currentScene.tileMaps[j];
                    var intersectMap;
                    var side = Side_2.Side.None;
                    var max = 2;
                    while (intersectMap = map.collides(actor)) {
                        if (max-- < 0) {
                            break;
                        }
                        side = actor.getSideFromIntersect(intersectMap);
                        eventDispatcher.emit('precollision', new Events_4.PreCollisionEvent(actor, null, side, intersectMap));
                        if (actor.collisionType === Actor_6.CollisionType.Active) {
                            actor.pos.y += intersectMap.y;
                            actor.pos.x += intersectMap.x;
                            eventDispatcher.emit('postcollision', new Events_4.PostCollisionEvent(actor, null, side, intersectMap));
                        }
                    }
                }
            }
        };
        return TileMapCollisionDetection;
    }());
    exports.TileMapCollisionDetection = TileMapCollisionDetection;
});
define("Traits/Index", ["require", "exports", "Traits/CapturePointer", "Traits/EulerMovement", "Traits/OffscreenCulling", "Traits/TileMapCollisionDetection"], function (require, exports, CapturePointer_1, EulerMovement_1, OffscreenCulling_1, TileMapCollisionDetection_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(CapturePointer_1);
    __export(EulerMovement_1);
    __export(OffscreenCulling_1);
    __export(TileMapCollisionDetection_1);
});
define("Particles", ["require", "exports", "Actor", "Drawing/Color", "Algebra", "Util/Util", "Util/DrawUtil", "Traits/Index", "Configurable", "Math/Random"], function (require, exports, Actor_7, Color_14, Algebra_15, Util, DrawUtil, Traits, Configurable_5, Random_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * An enum that represents the types of emitter nozzles
     */
    var EmitterType;
    (function (EmitterType) {
        /**
         * Constant for the circular emitter type
         */
        EmitterType[EmitterType["Circle"] = 0] = "Circle";
        /**
         * Constant for the rectangular emitter type
         */
        EmitterType[EmitterType["Rectangle"] = 1] = "Rectangle";
    })(EmitterType = exports.EmitterType || (exports.EmitterType = {}));
    /**
     * @hidden
     */
    var ParticleImpl = (function () {
        function ParticleImpl(emitterOrConfig, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize) {
            this.position = new Algebra_15.Vector(0, 0);
            this.velocity = new Algebra_15.Vector(0, 0);
            this.acceleration = new Algebra_15.Vector(0, 0);
            this.particleRotationalVelocity = 0;
            this.currentRotation = 0;
            this.focus = null;
            this.focusAccel = 0;
            this.opacity = 1;
            this.beginColor = Color_14.Color.White.clone();
            this.endColor = Color_14.Color.White.clone();
            // Life is counted in ms
            this.life = 300;
            this.fadeFlag = false;
            // Color transitions
            this._rRate = 1;
            this._gRate = 1;
            this._bRate = 1;
            this._aRate = 0;
            this._currentColor = Color_14.Color.White.clone();
            this.emitter = null;
            this.particleSize = 5;
            this.particleSprite = null;
            this.sizeRate = 0;
            this.elapsedMultiplier = 0;
            var emitter = emitterOrConfig;
            if (emitter && !(emitterOrConfig instanceof ParticleEmitter)) {
                var config = emitterOrConfig;
                emitter = config.emitter;
                life = config.life;
                opacity = config.opacity;
                endColor = config.endColor;
                beginColor = config.beginColor;
                position = config.position;
                velocity = config.velocity;
                acceleration = config.acceleration;
                startSize = config.startSize;
                endSize = config.endSize;
            }
            this.emitter = emitter;
            this.life = life || this.life;
            this.opacity = opacity || this.opacity;
            this.endColor = endColor || this.endColor.clone();
            this.beginColor = beginColor || this.beginColor.clone();
            this._currentColor = this.beginColor.clone();
            this.position = position || this.position;
            this.velocity = velocity || this.velocity;
            this.acceleration = acceleration || this.acceleration;
            this._rRate = (this.endColor.r - this.beginColor.r) / this.life;
            this._gRate = (this.endColor.g - this.beginColor.g) / this.life;
            this._bRate = (this.endColor.b - this.beginColor.b) / this.life;
            this._aRate = this.opacity / this.life;
            this.startSize = startSize || 0;
            this.endSize = endSize || 0;
            if ((this.endSize > 0) && (this.startSize > 0)) {
                this.sizeRate = (this.endSize - this.startSize) / this.life;
                this.particleSize = this.startSize;
            }
        }
        ParticleImpl.prototype.kill = function () {
            this.emitter.removeParticle(this);
        };
        ParticleImpl.prototype.update = function (delta) {
            this.life = this.life - delta;
            this.elapsedMultiplier = this.elapsedMultiplier + delta;
            if (this.life < 0) {
                this.kill();
            }
            if (this.fadeFlag) {
                this.opacity = Util.clamp(this._aRate * this.life, 0.0001, 1);
            }
            if ((this.startSize > 0) && (this.endSize > 0)) {
                this.particleSize = Util.clamp(this.sizeRate * delta + this.particleSize, Math.min(this.startSize, this.endSize), Math.max(this.startSize, this.endSize));
            }
            this._currentColor.r = Util.clamp(this._currentColor.r + this._rRate * delta, 0, 255);
            this._currentColor.g = Util.clamp(this._currentColor.g + this._gRate * delta, 0, 255);
            this._currentColor.b = Util.clamp(this._currentColor.b + this._bRate * delta, 0, 255);
            this._currentColor.a = Util.clamp(this.opacity, 0.0001, 1);
            if (this.focus) {
                var accel = this.focus.sub(this.position).normalize().scale(this.focusAccel).scale(delta / 1000);
                this.velocity = this.velocity.add(accel);
            }
            else {
                this.velocity = this.velocity.add(this.acceleration.scale(delta / 1000));
            }
            this.position = this.position.add(this.velocity.scale(delta / 1000));
            if (this.particleRotationalVelocity) {
                this.currentRotation = (this.currentRotation + this.particleRotationalVelocity * delta / 1000) % (2 * Math.PI);
            }
        };
        ParticleImpl.prototype.draw = function (ctx) {
            if (this.particleSprite) {
                this.particleSprite.rotation = this.currentRotation;
                this.particleSprite.scale.setTo(this.particleSize, this.particleSize);
                this.particleSprite.draw(ctx, this.position.x, this.position.y);
                return;
            }
            this._currentColor.a = Util.clamp(this.opacity, 0.0001, 1);
            ctx.fillStyle = this._currentColor.toString();
            ctx.beginPath();
            ctx.arc(this.position.x, this.position.y, this.particleSize, 0, Math.PI * 2);
            ctx.fill();
            ctx.closePath();
        };
        return ParticleImpl;
    }());
    exports.ParticleImpl = ParticleImpl;
    /**
     * Particle is used in a [[ParticleEmitter]]
     */
    var Particle = (function (_super) {
        __extends(Particle, _super);
        function Particle(emitterOrConfig, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize) {
            return _super.call(this, emitterOrConfig, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize) || this;
        }
        return Particle;
    }(Configurable_5.Configurable(ParticleImpl)));
    exports.Particle = Particle;
    /**
     * @hidden
     */
    var ParticleEmitterImpl = (function (_super) {
        __extends(ParticleEmitterImpl, _super);
        /**
         * @param x       The x position of the emitter
         * @param y       The y position of the emitter
         * @param width   The width of the emitter
         * @param height  The height of the emitter
         */
        function ParticleEmitterImpl(xOrConfig, y, width, height) {
            var _this = _super.call(this, typeof xOrConfig === 'number' ? { x: xOrConfig, y: y, width: width, height: height } : xOrConfig) || this;
            _this.numParticles = 0;
            /**
             * Gets or sets the isEmitting flag
             */
            _this.isEmitting = true;
            /**
             * Gets or sets the backing particle collection
             */
            _this.particles = null;
            /**
             * Gets or sets the backing deadParticle collection
             */
            _this.deadParticles = null;
            /**
             * Gets or sets the minimum particle velocity
             */
            _this.minVel = 0;
            /**
             * Gets or sets the maximum particle velocity
             */
            _this.maxVel = 0;
            /**
             * Gets or sets the acceleration vector for all particles
             */
            _this.acceleration = new Algebra_15.Vector(0, 0);
            /**
             * Gets or sets the minimum angle in radians
             */
            _this.minAngle = 0;
            /**
             * Gets or sets the maximum angle in radians
             */
            _this.maxAngle = 0;
            /**
             * Gets or sets the emission rate for particles (particles/sec)
             */
            _this.emitRate = 1; //particles/sec
            /**
             * Gets or sets the life of each particle in milliseconds
             */
            _this.particleLife = 2000;
            /**
             * Gets or sets the opacity of each particle from 0 to 1.0
             */
            _this.opacity = 1;
            /**
             * Gets or sets the fade flag which causes particles to gradually fade out over the course of their life.
             */
            _this.fadeFlag = false;
            /**
             * Gets or sets the optional focus where all particles should accelerate towards
             */
            _this.focus = null;
            /**
             * Gets or sets the acceleration for focusing particles if a focus has been specified
             */
            _this.focusAccel = 1;
            /*
             * Gets or sets the optional starting size for the particles
             */
            _this.startSize = null;
            /*
             * Gets or sets the optional ending size for the particles
             */
            _this.endSize = null;
            /**
             * Gets or sets the minimum size of all particles
             */
            _this.minSize = 5;
            /**
             * Gets or sets the maximum size of all particles
             */
            _this.maxSize = 5;
            /**
             * Gets or sets the beginning color of all particles
             */
            _this.beginColor = Color_14.Color.White.clone();
            /**
             * Gets or sets the ending color of all particles
             */
            _this.endColor = Color_14.Color.White.clone();
            /**
             * Gets or sets the sprite that a particle should use
             * @warning Performance intensive
             */
            _this.particleSprite = null;
            /**
             * Gets or sets the emitter type for the particle emitter
             */
            _this.emitterType = EmitterType.Rectangle;
            /**
             * Gets or sets the emitter radius, only takes effect when the [[emitterType]] is [[EmitterType.Circle]]
             */
            _this.radius = 0;
            /**
             * Gets or sets the particle rotational speed velocity
             */
            _this.particleRotationalVelocity = 0;
            /**
             * Indicates whether particles should start with a random rotation
             */
            _this.randomRotation = false;
            _this._particlesToEmit = 0;
            _this.collisionType = Actor_7.CollisionType.PreventCollision;
            _this.particles = new Util.Collection();
            _this.deadParticles = new Util.Collection();
            _this.random = new Random_2.Random();
            // Remove offscreen culling from particle emitters
            for (var i = 0; i < _this.traits.length; i++) {
                if (_this.traits[i] instanceof Traits.OffscreenCulling) {
                    _this.traits.splice(i, 1);
                }
            }
            return _this;
        }
        ParticleEmitterImpl.prototype.removeParticle = function (particle) {
            this.deadParticles.push(particle);
        };
        /**
         * Causes the emitter to emit particles
         * @param particleCount  Number of particles to emit right now
         */
        ParticleEmitterImpl.prototype.emitParticles = function (particleCount) {
            for (var i = 0; i < particleCount; i++) {
                this.particles.push(this._createParticle());
            }
        };
        ParticleEmitterImpl.prototype.clearParticles = function () {
            this.particles.clear();
        };
        // Creates a new particle given the constraints of the emitter
        ParticleEmitterImpl.prototype._createParticle = function () {
            // todo implement emitter constraints;
            var ranX = 0;
            var ranY = 0;
            var angle = Util.randomInRange(this.minAngle, this.maxAngle, this.random);
            var vel = Util.randomInRange(this.minVel, this.maxVel, this.random);
            var size = this.startSize || Util.randomInRange(this.minSize, this.maxSize, this.random);
            var dx = vel * Math.cos(angle);
            var dy = vel * Math.sin(angle);
            if (this.emitterType === EmitterType.Rectangle) {
                ranX = Util.randomInRange(this.pos.x, this.pos.x + this.getWidth(), this.random);
                ranY = Util.randomInRange(this.pos.y, this.pos.y + this.getHeight(), this.random);
            }
            else if (this.emitterType === EmitterType.Circle) {
                var radius = Util.randomInRange(0, this.radius, this.random);
                ranX = radius * Math.cos(angle) + this.pos.x;
                ranY = radius * Math.sin(angle) + this.pos.y;
            }
            var p = new Particle(this, this.particleLife, this.opacity, this.beginColor, this.endColor, new Algebra_15.Vector(ranX, ranY), new Algebra_15.Vector(dx, dy), this.acceleration, this.startSize, this.endSize);
            p.fadeFlag = this.fadeFlag;
            p.particleSize = size;
            if (this.particleSprite) {
                p.particleSprite = this.particleSprite;
            }
            p.particleRotationalVelocity = this.particleRotationalVelocity;
            if (this.randomRotation) {
                p.currentRotation = Util.randomInRange(0, Math.PI * 2, this.random);
            }
            if (this.focus) {
                p.focus = this.focus.add(new Algebra_15.Vector(this.pos.x, this.pos.y));
                p.focusAccel = this.focusAccel;
            }
            return p;
        };
        ParticleEmitterImpl.prototype.update = function (engine, delta) {
            var _this = this;
            _super.prototype.update.call(this, engine, delta);
            if (this.isEmitting) {
                this._particlesToEmit += this.emitRate * (delta / 1000);
                //var numParticles = Math.ceil(this.emitRate * delta / 1000);
                if (this._particlesToEmit > 1.0) {
                    this.emitParticles(Math.floor(this._particlesToEmit));
                    this._particlesToEmit = this._particlesToEmit - Math.floor(this._particlesToEmit);
                }
            }
            this.particles.forEach(function (p) { return p.update(delta); });
            this.deadParticles.forEach(function (p) { return _this.particles.removeElement(p); });
            this.deadParticles.clear();
        };
        ParticleEmitterImpl.prototype.draw = function (ctx) {
            // todo is there a more efficient to draw 
            // possibly use a webgl offscreen canvas and shaders to do particles?
            this.particles.forEach(function (p) { return p.draw(ctx); });
        };
        ParticleEmitterImpl.prototype.debugDraw = function (ctx) {
            _super.prototype.debugDraw.call(this, ctx);
            ctx.fillStyle = Color_14.Color.Black.toString();
            ctx.fillText('Particles: ' + this.particles.count(), this.pos.x, this.pos.y + 20);
            if (this.focus) {
                ctx.fillRect(this.focus.x + this.pos.x, this.focus.y + this.pos.y, 3, 3);
                DrawUtil.line(ctx, Color_14.Color.Yellow, this.focus.x + this.pos.x, this.focus.y + this.pos.y, _super.prototype.getCenter.call(this).x, _super.prototype.getCenter.call(this).y);
                ctx.fillText('Focus', this.focus.x + this.pos.x, this.focus.y + this.pos.y);
            }
        };
        return ParticleEmitterImpl;
    }(Actor_7.Actor));
    exports.ParticleEmitterImpl = ParticleEmitterImpl;
    /**
     * Using a particle emitter is a great way to create interesting effects
     * in your game, like smoke, fire, water, explosions, etc. `ParticleEmitter`
     * extend [[Actor]] allowing you to use all of the features that come with.
     *
     * [[include:Particles.md]]
     */
    var ParticleEmitter = (function (_super) {
        __extends(ParticleEmitter, _super);
        function ParticleEmitter(xOrConfig, y, width, height) {
            return _super.call(this, xOrConfig, y, width, height) || this;
        }
        return ParticleEmitter;
    }(Configurable_5.Configurable(ParticleEmitterImpl)));
    exports.ParticleEmitter = ParticleEmitter;
});
define("TileMap", ["require", "exports", "Collision/BoundingBox", "Drawing/Color", "Class", "Algebra", "Util/Log", "Events", "Configurable"], function (require, exports, BoundingBox_4, Color_15, Class_4, Algebra_16, Log_7, Events, Configurable_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @hidden
     */
    var TileMapImpl = (function (_super) {
        __extends(TileMapImpl, _super);
        /**
         * @param x             The x coordinate to anchor the TileMap's upper left corner (should not be changed once set)
         * @param y             The y coordinate to anchor the TileMap's upper left corner (should not be changed once set)
         * @param cellWidth     The individual width of each cell (in pixels) (should not be changed once set)
         * @param cellHeight    The individual height of each cell (in pixels) (should not be changed once set)
         * @param rows          The number of rows in the TileMap (should not be changed once set)
         * @param cols          The number of cols in the TileMap (should not be changed once set)
         */
        function TileMapImpl(xOrConfig, y, cellWidth, cellHeight, rows, cols) {
            var _this = _super.call(this) || this;
            _this._collidingX = -1;
            _this._collidingY = -1;
            _this._onScreenXStart = 0;
            _this._onScreenXEnd = 9999;
            _this._onScreenYStart = 0;
            _this._onScreenYEnd = 9999;
            _this._spriteSheets = {};
            _this.logger = Log_7.Logger.getInstance();
            _this.data = [];
            if (xOrConfig && typeof xOrConfig === 'object') {
                var config = xOrConfig;
                xOrConfig = config.x;
                y = config.y;
                cellWidth = config.cellWidth;
                cellHeight = config.cellHeight;
                rows = config.rows;
                cols = config.cols;
            }
            _this.data = new Array(rows * cols);
            for (var i = 0; i < cols; i++) {
                for (var j = 0; j < rows; j++) {
                    (function () {
                        var cd = new Cell(i * cellWidth + xOrConfig, j * cellHeight + y, cellWidth, cellHeight, i + j * cols);
                        _this.data[i + j * cols] = cd;
                    })();
                }
            }
            return _this;
        }
        TileMapImpl.prototype.on = function (eventName, handler) {
            _super.prototype.on.call(this, eventName, handler);
        };
        TileMapImpl.prototype.registerSpriteSheet = function (key, spriteSheet) {
            this._spriteSheets[key] = spriteSheet;
        };
        /**
         * Returns the intersection vector that can be used to resolve collisions with actors. If there
         * is no collision null is returned.
         */
        TileMapImpl.prototype.collides = function (actor) {
            var width = actor.pos.x + actor.getWidth();
            var height = actor.pos.y + actor.getHeight();
            var actorBounds = actor.getBounds();
            var overlaps = [];
            // trace points for overlap
            for (var x = actorBounds.left; x <= width; x += Math.min(actor.getWidth() / 2, this.cellWidth / 2)) {
                for (var y = actorBounds.top; y <= height; y += Math.min(actor.getHeight() / 2, this.cellHeight / 2)) {
                    var cell = this.getCellByPoint(x, y);
                    if (cell && cell.solid) {
                        var overlap = actorBounds.collides(cell.getBounds());
                        var dir = actor.getCenter().sub(cell.getCenter());
                        if (overlap && overlap.dot(dir) > 0) {
                            overlaps.push(overlap);
                        }
                    }
                }
            }
            if (overlaps.length === 0) {
                return null;
            }
            // Return the smallest change other than zero
            var result = overlaps.reduce(function (accum, next) {
                var x = accum.x;
                var y = accum.y;
                if (Math.abs(accum.x) < Math.abs(next.x)) {
                    x = next.x;
                }
                if (Math.abs(accum.y) < Math.abs(next.y)) {
                    y = next.y;
                }
                return new Algebra_16.Vector(x, y);
            });
            return result;
        };
        /**
         * Returns the [[Cell]] by index (row major order)
         */
        TileMapImpl.prototype.getCellByIndex = function (index) {
            return this.data[index];
        };
        /**
         * Returns the [[Cell]] by its x and y coordinates
         */
        TileMapImpl.prototype.getCell = function (x, y) {
            if (x < 0 || y < 0 || x >= this.cols || y >= this.rows) {
                return null;
            }
            return this.data[x + y * this.cols];
        };
        /**
         * Returns the [[Cell]] by testing a point in global coordinates,
         * returns `null` if no cell was found.
         */
        TileMapImpl.prototype.getCellByPoint = function (x, y) {
            x = Math.floor((x - this.x) / this.cellWidth);
            y = Math.floor((y - this.y) / this.cellHeight);
            var cell = this.getCell(x, y);
            if (x >= 0 && y >= 0 && x < this.cols && y < this.rows && cell) {
                return cell;
            }
            return null;
        };
        TileMapImpl.prototype.update = function (engine, delta) {
            this.emit('preupdate', new Events.PreUpdateEvent(engine, delta, this));
            var worldCoordsUpperLeft = engine.screenToWorldCoordinates(new Algebra_16.Vector(0, 0));
            var worldCoordsLowerRight = engine.screenToWorldCoordinates(new Algebra_16.Vector(engine.canvas.clientWidth, engine.canvas.clientHeight));
            this._onScreenXStart = Math.max(Math.floor(worldCoordsUpperLeft.x / this.cellWidth) - 2, 0);
            this._onScreenYStart = Math.max(Math.floor((worldCoordsUpperLeft.y - this.y) / this.cellHeight) - 2, 0);
            this._onScreenXEnd = Math.max(Math.floor(worldCoordsLowerRight.x / this.cellWidth) + 2, 0);
            this._onScreenYEnd = Math.max(Math.floor((worldCoordsLowerRight.y - this.y) / this.cellHeight) + 2, 0);
            this.emit('postupdate', new Events.PostUpdateEvent(engine, delta, this));
        };
        /**
         * Draws the tile map to the screen. Called by the [[Scene]].
         * @param ctx    The current rendering context
         * @param delta  The number of milliseconds since the last draw
         */
        TileMapImpl.prototype.draw = function (ctx, delta) {
            this.emit('predraw', new Events.PreDrawEvent(ctx, delta, this));
            ctx.save();
            ctx.translate(this.x, this.y);
            var x = this._onScreenXStart, xEnd = Math.min(this._onScreenXEnd, this.cols);
            var y = this._onScreenYStart, yEnd = Math.min(this._onScreenYEnd, this.rows);
            var cs, csi, cslen;
            for (x; x < xEnd; x++) {
                for (y; y < yEnd; y++) {
                    // get non-negative tile sprites
                    cs = this.getCell(x, y).sprites.filter(function (s) {
                        return s.spriteId > -1;
                    });
                    for (csi = 0, cslen = cs.length; csi < cslen; csi++) {
                        var ss = this._spriteSheets[cs[csi].spriteSheetKey];
                        // draw sprite, warning if sprite doesn't exist
                        if (ss) {
                            var sprite = ss.getSprite(cs[csi].spriteId);
                            if (sprite) {
                                sprite.draw(ctx, x * this.cellWidth, y * this.cellHeight);
                            }
                            else {
                                this.logger.warn('Sprite does not exist for id', cs[csi].spriteId, 'in sprite sheet', cs[csi].spriteSheetKey, sprite, ss);
                            }
                        }
                        else {
                            this.logger.warn('Sprite sheet', cs[csi].spriteSheetKey, 'does not exist', ss);
                        }
                    }
                }
                y = this._onScreenYStart;
            }
            ctx.restore();
            this.emit('postdraw', new Events.PostDrawEvent(ctx, delta, this));
        };
        /**
         * Draws all the tile map's debug info. Called by the [[Scene]].
         * @param ctx  The current rendering context
         */
        TileMapImpl.prototype.debugDraw = function (ctx) {
            var width = this.cols * this.cellWidth;
            var height = this.rows * this.cellHeight;
            ctx.save();
            ctx.strokeStyle = Color_15.Color.Red.toString();
            for (var x = 0; x < this.cols + 1; x++) {
                ctx.beginPath();
                ctx.moveTo(this.x + x * this.cellWidth, this.y);
                ctx.lineTo(this.x + x * this.cellWidth, this.y + height);
                ctx.stroke();
            }
            for (var y = 0; y < this.rows + 1; y++) {
                ctx.beginPath();
                ctx.moveTo(this.x, this.y + y * this.cellHeight);
                ctx.lineTo(this.x + width, this.y + y * this.cellHeight);
                ctx.stroke();
            }
            var solid = Color_15.Color.Red.clone();
            solid.a = .3;
            this.data.filter(function (cell) {
                return cell.solid;
            }).forEach(function (cell) {
                ctx.fillStyle = solid.toString();
                ctx.fillRect(cell.x, cell.y, cell.width, cell.height);
            });
            if (this._collidingY > -1 && this._collidingX > -1) {
                ctx.fillStyle = Color_15.Color.Cyan.toString();
                ctx.fillRect(this.x + this._collidingX * this.cellWidth, this.y + this._collidingY * this.cellHeight, this.cellWidth, this.cellHeight);
            }
            ctx.restore();
        };
        return TileMapImpl;
    }(Class_4.Class));
    exports.TileMapImpl = TileMapImpl;
    /**
     * The [[TileMap]] class provides a lightweight way to do large complex scenes with collision
     * without the overhead of actors.
     *
     * [[include:TileMaps.md]]
     */
    var TileMap = (function (_super) {
        __extends(TileMap, _super);
        function TileMap(xOrConfig, y, cellWidth, cellHeight, rows, cols) {
            return _super.call(this, xOrConfig, y, cellWidth, cellHeight, rows, cols) || this;
        }
        return TileMap;
    }(Configurable_6.Configurable(TileMapImpl)));
    exports.TileMap = TileMap;
    /**
     * Tile sprites are used to render a specific sprite from a [[TileMap]]'s spritesheet(s)
     */
    var TileSprite = (function () {
        /**
         * @param spriteSheetKey  The key of the spritesheet to use
         * @param spriteId        The index of the sprite in the [[SpriteSheet]]
         */
        function TileSprite(spriteSheetKey, spriteId) {
            this.spriteSheetKey = spriteSheetKey;
            this.spriteId = spriteId;
        }
        return TileSprite;
    }());
    exports.TileSprite = TileSprite;
    /**
     * @hidden
     */
    var CellImpl = (function () {
        /**
         * @param x       Gets or sets x coordinate of the cell in world coordinates
         * @param y       Gets or sets y coordinate of the cell in world coordinates
         * @param width   Gets or sets the width of the cell
         * @param height  Gets or sets the height of the cell
         * @param index   The index of the cell in row major order
         * @param solid   Gets or sets whether this cell is solid
         * @param sprites The list of tile sprites to use to draw in this cell (in order)
         */
        function CellImpl(xOrConfig, y, width, height, index, solid, sprites) {
            if (solid === void 0) { solid = false; }
            if (sprites === void 0) { sprites = []; }
            this.solid = false;
            this.sprites = [];
            if (xOrConfig && typeof xOrConfig === 'object') {
                var config = xOrConfig;
                xOrConfig = config.x;
                y = config.y;
                width = config.width;
                height = config.height;
                index = config.index;
                solid = config.solid;
                sprites = config.sprites;
            }
            this.x = xOrConfig;
            this.y = y;
            this.width = width;
            this.height = height;
            this.index = index;
            this.solid = solid;
            this.sprites = sprites;
            this._bounds = new BoundingBox_4.BoundingBox(this.x, this.y, this.x + this.width, this.y + this.height);
        }
        /**
         * Returns the bounding box for this cell
         */
        CellImpl.prototype.getBounds = function () {
            return this._bounds;
        };
        /**
         * Gets the center coordinate of this cell
         */
        CellImpl.prototype.getCenter = function () {
            return new Algebra_16.Vector(this.x + this.width / 2, this.y + this.height / 2);
        };
        /**
         * Add another [[TileSprite]] to this cell
         */
        CellImpl.prototype.pushSprite = function (tileSprite) {
            this.sprites.push(tileSprite);
        };
        /**
         * Remove an instance of [[TileSprite]] from this cell
         */
        CellImpl.prototype.removeSprite = function (tileSprite) {
            var index = -1;
            if ((index = this.sprites.indexOf(tileSprite)) > -1) {
                this.sprites.splice(index, 1);
            }
        };
        /**
         * Clear all sprites from this cell
         */
        CellImpl.prototype.clearSprites = function () {
            this.sprites.length = 0;
        };
        return CellImpl;
    }());
    exports.CellImpl = CellImpl;
    /**
     * TileMap Cell
     *
     * A light-weight object that occupies a space in a collision map. Generally
     * created by a [[TileMap]].
     *
     * Cells can draw multiple sprites. Note that the order of drawing is the order
     * of the sprites in the array so the last one will be drawn on top. You can
     * use transparency to create layers this way.
     */
    var Cell = (function (_super) {
        __extends(Cell, _super);
        function Cell(xOrConfig, y, width, height, index, solid, sprites) {
            return _super.call(this, xOrConfig, y, width, height, index, solid, sprites) || this;
        }
        return Cell;
    }(Configurable_6.Configurable(CellImpl)));
    exports.Cell = Cell;
});
define("Timer", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The Excalibur timer hooks into the internal timer and fires callbacks,
     * after a certain interval, optionally repeating.
     */
    var Timer = (function () {
        /**
         * @param fcn        The callback to be fired after the interval is complete.
         * @param interval   Interval length
         * @param repeats    Indicates whether this call back should be fired only once, or repeat after every interval as completed.
         */
        function Timer(fcn, interval, repeats) {
            this.id = 0;
            this.interval = 10;
            this.fcn = function () { return; };
            this.repeats = false;
            this._elapsedTime = 0;
            this._totalTimeAlive = 0;
            this._paused = false;
            this.complete = false;
            this.scene = null;
            this.id = Timer.id++;
            this.interval = interval || this.interval;
            this.fcn = fcn || this.fcn;
            this.repeats = repeats || this.repeats;
        }
        /**
         * Updates the timer after a certain number of milliseconds have elapsed. This is used internally by the engine.
         * @param delta  Number of elapsed milliseconds since the last update.
         */
        Timer.prototype.update = function (delta) {
            if (!this._paused) {
                this._totalTimeAlive += delta;
                this._elapsedTime += delta;
                if (!this.complete && this._elapsedTime >= this.interval) {
                    this.fcn.call(this);
                    if (this.repeats) {
                        this._elapsedTime = 0;
                    }
                    else {
                        this.complete = true;
                    }
                }
            }
        };
        /**
         * Resets the timer so that it can be reused, and optionally reconfigure the timers interval.
         * @param newInterval If specified, sets a new non-negative interval in milliseconds to refire the callback
         */
        Timer.prototype.reset = function (newInterval) {
            if (!!newInterval && newInterval >= 0) {
                this.interval = newInterval;
            }
            this.complete = false;
            this._elapsedTime = 0;
        };
        Timer.prototype.getTimeRunning = function () {
            return this._totalTimeAlive;
        };
        /**
         * Pauses the timer so that no more time will be incremented towards the next call
         */
        Timer.prototype.pause = function () {
            this._paused = true;
        };
        /**
         * Unpauses the timer. Time will now increment towards the next call
         */
        Timer.prototype.unpause = function () {
            this._paused = false;
        };
        /**
         * Cancels the timer, preventing any further executions.
         */
        Timer.prototype.cancel = function () {
            if (this.scene) {
                this.scene.cancelTimer(this);
            }
        };
        return Timer;
    }());
    Timer.id = 0;
    exports.Timer = Timer;
});
define("Trigger", ["require", "exports", "Drawing/Color", "Actions/Action", "EventDispatcher", "Actor", "Algebra", "Events", "Util/Util"], function (require, exports, Color_16, Action_1, EventDispatcher_1, Actor_8, Algebra_17, Events_5, Util) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var triggerDefaults = {
        pos: Algebra_17.Vector.Zero.clone(),
        width: 10,
        height: 10,
        visible: false,
        action: function () { return; },
        filter: function () { return true; },
        repeat: -1
    };
    /**
     * Triggers are a method of firing arbitrary code on collision. These are useful
     * as 'buttons', 'switches', or to trigger effects in a game. By default triggers
     * are invisible, and can only be seen when [[Trigger.visible]] is set to `true`.
     *
     * [[include:Triggers.md]]
     */
    var Trigger = (function (_super) {
        __extends(Trigger, _super);
        /**
         *
         * @param opts Trigger options
         */
        function Trigger(opts) {
            var _this = _super.call(this, opts.pos.x, opts.pos.y, opts.width, opts.height) || this;
            /**
             * Action to fire when triggered by collision
             */
            _this.action = function () { return; };
            /**
             * Filter to add additional granularity to action dispatch, if a filter is specified the action will only fire when
             * filter return true for the collided actor.
             */
            _this.filter = function () { return true; };
            /**
             * Number of times to repeat before killing the trigger,
             */
            _this.repeat = -1;
            opts = Util.extend({}, triggerDefaults, opts);
            _this.filter = opts.filter || _this.filter;
            _this.repeat = opts.repeat || _this.repeat;
            _this.action = opts.action || _this.action;
            if (opts.target) {
                _this.target = opts.target;
            }
            _this.visible = opts.visible;
            _this.collisionType = Actor_8.CollisionType.Passive;
            _this.eventDispatcher = new EventDispatcher_1.EventDispatcher(_this);
            _this.actionQueue = new Action_1.ActionQueue(_this);
            _this.on('collisionstart', function (evt) {
                if (_this.filter(evt.other)) {
                    _this.emit('enter', new Events_5.EnterTriggerEvent(_this, evt.other));
                    _this._dispatchAction();
                    // remove trigger if its done, -1 repeat forever
                    if (_this.repeat === 0) {
                        _this.kill();
                    }
                }
            });
            _this.on('collisionend', function (evt) {
                if (_this.filter(evt.other)) {
                    _this.emit('exit', new Events_5.ExitTriggerEvent(_this, evt.other));
                }
            });
            return _this;
        }
        Object.defineProperty(Trigger.prototype, "target", {
            get: function () {
                return this._target;
            },
            set: function (target) {
                this._target = target;
                this.filter = function (actor) { return actor === target; };
            },
            enumerable: true,
            configurable: true
        });
        Trigger.prototype._initialize = function (engine) {
            _super.prototype._initialize.call(this, engine);
        };
        Trigger.prototype._dispatchAction = function () {
            this.action.call(this);
            this.repeat--;
        };
        /* istanbul ignore next */
        Trigger.prototype.debugDraw = function (ctx) {
            _super.prototype.debugDraw.call(this, ctx);
            // Meant to draw debug information about actors
            ctx.save();
            ctx.translate(this.pos.x, this.pos.y);
            var bb = this.getBounds();
            var wp = this.getWorldPos();
            bb.left = bb.left - wp.x;
            bb.right = bb.right - wp.x;
            bb.top = bb.top - wp.y;
            bb.bottom = bb.bottom - wp.y;
            // Currently collision primitives cannot rotate 
            // ctx.rotate(this.rotation);
            ctx.fillStyle = Color_16.Color.Violet.toString();
            ctx.strokeStyle = Color_16.Color.Violet.toString();
            ctx.fillText('Trigger', 10, 10);
            bb.debugDraw(ctx);
            ctx.restore();
        };
        return Trigger;
    }(Actor_8.Actor));
    exports.Trigger = Trigger;
});
define("Actions/Index", ["require", "exports", "Actions/ActionContext", "Actions/RotationType", "Actions/Action"], function (require, exports, ActionContext_2, RotationType_1, actions) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(ActionContext_2);
    __export(RotationType_1);
    exports.Actions = actions;
    // legacy Internal.Actions namespace support
    exports.Internal = { Actions: actions };
});
define("Collision/DynamicTree", ["require", "exports", "Physics", "Collision/BoundingBox", "Util/Log"], function (require, exports, Physics_8, BoundingBox_5, Log_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Dynamic Tree Node used for tracking bounds within the tree
     */
    var TreeNode = (function () {
        function TreeNode(parent) {
            this.parent = parent;
            this.parent = parent || null;
            this.body = null;
            this.bounds = new BoundingBox_5.BoundingBox();
            this.left = null;
            this.right = null;
            this.height = 0;
        }
        TreeNode.prototype.isLeaf = function () {
            return (!this.left && !this.right);
        };
        return TreeNode;
    }());
    exports.TreeNode = TreeNode;
    /**
     * The DynamicTrees provides a spatial partiioning data structure for quickly querying for overlapping bounding boxes for
     * all tracked bodies. The worst case performance of this is O(n*log(n)) where n is the number of bodies in the tree.
     *
     * Internally the bounding boxes are organized as a balanced binary tree of bounding boxes, where the leaf nodes are tracked bodies.
     * Every non-leaf node is a bounding box that contains child bounding boxes.
     */
    var DynamicTree = (function () {
        function DynamicTree(worldBounds) {
            if (worldBounds === void 0) { worldBounds = new BoundingBox_5.BoundingBox(-Number.MAX_VALUE, -Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE); }
            this.worldBounds = worldBounds;
            this.root = null;
            this.nodes = {};
        }
        /**
         * Inserts a node into the dynamic tree
         */
        DynamicTree.prototype._insert = function (leaf) {
            // If there are no nodes in the tree, make this the root leaf
            if (this.root === null) {
                this.root = leaf;
                this.root.parent = null;
                return;
            }
            // Search the tree for a node that is not a leaf and find the best place to insert
            var leafAABB = leaf.bounds;
            var currentRoot = this.root;
            while (!currentRoot.isLeaf()) {
                var left = currentRoot.left;
                var right = currentRoot.right;
                var area = currentRoot.bounds.getPerimeter();
                var combinedAABB = currentRoot.bounds.combine(leafAABB);
                var combinedArea = combinedAABB.getPerimeter();
                // Calculate cost heuristic for creating a new parent and leaf
                var cost = 2 * combinedArea;
                // Minimum cost of pushing the leaf down the tree
                var inheritanceCost = 2 * (combinedArea - area);
                // Cost of descending
                var leftCost = 0;
                var leftCombined = leafAABB.combine(left.bounds);
                var newArea;
                var oldArea;
                if (left.isLeaf()) {
                    leftCost = leftCombined.getPerimeter() + inheritanceCost;
                }
                else {
                    oldArea = left.bounds.getPerimeter();
                    newArea = leftCombined.getPerimeter();
                    leftCost = (newArea - oldArea) + inheritanceCost;
                }
                var rightCost = 0;
                var rightCombined = leafAABB.combine(right.bounds);
                if (right.isLeaf()) {
                    rightCost = rightCombined.getPerimeter() + inheritanceCost;
                }
                else {
                    oldArea = right.bounds.getPerimeter();
                    newArea = rightCombined.getPerimeter();
                    rightCost = (newArea - oldArea) + inheritanceCost;
                }
                // cost is acceptable
                if (cost < leftCost && cost < rightCost) {
                    break;
                }
                // Descend to the depths
                if (leftCost < rightCost) {
                    currentRoot = left;
                }
                else {
                    currentRoot = right;
                }
            }
            // Create the new parent node and insert into the tree
            var oldParent = currentRoot.parent;
            var newParent = new TreeNode(oldParent);
            newParent.bounds = leafAABB.combine(currentRoot.bounds);
            newParent.height = currentRoot.height + 1;
            if (oldParent !== null) {
                // The sibling node was not the root
                if (oldParent.left === currentRoot) {
                    oldParent.left = newParent;
                }
                else {
                    oldParent.right = newParent;
                }
                newParent.left = currentRoot;
                newParent.right = leaf;
                currentRoot.parent = newParent;
                leaf.parent = newParent;
            }
            else {
                // The sibling node was the root
                newParent.left = currentRoot;
                newParent.right = leaf;
                currentRoot.parent = newParent;
                leaf.parent = newParent;
                this.root = newParent;
            }
            // Walk up the tree fixing heights and AABBs
            var currentNode = leaf.parent;
            while (currentNode) {
                currentNode = this._balance(currentNode);
                if (!currentNode.left) {
                    throw new Error('Parent of current leaf cannot have a null left child' + currentNode);
                }
                if (!currentNode.right) {
                    throw new Error('Parent of current leaf cannot have a null right child' + currentNode);
                }
                currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);
                currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);
                currentNode = currentNode.parent;
            }
        };
        /**
         * Removes a node from the dynamic tree
         */
        DynamicTree.prototype._remove = function (leaf) {
            if (leaf === this.root) {
                this.root = null;
                return;
            }
            var parent = leaf.parent;
            var grandParent = parent.parent;
            var sibling;
            if (parent.left === leaf) {
                sibling = parent.right;
            }
            else {
                sibling = parent.left;
            }
            if (grandParent) {
                if (grandParent.left === parent) {
                    grandParent.left = sibling;
                }
                else {
                    grandParent.right = sibling;
                }
                sibling.parent = grandParent;
                var currentNode = grandParent;
                while (currentNode) {
                    currentNode = this._balance(currentNode);
                    currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);
                    currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);
                    currentNode = currentNode.parent;
                }
            }
            else {
                this.root = sibling;
                sibling.parent = null;
            }
        };
        /**
         * Tracks a body in the dynamic tree
         */
        DynamicTree.prototype.trackBody = function (body) {
            var node = new TreeNode();
            node.body = body;
            node.bounds = body.getBounds();
            node.bounds.left -= 2;
            node.bounds.top -= 2;
            node.bounds.right += 2;
            node.bounds.bottom += 2;
            this.nodes[body.actor.id] = node;
            this._insert(node);
        };
        /**
         * Updates the dynamic tree given the current bounds of each body being tracked
         */
        DynamicTree.prototype.updateBody = function (body) {
            var node = this.nodes[body.actor.id];
            if (!node) {
                return false;
            }
            var b = body.getBounds();
            // if the body is outside the world no longer update it
            if (!this.worldBounds.contains(b)) {
                Log_8.Logger.getInstance().warn('Actor with id ' + body.actor.id +
                    ' is outside the world bounds and will no longer be tracked for physics');
                this.untrackBody(body);
                return false;
            }
            if (node.bounds.contains(b)) {
                return false;
            }
            this._remove(node);
            b.left -= Physics_8.Physics.boundsPadding;
            b.top -= Physics_8.Physics.boundsPadding;
            b.right += Physics_8.Physics.boundsPadding;
            b.bottom += Physics_8.Physics.boundsPadding;
            var multdx = body.vel.x * Physics_8.Physics.dynamicTreeVelocityMultiplyer;
            var multdy = body.vel.y * Physics_8.Physics.dynamicTreeVelocityMultiplyer;
            if (multdx < 0) {
                b.left += multdx;
            }
            else {
                b.right += multdx;
            }
            if (multdy < 0) {
                b.top += multdy;
            }
            else {
                b.bottom += multdy;
            }
            node.bounds = b;
            this._insert(node);
            return true;
        };
        /**
         * Untracks a body from the dynamic tree
         */
        DynamicTree.prototype.untrackBody = function (body) {
            var node = this.nodes[body.actor.id];
            if (!node) {
                return;
            }
            this._remove(node);
            this.nodes[body.actor.id] = null;
            delete this.nodes[body.actor.id];
        };
        /**
         * Balances the tree about a node
         */
        DynamicTree.prototype._balance = function (node) {
            if (node === null) {
                throw new Error('Cannot balance at null node');
            }
            if (node.isLeaf() || node.height < 2) {
                return node;
            }
            var left = node.left;
            var right = node.right;
            var a = node;
            var b = left;
            var c = right;
            var d = left.left;
            var e = left.right;
            var f = right.left;
            var g = right.right;
            var balance = c.height - b.height;
            // Rotate c node up
            if (balance > 1) {
                // Swap the right node with it's parent
                c.left = a;
                c.parent = a.parent;
                a.parent = c;
                // The original node's old parent should point to the right node
                // this is mega confusing
                if (c.parent) {
                    if (c.parent.left === a) {
                        c.parent.left = c;
                    }
                    else {
                        c.parent.right = c;
                    }
                }
                else {
                    this.root = c;
                }
                // Rotate
                if (f.height > g.height) {
                    c.right = f;
                    a.right = g;
                    g.parent = a;
                    a.bounds = b.bounds.combine(g.bounds);
                    c.bounds = a.bounds.combine(f.bounds);
                    a.height = 1 + Math.max(b.height, g.height);
                    c.height = 1 + Math.max(a.height, f.height);
                }
                else {
                    c.right = g;
                    a.right = f;
                    f.parent = a;
                    a.bounds = b.bounds.combine(f.bounds);
                    c.bounds = a.bounds.combine(g.bounds);
                    a.height = 1 + Math.max(b.height, f.height);
                    c.height = 1 + Math.max(a.height, g.height);
                }
                return c;
            }
            // Rotate left node up
            if (balance < -1) {
                // swap
                b.left = a;
                b.parent = a.parent;
                a.parent = b;
                // node's old parent should point to b
                if (b.parent) {
                    if (b.parent.left === a) {
                        b.parent.left = b;
                    }
                    else {
                        if (b.parent.right !== a) {
                            throw 'Error rotating Dynamic Tree';
                        }
                        b.parent.right = b;
                    }
                }
                else {
                    this.root = b;
                }
                // rotate
                if (d.height > e.height) {
                    b.right = d;
                    a.left = e;
                    e.parent = a;
                    a.bounds = c.bounds.combine(e.bounds);
                    b.bounds = a.bounds.combine(d.bounds);
                    a.height = 1 + Math.max(c.height, e.height);
                    b.height = 1 + Math.max(a.height, d.height);
                }
                else {
                    b.right = e;
                    a.left = d;
                    d.parent = a;
                    a.bounds = c.bounds.combine(d.bounds);
                    b.bounds = a.bounds.combine(e.bounds);
                    a.height = 1 + Math.max(c.height, d.height);
                    b.height = 1 + Math.max(a.height, e.height);
                }
                return b;
            }
            return node;
        };
        /**
         * Returns the internal height of the tree, shorter trees are better. Performance drops as the tree grows
         */
        DynamicTree.prototype.getHeight = function () {
            if (this.root === null) {
                return 0;
            }
            return this.root.height;
        };
        /**
         * Queries the Dynamic Axis Aligned Tree for bodies that could be colliding with the provided body.
         *
         * In the query callback, it will be passed a potential collider. Returning true from this callback indicates
         * that you are complete with your query and you do not want to continue. Returning false will continue searching
         * the tree until all possible colliders have been returned.
         */
        DynamicTree.prototype.query = function (body, callback) {
            var bounds = body.getBounds();
            var helper = function (currentNode) {
                if (currentNode && currentNode.bounds.collides(bounds)) {
                    if (currentNode.isLeaf() && currentNode.body !== body) {
                        if (callback.call(body, currentNode.body)) {
                            return true;
                        }
                    }
                    else {
                        return helper(currentNode.left) || helper(currentNode.right);
                    }
                }
                return false;
            };
            helper(this.root);
        };
        /**
         * Queries the Dynamic Axis Aligned Tree for bodies that could be intersecting. By default the raycast query uses an infinitely
         * long ray to test the tree specified by `max`.
         *
         * In the query callback, it will be passed a potential body that intersects with the racast. Returning true from this
         * callback indicates that your are complete with your query and do not want to continue. Return false will continue searching
         * the tree until all possible bodies that would intersect with the ray have been returned.
         */
        DynamicTree.prototype.rayCastQuery = function (ray, max, callback) {
            if (max === void 0) { max = Infinity; }
            var helper = function (currentNode) {
                if (currentNode && currentNode.bounds.rayCast(ray, max)) {
                    if (currentNode.isLeaf()) {
                        if (callback.call(ray, currentNode.body)) {
                            // ray hit a leaf! return the body
                            return true;
                        }
                    }
                    else {
                        // ray hit but not at a leaf, recurse deeper
                        return helper(currentNode.left) || helper(currentNode.right);
                    }
                }
                return false; // ray missed         
            };
            helper(this.root);
        };
        DynamicTree.prototype.getNodes = function () {
            var helper = function (currentNode) {
                if (currentNode) {
                    return [currentNode].concat(helper(currentNode.left), helper(currentNode.right));
                }
                else {
                    return [];
                }
            };
            return helper(this.root);
        };
        DynamicTree.prototype.debugDraw = function (ctx) {
            // draw all the nodes in the Dynamic Tree
            var helper = function (currentNode) {
                if (currentNode) {
                    if (currentNode.isLeaf()) {
                        ctx.lineWidth = 1;
                        ctx.strokeStyle = 'green';
                    }
                    else {
                        ctx.lineWidth = 1;
                        ctx.strokeStyle = 'white';
                    }
                    currentNode.bounds.debugDraw(ctx);
                    if (currentNode.left) {
                        helper(currentNode.left);
                    }
                    if (currentNode.right) {
                        helper(currentNode.right);
                    }
                }
            };
            helper(this.root);
        };
        return DynamicTree;
    }());
    exports.DynamicTree = DynamicTree;
});
define("Collision/ICollisionResolver", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Collision/DynamicTreeCollisionBroadphase", ["require", "exports", "Physics", "Collision/DynamicTree", "Collision/Pair", "Algebra", "Actor", "Util/Log", "Events"], function (require, exports, Physics_9, DynamicTree_1, Pair_2, Algebra_18, Actor_9, Log_9, Events_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DynamicTreeCollisionBroadphase = (function () {
        function DynamicTreeCollisionBroadphase() {
            this._dynamicCollisionTree = new DynamicTree_1.DynamicTree();
            this._collisionHash = {};
            this._collisionPairCache = [];
            this._lastFramePairs = [];
            this._lastFramePairsHash = {};
        }
        /**
         * Tracks a physics body for collisions
         */
        DynamicTreeCollisionBroadphase.prototype.track = function (target) {
            if (!target) {
                Log_9.Logger.getInstance().warn('Cannot track null physics body');
                return;
            }
            this._dynamicCollisionTree.trackBody(target);
        };
        /**
         * Untracks a physics body
         */
        DynamicTreeCollisionBroadphase.prototype.untrack = function (target) {
            if (!target) {
                Log_9.Logger.getInstance().warn('Cannot untrack a null physics body');
                return;
            }
            this._dynamicCollisionTree.untrackBody(target);
        };
        DynamicTreeCollisionBroadphase.prototype._canCollide = function (actorA, actorB) {
            // if the collision pair has been calculated already short circuit
            var hash = Pair_2.Pair.calculatePairHash(actorA.body, actorB.body);
            if (this._collisionHash[hash]) {
                return false; // pair exists easy exit return false
            }
            // if both are fixed short circuit
            if (actorA.collisionType === Actor_9.CollisionType.Fixed && actorB.collisionType === Actor_9.CollisionType.Fixed) {
                return false;
            }
            // if the other is prevent collision or is dead short circuit
            if (actorB.collisionType === Actor_9.CollisionType.PreventCollision || actorB.isKilled()) {
                return false;
            }
            // they can collide
            return true;
        };
        /**
         * Detects potential collision pairs in a broadphase approach with the dynamic aabb tree strategy
         */
        DynamicTreeCollisionBroadphase.prototype.broadphase = function (targets, delta, stats) {
            var _this = this;
            var seconds = delta / 1000;
            // TODO optimization use only the actors that are moving to start 
            // Retrieve the list of potential colliders, exclude killed, prevented, and self
            var potentialColliders = targets.filter(function (other) {
                return !other.isKilled() && other.collisionType !== Actor_9.CollisionType.PreventCollision;
            });
            // clear old list of collision pairs
            this._collisionPairCache = [];
            this._collisionHash = {};
            // check for normal collision pairs
            var actor;
            for (var j = 0, l = potentialColliders.length; j < l; j++) {
                actor = potentialColliders[j];
                // Query the collision tree for potential colliders
                this._dynamicCollisionTree.query(actor.body, function (other) {
                    if (_this._canCollide(actor, other.actor)) {
                        var pair = new Pair_2.Pair(actor.body, other);
                        _this._collisionHash[pair.id] = true;
                        _this._collisionPairCache.push(pair);
                    }
                    // Always return false, to query whole tree. Returning true in the query method stops searching
                    return false;
                });
            }
            if (stats) {
                stats.physics.pairs = this._collisionPairCache.length;
            }
            // Check dynamic tree for fast moving objects
            // Fast moving objects are those moving at least there smallest bound per frame
            if (Physics_9.Physics.checkForFastBodies) {
                for (var _i = 0, potentialColliders_1 = potentialColliders; _i < potentialColliders_1.length; _i++) {
                    var actor = potentialColliders_1[_i];
                    // Skip non-active objects. Does not make sense on other collison types
                    if (actor.collisionType !== Actor_9.CollisionType.Active) {
                        continue;
                    }
                    ;
                    // Maximum travel distance next frame
                    var updateDistance = (actor.vel.magnitude() * seconds) +
                        (actor.acc.magnitude() * .5 * seconds * seconds); // acc term
                    // Find the minimum dimension
                    var minDimension = Math.min(actor.body.getBounds().getHeight(), actor.body.getBounds().getWidth());
                    if (Physics_9.Physics.disableMinimumSpeedForFastBody || updateDistance > (minDimension / 2)) {
                        if (stats) {
                            stats.physics.fastBodies++;
                        }
                        // start with the oldPos because the integration for actors has already happened
                        // objects resting on a surface may be slightly penatrating in the current position
                        var updateVec = actor.pos.sub(actor.oldPos);
                        var centerPoint = actor.body.collisionArea.getCenter();
                        var furthestPoint = actor.body.collisionArea.getFurthestPoint(actor.vel);
                        var origin = furthestPoint.sub(updateVec);
                        var ray = new Algebra_18.Ray(origin, actor.vel);
                        // back the ray up by -2x surfaceEpsilon to account for fast moving objects starting on the surface 
                        ray.pos = ray.pos.add(ray.dir.scale(-2 * Physics_9.Physics.surfaceEpsilon));
                        var minBody;
                        var minTranslate = new Algebra_18.Vector(Infinity, Infinity);
                        this._dynamicCollisionTree.rayCastQuery(ray, updateDistance + Physics_9.Physics.surfaceEpsilon * 2, function (other) {
                            if (actor.body !== other && other.collisionArea) {
                                var hitPoint = other.collisionArea.rayCast(ray, updateDistance + Physics_9.Physics.surfaceEpsilon * 10);
                                if (hitPoint) {
                                    var translate = hitPoint.sub(origin);
                                    if (translate.magnitude() < minTranslate.magnitude()) {
                                        minTranslate = translate;
                                        minBody = other;
                                    }
                                }
                            }
                            return false;
                        });
                        if (minBody && Algebra_18.Vector.isValid(minTranslate)) {
                            var pair = new Pair_2.Pair(actor.body, minBody);
                            if (!this._collisionHash[pair.id]) {
                                this._collisionHash[pair.id] = true;
                                this._collisionPairCache.push(pair);
                            }
                            // move the fast moving object to the other body
                            // need to push into the surface by ex.Physics.surfaceEpsilon
                            var shift = centerPoint.sub(furthestPoint);
                            actor.pos = origin.add(shift).add(minTranslate).add(ray.dir.scale(2 * Physics_9.Physics.surfaceEpsilon));
                            actor.body.collisionArea.recalc();
                            if (stats) {
                                stats.physics.fastBodyCollisions++;
                            }
                        }
                    }
                }
            }
            // return cache
            return this._collisionPairCache;
        };
        /**
         * Applies narrow phase on collision pairs to find actual area intersections
         * Adds actual colliding pairs to stats' Frame data
         */
        DynamicTreeCollisionBroadphase.prototype.narrowphase = function (pairs, stats) {
            for (var i = 0; i < pairs.length; i++) {
                pairs[i].collide();
                if (stats && pairs[i].collision) {
                    stats.physics.collisions++;
                    stats.physics.collidersHash[pairs[i].id] = pairs[i];
                }
            }
            return pairs.filter(function (p) { return p.collision; });
        };
        /**
         * Perform collision resolution given a strategy (rigid body or box) and move objects out of intersect.
         */
        DynamicTreeCollisionBroadphase.prototype.resolve = function (pairs, delta, strategy) {
            for (var _i = 0, pairs_1 = pairs; _i < pairs_1.length; _i++) {
                var pair = pairs_1[_i];
                pair.resolve(strategy);
                if (pair.collision) {
                    pair.bodyA.applyMtv();
                    pair.bodyB.applyMtv();
                    // todo still don't like this, this is a small integration step to resolve narrowphase collisions
                    pair.bodyA.actor.integrate(delta * Physics_9.Physics.collisionShift);
                    pair.bodyB.actor.integrate(delta * Physics_9.Physics.collisionShift);
                }
            }
            return pairs.filter(function (p) { return p.canCollide; });
        };
        DynamicTreeCollisionBroadphase.prototype.runCollisionStartEnd = function (pairs) {
            var currentFrameHash = {};
            for (var _i = 0, pairs_2 = pairs; _i < pairs_2.length; _i++) {
                var p = pairs_2[_i];
                // load currentFrameHash
                currentFrameHash[p.id] = p;
                // find all new collisions
                if (!this._lastFramePairsHash[p.id]) {
                    var actor1 = p.bodyA.actor;
                    var actor2 = p.bodyB.actor;
                    actor1.emit('collisionstart', new Events_6.CollisionStartEvent(actor1, actor2, p));
                    actor2.emit('collisionstart', new Events_6.CollisionStartEvent(actor2, actor1, p));
                }
            }
            // find all old collisions
            for (var _a = 0, _b = this._lastFramePairs; _a < _b.length; _a++) {
                var p = _b[_a];
                if (!currentFrameHash[p.id]) {
                    var actor1 = p.bodyA.actor;
                    var actor2 = p.bodyB.actor;
                    actor1.emit('collisionend', new Events_6.CollisionEndEvent(actor1, actor2));
                    actor2.emit('collisionend', new Events_6.CollisionEndEvent(actor2, actor1));
                }
            }
            // reset the last frame cache
            this._lastFramePairs = pairs;
            this._lastFramePairsHash = currentFrameHash;
        };
        /**
         * Update the dynamic tree positions
         */
        DynamicTreeCollisionBroadphase.prototype.update = function (targets) {
            var updated = 0, i = 0, len = targets.length;
            for (i; i < len; i++) {
                if (this._dynamicCollisionTree.updateBody(targets[i].body)) {
                    updated++;
                }
            }
            return updated;
        };
        /* istanbul ignore next */
        DynamicTreeCollisionBroadphase.prototype.debugDraw = function (ctx) {
            if (Physics_9.Physics.broadphaseDebug) {
                this._dynamicCollisionTree.debugDraw(ctx);
            }
            if (Physics_9.Physics.showContacts || Physics_9.Physics.showCollisionNormals) {
                for (var _i = 0, _a = this._collisionPairCache; _i < _a.length; _i++) {
                    var pair = _a[_i];
                    pair.debugDraw(ctx);
                }
            }
        };
        return DynamicTreeCollisionBroadphase;
    }());
    exports.DynamicTreeCollisionBroadphase = DynamicTreeCollisionBroadphase;
});
define("Collision/IPhysics", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Collision/NaiveCollisionBroadphase", ["require", "exports", "Physics", "Collision/CollisionContact", "Collision/Pair", "Actor", "Events"], function (require, exports, Physics_10, CollisionContact_2, Pair_3, Actor_10, Events_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var NaiveCollisionBroadphase = (function () {
        function NaiveCollisionBroadphase() {
            this._lastFramePairs = [];
            this._lastFramePairsHash = {};
        }
        NaiveCollisionBroadphase.prototype.track = function () {
            // pass
        };
        NaiveCollisionBroadphase.prototype.untrack = function () {
            // pass
        };
        /**
         * Detects potential collision pairs in a broadphase approach with the dynamic aabb tree strategy
         */
        NaiveCollisionBroadphase.prototype.broadphase = function (targets) {
            // Retrieve the list of potential colliders, exclude killed, prevented, and self
            var potentialColliders = targets.filter(function (other) {
                return !other.isKilled() && other.collisionType !== Actor_10.CollisionType.PreventCollision;
            });
            var actor1;
            var actor2;
            var collisionPairs = [];
            for (var j = 0, l = potentialColliders.length; j < l; j++) {
                actor1 = potentialColliders[j];
                for (var i = j + 1; i < l; i++) {
                    actor2 = potentialColliders[i];
                    var minimumTranslationVector;
                    if (minimumTranslationVector = actor1.collides(actor2)) {
                        var pair = new Pair_3.Pair(actor1.body, actor2.body);
                        pair.collision = new CollisionContact_2.CollisionContact(actor1.collisionArea, actor2.collisionArea, minimumTranslationVector, actor1.pos, minimumTranslationVector);
                        if (!collisionPairs.some(function (cp) {
                            return cp.id === pair.id;
                        })) {
                            collisionPairs.push(pair);
                        }
                    }
                }
            }
            return collisionPairs;
        };
        /**
         * Identify actual collisions from those pairs, and calculate collision impulse
         */
        NaiveCollisionBroadphase.prototype.narrowphase = function (pairs) {
            return pairs;
        };
        NaiveCollisionBroadphase.prototype.runCollisionStartEnd = function (pairs) {
            var currentFrameHash = {};
            for (var _i = 0, pairs_3 = pairs; _i < pairs_3.length; _i++) {
                var p = pairs_3[_i];
                // load currentFrameHash
                currentFrameHash[p.id] = p;
                // find all new collisions
                if (!this._lastFramePairsHash[p.id]) {
                    var actor1 = p.bodyA.actor;
                    var actor2 = p.bodyB.actor;
                    actor1.emit('collisionstart', new Events_7.CollisionStartEvent(actor1, actor2, p));
                    actor2.emit('collisionstart', new Events_7.CollisionStartEvent(actor2, actor1, p));
                }
            }
            // find all old collisions
            for (var _a = 0, _b = this._lastFramePairs; _a < _b.length; _a++) {
                var p = _b[_a];
                if (!currentFrameHash[p.id]) {
                    var actor1 = p.bodyA.actor;
                    var actor2 = p.bodyB.actor;
                    actor1.emit('collisionend', new Events_7.CollisionEndEvent(actor1, actor2));
                    actor2.emit('collisionend', new Events_7.CollisionEndEvent(actor2, actor1));
                }
            }
            // reset the last frame cache
            this._lastFramePairs = pairs;
            this._lastFramePairsHash = currentFrameHash;
        };
        /**
         * Resolve the position and velocity of the physics bodies
         */
        NaiveCollisionBroadphase.prototype.resolve = function (pairs) {
            for (var _i = 0, pairs_4 = pairs; _i < pairs_4.length; _i++) {
                var pair = pairs_4[_i];
                pair.resolve(Physics_10.Physics.collisionResolutionStrategy);
            }
            return pairs.filter(function (p) { return p.canCollide; });
        };
        NaiveCollisionBroadphase.prototype.update = function () {
            return 0;
        };
        NaiveCollisionBroadphase.prototype.debugDraw = function () {
            return;
        };
        return NaiveCollisionBroadphase;
    }());
    exports.NaiveCollisionBroadphase = NaiveCollisionBroadphase;
});
define("Collision/Index", ["require", "exports", "Collision/Body", "Collision/BoundingBox", "Collision/CircleArea", "Collision/CollisionContact", "Collision/CollisionJumpTable", "Collision/DynamicTree", "Collision/DynamicTreeCollisionBroadphase", "Collision/EdgeArea", "Collision/NaiveCollisionBroadphase", "Collision/Pair", "Collision/PolygonArea", "Collision/Side"], function (require, exports, Body_1, BoundingBox_6, CircleArea_4, CollisionContact_3, CollisionJumpTable_4, DynamicTree_2, DynamicTreeCollisionBroadphase_1, EdgeArea_4, NaiveCollisionBroadphase_1, Pair_4, PolygonArea_6, Side_3) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(Body_1);
    __export(BoundingBox_6);
    __export(CircleArea_4);
    __export(CollisionContact_3);
    __export(CollisionJumpTable_4);
    __export(DynamicTree_2);
    __export(DynamicTreeCollisionBroadphase_1);
    __export(EdgeArea_4);
    __export(NaiveCollisionBroadphase_1);
    __export(Pair_4);
    __export(PolygonArea_6);
    __export(Side_3);
});
define("Drawing/Polygon", ["require", "exports", "Algebra"], function (require, exports, Algebra_19) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Creates a closed polygon drawing given a list of [[Vector]]s.
     *
     * @warning Use sparingly as Polygons are performance intensive
     */
    var Polygon = (function () {
        /**
         * @param points  The vectors to use to build the polygon in order
         */
        function Polygon(points) {
            /**
             * The width of the lines of the polygon
             */
            this.lineWidth = 5;
            /**
             * Indicates whether the polygon is filled or not.
             */
            this.filled = false;
            this._points = [];
            this.anchor = new Algebra_19.Vector(0, 0);
            this.rotation = 0;
            this.scale = new Algebra_19.Vector(1, 1);
            this._points = points;
            var minX = this._points.reduce(function (prev, curr) {
                return Math.min(prev, curr.x);
            }, 0);
            var maxX = this._points.reduce(function (prev, curr) {
                return Math.max(prev, curr.x);
            }, 0);
            this.width = maxX - minX;
            var minY = this._points.reduce(function (prev, curr) {
                return Math.min(prev, curr.y);
            }, 0);
            var maxY = this._points.reduce(function (prev, curr) {
                return Math.max(prev, curr.y);
            }, 0);
            this.height = maxY - minY;
            this.naturalHeight = this.height;
            this.naturalWidth = this.width;
        }
        /**
         * @notimplemented Effects are not supported on `Polygon`
         */
        Polygon.prototype.addEffect = function () {
            // not supported on polygons
        };
        /**
         * @notimplemented Effects are not supported on `Polygon`
         */
        Polygon.prototype.removeEffect = function () {
            // not supported on polygons
        };
        /**
         * @notimplemented Effects are not supported on `Polygon`
         */
        Polygon.prototype.clearEffects = function () {
            // not supported on polygons
        };
        Polygon.prototype.reset = function () {
            //pass
        };
        Polygon.prototype.draw = function (ctx, x, y) {
            ctx.save();
            ctx.translate(x + this.anchor.x, y + this.anchor.y);
            ctx.scale(this.scale.x, this.scale.y);
            ctx.rotate(this.rotation);
            ctx.beginPath();
            ctx.lineWidth = this.lineWidth;
            // Iterate through the supplied points and construct a 'polygon'
            var firstPoint = this._points[0];
            ctx.moveTo(firstPoint.x, firstPoint.y);
            var i = 0, len = this._points.length;
            for (i; i < len; i++) {
                ctx.lineTo(this._points[i].x, this._points[i].y);
            }
            ctx.lineTo(firstPoint.x, firstPoint.y);
            ctx.closePath();
            if (this.filled) {
                ctx.fillStyle = this.fillColor.toString();
                ctx.fill();
            }
            ctx.strokeStyle = this.lineColor.toString();
            if (this.flipHorizontal) {
                ctx.translate(this.width, 0);
                ctx.scale(-1, 1);
            }
            if (this.flipVertical) {
                ctx.translate(0, this.height);
                ctx.scale(1, -1);
            }
            ctx.stroke();
            ctx.restore();
        };
        return Polygon;
    }());
    exports.Polygon = Polygon;
});
define("Drawing/Index", ["require", "exports", "Drawing/Animation", "Drawing/Color", "Drawing/Polygon", "Drawing/Sprite", "Drawing/SpriteSheet", "Drawing/SpriteEffects"], function (require, exports, Animation_2, Color_17, Polygon_1, Sprite_3, SpriteSheet_1, effects) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Animation = Animation_2.Animation;
    __export(Color_17);
    __export(Polygon_1);
    exports.Sprite = Sprite_3.Sprite;
    exports.SpriteSheet = SpriteSheet_1.SpriteSheet;
    exports.SpriteFont = SpriteSheet_1.SpriteFont;
    exports.Effects = effects;
});
define("Interfaces/Index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Math/PerlinNoise", ["require", "exports", "Math/Random", "Drawing/Color", "Util/Util"], function (require, exports, Random_3, Color_18, Util) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _lerp(time, a, b) {
        return a + time * (b - a);
    }
    function _fade(t) {
        return t * t * t * (t * (t * 6 - 15) + 10);
    }
    /**
     * Generates perlin noise based on the 2002 Siggraph paper http://mrl.nyu.edu/~perlin/noise/
     * Also https://flafla2.github.io/2014/08/09/perlinnoise.html
     */
    var PerlinGenerator = (function () {
        function PerlinGenerator(options) {
            this._perm = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225,
                140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26,
                197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136,
                171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60,
                211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80,
                73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198,
                173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206,
                59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70,
                221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178,
                185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81,
                51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115,
                121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195,
                78, 66, 215, 61, 156, 180];
            this._p = new Uint8Array(512);
            this._defaultPerlinOptions = {
                octaves: 1,
                frequency: 1,
                amplitude: 1,
                persistance: .5
            };
            options = Util.extend({}, this._defaultPerlinOptions, options);
            this.persistance = options.persistance;
            this.amplitude = options.amplitude;
            this.frequency = options.frequency;
            this.octaves = options.octaves;
            if (options.seed) {
                this._random = new Random_3.Random(options.seed);
            }
            else {
                this._random = new Random_3.Random();
            }
            this._perm = this._random.shuffle(this._perm);
            for (var i = 0; i < 512; i++) {
                this._p[i] = this._perm[i % 256] & 0xFF;
            }
        }
        PerlinGenerator.prototype.noise = function () {
            var amp = this.amplitude;
            var freq = this.frequency;
            var total = 0;
            var maxValue = 0;
            for (var i = 0; i < this.octaves; i++) {
                switch (arguments.length) {
                    case 1:
                        total += this._noise1d(arguments[0] * freq) * amp;
                        break;
                    case 2:
                        total += this._noise2d(arguments[0] * freq, arguments[1] * freq) * amp;
                        break;
                    case 3:
                        total += this._noise3d(arguments[0] * freq, arguments[1] * freq, arguments[2] * freq) * amp;
                        break;
                    /* istanbul ignore next */
                    default: throw new Error('Invalid arguments for perlin noise');
                }
                maxValue += amp;
                amp *= this.persistance;
                freq *= 2;
            }
            return total / maxValue;
        };
        /**
         * Generates a list starting at 0 and ending at 1 of contious perlin noise, by default the step is 1/length;
         *
         */
        PerlinGenerator.prototype.sequence = function (length, step) {
            if (!step) {
                step = 1 / length;
            }
            var array = new Array(length);
            for (var i = 0; i < length; i++) {
                array[i] = this.noise(i * step);
            }
            return array;
        };
        /**
         * Generates a 2D grid of perlin noise given a step value packed into a 1D array i = (x + y*width),
         * by default the step will 1/(min(dimension))
         */
        PerlinGenerator.prototype.grid = function (width, height, step) {
            if (!step) {
                step = 1 / (Math.min(width, height));
            }
            var array = new Array(width * height);
            for (var y = 0; y < height; y++) {
                for (var x = 0; x < width; x++) {
                    array[x + y * width] = this.noise(x * step, y * step);
                }
            }
            return array;
        };
        PerlinGenerator.prototype._gradient3d = function (hash, x, y, z) {
            var h = hash & 0xF;
            var u = h < 8 ? x : y;
            var v = h < 4 ? y : ((h === 12 || h === 14) ? x : z);
            return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
        };
        PerlinGenerator.prototype._gradient2d = function (hash, x, y) {
            var value = (hash & 1) === 0 ? x : y;
            return (hash & 2) === 0 ? -value : value;
        };
        PerlinGenerator.prototype._gradient1d = function (hash, x) {
            return (hash & 1) === 0 ? -x : x;
        };
        PerlinGenerator.prototype._noise1d = function (x) {
            var intX = Math.floor(x) & 0xFF; // force 0-255 integers to lookup in permutation
            x -= Math.floor(x);
            var fadeX = _fade(x);
            return (_lerp(fadeX, this._gradient1d(this._p[intX], x), this._gradient1d(this._p[intX + 1], x - 1)) + 1) / 2;
        };
        PerlinGenerator.prototype._noise2d = function (x, y) {
            var intX = Math.floor(x) & 0xFF;
            var intY = Math.floor(y) & 0xFF;
            x -= Math.floor(x);
            y -= Math.floor(y);
            var fadeX = _fade(x);
            var fadeY = _fade(y);
            var a = this._p[intX] + intY;
            var b = this._p[intX + 1] + intY;
            return (_lerp(fadeY, _lerp(fadeX, this._gradient2d(this._p[a], x, y), this._gradient2d(this._p[b], x - 1, y)), _lerp(fadeX, this._gradient2d(this._p[a + 1], x, y - 1), this._gradient2d(this._p[b + 1], x - 1, y - 1))) + 1) / 2;
        };
        PerlinGenerator.prototype._noise3d = function (x, y, z) {
            var intX = Math.floor(x) & 0xFF;
            var intY = Math.floor(y) & 0xFF;
            var intZ = Math.floor(z) & 0xFF;
            x -= Math.floor(x);
            y -= Math.floor(y);
            z -= Math.floor(z);
            var fadeX = _fade(x);
            var fadeY = _fade(y);
            var fadeZ = _fade(z);
            var a = this._p[intX] + intY;
            var b = this._p[intX + 1] + intY;
            var aa = this._p[a] + intZ;
            var ba = this._p[b] + intZ;
            var ab = this._p[a + 1] + intZ;
            var bb = this._p[b + 1] + intZ;
            return (_lerp(fadeZ, _lerp(fadeY, _lerp(fadeX, this._gradient3d(this._p[aa], x, y, z), this._gradient3d(this._p[ba], x - 1, y, z)), _lerp(fadeX, this._gradient3d(this._p[ab], x, y - 1, z), this._gradient3d(this._p[bb], x - 1, y - 1, z))), _lerp(fadeY, _lerp(fadeX, this._gradient3d(this._p[aa + 1], x, y, z - 1), this._gradient3d(this._p[ba + 1], x - 1, y, z - 1)), _lerp(fadeX, this._gradient3d(this._p[ab + 1], x, y - 1, z - 1), this._gradient3d(this._p[bb + 1], x - 1, y - 1, z - 1)))) + 1) / 2;
        };
        return PerlinGenerator;
    }());
    exports.PerlinGenerator = PerlinGenerator;
    /**
     * A helper to draw 2D perlin maps given a perlin generator and a function
     */
    var PerlinDrawer2D = (function () {
        /**
         * @param generator - An existing perlin generator
         * @param colorFcn - A color function that takes a value between [0, 255] derived from the perlin generator, and returns a color
         */
        function PerlinDrawer2D(generator, colorFcn) {
            this.generator = generator;
            this.colorFcn = colorFcn;
            if (!colorFcn) {
                this.colorFcn = function (val) { return val < 125 ? Color_18.Color.Black : Color_18.Color.White; };
            }
        }
        /**
         * Returns an image of 2D perlin noise
         */
        PerlinDrawer2D.prototype.image = function (width, height) {
            var image = document.createElement('img');
            var canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            var ctx = canvas.getContext('2d');
            this.draw(ctx, 0, 0, width, height);
            image.src = canvas.toDataURL();
            return image;
        };
        /**
         * This draws a 2D perlin grid on a canvas context, not recommended to be called every frame due to performance
         */
        PerlinDrawer2D.prototype.draw = function (ctx, x, y, width, height) {
            var grid = this.generator.grid(width, height);
            var imageData = ctx.getImageData(x, y, width, height);
            for (var j = 0; j < height; j++) {
                for (var i = 0; i < width; i++) {
                    var val = grid[i + width * j];
                    var c = Math.floor(val * 255) & 0xff;
                    var pixel = (i + j * imageData.width) * 4;
                    var color = this.colorFcn(c);
                    imageData.data[pixel] = color.r;
                    imageData.data[pixel + 1] = color.g;
                    imageData.data[pixel + 2] = color.b;
                    imageData.data[pixel + 3] = Math.floor(color.a * 255);
                }
            }
            ctx.putImageData(imageData, x, y);
        };
        return PerlinDrawer2D;
    }());
    exports.PerlinDrawer2D = PerlinDrawer2D;
});
define("Math/Index", ["require", "exports", "Math/PerlinNoise", "Math/Random"], function (require, exports, PerlinNoise_1, Random_4) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(PerlinNoise_1);
    __export(Random_4);
});
define("PostProcessing/IPostProcessor", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("PostProcessing/ColorBlindCorrector", ["require", "exports", "Util/Log"], function (require, exports, Log_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ColorBlindness;
    (function (ColorBlindness) {
        ColorBlindness[ColorBlindness["Protanope"] = 0] = "Protanope";
        ColorBlindness[ColorBlindness["Deuteranope"] = 1] = "Deuteranope";
        ColorBlindness[ColorBlindness["Tritanope"] = 2] = "Tritanope";
    })(ColorBlindness = exports.ColorBlindness || (exports.ColorBlindness = {}));
    /**
     * This post processor can correct colors and simulate color blindness.
     * It is possible to use this on every game, but the game's performance
     * will suffer measurably. It's better to use it as a helpful tool while developing your game.
     * Remember, the best practice is to design with color blindness in mind.
     *
     * [[include:ColorBlind.md]]
     */
    var ColorBlindCorrector = (function () {
        function ColorBlindCorrector(engine, simulate, colorMode) {
            if (simulate === void 0) { simulate = false; }
            if (colorMode === void 0) { colorMode = ColorBlindness.Protanope; }
            this.engine = engine;
            this.simulate = simulate;
            this.colorMode = colorMode;
            this._vertexShader = 'attribute vec2 a_position;' +
                'attribute vec2 a_texCoord;' +
                'uniform vec2 u_resolution;' +
                'varying vec2 v_texCoord;' +
                'void main() {' +
                // convert the rectangle from pixels to 0.0 to 1.0
                'vec2 zeroToOne = a_position / u_resolution;' +
                // convert from 0->1 to 0->2
                'vec2 zeroToTwo = zeroToOne * 2.0;' +
                // convert from 0->2 to -1->+1 (clipspace)
                'vec2 clipSpace = zeroToTwo - 1.0;' +
                'gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);' +
                // pass the texCoord to the fragment shader
                // The GPU will interpolate this value between points.
                'v_texCoord = a_texCoord;' +
                '}';
            this._fragmentShader = 'precision mediump float;' +
                // our texture
                'uniform sampler2D u_image;' +
                // the texCoords passed in from the vertex shader.
                'varying vec2 v_texCoord;' +
                // Color blind conversions
                /*'mat3 m[9] =' +
                '{' +
                   'mat3(1.0, 0.0, 0.0,  0.0, 1.0, 0.0,  0.0, 0.0, 1.0  ),' + // normal
                   'mat3(0.567, 0.433, 0.0,  0.558, 0.442, 0.0,  0.0, 0.242, 0.758),' + // protanopia
                   'mat3(0.817, 0.183, 0.0,  0.333, 0.667, 0.0,  0.0, 0.125,0.875),' + // protanomaly
                   'mat3(0.625, 0.375, 0.0,  0.7, 0.3, 0.0,  0.0, 0.3,0.7  ),' + // deuteranopia
                   'mat3(0.8, 0.2, 0.0,  0.258, 0.742, 0.0,  0.0, 0.142,0.858),' + // deuteranomaly
                   'mat3(0.95, 0.05, 0.0,  0.0, 0.433, 0.567,  0.0, 0.475,0.525),' + // tritanopia
                   'mat3(0.967, 0.033, 0.0,  0.0, 0.733, 0.267,  0.0, 0.183,0.817),' + // tritanomaly
                   'mat3(0.299, 0.587, 0.114,  0.299, 0.587, 0.114,  0.299, 0.587,0.114),' + // achromatopsia
                   'mat3(0.618, 0.320, 0.062,  0.163, 0.775, 0.062,  0.163, 0.320,0.516)' +  // achromatomaly
                '};' +*/
                'void main() {' +
                'vec4 o =  texture2D(u_image, v_texCoord);' +
                // RGB to LMS matrix conversion
                'float L = (17.8824 * o.r) + (43.5161 * o.g) + (4.11935 * o.b);' +
                'float M = (3.45565 * o.r) + (27.1554 * o.g) + (3.86714 * o.b);' +
                'float S = (0.0299566 * o.r) + (0.184309 * o.g) + (1.46709 * o.b);' +
                // Simulate color blindness
                '//MODE CODE//' +
                /* Deuteranope for testing
                'float l = 1.0 * L + 0.0 * M + 0.0 * S;' +
                      'float m = 0.494207 * L + 0.0 * M + 1.24827 * S;' +
                      'float s = 0.0 * L + 0.0 * M + 1.0 * S;' +*/
                // LMS to RGB matrix conversion
                'vec4 error;' +
                'error.r = (0.0809444479 * l) + (-0.130504409 * m) + (0.116721066 * s);' +
                'error.g = (-0.0102485335 * l) + (0.0540193266 * m) + (-0.113614708 * s);' +
                'error.b = (-0.000365296938 * l) + (-0.00412161469 * m) + (0.693511405 * s);' +
                'error.a = 1.0;' +
                'vec4 diff = o - error;' +
                'vec4 correction;' +
                'correction.r = 0.0;' +
                'correction.g =  (diff.r * 0.7) + (diff.g * 1.0);' +
                'correction.b =  (diff.r * 0.7) + (diff.b * 1.0);' +
                'correction = o + correction;' +
                'correction.a = o.a;' +
                '//SIMULATE//' +
                '}';
            this._internalCanvas = document.createElement('canvas');
            this._internalCanvas.width = engine.drawWidth;
            this._internalCanvas.height = engine.drawHeight;
            this._gl = this._internalCanvas.getContext('webgl', { preserveDrawingBuffer: true });
            this._program = this._gl.createProgram();
            var fragmentShader = this._getShader('Fragment', this._getFragmentShaderByMode(colorMode));
            var vertextShader = this._getShader('Vertex', this._vertexShader);
            this._gl.attachShader(this._program, vertextShader);
            this._gl.attachShader(this._program, fragmentShader);
            this._gl.linkProgram(this._program);
            if (!this._gl.getProgramParameter(this._program, this._gl.LINK_STATUS)) {
                Log_10.Logger.getInstance().error('Unable to link shader program!');
            }
            this._gl.useProgram(this._program);
        }
        ColorBlindCorrector.prototype._getFragmentShaderByMode = function (colorMode) {
            var code = '';
            if (colorMode === ColorBlindness.Protanope) {
                code =
                    'float l = 0.0 * L + 2.02344 * M + -2.52581 * S;' +
                        'float m = 0.0 * L + 1.0 * M + 0.0 * S;' +
                        'float s = 0.0 * L + 0.0 * M + 1.0 * S;';
            }
            else if (colorMode === ColorBlindness.Deuteranope) {
                code =
                    'float l = 1.0 * L + 0.0 * M + 0.0 * S;' +
                        'float m = 0.494207 * L + 0.0 * M + 1.24827 * S;' +
                        'float s = 0.0 * L + 0.0 * M + 1.0 * S;';
            }
            else if (colorMode === ColorBlindness.Tritanope) {
                code =
                    'float l = 1.0 * L + 0.0 * M + 0.0 * S;' +
                        'float m = 0.0 * L + 1.0 * M + 0.0 * S;' +
                        'float s = -0.395913 * L + 0.801109 * M + 0.0 * S;';
            }
            if (this.simulate) {
                this._fragmentShader = this._fragmentShader.replace('//SIMULATE//', 'gl_FragColor = error.rgba;');
            }
            else {
                this._fragmentShader = this._fragmentShader.replace('//SIMULATE//', 'gl_FragColor = correction.rgba;');
            }
            return this._fragmentShader.replace('//MODE CODE//', code);
        };
        ColorBlindCorrector.prototype._setRectangle = function (x, y, width, height) {
            var x1 = x;
            var x2 = x + width;
            var y1 = y;
            var y2 = y + height;
            this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array([
                x1, y1,
                x2, y1,
                x1, y2,
                x1, y2,
                x2, y1,
                x2, y2
            ]), this._gl.STATIC_DRAW);
        };
        ColorBlindCorrector.prototype._getShader = function (type, program) {
            var shader;
            if (type === 'Fragment') {
                shader = this._gl.createShader(this._gl.FRAGMENT_SHADER);
            }
            else if (type === 'Vertex') {
                shader = this._gl.createShader(this._gl.VERTEX_SHADER);
            }
            else {
                Log_10.Logger.getInstance().error('Error unknown shader type', type);
            }
            this._gl.shaderSource(shader, program);
            this._gl.compileShader(shader);
            if (!this._gl.getShaderParameter(shader, this._gl.COMPILE_STATUS)) {
                Log_10.Logger.getInstance().error('Unable to compile shader!', this._gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        };
        ColorBlindCorrector.prototype.process = function (image, out) {
            // look up where the vertex data needs to go.
            var positionLocation = this._gl.getAttribLocation(this._program, 'a_position');
            var texCoordLocation = this._gl.getAttribLocation(this._program, 'a_texCoord');
            var texCoordBuffer = this._gl.createBuffer();
            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, texCoordBuffer);
            this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array([
                0.0, 0.0,
                1.0, 0.0,
                0.0, 1.0,
                0.0, 1.0,
                1.0, 0.0,
                1.0, 1.0
            ]), this._gl.STATIC_DRAW);
            this._gl.enableVertexAttribArray(texCoordLocation);
            this._gl.vertexAttribPointer(texCoordLocation, 2, this._gl.FLOAT, false, 0, 0);
            // Create a texture.
            var texture = this._gl.createTexture();
            this._gl.bindTexture(this._gl.TEXTURE_2D, texture);
            // Set the parameters so we can render any size image.
            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE);
            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);
            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.NEAREST);
            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.NEAREST);
            // Flip the texture when unpacking into the gl context, gl reads textures in the opposite order as everything else :/
            this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, 1);
            // Upload the image into the texture.
            this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, image);
            // lookup uniforms
            var resolutionLocation = this._gl.getUniformLocation(this._program, 'u_resolution');
            // set the resolution
            this._gl.uniform2f(resolutionLocation, this._internalCanvas.width, this._internalCanvas.height);
            // Create a buffer for the position of the rectangle corners.
            var positionBuffer = this._gl.createBuffer();
            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, positionBuffer);
            this._gl.enableVertexAttribArray(positionLocation);
            this._gl.vertexAttribPointer(positionLocation, 2, this._gl.FLOAT, false, 0, 0);
            // Set a rectangle the same size as the image.
            this._setRectangle(0, 0, image.width, image.height);
            // Draw the rectangle.
            this._gl.drawArrays(this._gl.TRIANGLES, 0, 6);
            // Grab tranformed image from internal canvas
            var pixelData = new Uint8Array(image.width * image.height * 4);
            this._gl.readPixels(0, 0, image.width, image.height, this._gl.RGBA, this._gl.UNSIGNED_BYTE, pixelData);
            image.data.set(pixelData);
            out.putImageData(image, 0, 0);
        };
        return ColorBlindCorrector;
    }());
    exports.ColorBlindCorrector = ColorBlindCorrector;
});
define("PostProcessing/Index", ["require", "exports", "PostProcessing/ColorBlindCorrector"], function (require, exports, ColorBlindCorrector_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(ColorBlindCorrector_1);
});
define("Resources/Index", ["require", "exports", "Resources/Resource", "Resources/Sound", "Resources/Texture"], function (require, exports, Resource_2, Sound_2, Texture_3) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(Resource_2);
    __export(Sound_2);
    __export(Texture_3);
});
define("Input/Gamepad", ["require", "exports", "Class", "Events"], function (require, exports, Class_5, Events_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Excalibur leverages the HTML5 Gamepad API [where it is supported](http://caniuse.com/#feat=gamepad)
     * to provide controller support for your games.
     *
     * [[include:Gamepads.md]]
     */
    var Gamepads = (function (_super) {
        __extends(Gamepads, _super);
        function Gamepads() {
            var _this = _super.call(this) || this;
            /**
             * Whether or not to poll for Gamepad input (default: `false`)
             */
            _this.enabled = false;
            /**
             * Whether or not Gamepad API is supported
             */
            _this.supported = !!navigator.getGamepads;
            _this._gamePadTimeStamps = [0, 0, 0, 0];
            _this._oldPads = [];
            _this._pads = [];
            _this._initSuccess = false;
            _this._navigator = navigator;
            _this._minimumConfiguration = null;
            return _this;
        }
        Gamepads.prototype.init = function () {
            if (!this.supported) {
                return;
            }
            if (this._initSuccess) {
                return;
            }
            // In Chrome, this will return 4 undefined items until a button is pressed
            // In FF, this will not return any items until a button is pressed
            this._oldPads = this._clonePads(this._navigator.getGamepads());
            if (this._oldPads.length && this._oldPads[0]) {
                this._initSuccess = true;
            }
        };
        /**
         * Sets the minimum gamepad configuration, for example {axis: 4, buttons: 4} means
         * this game requires at minimum 4 axis inputs and 4 buttons, this is not restrictive
         * all other controllers with more axis or buttons are valid as well. If no minimum
         * configuration is set all pads are valid.
         */
        Gamepads.prototype.setMinimumGamepadConfiguration = function (config) {
            this._enableAndUpdate(); // if config is used, implicitly enable
            this._minimumConfiguration = config;
        };
        /**
         * When implicitly enabled, set the enabled flag and run an update so information is updated
         */
        Gamepads.prototype._enableAndUpdate = function () {
            if (!this.enabled) {
                this.enabled = true;
                this.update();
            }
        };
        /**
         * Checks a navigator gamepad against the minimum configuration if present.
         */
        Gamepads.prototype._isGamepadValid = function (pad) {
            if (!this._minimumConfiguration) {
                return true;
            }
            ;
            if (!pad) {
                return false;
            }
            ;
            var axesLength = pad.axes.filter(function (value) {
                return (typeof value !== undefined);
            }).length;
            var buttonLength = pad.buttons.filter(function (value) {
                return (typeof value !== undefined);
            }).length;
            return axesLength >= this._minimumConfiguration.axis &&
                buttonLength >= this._minimumConfiguration.buttons &&
                pad.connected;
        };
        Gamepads.prototype.on = function (eventName, handler) {
            this._enableAndUpdate(); // implicitly enable
            _super.prototype.on.call(this, eventName, handler);
        };
        Gamepads.prototype.off = function (eventName, handler) {
            this._enableAndUpdate(); // implicitly enable
            _super.prototype.off.call(this, eventName, handler);
        };
        /**
         * Updates Gamepad state and publishes Gamepad events
         */
        Gamepads.prototype.update = function () {
            if (!this.enabled || !this.supported) {
                return;
            }
            this.init();
            var gamepads = this._navigator.getGamepads();
            for (var i = 0; i < gamepads.length; i++) {
                if (!gamepads[i]) {
                    var gamepad = this.at(i);
                    // If was connected, but now isn't emit the disconnect event
                    if (gamepad.connected) {
                        this.eventDispatcher.emit('disconnect', new Events_8.GamepadDisconnectEvent(i, gamepad));
                    }
                    // Reset connection status
                    gamepad.connected = false;
                    continue;
                }
                else {
                    if (!this.at(i).connected && this._isGamepadValid(gamepads[i])) {
                        this.eventDispatcher.emit('connect', new Events_8.GamepadConnectEvent(i, this.at(i)));
                    }
                    // Set connection status
                    this.at(i).connected = true;
                }
                ;
                // Only supported in Chrome
                if (gamepads[i].timestamp && gamepads[i].timestamp === this._gamePadTimeStamps[i]) {
                    continue;
                }
                this._gamePadTimeStamps[i] = gamepads[i].timestamp;
                // Add reference to navigator gamepad
                this.at(i).navigatorGamepad = gamepads[i];
                // Buttons
                var b, bi, a, ai, value;
                for (b in Buttons) {
                    bi = Buttons[b];
                    if (typeof bi === 'number') {
                        if (gamepads[i].buttons[bi]) {
                            value = gamepads[i].buttons[bi].value;
                            if (value !== this._oldPads[i].getButton(bi)) {
                                if (gamepads[i].buttons[bi].pressed) {
                                    this.at(i).updateButton(bi, value);
                                    this.at(i).eventDispatcher.emit('button', new Events_8.GamepadButtonEvent(bi, value, this.at(i)));
                                }
                                else {
                                    this.at(i).updateButton(bi, 0);
                                }
                            }
                        }
                    }
                }
                // Axes
                for (a in Axes) {
                    ai = Axes[a];
                    if (typeof ai === 'number') {
                        value = gamepads[i].axes[ai];
                        if (value !== this._oldPads[i].getAxes(ai)) {
                            this.at(i).updateAxes(ai, value);
                            this.at(i).eventDispatcher.emit('axis', new Events_8.GamepadAxisEvent(ai, value, this.at(i)));
                        }
                    }
                }
                this._oldPads[i] = this._clonePad(gamepads[i]);
            }
        };
        /**
         * Safely retrieves a Gamepad at a specific index and creates one if it doesn't yet exist
         */
        Gamepads.prototype.at = function (index) {
            this._enableAndUpdate(); // implicitly enable gamepads when at() is called         
            if (index >= this._pads.length) {
                // Ensure there is a pad to retrieve
                for (var i = this._pads.length - 1, max = index; i < max; i++) {
                    this._pads.push(new Gamepad());
                    this._oldPads.push(new Gamepad());
                }
            }
            return this._pads[index];
        };
        /**
         * Returns a list of all valid gamepads that meet the minimum configuration requirement.
         */
        Gamepads.prototype.getValidGamepads = function () {
            this._enableAndUpdate();
            var result = [];
            for (var i = 0; i < this._pads.length; i++) {
                if (this._isGamepadValid(this.at(i).navigatorGamepad) && this.at(i).connected) {
                    result.push(this.at(i));
                }
            }
            return result;
        };
        /**
         * Gets the number of connected gamepads
         */
        Gamepads.prototype.count = function () {
            return this._pads.filter(function (p) { return p.connected; }).length;
        };
        Gamepads.prototype._clonePads = function (pads) {
            var arr = [];
            for (var i = 0, len = pads.length; i < len; i++) {
                arr.push(this._clonePad(pads[i]));
            }
            return arr;
        };
        /**
         * Fastest way to clone a known object is to do it yourself
         */
        Gamepads.prototype._clonePad = function (pad) {
            var i, len;
            var clonedPad = new Gamepad();
            if (!pad) {
                return clonedPad;
            }
            for (i = 0, len = pad.buttons.length; i < len; i++) {
                if (pad.buttons[i]) {
                    clonedPad.updateButton(i, pad.buttons[i].value);
                }
            }
            for (i = 0, len = pad.axes.length; i < len; i++) {
                clonedPad.updateAxes(i, pad.axes[i]);
            }
            return clonedPad;
        };
        return Gamepads;
    }(Class_5.Class));
    /**
     * The minimum value an axis has to move before considering it a change
     */
    Gamepads.MinAxisMoveThreshold = 0.05;
    exports.Gamepads = Gamepads;
    /**
     * Gamepad holds state information for a connected controller. See [[Gamepads]]
     * for more information on handling controller input.
     */
    var Gamepad = (function (_super) {
        __extends(Gamepad, _super);
        function Gamepad() {
            var _this = _super.call(this) || this;
            _this.connected = false;
            _this._buttons = new Array(16);
            _this._axes = new Array(4);
            var i;
            for (i = 0; i < _this._buttons.length; i++) {
                _this._buttons[i] = 0;
            }
            for (i = 0; i < _this._axes.length; i++) {
                _this._axes[i] = 0;
            }
            return _this;
        }
        /**
         * Whether or not the given button is pressed
         * @param button     The button to query
         * @param threshold  The threshold over which the button is considered to be pressed
         */
        Gamepad.prototype.isButtonPressed = function (button, threshold) {
            if (threshold === void 0) { threshold = 1; }
            return this._buttons[button] >= threshold;
        };
        /**
         * Gets the given button value between 0 and 1
         */
        Gamepad.prototype.getButton = function (button) {
            return this._buttons[button];
        };
        /**
         * Gets the given axis value between -1 and 1. Values below
         * [[MinAxisMoveThreshold]] are considered 0.
         */
        Gamepad.prototype.getAxes = function (axes) {
            var value = this._axes[axes];
            if (Math.abs(value) < Gamepads.MinAxisMoveThreshold) {
                return 0;
            }
            else {
                return value;
            }
        };
        Gamepad.prototype.updateButton = function (buttonIndex, value) {
            this._buttons[buttonIndex] = value;
        };
        Gamepad.prototype.updateAxes = function (axesIndex, value) {
            this._axes[axesIndex] = value;
        };
        return Gamepad;
    }(Class_5.Class));
    exports.Gamepad = Gamepad;
    /**
     * Gamepad Buttons enumeration
     */
    var Buttons;
    (function (Buttons) {
        /**
         * Face 1 button (e.g. A)
         */
        Buttons[Buttons["Face1"] = 0] = "Face1";
        /**
         * Face 2 button (e.g. B)
         */
        Buttons[Buttons["Face2"] = 1] = "Face2";
        /**
         * Face 3 button (e.g. X)
         */
        Buttons[Buttons["Face3"] = 2] = "Face3";
        /**
         * Face 4 button (e.g. Y)
         */
        Buttons[Buttons["Face4"] = 3] = "Face4";
        /**
         * Left bumper button
         */
        Buttons[Buttons["LeftBumper"] = 4] = "LeftBumper";
        /**
         * Right bumper button
         */
        Buttons[Buttons["RightBumper"] = 5] = "RightBumper";
        /**
         * Left trigger button
         */
        Buttons[Buttons["LeftTrigger"] = 6] = "LeftTrigger";
        /**
         * Right trigger button
         */
        Buttons[Buttons["RightTrigger"] = 7] = "RightTrigger";
        /**
         * Select button
         */
        Buttons[Buttons["Select"] = 8] = "Select";
        /**
         * Start button
         */
        Buttons[Buttons["Start"] = 9] = "Start";
        /**
         * Left analog stick press (e.g. L3)
         */
        Buttons[Buttons["LeftStick"] = 10] = "LeftStick";
        /**
         * Right analog stick press (e.g. R3)
         */
        Buttons[Buttons["RightStick"] = 11] = "RightStick";
        /**
         * D-pad up
         */
        Buttons[Buttons["DpadUp"] = 12] = "DpadUp";
        /**
         * D-pad down
         */
        Buttons[Buttons["DpadDown"] = 13] = "DpadDown";
        /**
         * D-pad left
         */
        Buttons[Buttons["DpadLeft"] = 14] = "DpadLeft";
        /**
         * D-pad right
         */
        Buttons[Buttons["DpadRight"] = 15] = "DpadRight";
    })(Buttons = exports.Buttons || (exports.Buttons = {}));
    /**
     * Gamepad Axes enumeration
     */
    var Axes;
    (function (Axes) {
        /**
         * Left analogue stick X direction
         */
        Axes[Axes["LeftStickX"] = 0] = "LeftStickX";
        /**
         * Left analogue stick Y direction
         */
        Axes[Axes["LeftStickY"] = 1] = "LeftStickY";
        /**
         * Right analogue stick X direction
         */
        Axes[Axes["RightStickX"] = 2] = "RightStickX";
        /**
         * Right analogue stick Y direction
         */
        Axes[Axes["RightStickY"] = 3] = "RightStickY";
    })(Axes = exports.Axes || (exports.Axes = {}));
});
define("Input/Pointer", ["require", "exports", "Engine", "Events", "UIActor", "Algebra", "Class", "Util/Util"], function (require, exports, Engine_2, Events_9, UIActor_1, Algebra_20, Class_6, Util) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The type of pointer for a [[PointerEvent]].
     */
    var PointerType;
    (function (PointerType) {
        PointerType[PointerType["Touch"] = 0] = "Touch";
        PointerType[PointerType["Mouse"] = 1] = "Mouse";
        PointerType[PointerType["Pen"] = 2] = "Pen";
        PointerType[PointerType["Unknown"] = 3] = "Unknown";
    })(PointerType = exports.PointerType || (exports.PointerType = {}));
    /**
     * The mouse button being pressed.
     */
    var PointerButton;
    (function (PointerButton) {
        PointerButton[PointerButton["Left"] = 0] = "Left";
        PointerButton[PointerButton["Middle"] = 1] = "Middle";
        PointerButton[PointerButton["Right"] = 2] = "Right";
        PointerButton[PointerButton["Unknown"] = 3] = "Unknown";
    })(PointerButton = exports.PointerButton || (exports.PointerButton = {}));
    var WheelDeltaMode;
    (function (WheelDeltaMode) {
        WheelDeltaMode[WheelDeltaMode["Pixel"] = 0] = "Pixel";
        WheelDeltaMode[WheelDeltaMode["Line"] = 1] = "Line";
        WheelDeltaMode[WheelDeltaMode["Page"] = 2] = "Page";
    })(WheelDeltaMode = exports.WheelDeltaMode || (exports.WheelDeltaMode = {}));
    /**
     * Determines the scope of handling mouse/touch events. See [[Pointers]] for more information.
     */
    var PointerScope;
    (function (PointerScope) {
        /**
         * Handle events on the `canvas` element only. Events originating outside the
         * `canvas` will not be handled.
         */
        PointerScope[PointerScope["Canvas"] = 0] = "Canvas";
        /**
         * Handles events on the entire document. All events will be handled by Excalibur.
         */
        PointerScope[PointerScope["Document"] = 1] = "Document";
    })(PointerScope = exports.PointerScope || (exports.PointerScope = {}));
    /**
     * A constant used to normalize wheel events across different browsers
     *
     * This normalization factor is pulled from https://developer.mozilla.org/en-US/docs/Web/Events/wheel#Listening_to_this_event_across_browser
     */
    var ScrollWheelNormalizationFactor = -1 / 40;
    /**
     * Pointer events
     *
     * Represents a mouse, touch, or stylus event. See [[Pointers]] for more information on
     * handling pointer input.
     *
     * For mouse-based events, you can inspect [[PointerEvent.button]] to see what button was pressed.
     */
    var PointerEvent = (function (_super) {
        __extends(PointerEvent, _super);
        /**
         * @param pageX        The `x` coordinate of the event (in document coordinates)
         * @param pageY        The `y` coordinate of the event (in document coordinates)
         * @param screenX      The `x` coordinate of the event (in screen coordinates)
         * @param screenY      The `y` coordinate of the event (in screen coordinates)
         * @param index        The index of the pointer (zero-based)
         * @param pointerType  The type of pointer
         * @param button       The button pressed (if [[PointerType.Mouse]])
         * @param ev           The raw DOM event being handled
         * @param pos          (Will be added to signature in 0.14.0 release) The position of the event (in world coordinates)
         */
        function PointerEvent(x, y, pageX, pageY, screenX, screenY, index, pointerType, button, ev) {
            var _this = _super.call(this) || this;
            _this.x = x;
            _this.y = y;
            _this.pageX = pageX;
            _this.pageY = pageY;
            _this.screenX = screenX;
            _this.screenY = screenY;
            _this.index = index;
            _this.pointerType = pointerType;
            _this.button = button;
            _this.ev = ev;
            return _this;
        }
        Object.defineProperty(PointerEvent.prototype, "pos", {
            get: function () {
                return new Algebra_20.Vector(this.x, this.y);
            },
            enumerable: true,
            configurable: true
        });
        return PointerEvent;
    }(Events_9.GameEvent));
    exports.PointerEvent = PointerEvent;
    ;
    /**
     * Wheel Events
     *
     * Represents a mouse wheel event. See [[Pointers]] for more information on
     * handling point input.
     */
    var WheelEvent = (function (_super) {
        __extends(WheelEvent, _super);
        /**
         * @param x            The `x` coordinate of the event (in world coordinates)
         * @param y            The `y` coordinate of the event (in world coordinates)
         * @param pageX        The `x` coordinate of the event (in document coordinates)
         * @param pageY        The `y` coordinate of the event (in document coordinates)
         * @param screenX      The `x` coordinate of the event (in screen coordinates)
         * @param screenY      The `y` coordinate of the event (in screen coordinates)
         * @param index        The index of the pointer (zero-based)
         * @param deltaX       The type of pointer
         * @param deltaY       The type of pointer
         * @param deltaZ       The type of pointer
         * @param deltaMode    The type of movement [[WheelDeltaMode]]
         * @param ev           The raw DOM event being handled
         */
        function WheelEvent(x, y, pageX, pageY, screenX, screenY, index, deltaX, deltaY, deltaZ, deltaMode, ev) {
            var _this = _super.call(this) || this;
            _this.x = x;
            _this.y = y;
            _this.pageX = pageX;
            _this.pageY = pageY;
            _this.screenX = screenX;
            _this.screenY = screenY;
            _this.index = index;
            _this.deltaX = deltaX;
            _this.deltaY = deltaY;
            _this.deltaZ = deltaZ;
            _this.deltaMode = deltaMode;
            _this.ev = ev;
            return _this;
        }
        return WheelEvent;
    }(Events_9.GameEvent));
    exports.WheelEvent = WheelEvent;
    ;
    /**
     * Handles pointer events (mouse, touch, stylus, etc.) and normalizes to
     * [W3C Pointer Events](http://www.w3.org/TR/pointerevents/).
     *
     * [[include:Pointers.md]]
     */
    var Pointers = (function (_super) {
        __extends(Pointers, _super);
        function Pointers(engine) {
            var _this = _super.call(this) || this;
            _this._pointerDown = [];
            _this._pointerUp = [];
            _this._pointerMove = [];
            _this._pointerCancel = [];
            _this._wheel = [];
            _this._pointers = [];
            _this._activePointers = [];
            _this._engine = engine;
            _this._pointers.push(new Pointer());
            _this._activePointers = [-1];
            _this.primary = _this._pointers[0];
            return _this;
        }
        Pointers.prototype.on = function (eventName, handler) {
            _super.prototype.on.call(this, eventName, handler);
        };
        /**
         * Initializes pointer event listeners
         */
        Pointers.prototype.init = function (target) {
            target = target || this._engine.canvas;
            // Touch Events
            target.addEventListener('touchstart', this._handleTouchEvent('down', this._pointerDown));
            target.addEventListener('touchend', this._handleTouchEvent('up', this._pointerUp));
            target.addEventListener('touchmove', this._handleTouchEvent('move', this._pointerMove));
            target.addEventListener('touchcancel', this._handleTouchEvent('cancel', this._pointerCancel));
            // W3C Pointer Events
            // Current: IE11, IE10
            if (window.PointerEvent) {
                // IE11
                this._engine.canvas.style.touchAction = 'none';
                target.addEventListener('pointerdown', this._handlePointerEvent('down', this._pointerDown));
                target.addEventListener('pointerup', this._handlePointerEvent('up', this._pointerUp));
                target.addEventListener('pointermove', this._handlePointerEvent('move', this._pointerMove));
                target.addEventListener('pointercancel', this._handlePointerEvent('cancel', this._pointerMove));
            }
            else if (window.MSPointerEvent) {
                // IE10
                this._engine.canvas.style.msTouchAction = 'none';
                target.addEventListener('MSPointerDown', this._handlePointerEvent('down', this._pointerDown));
                target.addEventListener('MSPointerUp', this._handlePointerEvent('up', this._pointerUp));
                target.addEventListener('MSPointerMove', this._handlePointerEvent('move', this._pointerMove));
                target.addEventListener('MSPointerCancel', this._handlePointerEvent('cancel', this._pointerMove));
            }
            else {
                // Mouse Events
                target.addEventListener('mousedown', this._handleMouseEvent('down', this._pointerDown));
                target.addEventListener('mouseup', this._handleMouseEvent('up', this._pointerUp));
                target.addEventListener('mousemove', this._handleMouseEvent('move', this._pointerMove));
            }
            // MDN MouseWheelEvent
            if ('onwheel' in document.createElement('div')) {
                // Modern Browsers
                target.addEventListener('wheel', this._handleWheelEvent('wheel', this._wheel));
            }
            else if (document.onmousewheel !== undefined) {
                // Webkit and IE
                target.addEventListener('mousewheel', this._handleWheelEvent('wheel', this._wheel));
            }
            else {
                // Remaining browser and older Firefox
                target.addEventListener('MozMousePixelScroll', this._handleWheelEvent('wheel', this._wheel));
            }
        };
        Pointers.prototype.update = function () {
            this._pointerUp.length = 0;
            this._pointerDown.length = 0;
            this._pointerMove.length = 0;
            this._pointerCancel.length = 0;
            this._wheel.length = 0;
        };
        /**
         * Safely gets a Pointer at a specific index and initializes one if it doesn't yet exist
         * @param index  The pointer index to retrieve
         */
        Pointers.prototype.at = function (index) {
            if (index >= this._pointers.length) {
                // Ensure there is a pointer to retrieve
                for (var i = this._pointers.length - 1, max = index; i < max; i++) {
                    this._pointers.push(new Pointer());
                    this._activePointers.push(-1);
                }
            }
            return this._pointers[index];
        };
        /**
         * Get number of pointers being watched
         */
        Pointers.prototype.count = function () {
            return this._pointers.length;
        };
        /**
         * Propogates events to actor if necessary
         */
        Pointers.prototype.propogate = function (actor) {
            var isUIActor = actor instanceof UIActor_1.UIActor;
            var i = 0, len = this._pointerUp.length;
            for (i; i < len; i++) {
                if (actor.contains(this._pointerUp[i].x, this._pointerUp[i].y, !isUIActor)) {
                    actor.eventDispatcher.emit('pointerup', this._pointerUp[i]);
                }
            }
            i = 0;
            len = this._pointerDown.length;
            for (i; i < len; i++) {
                if (actor.contains(this._pointerDown[i].x, this._pointerDown[i].y, !isUIActor)) {
                    actor.eventDispatcher.emit('pointerdown', this._pointerDown[i]);
                }
            }
            if (actor.capturePointer.captureMoveEvents) {
                i = 0;
                len = this._pointerMove.length;
                for (i; i < len; i++) {
                    if (actor.contains(this._pointerMove[i].x, this._pointerMove[i].y, !isUIActor)) {
                        actor.eventDispatcher.emit('pointermove', this._pointerMove[i]);
                    }
                }
            }
            i = 0;
            len = this._pointerCancel.length;
            for (i; i < len; i++) {
                if (actor.contains(this._pointerCancel[i].x, this._pointerCancel[i].y, !isUIActor)) {
                    actor.eventDispatcher.emit('pointercancel', this._pointerCancel[i]);
                }
            }
            i = 0;
            len = this._wheel.length;
            for (i; i < len; i++) {
                if (actor.contains(this._wheel[i].x, this._wheel[i].y, !isUIActor)) {
                    actor.eventDispatcher.emit('pointerwheel', this._wheel[i]);
                }
            }
        };
        Pointers.prototype._handleMouseEvent = function (eventName, eventArr) {
            var _this = this;
            return function (e) {
                e.preventDefault();
                var x = e.pageX - Util.getPosition(_this._engine.canvas).x;
                var y = e.pageY - Util.getPosition(_this._engine.canvas).y;
                var transformedPoint = _this._engine.screenToWorldCoordinates(new Algebra_20.Vector(x, y));
                var pe = new PointerEvent(transformedPoint.x, transformedPoint.y, e.pageX, e.pageY, x, y, 0, PointerType.Mouse, e.button, e);
                eventArr.push(pe);
                _this.at(0).eventDispatcher.emit(eventName, pe);
            };
        };
        Pointers.prototype._handleTouchEvent = function (eventName, eventArr) {
            var _this = this;
            return function (e) {
                e.preventDefault();
                for (var i = 0, len = e.changedTouches.length; i < len; i++) {
                    var index = _this._pointers.length > 1 ? _this._getPointerIndex(e.changedTouches[i].identifier) : 0;
                    if (index === -1) {
                        continue;
                    }
                    var x = e.changedTouches[i].pageX - Util.getPosition(_this._engine.canvas).x;
                    var y = e.changedTouches[i].pageY - Util.getPosition(_this._engine.canvas).y;
                    var transformedPoint = _this._engine.screenToWorldCoordinates(new Algebra_20.Vector(x, y));
                    var pe = new PointerEvent(transformedPoint.x, transformedPoint.y, e.changedTouches[i].pageX, e.changedTouches[i].pageY, x, y, index, PointerType.Touch, PointerButton.Unknown, e);
                    eventArr.push(pe);
                    _this.at(index).eventDispatcher.emit(eventName, pe);
                    // only with multi-pointer
                    if (_this._pointers.length > 1) {
                        if (eventName === 'up') {
                            // remove pointer ID from pool when pointer is lifted
                            _this._activePointers[index] = -1;
                        }
                        else if (eventName === 'down') {
                            // set pointer ID to given index
                            _this._activePointers[index] = e.changedTouches[i].identifier;
                        }
                    }
                }
            };
        };
        Pointers.prototype._handlePointerEvent = function (eventName, eventArr) {
            var _this = this;
            return function (e) {
                e.preventDefault();
                // get the index for this pointer ID if multi-pointer is asked for
                var index = _this._pointers.length > 1 ? _this._getPointerIndex(e.pointerId) : 0;
                if (index === -1) {
                    return;
                }
                var x = e.pageX - Util.getPosition(_this._engine.canvas).x;
                var y = e.pageY - Util.getPosition(_this._engine.canvas).y;
                var transformedPoint = _this._engine.screenToWorldCoordinates(new Algebra_20.Vector(x, y));
                var pe = new PointerEvent(transformedPoint.x, transformedPoint.y, e.pageX, e.pageY, x, y, index, _this._stringToPointerType(e.pointerType), e.button, e);
                eventArr.push(pe);
                _this.at(index).eventDispatcher.emit(eventName, pe);
                // only with multi-pointer
                if (_this._pointers.length > 1) {
                    if (eventName === 'up') {
                        // remove pointer ID from pool when pointer is lifted
                        _this._activePointers[index] = -1;
                    }
                    else if (eventName === 'down') {
                        // set pointer ID to given index
                        _this._activePointers[index] = e.pointerId;
                    }
                }
            };
        };
        Pointers.prototype._handleWheelEvent = function (eventName, eventArr) {
            var _this = this;
            return function (e) {
                // Should we prevent page scroll because of this event
                if (_this._engine.pageScrollPreventionMode === Engine_2.ScrollPreventionMode.All ||
                    (_this._engine.pageScrollPreventionMode === Engine_2.ScrollPreventionMode.Canvas && e.target === _this._engine.canvas)) {
                    e.preventDefault();
                }
                var x = e.pageX - Util.getPosition(_this._engine.canvas).x;
                var y = e.pageY - Util.getPosition(_this._engine.canvas).y;
                var transformedPoint = _this._engine.screenToWorldCoordinates(new Algebra_20.Vector(x, y));
                // deltaX, deltaY, and deltaZ are the standard modern properties
                // wheelDeltaX, wheelDeltaY, are legacy properties in webkit browsers and older IE
                // e.detail is only used in opera
                var deltaX = e.deltaX ||
                    (e.wheelDeltaX * ScrollWheelNormalizationFactor) ||
                    0;
                var deltaY = e.deltaY ||
                    (e.wheelDeltaY * ScrollWheelNormalizationFactor) ||
                    (e.wheelDelta * ScrollWheelNormalizationFactor) ||
                    e.detail ||
                    0;
                var deltaZ = e.deltaZ || 0;
                var deltaMode = WheelDeltaMode.Pixel;
                if (e.deltaMode) {
                    if (e.deltaMode === 1) {
                        deltaMode = WheelDeltaMode.Line;
                    }
                    else if (e.deltaMode === 2) {
                        deltaMode = WheelDeltaMode.Page;
                    }
                }
                var we = new WheelEvent(transformedPoint.x, transformedPoint.y, e.pageX, e.pageY, x, y, 0, deltaX, deltaY, deltaZ, deltaMode, e);
                eventArr.push(we);
                _this.at(0).eventDispatcher.emit(eventName, we);
            };
        };
        /**
         * Gets the index of the pointer specified for the given pointer ID or finds the next empty pointer slot available.
         * This is required because IE10/11 uses incrementing pointer IDs so we need to store a mapping of ID => idx
         */
        Pointers.prototype._getPointerIndex = function (pointerId) {
            var idx;
            if ((idx = this._activePointers.indexOf(pointerId)) > -1) {
                return idx;
            }
            for (var i = 0; i < this._activePointers.length; i++) {
                if (this._activePointers[i] === -1) {
                    return i;
                }
            }
            // ignore pointer because game isn't watching
            return -1;
        };
        Pointers.prototype._stringToPointerType = function (s) {
            switch (s) {
                case 'touch':
                    return PointerType.Touch;
                case 'mouse':
                    return PointerType.Mouse;
                case 'pen':
                    return PointerType.Pen;
                default:
                    return PointerType.Unknown;
            }
        };
        return Pointers;
    }(Class_6.Class));
    exports.Pointers = Pointers;
    /**
     * Captures and dispatches PointerEvents
     */
    var Pointer = (function (_super) {
        __extends(Pointer, _super);
        function Pointer() {
            var _this = _super.call(this) || this;
            /**
             * The last position on the document this pointer was at. Can be `null` if pointer was never active.
             */
            _this.lastPagePos = null;
            /**
             * The last position on the screen this pointer was at. Can be `null` if pointer was never active.
             */
            _this.lastScreenPos = null;
            /**
             * The last position in the game world coordinates this pointer was at. Can be `null` if pointer was never active.
             */
            _this.lastWorldPos = null;
            _this.on('move', _this._onPointerMove);
            return _this;
        }
        Pointer.prototype._onPointerMove = function (ev) {
            this.lastWorldPos = new Algebra_20.Vector(ev.x, ev.y);
            this.lastPagePos = new Algebra_20.Vector(ev.pageX, ev.pageY);
            this.lastScreenPos = new Algebra_20.Vector(ev.screenX, ev.screenY);
        };
        return Pointer;
    }(Class_6.Class));
    exports.Pointer = Pointer;
});
define("Input/Keyboard", ["require", "exports", "Class", "Events"], function (require, exports, Class_7, Events_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Enum representing input key codes
     */
    var Keys;
    (function (Keys) {
        Keys[Keys["Num1"] = 97] = "Num1";
        Keys[Keys["Num2"] = 98] = "Num2";
        Keys[Keys["Num3"] = 99] = "Num3";
        Keys[Keys["Num4"] = 100] = "Num4";
        Keys[Keys["Num5"] = 101] = "Num5";
        Keys[Keys["Num6"] = 102] = "Num6";
        Keys[Keys["Num7"] = 103] = "Num7";
        Keys[Keys["Num8"] = 104] = "Num8";
        Keys[Keys["Num9"] = 105] = "Num9";
        Keys[Keys["Num0"] = 96] = "Num0";
        Keys[Keys["Numlock"] = 144] = "Numlock";
        Keys[Keys["Semicolon"] = 186] = "Semicolon";
        Keys[Keys["A"] = 65] = "A";
        Keys[Keys["B"] = 66] = "B";
        Keys[Keys["C"] = 67] = "C";
        Keys[Keys["D"] = 68] = "D";
        Keys[Keys["E"] = 69] = "E";
        Keys[Keys["F"] = 70] = "F";
        Keys[Keys["G"] = 71] = "G";
        Keys[Keys["H"] = 72] = "H";
        Keys[Keys["I"] = 73] = "I";
        Keys[Keys["J"] = 74] = "J";
        Keys[Keys["K"] = 75] = "K";
        Keys[Keys["L"] = 76] = "L";
        Keys[Keys["M"] = 77] = "M";
        Keys[Keys["N"] = 78] = "N";
        Keys[Keys["O"] = 79] = "O";
        Keys[Keys["P"] = 80] = "P";
        Keys[Keys["Q"] = 81] = "Q";
        Keys[Keys["R"] = 82] = "R";
        Keys[Keys["S"] = 83] = "S";
        Keys[Keys["T"] = 84] = "T";
        Keys[Keys["U"] = 85] = "U";
        Keys[Keys["V"] = 86] = "V";
        Keys[Keys["W"] = 87] = "W";
        Keys[Keys["X"] = 88] = "X";
        Keys[Keys["Y"] = 89] = "Y";
        Keys[Keys["Z"] = 90] = "Z";
        Keys[Keys["Shift"] = 16] = "Shift";
        Keys[Keys["Alt"] = 18] = "Alt";
        Keys[Keys["Up"] = 38] = "Up";
        Keys[Keys["Down"] = 40] = "Down";
        Keys[Keys["Left"] = 37] = "Left";
        Keys[Keys["Right"] = 39] = "Right";
        Keys[Keys["Space"] = 32] = "Space";
        Keys[Keys["Esc"] = 27] = "Esc";
    })(Keys = exports.Keys || (exports.Keys = {}));
    ;
    /**
     * Event thrown on a game object for a key event
     */
    var KeyEvent = (function (_super) {
        __extends(KeyEvent, _super);
        /**
         * @param key  The key responsible for throwing the event
         */
        function KeyEvent(key) {
            var _this = _super.call(this) || this;
            _this.key = key;
            return _this;
        }
        return KeyEvent;
    }(Events_10.GameEvent));
    exports.KeyEvent = KeyEvent;
    /**
     * Provides keyboard support for Excalibur.
     *
     * [[include:Keyboard.md]]
     */
    var Keyboard = (function (_super) {
        __extends(Keyboard, _super);
        function Keyboard() {
            var _this = _super.call(this) || this;
            _this._keys = [];
            _this._keysUp = [];
            _this._keysDown = [];
            return _this;
        }
        Keyboard.prototype.on = function (eventName, handler) {
            _super.prototype.on.call(this, eventName, handler);
        };
        /**
         * Initialize Keyboard event listeners
         */
        Keyboard.prototype.init = function (global) {
            var _this = this;
            global = global || window;
            global.addEventListener('blur', function () {
                _this._keys.length = 0; // empties array efficiently
            });
            // key up is on window because canvas cannot have focus
            global.addEventListener('keyup', function (ev) {
                var code = _this._normalizeKeyCode(ev.keyCode);
                var key = _this._keys.indexOf(code);
                _this._keys.splice(key, 1);
                _this._keysUp.push(code);
                var keyEvent = new KeyEvent(code);
                // alias the old api, we may want to deprecate this in the future
                _this.eventDispatcher.emit('up', keyEvent);
                _this.eventDispatcher.emit('release', keyEvent);
            });
            // key down is on window because canvas cannot have focus
            global.addEventListener('keydown', function (ev) {
                var code = _this._normalizeKeyCode(ev.keyCode);
                if (_this._keys.indexOf(code) === -1) {
                    _this._keys.push(code);
                    _this._keysDown.push(code);
                    var keyEvent = new KeyEvent(code);
                    _this.eventDispatcher.emit('down', keyEvent);
                    _this.eventDispatcher.emit('press', keyEvent);
                }
            });
        };
        Keyboard.prototype.update = function () {
            // Reset keysDown and keysUp after update is complete
            this._keysDown.length = 0;
            this._keysUp.length = 0;
            // Emit synthetic "hold" event
            for (var i = 0; i < this._keys.length; i++) {
                this.eventDispatcher.emit('hold', new KeyEvent(this._keys[i]));
            }
        };
        /**
         * Gets list of keys being pressed down
         */
        Keyboard.prototype.getKeys = function () {
            return this._keys;
        };
        /**
         * Tests if a certain key was just pressed this frame. This is cleared at the end of the update frame.
         * @param key Test whether a key was just pressed
         */
        Keyboard.prototype.wasPressed = function (key) {
            return this._keysDown.indexOf(key) > -1;
        };
        /**
         * Tests if a certain key is held down. This is persisted between frames.
         * @param key  Test whether a key is held down
         */
        Keyboard.prototype.isHeld = function (key) {
            return this._keys.indexOf(key) > -1;
        };
        /**
         * Tests if a certain key was just released this frame. This is cleared at the end of the update frame.
         * @param key  Test whether a key was just released
         */
        Keyboard.prototype.wasReleased = function (key) {
            return this._keysUp.indexOf(key) > -1;
        };
        /**
         * Normalizes some browser event key codes to map to standard Excalibur key codes
         * @param code Event keyCode
         * @see http://unixpapa.com/js/key.html
         */
        Keyboard.prototype._normalizeKeyCode = function (code) {
            switch (code) {
                case 59:
                    return Keys.Semicolon;
                default:
                    return code;
            }
        };
        return Keyboard;
    }(Class_7.Class));
    exports.Keyboard = Keyboard;
});
define("Input/IEngineInput", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
/**
 * Provides support for mice, keyboards, and controllers.
 *
 * [[include:Input.md]]
 */
define("Input/Index", ["require", "exports", "Input/Gamepad", "Input/Pointer", "Input/Keyboard"], function (require, exports, Gamepad_1, Pointer_1, Keyboard_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @typedoc
     */
    __export(Gamepad_1);
    __export(Pointer_1);
    __export(Keyboard_1);
});
define("Util/Index", ["require", "exports", "Util/Util", "Util/DrawUtil"], function (require, exports, Util_3, drawUtil) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(Util_3);
    exports.DrawUtil = drawUtil;
});
define("Util/Decorators", ["require", "exports", "Util/Log", "Util/Util"], function (require, exports, Log_11, Util) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Obsolete decorator for marking Excalibur methods obsolete, you can optionally specify a custom message and/or alternate replacement
     * method do the deprecated one. Inspired by https://github.com/jayphelps/core-decorators.js
     */
    function obsolete(options) {
        options = Util.extend({}, { message: 'This method will be removed in future versions of Excalibur.', alternateMethod: null }, options);
        return function (target, property, descriptor) {
            if (!(typeof descriptor.value === 'function' ||
                typeof descriptor.get === 'function' ||
                typeof descriptor.set === 'function')) {
                throw new SyntaxError('Only functions/getters/setters can be marked as obsolete');
            }
            var methodSignature = "" + (target.name || '') + (target.name ? '.' : '') + property;
            var message = methodSignature + " is marked obsolete: " + options.message +
                (options.alternateMethod ? " Use " + options.alternateMethod + " instead" : '');
            var method = Util.extend({}, descriptor);
            if (descriptor.value) {
                method.value = function () {
                    Log_11.Logger.getInstance().warn(message);
                    return descriptor.value.apply(this, arguments);
                };
                return method;
            }
            if (descriptor.get) {
                method.get = function () {
                    Log_11.Logger.getInstance().warn(message);
                    return descriptor.get.apply(this, arguments);
                };
            }
            if (descriptor.set) {
                method.set = function () {
                    Log_11.Logger.getInstance().warn(message);
                    return descriptor.set.apply(this, arguments);
                };
            }
            return method;
        };
    }
    exports.obsolete = obsolete;
});
define("Util/Detector", ["require", "exports", "Util/Log"], function (require, exports, Log_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * This is the list of features that will be used to log the supported
     * features to the console when Detector.logBrowserFeatures() is called.
     */
    var REPORTED_FEATURES = {
        webgl: 'WebGL',
        webaudio: 'WebAudio',
        gamepadapi: 'Gamepad API'
    };
    /**
     * Excalibur internal feature detection helper class
     */
    var Detector = (function () {
        function Detector() {
            this._features = null;
            this.failedTests = [];
            // critical browser features required for ex to run
            this._criticalTests = {
                // Test canvas/2d context support
                canvasSupport: function () {
                    var elem = document.createElement('canvas');
                    return !!(elem.getContext && elem.getContext('2d'));
                },
                // Test array buffer support ex uses for downloading binary data
                arrayBufferSupport: function () {
                    var xhr = new XMLHttpRequest();
                    xhr.open('GET', '/');
                    try {
                        xhr.responseType = 'arraybuffer';
                    }
                    catch (e) {
                        return false;
                    }
                    return xhr.responseType === 'arraybuffer';
                },
                // Test data urls ex uses for sprites
                dataUrlSupport: function () {
                    var canvas = document.createElement('canvas');
                    return canvas.toDataURL('image/png').indexOf('data:image/png') === 0;
                },
                // Test object url support for loading
                objectUrlSupport: function () {
                    return ('URL' in window) && ('revokeObjectURL' in URL) && ('createObjectURL' in URL);
                },
                // RGBA support for colors
                rgbaSupport: function () {
                    var style = document.createElement('a').style;
                    style.cssText = 'background-color:rgba(150,255,150,.5)';
                    return ('' + style.backgroundColor).indexOf('rgba') > -1;
                }
            };
            // warnings excalibur performance will be degraded
            this._warningTest = {
                webAudioSupport: function () {
                    return !!(window.AudioContext ||
                        window.webkitAudioContext ||
                        window.mozAudioContext ||
                        window.msAudioContext ||
                        window.oAudioContext);
                },
                webglSupport: function () {
                    var elem = document.createElement('canvas');
                    return !!(elem.getContext && elem.getContext('webgl'));
                }
            };
            this._features = this._loadBrowserFeatures();
        }
        /**
         * Returns a map of currently supported browser features. This method
         * treats the features as a singleton and will only calculate feature
         * support if it has not previously been done.
         */
        Detector.prototype.getBrowserFeatures = function () {
            if (this._features === null) {
                this._features = this._loadBrowserFeatures();
            }
            return this._features;
        };
        /**
         * Report on non-critical browser support for debugging purposes.
         * Use native browser console colors for visibility.
         */
        Detector.prototype.logBrowserFeatures = function () {
            var msg = '%cSUPPORTED BROWSER FEATURES\n==========================%c\n';
            var args = [
                'font-weight: bold; color: navy',
                'font-weight: normal; color: inherit'
            ];
            var supported = this.getBrowserFeatures();
            for (var _i = 0, _a = Object.keys(REPORTED_FEATURES); _i < _a.length; _i++) {
                var feature = _a[_i];
                if (supported[feature]) {
                    msg += '(%c\u2713%c)'; // (✓)
                    args.push('font-weight: bold; color: green');
                    args.push('font-weight: normal; color: inherit');
                }
                else {
                    msg += '(%c\u2717%c)'; // (✗)
                    args.push('font-weight: bold; color: red');
                    args.push('font-weight: normal; color: inherit');
                }
                ;
                msg += ' ' + REPORTED_FEATURES[feature] + '\n';
            }
            args.unshift(msg);
            console.log.apply(console, args);
        };
        /**
         * Executes several IIFE's to get a constant reference to supported
         * features within the current execution context.
         */
        Detector.prototype._loadBrowserFeatures = function () {
            var _this = this;
            return {
                // IIFE to check canvas support
                canvas: (function () {
                    return _this._criticalTests.canvasSupport();
                })(),
                // IIFE to check arraybuffer support
                arraybuffer: (function () {
                    return _this._criticalTests.arrayBufferSupport();
                })(),
                // IIFE to check dataurl support
                dataurl: (function () {
                    return _this._criticalTests.dataUrlSupport();
                })(),
                // IIFE to check objecturl support
                objecturl: (function () {
                    return _this._criticalTests.objectUrlSupport();
                })(),
                // IIFE to check rgba support
                rgba: (function () {
                    return _this._criticalTests.rgbaSupport();
                })(),
                // IIFE to check webaudio support
                webaudio: (function () {
                    return _this._warningTest.webAudioSupport();
                })(),
                // IIFE to check webgl support
                webgl: (function () {
                    return _this._warningTest.webglSupport();
                })(),
                // IIFE to check gamepadapi support
                gamepadapi: (function () {
                    return !!navigator.getGamepads;
                })()
            };
        };
        Detector.prototype.test = function () {
            // Critical test will for ex not to run
            var failedCritical = false;
            for (var test in this._criticalTests) {
                if (!this._criticalTests[test].call(this)) {
                    this.failedTests.push(test);
                    Log_12.Logger.getInstance().error('Critical browser feature missing, Excalibur requires:', test);
                    failedCritical = true;
                }
            }
            if (failedCritical) {
                return false;
            }
            // Warning tests do not for ex to return false to compatibility
            for (var warning in this._warningTest) {
                if (!this._warningTest[warning]()) {
                    Log_12.Logger.getInstance().warn('Warning browser feature missing, Excalibur will have reduced performance:', warning);
                }
            }
            return true;
        };
        return Detector;
    }());
    exports.Detector = Detector;
});
define("Util/SortedList", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A sorted list implementation. NOTE: this implementation is not self-balancing
     */
    var SortedList = (function () {
        function SortedList(getComparable) {
            this._getComparable = getComparable;
        }
        SortedList.prototype.find = function (element) {
            return this._find(this._root, element);
        };
        SortedList.prototype._find = function (node, element) {
            if (node == null) {
                return false;
            }
            else if (this._getComparable.call(element) === node.getKey()) {
                if (node.getData().indexOf(element) > -1) {
                    return true;
                }
                else {
                    return false;
                }
            }
            else if (this._getComparable.call(element) < node.getKey()) {
                return this._find(node.getLeft(), element);
            }
            else {
                return this._find(node.getRight(), element);
            }
        };
        // returns the array of elements at a specific key value
        SortedList.prototype.get = function (key) {
            return this._get(this._root, key);
        };
        SortedList.prototype._get = function (node, key) {
            if (node == null) {
                return [];
            }
            else if (key === node.getKey()) {
                return node.getData();
            }
            else if (key < node.getKey()) {
                return this._get(node.getLeft(), key);
            }
            else {
                return this._get(node.getRight(), key);
            }
        };
        SortedList.prototype.add = function (element) {
            if (this._root == null) {
                this._root = new BinaryTreeNode(this._getComparable.call(element), [element], null, null);
                return true;
            }
            else {
                return this._insert(this._root, element);
            }
        };
        SortedList.prototype._insert = function (node, element) {
            if (node != null) {
                if (this._getComparable.call(element) === node.getKey()) {
                    if (node.getData().indexOf(element) > -1) {
                        return false; // the element we're trying to insert already exists
                    }
                    else {
                        node.getData().push(element);
                        return true;
                    }
                }
                else if (this._getComparable.call(element) < node.getKey()) {
                    if (node.getLeft() == null) {
                        node.setLeft(new BinaryTreeNode(this._getComparable.call(element), [element], null, null));
                        return true;
                    }
                    else {
                        return this._insert(node.getLeft(), element);
                    }
                }
                else {
                    if (node.getRight() == null) {
                        node.setRight(new BinaryTreeNode(this._getComparable.call(element), [element], null, null));
                        return true;
                    }
                    else {
                        return this._insert(node.getRight(), element);
                    }
                }
            }
            return false;
        };
        SortedList.prototype.removeByComparable = function (element) {
            this._root = this._remove(this._root, element);
        };
        SortedList.prototype._remove = function (node, element) {
            if (node == null) {
                return null;
            }
            else if (this._getComparable.call(element) === node.getKey()) {
                var elementIndex = node.getData().indexOf(element);
                // if the node contains the element, remove the element
                if (elementIndex > -1) {
                    node.getData().splice(elementIndex, 1);
                    // if we have removed the last element at this node, remove the node
                    if (node.getData().length === 0) {
                        // if the node is a leaf
                        if (node.getLeft() == null && node.getRight() == null) {
                            return null;
                        }
                        else if (node.getLeft() == null) {
                            return node.getRight();
                        }
                        else if (node.getRight() == null) {
                            return node.getLeft();
                        }
                        // if node has 2 children
                        var temp = this._findMinNode(node.getRight());
                        node.setKey(temp.getKey());
                        node.setData(temp.getData());
                        node.setRight(this._cleanup(node.getRight(), temp)); //"cleanup nodes" (move them up recursively)
                        return node;
                    }
                    else {
                        // this prevents the node from being removed since it still contains elements
                        return node;
                    }
                }
            }
            else if (this._getComparable.call(element) < node.getKey()) {
                node.setLeft(this._remove(node.getLeft(), element));
                return node;
            }
            else {
                node.setRight(this._remove(node.getRight(), element));
                return node;
            }
            return null;
        };
        // called once we have successfully removed the element we wanted, recursively corrects the part of the tree below the removed node
        SortedList.prototype._cleanup = function (node, element) {
            var comparable = element.getKey();
            if (node == null) {
                return null;
            }
            else if (comparable === node.getKey()) {
                // if the node is a leaf
                if (node.getLeft() == null && node.getRight() == null) {
                    return null;
                }
                else if (node.getLeft() == null) {
                    return node.getRight();
                }
                else if (node.getRight() == null) {
                    return node.getLeft();
                }
                // if node has 2 children
                var temp = this._findMinNode(node.getRight());
                node.setKey(temp.getKey());
                node.setData(temp.getData());
                node.setRight(this._cleanup(node.getRight(), temp));
                return node;
            }
            else if (this._getComparable.call(element) < node.getKey()) {
                node.setLeft(this._cleanup(node.getLeft(), element));
                return node;
            }
            else {
                node.setRight(this._cleanup(node.getRight(), element));
                return node;
            }
        };
        SortedList.prototype._findMinNode = function (node) {
            var current = node;
            while (current.getLeft() != null) {
                current = current.getLeft();
            }
            return current;
        };
        SortedList.prototype.list = function () {
            var results = new Array();
            this._list(this._root, results);
            return results;
        };
        SortedList.prototype._list = function (treeNode, results) {
            if (treeNode != null) {
                this._list(treeNode.getLeft(), results);
                treeNode.getData().forEach(function (element) {
                    results.push(element);
                });
                this._list(treeNode.getRight(), results);
            }
        };
        return SortedList;
    }());
    exports.SortedList = SortedList;
    /**
     * A tree node part of [[SortedList]]
     */
    var BinaryTreeNode = (function () {
        function BinaryTreeNode(key, data, left, right) {
            this._key = key;
            this._data = data;
            this._left = left;
            this._right = right;
        }
        BinaryTreeNode.prototype.getKey = function () {
            return this._key;
        };
        BinaryTreeNode.prototype.setKey = function (key) {
            this._key = key;
        };
        BinaryTreeNode.prototype.getData = function () {
            return this._data;
        };
        BinaryTreeNode.prototype.setData = function (data) {
            this._data = data;
        };
        BinaryTreeNode.prototype.getLeft = function () {
            return this._left;
        };
        BinaryTreeNode.prototype.setLeft = function (left) {
            this._left = left;
        };
        BinaryTreeNode.prototype.getRight = function () {
            return this._right;
        };
        BinaryTreeNode.prototype.setRight = function (right) {
            this._right = right;
        };
        return BinaryTreeNode;
    }());
    exports.BinaryTreeNode = BinaryTreeNode;
    /**
     * Mock element for testing
     *
     * @internal
     */
    var MockedElement = (function () {
        function MockedElement(key) {
            this._key = 0;
            this._key = key;
        }
        MockedElement.prototype.getTheKey = function () {
            return this._key;
        };
        MockedElement.prototype.setKey = function (key) {
            this._key = key;
        };
        return MockedElement;
    }());
    exports.MockedElement = MockedElement;
});
define("Index", ["require", "exports", "Actor", "Algebra", "Camera", "Class", "Configurable", "Debug", "Engine", "EventDispatcher", "Events", "Group", "Label", "Loader", "Particles", "Physics", "Promises", "Scene", "TileMap", "Timer", "Trigger", "UIActor", "Actions/Index", "Collision/Index", "Drawing/Index", "Math/Index", "PostProcessing/Index", "Resources/Index", "Events", "Input/Index", "Traits/Index", "Util/Index", "Util/Decorators", "Util/Detector", "Util/CullingBox", "Util/EasingFunctions", "Util/Log", "Util/SortedList"], function (require, exports, Actor_11, Algebra_21, Camera_1, Class_8, Configurable_7, Debug_1, Engine_3, EventDispatcher_2, Events_11, Group_1, Label_2, Loader_1, Particles_1, Physics_11, Promises_7, Scene_1, TileMap_1, Timer_1, Trigger_1, UIActor_2, Index_1, Index_2, Index_3, Index_4, Index_5, Index_6, events, input, traits, util, Decorators_1, Detector_1, CullingBox_2, EasingFunctions_3, Log_13, SortedList_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The current Excalibur version string
     */
    exports.EX_VERSION = '0.15.0';
    exports.Actor = Actor_11.Actor;
    exports.CollisionType = Actor_11.CollisionType;
    __export(Algebra_21);
    __export(Camera_1);
    __export(Class_8);
    __export(Configurable_7);
    __export(Debug_1);
    __export(Engine_3);
    __export(EventDispatcher_2);
    __export(Events_11);
    __export(Group_1);
    exports.Label = Label_2.Label;
    exports.FontStyle = Label_2.FontStyle;
    exports.FontUnit = Label_2.FontUnit;
    exports.TextAlign = Label_2.TextAlign;
    exports.BaseAlign = Label_2.BaseAlign;
    __export(Loader_1);
    exports.Particle = Particles_1.Particle;
    exports.ParticleEmitter = Particles_1.ParticleEmitter;
    exports.EmitterType = Particles_1.EmitterType;
    __export(Physics_11);
    __export(Promises_7);
    __export(Scene_1);
    exports.TileMap = TileMap_1.TileMap;
    exports.Cell = TileMap_1.Cell;
    exports.TileSprite = TileMap_1.TileSprite;
    __export(Timer_1);
    __export(Trigger_1);
    __export(UIActor_2);
    __export(Index_1);
    __export(Index_2);
    __export(Index_3);
    __export(Index_4);
    __export(Index_5);
    __export(Index_6);
    exports.Events = events;
    exports.Input = input;
    exports.Traits = traits;
    exports.Util = util;
    __export(Decorators_1);
    __export(Detector_1);
    __export(CullingBox_2);
    __export(EasingFunctions_3);
    __export(Log_13);
    __export(SortedList_1);
});
define("Engine", ["require", "exports", "Index", "Promises", "Algebra", "UIActor", "Actor", "Timer", "TileMap", "Loader", "Util/Detector", "Events", "Util/Log", "Drawing/Color", "Scene", "Debug", "Class", "Input/Index", "Util/Util", "Collision/BoundingBox"], function (require, exports, Index_7, Promises_8, Algebra_22, UIActor_3, Actor_12, Timer_2, TileMap_2, Loader_2, Detector_2, Events_12, Log_14, Color_19, Scene_2, Debug_2, Class_9, Input, Util, BoundingBox_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Enum representing the different display modes available to Excalibur
     */
    var DisplayMode;
    (function (DisplayMode) {
        /**
         * Show the game as full screen
         */
        DisplayMode[DisplayMode["FullScreen"] = 0] = "FullScreen";
        /**
         * Scale the game to the parent DOM container
         */
        DisplayMode[DisplayMode["Container"] = 1] = "Container";
        /**
         * Show the game as a fixed size
         */
        DisplayMode[DisplayMode["Fixed"] = 2] = "Fixed";
        /**
         * Allow the game to be positioned with the [[IEngineOptions.position]] option
         */
        DisplayMode[DisplayMode["Position"] = 3] = "Position";
    })(DisplayMode = exports.DisplayMode || (exports.DisplayMode = {}));
    /**
     * Enum representing the different mousewheel event bubble prevention
     */
    var ScrollPreventionMode;
    (function (ScrollPreventionMode) {
        /**
         * Do not prevent any page scrolling
         */
        ScrollPreventionMode[ScrollPreventionMode["None"] = 0] = "None";
        /**
         * Prevent page scroll if mouse is over the game canvas
         */
        ScrollPreventionMode[ScrollPreventionMode["Canvas"] = 1] = "Canvas";
        /**
         * Prevent all page scrolling via mouse wheel
         */
        ScrollPreventionMode[ScrollPreventionMode["All"] = 2] = "All";
    })(ScrollPreventionMode = exports.ScrollPreventionMode || (exports.ScrollPreventionMode = {}));
    /**
     * The Excalibur Engine
     *
     * The [[Engine]] is the main driver for a game. It is responsible for
     * starting/stopping the game, maintaining state, transmitting events,
     * loading resources, and managing the scene.
     *
     * [[include:Engine.md]]
     */
    var Engine = (function (_super) {
        __extends(Engine, _super);
        /**
         * Creates a new game using the given [[IEngineOptions]]. By default, if no options are provided,
         * the game will be rendered full screen (taking up all available browser window space).
         * You can customize the game rendering through [[IEngineOptions]].
         *
         * Example:
         *
         * ```js
         * var game = new ex.Engine({
         *   width: 0, // the width of the canvas
         *   height: 0, // the height of the canvas
         *   canvasElementId: '', // the DOM canvas element ID, if you are providing your own
         *   displayMode: ex.DisplayMode.FullScreen, // the display mode
         *   pointerScope: ex.Input.PointerScope.Document, // the scope of capturing pointer (mouse/touch) events
         *   backgroundColor: ex.Color.fromHex('#2185d0') // background color of the engine
         * });
         *
         * // call game.start, which is a Promise
         * game.start().then(function () {
         *   // ready, set, go!
         * });
         * ```
         */
        function Engine(options) {
            var _this = _super.call(this) || this;
            _this._hasStarted = false;
            /**
             * Access Excalibur debugging functionality.
             */
            _this.debug = new Debug_2.Debug();
            /**
             * Gets or sets the list of post processors to apply at the end of drawing a frame (such as [[ColorBlindCorrector]])
             */
            _this.postProcessors = [];
            /**
             * Contains all the scenes currently registered with Excalibur
             */
            _this.scenes = {};
            _this._animations = [];
            /**
             * Indicates whether the engine is set to fullscreen or not
             */
            _this.isFullscreen = false;
            /**
             * Indicates the current [[DisplayMode]] of the engine.
             */
            _this.displayMode = DisplayMode.FullScreen;
            /**
             * Indicates whether audio should be paused when the game is no longer visible.
             */
            _this.pauseAudioWhenHidden = true;
            /**
             * Indicates whether the engine should draw with debug information
             */
            _this.isDebug = false;
            _this.debugColor = new Color_19.Color(255, 255, 255);
            /**
             * The action to take when a fatal exception is thrown
             */
            _this.onFatalException = function (e) { Log_14.Logger.getInstance().fatal(e); };
            _this._isSmoothingEnabled = true;
            _this._timescale = 1.0;
            _this._isLoading = false;
            options = Util.extend({}, Engine._DefaultEngineOptions, options);
            // Check compatibility 
            var detector = new Detector_2.Detector();
            if (!options.suppressMinimumBrowserFeatureDetection && !(_this._compatible = detector.test())) {
                var message = document.createElement('div');
                message.innerText = 'Sorry, your browser does not support all the features needed for Excalibur';
                document.body.appendChild(message);
                detector.failedTests.forEach(function (test) {
                    var testMessage = document.createElement('div');
                    testMessage.innerText = 'Browser feature missing ' + test;
                    document.body.appendChild(testMessage);
                });
                if (options.canvasElementId) {
                    var canvas = document.getElementById(options.canvasElementId);
                    if (canvas) {
                        canvas.parentElement.removeChild(canvas);
                    }
                }
                return _this;
            }
            else {
                _this._compatible = true;
            }
            // Use native console API for color fun
            if (console.log && !options.suppressConsoleBootMessage) {
                console.log("%cPowered by Excalibur.js (v" + Index_7.EX_VERSION + ")", 'background: #176BAA; color: white; border-radius: 5px; padding: 15px; font-size: 1.5em; line-height: 80px;');
                console.log('\n\
      /| ________________\n\
O|===|* >________________>\n\
      \\|');
                console.log('Visit', 'http://excaliburjs.com', 'for more information');
            }
            _this._logger = Log_14.Logger.getInstance();
            // If debug is enabled, let's log browser features to the console.
            if (_this._logger.defaultLevel === Log_14.LogLevel.Debug) {
                detector.logBrowserFeatures();
            }
            _this._logger.debug('Building engine...');
            _this.canvasElementId = options.canvasElementId;
            if (options.canvasElementId) {
                _this._logger.debug('Using Canvas element specified: ' + options.canvasElementId);
                _this.canvas = document.getElementById(options.canvasElementId);
            }
            else {
                _this._logger.debug('Using generated canvas element');
                _this.canvas = document.createElement('canvas');
            }
            if (options.width && options.height) {
                if (options.displayMode === undefined) {
                    _this.displayMode = DisplayMode.Fixed;
                }
                _this._logger.debug('Engine viewport is size ' + options.width + ' x ' + options.height);
                _this.canvas.width = options.width;
                _this.canvas.height = options.height;
            }
            else if (!options.displayMode) {
                _this._logger.debug('Engine viewport is fullscreen');
                _this.displayMode = DisplayMode.FullScreen;
            }
            if (options.backgroundColor) {
                _this.backgroundColor = options.backgroundColor.clone();
            }
            _this._loader = new Loader_2.Loader();
            _this._initialize(options);
            _this.rootScene = _this.currentScene = new Scene_2.Scene(_this);
            _this.addScene('root', _this.rootScene);
            _this.goToScene('root');
            return _this;
        }
        Object.defineProperty(Engine.prototype, "canvasWidth", {
            /**
             * The width of the game canvas in pixels (physical width component of the
             * resolution of the canvas element)
             */
            get: function () {
                return this.canvas.width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "halfCanvasWidth", {
            /**
             * Returns half width of the game canvas in pixels (half physical width component)
             */
            get: function () {
                return this.canvas.width / 2;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "canvasHeight", {
            /**
             * The height of the game canvas in pixels, (physical height component of
             * the resolution of the canvas element)
             */
            get: function () {
                return this.canvas.height;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "halfCanvasHeight", {
            /**
             * Returns half height of the game canvas in pixels (half physical height component)
             */
            get: function () {
                return this.canvas.height / 2;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "drawWidth", {
            /**
             * Returns the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
             */
            get: function () {
                if (this.currentScene && this.currentScene.camera) {
                    return (this.canvasWidth / this.currentScene.camera.getZoom()) / this.pixelRatio;
                }
                return this.canvasWidth / this.pixelRatio;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "halfDrawWidth", {
            /**
             * Returns half the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
             */
            get: function () {
                return this.drawWidth / 2;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "drawHeight", {
            /**
             * Returns the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
             */
            get: function () {
                if (this.currentScene && this.currentScene.camera) {
                    return (this.canvasHeight / this.currentScene.camera.getZoom()) / this.pixelRatio;
                }
                return this.canvasHeight / this.pixelRatio;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "halfDrawHeight", {
            /**
             * Returns half the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
             */
            get: function () {
                return this.drawHeight / 2;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "isHiDpi", {
            /**
             * Returns whether excalibur detects the current screen to be HiDPI
             */
            get: function () {
                return this.pixelRatio !== 1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "stats", {
            /**
             * Access [[stats]] that holds frame statistics.
             */
            get: function () {
                return this.debug.stats;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "pixelRatio", {
            /**
             * Returns the calculated pixel ration for use in rendering
             */
            get: function () {
                var devicePixelRatio = window.devicePixelRatio || 1;
                var pixelRatio = devicePixelRatio;
                return pixelRatio;
            },
            enumerable: true,
            configurable: true
        });
        Engine.prototype.on = function (eventName, handler) {
            _super.prototype.on.call(this, eventName, handler);
        };
        /**
         * Returns a BoundingBox of the top left corner of the screen
         * and the bottom right corner of the screen.
         */
        Engine.prototype.getWorldBounds = function () {
            var left = this.screenToWorldCoordinates(Algebra_22.Vector.Zero).x;
            var top = this.screenToWorldCoordinates(Algebra_22.Vector.Zero).y;
            var right = left + this.drawWidth;
            var bottom = top + this.drawHeight;
            return new BoundingBox_7.BoundingBox(left, top, right, bottom);
        };
        Object.defineProperty(Engine.prototype, "timescale", {
            /**
             * Gets the current engine timescale factor (default is 1.0 which is 1:1 time)
             */
            get: function () {
                return this._timescale;
            },
            /**
             * Sets the current engine timescale factor. Useful for creating slow-motion effects or fast-forward effects
             * when using time-based movement.
             */
            set: function (value) {
                if (value <= 0) {
                    Log_14.Logger.getInstance().error('Cannot set engine.timescale to a value of 0 or less than 0.');
                    return;
                }
                this._timescale = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Plays a sprite animation on the screen at the specified `x` and `y`
         * (in game coordinates, not screen pixels). These animations play
         * independent of actors, and will be cleaned up internally as soon
         * as they are complete. Note animations that loop will never be
         * cleaned up.
         *
         * @param animation  Animation to play
         * @param x          x game coordinate to play the animation
         * @param y          y game coordinate to play the animation
         */
        Engine.prototype.playAnimation = function (animation, x, y) {
            this._animations.push(new AnimationNode(animation, x, y));
        };
        /**
         * Adds a [[TileMap]] to the [[currentScene]], once this is done the TileMap
         * will be drawn and updated.
         */
        Engine.prototype.addTileMap = function (tileMap) {
            this.currentScene.addTileMap(tileMap);
        };
        /**
         * Removes a [[TileMap]] from the [[currentScene]], it will no longer be drawn or updated.
         */
        Engine.prototype.removeTileMap = function (tileMap) {
            this.currentScene.removeTileMap(tileMap);
        };
        /**
         * Adds a [[Timer]] to the [[currentScene]].
         * @param timer  The timer to add to the [[currentScene]].
         */
        Engine.prototype.addTimer = function (timer) {
            return this.currentScene.addTimer(timer);
        };
        /**
         * Removes a [[Timer]] from the [[currentScene]].
         * @param timer  The timer to remove to the [[currentScene]].
         */
        Engine.prototype.removeTimer = function (timer) {
            return this.currentScene.removeTimer(timer);
        };
        /**
         * Adds a [[Scene]] to the engine, think of scenes in Excalibur as you
         * would levels or menus.
         *
         * @param key  The name of the scene, must be unique
         * @param scene The scene to add to the engine
         */
        Engine.prototype.addScene = function (key, scene) {
            if (this.scenes[key]) {
                this._logger.warn('Scene', key, 'already exists overwriting');
            }
            this.scenes[key] = scene;
            scene.engine = this;
        };
        /**
         * @internal
         */
        Engine.prototype.removeScene = function (entity) {
            if (entity instanceof Scene_2.Scene) {
                // remove scene
                for (var key in this.scenes) {
                    if (this.scenes.hasOwnProperty(key)) {
                        if (this.scenes[key] === entity) {
                            delete this.scenes[key];
                        }
                    }
                }
            }
            if (typeof entity === 'string') {
                // remove scene
                delete this.scenes[entity];
            }
        };
        Engine.prototype.add = function (entity) {
            if (entity instanceof UIActor_3.UIActor) {
                this.currentScene.addUIActor(entity);
                return;
            }
            if (entity instanceof Actor_12.Actor) {
                this._addChild(entity);
            }
            if (entity instanceof Timer_2.Timer) {
                this.addTimer(entity);
            }
            if (entity instanceof TileMap_2.TileMap) {
                this.addTileMap(entity);
            }
            if (arguments.length === 2) {
                this.addScene(arguments[0], arguments[1]);
            }
        };
        Engine.prototype.remove = function (entity) {
            if (entity instanceof UIActor_3.UIActor) {
                this.currentScene.removeUIActor(entity);
                return;
            }
            if (entity instanceof Actor_12.Actor) {
                this._removeChild(entity);
            }
            if (entity instanceof Timer_2.Timer) {
                this.removeTimer(entity);
            }
            if (entity instanceof TileMap_2.TileMap) {
                this.removeTileMap(entity);
            }
            if (entity instanceof Scene_2.Scene) {
                this.removeScene(entity);
            }
            if (typeof entity === 'string') {
                this.removeScene(entity);
            }
        };
        /**
         * Adds an actor to the [[currentScene]] of the game. This is synonymous
         * to calling `engine.currentScene.add(actor)`.
         *
         * Actors can only be drawn if they are a member of a scene, and only
         * the [[currentScene]] may be drawn or updated.
         *
         * @param actor  The actor to add to the [[currentScene]]
         */
        Engine.prototype._addChild = function (actor) {
            this.currentScene.add(actor);
        };
        /**
         * Removes an actor from the [[currentScene]] of the game. This is synonymous
         * to calling `engine.currentScene.remove(actor)`.
         * Actors that are removed from a scene will no longer be drawn or updated.
         *
         * @param actor  The actor to remove from the [[currentScene]].
         */
        Engine.prototype._removeChild = function (actor) {
            this.currentScene.remove(actor);
        };
        /**
         * Changes the currently updating and drawing scene to a different,
         * named scene. Calls the [[Scene]] lifecycle events.
         * @param key  The key of the scene to transition to.
         */
        Engine.prototype.goToScene = function (key) {
            if (this.scenes[key]) {
                var oldScene = this.currentScene;
                var newScene = this.scenes[key];
                this._logger.debug('Going to scene:', key);
                // only deactivate when initialized
                if (this.currentScene.isInitialized) {
                    this.currentScene.onDeactivate.call(this.currentScene);
                    this.currentScene.eventDispatcher.emit('deactivate', new Events_12.DeactivateEvent(newScene, this.currentScene));
                }
                // set current scene to new one
                this.currentScene = newScene;
                // initialize the current scene if has not been already
                this.currentScene._initialize(this);
                this.currentScene.onActivate.call(this.currentScene);
                this.currentScene.eventDispatcher.emit('activate', new Events_12.ActivateEvent(oldScene, this.currentScene));
            }
            else {
                this._logger.error('Scene', key, 'does not exist!');
            }
        };
        /**
         * Transforms the current x, y from screen coordinates to world coordinates
         * @param point  Screen coordinate to convert
         */
        Engine.prototype.screenToWorldCoordinates = function (point) {
            var newX = point.x;
            var newY = point.y;
            // transform back to world space
            newX = (newX / this.canvas.clientWidth) * this.drawWidth;
            newY = (newY / this.canvas.clientHeight) * this.drawHeight;
            // transform based on zoom
            newX = newX - this.halfDrawWidth;
            newY = newY - this.halfDrawHeight;
            // shift by focus
            if (this.currentScene && this.currentScene.camera) {
                var focus = this.currentScene.camera.getFocus();
                newX += focus.x;
                newY += focus.y;
            }
            return new Algebra_22.Vector(Math.floor(newX), Math.floor(newY));
        };
        /**
         * Transforms a world coordinate, to a screen coordinate
         * @param point  World coordinate to convert
         */
        Engine.prototype.worldToScreenCoordinates = function (point) {
            var screenX = point.x;
            var screenY = point.y;
            // shift by focus
            if (this.currentScene && this.currentScene.camera) {
                var focus = this.currentScene.camera.getFocus();
                screenX -= focus.x;
                screenY -= focus.y;
            }
            // transform back on zoom
            screenX = screenX + this.halfDrawWidth;
            screenY = screenY + this.halfDrawHeight;
            // transform back to screen space
            screenX = (screenX * this.canvas.clientWidth) / this.drawWidth;
            screenY = (screenY * this.canvas.clientHeight) / this.drawHeight;
            return new Algebra_22.Vector(Math.floor(screenX), Math.floor(screenY));
        };
        /**
         * Sets the internal canvas height based on the selected display mode.
         */
        Engine.prototype._setHeightByDisplayMode = function (parent) {
            if (this.displayMode === DisplayMode.Container) {
                this.canvas.width = parent.clientWidth;
                this.canvas.height = parent.clientHeight;
            }
            if (this.displayMode === DisplayMode.FullScreen) {
                document.body.style.margin = '0px';
                document.body.style.overflow = 'hidden';
                this.canvas.width = parent.innerWidth;
                this.canvas.height = parent.innerHeight;
            }
        };
        /**
         * Initializes the internal canvas, rendering context, displaymode, and native event listeners
         */
        Engine.prototype._initialize = function (options) {
            var _this = this;
            if (options.displayMode) {
                this.displayMode = options.displayMode;
            }
            if (this.displayMode === DisplayMode.FullScreen || this.displayMode === DisplayMode.Container) {
                var parent = (this.displayMode === DisplayMode.Container ?
                    (this.canvas.parentElement || document.body) : window);
                this._setHeightByDisplayMode(parent);
                window.addEventListener('resize', function () {
                    _this._logger.debug('View port resized');
                    _this._setHeightByDisplayMode(parent);
                    _this._logger.info('parent.clientHeight ' + parent.clientHeight);
                    _this.setAntialiasing(_this._isSmoothingEnabled);
                });
            }
            else if (this.displayMode === DisplayMode.Position) {
                this._intializeDisplayModePosition(options);
            }
            // initialize inputs
            this.input = {
                keyboard: new Input.Keyboard(),
                pointers: new Input.Pointers(this),
                gamepads: new Input.Gamepads()
            };
            this.input.keyboard.init();
            this.input.pointers.init(options && options.pointerScope === Input.PointerScope.Document ? document : this.canvas);
            this.input.gamepads.init();
            this.pageScrollPreventionMode = options.scrollPreventionMode;
            // Issue #385 make use of the visibility api
            // https://developer.mozilla.org/en-US/docs/Web/Guide/User_experience/Using_the_Page_Visibility_API
            var hidden, visibilityChange;
            if (typeof document.hidden !== 'undefined') {
                hidden = 'hidden';
                visibilityChange = 'visibilitychange';
            }
            else if ('msHidden' in document) {
                hidden = 'msHidden';
                visibilityChange = 'msvisibilitychange';
            }
            else if ('webkitHidden' in document) {
                hidden = 'webkitHidden';
                visibilityChange = 'webkitvisibilitychange';
            }
            document.addEventListener(visibilityChange, function () {
                if (document[hidden]) {
                    _this.eventDispatcher.emit('hidden', new Events_12.HiddenEvent(_this));
                    _this._logger.debug('Window hidden');
                }
                else {
                    _this.eventDispatcher.emit('visible', new Events_12.VisibleEvent(_this));
                    _this._logger.debug('Window visible');
                }
            });
            this.ctx = this.canvas.getContext('2d');
            if (!options.suppressHiDPIScaling) {
                this._initializeHiDpi();
            }
            if (!this.canvasElementId) {
                document.body.appendChild(this.canvas);
            }
        };
        Engine.prototype._intializeDisplayModePosition = function (options) {
            if (!options.position) {
                throw new Error('DisplayMode of Position was selected but no position option was given');
            }
            else {
                this.canvas.style.display = 'block';
                this.canvas.style.position = 'absolute';
                if (typeof options.position === 'string') {
                    var specifiedPosition = options.position.split(' ');
                    switch (specifiedPosition[0]) {
                        case 'top':
                            this.canvas.style.top = '0px';
                            break;
                        case 'bottom':
                            this.canvas.style.bottom = '0px';
                            break;
                        case 'middle':
                            this.canvas.style.top = '50%';
                            var offsetY = -this.halfDrawHeight;
                            this.canvas.style.marginTop = offsetY.toString();
                            break;
                        default:
                            throw new Error('Invalid Position Given');
                    }
                    if (specifiedPosition[1]) {
                        switch (specifiedPosition[1]) {
                            case 'left':
                                this.canvas.style.left = '0px';
                                break;
                            case 'right':
                                this.canvas.style.right = '0px';
                                break;
                            case 'center':
                                this.canvas.style.left = '50%';
                                var offsetX = -this.halfDrawWidth;
                                this.canvas.style.marginLeft = offsetX.toString();
                                break;
                            default:
                                throw new Error('Invalid Position Given');
                        }
                    }
                }
                else {
                    if (options.position.top) {
                        typeof options.position.top === 'number' ?
                            this.canvas.style.top = options.position.top.toString() + 'px' :
                            this.canvas.style.top = options.position.top;
                    }
                    if (options.position.right) {
                        typeof options.position.right === 'number' ?
                            this.canvas.style.right = options.position.right.toString() + 'px' :
                            this.canvas.style.right = options.position.right;
                    }
                    if (options.position.bottom) {
                        typeof options.position.bottom === 'number' ?
                            this.canvas.style.bottom = options.position.bottom.toString() + 'px' :
                            this.canvas.style.bottom = options.position.bottom;
                    }
                    if (options.position.left) {
                        typeof options.position.left === 'number' ?
                            this.canvas.style.left = options.position.left.toString() + 'px' :
                            this.canvas.style.left = options.position.left;
                    }
                }
            }
        };
        Engine.prototype._initializeHiDpi = function () {
            // Scale the canvas if needed
            if (this.isHiDpi) {
                var oldWidth = this.canvas.width;
                var oldHeight = this.canvas.height;
                this.canvas.width = oldWidth * this.pixelRatio;
                this.canvas.height = oldHeight * this.pixelRatio;
                this.canvas.style.width = oldWidth + 'px';
                this.canvas.style.height = oldHeight + 'px';
                this._logger.warn("Hi DPI screen detected, resetting canvas resolution from \n                           " + oldWidth + "x" + oldHeight + " to " + this.canvas.width + "x" + this.canvas.height + " \n                           css size will remain " + oldWidth + "x" + oldHeight);
                this.ctx.scale(this.pixelRatio, this.pixelRatio);
                this._logger.warn("Canvas drawing context was scaled by " + this.pixelRatio);
            }
        };
        /**
         * If supported by the browser, this will set the antialiasing flag on the
         * canvas. Set this to `false` if you want a 'jagged' pixel art look to your
         * image resources.
         * @param isSmooth  Set smoothing to true or false
         */
        Engine.prototype.setAntialiasing = function (isSmooth) {
            this._isSmoothingEnabled = isSmooth;
            var ctx = this.ctx;
            ctx.imageSmoothingEnabled = isSmooth;
            for (var _i = 0, _a = ['webkitImageSmoothingEnabled', 'mozImageSmoothingEnabled', 'msImageSmoothingEnabled']; _i < _a.length; _i++) {
                var smoothing = _a[_i];
                if (smoothing in ctx) {
                    ctx[smoothing] = isSmooth;
                }
            }
            ;
        };
        /**
         * Return the current smoothing status of the canvas
         */
        Engine.prototype.getAntialiasing = function () {
            return this.ctx.imageSmoothingEnabled ||
                this.ctx.webkitImageSmoothingEnabled ||
                this.ctx.mozImageSmoothingEnabled ||
                this.ctx.msImageSmoothingEnabled;
        };
        /**
         * Updates the entire state of the game
         * @param delta  Number of milliseconds elapsed since the last update.
         */
        Engine.prototype._update = function (delta) {
            if (this._isLoading) {
                // suspend updates untill loading is finished
                this._loader.update(this, delta);
                // Update input listeners
                this.input.keyboard.update();
                this.input.pointers.update();
                this.input.gamepads.update();
                return;
            }
            this.emit('preupdate', new Events_12.PreUpdateEvent(this, delta, this));
            // process engine level events
            this.currentScene.update(this, delta);
            // update animations
            this._animations = this._animations.filter(function (a) {
                return !a.animation.isDone();
            });
            // Update input listeners
            this.input.keyboard.update();
            this.input.pointers.update();
            this.input.gamepads.update();
            // Publish update event
            this.emit('postupdate', new Events_12.PostUpdateEvent(this, delta, this));
        };
        /**
         * Draws the entire game
         * @param delta  Number of milliseconds elapsed since the last draw.
         */
        Engine.prototype._draw = function (delta) {
            var ctx = this.ctx;
            this.emit('predraw', new Events_12.PreDrawEvent(ctx, delta, this));
            if (this._isLoading) {
                this._loader.draw(ctx, delta);
                // Drawing nothing else while loading
                return;
            }
            ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
            ctx.fillStyle = this.backgroundColor.toString();
            ctx.fillRect(0, 0, this.canvasWidth, this.canvasHeight);
            this.currentScene.draw(this.ctx, delta);
            // todo needs to be a better way of doing this
            var a = 0, len = this._animations.length;
            for (a; a < len; a++) {
                this._animations[a].animation.draw(ctx, this._animations[a].x, this._animations[a].y);
            }
            // Draw debug information
            if (this.isDebug) {
                this.ctx.font = 'Consolas';
                this.ctx.fillStyle = this.debugColor.toString();
                var keys = this.input.keyboard.getKeys();
                for (var j = 0; j < keys.length; j++) {
                    this.ctx.fillText(keys[j].toString() + ' : ' + (Input.Keys[keys[j]] ? Input.Keys[keys[j]] : 'Not Mapped'), 100, 10 * j + 10);
                }
                this.ctx.fillText('FPS:' + this.stats.currFrame.fps.toFixed(2).toString(), 10, 10);
            }
            // Post processing
            for (var i = 0; i < this.postProcessors.length; i++) {
                this.postProcessors[i].process(this.ctx.getImageData(0, 0, this.canvasWidth, this.canvasHeight), this.ctx);
            }
            this.emit('postdraw', new Events_12.PostDrawEvent(ctx, delta, this));
        };
        /**
         * Starts the internal game loop for Excalibur after loading
         * any provided assets.
         * @param loader  Optional [[ILoader]] to use to load resources. The default loader is [[Loader]], override to provide your own
         * custom loader.
         */
        Engine.prototype.start = function (loader) {
            var _this = this;
            if (!this._compatible) {
                var promise = new Promises_8.Promise();
                return promise.reject('Excalibur is incompatible with your browser');
            }
            var loadingComplete;
            if (loader) {
                this._loader = loader;
                this._loader.wireEngine(this);
                loadingComplete = this.load(this._loader);
            }
            else {
                loadingComplete = Promises_8.Promise.resolve();
            }
            loadingComplete.then(function () {
                _this.emit('start', new Events_12.GameStartEvent(_this));
            });
            if (!this._hasStarted) {
                this._hasStarted = true;
                this._logger.debug('Starting game...');
                Engine.createMainLoop(this, window.requestAnimationFrame, Date.now)();
                this._logger.debug('Game started');
            }
            else {
                // Game already started;
            }
            return loadingComplete;
        };
        Engine.createMainLoop = function (game, raf, nowFn) {
            var lastTime = nowFn();
            return function mainloop() {
                if (!game._hasStarted) {
                    return;
                }
                try {
                    game._requestId = raf(mainloop);
                    game.emit('preframe', new Events_12.PreFrameEvent(game, game.stats.prevFrame));
                    // Get the time to calculate time-elapsed
                    var now = nowFn();
                    var elapsed = Math.floor(now - lastTime) || 1;
                    // Resolves issue #138 if the game has been paused, or blurred for 
                    // more than a 200 milliseconds, reset elapsed time to 1. This improves reliability 
                    // and provides more expected behavior when the engine comes back
                    // into focus
                    if (elapsed > 200) {
                        elapsed = 1;
                    }
                    var delta = elapsed * game.timescale;
                    // reset frame stats (reuse existing instances)
                    var frameId = game.stats.prevFrame.id + 1;
                    game.stats.prevFrame.reset(game.stats.currFrame);
                    game.stats.currFrame.reset();
                    game.stats.currFrame.id = frameId;
                    game.stats.currFrame.delta = delta;
                    game.stats.currFrame.fps = 1.0 / (delta / 1000);
                    var beforeUpdate = nowFn();
                    game._update(delta);
                    var afterUpdate = nowFn();
                    game._draw(delta);
                    var afterDraw = nowFn();
                    game.stats.currFrame.duration.update = afterUpdate - beforeUpdate;
                    game.stats.currFrame.duration.draw = afterDraw - afterUpdate;
                    lastTime = now;
                    game.emit('postframe', new Events_12.PostFrameEvent(game, game.stats.currFrame));
                }
                catch (e) {
                    window.cancelAnimationFrame(game._requestId);
                    game.stop();
                    game.onFatalException(e);
                }
            };
        };
        /**
         * Stops Excalibur's main loop, useful for pausing the game.
         */
        Engine.prototype.stop = function () {
            if (this._hasStarted) {
                this.emit('stop', new Events_12.GameStopEvent(this));
                this._hasStarted = false;
                this._logger.debug('Game stopped');
            }
        };
        /**
         * Returns the Engine's Running status, Useful for checking whether engine is running or paused.
         */
        Engine.prototype.isPaused = function () {
            return !(this._hasStarted);
        };
        /**
         * Takes a screen shot of the current viewport and returns it as an
         * HTML Image Element.
         */
        Engine.prototype.screenshot = function () {
            var result = new Image();
            var raw = this.canvas.toDataURL('image/png');
            result.src = raw;
            return result;
        };
        /**
         * Another option available to you to load resources into the game.
         * Immediately after calling this the game will pause and the loading screen
         * will appear.
         * @param loader  Some [[ILoadable]] such as a [[Loader]] collection, [[Sound]], or [[Texture]].
         */
        Engine.prototype.load = function (loader) {
            var _this = this;
            var complete = new Promises_8.Promise();
            this._isLoading = true;
            loader.load().then(function () {
                setTimeout(function () {
                    _this._isLoading = false;
                    complete.resolve();
                }, 500);
            });
            return complete;
        };
        return Engine;
    }(Class_9.Class));
    /**
     * Default [[IEngineOptions]]
     */
    Engine._DefaultEngineOptions = {
        width: 0,
        height: 0,
        canvasElementId: '',
        pointerScope: Input.PointerScope.Document,
        suppressConsoleBootMessage: null,
        suppressMinimumBrowserFeatureDetection: null,
        suppressHiDPIScaling: null,
        scrollPreventionMode: ScrollPreventionMode.Canvas,
        backgroundColor: Color_19.Color.fromHex('#2185d0') // Excalibur blue
    };
    exports.Engine = Engine;
    /**
     * @internal
     */
    var AnimationNode = (function () {
        function AnimationNode(animation, x, y) {
            this.animation = animation;
            this.x = x;
            this.y = y;
        }
        return AnimationNode;
    }());
});
define("UIActor", ["require", "exports", "Algebra", "Actor", "Traits/Index"], function (require, exports, Algebra_23, Actor_13, Traits) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Helper [[Actor]] primitive for drawing UI's, optimized for UI drawing. Does
     * not participate in collisions. Drawn on top of all other actors.
     */
    var UIActor = (function (_super) {
        __extends(UIActor, _super);
        /**
         * @param x       The starting x coordinate of the actor
         * @param y       The starting y coordinate of the actor
         * @param width   The starting width of the actor
         * @param height  The starting height of the actor
         */
        function UIActor(xOrConfig, y, width, height) {
            var _this = this;
            if (typeof (xOrConfig !== 'object')) {
                _this = _super.call(this, xOrConfig, y, width, height) || this;
            }
            else {
                _this = _super.call(this, xOrConfig) || this;
            }
            _this.traits = [];
            _this.traits.push(new Traits.CapturePointer());
            _this.anchor.setTo(0, 0);
            _this.collisionType = Actor_13.CollisionType.PreventCollision;
            _this.enableCapturePointer = true;
            return _this;
        }
        UIActor.prototype.onInitialize = function (engine) {
            this._engine = engine;
        };
        UIActor.prototype.contains = function (x, y, useWorld) {
            if (useWorld === void 0) { useWorld = true; }
            if (useWorld) {
                return _super.prototype.contains.call(this, x, y);
            }
            var coords = this._engine.worldToScreenCoordinates(new Algebra_23.Vector(x, y));
            return _super.prototype.contains.call(this, coords.x, coords.y);
        };
        return UIActor;
    }(Actor_13.Actor));
    exports.UIActor = UIActor;
});
define("Util/Actors", ["require", "exports", "UIActor", "Label", "Trigger"], function (require, exports, UIActor_4, Label_3, Trigger_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isVanillaActor(actor) {
        return !(actor instanceof UIActor_4.UIActor) &&
            !(actor instanceof Trigger_2.Trigger) &&
            !(actor instanceof Label_3.Label);
    }
    exports.isVanillaActor = isVanillaActor;
    function isUIActor(actor) {
        return actor instanceof UIActor_4.UIActor;
    }
    exports.isUIActor = isUIActor;
});
define("Scene", ["require", "exports", "UIActor", "Physics", "Events", "Util/Log", "Timer", "Collision/DynamicTreeCollisionBroadphase", "Util/SortedList", "Group", "TileMap", "Camera", "Actor", "Class", "Util/Util", "Util/Actors", "Trigger"], function (require, exports, UIActor_5, Physics_12, Events_13, Log_15, Timer_3, DynamicTreeCollisionBroadphase_2, SortedList_2, Group_2, TileMap_3, Camera_2, Actor_14, Class_10, Util, ActorUtils, Trigger_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * [[Actor|Actors]] are composed together into groupings called Scenes in
     * Excalibur. The metaphor models the same idea behind real world
     * actors in a scene. Only actors in scenes will be updated and drawn.
     *
     * Typical usages of a scene include: levels, menus, loading screens, etc.
     *
     * [[include:Scenes.md]]
     */
    var Scene = (function (_super) {
        __extends(Scene, _super);
        function Scene(engine) {
            var _this = _super.call(this) || this;
            /**
             * The actors in the current scene
             */
            _this.actors = [];
            /**
             * The triggers in the current scene
             */
            _this.triggers = [];
            /**
             * The [[TileMap]]s in the scene, if any
             */
            _this.tileMaps = [];
            /**
             * The [[Group]]s in the scene, if any
             */
            _this.groups = {};
            /**
             * The [[UIActor]]s in a scene, if any; these are drawn last
             */
            _this.uiActors = [];
            _this._isInitialized = false;
            _this._sortedDrawingTree = new SortedList_2.SortedList(Actor_14.Actor.prototype.getZIndex);
            _this._broadphase = new DynamicTreeCollisionBroadphase_2.DynamicTreeCollisionBroadphase();
            _this._killQueue = [];
            _this._triggerKillQueue = [];
            _this._timers = [];
            _this._cancelQueue = [];
            _this._logger = Log_15.Logger.getInstance();
            _this.camera = new Camera_2.BaseCamera();
            if (engine) {
                _this.camera.x = engine.halfDrawWidth;
                _this.camera.y = engine.halfDrawHeight;
            }
            return _this;
        }
        Scene.prototype.on = function (eventName, handler) {
            _super.prototype.on.call(this, eventName, handler);
        };
        /**
         * This is called before the first update of the [[Scene]]. Initializes scene members like the camera. This method is meant to be
         * overridden. This is where initialization of child actors should take place.
         */
        Scene.prototype.onInitialize = function (engine) {
            // will be overridden
            if (this.camera) {
                this.camera.x = engine.halfDrawWidth;
                this.camera.y = engine.halfDrawHeight;
            }
            this._logger.debug('Scene.onInitialize', this, engine);
        };
        /**
         * This is called when the scene is made active and started. It is meant to be overriden,
         * this is where you should setup any DOM UI or event handlers needed for the scene.
         */
        Scene.prototype.onActivate = function () {
            // will be overridden
            this._logger.debug('Scene.onActivate', this);
        };
        /**
         * This is called when the scene is made transitioned away from and stopped. It is meant to be overriden,
         * this is where you should cleanup any DOM UI or event handlers needed for the scene.
         */
        Scene.prototype.onDeactivate = function () {
            // will be overridden
            this._logger.debug('Scene.onDeactivate', this);
        };
        /**
         * Initializes actors in the scene
         */
        Scene.prototype._initializeChildren = function () {
            for (var _i = 0, _a = this.actors; _i < _a.length; _i++) {
                var child = _a[_i];
                child._initialize(this.engine);
            }
        };
        Object.defineProperty(Scene.prototype, "isInitialized", {
            /**
             * Gets whether or not the [[Scene]] has been initialized
             */
            get: function () {
                return this._isInitialized;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Initializes the scene before the first update, meant to be called by engine not by users of
         * Excalibur
         * @internal
         */
        Scene.prototype._initialize = function (engine) {
            if (!this.isInitialized) {
                this.onInitialize.call(this, engine);
                this.eventDispatcher.emit('initialize', new Events_13.InitializeEvent(engine, this));
                this._initializeChildren();
                this._isInitialized = true;
            }
        };
        /**
         * Updates all the actors and timers in the scene. Called by the [[Engine]].
         * @param engine  Reference to the current Engine
         * @param delta   The number of milliseconds since the last update
         */
        Scene.prototype.update = function (engine, delta) {
            this.emit('preupdate', new Events_13.PreUpdateEvent(engine, delta, this));
            var i, len;
            // Remove timers in the cancel queue before updating them
            for (i = 0, len = this._cancelQueue.length; i < len; i++) {
                this.removeTimer(this._cancelQueue[i]);
            }
            this._cancelQueue.length = 0;
            // Cycle through timers updating timers
            for (var _i = 0, _a = this._timers; _i < _a.length; _i++) {
                var timer = _a[_i];
                timer.update(delta);
            }
            ;
            // Cycle through actors updating UI actors
            for (i = 0, len = this.uiActors.length; i < len; i++) {
                this.uiActors[i].update(engine, delta);
            }
            // Cycle through actors updating tile maps
            for (i = 0, len = this.tileMaps.length; i < len; i++) {
                this.tileMaps[i].update(engine, delta);
            }
            // Cycle through actors updating actors
            for (i = 0, len = this.actors.length; i < len; i++) {
                this.actors[i].update(engine, delta);
            }
            // Cycle through triggers updating
            for (i = 0, len = this.triggers.length; i < len; i++) {
                this.triggers[i].update(engine, delta);
            }
            this._collectActorStats(engine);
            // Run the broadphase and narrowphase
            if (this._broadphase && Physics_12.Physics.enabled) {
                var beforeBroadphase = Date.now();
                this._broadphase.update(this.actors, delta);
                var pairs = this._broadphase.broadphase(this.actors, delta, engine.stats.currFrame);
                var afterBroadphase = Date.now();
                var beforeNarrowphase = Date.now();
                var iter = Physics_12.Physics.collisionPasses;
                var collisionDelta = delta / iter;
                while (iter > 0) {
                    // Run the narrowphase
                    pairs = this._broadphase.narrowphase(pairs, engine.stats.currFrame);
                    // Run collision resolution strategy
                    pairs = this._broadphase.resolve(pairs, collisionDelta, Physics_12.Physics.collisionResolutionStrategy);
                    this._broadphase.runCollisionStartEnd(pairs);
                    iter--;
                }
                var afterNarrowphase = Date.now();
                engine.stats.currFrame.physics.broadphase = afterBroadphase - beforeBroadphase;
                engine.stats.currFrame.physics.narrowphase = afterNarrowphase - beforeNarrowphase;
            }
            engine.stats.currFrame.actors.killed = this._killQueue.length + this._triggerKillQueue.length;
            this._processKillQueue(this._killQueue, this.actors);
            this._processKillQueue(this._triggerKillQueue, this.triggers);
            if (this.camera) {
                this.camera.update(engine, delta);
            }
            this.emit('postupdate', new Events_13.PostUpdateEvent(engine, delta, this));
        };
        Scene.prototype._processKillQueue = function (killQueue, collection) {
            // Remove actors from scene graph after being killed
            var actorIndex;
            for (var _i = 0, killQueue_1 = killQueue; _i < killQueue_1.length; _i++) {
                var killed = killQueue_1[_i];
                actorIndex = collection.indexOf(killed);
                if (actorIndex > -1) {
                    this._sortedDrawingTree.removeByComparable(killed);
                    collection.splice(actorIndex, 1);
                }
            }
            killQueue.length = 0;
        };
        /**
         * Draws all the actors in the Scene. Called by the [[Engine]].
         * @param ctx    The current rendering context
         * @param delta  The number of milliseconds since the last draw
         */
        Scene.prototype.draw = function (ctx, delta) {
            this.emit('predraw', new Events_13.PreDrawEvent(ctx, delta, this));
            ctx.save();
            if (this.camera) {
                this.camera.draw(ctx);
            }
            var i, len;
            for (i = 0, len = this.tileMaps.length; i < len; i++) {
                this.tileMaps[i].draw(ctx, delta);
            }
            var sortedChildren = this._sortedDrawingTree.list();
            for (i = 0, len = sortedChildren.length; i < len; i++) {
                // only draw actors that are visible and on screen
                if (sortedChildren[i].visible && !sortedChildren[i].isOffScreen) {
                    sortedChildren[i].draw(ctx, delta);
                }
            }
            if (this.engine && this.engine.isDebug) {
                ctx.strokeStyle = 'yellow';
                this.debugDraw(ctx);
            }
            ctx.restore();
            for (i = 0, len = this.uiActors.length; i < len; i++) {
                // only draw ui actors that are visible and on screen
                if (this.uiActors[i].visible) {
                    this.uiActors[i].draw(ctx, delta);
                }
            }
            if (this.engine && this.engine.isDebug) {
                for (i = 0, len = this.uiActors.length; i < len; i++) {
                    this.uiActors[i].debugDraw(ctx);
                }
            }
            this.emit('postdraw', new Events_13.PostDrawEvent(ctx, delta, this));
        };
        /**
         * Draws all the actors' debug information in the Scene. Called by the [[Engine]].
         * @param ctx  The current rendering context
         */
        /* istanbul ignore next */
        Scene.prototype.debugDraw = function (ctx) {
            this.emit('predebugdraw', new Events_13.PreDebugDrawEvent(ctx, this));
            var i, len;
            for (i = 0, len = this.tileMaps.length; i < len; i++) {
                this.tileMaps[i].debugDraw(ctx);
            }
            for (i = 0, len = this.actors.length; i < len; i++) {
                this.actors[i].debugDraw(ctx);
            }
            for (i = 0, len = this.triggers.length; i < len; i++) {
                this.triggers[i].debugDraw(ctx);
            }
            this._broadphase.debugDraw(ctx, 20);
            this.camera.debugDraw(ctx);
            this.emit('postdebugdraw', new Events_13.PostDebugDrawEvent(ctx, this));
        };
        /**
         * Checks whether an actor is contained in this scene or not
         */
        Scene.prototype.contains = function (actor) {
            return this.actors.indexOf(actor) > -1;
        };
        Scene.prototype.add = function (entity) {
            if (entity instanceof Actor_14.Actor) {
                entity.unkill();
            }
            if (entity instanceof UIActor_5.UIActor) {
                if (!Util.contains(this.uiActors, entity)) {
                    this.addUIActor(entity);
                }
                return;
            }
            if (entity instanceof Actor_14.Actor) {
                if (!Util.contains(this.actors, entity)) {
                    this._addChild(entity);
                }
                return;
            }
            if (entity instanceof Timer_3.Timer) {
                if (!Util.contains(this._timers, entity)) {
                    this.addTimer(entity);
                }
                return;
            }
            if (entity instanceof TileMap_3.TileMap) {
                if (!Util.contains(this.tileMaps, entity)) {
                    this.addTileMap(entity);
                }
            }
        };
        Scene.prototype.remove = function (entity) {
            if (entity instanceof UIActor_5.UIActor) {
                this.removeUIActor(entity);
                return;
            }
            if (entity instanceof Actor_14.Actor) {
                this._broadphase.untrack(entity.body);
                this._removeChild(entity);
            }
            if (entity instanceof Timer_3.Timer) {
                this.removeTimer(entity);
            }
            if (entity instanceof TileMap_3.TileMap) {
                this.removeTileMap(entity);
            }
        };
        /**
         * Adds (any) actor to act as a piece of UI, meaning it is always positioned
         * in screen coordinates. UI actors do not participate in collisions.
         * @todo Should this be `UIActor` only?
         */
        Scene.prototype.addUIActor = function (actor) {
            this.uiActors.push(actor);
            actor.scene = this;
        };
        /**
         * Removes an actor as a piece of UI
         */
        Scene.prototype.removeUIActor = function (actor) {
            var index = this.uiActors.indexOf(actor);
            if (index > -1) {
                this.uiActors.splice(index, 1);
            }
        };
        /**
         * Adds an actor to the scene, once this is done the actor will be drawn and updated.
         */
        Scene.prototype._addChild = function (actor) {
            this._broadphase.track(actor.body);
            actor.scene = this;
            if (actor instanceof Trigger_3.Trigger) {
                this.triggers.push(actor);
            }
            else {
                this.actors.push(actor);
            }
            this._sortedDrawingTree.add(actor);
        };
        /**
         * Adds a [[TileMap]] to the scene, once this is done the TileMap will be drawn and updated.
         */
        Scene.prototype.addTileMap = function (tileMap) {
            this.tileMaps.push(tileMap);
        };
        /**
         * Removes a [[TileMap]] from the scene, it will no longer be drawn or updated.
         */
        Scene.prototype.removeTileMap = function (tileMap) {
            var index = this.tileMaps.indexOf(tileMap);
            if (index > -1) {
                this.tileMaps.splice(index, 1);
            }
        };
        /**
         * Removes an actor from the scene, it will no longer be drawn or updated.
         */
        Scene.prototype._removeChild = function (actor) {
            this._broadphase.untrack(actor.body);
            if (actor instanceof Trigger_3.Trigger) {
                this._triggerKillQueue.push(actor);
            }
            else {
                this._killQueue.push(actor);
            }
            actor.parent = null;
        };
        /**
         * Adds a [[Timer]] to the scene
         * @param timer  The timer to add
         */
        Scene.prototype.addTimer = function (timer) {
            this._timers.push(timer);
            timer.scene = this;
            return timer;
        };
        /**
         * Removes a [[Timer]] from the scene.
         * @warning Can be dangerous, use [[cancelTimer]] instead
         * @param timer  The timer to remove
         */
        Scene.prototype.removeTimer = function (timer) {
            var i = this._timers.indexOf(timer);
            if (i !== -1) {
                this._timers.splice(i, 1);
            }
            return timer;
        };
        /**
         * Cancels a [[Timer]], removing it from the scene nicely
         * @param timer  The timer to cancel
         */
        Scene.prototype.cancelTimer = function (timer) {
            this._cancelQueue.push(timer);
            return timer;
        };
        /**
         * Tests whether a [[Timer]] is active in the scene
         */
        Scene.prototype.isTimerActive = function (timer) {
            return (this._timers.indexOf(timer) > -1 && !timer.complete);
        };
        /**
         * Creates and adds a [[Group]] to the scene with a name
         */
        Scene.prototype.createGroup = function (name) {
            return new Group_2.Group(name, this);
        };
        /**
         * Returns a [[Group]] by name
         */
        Scene.prototype.getGroup = function (name) {
            return this.groups[name];
        };
        Scene.prototype.removeGroup = function (group) {
            if (typeof group === 'string') {
                delete this.groups[group];
            }
            else if (group instanceof Group_2.Group) {
                delete this.groups[group.name];
            }
            else {
                this._logger.error('Invalid arguments to removeGroup', group);
            }
        };
        /**
         * Removes the given actor from the sorted drawing tree
         */
        Scene.prototype.cleanupDrawTree = function (actor) {
            this._sortedDrawingTree.removeByComparable(actor);
        };
        /**
         * Updates the given actor's position in the sorted drawing tree
         */
        Scene.prototype.updateDrawTree = function (actor) {
            this._sortedDrawingTree.add(actor);
        };
        Scene.prototype._collectActorStats = function (engine) {
            for (var _i = 0, _a = this.uiActors; _i < _a.length; _i++) {
                var _ui = _a[_i];
                engine.stats.currFrame.actors.ui++;
            }
            for (var _b = 0, _c = this.actors; _b < _c.length; _b++) {
                var actor = _c[_b];
                engine.stats.currFrame.actors.alive++;
                for (var _d = 0, _e = actor.children; _d < _e.length; _d++) {
                    var child = _e[_d];
                    if (ActorUtils.isUIActor(child)) {
                        engine.stats.currFrame.actors.ui++;
                    }
                    else {
                        engine.stats.currFrame.actors.alive++;
                    }
                }
            }
        };
        return Scene;
    }(Class_10.Class));
    exports.Scene = Scene;
});
define("Events", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Base event type in Excalibur that all other event types derive from. Not all event types are thrown on all Excalibur game objects,
     * some events are unique to a type, others are not.
     *
     */
    var GameEvent = (function () {
        function GameEvent() {
        }
        return GameEvent;
    }());
    exports.GameEvent = GameEvent;
    /**
     * The 'kill' event is emitted on actors when it is killed. The target is the actor that was killed.
     */
    var KillEvent = (function (_super) {
        __extends(KillEvent, _super);
        function KillEvent(target) {
            var _this = _super.call(this) || this;
            _this.target = target;
            return _this;
        }
        return KillEvent;
    }(GameEvent));
    exports.KillEvent = KillEvent;
    /**
     * The 'start' event is emitted on engine when has started and is ready for interaction.
     */
    var GameStartEvent = (function (_super) {
        __extends(GameStartEvent, _super);
        function GameStartEvent(target) {
            var _this = _super.call(this) || this;
            _this.target = target;
            return _this;
        }
        return GameStartEvent;
    }(GameEvent));
    exports.GameStartEvent = GameStartEvent;
    /**
     * The 'stop' event is emitted on engine when has been stopped and will no longer take input, update or draw.
     */
    var GameStopEvent = (function (_super) {
        __extends(GameStopEvent, _super);
        function GameStopEvent(target) {
            var _this = _super.call(this) || this;
            _this.target = target;
            return _this;
        }
        return GameStopEvent;
    }(GameEvent));
    exports.GameStopEvent = GameStopEvent;
    /**
     * The 'predraw' event is emitted on actors, scenes, and engine before drawing starts. Actors' predraw happens inside their graphics
     * transform so that all drawing takes place with the actor as the origin.
     *
     */
    var PreDrawEvent = (function (_super) {
        __extends(PreDrawEvent, _super);
        function PreDrawEvent(ctx, delta, target) {
            var _this = _super.call(this) || this;
            _this.ctx = ctx;
            _this.delta = delta;
            _this.target = target;
            return _this;
        }
        return PreDrawEvent;
    }(GameEvent));
    exports.PreDrawEvent = PreDrawEvent;
    /**
     * The 'postdraw' event is emitted on actors, scenes, and engine after drawing finishes. Actors' postdraw happens inside their graphics
     * transform so that all drawing takes place with the actor as the origin.
     *
     */
    var PostDrawEvent = (function (_super) {
        __extends(PostDrawEvent, _super);
        function PostDrawEvent(ctx, delta, target) {
            var _this = _super.call(this) || this;
            _this.ctx = ctx;
            _this.delta = delta;
            _this.target = target;
            return _this;
        }
        return PostDrawEvent;
    }(GameEvent));
    exports.PostDrawEvent = PostDrawEvent;
    /**
     * The 'predebugdraw' event is emitted on actors, scenes, and engine before debug drawing starts.
     */
    var PreDebugDrawEvent = (function (_super) {
        __extends(PreDebugDrawEvent, _super);
        function PreDebugDrawEvent(ctx, target) {
            var _this = _super.call(this) || this;
            _this.ctx = ctx;
            _this.target = target;
            return _this;
        }
        return PreDebugDrawEvent;
    }(GameEvent));
    exports.PreDebugDrawEvent = PreDebugDrawEvent;
    /**
     * The 'postdebugdraw' event is emitted on actors, scenes, and engine after debug drawing starts.
     */
    var PostDebugDrawEvent = (function (_super) {
        __extends(PostDebugDrawEvent, _super);
        function PostDebugDrawEvent(ctx, target) {
            var _this = _super.call(this) || this;
            _this.ctx = ctx;
            _this.target = target;
            return _this;
        }
        return PostDebugDrawEvent;
    }(GameEvent));
    exports.PostDebugDrawEvent = PostDebugDrawEvent;
    /**
     * The 'preupdate' event is emitted on actors, scenes, and engine before the update starts.
     */
    var PreUpdateEvent = (function (_super) {
        __extends(PreUpdateEvent, _super);
        function PreUpdateEvent(engine, delta, target) {
            var _this = _super.call(this) || this;
            _this.engine = engine;
            _this.delta = delta;
            _this.target = target;
            return _this;
        }
        return PreUpdateEvent;
    }(GameEvent));
    exports.PreUpdateEvent = PreUpdateEvent;
    /**
     * The 'postupdate' event is emitted on actors, scenes, and engine after the update ends.
     */
    var PostUpdateEvent = (function (_super) {
        __extends(PostUpdateEvent, _super);
        function PostUpdateEvent(engine, delta, target) {
            var _this = _super.call(this) || this;
            _this.engine = engine;
            _this.delta = delta;
            _this.target = target;
            return _this;
        }
        return PostUpdateEvent;
    }(GameEvent));
    exports.PostUpdateEvent = PostUpdateEvent;
    /**
     * The 'preframe' event is emitted on the engine, before the frame begins.
     */
    var PreFrameEvent = (function (_super) {
        __extends(PreFrameEvent, _super);
        function PreFrameEvent(engine, prevStats) {
            var _this = _super.call(this) || this;
            _this.engine = engine;
            _this.prevStats = prevStats;
            _this.target = engine;
            return _this;
        }
        return PreFrameEvent;
    }(GameEvent));
    exports.PreFrameEvent = PreFrameEvent;
    /**
     * The 'postframe' event is emitted on the engine, after a frame ends.
     */
    var PostFrameEvent = (function (_super) {
        __extends(PostFrameEvent, _super);
        function PostFrameEvent(engine, stats) {
            var _this = _super.call(this) || this;
            _this.engine = engine;
            _this.stats = stats;
            _this.target = engine;
            return _this;
        }
        return PostFrameEvent;
    }(GameEvent));
    exports.PostFrameEvent = PostFrameEvent;
    /**
     * Event received when a gamepad is connected to Excalibur. [[Gamepads]] receives this event.
     */
    var GamepadConnectEvent = (function (_super) {
        __extends(GamepadConnectEvent, _super);
        function GamepadConnectEvent(index, gamepad) {
            var _this = _super.call(this) || this;
            _this.index = index;
            _this.gamepad = gamepad;
            _this.target = gamepad;
            return _this;
        }
        return GamepadConnectEvent;
    }(GameEvent));
    exports.GamepadConnectEvent = GamepadConnectEvent;
    /**
     * Event received when a gamepad is disconnected from Excalibur. [[Gamepads]] receives this event.
     */
    var GamepadDisconnectEvent = (function (_super) {
        __extends(GamepadDisconnectEvent, _super);
        function GamepadDisconnectEvent(index, gamepad) {
            var _this = _super.call(this) || this;
            _this.index = index;
            _this.gamepad = gamepad;
            _this.target = gamepad;
            return _this;
        }
        return GamepadDisconnectEvent;
    }(GameEvent));
    exports.GamepadDisconnectEvent = GamepadDisconnectEvent;
    /**
     * Gamepad button event. See [[Gamepads]] for information on responding to controller input. [[Gamepad]] instances receive this event;
     */
    var GamepadButtonEvent = (function (_super) {
        __extends(GamepadButtonEvent, _super);
        /**
         * @param button  The Gamepad button
         * @param value   A numeric value between 0 and 1
         */
        function GamepadButtonEvent(button, value, target) {
            var _this = _super.call(this) || this;
            _this.button = button;
            _this.value = value;
            _this.target = target;
            return _this;
        }
        return GamepadButtonEvent;
    }(GameEvent));
    exports.GamepadButtonEvent = GamepadButtonEvent;
    /**
     * Gamepad axis event. See [[Gamepads]] for information on responding to controller input. [[Gamepad]] instances receive this event;
     */
    var GamepadAxisEvent = (function (_super) {
        __extends(GamepadAxisEvent, _super);
        /**
         * @param axis  The Gamepad axis
         * @param value A numeric value between -1 and 1
         */
        function GamepadAxisEvent(axis, value, target) {
            var _this = _super.call(this) || this;
            _this.axis = axis;
            _this.value = value;
            _this.target = target;
            return _this;
        }
        return GamepadAxisEvent;
    }(GameEvent));
    exports.GamepadAxisEvent = GamepadAxisEvent;
    /**
     * Subscribe event thrown when handlers for events other than subscribe are added. Meta event that is received by
     * [[EventDispatcher|event dispatchers]].
     */
    var SubscribeEvent = (function (_super) {
        __extends(SubscribeEvent, _super);
        function SubscribeEvent(topic, handler) {
            var _this = _super.call(this) || this;
            _this.topic = topic;
            _this.handler = handler;
            return _this;
        }
        return SubscribeEvent;
    }(GameEvent));
    exports.SubscribeEvent = SubscribeEvent;
    /**
     * Unsubscribe event thrown when handlers for events other than unsubscribe are removed. Meta event that is received by
     * [[EventDispatcher|event dispatchers]].
     */
    var UnsubscribeEvent = (function (_super) {
        __extends(UnsubscribeEvent, _super);
        function UnsubscribeEvent(topic, handler) {
            var _this = _super.call(this) || this;
            _this.topic = topic;
            _this.handler = handler;
            return _this;
        }
        return UnsubscribeEvent;
    }(GameEvent));
    exports.UnsubscribeEvent = UnsubscribeEvent;
    /**
     * Event received by the [[Engine]] when the browser window is visible on a screen.
     */
    var VisibleEvent = (function (_super) {
        __extends(VisibleEvent, _super);
        function VisibleEvent(target) {
            var _this = _super.call(this) || this;
            _this.target = target;
            return _this;
        }
        return VisibleEvent;
    }(GameEvent));
    exports.VisibleEvent = VisibleEvent;
    /**
     * Event received by the [[Engine]] when the browser window is hidden from all screens.
     */
    var HiddenEvent = (function (_super) {
        __extends(HiddenEvent, _super);
        function HiddenEvent(target) {
            var _this = _super.call(this) || this;
            _this.target = target;
            return _this;
        }
        return HiddenEvent;
    }(GameEvent));
    exports.HiddenEvent = HiddenEvent;
    /**
     * Event thrown on an [[Actor|actor]] when a collision will occur this frame if it resolves
     */
    var PreCollisionEvent = (function (_super) {
        __extends(PreCollisionEvent, _super);
        /**
         * @param actor         The actor the event was thrown on
         * @param other         The actor that will collided with the current actor
         * @param side          The side that will be collided with the current actor
         * @param intersection  Intersection vector
         */
        function PreCollisionEvent(actor, other, side, intersection) {
            var _this = _super.call(this) || this;
            _this.actor = actor;
            _this.other = other;
            _this.side = side;
            _this.intersection = intersection;
            _this.target = actor;
            return _this;
        }
        return PreCollisionEvent;
    }(GameEvent));
    exports.PreCollisionEvent = PreCollisionEvent;
    /**
     * Event thrown on an [[Actor|actor]] when a collision has been resolved (body reacted) this frame
     */
    var PostCollisionEvent = (function (_super) {
        __extends(PostCollisionEvent, _super);
        /**
         * @param actor         The actor the event was thrown on
         * @param other         The actor that did collide with the current actor
         * @param side          The side that did collide with the current actor
         * @param intersection  Intersection vector
         */
        function PostCollisionEvent(actor, other, side, intersection) {
            var _this = _super.call(this) || this;
            _this.actor = actor;
            _this.other = other;
            _this.side = side;
            _this.intersection = intersection;
            _this.target = actor;
            return _this;
        }
        return PostCollisionEvent;
    }(GameEvent));
    exports.PostCollisionEvent = PostCollisionEvent;
    /**
     * Event thrown the first time an [[Actor|actor]] collides with another, after an actor is in contact normal collision events are fired.
     */
    var CollisionStartEvent = (function (_super) {
        __extends(CollisionStartEvent, _super);
        /**
         *
         */
        function CollisionStartEvent(actor, other, pair) {
            var _this = _super.call(this) || this;
            _this.actor = actor;
            _this.other = other;
            _this.pair = pair;
            _this.target = actor;
            return _this;
        }
        return CollisionStartEvent;
    }(GameEvent));
    exports.CollisionStartEvent = CollisionStartEvent;
    /**
     * Event thrown when the [[Actor|actor]] is no longer colliding with another
     */
    var CollisionEndEvent = (function (_super) {
        __extends(CollisionEndEvent, _super);
        /**
         *
         */
        function CollisionEndEvent(actor, other) {
            var _this = _super.call(this) || this;
            _this.actor = actor;
            _this.other = other;
            _this.target = actor;
            return _this;
        }
        return CollisionEndEvent;
    }(GameEvent));
    exports.CollisionEndEvent = CollisionEndEvent;
    /**
     * Event thrown on an [[Actor]] and a [[Scene]] only once before the first update call
     */
    var InitializeEvent = (function (_super) {
        __extends(InitializeEvent, _super);
        /**
         * @param engine  The reference to the current engine
         */
        function InitializeEvent(engine, target) {
            var _this = _super.call(this) || this;
            _this.engine = engine;
            _this.target = target;
            return _this;
        }
        return InitializeEvent;
    }(GameEvent));
    exports.InitializeEvent = InitializeEvent;
    /**
     * Event thrown on a [[Scene]] on activation
     */
    var ActivateEvent = (function (_super) {
        __extends(ActivateEvent, _super);
        /**
         * @param oldScene  The reference to the old scene
         */
        function ActivateEvent(oldScene, target) {
            var _this = _super.call(this) || this;
            _this.oldScene = oldScene;
            _this.target = target;
            return _this;
        }
        return ActivateEvent;
    }(GameEvent));
    exports.ActivateEvent = ActivateEvent;
    /**
     * Event thrown on a [[Scene]] on deactivation
     */
    var DeactivateEvent = (function (_super) {
        __extends(DeactivateEvent, _super);
        /**
         * @param newScene  The reference to the new scene
         */
        function DeactivateEvent(newScene, target) {
            var _this = _super.call(this) || this;
            _this.newScene = newScene;
            _this.target = target;
            return _this;
        }
        return DeactivateEvent;
    }(GameEvent));
    exports.DeactivateEvent = DeactivateEvent;
    /**
     * Event thrown on an [[Actor]] when it completely leaves the screen.
     */
    var ExitViewPortEvent = (function (_super) {
        __extends(ExitViewPortEvent, _super);
        function ExitViewPortEvent(target) {
            var _this = _super.call(this) || this;
            _this.target = target;
            return _this;
        }
        return ExitViewPortEvent;
    }(GameEvent));
    exports.ExitViewPortEvent = ExitViewPortEvent;
    /**
     * Event thrown on an [[Actor]] when it completely leaves the screen.
     */
    var EnterViewPortEvent = (function (_super) {
        __extends(EnterViewPortEvent, _super);
        function EnterViewPortEvent(target) {
            var _this = _super.call(this) || this;
            _this.target = target;
            return _this;
        }
        return EnterViewPortEvent;
    }(GameEvent));
    exports.EnterViewPortEvent = EnterViewPortEvent;
    var EnterTriggerEvent = (function (_super) {
        __extends(EnterTriggerEvent, _super);
        function EnterTriggerEvent(target, actor) {
            var _this = _super.call(this) || this;
            _this.target = target;
            _this.actor = actor;
            return _this;
        }
        return EnterTriggerEvent;
    }(GameEvent));
    exports.EnterTriggerEvent = EnterTriggerEvent;
    var ExitTriggerEvent = (function (_super) {
        __extends(ExitTriggerEvent, _super);
        function ExitTriggerEvent(target, actor) {
            var _this = _super.call(this) || this;
            _this.target = target;
            _this.actor = actor;
            return _this;
        }
        return ExitTriggerEvent;
    }(GameEvent));
    exports.ExitTriggerEvent = ExitTriggerEvent;
});
define("Class", ["require", "exports", "EventDispatcher"], function (require, exports, EventDispatcher_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Excalibur base class that provides basic functionality such as [[EventDispatcher]]
     * and extending abilities for vanilla Javascript projects
     */
    var Class = (function () {
        function Class() {
            this.eventDispatcher = new EventDispatcher_3.EventDispatcher(this);
        }
        /**
         * Alias for `addEventListener`. You can listen for a variety of
         * events off of the engine; see the events section below for a complete list.
         * @param eventName  Name of the event to listen for
         * @param handler    Event handler for the thrown event
         */
        Class.prototype.on = function (eventName, handler) {
            this.eventDispatcher.on(eventName, handler);
        };
        /**
         * Alias for `removeEventListener`. If only the eventName is specified
         * it will remove all handlers registered for that specific event. If the eventName
         * and the handler instance are specified only that handler will be removed.
         *
         * @param eventName  Name of the event to listen for
         * @param handler    Event handler for the thrown event
         */
        Class.prototype.off = function (eventName, handler) {
            this.eventDispatcher.off(eventName, handler);
        };
        /**
         * Emits a new event
         * @param eventName   Name of the event to emit
         * @param eventObject Data associated with this event
         */
        Class.prototype.emit = function (eventName, eventObject) {
            this.eventDispatcher.emit(eventName, eventObject);
        };
        /**
         * Once listens to an event one time, then unsubscribes from that event
         *
         * @param eventName The name of the event to subscribe to once
         * @param handler   The handler of the event that will be auto unsubscribed
         */
        Class.prototype.once = function (eventName, handler) {
            this.eventDispatcher.once(eventName, handler);
        };
        /**
         * You may wish to extend native Excalibur functionality in vanilla Javascript.
         * Any method on a class inheriting [[Class]] may be extended to support
         * additional functionality. In the example below we create a new type called `MyActor`.
         *
         *
         * ```js
         * var MyActor = Actor.extend({
         *
         *    constructor: function() {
         *       this.newprop = 'something';
         *       Actor.apply(this, arguments);
         *    },
         *
         *    update: function(engine, delta) {
         *       // Implement custom update
         *       // Call super constructor update
         *       Actor.prototype.update.call(this, engine, delta);
         *
         *       console.log("Something cool!");
         *    }
         * });
         *
         * var myActor = new MyActor(100, 100, 100, 100, Color.Azure);
         * ```
         *
         * In TypeScript, you only need to use the `extends` syntax, you do not need
         * to use this method of extension.
         *
         * @param methods A JSON object contain any methods/properties you want to extend
         */
        Class.extend = function (methods) {
            var parent = this;
            var child;
            if (methods && methods.hasOwnProperty('constructor')) {
                child = methods.constructor;
            }
            else {
                child = function () { return parent.apply(this, arguments); };
            }
            // Using constructor allows JS to lazily instantiate super classes
            var Super = function () { this.constructor = child; };
            Super.prototype = parent.prototype;
            child.prototype = new Super;
            if (methods) {
                for (var prop in methods) {
                    if (methods.hasOwnProperty(prop)) {
                        child.prototype[prop] = methods[prop];
                    }
                }
            }
            // Make subclasses extendable
            child.extend = Class.extend;
            return child;
        };
        return Class;
    }());
    exports.Class = Class;
});
define("Actor", ["require", "exports", "Physics", "Class", "Collision/BoundingBox", "Resources/Texture", "Events", "Drawing/Color", "Drawing/Sprite", "Util/Log", "Actions/ActionContext", "Actions/Action", "Algebra", "Collision/Body", "Collision/Side", "Configurable", "Traits/Index", "Drawing/SpriteEffects", "Util/Util"], function (require, exports, Physics_13, Class_11, BoundingBox_8, Texture_4, Events_14, Color_20, Sprite_4, Log_16, ActionContext_3, Action_2, Algebra_24, Body_2, Side_4, Configurable_8, Traits, Effects, Util) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @hidden
     */
    var ActorImpl = (function (_super) {
        __extends(ActorImpl, _super);
        /**
         * @param x       The starting x coordinate of the actor
         * @param y       The starting y coordinate of the actor
         * @param width   The starting width of the actor
         * @param height  The starting height of the actor
         * @param color   The starting color of the actor. Leave null to draw a transparent actor. The opacity of the color will be used as the
         * initial [[opacity]].
         */
        function ActorImpl(xOrConfig, y, width, height, color) {
            var _this = _super.call(this) || this;
            /**
             * The unique identifier for the actor
             */
            _this.id = ActorImpl.maxId++;
            /**
             * The physics body the is associated with this actor. The body is the container for all physical properties, like position, velocity,
             * acceleration, mass, inertia, etc.
             */
            _this.body = new Body_2.Body(_this);
            _this._height = 0;
            _this._width = 0;
            /**
             * The scale vector of the actor
             */
            _this.scale = new Algebra_24.Vector(1, 1);
            /**
             * The x scalar velocity of the actor in scale/second
             */
            _this.sx = 0; //scale/sec
            /**
             * The y scalar velocity of the actor in scale/second
             */
            _this.sy = 0; //scale/sec
            /**
             * Indicates whether the actor is physically in the viewport
             */
            _this.isOffScreen = false;
            /**
             * The visibility of an actor
             */
            _this.visible = true;
            /**
             * The opacity of an actor. Passing in a color in the [[constructor]] will use the
             * color's opacity.
             */
            _this.opacity = 1;
            _this.previousOpacity = 1;
            /**
             * Convenience reference to the global logger
             */
            _this.logger = Log_16.Logger.getInstance();
            /**
             * The scene that the actor is in
             */
            _this.scene = null;
            /**
             * The parent of this actor
             */
            _this.parent = null;
            // TODO: Replace this with the new actor collection once z-indexing is built
            /**
             * The children of this actor
             */
            _this.children = [];
            /**
             * Gets or sets the current collision type of this actor. By
             * default it is ([[CollisionType.PreventCollision]]).
             */
            _this.collisionType = CollisionType.PreventCollision;
            _this.collisionGroups = [];
            _this._collisionHandlers = {};
            _this._isInitialized = false;
            _this.frames = {};
            _this._effectsDirty = false;
            /**
             * Access to the current drawing for the actor, this can be
             * an [[Animation]], [[Sprite]], or [[Polygon]].
             * Set drawings with [[setDrawing]].
             */
            _this.currentDrawing = null;
            /**
             * Modify the current actor update pipeline.
             */
            _this.traits = [];
            /**
             * Whether or not to enable the [[CapturePointer]] trait that propagates
             * pointer events to this actor
             */
            _this.enableCapturePointer = false;
            /**
             * Configuration for [[CapturePointer]] trait
             */
            _this.capturePointer = {
                captureMoveEvents: false
            };
            _this._zIndex = 0;
            _this._isKilled = false;
            _this._opacityFx = new Effects.Opacity(_this.opacity);
            if (xOrConfig && typeof xOrConfig === 'object') {
                var config = xOrConfig;
                xOrConfig = config.pos ? config.pos.x : config.x;
                y = config.pos ? config.pos.y : config.y;
                width = config.width;
                height = config.height;
            }
            _this.pos.x = xOrConfig || 0;
            _this.pos.y = y || 0;
            _this._width = width || 0;
            _this._height = height || 0;
            if (color) {
                _this.color = color;
                // set default opacity of an actor to the color
                _this.opacity = color.a;
            }
            // Build default pipeline
            //this.traits.push(new ex.Traits.EulerMovement());
            // TODO: TileMaps should be converted to a collision area
            _this.traits.push(new Traits.TileMapCollisionDetection());
            _this.traits.push(new Traits.OffscreenCulling());
            _this.traits.push(new Traits.CapturePointer());
            // Build the action queue
            _this.actionQueue = new Action_2.ActionQueue(_this);
            _this.actions = new ActionContext_3.ActionContext(_this);
            // default anchor is in the middle
            _this.anchor = new Algebra_24.Vector(.5, .5);
            // Initialize default collision area to be box
            _this.body.useBoxCollision();
            return _this;
        }
        Object.defineProperty(ActorImpl.prototype, "collisionArea", {
            /**
             * Gets the collision area shape to use for collision possible options are [CircleArea|circles], [PolygonArea|polygons], and
             * [EdgeArea|edges].
             */
            get: function () {
                return this.body.collisionArea;
            },
            /**
             * Gets the collision area shape to use for collision possible options are [CircleArea|circles], [PolygonArea|polygons], and
             * [EdgeArea|edges].
             */
            set: function (area) {
                this.body.collisionArea = area;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "x", {
            /**
             * Gets the x position of the actor relative to it's parent (if any)
             */
            get: function () {
                return this.body.pos.x;
            },
            /**
             * Sets the x position of the actor relative to it's parent (if any)
             */
            set: function (theX) {
                this.body.pos.x = theX;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "y", {
            /**
             * Gets the y position of the actor relative to it's parent (if any)
             */
            get: function () {
                return this.body.pos.y;
            },
            /**
             * Sets the y position of the actor relative to it's parent (if any)
             */
            set: function (theY) {
                this.body.pos.y = theY;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "pos", {
            /**
             * Gets the position vector of the actor in pixels
             */
            get: function () {
                return this.body.pos;
            },
            /**
             * Sets the position vector of the actor in pixels
             */
            set: function (thePos) {
                this.body.pos.setTo(thePos.x, thePos.y);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "oldPos", {
            /**
             * Gets the position vector of the actor from the last frame
             */
            get: function () {
                return this.body.oldPos;
            },
            /**
             * Sets the position vector of the actor in the last frame
             */
            set: function (thePos) {
                this.body.oldPos.setTo(thePos.x, thePos.y);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "vel", {
            /**
             * Gets the velocity vector of the actor in pixels/sec
             */
            get: function () {
                return this.body.vel;
            },
            /**
             * Sets the velocity vector of the actor in pixels/sec
             */
            set: function (theVel) {
                this.body.vel.setTo(theVel.x, theVel.y);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "oldVel", {
            /**
             * Gets the velocity vector of the actor from the last frame
             */
            get: function () {
                return this.body.oldVel;
            },
            /**
             * Sets the velocity vector of the actor from the last frame
             */
            set: function (theVel) {
                this.body.oldVel.setTo(theVel.x, theVel.y);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "acc", {
            /**
             * Gets the acceleration vector of the actor in pixels/second/second. An acceleration pointing down such as (0, 100) may be
             * useful to simulate a gravitational effect.
             */
            get: function () {
                return this.body.acc;
            },
            /**
             * Sets the acceleration vector of teh actor in pixels/second/second
             */
            set: function (theAcc) {
                this.body.acc.setTo(theAcc.x, theAcc.y);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "rotation", {
            /**
             * Gets the rotation of the actor in radians. 1 radian = 180/PI Degrees.
             */
            get: function () {
                return this.body.rotation;
            },
            /**
             * Sets the rotation of the actor in radians. 1 radian = 180/PI Degrees.
             */
            set: function (theAngle) {
                this.body.rotation = theAngle;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "rx", {
            /**
             * Gets the rotational velocity of the actor in radians/second
             */
            get: function () {
                return this.body.rx;
            },
            /**
             * Sets the rotational velocity of the actor in radians/sec
             */
            set: function (angularVelocity) {
                this.body.rx = angularVelocity;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "torque", {
            /**
             * Gets the current torque applied to the actor. Torque can be thought of as rotational force
             */
            get: function () {
                return this.body.torque;
            },
            /**
             * Sets the current torque applied to the actor. Torque can be thought of as rotational force
             */
            set: function (theTorque) {
                this.body.torque = theTorque;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "mass", {
            /**
             * Get the current mass of the actor, mass can be thought of as the resistance to acceleration.
             */
            get: function () {
                return this.body.mass;
            },
            /**
             * Sets the mass of the actor, mass can be thought of as the resistance to acceleration.
             */
            set: function (theMass) {
                this.body.mass = theMass;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "moi", {
            /**
             * Gets the current moment of inertia, moi can be thought of as the resistance to rotation.
             */
            get: function () {
                return this.body.moi;
            },
            /**
             * Sets the current moment of inertia, moi can be thought of as the resistance to rotation.
             */
            set: function (theMoi) {
                this.body.moi = theMoi;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "friction", {
            /**
             * Gets the coefficient of friction on this actor, this can be thought of as how sticky or slippery an object is.
             */
            get: function () {
                return this.body.friction;
            },
            /**
             * Sets the coefficient of friction of this actor, this can ve thought of as how stick or slippery an object is.
             */
            set: function (theFriction) {
                this.body.friction = theFriction;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "restitution", {
            /**
             * Gets the coefficient of restitution of this actor, represents the amount of energy preserved after collision. Think of this
             * as bounciness.
             */
            get: function () {
                return this.body.restitution;
            },
            /**
             * Sets the coefficient of restitution of this actor, represents the amount of energy preserved after collision. Think of this
             * as bounciness.
             */
            set: function (theRestitution) {
                this.body.restitution = theRestitution;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "color", {
            /**
             * Sets the color of the actor. A rectangle of this color will be
             * drawn if no [[IDrawable]] is specified as the actors drawing.
             *
             * The default is `null` which prevents a rectangle from being drawn.
             */
            get: function () {
                return this._color;
            },
            set: function (v) {
                this._color = v.clone();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * This is called before the first update of the actor. This method is meant to be
         * overridden. This is where initialization of child actors should take place.
         */
        ActorImpl.prototype.onInitialize = function (_engine) {
            // Override me
        };
        Object.defineProperty(ActorImpl.prototype, "isInitialized", {
            /**
             * Gets wether the actor is Initialized
             */
            get: function () {
                return this._isInitialized;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Initializes this actor and all it's child actors, meant to be called by the Scene before first update not by users of Excalibur.
         * @internal
         */
        ActorImpl.prototype._initialize = function (engine) {
            if (!this.isInitialized) {
                this.onInitialize(engine);
                this.eventDispatcher.emit('initialize', new Events_14.InitializeEvent(engine, this));
                this._isInitialized = true;
            }
            for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
                var child = _a[_i];
                child._initialize(engine);
            }
        };
        ActorImpl.prototype._checkForPointerOptIn = function (eventName) {
            if (eventName) {
                var normalized = eventName.toLowerCase();
                if (normalized === 'pointerup' || normalized === 'pointerdown' || normalized === 'pointermove') {
                    this.enableCapturePointer = true;
                    if (normalized === 'pointermove') {
                        this.capturePointer.captureMoveEvents = true;
                    }
                }
            }
        };
        ActorImpl.prototype.on = function (eventName, handler) {
            this._checkForPointerOptIn(eventName);
            this.eventDispatcher.on(eventName, handler);
        };
        ActorImpl.prototype.once = function (eventName, handler) {
            this._checkForPointerOptIn(eventName);
            this.eventDispatcher.once(eventName, handler);
        };
        /**
         * If the current actor is a member of the scene, this will remove
         * it from the scene graph. It will no longer be drawn or updated.
         */
        ActorImpl.prototype.kill = function () {
            if (this.scene) {
                this.emit('kill', new Events_14.KillEvent(this));
                this.scene.remove(this);
                this._isKilled = true;
            }
            else {
                this.logger.warn('Cannot kill actor, it was never added to the Scene');
            }
        };
        /**
         * If the current actor is killed, it will now not be killed.
         */
        ActorImpl.prototype.unkill = function () {
            this._isKilled = false;
        };
        /**
         * Indicates wether the actor has been killed.
         */
        ActorImpl.prototype.isKilled = function () {
            return this._isKilled;
        };
        /**
         * Adds a child actor to this actor. All movement of the child actor will be
         * relative to the parent actor. Meaning if the parent moves the child will
         * move with it.
         * @param actor The child actor to add
         */
        ActorImpl.prototype.add = function (actor) {
            actor.collisionType = CollisionType.PreventCollision;
            if (Util.addItemToArray(actor, this.children)) {
                actor.parent = this;
            }
        };
        /**
         * Removes a child actor from this actor.
         * @param actor The child actor to remove
         */
        ActorImpl.prototype.remove = function (actor) {
            if (Util.removeItemFromArray(actor, this.children)) {
                actor.parent = null;
            }
        };
        ActorImpl.prototype.setDrawing = function (key) {
            key = key.toString();
            if (this.currentDrawing !== this.frames[key]) {
                if (this.frames[key] != null) {
                    this.frames[key].reset();
                    this.currentDrawing = this.frames[key];
                }
                else {
                    Log_16.Logger.getInstance().error('the specified drawing key \'' + key + '\' does not exist');
                }
            }
        };
        ActorImpl.prototype.addDrawing = function () {
            if (arguments.length === 2) {
                this.frames[arguments[0]] = arguments[1];
                if (!this.currentDrawing) {
                    this.currentDrawing = arguments[1];
                }
                this._effectsDirty = true;
            }
            else {
                if (arguments[0] instanceof Sprite_4.Sprite) {
                    this.addDrawing('default', arguments[0]);
                }
                if (arguments[0] instanceof Texture_4.Texture) {
                    this.addDrawing('default', arguments[0].asSprite());
                }
            }
        };
        Object.defineProperty(ActorImpl.prototype, "z", {
            get: function () {
                return this.getZIndex();
            },
            set: function (newZ) {
                this.setZIndex(newZ);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Gets the z-index of an actor. The z-index determines the relative order an actor is drawn in.
         * Actors with a higher z-index are drawn on top of actors with a lower z-index
         */
        ActorImpl.prototype.getZIndex = function () {
            return this._zIndex;
        };
        /**
         * Sets the z-index of an actor and updates it in the drawing list for the scene.
         * The z-index determines the relative order an actor is drawn in.
         * Actors with a higher z-index are drawn on top of actors with a lower z-index
         * @param newIndex new z-index to assign
         */
        ActorImpl.prototype.setZIndex = function (newIndex) {
            this.scene.cleanupDrawTree(this);
            this._zIndex = newIndex;
            this.scene.updateDrawTree(this);
        };
        /**
         * Adds an actor to a collision group. Actors with no named collision groups are
         * considered to be in every collision group.
         *
         * Once in a collision group(s) actors will only collide with other actors in
         * that group.
         *
         * @param name The name of the collision group
         */
        ActorImpl.prototype.addCollisionGroup = function (name) {
            this.collisionGroups.push(name);
        };
        /**
         * Removes an actor from a collision group.
         * @param name The name of the collision group
         */
        ActorImpl.prototype.removeCollisionGroup = function (name) {
            var index = this.collisionGroups.indexOf(name);
            if (index !== -1) {
                this.collisionGroups.splice(index, 1);
            }
        };
        /**
         * Get the center point of an actor
         */
        ActorImpl.prototype.getCenter = function () {
            return new Algebra_24.Vector(this.pos.x + this.getWidth() / 2 - this.anchor.x * this.getWidth(), this.pos.y + this.getHeight() / 2 - this.anchor.y * this.getHeight());
        };
        /**
         * Gets the calculated width of an actor, factoring in scale
         */
        ActorImpl.prototype.getWidth = function () {
            return this._width * this.getGlobalScale().x;
        };
        /**
         * Sets the width of an actor, factoring in the current scale
         */
        ActorImpl.prototype.setWidth = function (width) {
            this._width = width / this.scale.x;
        };
        /**
         * Gets the calculated height of an actor, factoring in scale
         */
        ActorImpl.prototype.getHeight = function () {
            return this._height * this.getGlobalScale().y;
        };
        /**
         * Sets the height of an actor, factoring in the current scale
         */
        ActorImpl.prototype.setHeight = function (height) {
            this._height = height / this.scale.y;
        };
        /**
         * Gets the left edge of the actor
         */
        ActorImpl.prototype.getLeft = function () {
            return this.getBounds().left;
        };
        /**
         * Gets the right edge of the actor
         */
        ActorImpl.prototype.getRight = function () {
            return this.getBounds().right;
        };
        /**
         * Gets the top edge of the actor
         */
        ActorImpl.prototype.getTop = function () {
            return this.getBounds().top;
        };
        /**
         * Gets the bottom edge of the actor
         */
        ActorImpl.prototype.getBottom = function () {
            return this.getBounds().bottom;
        };
        /**
         * Gets this actor's rotation taking into account any parent relationships
         *
         * @returns Rotation angle in radians
         */
        ActorImpl.prototype.getWorldRotation = function () {
            if (!this.parent) {
                return this.rotation;
            }
            return this.rotation + this.parent.getWorldRotation();
        };
        /**
         * Gets an actor's world position taking into account parent relationships, scaling, rotation, and translation
         *
         * @returns Position in world coordinates
         */
        ActorImpl.prototype.getWorldPos = function () {
            if (!this.parent) {
                return this.pos.clone();
            }
            // collect parents                  
            var parents = [];
            var root = this;
            parents.push(this);
            // find parents
            while (root.parent) {
                root = root.parent;
                parents.push(root);
            }
            // calculate position       
            var x = parents.reduceRight(function (px, p) {
                if (p.parent) {
                    return px + (p.pos.x * p.getGlobalScale().x);
                }
                return px + p.pos.x;
            }, 0);
            var y = parents.reduceRight(function (py, p) {
                if (p.parent) {
                    return py + (p.pos.y * p.getGlobalScale().y);
                }
                return py + p.pos.y;
            }, 0);
            // rotate around root anchor
            var ra = root.getWorldPos(); // 10, 10
            var r = this.getWorldRotation();
            return new Algebra_24.Vector(x, y).rotate(r, ra);
        };
        /**
         * Gets the global scale of the Actor
         */
        ActorImpl.prototype.getGlobalScale = function () {
            if (!this.parent) {
                return new Algebra_24.Vector(this.scale.x, this.scale.y);
            }
            var parentScale = this.parent.getGlobalScale();
            return new Algebra_24.Vector(this.scale.x * parentScale.x, this.scale.y * parentScale.y);
        };
        /**
         * Returns the actor's [[BoundingBox]] calculated for this instant in world space.
         */
        ActorImpl.prototype.getBounds = function () {
            // todo cache bounding box
            var anchor = this._getCalculatedAnchor();
            var pos = this.getWorldPos();
            return new BoundingBox_8.BoundingBox(pos.x - anchor.x, pos.y - anchor.y, pos.x + this.getWidth() - anchor.x, pos.y + this.getHeight() - anchor.y).rotate(this.rotation, pos);
        };
        /**
         * Returns the actor's [[BoundingBox]] relative to the actors position.
         */
        ActorImpl.prototype.getRelativeBounds = function () {
            // todo cache bounding box
            var anchor = this._getCalculatedAnchor();
            return new BoundingBox_8.BoundingBox(-anchor.x, -anchor.y, this.getWidth() - anchor.x, this.getHeight() - anchor.y).rotate(this.rotation);
        };
        /**
         * Tests whether the x/y specified are contained in the actor
         * @param x  X coordinate to test (in world coordinates)
         * @param y  Y coordinate to test (in world coordinates)
         * @param recurse checks whether the x/y are contained in any child actors (if they exist).
         */
        ActorImpl.prototype.contains = function (x, y, recurse) {
            if (recurse === void 0) { recurse = false; }
            var containment = this.getBounds().contains(new Algebra_24.Vector(x, y));
            if (recurse) {
                return containment || this.children.some(function (child) {
                    return child.contains(x, y, true);
                });
            }
            return containment;
        };
        /**
         * Returns the side of the collision based on the intersection
         * @param intersect The displacement vector returned by a collision
         */
        ActorImpl.prototype.getSideFromIntersect = function (intersect) {
            if (intersect) {
                if (Math.abs(intersect.x) > Math.abs(intersect.y)) {
                    if (intersect.x < 0) {
                        return Side_4.Side.Right;
                    }
                    return Side_4.Side.Left;
                }
                else {
                    if (intersect.y < 0) {
                        return Side_4.Side.Bottom;
                    }
                    return Side_4.Side.Top;
                }
            }
            return Side_4.Side.None;
        };
        /**
         * Test whether the actor has collided with another actor, returns the side of the current actor that collided.
         * @param actor The other actor to test
         */
        ActorImpl.prototype.collidesWithSide = function (actor) {
            var separationVector = this.collides(actor);
            if (!separationVector) {
                return Side_4.Side.None;
            }
            if (Math.abs(separationVector.x) > Math.abs(separationVector.y)) {
                if (this.pos.x < actor.pos.x) {
                    return Side_4.Side.Right;
                }
                else {
                    return Side_4.Side.Left;
                }
            }
            else {
                if (this.pos.y < actor.pos.y) {
                    return Side_4.Side.Bottom;
                }
                else {
                    return Side_4.Side.Top;
                }
            }
        };
        /**
         * Test whether the actor has collided with another actor, returns the intersection vector on collision. Returns
         * `null` when there is no collision;
         * @param actor The other actor to test
         */
        ActorImpl.prototype.collides = function (actor) {
            var bounds = this.getBounds();
            var otherBounds = actor.getBounds();
            var intersect = bounds.collides(otherBounds);
            return intersect;
        };
        /**
         * Register a handler to fire when this actor collides with another in a specified group
         * @param group The group name to listen for
         * @param func The callback to fire on collision with another actor from the group. The callback is passed the other actor.
         */
        ActorImpl.prototype.onCollidesWith = function (group, func) {
            if (!this._collisionHandlers[group]) {
                this._collisionHandlers[group] = [];
            }
            this._collisionHandlers[group].push(func);
        };
        ActorImpl.prototype.getCollisionHandlers = function () {
            return this._collisionHandlers;
        };
        /**
         * Removes all collision handlers for this group on this actor
         * @param group Group to remove all handlers for on this actor.
         */
        ActorImpl.prototype.removeCollidesWith = function (group) {
            this._collisionHandlers[group] = [];
        };
        /**
         * Returns true if the two actors are less than or equal to the distance specified from each other
         * @param actor     Actor to test
         * @param distance  Distance in pixels to test
         */
        ActorImpl.prototype.within = function (actor, distance) {
            return Math.sqrt(Math.pow(this.pos.x - actor.pos.x, 2) + Math.pow(this.pos.y - actor.pos.y, 2)) <= distance;
        };
        ActorImpl.prototype._getCalculatedAnchor = function () {
            return new Algebra_24.Vector(this.getWidth() * this.anchor.x, this.getHeight() * this.anchor.y);
        };
        ActorImpl.prototype._reapplyEffects = function (drawing) {
            drawing.removeEffect(this._opacityFx);
            drawing.addEffect(this._opacityFx);
        };
        /**
         * Perform euler integration at the specified time step
         */
        ActorImpl.prototype.integrate = function (delta) {
            // Update placements based on linear algebra
            var seconds = delta / 1000;
            var totalAcc = this.acc.clone();
            // Only active vanilla actors are affected by global acceleration
            if (this.collisionType === CollisionType.Active) {
                totalAcc.addEqual(Physics_13.Physics.acc);
            }
            this.vel.addEqual(totalAcc.scale(seconds));
            this.pos.addEqual(this.vel.scale(seconds)).addEqual(totalAcc.scale(0.5 * seconds * seconds));
            this.rx += this.torque * (1.0 / this.moi) * seconds;
            this.rotation += this.rx * seconds;
            this.scale.x += this.sx * delta / 1000;
            this.scale.y += this.sy * delta / 1000;
            // Update physics body
            this.body.update();
        };
        /**
         * Called by the Engine, updates the state of the actor
         * @param engine The reference to the current game engine
         * @param delta  The time elapsed since the last update in milliseconds
         */
        ActorImpl.prototype.update = function (engine, delta) {
            this._initialize(engine);
            this.emit('preupdate', new Events_14.PreUpdateEvent(engine, delta, this));
            // Update action queue
            this.actionQueue.update(delta);
            // Update color only opacity
            if (this.color) {
                this.color.a = this.opacity;
            }
            // calculate changing opacity
            if (this.previousOpacity !== this.opacity) {
                this.previousOpacity = this.opacity;
                this._opacityFx.opacity = this.opacity;
                this._effectsDirty = true;
            }
            // Capture old values before integration step updates them
            this.oldVel.setTo(this.vel.x, this.vel.y);
            this.oldPos.setTo(this.pos.x, this.pos.y);
            // Run Euler integration
            this.integrate(delta);
            // Update actor pipeline (movement, collision detection, event propagation, offscreen culling)
            for (var _i = 0, _a = this.traits; _i < _a.length; _i++) {
                var trait = _a[_i];
                trait.update(this, engine, delta);
            }
            // Update child actors
            for (var i = 0; i < this.children.length; i++) {
                this.children[i].update(engine, delta);
            }
            this.emit('postupdate', new Events_14.PostUpdateEvent(engine, delta, this));
        };
        /**
         * Called by the Engine, draws the actor to the screen
         * @param ctx   The rendering context
         * @param delta The time since the last draw in milliseconds
         */
        ActorImpl.prototype.draw = function (ctx, delta) {
            ctx.save();
            ctx.translate(this.pos.x, this.pos.y);
            ctx.rotate(this.rotation);
            ctx.scale(this.scale.x, this.scale.y);
            // translate canvas by anchor offset
            ctx.save();
            ctx.translate(-(this._width * this.anchor.x), -(this._height * this.anchor.y));
            this.emit('predraw', new Events_14.PreDrawEvent(ctx, delta, this));
            if (this.currentDrawing) {
                var drawing = this.currentDrawing;
                // See https://github.com/excaliburjs/Excalibur/pull/619 for discussion on this formula          
                var offsetX = (this._width - drawing.naturalWidth * drawing.scale.x) * this.anchor.x;
                var offsetY = (this._height - drawing.naturalHeight * drawing.scale.y) * this.anchor.y;
                if (this._effectsDirty) {
                    this._reapplyEffects(this.currentDrawing);
                    this._effectsDirty = false;
                }
                this.currentDrawing.draw(ctx, offsetX, offsetY);
            }
            else {
                if (this.color) {
                    ctx.fillStyle = this.color.toString();
                    ctx.fillRect(0, 0, this._width, this._height);
                }
            }
            ctx.restore();
            // Draw child actors
            for (var i = 0; i < this.children.length; i++) {
                if (this.children[i].visible) {
                    this.children[i].draw(ctx, delta);
                }
            }
            this.emit('postdraw', new Events_14.PostDrawEvent(ctx, delta, this));
            ctx.restore();
        };
        /**
         * Called by the Engine, draws the actors debugging to the screen
         * @param ctx The rendering context
         */
        /* istanbul ignore next */
        ActorImpl.prototype.debugDraw = function (ctx) {
            this.emit('predebugdraw', new Events_14.PreDebugDrawEvent(ctx, this));
            this.body.debugDraw(ctx);
            // Draw actor bounding box
            var bb = this.getBounds();
            bb.debugDraw(ctx);
            // Draw actor Id
            ctx.fillText('id: ' + this.id, bb.left + 3, bb.top + 10);
            // Draw actor anchor Vector
            ctx.fillStyle = Color_20.Color.Yellow.toString();
            ctx.beginPath();
            ctx.arc(this.getWorldPos().x, this.getWorldPos().y, 3, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fill();
            // Culling Box debug draw
            for (var j = 0; j < this.traits.length; j++) {
                if (this.traits[j] instanceof Traits.OffscreenCulling) {
                    this.traits[j].cullingBox.debugDraw(ctx);
                }
            }
            // Unit Circle debug draw
            ctx.strokeStyle = Color_20.Color.Yellow.toString();
            ctx.beginPath();
            var radius = Math.min(this.getWidth(), this.getHeight());
            ctx.arc(this.getWorldPos().x, this.getWorldPos().y, radius, 0, Math.PI * 2);
            ctx.closePath();
            ctx.stroke();
            var ticks = {
                '0 Pi': 0,
                'Pi/2': Math.PI / 2,
                'Pi': Math.PI,
                '3/2 Pi': 3 * Math.PI / 2
            };
            var oldFont = ctx.font;
            for (var tick in ticks) {
                ctx.fillStyle = Color_20.Color.Yellow.toString();
                ctx.font = '14px';
                ctx.textAlign = 'center';
                ctx.fillText(tick, this.getWorldPos().x + Math.cos(ticks[tick]) * (radius + 10), this.getWorldPos().y + Math.sin(ticks[tick]) * (radius + 10));
            }
            ctx.font = oldFont;
            // Draw child actors
            for (var i = 0; i < this.children.length; i++) {
                this.children[i].debugDraw(ctx);
            }
            this.emit('postdebugdraw', new Events_14.PostDebugDrawEvent(ctx, this));
        };
        return ActorImpl;
    }(Class_11.Class));
    /**
     * Indicates the next id to be set
     */
    ActorImpl.maxId = 0;
    exports.ActorImpl = ActorImpl;
    /**
     * The most important primitive in Excalibur is an `Actor`. Anything that
     * can move on the screen, collide with another `Actor`, respond to events,
     * or interact with the current scene, must be an actor. An `Actor` **must**
     * be part of a [[Scene]] for it to be drawn to the screen.
     *
     * [[include:Actors.md]]
     *
     *
     * [[include:Constructors.md]]
     *
     */
    var Actor = (function (_super) {
        __extends(Actor, _super);
        function Actor(xOrConfig, y, width, height, color) {
            return _super.call(this, xOrConfig, y, width, height, color) || this;
        }
        return Actor;
    }(Configurable_8.Configurable(ActorImpl)));
    exports.Actor = Actor;
    /**
     * An enum that describes the types of collisions actors can participate in
     */
    var CollisionType;
    (function (CollisionType) {
        /**
         * Actors with the `PreventCollision` setting do not participate in any
         * collisions and do not raise collision events.
         */
        CollisionType[CollisionType["PreventCollision"] = 0] = "PreventCollision";
        /**
         * Actors with the `Passive` setting only raise collision events, but are not
         * influenced or moved by other actors and do not influence or move other actors.
         */
        CollisionType[CollisionType["Passive"] = 1] = "Passive";
        /**
         * Actors with the `Active` setting raise collision events and participate
         * in collisions with other actors and will be push or moved by actors sharing
         * the `Active` or `Fixed` setting.
         */
        CollisionType[CollisionType["Active"] = 2] = "Active";
        /**
         * Actors with the `Fixed` setting raise collision events and participate in
         * collisions with other actors. Actors with the `Fixed` setting will not be
         * pushed or moved by other actors sharing the `Fixed`. Think of Fixed
         * actors as "immovable/onstoppable" objects. If two `Fixed` actors meet they will
         * not be pushed or moved by each other, they will not interact except to throw
         * collision events.
         */
        CollisionType[CollisionType["Fixed"] = 3] = "Fixed";
    })(CollisionType = exports.CollisionType || (exports.CollisionType = {}));
});
define("Actions/Action", ["require", "exports", "Actions/RotationType", "Algebra", "Util/Log", "Util/Util"], function (require, exports, RotationType_2, Algebra_25, Log_17, Util) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var EaseTo = (function () {
        function EaseTo(actor, x, y, duration, easingFcn) {
            this.actor = actor;
            this.easingFcn = easingFcn;
            this._currentLerpTime = 0;
            this._lerpDuration = 1 * 1000; // 1 second
            this._lerpStart = new Algebra_25.Vector(0, 0);
            this._lerpEnd = new Algebra_25.Vector(0, 0);
            this._initialized = false;
            this._stopped = false;
            this._distance = 0;
            this._lerpDuration = duration;
            this._lerpEnd = new Algebra_25.Vector(x, y);
        }
        EaseTo.prototype._initialize = function () {
            this._lerpStart = new Algebra_25.Vector(this.actor.pos.x, this.actor.pos.y);
            this._currentLerpTime = 0;
            this._distance = this._lerpStart.distance(this._lerpEnd);
        };
        EaseTo.prototype.update = function (delta) {
            if (!this._initialized) {
                this._initialize();
                this._initialized = true;
            }
            var newX = this.actor.pos.x;
            var newY = this.actor.pos.y;
            if (this._currentLerpTime < this._lerpDuration) {
                if (this._lerpEnd.x < this._lerpStart.x) {
                    newX = this._lerpStart.x - (this.easingFcn(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x);
                }
                else {
                    newX = this.easingFcn(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration);
                }
                if (this._lerpEnd.y < this._lerpStart.y) {
                    newY = this._lerpStart.y - (this.easingFcn(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y);
                }
                else {
                    newY = this.easingFcn(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);
                }
                this.actor.pos.x = newX;
                this.actor.pos.y = newY;
                this._currentLerpTime += delta;
            }
            else {
                this.actor.pos.x = this._lerpEnd.x;
                this.actor.pos.y = this._lerpEnd.y;
                //this._lerpStart = null;
                //this._lerpEnd = null;
                //this._currentLerpTime = 0;
            }
        };
        EaseTo.prototype.isComplete = function (actor) {
            return this._stopped || (new Algebra_25.Vector(actor.pos.x, actor.pos.y)).distance(this._lerpStart) >= this._distance;
        };
        EaseTo.prototype.reset = function () {
            this._initialized = false;
        };
        EaseTo.prototype.stop = function () {
            this._stopped = true;
        };
        return EaseTo;
    }());
    exports.EaseTo = EaseTo;
    var MoveTo = (function () {
        function MoveTo(actor, destx, desty, speed) {
            this._started = false;
            this._stopped = false;
            this._actor = actor;
            this._end = new Algebra_25.Vector(destx, desty);
            this._speed = speed;
        }
        MoveTo.prototype.update = function (_delta) {
            if (!this._started) {
                this._started = true;
                this._start = new Algebra_25.Vector(this._actor.pos.x, this._actor.pos.y);
                this._distance = this._start.distance(this._end);
                this._dir = this._end.sub(this._start).normalize();
            }
            var m = this._dir.scale(this._speed);
            this._actor.vel.x = m.x;
            this._actor.vel.y = m.y;
            if (this.isComplete(this._actor)) {
                this._actor.pos.x = this._end.x;
                this._actor.pos.y = this._end.y;
                this._actor.vel.y = 0;
                this._actor.vel.x = 0;
            }
        };
        MoveTo.prototype.isComplete = function (actor) {
            return this._stopped || (new Algebra_25.Vector(actor.pos.x, actor.pos.y)).distance(this._start) >= this._distance;
        };
        MoveTo.prototype.stop = function () {
            this._actor.vel.y = 0;
            this._actor.vel.x = 0;
            this._stopped = true;
        };
        MoveTo.prototype.reset = function () {
            this._started = false;
        };
        return MoveTo;
    }());
    exports.MoveTo = MoveTo;
    var MoveBy = (function () {
        function MoveBy(actor, destx, desty, time) {
            this._started = false;
            this._stopped = false;
            this._actor = actor;
            this._end = new Algebra_25.Vector(destx, desty);
            if (time <= 0) {
                Log_17.Logger.getInstance().error('Attempted to moveBy time less than or equal to zero : ' + time);
                throw new Error('Cannot move in time <= 0');
            }
            this._time = time;
        }
        MoveBy.prototype.update = function (_delta) {
            if (!this._started) {
                this._started = true;
                this._start = new Algebra_25.Vector(this._actor.pos.x, this._actor.pos.y);
                this._distance = this._start.distance(this._end);
                this._dir = this._end.sub(this._start).normalize();
                this._speed = this._distance / (this._time / 1000);
            }
            var m = this._dir.scale(this._speed);
            this._actor.vel.x = m.x;
            this._actor.vel.y = m.y;
            if (this.isComplete(this._actor)) {
                this._actor.pos.x = this._end.x;
                this._actor.pos.y = this._end.y;
                this._actor.vel.y = 0;
                this._actor.vel.x = 0;
            }
        };
        MoveBy.prototype.isComplete = function (actor) {
            return this._stopped || (new Algebra_25.Vector(actor.pos.x, actor.pos.y)).distance(this._start) >= this._distance;
        };
        MoveBy.prototype.stop = function () {
            this._actor.vel.y = 0;
            this._actor.vel.x = 0;
            this._stopped = true;
        };
        MoveBy.prototype.reset = function () {
            this._started = false;
        };
        return MoveBy;
    }());
    exports.MoveBy = MoveBy;
    var Follow = (function () {
        function Follow(actor, actorToFollow, followDistance) {
            this._started = false;
            this._stopped = false;
            this._actor = actor;
            this._actorToFollow = actorToFollow;
            this._current = new Algebra_25.Vector(this._actor.pos.x, this._actor.pos.y);
            this._end = new Algebra_25.Vector(actorToFollow.pos.x, actorToFollow.pos.y);
            this._maximumDistance = (followDistance !== undefined) ? followDistance : this._current.distance(this._end);
            this._speed = 0;
        }
        Follow.prototype.update = function (_delta) {
            if (!this._started) {
                this._started = true;
                this._distanceBetween = this._current.distance(this._end);
                this._dir = this._end.sub(this._current).normalize();
            }
            var actorToFollowSpeed = Math.sqrt(Math.pow(this._actorToFollow.vel.x, 2) + Math.pow(this._actorToFollow.vel.y, 2));
            if (actorToFollowSpeed !== 0) {
                this._speed = actorToFollowSpeed;
            }
            this._current.x = this._actor.pos.x;
            this._current.y = this._actor.pos.y;
            this._end.x = this._actorToFollow.pos.x;
            this._end.y = this._actorToFollow.pos.y;
            this._distanceBetween = this._current.distance(this._end);
            this._dir = this._end.sub(this._current).normalize();
            if (this._distanceBetween >= this._maximumDistance) {
                var m = this._dir.scale(this._speed);
                this._actor.vel.x = m.x;
                this._actor.vel.y = m.y;
            }
            else {
                this._actor.vel.x = 0;
                this._actor.vel.y = 0;
            }
            if (this.isComplete()) {
                // TODO this should never occur
                this._actor.pos.x = this._end.x;
                this._actor.pos.y = this._end.y;
                this._actor.vel.y = 0;
                this._actor.vel.x = 0;
            }
        };
        Follow.prototype.stop = function () {
            this._actor.vel.y = 0;
            this._actor.vel.x = 0;
            this._stopped = true;
        };
        Follow.prototype.isComplete = function () {
            // the actor following should never stop unless specified to do so
            return this._stopped;
        };
        Follow.prototype.reset = function () {
            this._started = false;
        };
        return Follow;
    }());
    exports.Follow = Follow;
    var Meet = (function () {
        function Meet(actor, actorToMeet, speed) {
            this._started = false;
            this._stopped = false;
            this._speedWasSpecified = false;
            this._actor = actor;
            this._actorToMeet = actorToMeet;
            this._current = new Algebra_25.Vector(this._actor.pos.x, this._actor.pos.y);
            this._end = new Algebra_25.Vector(actorToMeet.pos.x, actorToMeet.pos.y);
            this._speed = speed || 0;
            if (speed !== undefined) {
                this._speedWasSpecified = true;
            }
        }
        Meet.prototype.update = function (_delta) {
            if (!this._started) {
                this._started = true;
                this._distanceBetween = this._current.distance(this._end);
                this._dir = this._end.sub(this._current).normalize();
            }
            var actorToMeetSpeed = Math.sqrt(Math.pow(this._actorToMeet.vel.x, 2) + Math.pow(this._actorToMeet.vel.y, 2));
            if ((actorToMeetSpeed !== 0) && (!this._speedWasSpecified)) {
                this._speed = actorToMeetSpeed;
            }
            this._current.x = this._actor.pos.x;
            this._current.y = this._actor.pos.y;
            this._end.x = this._actorToMeet.pos.x;
            this._end.y = this._actorToMeet.pos.y;
            this._distanceBetween = this._current.distance(this._end);
            this._dir = this._end.sub(this._current).normalize();
            var m = this._dir.scale(this._speed);
            this._actor.vel.x = m.x;
            this._actor.vel.y = m.y;
            if (this.isComplete()) {
                this._actor.pos.x = this._end.x;
                this._actor.pos.y = this._end.y;
                this._actor.vel.y = 0;
                this._actor.vel.x = 0;
            }
        };
        Meet.prototype.isComplete = function () {
            return this._stopped || (this._distanceBetween <= 1);
        };
        Meet.prototype.stop = function () {
            this._actor.vel.y = 0;
            this._actor.vel.x = 0;
            this._stopped = true;
        };
        Meet.prototype.reset = function () {
            this._started = false;
        };
        return Meet;
    }());
    exports.Meet = Meet;
    var RotateTo = (function () {
        function RotateTo(actor, angleRadians, speed, rotationType) {
            this._started = false;
            this._stopped = false;
            this._actor = actor;
            this._end = angleRadians;
            this._speed = speed;
            this._rotationType = rotationType || RotationType_2.RotationType.ShortestPath;
        }
        RotateTo.prototype.update = function (_delta) {
            if (!this._started) {
                this._started = true;
                this._start = this._actor.rotation;
                var distance1 = Math.abs(this._end - this._start);
                var distance2 = Util.TwoPI - distance1;
                if (distance1 > distance2) {
                    this._shortDistance = distance2;
                    this._longDistance = distance1;
                }
                else {
                    this._shortDistance = distance1;
                    this._longDistance = distance2;
                }
                this._shortestPathIsPositive = (this._start - this._end + Util.TwoPI) % Util.TwoPI >= Math.PI;
                switch (this._rotationType) {
                    case RotationType_2.RotationType.ShortestPath:
                        this._distance = this._shortDistance;
                        if (this._shortestPathIsPositive) {
                            this._direction = 1;
                        }
                        else {
                            this._direction = -1;
                        }
                        break;
                    case RotationType_2.RotationType.LongestPath:
                        this._distance = this._longDistance;
                        if (this._shortestPathIsPositive) {
                            this._direction = -1;
                        }
                        else {
                            this._direction = 1;
                        }
                        break;
                    case RotationType_2.RotationType.Clockwise:
                        this._direction = 1;
                        if (this._shortestPathIsPositive) {
                            this._distance = this._shortDistance;
                        }
                        else {
                            this._distance = this._longDistance;
                        }
                        break;
                    case RotationType_2.RotationType.CounterClockwise:
                        this._direction = -1;
                        if (!this._shortestPathIsPositive) {
                            this._distance = this._shortDistance;
                        }
                        else {
                            this._distance = this._longDistance;
                        }
                        break;
                }
            }
            this._actor.rx = this._direction * this._speed;
            if (this.isComplete()) {
                this._actor.rotation = this._end;
                this._actor.rx = 0;
                this._stopped = true;
            }
        };
        RotateTo.prototype.isComplete = function () {
            var distanceTravelled = Math.abs(this._actor.rotation - this._start);
            return this._stopped || (distanceTravelled >= Math.abs(this._distance));
        };
        RotateTo.prototype.stop = function () {
            this._actor.rx = 0;
            this._stopped = true;
        };
        RotateTo.prototype.reset = function () {
            this._started = false;
        };
        return RotateTo;
    }());
    exports.RotateTo = RotateTo;
    var RotateBy = (function () {
        function RotateBy(actor, angleRadians, time, rotationType) {
            this._started = false;
            this._stopped = false;
            this._actor = actor;
            this._end = angleRadians;
            this._time = time;
            this._rotationType = rotationType || RotationType_2.RotationType.ShortestPath;
        }
        RotateBy.prototype.update = function (_delta) {
            if (!this._started) {
                this._started = true;
                this._start = this._actor.rotation;
                var distance1 = Math.abs(this._end - this._start);
                var distance2 = Util.TwoPI - distance1;
                if (distance1 > distance2) {
                    this._shortDistance = distance2;
                    this._longDistance = distance1;
                }
                else {
                    this._shortDistance = distance1;
                    this._longDistance = distance2;
                }
                this._shortestPathIsPositive = (this._start - this._end + Util.TwoPI) % Util.TwoPI >= Math.PI;
                switch (this._rotationType) {
                    case RotationType_2.RotationType.ShortestPath:
                        this._distance = this._shortDistance;
                        if (this._shortestPathIsPositive) {
                            this._direction = 1;
                        }
                        else {
                            this._direction = -1;
                        }
                        break;
                    case RotationType_2.RotationType.LongestPath:
                        this._distance = this._longDistance;
                        if (this._shortestPathIsPositive) {
                            this._direction = -1;
                        }
                        else {
                            this._direction = 1;
                        }
                        break;
                    case RotationType_2.RotationType.Clockwise:
                        this._direction = 1;
                        if (this._shortDistance >= 0) {
                            this._distance = this._shortDistance;
                        }
                        else {
                            this._distance = this._longDistance;
                        }
                        break;
                    case RotationType_2.RotationType.CounterClockwise:
                        this._direction = -1;
                        if (this._shortDistance <= 0) {
                            this._distance = this._shortDistance;
                        }
                        else {
                            this._distance = this._longDistance;
                        }
                        break;
                }
                this._speed = Math.abs(this._distance / this._time * 1000);
            }
            this._actor.rx = this._direction * this._speed;
            if (this.isComplete()) {
                this._actor.rotation = this._end;
                this._actor.rx = 0;
                this._stopped = true;
            }
        };
        RotateBy.prototype.isComplete = function () {
            var distanceTravelled = Math.abs(this._actor.rotation - this._start);
            return this._stopped || (distanceTravelled >= Math.abs(this._distance));
        };
        RotateBy.prototype.stop = function () {
            this._actor.rx = 0;
            this._stopped = true;
        };
        RotateBy.prototype.reset = function () {
            this._started = false;
        };
        return RotateBy;
    }());
    exports.RotateBy = RotateBy;
    var ScaleTo = (function () {
        function ScaleTo(actor, scaleX, scaleY, speedX, speedY) {
            this._started = false;
            this._stopped = false;
            this._actor = actor;
            this._endX = scaleX;
            this._endY = scaleY;
            this._speedX = speedX;
            this._speedY = speedY;
        }
        ScaleTo.prototype.update = function (_delta) {
            if (!this._started) {
                this._started = true;
                this._startX = this._actor.scale.x;
                this._startY = this._actor.scale.y;
                this._distanceX = Math.abs(this._endX - this._startX);
                this._distanceY = Math.abs(this._endY - this._startY);
            }
            if (!(Math.abs(this._actor.scale.x - this._startX) >= this._distanceX)) {
                var directionX = this._endY < this._startY ? -1 : 1;
                this._actor.sx = this._speedX * directionX;
            }
            else {
                this._actor.sx = 0;
            }
            if (!(Math.abs(this._actor.scale.y - this._startY) >= this._distanceY)) {
                var directionY = this._endY < this._startY ? -1 : 1;
                this._actor.sy = this._speedY * directionY;
            }
            else {
                this._actor.sy = 0;
            }
            if (this.isComplete()) {
                this._actor.scale.x = this._endX;
                this._actor.scale.y = this._endY;
                this._actor.sx = 0;
                this._actor.sy = 0;
            }
        };
        ScaleTo.prototype.isComplete = function () {
            return this._stopped || ((Math.abs(this._actor.scale.y - this._startX) >= this._distanceX) &&
                (Math.abs(this._actor.scale.y - this._startY) >= this._distanceY));
        };
        ScaleTo.prototype.stop = function () {
            this._actor.sx = 0;
            this._actor.sy = 0;
            this._stopped = true;
        };
        ScaleTo.prototype.reset = function () {
            this._started = false;
        };
        return ScaleTo;
    }());
    exports.ScaleTo = ScaleTo;
    var ScaleBy = (function () {
        function ScaleBy(actor, scaleX, scaleY, time) {
            this._started = false;
            this._stopped = false;
            this._actor = actor;
            this._endX = scaleX;
            this._endY = scaleY;
            this._speedX = (this._endX - this._actor.scale.x) / time * 1000;
            this._speedY = (this._endY - this._actor.scale.y) / time * 1000;
        }
        ScaleBy.prototype.update = function (_delta) {
            if (!this._started) {
                this._started = true;
                this._startX = this._actor.scale.x;
                this._startY = this._actor.scale.y;
                this._distanceX = Math.abs(this._endX - this._startX);
                this._distanceY = Math.abs(this._endY - this._startY);
            }
            var directionX = this._endX < this._startX ? -1 : 1;
            var directionY = this._endY < this._startY ? -1 : 1;
            this._actor.sx = this._speedX * directionX;
            this._actor.sy = this._speedY * directionY;
            if (this.isComplete()) {
                this._actor.scale.x = this._endX;
                this._actor.scale.y = this._endY;
                this._actor.sx = 0;
                this._actor.sy = 0;
            }
        };
        ScaleBy.prototype.isComplete = function () {
            return this._stopped || ((Math.abs(this._actor.scale.x - this._startX) >= this._distanceX) &&
                (Math.abs(this._actor.scale.y - this._startY) >= this._distanceY));
        };
        ScaleBy.prototype.stop = function () {
            this._actor.sx = 0;
            this._actor.sy = 0;
            this._stopped = true;
        };
        ScaleBy.prototype.reset = function () {
            this._started = false;
        };
        return ScaleBy;
    }());
    exports.ScaleBy = ScaleBy;
    var Delay = (function () {
        function Delay(actor, delay) {
            this._elapsedTime = 0;
            this._started = false;
            this._stopped = false;
            this._actor = actor;
            this._delay = delay;
        }
        Delay.prototype.update = function (delta) {
            if (!this._started) {
                this._started = true;
            }
            this.x = this._actor.pos.x;
            this.y = this._actor.pos.y;
            this._elapsedTime += delta;
        };
        Delay.prototype.isComplete = function () {
            return this._stopped || (this._elapsedTime >= this._delay);
        };
        Delay.prototype.stop = function () {
            this._stopped = true;
        };
        Delay.prototype.reset = function () {
            this._elapsedTime = 0;
            this._started = false;
        };
        return Delay;
    }());
    exports.Delay = Delay;
    var Blink = (function () {
        function Blink(actor, timeVisible, timeNotVisible, numBlinks) {
            if (numBlinks === void 0) { numBlinks = 1; }
            this._timeVisible = 0;
            this._timeNotVisible = 0;
            this._elapsedTime = 0;
            this._totalTime = 0;
            this._stopped = false;
            this._started = false;
            this._actor = actor;
            this._timeVisible = timeVisible;
            this._timeNotVisible = timeNotVisible;
            this._duration = (timeVisible + timeNotVisible) * numBlinks;
        }
        Blink.prototype.update = function (delta) {
            if (!this._started) {
                this._started = true;
            }
            this._elapsedTime += delta;
            this._totalTime += delta;
            if (this._actor.visible && this._elapsedTime >= this._timeVisible) {
                this._actor.visible = false;
                this._elapsedTime = 0;
            }
            if (!this._actor.visible && this._elapsedTime >= this._timeNotVisible) {
                this._actor.visible = true;
                this._elapsedTime = 0;
            }
            if (this.isComplete()) {
                this._actor.visible = true;
            }
        };
        Blink.prototype.isComplete = function () {
            return this._stopped || (this._totalTime >= this._duration);
        };
        Blink.prototype.stop = function () {
            this._actor.visible = true;
            this._stopped = true;
        };
        Blink.prototype.reset = function () {
            this._started = false;
            this._elapsedTime = 0;
            this._totalTime = 0;
        };
        return Blink;
    }());
    exports.Blink = Blink;
    var Fade = (function () {
        function Fade(actor, endOpacity, speed) {
            this._multiplier = 1;
            this._started = false;
            this._stopped = false;
            this._actor = actor;
            this._endOpacity = endOpacity;
            this._speed = speed;
        }
        Fade.prototype.update = function (delta) {
            if (!this._started) {
                this._started = true;
                // determine direction when we start
                if (this._endOpacity < this._actor.opacity) {
                    this._multiplier = -1;
                }
                else {
                    this._multiplier = 1;
                }
            }
            if (this._speed > 0) {
                this._actor.opacity += this._multiplier * (Math.abs(this._actor.opacity - this._endOpacity) * delta) / this._speed;
            }
            this._speed -= delta;
            if (this.isComplete()) {
                this._actor.opacity = this._endOpacity;
            }
            Log_17.Logger.getInstance().debug('[Action fade] Actor opacity:', this._actor.opacity);
        };
        Fade.prototype.isComplete = function () {
            return this._stopped || (Math.abs(this._actor.opacity - this._endOpacity) < 0.05);
        };
        Fade.prototype.stop = function () {
            this._stopped = true;
        };
        Fade.prototype.reset = function () {
            this._started = false;
        };
        return Fade;
    }());
    exports.Fade = Fade;
    var Die = (function () {
        function Die(actor) {
            this._stopped = false;
            this._actor = actor;
        }
        Die.prototype.update = function (_delta) {
            this._actor.actionQueue.clearActions();
            this._actor.kill();
            this._stopped = true;
        };
        Die.prototype.isComplete = function () {
            return this._stopped;
        };
        Die.prototype.stop = function () { return; };
        Die.prototype.reset = function () { return; };
        return Die;
    }());
    exports.Die = Die;
    var CallMethod = (function () {
        function CallMethod(actor, method) {
            this._method = null;
            this._actor = null;
            this._hasBeenCalled = false;
            this._actor = actor;
            this._method = method;
        }
        CallMethod.prototype.update = function (_delta) {
            this._method.call(this._actor);
            this._hasBeenCalled = true;
        };
        CallMethod.prototype.isComplete = function () {
            return this._hasBeenCalled;
        };
        CallMethod.prototype.reset = function () {
            this._hasBeenCalled = false;
        };
        CallMethod.prototype.stop = function () {
            this._hasBeenCalled = true;
        };
        return CallMethod;
    }());
    exports.CallMethod = CallMethod;
    var Repeat = (function () {
        function Repeat(actor, repeat, actions) {
            this._stopped = false;
            this._actor = actor;
            this._actionQueue = new ActionQueue(actor);
            this._repeat = repeat;
            this._originalRepeat = repeat;
            var i = 0, len = actions.length;
            for (i; i < len; i++) {
                actions[i].reset();
                this._actionQueue.add(actions[i]);
            }
            ;
        }
        Repeat.prototype.update = function (delta) {
            this.x = this._actor.pos.x;
            this.y = this._actor.pos.y;
            if (!this._actionQueue.hasNext()) {
                this._actionQueue.reset();
                this._repeat--;
            }
            this._actionQueue.update(delta);
        };
        Repeat.prototype.isComplete = function () {
            return this._stopped || (this._repeat <= 0);
        };
        Repeat.prototype.stop = function () {
            this._stopped = true;
        };
        Repeat.prototype.reset = function () {
            this._repeat = this._originalRepeat;
        };
        return Repeat;
    }());
    exports.Repeat = Repeat;
    var RepeatForever = (function () {
        function RepeatForever(actor, actions) {
            this._stopped = false;
            this._actor = actor;
            this._actionQueue = new ActionQueue(actor);
            var i = 0, len = actions.length;
            for (i; i < len; i++) {
                actions[i].reset();
                this._actionQueue.add(actions[i]);
            }
            ;
        }
        RepeatForever.prototype.update = function (delta) {
            this.x = this._actor.pos.x;
            this.y = this._actor.pos.y;
            if (this._stopped) {
                return;
            }
            if (!this._actionQueue.hasNext()) {
                this._actionQueue.reset();
            }
            this._actionQueue.update(delta);
        };
        RepeatForever.prototype.isComplete = function () {
            return this._stopped;
        };
        RepeatForever.prototype.stop = function () {
            this._stopped = true;
            this._actionQueue.clearActions();
        };
        RepeatForever.prototype.reset = function () { return; };
        return RepeatForever;
    }());
    exports.RepeatForever = RepeatForever;
    /**
     * Action Queues
     *
     * Action queues are part of the [[ActionContext|Action API]] and
     * store the list of actions to be executed for an [[Actor]].
     *
     * Actors implement [[Actor.actions]] which can be manipulated by
     * advanced users to adjust the actions currently being executed in the
     * queue.
     */
    var ActionQueue = (function () {
        function ActionQueue(actor) {
            this._actions = [];
            this._completedActions = [];
            this._actor = actor;
        }
        ActionQueue.prototype.add = function (action) {
            this._actions.push(action);
        };
        ActionQueue.prototype.remove = function (action) {
            var index = this._actions.indexOf(action);
            this._actions.splice(index, 1);
        };
        ActionQueue.prototype.clearActions = function () {
            this._actions.length = 0;
            this._completedActions.length = 0;
            if (this._currentAction) {
                this._currentAction.stop();
            }
        };
        ActionQueue.prototype.getActions = function () {
            return this._actions.concat(this._completedActions);
        };
        ActionQueue.prototype.hasNext = function () {
            return this._actions.length > 0;
        };
        ActionQueue.prototype.reset = function () {
            this._actions = this.getActions();
            var i = 0, len = this._actions.length;
            for (i; i < len; i++) {
                this._actions[i].reset();
            }
            this._completedActions = [];
        };
        ActionQueue.prototype.update = function (delta) {
            if (this._actions.length > 0) {
                this._currentAction = this._actions[0];
                this._currentAction.update(delta);
                if (this._currentAction.isComplete(this._actor)) {
                    this._completedActions.push(this._actions.shift());
                }
            }
        };
        return ActionQueue;
    }());
    exports.ActionQueue = ActionQueue;
});
/* istanbul ignore next */
if (typeof window === 'undefined') {
    window = { audioContext: function () { return; } };
}
/* istanbul ignore next */
if (typeof window !== 'undefined' && !window.requestAnimationFrame) {
    window.requestAnimationFrame =
        window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            function (callback) { window.setInterval(callback, 1000 / 60); };
}
/* istanbul ignore next */
if (typeof window !== 'undefined' && !window.cancelAnimationFrame) {
    window.cancelAnimationFrame =
        window.webkitCancelAnimationFrame ||
            window.mozCancelAnimationFrame ||
            function () { return; };
}
/* istanbul ignore next */
if (typeof window !== 'undefined' && !window.AudioContext) {
    window.AudioContext = window.AudioContext ||
        window.webkitAudioContext ||
        window.mozAudioContext ||
        window.msAudioContext ||
        window.oAudioContext;
}
if (typeof window !== 'undefined' && !window.devicePixelRatio) {
    window.devicePixelRatio = window.devicePixelRatio || 1;
}
// Polyfill from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
// Production steps of ECMA-262, Edition 5, 15.4.4.18
// Reference: http://es5.github.io/#x15.4.4.18
/* istanbul ignore next */
if (!Array.prototype.forEach) {
    Array.prototype.forEach = function (callback, thisArg) {
        var T, k;
        if (this == null) {
            throw new TypeError('this is null or not defined');
        }
        // 1. Let O be the result of calling ToObject passing the |this| value as the argument. 
        var O = Object(this);
        // 2. Let lenValue be the result of calling the Get internal method of O with the argument "length".
        // 3. Let len be ToUint32(lenValue).
        var len = O.length >>> 0;
        // 4. If IsCallable(callback) is false, throw a TypeError exception.
        // See: http://es5.github.com/#x9.11
        if (typeof callback !== 'function') {
            throw new TypeError(callback + ' is not a function');
        }
        // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
        if (arguments.length > 1) {
            T = thisArg;
        }
        // 6. Let k be 0
        k = 0;
        // 7. Repeat, while k < len
        while (k < len) {
            var kValue;
            // a. Let Pk be ToString(k).
            //   This is implicit for LHS operands of the in operator
            // b. Let kPresent be the result of calling the HasProperty internal method of O with argument Pk.
            //   This step can be combined with c
            // c. If kPresent is true, then
            if (k in O) {
                // i. Let kValue be the result of calling the Get internal method of O with argument Pk.
                kValue = O[k];
                // ii. Call the Call internal method of callback with T as the this value and
                // argument list containing kValue, k, and O.
                callback.call(T, kValue, k, O);
            }
            // d. Increase k by 1.
            k++;
        }
        // 8. return undefined
    };
}
// Polyfill from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some
/* istanbul ignore next */
if (!Array.prototype.some) {
    Array.prototype.some = function (fun /*, thisArg */) {
        'use strict';
        if (this === void 0 || this === null) {
            throw new TypeError();
        }
        var t = Object(this);
        var len = t.length >>> 0;
        if (typeof fun !== 'function') {
            throw new TypeError();
        }
        var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
        for (var i = 0; i < len; i++) {
            if (i in t && fun.call(thisArg, t[i], i, t)) {
                return true;
            }
        }
        return false;
    };
}
// Polyfill from  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Polyfill
/* istanbul ignore next */
if (!Function.prototype.bind) {
    Function.prototype.bind = function (oThis) {
        if (typeof this !== 'function') {
            // closest thing possible to the ECMAScript 5
            // internal IsCallable function
            throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
        }
        var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function () { return; }, fBound = function () {
            return fToBind.apply(this instanceof fNOP && oThis
                ? this
                : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));
        };
        fNOP.prototype = this.prototype;
        fBound.prototype = new fNOP();
        return fBound;
    };
}
    //The modules for your project will be inlined above
    //this snippet. Ask almond to synchronously require the
    //module value for 'main' here and return it as the
    //value to use for the public API for the built file.
    return require('Index');
}));
//# sourceMappingURL=excalibur.js.map

/***/ }),

/***/ "./src/actors/decor/backgroundObject.ts":
/*!**********************************************!*\
  !*** ./src/actors/decor/backgroundObject.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ex = __webpack_require__(/*! excalibur */ "./node_modules/excalibur/dist/excalibur.js");
var resource_1 = __webpack_require__(/*! ../../resource */ "./src/resource.ts");
var gamesettings_1 = __webpack_require__(/*! ../../gamesettings */ "./src/gamesettings.ts");
var objSprites = [resource_1.Resource.ChemicalPlant, resource_1.Resource.RadioTower];
var BackgroundObject = /** @class */ (function (_super) {
    __extends(BackgroundObject, _super);
    function BackgroundObject(scene) {
        var _this = _super.call(this) || this;
        _this.x = 1.1 * gamesettings_1.GameSettings.WIDTH + Math.floor(Math.random() * gamesettings_1.GameSettings.BG_VARIABILITY);
        _this.y = gamesettings_1.GameSettings.HEIGHT - gamesettings_1.GameSettings.GROUND_HEIGHT;
        var randi = Math.floor(Math.random() * objSprites.length);
        _this.anchor.setTo(0, 0);
        var sprite = objSprites[randi].asSprite();
        sprite.anchor.setTo(0, 1);
        _this.addDrawing(sprite);
        _this.setHeight(sprite.height);
        _this.setWidth(sprite.width);
        _this.gameScene = scene;
        return _this;
    }
    BackgroundObject.prototype.onInitialize = function (engine) {
        // do stuff
    };
    BackgroundObject.prototype.update = function (engine, delta) {
        _super.prototype.update.call(this, engine, delta); // call base update logic
        if (this.gameScene.gameOver || !this.gameScene.gameStarted)
            return;
        this.x -= gamesettings_1.GameSettings.BG_HSPEED * delta / 1000;
        if (this.x < -gamesettings_1.GameSettings.WIDTH / 2) {
            this.kill();
        }
    };
    return BackgroundObject;
}(ex.Actor));
exports.BackgroundObject = BackgroundObject;


/***/ }),

/***/ "./src/actors/obstacles/pesticide.ts":
/*!*******************************************!*\
  !*** ./src/actors/obstacles/pesticide.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ex = __webpack_require__(/*! excalibur */ "./node_modules/excalibur/dist/excalibur.js");
var resource_1 = __webpack_require__(/*! ../../resource */ "./src/resource.ts");
var gamesettings_1 = __webpack_require__(/*! ../../gamesettings */ "./src/gamesettings.ts");
var pestSprites = [resource_1.Resource.Rndp, resource_1.Resource.Smrtx, resource_1.Resource.InsctWasp, resource_1.Resource.Chogo];
var Pesticide = /** @class */ (function (_super) {
    __extends(Pesticide, _super);
    function Pesticide(xi, yi, ySpace, scene) {
        var _this = _super.call(this) || this;
        _this.x = xi;
        _this.setWidth(0.8 * gamesettings_1.GameSettings.PEST_WIDTH);
        _this.setHeight(ySpace + 2 * gamesettings_1.GameSettings.PEST_HEIGHT);
        var randi;
        do {
            randi = Math.floor(Math.random() * pestSprites.length);
        } while (randi == scene.lastPest);
        scene.lastPest = randi;
        _this.topPart = new ex.Actor();
        var topSprite = new ex.Sprite(pestSprites[randi], 0, 0, gamesettings_1.GameSettings.PEST_WIDTH, gamesettings_1.GameSettings.PEST_HEIGHT);
        topSprite.flipVertical = true;
        _this.topPart.addDrawing(topSprite);
        _this.topPart.x = 0;
        _this.topPart.y = yi - (gamesettings_1.GameSettings.PEST_HEIGHT + ySpace) / 2;
        _this.topPart.setWidth(gamesettings_1.GameSettings.PEST_WIDTH);
        _this.topPart.setHeight(gamesettings_1.GameSettings.PEST_HEIGHT);
        _this.add(_this.topPart);
        _this.bottomPart = new ex.Actor();
        var bottomSprite = new ex.Sprite(pestSprites[randi], 0, 0, gamesettings_1.GameSettings.PEST_WIDTH, gamesettings_1.GameSettings.PEST_HEIGHT);
        //bottomSprite.flipVertical = false;
        _this.bottomPart.addDrawing(bottomSprite);
        _this.bottomPart.x = 0;
        _this.bottomPart.y = yi + (gamesettings_1.GameSettings.PEST_HEIGHT + ySpace) / 2;
        _this.bottomPart.setWidth(gamesettings_1.GameSettings.PEST_WIDTH);
        _this.bottomPart.setHeight(gamesettings_1.GameSettings.PEST_HEIGHT);
        _this.add(_this.bottomPart);
        _this.gameScene = scene;
        _this.passed = false;
        return _this;
    }
    Pesticide.prototype.onInitialize = function (engine) {
        // do stuff
    };
    Pesticide.prototype.update = function (engine, delta) {
        _super.prototype.update.call(this, engine, delta); // call base update logic
        if (this.gameScene.gameOver || !this.gameScene.gameStarted)
            return;
        this.x -= gamesettings_1.GameSettings.HSPEED * delta / 1000;
        if (this.topPart.collides(this.gameScene.player) != null || this.bottomPart.collides(this.gameScene.player) != null)
            this.gameScene.setGameOver();
        if (this.x < gamesettings_1.GameSettings.PEST_WIDTH / 2) {
            if (!this.passed) {
                this.passed = true;
                this.gameScene.score++;
            }
            if (this.x < -gamesettings_1.GameSettings.PEST_WIDTH / 2) {
                this.kill();
            }
        }
    };
    return Pesticide;
}(ex.Actor));
exports.Pesticide = Pesticide;


/***/ }),

/***/ "./src/actors/player/player.ts":
/*!*************************************!*\
  !*** ./src/actors/player/player.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ex = __webpack_require__(/*! excalibur */ "./node_modules/excalibur/dist/excalibur.js");
var resource_1 = __webpack_require__(/*! ../../resource */ "./src/resource.ts");
var gamesettings_1 = __webpack_require__(/*! ../../gamesettings */ "./src/gamesettings.ts");
var Player = /** @class */ (function (_super) {
    __extends(Player, _super);
    function Player(scene) {
        var _this = _super.call(this) || this;
        _this.onPress = function () {
            //this.gameStarted = true;
            _this.pressed = true;
        };
        _this.reset = function () {
            _this.ypos = gamesettings_1.GameSettings.HEIGHT / 2;
            _this.yspeed = 0;
            _this.yacc = gamesettings_1.GameSettings.GRAVITY;
            _this.pressed = false;
            _this.y = _this.ypos;
            _this.rotation = 0;
            //this.gameStarted = false;
        };
        _this.setWidth(42);
        _this.setHeight(32);
        _this.x = 100;
        _this.ypos = gamesettings_1.GameSettings.HEIGHT / 2;
        _this.yspeed = 0;
        _this.yacc = gamesettings_1.GameSettings.GRAVITY;
        _this.pressed = false;
        _this.y = _this.ypos;
        //this.gameStarted = false;
        _this.gameScene = scene;
        return _this;
    }
    Player.prototype.onInitialize = function (engine) {
        this.addDrawing("idle", new ex.Sprite(resource_1.Resource.TxPlayer, 0, 0, 64, 64));
        this.setDrawing("idle");
        var playerIdleSheet = new ex.SpriteSheet(resource_1.Resource.TxPlayer, 16, 1, 64, 64);
        this.flapAnimation = playerIdleSheet.getAnimationBetween(engine, 1, 16, 3);
        this.flapAnimation.loop = false;
        this.addDrawing("flap", this.flapAnimation);
        engine.input.pointers.primary.on("down", this.onPress);
    };
    Player.prototype.update = function (engine, delta) {
        _super.prototype.update.call(this, engine, delta); // call base update logic
        if (this.gameScene.gameOver || !this.gameScene.gameStarted)
            return;
        if (this.pressed) {
            this.yspeed = gamesettings_1.GameSettings.FORCE;
            this.setDrawing("flap");
        }
        else
            this.yspeed = gamesettings_1.GameSettings.GRAVITY + (this.yspeed - gamesettings_1.GameSettings.GRAVITY) * (Math.exp(-delta / (1000 * gamesettings_1.GameSettings.INERTIA)));
        this.ypos += this.yspeed * delta / 1000;
        this.y = this.ypos;
        //this.rotation = Math.max(-0.3, Math.min(0.3, Math.atan2(this.yspeed, GameSettings.HSPEED)/2));
        this.rotation = this.yspeed < 300 ? -0.3 : (this.yspeed > 600 ? 0.3 : -0.9 + 0.002 * this.yspeed);
        this.pressed = false;
        if (this.flapAnimation.isDone())
            this.setDrawing("idle");
        if (this.collides(this.gameScene.ground) != null)
            this.gameScene.setGameOver();
    };
    return Player;
}(ex.Actor));
exports.Player = Player;


/***/ }),

/***/ "./src/communication.ts":
/*!******************************!*\
  !*** ./src/communication.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Communication;
(function (Communication) {
    // class ScoreMessage {
    //     public messageType: string;
    //     public score: number;
    //     constructor() {
    //         this.messageType = "SCORE";
    //     }
    // }
    function postScore(newScore) {
        var msg = { messageType: "SCORE", score: newScore };
        window.parent.postMessage(msg, "*");
        //console.log(msg);
    }
    Communication.postScore = postScore;
})(Communication = exports.Communication || (exports.Communication = {}));


/***/ }),

/***/ "./src/gamesettings.ts":
/*!*****************************!*\
  !*** ./src/gamesettings.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var GameSettings;
(function (GameSettings) {
    GameSettings.WIDTH = 800;
    GameSettings.HEIGHT = 600;
    GameSettings.GRAVITY = 800;
    GameSettings.FORCE = -800;
    GameSettings.INERTIA = 0.3;
    GameSettings.HSPEED = 200;
    GameSettings.TIME_INTERVAL = 1.5;
    GameSettings.VARIABILITY = 100;
    GameSettings.MAX_SPACE = 180;
    GameSettings.MIN_SPACE = 100;
    GameSettings.SCORE_MAX_DIFF = 100;
    GameSettings.START_V_LIMIT = 0.2;
    GameSettings.END_V_LIMIT = 1;
    GameSettings.BG_TIME_INTERVAL = 30;
    GameSettings.BG_HSPEED = 80;
    GameSettings.BG_VARIABILITY = 300;
    GameSettings.GROUND_HEIGHT = 64;
    GameSettings.PEST_HEIGHT = 512;
    GameSettings.PEST_WIDTH = 64;
})(GameSettings = exports.GameSettings || (exports.GameSettings = {}));


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ex = __webpack_require__(/*! excalibur */ "./node_modules/excalibur/dist/excalibur.js");
var gamescene_1 = __webpack_require__(/*! ./scenes/gameScene/gamescene */ "./src/scenes/gameScene/gamescene.ts");
var resource_1 = __webpack_require__(/*! ./resource */ "./src/resource.ts");
var gamesettings_1 = __webpack_require__(/*! ./gamesettings */ "./src/gamesettings.ts");
var Game = /** @class */ (function (_super) {
    __extends(Game, _super);
    function Game() {
        return _super.call(this, { width: gamesettings_1.GameSettings.WIDTH,
            height: gamesettings_1.GameSettings.HEIGHT,
            displayMode: ex.DisplayMode.Fixed,
            pointerScope: ex.Input.PointerScope.Canvas }) || this;
    }
    Game.prototype.start = function (loader) {
        return _super.prototype.start.call(this, loader);
    };
    return Game;
}(ex.Engine));
var loader = new ex.Loader();
for (var resource in resource_1.Resource) {
    loader.addResource(resource_1.Resource[resource]);
}
var game = new Game();
var gameScene = new gamescene_1.GameScene();
game.add('gameScene', gameScene);
game.start(loader).then(function () {
    game.goToScene('gameScene');
});


/***/ }),

/***/ "./src/resource.ts":
/*!*************************!*\
  !*** ./src/resource.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ex = __webpack_require__(/*! excalibur */ "./node_modules/excalibur/dist/excalibur.js");
// Image and sound resources to be loaded
var Resource = {
    Background: new ex.Texture("assets/background.png"),
    TxPlayer: new ex.Texture("assets/bee.png"),
    Ground: new ex.Texture("assets/ground.png"),
    Rndp: new ex.Texture("assets/rndp.png"),
    Smrtx: new ex.Texture("assets/smrtx.png"),
    InsctWasp: new ex.Texture("assets/insct_wasp.png"),
    Chogo: new ex.Texture("assets/chogo.png"),
    ChemicalPlant: new ex.Texture("assets/chemical_plant.png"),
    RadioTower: new ex.Texture("assets/radio_tower.png")
};
exports.Resource = Resource;


/***/ }),

/***/ "./src/scenes/gameScene/gamescene.ts":
/*!*******************************************!*\
  !*** ./src/scenes/gameScene/gamescene.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ex = __webpack_require__(/*! excalibur */ "./node_modules/excalibur/dist/excalibur.js");
var resource_1 = __webpack_require__(/*! ../../resource */ "./src/resource.ts");
var player_1 = __webpack_require__(/*! ../../actors/player/player */ "./src/actors/player/player.ts");
var pesticide_1 = __webpack_require__(/*! ../../actors/obstacles/pesticide */ "./src/actors/obstacles/pesticide.ts");
var backgroundObject_1 = __webpack_require__(/*! ../../actors/decor/backgroundObject */ "./src/actors/decor/backgroundObject.ts");
var gamesettings_1 = __webpack_require__(/*! ../../gamesettings */ "./src/gamesettings.ts");
var communication_1 = __webpack_require__(/*! ../../communication */ "./src/communication.ts");
//import { Input } from 'excalibur';
var GameScene = /** @class */ (function (_super) {
    __extends(GameScene, _super);
    function GameScene() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.onPress = function () {
            if (!_this.gameStarted) {
                _this.gameStarted = true;
                _this.centerLabel.visible = false;
            }
            if (_this.gameOver && _this.canRestart)
                _this.resetScene = true;
        };
        _this.setGameOver = function () {
            _this.gameOver = true;
            _this.centerLabel.text = "Game Over";
            _this.centerLabel.visible = true;
            _this.lastObstacleTime = 0;
            communication_1.Communication.postScore(_this.score);
        };
        return _this;
    }
    GameScene.prototype.onInitialize = function (engine) {
        this.score = 0;
        var background = new ex.Actor();
        background.addDrawing(resource_1.Resource.Background.asSprite());
        this.add(background);
        background.x = gamesettings_1.GameSettings.WIDTH / 2;
        background.y = gamesettings_1.GameSettings.HEIGHT / 2;
        background.z = -10;
        this.player = new player_1.Player(this);
        this.add(this.player);
        this.player.z = 7;
        this.lastObstacleTime = gamesettings_1.GameSettings.TIME_INTERVAL;
        this.lastObstacleY = gamesettings_1.GameSettings.HEIGHT / 2;
        this.lastPest = -1;
        this.lastBackgroundTime = gamesettings_1.GameSettings.BG_TIME_INTERVAL;
        this.centerLabel = new ex.Label("Click to start flapping.", gamesettings_1.GameSettings.WIDTH / 2, gamesettings_1.GameSettings.HEIGHT / 2, "Arial");
        this.centerLabel.textAlign = ex.TextAlign.Center;
        this.centerLabel.baseAlign = ex.BaseAlign.Middle;
        this.centerLabel.fontSize = 42;
        this.centerLabel.color = ex.Color.White;
        this.add(this.centerLabel);
        this.centerLabel.z = 10;
        this.restartLabel = new ex.Label("click to restart", gamesettings_1.GameSettings.WIDTH / 2, gamesettings_1.GameSettings.HEIGHT / 2 + 32, "Arial");
        this.restartLabel.textAlign = ex.TextAlign.Center;
        this.restartLabel.baseAlign = ex.BaseAlign.Top;
        this.restartLabel.fontSize = 28;
        this.restartLabel.color = ex.Color.White;
        this.add(this.restartLabel);
        this.restartLabel.z = 10;
        this.restartLabel.visible = false;
        this.scoreLabel = new ex.Label("0", gamesettings_1.GameSettings.WIDTH - 32, 32, "Arial");
        this.scoreLabel.textAlign = ex.TextAlign.Right;
        this.scoreLabel.baseAlign = ex.BaseAlign.Top;
        this.scoreLabel.fontSize = 42;
        this.scoreLabel.color = ex.Color.White;
        this.add(this.scoreLabel);
        this.scoreLabel.z = 10;
        this.gameStarted = false;
        this.gameOver = false;
        this.resetScene = false;
        this.canRestart = false;
        this.ground = new ex.Actor();
        this.ground.addDrawing(resource_1.Resource.Ground.asSprite());
        this.ground.x = gamesettings_1.GameSettings.WIDTH / 2;
        this.ground.y = gamesettings_1.GameSettings.HEIGHT - gamesettings_1.GameSettings.GROUND_HEIGHT / 2;
        this.ground.setWidth(gamesettings_1.GameSettings.WIDTH);
        this.ground.setHeight(gamesettings_1.GameSettings.GROUND_HEIGHT);
        this.add(this.ground);
        this.ground.z = 5;
        engine.input.pointers.primary.on("down", this.onPress);
        //engine.input.keyboard.on("press", (evt: Input.KeyEvent) => { if(evt.key == Input.Keys.Space) this.onSpace() });
        this.camera.pos = new ex.Vector(gamesettings_1.GameSettings.WIDTH / 2, gamesettings_1.GameSettings.HEIGHT / 2);
    };
    GameScene.prototype.update = function (engine, delta) {
        _super.prototype.update.call(this, engine, delta);
        if (this.gameOver && !this.canRestart) {
            this.lastObstacleTime += delta / 1000;
            if (this.lastObstacleTime > 1) {
                this.canRestart = true;
                this.restartLabel.visible = true;
            }
        }
        if (this.resetScene) {
            for (var ac in this.actors) {
                if (this.actors[ac] instanceof pesticide_1.Pesticide || this.actors[ac] instanceof backgroundObject_1.BackgroundObject) {
                    this.actors[ac].kill();
                }
            }
            this.player.reset();
            this.score = 0;
            this.restartLabel.visible = false;
            this.centerLabel.text = "Click to start flapping.";
            this.gameStarted = false;
            this.gameOver = false;
            this.canRestart = false;
            this.lastObstacleTime = gamesettings_1.GameSettings.TIME_INTERVAL;
            this.lastObstacleY = gamesettings_1.GameSettings.HEIGHT / 2;
            this.lastBackgroundTime = gamesettings_1.GameSettings.BG_TIME_INTERVAL;
            this.resetScene = false;
        }
        else if (this.gameOver || !this.gameStarted)
            return;
        else {
            //super.update(engine, delta); // call base update logic
            this.lastObstacleTime += delta / 1000;
            this.lastBackgroundTime += delta / 1000;
            if (this.lastObstacleTime > gamesettings_1.GameSettings.TIME_INTERVAL) {
                var posx = gamesettings_1.GameSettings.WIDTH + Math.floor(Math.random() * gamesettings_1.GameSettings.VARIABILITY);
                var spaceY = Math.floor(gamesettings_1.GameSettings.MAX_SPACE - (gamesettings_1.GameSettings.MAX_SPACE - gamesettings_1.GameSettings.MIN_SPACE) / gamesettings_1.GameSettings.SCORE_MAX_DIFF);
                var posy;
                do {
                    posy = Math.floor(spaceY + Math.random() * (gamesettings_1.GameSettings.HEIGHT - gamesettings_1.GameSettings.GROUND_HEIGHT - 2 * spaceY));
                } while (Math.abs(posy - this.lastObstacleY) > (gamesettings_1.GameSettings.START_V_LIMIT + (gamesettings_1.GameSettings.END_V_LIMIT - gamesettings_1.GameSettings.START_V_LIMIT) * this.score / gamesettings_1.GameSettings.SCORE_MAX_DIFF) * gamesettings_1.GameSettings.HEIGHT);
                //alert(posx + " " + posy + " " + spaceY);
                this.add(new pesticide_1.Pesticide(posx, posy, spaceY, this));
                this.lastObstacleY = posy;
                this.lastObstacleTime = 0;
            }
            if (this.lastBackgroundTime > gamesettings_1.GameSettings.BG_TIME_INTERVAL) {
                var bg = new backgroundObject_1.BackgroundObject(this);
                this.add(bg);
                bg.z = -3;
                this.lastBackgroundTime = 0;
            }
            this.scoreLabel.text = this.score.toString();
        }
    };
    GameScene.prototype.onActivate = function () { };
    GameScene.prototype.onDeactivate = function () { };
    return GameScene;
}(ex.Scene));
exports.GameScene = GameScene;


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V4Y2FsaWJ1ci9kaXN0L2V4Y2FsaWJ1ci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYWN0b3JzL2RlY29yL2JhY2tncm91bmRPYmplY3QudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FjdG9ycy9vYnN0YWNsZXMvcGVzdGljaWRlLnRzIiwid2VicGFjazovLy8uL3NyYy9hY3RvcnMvcGxheWVyL3BsYXllci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tbXVuaWNhdGlvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZ2FtZXNldHRpbmdzLnRzIiwid2VicGFjazovLy8uL3NyYy9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVzb3VyY2UudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjZW5lcy9nYW1lU2NlbmUvZ2FtZXNjZW5lLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlEQUFpRCxjQUFjO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOzs7QUFHQTtBQUNBOzs7Ozs7Ozs7Ozs7Z0VDbkVBO0FBQ0E7QUFDQSxpR0FBaUc7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUFBO0FBQ1QsS0FBSyxRQVFMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixtQkFBbUI7QUFDbkIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLE9BQU87QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE9BQU87QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsMENBQTBDO0FBQzFDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQix1RkFBdUY7QUFDdkY7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsaUdBQWlHO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0JBQWdCLHNDQUFzQyxpQkFBaUIsRUFBRTtBQUNuRix5QkFBeUIsdURBQXVEO0FBQ2hGO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxtRUFBbUU7QUFDeEUsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsa0JBQWtCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFVBQVU7QUFDekMsK0JBQStCLFVBQVU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGdIQUFnSDtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxxRkFBcUY7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyw2REFBNkQ7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssbUVBQW1FO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHVCQUF1QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qyx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdUJBQXVCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxpQkFBaUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMseUJBQXlCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsY0FBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBCQUEwQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsWUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssMkNBQTJDO0FBQ2hELENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdDQUFnQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQ0FBZ0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsc0NBQXNDO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsV0FBVztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixXQUFXO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFdBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsV0FBVztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssMkNBQTJDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsNkRBQTZEO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxjQUFjO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGdCQUFnQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHVCQUF1QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELDRCQUE0QixFQUFFO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUUsV0FBVyxFQUFFO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixTQUFTO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsZ0JBQWdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVELDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdCQUFnQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxxQ0FBcUM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0MsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdCQUF3QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsbUNBQW1DO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsVUFBVTtBQUM1QyxpQ0FBaUMsU0FBUztBQUMxQyxtQ0FBbUMsV0FBVztBQUM5QyxvQ0FBb0MsWUFBWTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtQkFBbUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsdUNBQXVDO0FBQzFFLDREQUE0RCwrQkFBK0IsRUFBRTtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsNEJBQTRCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDRCQUE0QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsOEJBQThCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0JBQWdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsbUNBQW1DO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUNBQW1DO0FBQ2xFLG1DQUFtQyxlQUFlO0FBQ2xELDZCQUE2QixjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQ0FBbUM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGFBQWE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxZQUFZO0FBQzVDLGdDQUFnQyw4QkFBOEI7QUFDOUQsOEJBQThCLGFBQWE7QUFDM0M7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsOEJBQThCO0FBQzlELDhCQUE4QixhQUFhO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx3Q0FBd0M7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx3Q0FBd0M7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHdDQUF3QztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHNEQUFzRDtBQUM3RjtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGVBQWU7QUFDdEQ7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssdURBQXVEO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJCQUEyQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEUsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsZ0JBQWdCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsc0JBQXNCLEVBQUU7QUFDL0U7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEUsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGtCQUFrQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRCw0Q0FBNEMsUUFBUTtBQUNwRCx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGdCQUFnQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxrQkFBa0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGVBQWU7QUFDMUMsK0JBQStCLGtCQUFrQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEYsa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwyQkFBMkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssdURBQXVEO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssMERBQTBEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDBEQUEwRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSywwREFBMEQ7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBSSxhQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMscUJBQXFCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRCwyQ0FBMkMsUUFBUTtBQUNuRCx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxxQkFBcUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGdCQUFnQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGdCQUFnQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsc0JBQXNCLEVBQUU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsZ0JBQWdCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxnQkFBZ0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHNCQUFzQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0IsNEJBQTRCLEVBQUU7QUFDbkUsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHdCQUF3QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCwrQkFBK0I7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkY7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsK0JBQStCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pELHlDQUF5QyxRQUFRO0FBQ2pELDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0EsZ0NBQWdDO0FBQ2hDLHFCQUFxQixHQUFHLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUY7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEUsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMkJBQTJCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix5Q0FBeUM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxnRUFBZ0U7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsbURBQW1EO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHlCQUF5QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCx3QkFBd0IsRUFBRTtBQUMzRSxxREFBcUQseUNBQXlDLEVBQUU7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxvQkFBb0IsRUFBRTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsVUFBVTtBQUNyQywrQkFBK0IsVUFBVTtBQUN6QztBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxZQUFZO0FBQ3RELDZDQUE2QyxhQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCLHVCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixvREFBb0QsYUFBYTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbUJBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbUJBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGVBQWU7QUFDbEQscUNBQXFDLGNBQWM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsUUFBUSxFQUFFO0FBQ3ZDLDZCQUE2QixhQUFhLEVBQUU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGFBQWE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZ0RBQWdELHlCQUF5QjtBQUN6RSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHVIQUF1SDtBQUNoSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEUsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsT0FBTztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxrQ0FBa0M7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxvQkFBb0IsRUFBRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHFCQUFxQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxxQkFBcUIsRUFBRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMscUJBQXFCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxnQkFBZ0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxnQkFBZ0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsT0FBTztBQUNqRTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxxQkFBcUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGdCQUFnQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxxQkFBcUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHFCQUFxQixFQUFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFlBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsWUFBWTtBQUN2QywrQkFBK0IsV0FBVztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxnRUFBZ0U7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFlBQVk7QUFDdkMsK0JBQStCLFdBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUsseUVBQXlFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGtCQUFrQjtBQUN4RCx1Q0FBdUMsc0NBQXNDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RCwyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDLHlDQUF5QztBQUN6Qyw4QkFBOEI7QUFDOUI7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSxrREFBa0Q7QUFDbEQsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsa0JBQWtCO0FBQ2xCLDREQUE0RDtBQUM1RDtBQUNBLDJDQUEyQztBQUMzQztBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQiw4QkFBOEI7QUFDOUIsMERBQTBEO0FBQzFEO0FBQ0EsK0VBQStFO0FBQy9FLCtFQUErRTtBQUMvRSxrRkFBa0Y7QUFDbEY7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZELHNFQUFzRTtBQUN0RSw2REFBNkQ7QUFDN0Q7QUFDQSw0QkFBNEI7QUFDNUIsdUZBQXVGO0FBQ3ZGLHlGQUF5RjtBQUN6Riw0RkFBNEY7QUFDNUYsK0JBQStCO0FBQy9CLHVDQUF1QztBQUN2QyxpQ0FBaUM7QUFDakMsb0NBQW9DO0FBQ3BDLGlFQUFpRTtBQUNqRSxpRUFBaUU7QUFDakUsNkNBQTZDO0FBQzdDLG9DQUFvQztBQUNwQztBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsOEJBQThCO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRSwrREFBK0Q7QUFDL0QsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCx3RUFBd0U7QUFDeEUsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCwrREFBK0Q7QUFDL0QsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQSwrR0FBK0c7QUFDL0c7QUFDQTtBQUNBLG9IQUFvSDtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0Usb0JBQW9CO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSxnRUFBZ0UsU0FBUztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdUJBQXVCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELG9CQUFvQixFQUFFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFNBQVM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMkJBQTJCO0FBQ2xEO0FBQ0E7QUFDQSx1QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGVBQWU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLG9EQUFvRDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDJDQUEyQztBQUNoRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssZ0VBQWdFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssc0VBQXNFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHlFQUF5RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxtRUFBbUU7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLFNBQVM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxTQUFTO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUNBQWlDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSywyQ0FBMkM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdUJBQXVCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxHQUFHLGlHQUFpRztBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsaUVBQWlFLGdCQUFnQjtBQUNqRjtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLGlEQUFpRDtBQUNqRCxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyxpREFBaUQ7QUFDakQsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssZ0VBQWdFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDJGQUEyRjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsc0NBQXNDO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRHQUE0RyxjQUFjLG9CQUFvQixlQUFlLGtCQUFrQixtQkFBbUI7QUFDbE07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5SEFBeUgsZ0JBQWdCO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlCQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdDQUFnQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsaUJBQWlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGdCQUFnQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFNBQVM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZ0JBQWdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsU0FBUztBQUMxRDtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELHlCQUF5QjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsU0FBUztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxTQUFTO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxTQUFTO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxnQkFBZ0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGdCQUFnQjtBQUM5RDtBQUNBO0FBQ0EscURBQXFELGdCQUFnQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHNDQUFzQztBQUMzRTtBQUNBO0FBQ0EscUNBQXFDLDBCQUEwQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZ0JBQWdCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsaUJBQWlCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0JBQWdCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBCQUEwQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwwQkFBMEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdCQUF3QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBCQUEwQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHNFQUFzRTtBQUMzRSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGVBQWU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRCwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsUUFBUTtBQUM3RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGNBQWMsNEJBQTRCLFFBQVEsRUFBRTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMseUNBQXlDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRyxRQUFRLEVBQUU7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxxQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMzBmQSw0RkFBZ0M7QUFDaEMsZ0ZBQTBDO0FBQzFDLDRGQUFrRDtBQUdsRCxJQUFNLFVBQVUsR0FBRyxDQUFDLG1CQUFRLENBQUMsYUFBYSxFQUFFLG1CQUFRLENBQUMsVUFBVSxDQUFDLENBQUM7QUFFakU7SUFBK0Isb0NBQVE7SUFJbkMsMEJBQVksS0FBZ0I7UUFBNUIsWUFDSSxpQkFBTyxTQWlCVjtRQWZHLEtBQUksQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFDLDJCQUFZLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLDJCQUFZLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDMUYsS0FBSSxDQUFDLENBQUMsR0FBRywyQkFBWSxDQUFDLE1BQU0sR0FBRywyQkFBWSxDQUFDLGFBQWEsQ0FBQztRQUUxRCxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFMUQsS0FBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBRXhCLElBQUksTUFBTSxHQUFHLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUMxQyxNQUFNLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDMUIsS0FBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUV4QixLQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUM5QixLQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUU1QixLQUFJLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQzs7SUFDM0IsQ0FBQztJQUVNLHVDQUFZLEdBQW5CLFVBQW9CLE1BQWlCO1FBQ2pDLFdBQVc7SUFDZixDQUFDO0lBRU0saUNBQU0sR0FBYixVQUFjLE1BQWlCLEVBQUUsS0FBYTtRQUM1QyxpQkFBTSxNQUFNLFlBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMseUJBQXlCO1FBRXRELEVBQUUsRUFBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDO1lBQ3RELE1BQU0sQ0FBQztRQUVYLElBQUksQ0FBQyxDQUFDLElBQUksMkJBQVksQ0FBQyxTQUFTLEdBQUcsS0FBSyxHQUFDLElBQUksQ0FBQztRQUU1QyxFQUFFLEVBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLDJCQUFZLENBQUMsS0FBSyxHQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDaEMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ2hCLENBQUM7SUFDTixDQUFDO0lBQ0osdUJBQUM7QUFBRCxDQUFDLENBeEM4QixFQUFFLENBQUMsS0FBSyxHQXdDdEM7QUFFUSw0Q0FBZ0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqRHpCLDRGQUFnQztBQUNoQyxnRkFBMEM7QUFDMUMsNEZBQWtEO0FBR2xELElBQU0sV0FBVyxHQUFHLENBQUMsbUJBQVEsQ0FBQyxJQUFJLEVBQUUsbUJBQVEsQ0FBQyxLQUFLLEVBQUUsbUJBQVEsQ0FBQyxTQUFTLEVBQUUsbUJBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUV4RjtJQUF3Qiw2QkFBUTtJQU01QixtQkFBWSxFQUFVLEVBQUUsRUFBVSxFQUFFLE1BQWMsRUFBRSxLQUFnQjtRQUFwRSxZQUNJLGlCQUFPLFNBa0NWO1FBaENHLEtBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQ1osS0FBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLEdBQUMsMkJBQVksQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUMzQyxLQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLEdBQUcsMkJBQVksQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUV0RCxJQUFJLEtBQUssQ0FBQztRQUNWLEdBQUcsQ0FBQztZQUNBLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDM0QsQ0FBQyxRQUFPLEtBQUssSUFBSSxLQUFLLENBQUMsUUFBUSxFQUFFO1FBQ2pDLEtBQUssQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDO1FBRXZCLEtBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxFQUFFLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDOUIsSUFBSSxTQUFTLEdBQUcsSUFBSSxFQUFFLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLDJCQUFZLENBQUMsVUFBVSxFQUFFLDJCQUFZLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDM0csU0FBUyxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUM7UUFDOUIsS0FBSSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDbkMsS0FBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ25CLEtBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLDJCQUFZLENBQUMsV0FBVyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUM5RCxLQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQywyQkFBWSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQy9DLEtBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLDJCQUFZLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDakQsS0FBSSxDQUFDLEdBQUcsQ0FBQyxLQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFdkIsS0FBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLEVBQUUsQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUNqQyxJQUFJLFlBQVksR0FBRyxJQUFJLEVBQUUsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsMkJBQVksQ0FBQyxVQUFVLEVBQUUsMkJBQVksQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUM5RyxvQ0FBb0M7UUFDcEMsS0FBSSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDekMsS0FBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3RCLEtBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLDJCQUFZLENBQUMsV0FBVyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNqRSxLQUFJLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQywyQkFBWSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ2xELEtBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLDJCQUFZLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDcEQsS0FBSSxDQUFDLEdBQUcsQ0FBQyxLQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7UUFFMUIsS0FBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7UUFDdkIsS0FBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUM7O0lBQ3hCLENBQUM7SUFFTSxnQ0FBWSxHQUFuQixVQUFvQixNQUFpQjtRQUNqQyxXQUFXO0lBQ2YsQ0FBQztJQUVNLDBCQUFNLEdBQWIsVUFBYyxNQUFpQixFQUFFLEtBQWE7UUFDNUMsaUJBQU0sTUFBTSxZQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLHlCQUF5QjtRQUV0RCxFQUFFLEVBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQztZQUN0RCxNQUFNLENBQUM7UUFFWCxJQUFJLENBQUMsQ0FBQyxJQUFJLDJCQUFZLENBQUMsTUFBTSxHQUFHLEtBQUssR0FBQyxJQUFJLENBQUM7UUFFM0MsRUFBRSxFQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLElBQUksSUFBSSxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLElBQUksSUFBSSxDQUFDO1lBQ2hILElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxFQUFFLENBQUM7UUFFaEMsRUFBRSxFQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsMkJBQVksQ0FBQyxVQUFVLEdBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNwQyxFQUFFLEVBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztnQkFDZCxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQztnQkFDbkIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUMzQixDQUFDO1lBRUQsRUFBRSxFQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQywyQkFBWSxDQUFDLFVBQVUsR0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNyQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDaEIsQ0FBQztRQUNMLENBQUM7SUFDSixDQUFDO0lBQ0osZ0JBQUM7QUFBRCxDQUFDLENBckV1QixFQUFFLENBQUMsS0FBSyxHQXFFL0I7QUFFUSw4QkFBUzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlFbEIsNEZBQWdDO0FBQ2hDLGdGQUEwQztBQUMxQyw0RkFBa0Q7QUFHbEQ7SUFBcUIsMEJBQVE7SUFTekIsZ0JBQVksS0FBZ0I7UUFBNUIsWUFDSSxpQkFBTyxTQWVWO1FBY00sYUFBTyxHQUFHO1lBQ2IsMEJBQTBCO1lBQzFCLEtBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO1FBQ3hCLENBQUM7UUFFTSxXQUFLLEdBQUc7WUFDWCxLQUFJLENBQUMsSUFBSSxHQUFHLDJCQUFZLENBQUMsTUFBTSxHQUFDLENBQUMsQ0FBQztZQUNsQyxLQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztZQUNoQixLQUFJLENBQUMsSUFBSSxHQUFHLDJCQUFZLENBQUMsT0FBTyxDQUFDO1lBQ2pDLEtBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO1lBQ3JCLEtBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSSxDQUFDLElBQUksQ0FBQztZQUNuQixLQUFJLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQztZQUVsQiwyQkFBMkI7UUFDL0IsQ0FBQztRQXpDRyxLQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ2xCLEtBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDbkIsS0FBSSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUM7UUFFYixLQUFJLENBQUMsSUFBSSxHQUFHLDJCQUFZLENBQUMsTUFBTSxHQUFDLENBQUMsQ0FBQztRQUNsQyxLQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztRQUNoQixLQUFJLENBQUMsSUFBSSxHQUFHLDJCQUFZLENBQUMsT0FBTyxDQUFDO1FBQ2pDLEtBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO1FBQ3JCLEtBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSSxDQUFDLElBQUksQ0FBQztRQUVuQiwyQkFBMkI7UUFFM0IsS0FBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7O0lBQzNCLENBQUM7SUFFTSw2QkFBWSxHQUFuQixVQUFvQixNQUFpQjtRQUNqQyxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBRSxJQUFJLEVBQUUsQ0FBQyxNQUFNLENBQUMsbUJBQVEsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUN4RSxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRXhCLElBQU0sZUFBZSxHQUFHLElBQUksRUFBRSxDQUFDLFdBQVcsQ0FBQyxtQkFBUSxDQUFDLFFBQVEsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUM3RSxJQUFJLENBQUMsYUFBYSxHQUFHLGVBQWUsQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUMzRSxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksR0FBRyxLQUFLLENBQUM7UUFDaEMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBRTVDLE1BQU0sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUMzRCxDQUFDO0lBa0JNLHVCQUFNLEdBQWIsVUFBYyxNQUFpQixFQUFFLEtBQWE7UUFDNUMsaUJBQU0sTUFBTSxZQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLHlCQUF5QjtRQUV0RCxFQUFFLEVBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQztZQUN0RCxNQUFNLENBQUM7UUFFWCxFQUFFLEVBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7WUFDZCxJQUFJLENBQUMsTUFBTSxHQUFHLDJCQUFZLENBQUMsS0FBSyxDQUFDO1lBQ2pDLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDNUIsQ0FBQztRQUNELElBQUk7WUFDQSxJQUFJLENBQUMsTUFBTSxHQUFHLDJCQUFZLENBQUMsT0FBTyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sR0FBRywyQkFBWSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBQyxDQUFDLElBQUksR0FBQywyQkFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUUvSCxJQUFJLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxHQUFDLElBQUksQ0FBQztRQUN0QyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7UUFDbkIsZ0dBQWdHO1FBQ2hHLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLEtBQUssR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFbEcsSUFBSSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUM7UUFFckIsRUFBRSxFQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxFQUFFLENBQUM7WUFDM0IsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUc1QixFQUFFLEVBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxJQUFJLElBQUksQ0FBQztZQUM3QyxJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQ25DLENBQUM7SUFDSixhQUFDO0FBQUQsQ0FBQyxDQWxGb0IsRUFBRSxDQUFDLEtBQUssR0FrRjVCO0FBRVEsd0JBQU07Ozs7Ozs7Ozs7Ozs7OztBQ3pGZixJQUFpQixhQUFhLENBZTdCO0FBZkQsV0FBaUIsYUFBYTtJQUMxQix1QkFBdUI7SUFDdkIsa0NBQWtDO0lBQ2xDLDRCQUE0QjtJQUU1QixzQkFBc0I7SUFDdEIsc0NBQXNDO0lBQ3RDLFFBQVE7SUFDUixJQUFJO0lBRUosbUJBQTJCLFFBQWdCO1FBQ3ZDLElBQUksR0FBRyxHQUFHLEVBQUMsV0FBVyxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFDLENBQUM7UUFDbEQsTUFBTSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQ3BDLG1CQUFtQjtJQUN2QixDQUFDO0lBSmUsdUJBQVMsWUFJeEI7QUFDTCxDQUFDLEVBZmdCLGFBQWEsR0FBYixxQkFBYSxLQUFiLHFCQUFhLFFBZTdCOzs7Ozs7Ozs7Ozs7Ozs7QUNmRCxJQUFpQixZQUFZLENBd0I1QjtBQXhCRCxXQUFpQixZQUFZO0lBQ1osa0JBQUssR0FBRyxHQUFHLENBQUM7SUFDWixtQkFBTSxHQUFHLEdBQUcsQ0FBQztJQUViLG9CQUFPLEdBQUcsR0FBRyxDQUFDO0lBQ2Qsa0JBQUssR0FBRyxDQUFDLEdBQUcsQ0FBQztJQUNiLG9CQUFPLEdBQUcsR0FBRyxDQUFDO0lBQ2QsbUJBQU0sR0FBRyxHQUFHLENBQUM7SUFFYiwwQkFBYSxHQUFHLEdBQUcsQ0FBQztJQUNwQix3QkFBVyxHQUFHLEdBQUcsQ0FBQztJQUNsQixzQkFBUyxHQUFHLEdBQUcsQ0FBQztJQUNoQixzQkFBUyxHQUFHLEdBQUcsQ0FBQztJQUNoQiwyQkFBYyxHQUFHLEdBQUcsQ0FBQztJQUNyQiwwQkFBYSxHQUFHLEdBQUcsQ0FBQztJQUNwQix3QkFBVyxHQUFHLENBQUMsQ0FBQztJQUVoQiw2QkFBZ0IsR0FBRyxFQUFFLENBQUM7SUFDdEIsc0JBQVMsR0FBRyxFQUFFLENBQUM7SUFDZiwyQkFBYyxHQUFHLEdBQUcsQ0FBQztJQUVyQiwwQkFBYSxHQUFHLEVBQUUsQ0FBQztJQUNuQix3QkFBVyxHQUFHLEdBQUcsQ0FBQztJQUNsQix1QkFBVSxHQUFHLEVBQUUsQ0FBQztBQUNqQyxDQUFDLEVBeEJnQixZQUFZLEdBQVosb0JBQVksS0FBWixvQkFBWSxRQXdCNUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4QkQsNEZBQWdDO0FBQ2hDLGlIQUF5RDtBQUV6RCw0RUFBc0M7QUFDdEMsd0ZBQThDO0FBRTlDO0lBQW1CLHdCQUFTO0lBQ3hCO2VBQ0ksa0JBQU0sRUFBRSxLQUFLLEVBQUUsMkJBQVksQ0FBQyxLQUFLO1lBQ3pCLE1BQU0sRUFBRSwyQkFBWSxDQUFDLE1BQU07WUFDM0IsV0FBVyxFQUFFLEVBQUUsQ0FBQyxXQUFXLENBQUMsS0FBSztZQUNqQyxZQUFZLEVBQUUsRUFBRSxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsTUFBTSxFQUFFLENBQUM7SUFDekQsQ0FBQztJQUVNLG9CQUFLLEdBQVosVUFBYSxNQUFtQjtRQUM1QixNQUFNLENBQUMsaUJBQU0sS0FBSyxZQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQy9CLENBQUM7SUFDTCxXQUFDO0FBQUQsQ0FBQyxDQVhrQixFQUFFLENBQUMsTUFBTSxHQVczQjtBQUVELElBQUksTUFBTSxHQUFHLElBQUksRUFBRSxDQUFDLE1BQU0sRUFBRSxDQUFDO0FBQzdCLEdBQUcsRUFBQyxJQUFJLFFBQVEsSUFBSSxtQkFBUSxDQUFDLEVBQUM7SUFDMUIsTUFBTSxDQUFDLFdBQVcsQ0FBQyxtQkFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7QUFDM0MsQ0FBQztBQUVELElBQU0sSUFBSSxHQUFHLElBQUksSUFBSSxFQUFFLENBQUM7QUFDeEIsSUFBTSxTQUFTLEdBQUcsSUFBSSxxQkFBUyxFQUFFLENBQUM7QUFFbEMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxXQUFXLEVBQUUsU0FBUyxDQUFDLENBQUM7QUFFakMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUM7SUFDcEIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUNoQyxDQUFDLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7O0FDL0JILDRGQUFnQztBQUVoQyx5Q0FBeUM7QUFDekMsSUFBSSxRQUFRLEdBQUc7SUFDZCxVQUFVLEVBQUUsSUFBSSxFQUFFLENBQUMsT0FBTyxDQUFDLHVCQUF1QixDQUFDO0lBRWhELFFBQVEsRUFBRSxJQUFJLEVBQUUsQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLENBQUM7SUFDMUMsTUFBTSxFQUFFLElBQUksRUFBRSxDQUFDLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQztJQUUzQyxJQUFJLEVBQUUsSUFBSSxFQUFFLENBQUMsT0FBTyxDQUFDLGlCQUFpQixDQUFDO0lBQ3ZDLEtBQUssRUFBRSxJQUFJLEVBQUUsQ0FBQyxPQUFPLENBQUMsa0JBQWtCLENBQUM7SUFDekMsU0FBUyxFQUFFLElBQUksRUFBRSxDQUFDLE9BQU8sQ0FBQyx1QkFBdUIsQ0FBQztJQUNsRCxLQUFLLEVBQUUsSUFBSSxFQUFFLENBQUMsT0FBTyxDQUFDLGtCQUFrQixDQUFDO0lBRXpDLGFBQWEsRUFBRSxJQUFJLEVBQUUsQ0FBQyxPQUFPLENBQUMsMkJBQTJCLENBQUM7SUFDMUQsVUFBVSxFQUFFLElBQUksRUFBRSxDQUFDLE9BQU8sQ0FBQyx3QkFBd0IsQ0FBQztDQUN2RDtBQUVRLDRCQUFROzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbEJqQiw0RkFBZ0M7QUFDaEMsZ0ZBQTBDO0FBQzFDLHNHQUFvRDtBQUNwRCxxSEFBNkQ7QUFDN0Qsa0lBQXVFO0FBQ3ZFLDRGQUFrRDtBQUNsRCwrRkFBb0Q7QUFDcEQsb0NBQW9DO0FBR3BDO0lBQXdCLDZCQUFRO0lBQWhDO1FBQUEscUVBa0xDO1FBOUZVLGFBQU8sR0FBRztZQUNiLEVBQUUsRUFBQyxDQUFDLEtBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO2dCQUNuQixLQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQztnQkFDeEIsS0FBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO1lBQ3JDLENBQUM7WUFFRCxFQUFFLEVBQUMsS0FBSSxDQUFDLFFBQVEsSUFBSSxLQUFJLENBQUMsVUFBVSxDQUFDO2dCQUNoQyxLQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQztRQUMvQixDQUFDO1FBMkVNLGlCQUFXLEdBQUc7WUFDakIsS0FBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7WUFDckIsS0FBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLEdBQUcsV0FBVztZQUNuQyxLQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7WUFDaEMsS0FBSSxDQUFDLGdCQUFnQixHQUFHLENBQUMsQ0FBQztZQUUxQiw2QkFBYSxDQUFDLFNBQVMsQ0FBQyxLQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDeEMsQ0FBQzs7SUFJTCxDQUFDO0lBOUpVLGdDQUFZLEdBQW5CLFVBQW9CLE1BQWlCO1FBQ2pDLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDO1FBRWYsSUFBSSxVQUFVLEdBQUcsSUFBSSxFQUFFLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDaEMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxtQkFBUSxDQUFDLFVBQVUsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO1FBQ3RELElBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDckIsVUFBVSxDQUFDLENBQUMsR0FBRywyQkFBWSxDQUFDLEtBQUssR0FBQyxDQUFDLENBQUM7UUFDcEMsVUFBVSxDQUFDLENBQUMsR0FBRywyQkFBWSxDQUFDLE1BQU0sR0FBQyxDQUFDLENBQUM7UUFDckMsVUFBVSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQztRQUVuQixJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksZUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQy9CLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3RCLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUVsQixJQUFJLENBQUMsZ0JBQWdCLEdBQUcsMkJBQVksQ0FBQyxhQUFhLENBQUM7UUFDbkQsSUFBSSxDQUFDLGFBQWEsR0FBRywyQkFBWSxDQUFDLE1BQU0sR0FBQyxDQUFDLENBQUM7UUFDM0MsSUFBSSxDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUNuQixJQUFJLENBQUMsa0JBQWtCLEdBQUcsMkJBQVksQ0FBQyxnQkFBZ0IsQ0FBQztRQUV4RCxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksRUFBRSxDQUFDLEtBQUssQ0FBQywwQkFBMEIsRUFBRSwyQkFBWSxDQUFDLEtBQUssR0FBQyxDQUFDLEVBQUUsMkJBQVksQ0FBQyxNQUFNLEdBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ2xILElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDO1FBQ2pELElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDO1FBQ2pELElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxHQUFHLEVBQUUsQ0FBQztRQUMvQixJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQztRQUN4QyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUMzQixJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7UUFFeEIsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLEVBQUUsQ0FBQyxLQUFLLENBQUMsa0JBQWtCLEVBQUUsMkJBQVksQ0FBQyxLQUFLLEdBQUMsQ0FBQyxFQUFFLDJCQUFZLENBQUMsTUFBTSxHQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDaEgsSUFBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLEdBQUcsRUFBRSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUM7UUFDbEQsSUFBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLEdBQUcsRUFBRSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUM7UUFDL0MsSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLEdBQUcsRUFBRSxDQUFDO1FBQ2hDLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDO1FBQ3pDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBQzVCLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUN6QixJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUM7UUFFbEMsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLEVBQUUsQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLDJCQUFZLENBQUMsS0FBSyxHQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDeEUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTLEdBQUcsRUFBRSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUM7UUFDL0MsSUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTLEdBQUcsRUFBRSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUM7UUFDN0MsSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLEdBQUcsRUFBRSxDQUFDO1FBQzlCLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDO1FBQ3ZDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQzFCLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUV2QixJQUFJLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQztRQUN6QixJQUFJLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQztRQUN0QixJQUFJLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQztRQUN4QixJQUFJLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQztRQUV4QixJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksRUFBRSxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQzdCLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLG1CQUFRLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7UUFDbkQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsMkJBQVksQ0FBQyxLQUFLLEdBQUMsQ0FBQyxDQUFDO1FBQ3JDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLDJCQUFZLENBQUMsTUFBTSxHQUFHLDJCQUFZLENBQUMsYUFBYSxHQUFDLENBQUMsQ0FBQztRQUNuRSxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQywyQkFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3pDLElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLDJCQUFZLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDbEQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDdEIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRWxCLE1BQU0sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUN2RCxpSEFBaUg7UUFFakgsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEdBQUcsSUFBSSxFQUFFLENBQUMsTUFBTSxDQUFDLDJCQUFZLENBQUMsS0FBSyxHQUFDLENBQUMsRUFBRSwyQkFBWSxDQUFDLE1BQU0sR0FBQyxDQUFDLENBQUMsQ0FBQztJQUNqRixDQUFDO0lBYU0sMEJBQU0sR0FBYixVQUFjLE1BQWlCLEVBQUUsS0FBYTtRQUMxQyxpQkFBTSxNQUFNLFlBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBRTVCLEVBQUUsRUFBQyxJQUFJLENBQUMsUUFBUSxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7WUFDbkMsSUFBSSxDQUFDLGdCQUFnQixJQUFJLEtBQUssR0FBQyxJQUFJLENBQUM7WUFDcEMsRUFBRSxFQUFDLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUMzQixJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQztnQkFDdkIsSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO1lBQ3JDLENBQUM7UUFDTCxDQUFDO1FBRUQsRUFBRSxFQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1lBQ2pCLEdBQUcsRUFBQyxJQUFJLEVBQUUsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztnQkFDeEIsRUFBRSxFQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFlBQVkscUJBQVMsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxZQUFZLG1DQUFnQixDQUFDLENBQUMsQ0FBQztvQkFDckYsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztnQkFDM0IsQ0FBQztZQUNMLENBQUM7WUFFRCxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDO1lBRXBCLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDO1lBQ2YsSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO1lBQ2xDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxHQUFHLDBCQUEwQixDQUFDO1lBRW5ELElBQUksQ0FBQyxXQUFXLEdBQUcsS0FBSyxDQUFDO1lBQ3pCLElBQUksQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDO1lBQ3RCLElBQUksQ0FBQyxVQUFVLEdBQUcsS0FBSyxDQUFDO1lBRXhCLElBQUksQ0FBQyxnQkFBZ0IsR0FBRywyQkFBWSxDQUFDLGFBQWEsQ0FBQztZQUNuRCxJQUFJLENBQUMsYUFBYSxHQUFHLDJCQUFZLENBQUMsTUFBTSxHQUFDLENBQUMsQ0FBQztZQUUzQyxJQUFJLENBQUMsa0JBQWtCLEdBQUcsMkJBQVksQ0FBQyxnQkFBZ0IsQ0FBQztZQUV4RCxJQUFJLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQztRQUM1QixDQUFDO1FBRUQsSUFBSSxDQUFDLEVBQUUsRUFBQyxJQUFJLENBQUMsUUFBUSxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQztZQUN2QyxNQUFNLENBQUM7UUFFWCxJQUFJLENBQUMsQ0FBQztZQUVGLHdEQUF3RDtZQUV4RCxJQUFJLENBQUMsZ0JBQWdCLElBQUksS0FBSyxHQUFDLElBQUksQ0FBQztZQUNwQyxJQUFJLENBQUMsa0JBQWtCLElBQUksS0FBSyxHQUFDLElBQUksQ0FBQztZQUV0QyxFQUFFLEVBQUMsSUFBSSxDQUFDLGdCQUFnQixHQUFHLDJCQUFZLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztnQkFDcEQsSUFBSSxJQUFJLEdBQUcsMkJBQVksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsMkJBQVksQ0FBQyxXQUFXLENBQUMsQ0FBQztnQkFDckYsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQywyQkFBWSxDQUFDLFNBQVMsR0FBRyxDQUFDLDJCQUFZLENBQUMsU0FBUyxHQUFHLDJCQUFZLENBQUMsU0FBUyxDQUFDLEdBQUcsMkJBQVksQ0FBQyxjQUFjLENBQUMsQ0FBQztnQkFDbEksSUFBSSxJQUFJLENBQUM7Z0JBQ1QsR0FBRyxDQUFDO29CQUNBLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQywyQkFBWSxDQUFDLE1BQU0sR0FBRywyQkFBWSxDQUFDLGFBQWEsR0FBRyxDQUFDLEdBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQzdHLENBQUMsUUFBTyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQywyQkFBWSxDQUFDLGFBQWEsR0FBRyxDQUFDLDJCQUFZLENBQUMsV0FBVyxHQUFHLDJCQUFZLENBQUMsYUFBYSxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssR0FBRywyQkFBWSxDQUFDLGNBQWMsQ0FBQyxHQUFHLDJCQUFZLENBQUMsTUFBTSxFQUFFO2dCQUN2TSwwQ0FBMEM7Z0JBRTFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxxQkFBUyxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7Z0JBQ2xELElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDO2dCQUMxQixJQUFJLENBQUMsZ0JBQWdCLEdBQUcsQ0FBQyxDQUFDO1lBQzlCLENBQUM7WUFHRCxFQUFFLEVBQUMsSUFBSSxDQUFDLGtCQUFrQixHQUFHLDJCQUFZLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDO2dCQUN6RCxJQUFJLEVBQUUsR0FBRyxJQUFJLG1DQUFnQixDQUFDLElBQUksQ0FBQztnQkFDbkMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQztnQkFDYixFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFDVCxJQUFJLENBQUMsa0JBQWtCLEdBQUcsQ0FBQyxDQUFDO1lBQ2hDLENBQUM7WUFFRCxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ2pELENBQUM7SUFDTCxDQUFDO0lBV00sOEJBQVUsR0FBakIsY0FBcUIsQ0FBQztJQUNmLGdDQUFZLEdBQW5CLGNBQXVCLENBQUM7SUFDNUIsZ0JBQUM7QUFBRCxDQUFDLENBbEx1QixFQUFFLENBQUMsS0FBSyxHQWtML0I7QUFFUSw4QkFBUyIsImZpbGUiOiJidW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvaW5kZXgudHNcIik7XG4iLCIvKiEgZXhjYWxpYnVyIC0gdjAuMTUuMCAtIDIwMTgtMDItMTdcclxuKiBodHRwczovL2dpdGh1Yi5jb20vZXhjYWxpYnVyanMvRXhjYWxpYnVyXHJcbiogQ29weXJpZ2h0IChjKSAyMDE4IEV4Y2FsaWJ1ci5qcyA8aHR0cHM6Ly9naXRodWIuY29tL2V4Y2FsaWJ1cmpzL0V4Y2FsaWJ1ci9ncmFwaHMvY29udHJpYnV0b3JzPjsgTGljZW5zZWQgQlNELTItQ2xhdXNlXHJcbiogQHByZXNlcnZlICovXHJcbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xyXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cclxuICAgICAgICBkZWZpbmUoW10sIGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAocm9vdC5leCA9IGZhY3RvcnkoYikpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xyXG4gICAgICAgIC8vIE5vZGUuIERvZXMgbm90IHdvcmsgd2l0aCBzdHJpY3QgQ29tbW9uSlMsIGJ1dFxyXG4gICAgICAgIC8vIG9ubHkgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxyXG4gICAgICAgIC8vIGxpa2UgTm9kZS5cclxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzXHJcbiAgICAgICAgcm9vdC5leCA9IGZhY3RvcnkoKTtcclxuICAgIH1cclxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAvL2FsbW9uZCwgYW5kIHlvdXIgbW9kdWxlcyB3aWxsIGJlIGlubGluZWQgaGVyZVxyXG4vKipcclxuICogQGxpY2Vuc2UgYWxtb25kIDAuMy4zIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzLlxyXG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSwgaHR0cDovL2dpdGh1Yi5jb20vcmVxdWlyZWpzL2FsbW9uZC9MSUNFTlNFXHJcbiAqL1xyXG4vL0dvaW5nIHNsb3BweSB0byBhdm9pZCAndXNlIHN0cmljdCcgc3RyaW5nIGNvc3QsIGJ1dCBzdHJpY3QgcHJhY3RpY2VzIHNob3VsZFxyXG4vL2JlIGZvbGxvd2VkLlxyXG4vKmdsb2JhbCBzZXRUaW1lb3V0OiBmYWxzZSAqL1xyXG5cclxudmFyIHJlcXVpcmVqcywgcmVxdWlyZSwgZGVmaW5lO1xyXG4oZnVuY3Rpb24gKHVuZGVmKSB7XHJcbiAgICB2YXIgbWFpbiwgcmVxLCBtYWtlTWFwLCBoYW5kbGVycyxcclxuICAgICAgICBkZWZpbmVkID0ge30sXHJcbiAgICAgICAgd2FpdGluZyA9IHt9LFxyXG4gICAgICAgIGNvbmZpZyA9IHt9LFxyXG4gICAgICAgIGRlZmluaW5nID0ge30sXHJcbiAgICAgICAgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcclxuICAgICAgICBhcHMgPSBbXS5zbGljZSxcclxuICAgICAgICBqc1N1ZmZpeFJlZ0V4cCA9IC9cXC5qcyQvO1xyXG5cclxuICAgIGZ1bmN0aW9uIGhhc1Byb3Aob2JqLCBwcm9wKSB7XHJcbiAgICAgICAgcmV0dXJuIGhhc093bi5jYWxsKG9iaiwgcHJvcCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiBhIHJlbGF0aXZlIG1vZHVsZSBuYW1lLCBsaWtlIC4vc29tZXRoaW5nLCBub3JtYWxpemUgaXQgdG9cclxuICAgICAqIGEgcmVhbCBuYW1lIHRoYXQgY2FuIGJlIG1hcHBlZCB0byBhIHBhdGguXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgcmVsYXRpdmUgbmFtZVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGJhc2VOYW1lIGEgcmVhbCBuYW1lIHRoYXQgdGhlIG5hbWUgYXJnIGlzIHJlbGF0aXZlXHJcbiAgICAgKiB0by5cclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IG5vcm1hbGl6ZWQgbmFtZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBub3JtYWxpemUobmFtZSwgYmFzZU5hbWUpIHtcclxuICAgICAgICB2YXIgbmFtZVBhcnRzLCBuYW1lU2VnbWVudCwgbWFwVmFsdWUsIGZvdW5kTWFwLCBsYXN0SW5kZXgsXHJcbiAgICAgICAgICAgIGZvdW5kSSwgZm91bmRTdGFyTWFwLCBzdGFySSwgaSwgaiwgcGFydCwgbm9ybWFsaXplZEJhc2VQYXJ0cyxcclxuICAgICAgICAgICAgYmFzZVBhcnRzID0gYmFzZU5hbWUgJiYgYmFzZU5hbWUuc3BsaXQoXCIvXCIpLFxyXG4gICAgICAgICAgICBtYXAgPSBjb25maWcubWFwLFxyXG4gICAgICAgICAgICBzdGFyTWFwID0gKG1hcCAmJiBtYXBbJyonXSkgfHwge307XHJcblxyXG4gICAgICAgIC8vQWRqdXN0IGFueSByZWxhdGl2ZSBwYXRocy5cclxuICAgICAgICBpZiAobmFtZSkge1xyXG4gICAgICAgICAgICBuYW1lID0gbmFtZS5zcGxpdCgnLycpO1xyXG4gICAgICAgICAgICBsYXN0SW5kZXggPSBuYW1lLmxlbmd0aCAtIDE7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiB3YW50aW5nIG5vZGUgSUQgY29tcGF0aWJpbGl0eSwgc3RyaXAgLmpzIGZyb20gZW5kXHJcbiAgICAgICAgICAgIC8vIG9mIElEcy4gSGF2ZSB0byBkbyB0aGlzIGhlcmUsIGFuZCBub3QgaW4gbmFtZVRvVXJsXHJcbiAgICAgICAgICAgIC8vIGJlY2F1c2Ugbm9kZSBhbGxvd3MgZWl0aGVyIC5qcyBvciBub24gLmpzIHRvIG1hcFxyXG4gICAgICAgICAgICAvLyB0byBzYW1lIGZpbGUuXHJcbiAgICAgICAgICAgIGlmIChjb25maWcubm9kZUlkQ29tcGF0ICYmIGpzU3VmZml4UmVnRXhwLnRlc3QobmFtZVtsYXN0SW5kZXhdKSkge1xyXG4gICAgICAgICAgICAgICAgbmFtZVtsYXN0SW5kZXhdID0gbmFtZVtsYXN0SW5kZXhdLnJlcGxhY2UoanNTdWZmaXhSZWdFeHAsICcnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU3RhcnRzIHdpdGggYSAnLicgc28gbmVlZCB0aGUgYmFzZU5hbWVcclxuICAgICAgICAgICAgaWYgKG5hbWVbMF0uY2hhckF0KDApID09PSAnLicgJiYgYmFzZVBhcnRzKSB7XHJcbiAgICAgICAgICAgICAgICAvL0NvbnZlcnQgYmFzZU5hbWUgdG8gYXJyYXksIGFuZCBsb3Agb2ZmIHRoZSBsYXN0IHBhcnQsXHJcbiAgICAgICAgICAgICAgICAvL3NvIHRoYXQgLiBtYXRjaGVzIHRoYXQgJ2RpcmVjdG9yeScgYW5kIG5vdCBuYW1lIG9mIHRoZSBiYXNlTmFtZSdzXHJcbiAgICAgICAgICAgICAgICAvL21vZHVsZS4gRm9yIGluc3RhbmNlLCBiYXNlTmFtZSBvZiAnb25lL3R3by90aHJlZScsIG1hcHMgdG9cclxuICAgICAgICAgICAgICAgIC8vJ29uZS90d28vdGhyZWUuanMnLCBidXQgd2Ugd2FudCB0aGUgZGlyZWN0b3J5LCAnb25lL3R3bycgZm9yXHJcbiAgICAgICAgICAgICAgICAvL3RoaXMgbm9ybWFsaXphdGlvbi5cclxuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRCYXNlUGFydHMgPSBiYXNlUGFydHMuc2xpY2UoMCwgYmFzZVBhcnRzLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgbmFtZSA9IG5vcm1hbGl6ZWRCYXNlUGFydHMuY29uY2F0KG5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL3N0YXJ0IHRyaW1Eb3RzXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJ0ID0gbmFtZVtpXTtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJ0ID09PSAnLicpIHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICBpIC09IDE7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnQgPT09ICcuLicpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhdCB0aGUgc3RhcnQsIG9yIHByZXZpb3VzIHZhbHVlIGlzIHN0aWxsIC4uLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGtlZXAgdGhlbSBzbyB0aGF0IHdoZW4gY29udmVydGVkIHRvIGEgcGF0aCBpdCBtYXlcclxuICAgICAgICAgICAgICAgICAgICAvLyBzdGlsbCB3b3JrIHdoZW4gY29udmVydGVkIHRvIGEgcGF0aCwgZXZlbiB0aG91Z2hcclxuICAgICAgICAgICAgICAgICAgICAvLyBhcyBhbiBJRCBpdCBpcyBsZXNzIHRoYW4gaWRlYWwuIEluIGxhcmdlciBwb2ludFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbGVhc2VzLCBtYXkgYmUgYmV0dGVyIHRvIGp1c3Qga2ljayBvdXQgYW4gZXJyb3IuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDAgfHwgKGkgPT09IDEgJiYgbmFtZVsyXSA9PT0gJy4uJykgfHwgbmFtZVtpIC0gMV0gPT09ICcuLicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lLnNwbGljZShpIC0gMSwgMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgLT0gMjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9lbmQgdHJpbURvdHNcclxuXHJcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLmpvaW4oJy8nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vQXBwbHkgbWFwIGNvbmZpZyBpZiBhdmFpbGFibGUuXHJcbiAgICAgICAgaWYgKChiYXNlUGFydHMgfHwgc3Rhck1hcCkgJiYgbWFwKSB7XHJcbiAgICAgICAgICAgIG5hbWVQYXJ0cyA9IG5hbWUuc3BsaXQoJy8nKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IG5hbWVQYXJ0cy5sZW5ndGg7IGkgPiAwOyBpIC09IDEpIHtcclxuICAgICAgICAgICAgICAgIG5hbWVTZWdtZW50ID0gbmFtZVBhcnRzLnNsaWNlKDAsIGkpLmpvaW4oXCIvXCIpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChiYXNlUGFydHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL0ZpbmQgdGhlIGxvbmdlc3QgYmFzZU5hbWUgc2VnbWVudCBtYXRjaCBpbiB0aGUgY29uZmlnLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vU28sIGRvIGpvaW5zIG9uIHRoZSBiaWdnZXN0IHRvIHNtYWxsZXN0IGxlbmd0aHMgb2YgYmFzZVBhcnRzLlxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IGJhc2VQYXJ0cy5sZW5ndGg7IGogPiAwOyBqIC09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwVmFsdWUgPSBtYXBbYmFzZVBhcnRzLnNsaWNlKDAsIGopLmpvaW4oJy8nKV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2Jhc2VOYW1lIHNlZ21lbnQgaGFzICBjb25maWcsIGZpbmQgaWYgaXQgaGFzIG9uZSBmb3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy90aGlzIG5hbWUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXBWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwVmFsdWUgPSBtYXBWYWx1ZVtuYW1lU2VnbWVudF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFwVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL01hdGNoLCB1cGRhdGUgbmFtZSB0byB0aGUgbmV3IHZhbHVlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kTWFwID0gbWFwVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRJID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZm91bmRNYXApIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvL0NoZWNrIGZvciBhIHN0YXIgbWFwIG1hdGNoLCBidXQganVzdCBob2xkIG9uIHRvIGl0LFxyXG4gICAgICAgICAgICAgICAgLy9pZiB0aGVyZSBpcyBhIHNob3J0ZXIgc2VnbWVudCBtYXRjaCBsYXRlciBpbiBhIG1hdGNoaW5nXHJcbiAgICAgICAgICAgICAgICAvL2NvbmZpZywgdGhlbiBmYXZvciBvdmVyIHRoaXMgc3RhciBtYXAuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWZvdW5kU3Rhck1hcCAmJiBzdGFyTWFwICYmIHN0YXJNYXBbbmFtZVNlZ21lbnRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm91bmRTdGFyTWFwID0gc3Rhck1hcFtuYW1lU2VnbWVudF07XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhckkgPSBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIWZvdW5kTWFwICYmIGZvdW5kU3Rhck1hcCkge1xyXG4gICAgICAgICAgICAgICAgZm91bmRNYXAgPSBmb3VuZFN0YXJNYXA7XHJcbiAgICAgICAgICAgICAgICBmb3VuZEkgPSBzdGFySTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGZvdW5kTWFwKSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lUGFydHMuc3BsaWNlKDAsIGZvdW5kSSwgZm91bmRNYXApO1xyXG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWVQYXJ0cy5qb2luKCcvJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBuYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1ha2VSZXF1aXJlKHJlbE5hbWUsIGZvcmNlU3luYykge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vQSB2ZXJzaW9uIG9mIGEgcmVxdWlyZSBmdW5jdGlvbiB0aGF0IHBhc3NlcyBhIG1vZHVsZU5hbWVcclxuICAgICAgICAgICAgLy92YWx1ZSBmb3IgaXRlbXMgdGhhdCBtYXkgbmVlZCB0b1xyXG4gICAgICAgICAgICAvL2xvb2sgdXAgcGF0aHMgcmVsYXRpdmUgdG8gdGhlIG1vZHVsZU5hbWVcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcHMuY2FsbChhcmd1bWVudHMsIDApO1xyXG5cclxuICAgICAgICAgICAgLy9JZiBmaXJzdCBhcmcgaXMgbm90IHJlcXVpcmUoJ3N0cmluZycpLCBhbmQgdGhlcmUgaXMgb25seVxyXG4gICAgICAgICAgICAvL29uZSBhcmcsIGl0IGlzIHRoZSBhcnJheSBmb3JtIHdpdGhvdXQgYSBjYWxsYmFjay4gSW5zZXJ0XHJcbiAgICAgICAgICAgIC8vYSBudWxsIHNvIHRoYXQgdGhlIGZvbGxvd2luZyBjb25jYXQgaXMgY29ycmVjdC5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmdzWzBdICE9PSAnc3RyaW5nJyAmJiBhcmdzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXEuYXBwbHkodW5kZWYsIGFyZ3MuY29uY2F0KFtyZWxOYW1lLCBmb3JjZVN5bmNdKSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtYWtlTm9ybWFsaXplKHJlbE5hbWUpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZShuYW1lLCByZWxOYW1lKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1ha2VMb2FkKGRlcE5hbWUpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGRlZmluZWRbZGVwTmFtZV0gPSB2YWx1ZTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNhbGxEZXAobmFtZSkge1xyXG4gICAgICAgIGlmIChoYXNQcm9wKHdhaXRpbmcsIG5hbWUpKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gd2FpdGluZ1tuYW1lXTtcclxuICAgICAgICAgICAgZGVsZXRlIHdhaXRpbmdbbmFtZV07XHJcbiAgICAgICAgICAgIGRlZmluaW5nW25hbWVdID0gdHJ1ZTtcclxuICAgICAgICAgICAgbWFpbi5hcHBseSh1bmRlZiwgYXJncyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWhhc1Byb3AoZGVmaW5lZCwgbmFtZSkgJiYgIWhhc1Byb3AoZGVmaW5pbmcsIG5hbWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gJyArIG5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVmaW5lZFtuYW1lXTtcclxuICAgIH1cclxuXHJcbiAgICAvL1R1cm5zIGEgcGx1Z2luIXJlc291cmNlIHRvIFtwbHVnaW4sIHJlc291cmNlXVxyXG4gICAgLy93aXRoIHRoZSBwbHVnaW4gYmVpbmcgdW5kZWZpbmVkIGlmIHRoZSBuYW1lXHJcbiAgICAvL2RpZCBub3QgaGF2ZSBhIHBsdWdpbiBwcmVmaXguXHJcbiAgICBmdW5jdGlvbiBzcGxpdFByZWZpeChuYW1lKSB7XHJcbiAgICAgICAgdmFyIHByZWZpeCxcclxuICAgICAgICAgICAgaW5kZXggPSBuYW1lID8gbmFtZS5pbmRleE9mKCchJykgOiAtMTtcclxuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICBwcmVmaXggPSBuYW1lLnN1YnN0cmluZygwLCBpbmRleCk7XHJcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cmluZyhpbmRleCArIDEsIG5hbWUubGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtwcmVmaXgsIG5hbWVdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vQ3JlYXRlcyBhIHBhcnRzIGFycmF5IGZvciBhIHJlbE5hbWUgd2hlcmUgZmlyc3QgcGFydCBpcyBwbHVnaW4gSUQsXHJcbiAgICAvL3NlY29uZCBwYXJ0IGlzIHJlc291cmNlIElELiBBc3N1bWVzIHJlbE5hbWUgaGFzIGFscmVhZHkgYmVlbiBub3JtYWxpemVkLlxyXG4gICAgZnVuY3Rpb24gbWFrZVJlbFBhcnRzKHJlbE5hbWUpIHtcclxuICAgICAgICByZXR1cm4gcmVsTmFtZSA/IHNwbGl0UHJlZml4KHJlbE5hbWUpIDogW107XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYWtlcyBhIG5hbWUgbWFwLCBub3JtYWxpemluZyB0aGUgbmFtZSwgYW5kIHVzaW5nIGEgcGx1Z2luXHJcbiAgICAgKiBmb3Igbm9ybWFsaXphdGlvbiBpZiBuZWNlc3NhcnkuIEdyYWJzIGEgcmVmIHRvIHBsdWdpblxyXG4gICAgICogdG9vLCBhcyBhbiBvcHRpbWl6YXRpb24uXHJcbiAgICAgKi9cclxuICAgIG1ha2VNYXAgPSBmdW5jdGlvbiAobmFtZSwgcmVsUGFydHMpIHtcclxuICAgICAgICB2YXIgcGx1Z2luLFxyXG4gICAgICAgICAgICBwYXJ0cyA9IHNwbGl0UHJlZml4KG5hbWUpLFxyXG4gICAgICAgICAgICBwcmVmaXggPSBwYXJ0c1swXSxcclxuICAgICAgICAgICAgcmVsUmVzb3VyY2VOYW1lID0gcmVsUGFydHNbMV07XHJcblxyXG4gICAgICAgIG5hbWUgPSBwYXJ0c1sxXTtcclxuXHJcbiAgICAgICAgaWYgKHByZWZpeCkge1xyXG4gICAgICAgICAgICBwcmVmaXggPSBub3JtYWxpemUocHJlZml4LCByZWxSZXNvdXJjZU5hbWUpO1xyXG4gICAgICAgICAgICBwbHVnaW4gPSBjYWxsRGVwKHByZWZpeCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL05vcm1hbGl6ZSBhY2NvcmRpbmdcclxuICAgICAgICBpZiAocHJlZml4KSB7XHJcbiAgICAgICAgICAgIGlmIChwbHVnaW4gJiYgcGx1Z2luLm5vcm1hbGl6ZSkge1xyXG4gICAgICAgICAgICAgICAgbmFtZSA9IHBsdWdpbi5ub3JtYWxpemUobmFtZSwgbWFrZU5vcm1hbGl6ZShyZWxSZXNvdXJjZU5hbWUpKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5hbWUgPSBub3JtYWxpemUobmFtZSwgcmVsUmVzb3VyY2VOYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG5hbWUgPSBub3JtYWxpemUobmFtZSwgcmVsUmVzb3VyY2VOYW1lKTtcclxuICAgICAgICAgICAgcGFydHMgPSBzcGxpdFByZWZpeChuYW1lKTtcclxuICAgICAgICAgICAgcHJlZml4ID0gcGFydHNbMF07XHJcbiAgICAgICAgICAgIG5hbWUgPSBwYXJ0c1sxXTtcclxuICAgICAgICAgICAgaWYgKHByZWZpeCkge1xyXG4gICAgICAgICAgICAgICAgcGx1Z2luID0gY2FsbERlcChwcmVmaXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL1VzaW5nIHJpZGljdWxvdXMgcHJvcGVydHkgbmFtZXMgZm9yIHNwYWNlIHJlYXNvbnNcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBmOiBwcmVmaXggPyBwcmVmaXggKyAnIScgKyBuYW1lIDogbmFtZSwgLy9mdWxsTmFtZVxyXG4gICAgICAgICAgICBuOiBuYW1lLFxyXG4gICAgICAgICAgICBwcjogcHJlZml4LFxyXG4gICAgICAgICAgICBwOiBwbHVnaW5cclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBtYWtlQ29uZmlnKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKGNvbmZpZyAmJiBjb25maWcuY29uZmlnICYmIGNvbmZpZy5jb25maWdbbmFtZV0pIHx8IHt9O1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgaGFuZGxlcnMgPSB7XHJcbiAgICAgICAgcmVxdWlyZTogZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1ha2VSZXF1aXJlKG5hbWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXhwb3J0czogZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIGUgPSBkZWZpbmVkW25hbWVdO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoZGVmaW5lZFtuYW1lXSA9IHt9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbW9kdWxlOiBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgaWQ6IG5hbWUsXHJcbiAgICAgICAgICAgICAgICB1cmk6ICcnLFxyXG4gICAgICAgICAgICAgICAgZXhwb3J0czogZGVmaW5lZFtuYW1lXSxcclxuICAgICAgICAgICAgICAgIGNvbmZpZzogbWFrZUNvbmZpZyhuYW1lKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgbWFpbiA9IGZ1bmN0aW9uIChuYW1lLCBkZXBzLCBjYWxsYmFjaywgcmVsTmFtZSkge1xyXG4gICAgICAgIHZhciBjanNNb2R1bGUsIGRlcE5hbWUsIHJldCwgbWFwLCBpLCByZWxQYXJ0cyxcclxuICAgICAgICAgICAgYXJncyA9IFtdLFxyXG4gICAgICAgICAgICBjYWxsYmFja1R5cGUgPSB0eXBlb2YgY2FsbGJhY2ssXHJcbiAgICAgICAgICAgIHVzaW5nRXhwb3J0cztcclxuXHJcbiAgICAgICAgLy9Vc2UgbmFtZSBpZiBubyByZWxOYW1lXHJcbiAgICAgICAgcmVsTmFtZSA9IHJlbE5hbWUgfHwgbmFtZTtcclxuICAgICAgICByZWxQYXJ0cyA9IG1ha2VSZWxQYXJ0cyhyZWxOYW1lKTtcclxuXHJcbiAgICAgICAgLy9DYWxsIHRoZSBjYWxsYmFjayB0byBkZWZpbmUgdGhlIG1vZHVsZSwgaWYgbmVjZXNzYXJ5LlxyXG4gICAgICAgIGlmIChjYWxsYmFja1R5cGUgPT09ICd1bmRlZmluZWQnIHx8IGNhbGxiYWNrVHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAvL1B1bGwgb3V0IHRoZSBkZWZpbmVkIGRlcGVuZGVuY2llcyBhbmQgcGFzcyB0aGUgb3JkZXJlZFxyXG4gICAgICAgICAgICAvL3ZhbHVlcyB0byB0aGUgY2FsbGJhY2suXHJcbiAgICAgICAgICAgIC8vRGVmYXVsdCB0byBbcmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlXSBpZiBubyBkZXBzXHJcbiAgICAgICAgICAgIGRlcHMgPSAhZGVwcy5sZW5ndGggJiYgY2FsbGJhY2subGVuZ3RoID8gWydyZXF1aXJlJywgJ2V4cG9ydHMnLCAnbW9kdWxlJ10gOiBkZXBzO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGVwcy5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgbWFwID0gbWFrZU1hcChkZXBzW2ldLCByZWxQYXJ0cyk7XHJcbiAgICAgICAgICAgICAgICBkZXBOYW1lID0gbWFwLmY7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9GYXN0IHBhdGggQ29tbW9uSlMgc3RhbmRhcmQgZGVwZW5kZW5jaWVzLlxyXG4gICAgICAgICAgICAgICAgaWYgKGRlcE5hbWUgPT09IFwicmVxdWlyZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tpXSA9IGhhbmRsZXJzLnJlcXVpcmUobmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRlcE5hbWUgPT09IFwiZXhwb3J0c1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9Db21tb25KUyBtb2R1bGUgc3BlYyAxLjFcclxuICAgICAgICAgICAgICAgICAgICBhcmdzW2ldID0gaGFuZGxlcnMuZXhwb3J0cyhuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB1c2luZ0V4cG9ydHMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkZXBOYW1lID09PSBcIm1vZHVsZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9Db21tb25KUyBtb2R1bGUgc3BlYyAxLjFcclxuICAgICAgICAgICAgICAgICAgICBjanNNb2R1bGUgPSBhcmdzW2ldID0gaGFuZGxlcnMubW9kdWxlKG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoYXNQcm9wKGRlZmluZWQsIGRlcE5hbWUpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc1Byb3Aod2FpdGluZywgZGVwTmFtZSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzUHJvcChkZWZpbmluZywgZGVwTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBhcmdzW2ldID0gY2FsbERlcChkZXBOYW1lKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWFwLnApIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXAucC5sb2FkKG1hcC5uLCBtYWtlUmVxdWlyZShyZWxOYW1lLCB0cnVlKSwgbWFrZUxvYWQoZGVwTmFtZSksIHt9KTtcclxuICAgICAgICAgICAgICAgICAgICBhcmdzW2ldID0gZGVmaW5lZFtkZXBOYW1lXTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG5hbWUgKyAnIG1pc3NpbmcgJyArIGRlcE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXQgPSBjYWxsYmFjayA/IGNhbGxiYWNrLmFwcGx5KGRlZmluZWRbbmFtZV0sIGFyZ3MpIDogdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAgICAgaWYgKG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIC8vSWYgc2V0dGluZyBleHBvcnRzIHZpYSBcIm1vZHVsZVwiIGlzIGluIHBsYXksXHJcbiAgICAgICAgICAgICAgICAvL2Zhdm9yIHRoYXQgb3ZlciByZXR1cm4gdmFsdWUgYW5kIGV4cG9ydHMuIEFmdGVyIHRoYXQsXHJcbiAgICAgICAgICAgICAgICAvL2Zhdm9yIGEgbm9uLXVuZGVmaW5lZCByZXR1cm4gdmFsdWUgb3ZlciBleHBvcnRzIHVzZS5cclxuICAgICAgICAgICAgICAgIGlmIChjanNNb2R1bGUgJiYgY2pzTW9kdWxlLmV4cG9ydHMgIT09IHVuZGVmICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNqc01vZHVsZS5leHBvcnRzICE9PSBkZWZpbmVkW25hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lZFtuYW1lXSA9IGNqc01vZHVsZS5leHBvcnRzO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXQgIT09IHVuZGVmIHx8ICF1c2luZ0V4cG9ydHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL1VzZSB0aGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGZ1bmN0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgIGRlZmluZWRbbmFtZV0gPSByZXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKG5hbWUpIHtcclxuICAgICAgICAgICAgLy9NYXkganVzdCBiZSBhbiBvYmplY3QgZGVmaW5pdGlvbiBmb3IgdGhlIG1vZHVsZS4gT25seVxyXG4gICAgICAgICAgICAvL3dvcnJ5IGFib3V0IGRlZmluaW5nIGlmIGhhdmUgYSBtb2R1bGUgbmFtZS5cclxuICAgICAgICAgICAgZGVmaW5lZFtuYW1lXSA9IGNhbGxiYWNrO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcmVxdWlyZWpzID0gcmVxdWlyZSA9IHJlcSA9IGZ1bmN0aW9uIChkZXBzLCBjYWxsYmFjaywgcmVsTmFtZSwgZm9yY2VTeW5jLCBhbHQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGRlcHMgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgaWYgKGhhbmRsZXJzW2RlcHNdKSB7XHJcbiAgICAgICAgICAgICAgICAvL2NhbGxiYWNrIGluIHRoaXMgY2FzZSBpcyByZWFsbHkgcmVsTmFtZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXJzW2RlcHNdKGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL0p1c3QgcmV0dXJuIHRoZSBtb2R1bGUgd2FudGVkLiBJbiB0aGlzIHNjZW5hcmlvLCB0aGVcclxuICAgICAgICAgICAgLy9kZXBzIGFyZyBpcyB0aGUgbW9kdWxlIG5hbWUsIGFuZCBzZWNvbmQgYXJnIChpZiBwYXNzZWQpXHJcbiAgICAgICAgICAgIC8vaXMganVzdCB0aGUgcmVsTmFtZS5cclxuICAgICAgICAgICAgLy9Ob3JtYWxpemUgbW9kdWxlIG5hbWUsIGlmIGl0IGNvbnRhaW5zIC4gb3IgLi5cclxuICAgICAgICAgICAgcmV0dXJuIGNhbGxEZXAobWFrZU1hcChkZXBzLCBtYWtlUmVsUGFydHMoY2FsbGJhY2spKS5mKTtcclxuICAgICAgICB9IGVsc2UgaWYgKCFkZXBzLnNwbGljZSkge1xyXG4gICAgICAgICAgICAvL2RlcHMgaXMgYSBjb25maWcgb2JqZWN0LCBub3QgYW4gYXJyYXkuXHJcbiAgICAgICAgICAgIGNvbmZpZyA9IGRlcHM7XHJcbiAgICAgICAgICAgIGlmIChjb25maWcuZGVwcykge1xyXG4gICAgICAgICAgICAgICAgcmVxKGNvbmZpZy5kZXBzLCBjb25maWcuY2FsbGJhY2spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrLnNwbGljZSkge1xyXG4gICAgICAgICAgICAgICAgLy9jYWxsYmFjayBpcyBhbiBhcnJheSwgd2hpY2ggbWVhbnMgaXQgaXMgYSBkZXBlbmRlbmN5IGxpc3QuXHJcbiAgICAgICAgICAgICAgICAvL0FkanVzdCBhcmdzIGlmIHRoZXJlIGFyZSBkZXBlbmRlbmNpZXNcclxuICAgICAgICAgICAgICAgIGRlcHMgPSBjYWxsYmFjaztcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gcmVsTmFtZTtcclxuICAgICAgICAgICAgICAgIHJlbE5hbWUgPSBudWxsO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGVwcyA9IHVuZGVmO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL1N1cHBvcnQgcmVxdWlyZShbJ2EnXSlcclxuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xyXG5cclxuICAgICAgICAvL0lmIHJlbE5hbWUgaXMgYSBmdW5jdGlvbiwgaXQgaXMgYW4gZXJyYmFjayBoYW5kbGVyLFxyXG4gICAgICAgIC8vc28gcmVtb3ZlIGl0LlxyXG4gICAgICAgIGlmICh0eXBlb2YgcmVsTmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICByZWxOYW1lID0gZm9yY2VTeW5jO1xyXG4gICAgICAgICAgICBmb3JjZVN5bmMgPSBhbHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL1NpbXVsYXRlIGFzeW5jIGNhbGxiYWNrO1xyXG4gICAgICAgIGlmIChmb3JjZVN5bmMpIHtcclxuICAgICAgICAgICAgbWFpbih1bmRlZiwgZGVwcywgY2FsbGJhY2ssIHJlbE5hbWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vVXNpbmcgYSBub24temVybyB2YWx1ZSBiZWNhdXNlIG9mIGNvbmNlcm4gZm9yIHdoYXQgb2xkIGJyb3dzZXJzXHJcbiAgICAgICAgICAgIC8vZG8sIGFuZCBsYXRlc3QgYnJvd3NlcnMgXCJ1cGdyYWRlXCIgdG8gNCBpZiBsb3dlciB2YWx1ZSBpcyB1c2VkOlxyXG4gICAgICAgICAgICAvL2h0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RpbWVycy5odG1sI2RvbS13aW5kb3d0aW1lcnMtc2V0dGltZW91dDpcclxuICAgICAgICAgICAgLy9JZiB3YW50IGEgdmFsdWUgaW1tZWRpYXRlbHksIHVzZSByZXF1aXJlKCdpZCcpIGluc3RlYWQgLS0gc29tZXRoaW5nXHJcbiAgICAgICAgICAgIC8vdGhhdCB3b3JrcyBpbiBhbG1vbmQgb24gdGhlIGdsb2JhbCBsZXZlbCwgYnV0IG5vdCBndWFyYW50ZWVkIGFuZFxyXG4gICAgICAgICAgICAvL3VubGlrZWx5IHRvIHdvcmsgaW4gb3RoZXIgQU1EIGltcGxlbWVudGF0aW9ucy5cclxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBtYWluKHVuZGVmLCBkZXBzLCBjYWxsYmFjaywgcmVsTmFtZSk7XHJcbiAgICAgICAgICAgIH0sIDQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlcTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBKdXN0IGRyb3BzIHRoZSBjb25maWcgb24gdGhlIGZsb29yLCBidXQgcmV0dXJucyByZXEgaW4gY2FzZVxyXG4gICAgICogdGhlIGNvbmZpZyByZXR1cm4gdmFsdWUgaXMgdXNlZC5cclxuICAgICAqL1xyXG4gICAgcmVxLmNvbmZpZyA9IGZ1bmN0aW9uIChjZmcpIHtcclxuICAgICAgICByZXR1cm4gcmVxKGNmZyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXhwb3NlIG1vZHVsZSByZWdpc3RyeSBmb3IgZGVidWdnaW5nIGFuZCB0b29saW5nXHJcbiAgICAgKi9cclxuICAgIHJlcXVpcmVqcy5fZGVmaW5lZCA9IGRlZmluZWQ7XHJcblxyXG4gICAgZGVmaW5lID0gZnVuY3Rpb24gKG5hbWUsIGRlcHMsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlZSBhbG1vbmQgUkVBRE1FOiBpbmNvcnJlY3QgbW9kdWxlIGJ1aWxkLCBubyBtb2R1bGUgbmFtZScpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9UaGlzIG1vZHVsZSBtYXkgbm90IGhhdmUgZGVwZW5kZW5jaWVzXHJcbiAgICAgICAgaWYgKCFkZXBzLnNwbGljZSkge1xyXG4gICAgICAgICAgICAvL2RlcHMgaXMgbm90IGFuIGFycmF5LCBzbyBwcm9iYWJseSBtZWFuc1xyXG4gICAgICAgICAgICAvL2FuIG9iamVjdCBsaXRlcmFsIG9yIGZhY3RvcnkgZnVuY3Rpb24gZm9yXHJcbiAgICAgICAgICAgIC8vdGhlIHZhbHVlLiBBZGp1c3QgYXJncy5cclxuICAgICAgICAgICAgY2FsbGJhY2sgPSBkZXBzO1xyXG4gICAgICAgICAgICBkZXBzID0gW107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWhhc1Byb3AoZGVmaW5lZCwgbmFtZSkgJiYgIWhhc1Byb3Aod2FpdGluZywgbmFtZSkpIHtcclxuICAgICAgICAgICAgd2FpdGluZ1tuYW1lXSA9IFtuYW1lLCBkZXBzLCBjYWxsYmFja107XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBkZWZpbmUuYW1kID0ge1xyXG4gICAgICAgIGpRdWVyeTogdHJ1ZVxyXG4gICAgfTtcclxufSgpKTtcclxuLyohIGV4Y2FsaWJ1ciAtIHYwLjE1LjAgLSAyMDE4LTAyLTE3XHJcbiogaHR0cHM6Ly9naXRodWIuY29tL2V4Y2FsaWJ1cmpzL0V4Y2FsaWJ1clxyXG4qIENvcHlyaWdodCAoYykgMjAxOCBFeGNhbGlidXIuanMgPGh0dHBzOi8vZ2l0aHViLmNvbS9leGNhbGlidXJqcy9FeGNhbGlidXIvZ3JhcGhzL2NvbnRyaWJ1dG9ycz47IExpY2Vuc2VkIEJTRC0yLUNsYXVzZVxyXG4qIEBwcmVzZXJ2ZSAqL1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxuZGVmaW5lKFwiQWN0aW9ucy9Sb3RhdGlvblR5cGVcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogQW4gZW51bSB0aGF0IGRlc2NyaWJlcyB0aGUgc3RyYXRlZ2llcyB0aGF0IHJvdGF0aW9uIGFjdGlvbnMgY2FuIHVzZVxyXG4gICAgICovXHJcbiAgICB2YXIgUm90YXRpb25UeXBlO1xyXG4gICAgKGZ1bmN0aW9uIChSb3RhdGlvblR5cGUpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSb3RhdGlvbiB2aWEgYFNob3J0ZXN0UGF0aGAgd2lsbCB1c2UgdGhlIHNtYWxsZXN0IGFuZ2xlXHJcbiAgICAgICAgICogYmV0d2VlbiB0aGUgc3RhcnRpbmcgYW5kIGVuZGluZyBwb2ludHMuIFRoaXMgc3RyYXRlZ3kgaXMgdGhlIGRlZmF1bHQgYmVoYXZpb3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUm90YXRpb25UeXBlW1JvdGF0aW9uVHlwZVtcIlNob3J0ZXN0UGF0aFwiXSA9IDBdID0gXCJTaG9ydGVzdFBhdGhcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSb3RhdGlvbiB2aWEgYExvbmdlc3RQYXRoYCB3aWxsIHVzZSB0aGUgbGFyZ2VzdCBhbmdsZVxyXG4gICAgICAgICAqIGJldHdlZW4gdGhlIHN0YXJ0aW5nIGFuZCBlbmRpbmcgcG9pbnRzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJvdGF0aW9uVHlwZVtSb3RhdGlvblR5cGVbXCJMb25nZXN0UGF0aFwiXSA9IDFdID0gXCJMb25nZXN0UGF0aFwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJvdGF0aW9uIHZpYSBgQ2xvY2t3aXNlYCB3aWxsIHRyYXZlbCBpbiBhIGNsb2Nrd2lzZSBkaXJlY3Rpb24sXHJcbiAgICAgICAgICogcmVnYXJkbGVzcyBvZiB0aGUgc3RhcnRpbmcgYW5kIGVuZGluZyBwb2ludHMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUm90YXRpb25UeXBlW1JvdGF0aW9uVHlwZVtcIkNsb2Nrd2lzZVwiXSA9IDJdID0gXCJDbG9ja3dpc2VcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSb3RhdGlvbiB2aWEgYENvdW50ZXJDbG9ja3dpc2VgIHdpbGwgdHJhdmVsIGluIGEgY291bnRlcmNsb2Nrd2lzZSBkaXJlY3Rpb24sXHJcbiAgICAgICAgICogcmVnYXJkbGVzcyBvZiB0aGUgc3RhcnRpbmcgYW5kIGVuZGluZyBwb2ludHMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUm90YXRpb25UeXBlW1JvdGF0aW9uVHlwZVtcIkNvdW50ZXJDbG9ja3dpc2VcIl0gPSAzXSA9IFwiQ291bnRlckNsb2Nrd2lzZVwiO1xyXG4gICAgfSkoUm90YXRpb25UeXBlID0gZXhwb3J0cy5Sb3RhdGlvblR5cGUgfHwgKGV4cG9ydHMuUm90YXRpb25UeXBlID0ge30pKTtcclxufSk7XHJcbmRlZmluZShcIkFsZ2VicmFcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogQSAyRCB2ZWN0b3Igb24gYSBwbGFuZS5cclxuICAgICAqL1xyXG4gICAgdmFyIFZlY3RvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHggIFggY29tcG9uZW50IG9mIHRoZSBWZWN0b3JcclxuICAgICAgICAgKiBAcGFyYW0geSAgWSBjb21wb25lbnQgb2YgdGhlIFZlY3RvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIFZlY3Rvcih4LCB5KSB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSB2ZWN0b3Igb2YgdW5pdCBsZW5ndGggaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgc3BlY2lmaWVkIGFuZ2xlIGluIFJhZGlhbnMuXHJcbiAgICAgICAgICogQHBhcmFtIGFuZ2xlIFRoZSBhbmdsZSB0byBnZW5lcmF0ZSB0aGUgdmVjdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVmVjdG9yLmZyb21BbmdsZSA9IGZ1bmN0aW9uIChhbmdsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvcihNYXRoLmNvcyhhbmdsZSksIE1hdGguc2luKGFuZ2xlKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGVja3MgaWYgdmVjdG9yIGlzIG5vdCBudWxsLCB1bmRlZmluZWQsIG9yIGlmIGFueSBvZiBpdHMgY29tcG9uZW50cyBhcmUgTmFOIG9yIEluZmluaXR5LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFZlY3Rvci5pc1ZhbGlkID0gZnVuY3Rpb24gKHZlYykge1xyXG4gICAgICAgICAgICBpZiAodmVjID09PSBudWxsIHx8IHZlYyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzTmFOKHZlYy54KSB8fCBpc05hTih2ZWMueSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodmVjLnggPT09IEluZmluaXR5IHx8XHJcbiAgICAgICAgICAgICAgICB2ZWMueSA9PT0gSW5maW5pdHkgfHxcclxuICAgICAgICAgICAgICAgIHZlYy54ID09PSAtSW5maW5pdHkgfHxcclxuICAgICAgICAgICAgICAgIHZlYy55ID09PSBJbmZpbml0eSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FsY3VsYXRlcyBkaXN0YW5jZSBiZXR3ZWVuIHR3byBWZWN0b3JzXHJcbiAgICAgICAgICogQHBhcmFtIHZlYzFcclxuICAgICAgICAgKiBAcGFyYW0gdmVjMlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFZlY3Rvci5kaXN0YW5jZSA9IGZ1bmN0aW9uICh2ZWMxLCB2ZWMyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3codmVjMS54IC0gdmVjMi54LCAyKSArIE1hdGgucG93KHZlYzEueSAtIHZlYzIueSwgMikpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgeCBhbmQgeSBjb21wb25lbnRzIGF0IG9uY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBWZWN0b3IucHJvdG90eXBlLnNldFRvID0gZnVuY3Rpb24gKHgsIHkpIHtcclxuICAgICAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbXBhcmVzIHRoaXMgcG9pbnQgYWdhaW5zdCBhbm90aGVyIGFuZCB0ZXN0cyBmb3IgZXF1YWxpdHlcclxuICAgICAgICAgKiBAcGFyYW0gcG9pbnQgIFRoZSBvdGhlciBwb2ludCB0byBjb21wYXJlIHRvXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAodmVjdG9yLCB0b2xlcmFuY2UpIHtcclxuICAgICAgICAgICAgaWYgKHRvbGVyYW5jZSA9PT0gdm9pZCAwKSB7IHRvbGVyYW5jZSA9IC4wMDE7IH1cclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHRoaXMueCAtIHZlY3Rvci54KSA8PSB0b2xlcmFuY2UgJiYgTWF0aC5hYnModGhpcy55IC0gdmVjdG9yLnkpIDw9IHRvbGVyYW5jZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBkaXN0YW5jZSB0byBhbm90aGVyIHZlY3Rvci4gSWYgbm8gb3RoZXIgVmVjdG9yIGlzIHNwZWNpZmllZCwgdGhpcyB3aWxsIHJldHVybiB0aGUgW1ttYWduaXR1ZGVdXS5cclxuICAgICAgICAgKiBAcGFyYW0gdiAgVGhlIG90aGVyIHZlY3Rvci4gTGVhdmUgYmxhbmsgdG8gdXNlIG9yaWdpbiB2ZWN0b3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS5kaXN0YW5jZSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIGlmICghdikge1xyXG4gICAgICAgICAgICAgICAgdiA9IFZlY3Rvci5aZXJvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy54IC0gdi54LCAyKSArIE1hdGgucG93KHRoaXMueSAtIHYueSwgMikpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG1hZ25pdHVkZSAoc2l6ZSkgb2YgdGhlIFZlY3RvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUubWFnbml0dWRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaXN0YW5jZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTm9ybWFsaXplcyBhIHZlY3RvciB0byBoYXZlIGEgbWFnbml0dWRlIG9mIDEuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBkID0gdGhpcy5kaXN0YW5jZSgpO1xyXG4gICAgICAgICAgICBpZiAoZCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMueCAvIGQsIHRoaXMueSAvIGQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoMCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIGF2ZXJhZ2UgKG1pZHBvaW50KSBiZXR3ZWVuIHRoZSBjdXJyZW50IHBvaW50IGFuZCB0aGUgc3BlY2lmaWVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS5hdmVyYWdlID0gZnVuY3Rpb24gKHZlYykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQodmVjKS5zY2FsZSguNSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTY2FsZXMgYSB2ZWN0b3IncyBieSBhIGZhY3RvciBvZiBzaXplXHJcbiAgICAgICAgICogQHBhcmFtIHNpemUgIFRoZSBmYWN0b3IgdG8gc2NhbGUgdGhlIG1hZ25pdHVkZSBieVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUuc2NhbGUgPSBmdW5jdGlvbiAoc2l6ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLnggKiBzaXplLCB0aGlzLnkgKiBzaXplKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgb25lIHZlY3RvciB0byBhbm90aGVyXHJcbiAgICAgICAgICogQHBhcmFtIHYgVGhlIHZlY3RvciB0byBhZGRcclxuICAgICAgICAgKi9cclxuICAgICAgICBWZWN0b3IucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMueCArIHYueCwgdGhpcy55ICsgdi55KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN1YnRyYWN0cyBhIHZlY3RvciBmcm9tIGFub3RoZXIsIGlmIHlvdSBzdWJyYWN0IHZlY3RvciBgQi5zdWIoQSlgIHRoZSByZXN1bHRpbmcgdmVjdG9yIHBvaW50cyBmcm9tIEEgLT4gQlxyXG4gICAgICAgICAqIEBwYXJhbSB2IFRoZSB2ZWN0b3IgdG8gc3VidHJhY3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBWZWN0b3IucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMueCAtIHYueCwgdGhpcy55IC0gdi55KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgb25lIHZlY3RvciB0byB0aGlzIG9uZSBtb2RpZnlpbmcgdGhlIG9yaWdpbmFsXHJcbiAgICAgICAgICogQHBhcmFtIHYgVGhlIHZlY3RvciB0byBhZGRcclxuICAgICAgICAgKi9cclxuICAgICAgICBWZWN0b3IucHJvdG90eXBlLmFkZEVxdWFsID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgdGhpcy54ICs9IHYueDtcclxuICAgICAgICAgICAgdGhpcy55ICs9IHYueTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTdWJ0cmFjdHMgYSB2ZWN0b3IgZnJvbSB0aGlzIG9uZSBtb2RpZnlpbmcgdGhlIG9yaWdpbmFsXHJcbiAgICAgICAgICogQHBhcmFsbGVsIHYgVGhlIHZlY3RvciB0byBzdWJ0cmFjdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUuc3ViRXF1YWwgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICB0aGlzLnggLT0gdi54O1xyXG4gICAgICAgICAgICB0aGlzLnkgLT0gdi55O1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNjYWxlcyB0aGlzIHZlY3RvciBieSBhIGZhY3RvciBvZiBzaXplIGFuZCBtb2RpZmllcyB0aGUgb3JpZ2luYWxcclxuICAgICAgICAgKi9cclxuICAgICAgICBWZWN0b3IucHJvdG90eXBlLnNjYWxlRXF1YWwgPSBmdW5jdGlvbiAoc2l6ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnggKj0gc2l6ZTtcclxuICAgICAgICAgICAgdGhpcy55ICo9IHNpemU7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGVyZm9ybXMgYSBkb3QgcHJvZHVjdCB3aXRoIGFub3RoZXIgdmVjdG9yXHJcbiAgICAgICAgICogQHBhcmFtIHYgIFRoZSB2ZWN0b3IgdG8gZG90XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS5kb3QgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS5jcm9zcyA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIGlmICh2IGluc3RhbmNlb2YgVmVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy54ICogdi55IC0gdGhpcy55ICogdi54O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodiAqIHRoaXMueSwgLXYgKiB0aGlzLngpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBwZXJwZW5kaWN1bGFyIHZlY3RvciB0byB0aGlzIG9uZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUucGVycGVuZGljdWxhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy55LCAtdGhpcy54KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIG5vcm1hbCB2ZWN0b3IgdG8gdGhpcyBvbmUsIHNhbWUgYXMgdGhlIHBlcnBlbmRpY3VsYXIgb2YgbGVuZ3RoIDFcclxuICAgICAgICAgKi9cclxuICAgICAgICBWZWN0b3IucHJvdG90eXBlLm5vcm1hbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGVycGVuZGljdWxhcigpLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTmVnYXRlIHRoZSBjdXJyZW50IHZlY3RvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FsZSgtMSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBhbmdsZSBvZiB0aGlzIHZlY3Rvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBWZWN0b3IucHJvdG90eXBlLnRvQW5nbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmF0YW4yKHRoaXMueSwgdGhpcy54KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJvdGF0ZXMgdGhlIGN1cnJlbnQgdmVjdG9yIGFyb3VuZCBhIHBvaW50IGJ5IGEgY2VydGFpbiBudW1iZXIgb2ZcclxuICAgICAgICAgKiBkZWdyZWVzIGluIHJhZGlhbnNcclxuICAgICAgICAgKi9cclxuICAgICAgICBWZWN0b3IucHJvdG90eXBlLnJvdGF0ZSA9IGZ1bmN0aW9uIChhbmdsZSwgYW5jaG9yKSB7XHJcbiAgICAgICAgICAgIGlmICghYW5jaG9yKSB7XHJcbiAgICAgICAgICAgICAgICBhbmNob3IgPSBuZXcgVmVjdG9yKDAsIDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBzaW5BbmdsZSA9IE1hdGguc2luKGFuZ2xlKTtcclxuICAgICAgICAgICAgdmFyIGNvc0FuZ2xlID0gTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgICAgICAgICB2YXIgeCA9IGNvc0FuZ2xlICogKHRoaXMueCAtIGFuY2hvci54KSAtIHNpbkFuZ2xlICogKHRoaXMueSAtIGFuY2hvci55KSArIGFuY2hvci54O1xyXG4gICAgICAgICAgICB2YXIgeSA9IHNpbkFuZ2xlICogKHRoaXMueCAtIGFuY2hvci54KSArIGNvc0FuZ2xlICogKHRoaXMueSAtIGFuY2hvci55KSArIGFuY2hvci55O1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih4LCB5KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgbmV3IHZlY3RvciB0aGF0IGhhcyB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhlIHByZXZpb3VzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMueCwgdGhpcy55KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIihcIiArIHRoaXMueCArIFwiLCBcIiArIHRoaXMueSArIFwiKVwiO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFZlY3RvcjtcclxuICAgIH0oKSk7XHJcbiAgICAvKipcclxuICAgICAqIEEgKDAsIDApIHZlY3RvclxyXG4gICAgICovXHJcbiAgICBWZWN0b3IuWmVybyA9IG5ldyBWZWN0b3IoMCwgMCk7XHJcbiAgICAvKipcclxuICAgICAqIEEgKDEsIDEpIHZlY3RvclxyXG4gICAgICovXHJcbiAgICBWZWN0b3IuT25lID0gbmV3IFZlY3RvcigxLCAxKTtcclxuICAgIC8qKlxyXG4gICAgICogQSAoMC41LCAwLjUpIHZlY3RvclxyXG4gICAgICovXHJcbiAgICBWZWN0b3IuSGFsZiA9IG5ldyBWZWN0b3IoMC41LCAwLjUpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIHVuaXQgdmVjdG9yIHBvaW50aW5nIHVwICgwLCAtMSlcclxuICAgICAqL1xyXG4gICAgVmVjdG9yLlVwID0gbmV3IFZlY3RvcigwLCAtMSk7XHJcbiAgICAvKipcclxuICAgICAqIEEgdW5pdCB2ZWN0b3IgcG9pbnRpbmcgZG93biAoMCwgMSlcclxuICAgICAqL1xyXG4gICAgVmVjdG9yLkRvd24gPSBuZXcgVmVjdG9yKDAsIDEpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIHVuaXQgdmVjdG9yIHBvaW50aW5nIGxlZnQgKC0xLCAwKVxyXG4gICAgICovXHJcbiAgICBWZWN0b3IuTGVmdCA9IG5ldyBWZWN0b3IoLTEsIDApO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIHVuaXQgdmVjdG9yIHBvaW50aW5nIHJpZ2h0ICgxLCAwKVxyXG4gICAgICovXHJcbiAgICBWZWN0b3IuUmlnaHQgPSBuZXcgVmVjdG9yKDEsIDApO1xyXG4gICAgZXhwb3J0cy5WZWN0b3IgPSBWZWN0b3I7XHJcbiAgICAvKipcclxuICAgICAqIEEgMkQgcmF5IHRoYXQgY2FuIGJlIGNhc3QgaW50byB0aGUgc2NlbmUgdG8gZG8gY29sbGlzaW9uIGRldGVjdGlvblxyXG4gICAgICovXHJcbiAgICB2YXIgUmF5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gcG9zIFRoZSBzdGFydGluZyBwb3NpdGlvbiBmb3IgdGhlIHJheVxyXG4gICAgICAgICAqIEBwYXJhbSBkaXIgVGhlIHZlY3RvciBpbmRpY2F0aW5nIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHJheVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIFJheShwb3MsIGRpcikge1xyXG4gICAgICAgICAgICB0aGlzLnBvcyA9IHBvcztcclxuICAgICAgICAgICAgdGhpcy5kaXIgPSBkaXIubm9ybWFsaXplKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRlc3RzIGEgd2hldGhlciB0aGlzIHJheSBpbnRlcnNlY3RzIHdpdGggYSBsaW5lIHNlZ21lbnQuIFJldHVybnMgYSBudW1iZXIgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAgb24gc3VjY2Vzcy5cclxuICAgICAgICAgKiBUaGlzIG51bWJlciBpbmRpY2F0ZXMgdGhlIG1hdGhlbWF0aWNhbCBpbnRlcnNlY3Rpb24gdGltZS5cclxuICAgICAgICAgKiBAcGFyYW0gbGluZSAgVGhlIGxpbmUgdG8gdGVzdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJheS5wcm90b3R5cGUuaW50ZXJzZWN0ID0gZnVuY3Rpb24gKGxpbmUpIHtcclxuICAgICAgICAgICAgdmFyIG51bWVyYXRvciA9IGxpbmUuYmVnaW4uc3ViKHRoaXMucG9zKTtcclxuICAgICAgICAgICAgLy8gVGVzdCBpcyBsaW5lIGFuZCByYXkgYXJlIHBhcmFsbGVsIGFuZCBub24gaW50ZXJzZWN0aW5nXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRpci5jcm9zcyhsaW5lLmdldFNsb3BlKCkpID09PSAwICYmIG51bWVyYXRvci5jcm9zcyh0aGlzLmRpcikgIT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBMaW5lcyBhcmUgcGFyYWxsZWxcclxuICAgICAgICAgICAgdmFyIGRpdmlzb3IgPSAodGhpcy5kaXIuY3Jvc3MobGluZS5nZXRTbG9wZSgpKSk7XHJcbiAgICAgICAgICAgIGlmIChkaXZpc29yID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHQgPSBudW1lcmF0b3IuY3Jvc3MobGluZS5nZXRTbG9wZSgpKSAvIGRpdmlzb3I7XHJcbiAgICAgICAgICAgIGlmICh0ID49IDApIHtcclxuICAgICAgICAgICAgICAgIHZhciB1ID0gKG51bWVyYXRvci5jcm9zcyh0aGlzLmRpcikgLyBkaXZpc29yKSAvIGxpbmUuZ2V0TGVuZ3RoKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodSA+PSAwICYmIHUgPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIHBvaW50IG9mIGludGVyc2VjdGlvbiBnaXZlbiB0aGUgaW50ZXJzZWN0aW9uIHRpbWVcclxuICAgICAgICAgKi9cclxuICAgICAgICBSYXkucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKHRpbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zLmFkZCh0aGlzLmRpci5zY2FsZSh0aW1lKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gUmF5O1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuUmF5ID0gUmF5O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIDJEIGxpbmUgc2VnbWVudFxyXG4gICAgICovXHJcbiAgICB2YXIgTGluZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIGJlZ2luICBUaGUgc3RhcnRpbmcgcG9pbnQgb2YgdGhlIGxpbmUgc2VnbWVudFxyXG4gICAgICAgICAqIEBwYXJhbSBlbmQgIFRoZSBlbmRpbmcgcG9pbnQgb2YgdGhlIGxpbmUgc2VnbWVudFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIExpbmUoYmVnaW4sIGVuZCkge1xyXG4gICAgICAgICAgICB0aGlzLmJlZ2luID0gYmVnaW47XHJcbiAgICAgICAgICAgIHRoaXMuZW5kID0gZW5kO1xyXG4gICAgICAgIH1cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGluZS5wcm90b3R5cGUsIFwic2xvcGVcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgcmF3IHNsb3BlIChtKSBvZiB0aGUgbGluZS4gV2lsbCByZXR1cm4gKCsvLSlJbmZpbml0eSBmb3IgdmVydGljYWwgbGluZXMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5lbmQueSAtIHRoaXMuYmVnaW4ueSkgLyAodGhpcy5lbmQueCAtIHRoaXMuYmVnaW4ueCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMaW5lLnByb3RvdHlwZSwgXCJpbnRlcmNlcHRcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgWS1pbnRlcmNlcHQgKGIpIG9mIHRoZSBsaW5lLiBXaWxsIHJldHVybiAoKy8tKUluZmluaXR5IGlmIHRoZXJlIGlzIG5vIGludGVyY2VwdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmVnaW4ueSAtICh0aGlzLnNsb3BlICogdGhpcy5iZWdpbi54KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgbm9ybWFsIG9mIHRoZSBsaW5lXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGluZS5wcm90b3R5cGUubm9ybWFsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmQuc3ViKHRoaXMuYmVnaW4pLm5vcm1hbCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgc2xvcGUgb2YgdGhlIGxpbmUgaW4gdGhlIGZvcm0gb2YgYSB2ZWN0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBMaW5lLnByb3RvdHlwZS5nZXRTbG9wZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGJlZ2luID0gdGhpcy5iZWdpbjtcclxuICAgICAgICAgICAgdmFyIGVuZCA9IHRoaXMuZW5kO1xyXG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBiZWdpbi5kaXN0YW5jZShlbmQpO1xyXG4gICAgICAgICAgICByZXR1cm4gZW5kLnN1YihiZWdpbikuc2NhbGUoMSAvIGRpc3RhbmNlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgbGluZSBzZWdtZW50IGluIHBpeGVsc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpbmUucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGJlZ2luID0gdGhpcy5iZWdpbjtcclxuICAgICAgICAgICAgdmFyIGVuZCA9IHRoaXMuZW5kO1xyXG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBiZWdpbi5kaXN0YW5jZShlbmQpO1xyXG4gICAgICAgICAgICByZXR1cm4gZGlzdGFuY2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGaW5kIHRoZSBwZXJwZW5kaWN1bGFyIGRpc3RhbmNlIGZyb20gdGhlIGxpbmUgdG8gYSBwb2ludFxyXG4gICAgICAgICAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Rpc3RhbmNlX2Zyb21fYV9wb2ludF90b19hX2xpbmVcclxuICAgICAgICAgKiBAcGFyYW0gcG9pbnRcclxuICAgICAgICAgKi9cclxuICAgICAgICBMaW5lLnByb3RvdHlwZS5kaXN0YW5jZVRvUG9pbnQgPSBmdW5jdGlvbiAocG9pbnQpIHtcclxuICAgICAgICAgICAgdmFyIHgwID0gcG9pbnQueDtcclxuICAgICAgICAgICAgdmFyIHkwID0gcG9pbnQueTtcclxuICAgICAgICAgICAgdmFyIGwgPSB0aGlzLmdldExlbmd0aCgpO1xyXG4gICAgICAgICAgICB2YXIgZHkgPSB0aGlzLmVuZC55IC0gdGhpcy5iZWdpbi55O1xyXG4gICAgICAgICAgICB2YXIgZHggPSB0aGlzLmVuZC54IC0gdGhpcy5iZWdpbi54O1xyXG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLmFicyhkeSAqIHgwIC0gZHggKiB5MCArIHRoaXMuZW5kLnggKiB0aGlzLmJlZ2luLnkgLSB0aGlzLmVuZC55ICogdGhpcy5iZWdpbi54KSAvIGw7XHJcbiAgICAgICAgICAgIHJldHVybiBkaXN0YW5jZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZpbmRzIGEgcG9pbnQgb24gdGhlIGxpbmUgZ2l2ZW4gb25seSBhbiBYIG9yIGEgWSB2YWx1ZS4gR2l2ZW4gYW4gWCB2YWx1ZSwgdGhlIGZ1bmN0aW9uIHJldHVybnNcclxuICAgICAgICAgKiBhIG5ldyBwb2ludCB3aXRoIHRoZSBjYWxjdWxhdGVkIFkgdmFsdWUgYW5kIHZpY2UtdmVyc2EuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0geCBUaGUga25vd24gWCB2YWx1ZSBvZiB0aGUgdGFyZ2V0IHBvaW50XHJcbiAgICAgICAgICogQHBhcmFtIHkgVGhlIGtub3duIFkgdmFsdWUgb2YgdGhlIHRhcmdldCBwb2ludFxyXG4gICAgICAgICAqIEByZXR1cm5zIEEgbmV3IHBvaW50IHdpdGggdGhlIG90aGVyIGNhbGN1bGF0ZWQgYXhpcyB2YWx1ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpbmUucHJvdG90eXBlLmZpbmRQb2ludCA9IGZ1bmN0aW9uICh4LCB5KSB7XHJcbiAgICAgICAgICAgIGlmICh4ID09PSB2b2lkIDApIHsgeCA9IG51bGw7IH1cclxuICAgICAgICAgICAgaWYgKHkgPT09IHZvaWQgMCkgeyB5ID0gbnVsbDsgfVxyXG4gICAgICAgICAgICB2YXIgbSA9IHRoaXMuc2xvcGU7XHJcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy5pbnRlcmNlcHQ7XHJcbiAgICAgICAgICAgIGlmICh4ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih4LCAobSAqIHgpICsgYik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoeSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoKHkgLSBiKSAvIG0sIHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBwcm92aWRlIGFuIFggb3IgYSBZIHZhbHVlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBzZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTE5MDgxNTgvMTA5NDU4XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGluZS5wcm90b3R5cGUuaGFzUG9pbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBjdXJyUG9pbnQ7XHJcbiAgICAgICAgICAgIHZhciB0aHJlc2hvbGQgPSAwO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicgJiZcclxuICAgICAgICAgICAgICAgIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyUG9pbnQgPSBuZXcgVmVjdG9yKGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdKTtcclxuICAgICAgICAgICAgICAgIHRocmVzaG9sZCA9IGFyZ3VtZW50c1syXSB8fCAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIFZlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgY3VyclBvaW50ID0gYXJndW1lbnRzWzBdO1xyXG4gICAgICAgICAgICAgICAgdGhyZXNob2xkID0gYXJndW1lbnRzWzFdIHx8IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyAnQ291bGQgbm90IGRldGVybWluZSB0aGUgYXJndW1lbnRzIGZvciBWZWN0b3IuaGFzUG9pbnQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBkeGMgPSBjdXJyUG9pbnQueCAtIHRoaXMuYmVnaW4ueDtcclxuICAgICAgICAgICAgdmFyIGR5YyA9IGN1cnJQb2ludC55IC0gdGhpcy5iZWdpbi55O1xyXG4gICAgICAgICAgICB2YXIgZHgxID0gdGhpcy5lbmQueCAtIHRoaXMuYmVnaW4ueDtcclxuICAgICAgICAgICAgdmFyIGR5MSA9IHRoaXMuZW5kLnkgLSB0aGlzLmJlZ2luLnk7XHJcbiAgICAgICAgICAgIHZhciBjcm9zcyA9IGR4YyAqIGR5MSAtIGR5YyAqIGR4MTtcclxuICAgICAgICAgICAgLy8gY2hlY2sgd2hldGhlciBwb2ludCBsaW5lcyBvbiB0aGUgbGluZVxyXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoY3Jvc3MpID4gdGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gY2hlY2sgd2hldGhlciBwb2ludCBsaWVzIGluLWJldHdlZW4gc3RhcnQgYW5kIGVuZFxyXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoZHgxKSA+PSBNYXRoLmFicyhkeTEpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZHgxID4gMFxyXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5iZWdpbi54IDw9IGN1cnJQb2ludC54ICYmIGN1cnJQb2ludC54IDw9IHRoaXMuZW5kLnhcclxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuZW5kLnggPD0gY3VyclBvaW50LnggJiYgY3VyclBvaW50LnggPD0gdGhpcy5iZWdpbi54O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGR5MSA+IDBcclxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMuYmVnaW4ueSA8PSBjdXJyUG9pbnQueSAmJiBjdXJyUG9pbnQueSA8PSB0aGlzLmVuZC55XHJcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmVuZC55IDw9IGN1cnJQb2ludC55ICYmIGN1cnJQb2ludC55IDw9IHRoaXMuYmVnaW4ueTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIExpbmU7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5MaW5lID0gTGluZTtcclxuICAgIC8qKlxyXG4gICAgICogQSAxIGRpbWVuc2lvbmFsIHByb2plY3Rpb24gb24gYW4gYXhpcywgdXNlZCB0byB0ZXN0IG92ZXJsYXBzXHJcbiAgICAgKi9cclxuICAgIHZhciBQcm9qZWN0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBQcm9qZWN0aW9uKG1pbiwgbWF4KSB7XHJcbiAgICAgICAgICAgIHRoaXMubWluID0gbWluO1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IG1heDtcclxuICAgICAgICB9XHJcbiAgICAgICAgUHJvamVjdGlvbi5wcm90b3R5cGUub3ZlcmxhcHMgPSBmdW5jdGlvbiAocHJvamVjdGlvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXggPiBwcm9qZWN0aW9uLm1pbiAmJiBwcm9qZWN0aW9uLm1heCA+IHRoaXMubWluO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUHJvamVjdGlvbi5wcm90b3R5cGUuZ2V0T3ZlcmxhcCA9IGZ1bmN0aW9uIChwcm9qZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm92ZXJsYXBzKHByb2plY3Rpb24pKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXggPiBwcm9qZWN0aW9uLm1heCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9qZWN0aW9uLm1heCAtIHRoaXMubWluO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF4IC0gcHJvamVjdGlvbi5taW47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gUHJvamVjdGlvbjtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLlByb2plY3Rpb24gPSBQcm9qZWN0aW9uO1xyXG59KTtcclxuZGVmaW5lKFwiUGh5c2ljc1wiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkFsZ2VicmFcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBBbGdlYnJhXzEpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQb3NzaWJsZSBjb2xsaXNpb24gcmVzb2x1dGlvbiBzdHJhdGVnaWVzXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGRlZmF1bHQgaXMgW1tDb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kuQm94XV0gd2hpY2ggcGVyZm9ybXMgc2ltcGxlIGF4aXMgYWxpZ25lZCBhcmNhZGUgc3R5bGUgcGh5c2ljcy5cclxuICAgICAqXHJcbiAgICAgKiBNb3JlIGFkdmFuY2VkIHJpZ2lkIGJvZHkgcGh5c2ljcyBhcmUgZW5hYmxlZCBieSBzZXR0aW5nIFtbQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5LlJpZ2lkQm9keV1dIHdoaWNoIGFsbG93cyBmb3IgY29tcGxpY2F0ZWRcclxuICAgICAqIHNpbXVsYXRlZCBwaHlzaWNhbCBpbnRlcmFjdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIHZhciBDb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3k7XHJcbiAgICAoZnVuY3Rpb24gKENvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneSkge1xyXG4gICAgICAgIENvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneVtDb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3lbXCJCb3hcIl0gPSAwXSA9IFwiQm94XCI7XHJcbiAgICAgICAgQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5W0NvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneVtcIlJpZ2lkQm9keVwiXSA9IDFdID0gXCJSaWdpZEJvZHlcIjtcclxuICAgIH0pKENvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneSA9IGV4cG9ydHMuQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5IHx8IChleHBvcnRzLkNvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneSA9IHt9KSk7XHJcbiAgICAvKipcclxuICAgICAqIFBvc3NpYmxlIGJyb2FkcGhhc2UgY29sbGlzaW9uIHBhaXIgaWRlbnRpZmljYXRpb24gc3RyYXRlZ2llc1xyXG4gICAgICpcclxuICAgICAqIFRoZSBkZWZhdWx0IHN0cmF0ZWd5IGlzIFtbQnJvYWRwaGFzZVN0cmF0ZWd5LkR5bmFtaWNBQUJCVHJlZV1dIHdoaWNoIHVzZXMgYSBiaW5hcnkgdHJlZSBvZiBheGlzLWFsaWduZWQgYm91bmRpbmcgYm94ZXMgdG8gaWRlbnRpZnlcclxuICAgICAqIHBvdGVudGlhbCBjb2xsaXNpb24gcGFpcnMgd2hpY2ggaXMgTyhubG9nKG4pKSBmYXN0ZXIuIFRoZSBvdGhlciBwb3NzaWJsZSBzdHJhdGVneSBpcyB0aGUgW1tCcm9hZHBoYXNlU3RyYXRlZ3kuTmFpdmVdXSBzdHJhdGVneVxyXG4gICAgICogd2hpY2ggbG9vcHMgb3ZlciBldmVyeSBvYmplY3QgZm9yIGV2ZXJ5IG9iamVjdCBpbiB0aGUgc2NlbmUgdG8gaWRlbnRpZnkgY29sbGlzaW9uIHBhaXJzIHdoaWNoIGlzIE8obl4yKSBzbG93ZXIuXHJcbiAgICAgKi9cclxuICAgIHZhciBCcm9hZHBoYXNlU3RyYXRlZ3k7XHJcbiAgICAoZnVuY3Rpb24gKEJyb2FkcGhhc2VTdHJhdGVneSkge1xyXG4gICAgICAgIEJyb2FkcGhhc2VTdHJhdGVneVtCcm9hZHBoYXNlU3RyYXRlZ3lbXCJOYWl2ZVwiXSA9IDBdID0gXCJOYWl2ZVwiO1xyXG4gICAgICAgIEJyb2FkcGhhc2VTdHJhdGVneVtCcm9hZHBoYXNlU3RyYXRlZ3lbXCJEeW5hbWljQUFCQlRyZWVcIl0gPSAxXSA9IFwiRHluYW1pY0FBQkJUcmVlXCI7XHJcbiAgICB9KShCcm9hZHBoYXNlU3RyYXRlZ3kgPSBleHBvcnRzLkJyb2FkcGhhc2VTdHJhdGVneSB8fCAoZXhwb3J0cy5Ccm9hZHBoYXNlU3RyYXRlZ3kgPSB7fSkpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQb3NzaWJsZSBudW1lcmljYWwgaW50ZWdyYXRvcnMgZm9yIHBvc2l0aW9uIGFuZCB2ZWxvY2l0eVxyXG4gICAgICovXHJcbiAgICB2YXIgSW50ZWdyYXRvcjtcclxuICAgIChmdW5jdGlvbiAoSW50ZWdyYXRvcikge1xyXG4gICAgICAgIEludGVncmF0b3JbSW50ZWdyYXRvcltcIkV1bGVyXCJdID0gMF0gPSBcIkV1bGVyXCI7XHJcbiAgICB9KShJbnRlZ3JhdG9yID0gZXhwb3J0cy5JbnRlZ3JhdG9yIHx8IChleHBvcnRzLkludGVncmF0b3IgPSB7fSkpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgW1tQaHlzaWNzXV0gb2JqZWN0IGlzIHRoZSBnbG9iYWwgY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGFsbCBFeGNhbGlidXIgcGh5c2ljcy5cclxuICAgICAqXHJcbiAgICAgKiBbW2luY2x1ZGU6UGh5c2ljcy5tZF1dXHJcbiAgICAgKi9cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICB2YXIgUGh5c2ljcyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gUGh5c2ljcygpIHtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uZmlndXJlcyBFeGNhbGlidXIgdG8gdXNlIGJveCBwaHlzaWNzLiBCb3ggcGh5c2ljcyB3aGljaCBwZXJmb3JtcyBzaW1wbGUgYXhpcyBhbGlnbmVkIGFyY2FkZSBzdHlsZSBwaHlzaWNzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBoeXNpY3MudXNlQm94UGh5c2ljcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgUGh5c2ljcy5jb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kgPSBDb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kuQm94O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uZmlndXJlcyBFeGNhbGlidXIgdG8gdXNlIHJpZ2lkIGJvZHkgcGh5c2ljcy4gUmlnaWQgYm9keSBwaHlzaWNzIGFsbG93cyBmb3IgY29tcGxpY2F0ZWRcclxuICAgICAgICAgKiBzaW11bGF0ZWQgcGh5c2ljYWwgaW50ZXJhY3Rpb25zLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBoeXNpY3MudXNlUmlnaWRCb2R5UGh5c2ljcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgUGh5c2ljcy5jb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kgPSBDb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kuUmlnaWRCb2R5O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFBoeXNpY3M7XHJcbiAgICB9KCkpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHbG9iYWwgYWNjZWxlcmF0aW9uIHRoYXQgaXMgYXBwbGllZCB0byBhbGwgdmFuaWxsYSBhY3RvcnMgKGl0IHdvbnQgZWZmZWN0IFtbTGFiZWx8bGFiZWxzXV0sIFtbVUlBY3Rvcnx1aSBhY3RvcnNdXSwgb3JcclxuICAgICAqIFtbVHJpZ2dlcnx0cmlnZ2Vyc11dIGluIEV4Y2FsaWJ1ciB0aGF0IGhhdmUgYW4gW1tDb2xsaXNpb25UeXBlLkFjdGl2ZXxhY3RpdmVdXSBjb2xsaXNpb24gdHlwZSkuXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgaXMgYSBncmVhdCB3YXkgdG8gZ2xvYmFsbHkgc2ltdWxhdGUgZWZmZWN0cyBsaWtlIGdyYXZpdHkuXHJcbiAgICAgKi9cclxuICAgIFBoeXNpY3MuYWNjID0gbmV3IEFsZ2VicmFfMS5WZWN0b3IoMCwgMCk7XHJcbiAgICAvKipcclxuICAgICAqIEdsb2JhbGx5IHN3aXRjaGVzIGFsbCBFeGNhbGlidXIgcGh5c2ljcyBiZWhhdmlvciBvbiBvciBvZmYuXHJcbiAgICAgKi9cclxuICAgIFBoeXNpY3MuZW5hYmxlZCA9IHRydWU7XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbnVtYmVyIG9mIGNvbGxpc2lvbiBwYXNzZXMgZm9yIEV4Y2FsaWJ1ciB0byBwZXJmb3JtIG9uIHBoeXNpY3MgYm9kaWVzLlxyXG4gICAgICpcclxuICAgICAqIFJlZHVjaW5nIGNvbGxpc2lvbiBwYXNzZXMgbWF5IGNhdXNlIHRoaW5ncyBub3QgdG8gY29sbGlkZSBhcyBleHBlY3RlZCBpbiB5b3VyIGdhbWUsIGJ1dCBtYXkgaW5jcmVhc2UgcGVyZm9ybWFuY2UuXHJcbiAgICAgKlxyXG4gICAgICogTW9yZSBwYXNzZXMgY2FuIGltcHJvdmUgdGhlIHZpc3VhbCBxdWFsaXR5IG9mIGNvbGxpc2lvbnMgd2hlbiBtYW55IG9iamVjdHMgYXJlIG9uIHRoZSBzY3JlZW4uIFRoaXMgY2FuIHJlZHVjZSBqaXR0ZXIsIGltcHJvdmUgdGhlXHJcbiAgICAgKiBjb2xsaXNpb24gcmVzb2x1dGlvbiBvZiBmYXN0IG1vdmUgb2JqZWN0cywgb3IgdGhlIHN0YWJpbGl0eSBvZiBsYXJnZSBudW1iZXJzIG9mIG9iamVjdHMgc3RhY2tlZCB0b2dldGhlci5cclxuICAgICAqXHJcbiAgICAgKiBGZXdlciBwYXNzZXMgd2lsbCBpbXByb3ZlIHRoZSBwZXJmb3JtYW5jZSBvZiB0aGUgZ2FtZSBhdCB0aGUgY29zdCBvZiBjb2xsaXNpb24gcXVhbGl0eSwgbW9yZSBwYXNzZXMgd2lsbCBpbXByb3ZlIHF1YWxpdHkgYXQgdGhlXHJcbiAgICAgKiBjb3N0IG9mIHBlcmZvcm1hbmNlLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBkZWZhdWx0IGlzIHNldCB0byA1IHBhc3NlcyB3aGljaCBpcyBhIGdvb2Qgc3RhcnQuXHJcbiAgICAgKi9cclxuICAgIFBoeXNpY3MuY29sbGlzaW9uUGFzc2VzID0gNTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBicm9hZHBoYXNlIHBhaXIgaWRlbnRpZmljYXRpb24gc3RyYXRlZ3kuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGRlZmF1bHQgc3RyYXRlZ3kgaXMgW1tCcm9hZHBoYXNlU3RyYXRlZ3kuRHluYW1pY0FBQkJUcmVlXV0gd2hpY2ggdXNlcyBhIGJpbmFyeSB0cmVlIG9mIGF4aXMtYWxpZ25lZCBib3VuZGluZyBib3hlcyB0byBpZGVudGlmeVxyXG4gICAgICogcG90ZW50aWFsIGNvbGxpc2lvbiBwYWlycyB3aGljaCBpcyBPKG5sb2cobikpIGZhc3Rlci4gVGhlIG90aGVyIHBvc3NpYmxlIHN0cmF0ZWd5IGlzIHRoZSBbW0Jyb2FkcGhhc2VTdHJhdGVneS5OYWl2ZV1dIHN0cmF0ZWd5XHJcbiAgICAgKiB3aGljaCBsb29wcyBvdmVyIGV2ZXJ5IG9iamVjdCBmb3IgZXZlcnkgb2JqZWN0IGluIHRoZSBzY2VuZSB0byBpZGVudGlmeSBjb2xsaXNpb24gcGFpcnMgd2hpY2ggaXMgTyhuXjIpIHNsb3dlci5cclxuICAgICAqL1xyXG4gICAgUGh5c2ljcy5icm9hZHBoYXNlU3RyYXRlZ3kgPSBCcm9hZHBoYXNlU3RyYXRlZ3kuRHluYW1pY0FBQkJUcmVlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHbG9iYWxseSBzd2l0Y2hlcyB0aGUgZGVidWcgaW5mb3JtYXRpb24gZm9yIHRoZSBicm9hZHBoYXNlIHN0cmF0ZWd5XHJcbiAgICAgKi9cclxuICAgIFBoeXNpY3MuYnJvYWRwaGFzZURlYnVnID0gZmFsc2U7XHJcbiAgICAvKipcclxuICAgICAqIFNob3cgdGhlIG5vcm1hbHMgYXMgYSByZXN1bHQgb2YgY29sbGlzaW9uIG9uIHRoZSBzY3JlZW4uXHJcbiAgICAgKi9cclxuICAgIFBoeXNpY3Muc2hvd0NvbGxpc2lvbk5vcm1hbHMgPSBmYWxzZTtcclxuICAgIC8qKlxyXG4gICAgICogU2hvdyB0aGUgcG9zaXRpb24sIHZlbG9jaXR5LCBhbmQgYWNjZWxlcmF0aW9uIGFzIGdyYXBoaWNhbCB2ZWN0b3JzLlxyXG4gICAgICovXHJcbiAgICBQaHlzaWNzLnNob3dNb3Rpb25WZWN0b3JzID0gZmFsc2U7XHJcbiAgICAvKipcclxuICAgICAqIFNob3cgdGhlIGF4aXMtYWxpZ25lZCBib3VuZGluZyBib3hlcyBvZiB0aGUgY29sbGlzaW9uIGJvZGllcyBvbiB0aGUgc2NyZWVuLlxyXG4gICAgICovXHJcbiAgICBQaHlzaWNzLnNob3dCb3VuZHMgPSBmYWxzZTtcclxuICAgIC8qKlxyXG4gICAgICogU2hvdyB0aGUgYm91bmRpbmcgY29sbGlzaW9uIGFyZWEgc2hhcGVzXHJcbiAgICAgKi9cclxuICAgIFBoeXNpY3Muc2hvd0FyZWEgPSBmYWxzZTtcclxuICAgIC8qKlxyXG4gICAgICogU2hvdyBwb2ludHMgb2YgY29sbGlzaW9uIGludGVycHJldGVkIGJ5IGV4Y2FsaWJ1ciBhcyBhIHJlc3VsdCBvZiBjb2xsaXNpb24uXHJcbiAgICAgKi9cclxuICAgIFBoeXNpY3Muc2hvd0NvbnRhY3RzID0gZmFsc2U7XHJcbiAgICAvKipcclxuICAgICAqIFNob3cgdGhlIHN1cmZhY2Ugbm9ybWFscyBvZiB0aGUgY29sbGlzaW9uIGFyZWFzLlxyXG4gICAgICovXHJcbiAgICBQaHlzaWNzLnNob3dOb3JtYWxzID0gZmFsc2U7XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgZ2xvYmFsIGNvbGxpc2lvbiByZXNvbHV0aW9uIHN0cmF0ZWd5IChuYXJyb3dwaGFzZSkuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGRlZmF1bHQgaXMgW1tDb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kuQm94XV0gd2hpY2ggcGVyZm9ybXMgc2ltcGxlIGF4aXMgYWxpZ25lZCBhcmNhZGUgc3R5bGUgcGh5c2ljcy5cclxuICAgICAqXHJcbiAgICAgKiBNb3JlIGFkdmFuY2VkIHJpZ2lkIGJvZHkgcGh5c2ljcyBhcmUgZW5hYmxlZCBieSBzZXR0aW5nIFtbQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5LlJpZ2lkQm9keV1dIHdoaWNoIGFsbG93cyBmb3IgY29tcGxpY2F0ZWRcclxuICAgICAqIHNpbXVsYXRlZCBwaHlzaWNhbCBpbnRlcmFjdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIFBoeXNpY3MuY29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5ID0gQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5LkJveDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGRlZmF1bHQgbWFzcyB0byB1c2UgaWYgbm9uZSBpcyBzcGVjaWZpZWRcclxuICAgICAqL1xyXG4gICAgUGh5c2ljcy5kZWZhdWx0TWFzcyA9IDEwO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHBvc2l0aW9uIGFuZCB2ZWxvY2l0eSBwb3NpdGlvbmFsIGludGVncmF0b3IsIGN1cnJlbnRseSBvbmx5IEV1bGVyIGlzIHN1cHBvcnRlZC5cclxuICAgICAqL1xyXG4gICAgUGh5c2ljcy5pbnRlZ3JhdG9yID0gSW50ZWdyYXRvci5FdWxlcjtcclxuICAgIC8qKlxyXG4gICAgICogTnVtYmVyIG9mIHN0ZXBzIHRvIHVzZSBpbiBpbnRlZ3JhdGlvbi4gQSBoaWdoZXIgbnVtYmVyIGltcHJvdmVzIHRoZSBwb3NpdGlvbmFsIGFjY3VyYWN5IG92ZXIgdGltZS4gVGhpcyBjYW4gYmUgdXNlZnVsIHRvIGluY3JlYXNlXHJcbiAgICAgKiBpZiB5b3UgaGF2ZSBmYXN0IG1vdmluZyBvYmplY3RzIGluIHlvdXIgc2ltdWxhdGlvbiBvciB5b3UgaGF2ZSBhIGxhcmdlIG51bWJlciBvZiBvYmplY3RzIGFuZCBuZWVkIHRvIGluY3JlYXNlIHN0YWJpbGl0eS5cclxuICAgICAqL1xyXG4gICAgUGh5c2ljcy5pbnRlZ3JhdGlvblN0ZXBzID0gMTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHdoZXRoZXIgcm90YXRpb24gaXMgYWxsb3dlZCBpbiBhIFJpZ2lkQm9keSBjb2xsaXNpb24gcmVzb2x1dGlvblxyXG4gICAgICovXHJcbiAgICBQaHlzaWNzLmFsbG93UmlnaWRCb2R5Um90YXRpb24gPSB0cnVlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTbWFsbCB2YWx1ZSB0byBoZWxwIGNvbGxpc2lvbiBwYXNzZXMgc2V0dGxlIHRoZW1zZWx2ZXMgYWZ0ZXIgdGhlIG5hcnJvd3BoYXNlLlxyXG4gICAgICovXHJcbiAgICBQaHlzaWNzLmNvbGxpc2lvblNoaWZ0ID0gLjAwMTtcclxuICAgIC8qKlxyXG4gICAgICogRmFjdG9yIHRvIGFkZCB0byB0aGUgUmlnaWRCb2R5IEJvdW5kaW5nQm94LCBib3VuZGluZyBib3ggKGRpbWVuc2lvbnMgKz0gdmVsICogZHluYW1pY1RyZWVWZWxvY2l0eU11bHRpcGx5ZXIpO1xyXG4gICAgICovXHJcbiAgICBQaHlzaWNzLmR5bmFtaWNUcmVlVmVsb2NpdHlNdWx0aXBseWVyID0gMjtcclxuICAgIC8qKlxyXG4gICAgICogUGFkIFJpZ2lkQm9keSBCb3VuZGluZ0JveCBieSBhIGNvbnN0YW50IGFtb3VudFxyXG4gICAgICovXHJcbiAgICBQaHlzaWNzLmJvdW5kc1BhZGRpbmcgPSA1O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdXJmYWNlIGVwc2lsb24gaXMgdXNlZCB0byBoZWxwIGRlYWwgd2l0aCBzdXJmYWNlIHBlbmF0cmF0aW9uXHJcbiAgICAgKi9cclxuICAgIFBoeXNpY3Muc3VyZmFjZUVwc2lsb24gPSAuMTtcclxuICAgIC8qKlxyXG4gICAgICogRW5hYmxlIGZhc3QgbW92aW5nIGJvZHkgY2hlY2tpbmcsIHRoaXMgZW5hYmxlcyBjaGVja2luZyBmb3IgY29sbGlzaW9uIHBhaXJzIHZpYSByYXljYXN0IGZvciBmYXN0IG1vdmluZyBvYmplY3RzIHRvIHByZXZlbnRcclxuICAgICAqIGJvZGllcyBmcm9tIHR1bm5lbGluZyB0aHJvdWdoIG9uZSBhbm90aGVyLlxyXG4gICAgICovXHJcbiAgICBQaHlzaWNzLmNoZWNrRm9yRmFzdEJvZGllcyA9IHRydWU7XHJcbiAgICAvKipcclxuICAgICAqIERpc2FibGUgbWluaW11bSBmYXN0IG1vdmluZyBib2R5IHJheWNhc3QsIGJ5IGRlZmF1bHQgaWYgZXguUGh5c2ljcy5jaGVja0ZvckZhc3RCb2RpZXMgPSB0cnVlIEV4Y2FsaWJ1ciB3aWxsIG9ubHkgY2hlY2sgaWYgdGhlXHJcbiAgICAgKiBib2R5IGlzIG1vdmluZyBhdCBsZWFzdCBoYWxmIG9mIGl0cyBtaW5pbXVtIGRpbWluZW5zaW9uIGluIGFuIHVwZGF0ZS4gSWYgZXguUGh5c2ljcy5kaXNhYmxlTWluaW11bVNwZWVkRm9yRmFzdEJvZHkgaXMgc2V0IHRvIHRydWUsXHJcbiAgICAgKiBFeGNhbGlidXIgd2lsbCBhbHdheXMgcGVyZm9ybSB0aGUgZmFzdCBib2R5IHJheWNhc3QgcmVnYXJkbGVzcyBvZiBzcGVlZC5cclxuICAgICAqL1xyXG4gICAgUGh5c2ljcy5kaXNhYmxlTWluaW11bVNwZWVkRm9yRmFzdEJvZHkgPSBmYWxzZTtcclxuICAgIGV4cG9ydHMuUGh5c2ljcyA9IFBoeXNpY3M7XHJcbn0pO1xyXG5kZWZpbmUoXCJVdGlsL0Vhc2luZ0Z1bmN0aW9uc1wiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFuZGFyZCBlYXNpbmcgZnVuY3Rpb25zIGZvciBtb3Rpb24gaW4gRXhjYWxpYnVyLCBkZWZpbmVkIG9uIGEgZG9tYWluIG9mIFswLCBkdXJhdGlvbl0gYW5kIGEgcmFuZ2UgZnJvbSBbK3N0YXJ0VmFsdWUsK2VuZFZhbHVlXVxyXG4gICAgICogR2l2ZW4gYSB0aW1lLCB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gYSB2YWx1ZSBmcm9tIHBvc2l0aXZlIHN0YXJ0VmFsdWUgdG8gcG9zaXRpdmUgZW5kVmFsdWUuXHJcbiAgICAgKlxyXG4gICAgICogYGBganNcclxuICAgICAqIGZ1bmN0aW9uIExpbmVhciAodCkge1xyXG4gICAgICogICAgcmV0dXJuIHQgKiB0O1xyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIC8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcclxuICAgICAqIGZ1bmN0aW9uIEVhc2VJblF1YWQgKHQpIHtcclxuICAgICAqICAgIHJldHVybiB0ICogdDtcclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiAvLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxyXG4gICAgICogZnVuY3Rpb24gRWFzZU91dFF1YWQgKHQpIHtcclxuICAgICAqICAgIHJldHVybiB0ICogKDIgLSB0KTtcclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiAvLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cclxuICAgICAqIGZ1bmN0aW9uIEVhc2VJbk91dFF1YWQgKHQpIHtcclxuICAgICAqICAgIHJldHVybiB0IDwgLjUgPyAyICogdCAqIHQgOiAtMSArICg0IC0gMiAqIHQpICogdDtcclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiAvLyBhY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XHJcbiAgICAgKiBmdW5jdGlvbiBFYXNlSW5DdWJpYyAodCkge1xyXG4gICAgICogICAgcmV0dXJuIHQgKiB0ICogdDtcclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiAvLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxyXG4gICAgICogZnVuY3Rpb24gRWFzZU91dEN1YmljICh0KSB7XHJcbiAgICAgKiAgICByZXR1cm4gKC0tdCkgKiB0ICogdCArIDE7XHJcbiAgICAgKiB9XHJcbiAgICAgKlxyXG4gICAgICogLy8gYWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXHJcbiAgICAgKiBmdW5jdGlvbiBFYXNlSW5PdXRDdWJpYyAodCkge1xyXG4gICAgICogICAgcmV0dXJuIHQgPCAuNSA/IDQgKiB0ICogdCAqIHQgOiAodCAtIDEpICogKDIgKiB0IC0gMikgKiAoMiAqIHQgLSAyKSArIDE7XHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgdmFyIEVhc2luZ0Z1bmN0aW9ucyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gRWFzaW5nRnVuY3Rpb25zKCkge1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gRWFzaW5nRnVuY3Rpb25zO1xyXG4gICAgfSgpKTtcclxuICAgIEVhc2luZ0Z1bmN0aW9ucy5MaW5lYXIgPSBmdW5jdGlvbiAoY3VycmVudFRpbWUsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBkdXJhdGlvbikge1xyXG4gICAgICAgIGVuZFZhbHVlID0gKGVuZFZhbHVlIC0gc3RhcnRWYWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIGVuZFZhbHVlICogY3VycmVudFRpbWUgLyBkdXJhdGlvbiArIHN0YXJ0VmFsdWU7XHJcbiAgICB9O1xyXG4gICAgRWFzaW5nRnVuY3Rpb25zLkVhc2VJblF1YWQgPSBmdW5jdGlvbiAoY3VycmVudFRpbWUsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBkdXJhdGlvbikge1xyXG4gICAgICAgIGVuZFZhbHVlID0gKGVuZFZhbHVlIC0gc3RhcnRWYWx1ZSk7XHJcbiAgICAgICAgY3VycmVudFRpbWUgLz0gZHVyYXRpb247XHJcbiAgICAgICAgcmV0dXJuIGVuZFZhbHVlICogY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSArIHN0YXJ0VmFsdWU7XHJcbiAgICB9O1xyXG4gICAgRWFzaW5nRnVuY3Rpb25zLkVhc2VPdXRRdWFkID0gZnVuY3Rpb24gKGN1cnJlbnRUaW1lLCBzdGFydFZhbHVlLCBlbmRWYWx1ZSwgZHVyYXRpb24pIHtcclxuICAgICAgICBlbmRWYWx1ZSA9IChlbmRWYWx1ZSAtIHN0YXJ0VmFsdWUpO1xyXG4gICAgICAgIGN1cnJlbnRUaW1lIC89IGR1cmF0aW9uO1xyXG4gICAgICAgIHJldHVybiAtZW5kVmFsdWUgKiBjdXJyZW50VGltZSAqIChjdXJyZW50VGltZSAtIDIpICsgc3RhcnRWYWx1ZTtcclxuICAgIH07XHJcbiAgICBFYXNpbmdGdW5jdGlvbnMuRWFzZUluT3V0UXVhZCA9IGZ1bmN0aW9uIChjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGR1cmF0aW9uKSB7XHJcbiAgICAgICAgZW5kVmFsdWUgPSAoZW5kVmFsdWUgLSBzdGFydFZhbHVlKTtcclxuICAgICAgICBjdXJyZW50VGltZSAvPSBkdXJhdGlvbiAvIDI7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lIDwgMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZW5kVmFsdWUgLyAyICogY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSArIHN0YXJ0VmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnJlbnRUaW1lLS07XHJcbiAgICAgICAgcmV0dXJuIC1lbmRWYWx1ZSAvIDIgKiAoY3VycmVudFRpbWUgKiAoY3VycmVudFRpbWUgLSAyKSAtIDEpICsgc3RhcnRWYWx1ZTtcclxuICAgIH07XHJcbiAgICBFYXNpbmdGdW5jdGlvbnMuRWFzZUluQ3ViaWMgPSBmdW5jdGlvbiAoY3VycmVudFRpbWUsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBkdXJhdGlvbikge1xyXG4gICAgICAgIGVuZFZhbHVlID0gKGVuZFZhbHVlIC0gc3RhcnRWYWx1ZSk7XHJcbiAgICAgICAgY3VycmVudFRpbWUgLz0gZHVyYXRpb247XHJcbiAgICAgICAgcmV0dXJuIGVuZFZhbHVlICogY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICsgc3RhcnRWYWx1ZTtcclxuICAgIH07XHJcbiAgICBFYXNpbmdGdW5jdGlvbnMuRWFzZU91dEN1YmljID0gZnVuY3Rpb24gKGN1cnJlbnRUaW1lLCBzdGFydFZhbHVlLCBlbmRWYWx1ZSwgZHVyYXRpb24pIHtcclxuICAgICAgICBlbmRWYWx1ZSA9IChlbmRWYWx1ZSAtIHN0YXJ0VmFsdWUpO1xyXG4gICAgICAgIGN1cnJlbnRUaW1lIC89IGR1cmF0aW9uO1xyXG4gICAgICAgIGN1cnJlbnRUaW1lLS07XHJcbiAgICAgICAgcmV0dXJuIGVuZFZhbHVlICogKGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSArIDEpICsgc3RhcnRWYWx1ZTtcclxuICAgIH07XHJcbiAgICBFYXNpbmdGdW5jdGlvbnMuRWFzZUluT3V0Q3ViaWMgPSBmdW5jdGlvbiAoY3VycmVudFRpbWUsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBkdXJhdGlvbikge1xyXG4gICAgICAgIGVuZFZhbHVlID0gKGVuZFZhbHVlIC0gc3RhcnRWYWx1ZSk7XHJcbiAgICAgICAgY3VycmVudFRpbWUgLz0gZHVyYXRpb24gLyAyO1xyXG4gICAgICAgIGlmIChjdXJyZW50VGltZSA8IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVuZFZhbHVlIC8gMiAqIGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSArIHN0YXJ0VmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnJlbnRUaW1lIC09IDI7XHJcbiAgICAgICAgcmV0dXJuIGVuZFZhbHVlIC8gMiAqIChjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKyAyKSArIHN0YXJ0VmFsdWU7XHJcbiAgICB9O1xyXG4gICAgZXhwb3J0cy5FYXNpbmdGdW5jdGlvbnMgPSBFYXNpbmdGdW5jdGlvbnM7XHJcbn0pO1xyXG4vLyBQcm9taXNlcy9BKyBTcGVjIGh0dHA6Ly9wcm9taXNlcy1hcGx1cy5naXRodWIuaW8vcHJvbWlzZXMtc3BlYy9cclxuZGVmaW5lKFwiUHJvbWlzZXNcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogVmFsaWQgc3RhdGVzIGZvciBhIHByb21pc2UgdG8gYmUgaW5cclxuICAgICAqL1xyXG4gICAgdmFyIFByb21pc2VTdGF0ZTtcclxuICAgIChmdW5jdGlvbiAoUHJvbWlzZVN0YXRlKSB7XHJcbiAgICAgICAgUHJvbWlzZVN0YXRlW1Byb21pc2VTdGF0ZVtcIlJlc29sdmVkXCJdID0gMF0gPSBcIlJlc29sdmVkXCI7XHJcbiAgICAgICAgUHJvbWlzZVN0YXRlW1Byb21pc2VTdGF0ZVtcIlJlamVjdGVkXCJdID0gMV0gPSBcIlJlamVjdGVkXCI7XHJcbiAgICAgICAgUHJvbWlzZVN0YXRlW1Byb21pc2VTdGF0ZVtcIlBlbmRpbmdcIl0gPSAyXSA9IFwiUGVuZGluZ1wiO1xyXG4gICAgfSkoUHJvbWlzZVN0YXRlID0gZXhwb3J0cy5Qcm9taXNlU3RhdGUgfHwgKGV4cG9ydHMuUHJvbWlzZVN0YXRlID0ge30pKTtcclxuICAgIC8qKlxyXG4gICAgICogUHJvbWlzZXMgYXJlIHVzZWQgdG8gZG8gYXN5bmNocm9ub3VzIHdvcmsgYW5kIHRoZXkgYXJlIHVzZWZ1bCBmb3JcclxuICAgICAqIGNyZWF0aW5nIGEgY2hhaW4gb2YgYWN0aW9ucy4gSW4gRXhjYWxpYnVyIHRoZXkgYXJlIHVzZWQgZm9yIGxvYWRpbmcsXHJcbiAgICAgKiBzb3VuZHMsIGFuaW1hdGlvbiwgYWN0aW9ucywgYW5kIG1vcmUuXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOlByb21pc2VzLm1kXV1cclxuICAgICAqL1xyXG4gICAgdmFyIFByb21pc2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIFByb21pc2UoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gUHJvbWlzZVN0YXRlLlBlbmRpbmc7XHJcbiAgICAgICAgICAgIHRoaXMuX3N1Y2Nlc3NDYWxsYmFja3MgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5fcmVqZWN0Q2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7IHJldHVybjsgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlIGFuZCByZXNvbHZlIGEgUHJvbWlzZSB3aXRoIGFuIG9wdGlvbmFsIHZhbHVlXHJcbiAgICAgICAgICogQHBhcmFtIHZhbHVlICBBbiBvcHRpb25hbCB2YWx1ZSB0byB3cmFwIGluIGEgcmVzb2x2ZWQgcHJvbWlzZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb21pc2UucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IChuZXcgUHJvbWlzZSgpKS5yZXNvbHZlKHZhbHVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGUgYW5kIHJlamVjdCBhIFByb21pc2Ugd2l0aCBhbiBvcHRpb25hbCB2YWx1ZVxyXG4gICAgICAgICAqIEBwYXJhbSB2YWx1ZSAgQW4gb3B0aW9uYWwgdmFsdWUgdG8gd3JhcCBpbiBhIHJlamVjdGVkIHByb21pc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBQcm9taXNlLnJlamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IChuZXcgUHJvbWlzZSgpKS5yZWplY3QodmFsdWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFByb21pc2Uuam9pbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHByb21pc2VzID0gW107XHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCAmJiAhQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9taXNlcyA9IGFyZ3VtZW50c1swXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgam9pbmVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKCk7XHJcbiAgICAgICAgICAgIGlmICghcHJvbWlzZXMgfHwgIXByb21pc2VzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGpvaW5lZFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB0b3RhbCA9IHByb21pc2VzLmxlbmd0aDtcclxuICAgICAgICAgICAgdmFyIHN1Y2Nlc3NlcyA9IDA7XHJcbiAgICAgICAgICAgIHZhciByZWplY3RzID0gMDtcclxuICAgICAgICAgICAgdmFyIGVycm9ycyA9IFtdO1xyXG4gICAgICAgICAgICBwcm9taXNlcy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XHJcbiAgICAgICAgICAgICAgICBwLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NlcyArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWNjZXNzZXMgPT09IHRvdGFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpvaW5lZFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzdWNjZXNzZXMgKyByZWplY3RzICsgZXJyb3JzLmxlbmd0aCA9PT0gdG90YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgam9pbmVkUHJvbWlzZS5yZWplY3QoZXJyb3JzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0cyArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWNjZXNzZXMgKyByZWplY3RzICsgZXJyb3JzLmxlbmd0aCA9PT0gdG90YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgam9pbmVkUHJvbWlzZS5yZWplY3QoZXJyb3JzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KS5lcnJvcihmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoZXJyb3JzLmxlbmd0aCArIHN1Y2Nlc3NlcyArIHJlamVjdHMpID09PSB0b3RhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqb2luZWRQcm9taXNlLnJlamVjdChlcnJvcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIGpvaW5lZFByb21pc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGFpbiBzdWNjZXNzIGFuZCByZWplY3QgY2FsbGJhY2tzIGFmdGVyIHRoZSBwcm9taXNlIGlzIHJlc29sdmVkXHJcbiAgICAgICAgICogQHBhcmFtIHN1Y2Nlc3NDYWxsYmFjayAgQ2FsbCBvbiByZXNvbHV0aW9uIG9mIHByb21pc2VcclxuICAgICAgICAgKiBAcGFyYW0gcmVqZWN0Q2FsbGJhY2sgICBDYWxsIG9uIHJlamVjdGlvbiBvZiBwcm9taXNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChzdWNjZXNzQ2FsbGJhY2ssIHJlamVjdENhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGlmIChzdWNjZXNzQ2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N1Y2Nlc3NDYWxsYmFja3MucHVzaChzdWNjZXNzQ2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHByb21pc2UgaXMgYWxyZWFkeSByZXNvdmxlZCBjYWxsIGltbWVkaWF0ZWx5XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSgpID09PSBQcm9taXNlU3RhdGUuUmVzb2x2ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzQ2FsbGJhY2suY2FsbCh0aGlzLCB0aGlzLl92YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZUVycm9yKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmVqZWN0Q2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlamVjdENhbGxiYWNrID0gcmVqZWN0Q2FsbGJhY2s7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcHJvbWlzZSBpcyBhbHJlYWR5IHJlamVjdGVkIGNhbGwgaW1tZWRpYXRlbHlcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlKCkgPT09IFByb21pc2VTdGF0ZS5SZWplY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdENhbGxiYWNrLmNhbGwodGhpcywgdGhpcy5fdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVFcnJvcihlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGQgYW4gZXJyb3IgY2FsbGJhY2sgdG8gdGhlIHByb21pc2VcclxuICAgICAgICAgKiBAcGFyYW0gZXJyb3JDYWxsYmFjayAgQ2FsbCBpZiB0aGVyZSB3YXMgYW4gZXJyb3IgaW4gYSBjYWxsYmFja1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycm9yQ2FsbGJhY2spIHtcclxuICAgICAgICAgICAgaWYgKGVycm9yQ2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9yQ2FsbGJhY2sgPSBlcnJvckNhbGxiYWNrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVzb2x2ZSB0aGUgcHJvbWlzZSBhbmQgcGFzcyBhbiBvcHRpb24gdmFsdWUgdG8gdGhlIHN1Y2Nlc3MgY2FsbGJhY2tzXHJcbiAgICAgICAgICogQHBhcmFtIHZhbHVlICBWYWx1ZSB0byBwYXNzIHRvIHRoZSBzdWNjZXNzIGNhbGxiYWNrc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBQcm9taXNlU3RhdGUuUGVuZGluZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBQcm9taXNlU3RhdGUuUmVzb2x2ZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3VjY2Vzc0NhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChjYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYi5jYWxsKF90aGlzLCBfdGhpcy5fdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVFcnJvcihlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlc29sdmUgYSBwcm9taXNlIHRoYXQgaXMgbm90IGluIGEgcGVuZGluZyBzdGF0ZSEnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlamVjdCB0aGUgcHJvbWlzZSBhbmQgcGFzcyBhbiBvcHRpb24gdmFsdWUgdG8gdGhlIHJlamVjdCBjYWxsYmFja3NcclxuICAgICAgICAgKiBAcGFyYW0gdmFsdWUgIFZhbHVlIHRvIHBhc3MgdG8gdGhlIHJlamVjdCBjYWxsYmFja3NcclxuICAgICAgICAgKi9cclxuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5yZWplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBQcm9taXNlU3RhdGUuUGVuZGluZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBQcm9taXNlU3RhdGUuUmVqZWN0ZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVqZWN0Q2FsbGJhY2suY2FsbCh0aGlzLCB0aGlzLl92YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZUVycm9yKGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVqZWN0IGEgcHJvbWlzZSB0aGF0IGlzIG5vdCBpbiBhIHBlbmRpbmcgc3RhdGUhJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbnNwZWN0IHRoZSBjdXJyZW50IHN0YXRlIG9mIGEgcHJvbWlzZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLnN0YXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5faGFuZGxlRXJyb3IgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fZXJyb3JDYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZXJyb3JDYWxsYmFjay5jYWxsKHRoaXMsIGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gcmV0aHJvdyBlcnJvclxyXG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2U7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5Qcm9taXNlID0gUHJvbWlzZTtcclxufSk7XHJcbi8qKlxyXG4gKiBQc2V1ZG8tUmFuZG9tIFV0aWxpdHlcclxuICpcclxuICogQSBwc2V1ZG8tcmFuZG9tIHV0aWxpdHkgdG8gYWRkIHNlZWRlZCByYW5kb20gc3VwcG9ydCBmb3IgaGVscCBpblxyXG4gKiBnZW5lcmF0aW5nIHRoaW5ncyBsaWtlIHRlcnJhaW4gb3IgcmVwcm9kdWNpYmxlIHJhbmRvbW5lc3MuIFVzZXMgdGhlXHJcbiAqIFtNZXJzZW5uZSBUd2lzdGVyXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NZXJzZW5uZV9Ud2lzdGVyKSBhbGdvcml0aG0uXHJcbiAqXHJcbiAqIFtbaW5jbHVkZTpSYW5kb20ubWRdXVxyXG4gKi9cclxuZGVmaW5lKFwiTWF0aC9SYW5kb21cIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogMzItYml0IG1hc2tcclxuICAgICAqL1xyXG4gICAgdmFyIEJJVE1BU0szMiA9IDB4RkZGRkZGRkY7XHJcbiAgICAvKipcclxuICAgICAqIFBzZXVkby1yYW5kb20gbnVtYmVyIGdlbmVyYXRvciBmb2xsb3dpbmcgdGhlIE1lcnNlbm5lX1R3aXN0ZXIgYWxnb3JpdGhtLiBHaXZlbiBhIHNlZWQgdGhpcyBnZW5lcmF0b3Igd2lsbCBwcm9kdWNlIHRoZSBzYW1lIHNlcXVlbmNlXHJcbiAgICAgKiBvZiBudW1iZXJzIGVhY2ggdGltZSBpdCBpcyBjYWxsZWQuXHJcbiAgICAgKiBTZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWVyc2VubmVfVHdpc3RlciBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gICAgICogVXNlcyB0aGUgTVQxOTkzNy0zMiAoMjAwMikgaW1wbGVtZW50YXRpb24gZG9jdW1lbnRlZCBoZXJlIGh0dHA6Ly93d3cubWF0aC5zY2kuaGlyb3NoaW1hLXUuYWMuanAvfm0tbWF0L01UL01UMjAwMi9lbXQxOTkzN2FyLmh0bWxcclxuICAgICAqXHJcbiAgICAgKiBBcGkgaW5zcGlyZWQgYnkgaHR0cDovL2NoYW5jZWpzLmNvbS8jIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFuY2Vqcy9jaGFuY2Vqc1xyXG4gICAgICovXHJcbiAgICB2YXIgUmFuZG9tID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiBubyBzZWVkIGlzIHNwZWNpZmllZCwgdGhlIERhdGUubm93KCkgaXMgdXNlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIFJhbmRvbShzZWVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VlZCA9IHNlZWQ7XHJcbiAgICAgICAgICAgIC8vIFNlcGFyYXRpb24gcG9pbnQgb2Ygb25lIG9uZSB3b3JkLCB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gdGhlIGxvd2VyIGJpdG1hc2sgMCA8PSByIDw9IHctMVxyXG4gICAgICAgICAgICB0aGlzLl9sb3dlck1hc2sgPSAweDdGRkZGRkZGOyAvLyAzMSBiaXRzIHNhbWUgYXMgX3JcclxuICAgICAgICAgICAgdGhpcy5fdXBwZXJNYXNrID0gMHg4MDAwMDAwMDsgLy8gMzQgaGlnaCBiaXRzXHJcbiAgICAgICAgICAgIC8vIFdvcmQgc2l6ZSwgNjQgYml0c1xyXG4gICAgICAgICAgICB0aGlzLl93ID0gMzI7XHJcbiAgICAgICAgICAgIC8vIERlZ3JlZSBvZiByZWN1cnJhbmNlXHJcbiAgICAgICAgICAgIHRoaXMuX24gPSA2MjQ7XHJcbiAgICAgICAgICAgIC8vIE1pZGRsZSB3b3JkLCBhbiBvZmZzZXQgdXNlZCBpbiB0aGUgcmVjdXJyYW5jZSBkZWZpbmluZyB0aGUgc2VyaWVzIHgsIDE8PW08blxyXG4gICAgICAgICAgICB0aGlzLl9tID0gMzk3O1xyXG4gICAgICAgICAgICAvLyBjb2VmZmljaWVudHMgb2YgdGVoIHJhdGlvbmFsIG5vcm1hbCBmb3JtIHR3aXN0IG1hdHJpeFxyXG4gICAgICAgICAgICB0aGlzLl9hID0gMHg5OTA4QjBERjtcclxuICAgICAgICAgICAgLy8gdGVtcGVyaW5nIGJpdCBzaGlmdHMgYW5kIG1hc2tzXHJcbiAgICAgICAgICAgIHRoaXMuX3UgPSAxMTtcclxuICAgICAgICAgICAgdGhpcy5fcyA9IDc7XHJcbiAgICAgICAgICAgIHRoaXMuX2IgPSAweDlkMmM1NjgwO1xyXG4gICAgICAgICAgICB0aGlzLl90ID0gMTU7XHJcbiAgICAgICAgICAgIHRoaXMuX2MgPSAweGVmYzYwMDAwO1xyXG4gICAgICAgICAgICB0aGlzLl9sID0gMTg7XHJcbiAgICAgICAgICAgIHRoaXMuX2YgPSAxODEyNDMzMjUzO1xyXG4gICAgICAgICAgICB0aGlzLl9tdCA9IG5ldyBBcnJheSh0aGlzLl9uKTtcclxuICAgICAgICAgICAgLy8gbmVlZCB0byBtYXNrIHRvIHN1cHBvcnQgaGlnaGVyIGJpdCBtYWNoaW5lc1xyXG4gICAgICAgICAgICB0aGlzLl9tdFswXSA9IChzZWVkIHx8IERhdGUubm93KCkpID4+PiAwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMuX247IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHMgPSB0aGlzLl9tdFtpIC0gMV0gXiAodGhpcy5fbXRbaSAtIDFdID4+PiAodGhpcy5fdyAtIDIpKTtcclxuICAgICAgICAgICAgICAgIC8vIG51bWJlcnMgYXJlIGJpZ2dlciB0aGFuIHRoZSBKUyBtYXggc2FmZSBpbnQsIGFkZCBpbiAxNi1iaXQgY2h1bmtzIHRvIHByZXZlbnQgSUVFRSByb3VuZGluZyBlcnJvcnMgb24gaGlnaCBiaXRzICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tdFtpXSA9ICgoKHRoaXMuX2YgKiAoKHMgJiAweEZGRkYwMDAwKSA+Pj4gMTYpKSA8PCAxNikgKyAodGhpcy5fZiAqIChzICYgMHhGRkZGKSkgKyBpKSA+Pj4gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9pbmRleCA9IHRoaXMuX247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFwcGx5IHRoZSB0d2lzdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmRvbS5wcm90b3R5cGUuX3R3aXN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbWFnMDEgPSBbMHgwLCB0aGlzLl9hXTtcclxuICAgICAgICAgICAgdmFyIHkgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX24gLSB0aGlzLl9tOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHkgPSAodGhpcy5fbXRbaV0gJiB0aGlzLl91cHBlck1hc2spIHwgKHRoaXMuX210W2kgKyAxXSAmIHRoaXMuX2xvd2VyTWFzayk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tdFtpXSA9IHRoaXMuX210W2kgKyB0aGlzLl9tXSBeICh5ID4+PiAxKSBeIG1hZzAxW3kgJiAweDFdICYgQklUTUFTSzMyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoOyBpIDwgdGhpcy5fbiAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgeSA9ICh0aGlzLl9tdFtpXSAmIHRoaXMuX3VwcGVyTWFzaykgfCAodGhpcy5fbXRbaSArIDFdICYgdGhpcy5fbG93ZXJNYXNrKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX210W2ldID0gdGhpcy5fbXRbaSArICh0aGlzLl9tIC0gdGhpcy5fbildIF4gKHkgPj4+IDEpIF4gbWFnMDFbeSAmIDB4MV0gJiBCSVRNQVNLMzI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgeSA9ICh0aGlzLl9tdFt0aGlzLl9uIC0gMV0gJiB0aGlzLl91cHBlck1hc2spIHwgKHRoaXMuX210WzBdICYgdGhpcy5fbG93ZXJNYXNrKTtcclxuICAgICAgICAgICAgdGhpcy5fbXRbdGhpcy5fbiAtIDFdID0gdGhpcy5fbXRbdGhpcy5fbSAtIDFdIF4gKHkgPj4+IDEpIF4gbWFnMDFbeSAmIDB4MV0gJiBCSVRNQVNLMzI7XHJcbiAgICAgICAgICAgIHRoaXMuX2luZGV4ID0gMDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybiBuZXh0IDMyIGJpdCBpbnRlZ2VyIG51bWJlciBpbiBzZXF1ZW5jZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmRvbS5wcm90b3R5cGUubmV4dEludCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2luZGV4ID49IHRoaXMuX24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3R3aXN0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHkgPSB0aGlzLl9tdFt0aGlzLl9pbmRleCsrXTtcclxuICAgICAgICAgICAgeSBePSB5ID4+PiB0aGlzLl91O1xyXG4gICAgICAgICAgICB5IF49ICgoeSA8PCB0aGlzLl9zKSAmIHRoaXMuX2IpO1xyXG4gICAgICAgICAgICB5IF49ICgoeSA8PCB0aGlzLl90KSAmIHRoaXMuX2MpO1xyXG4gICAgICAgICAgICB5IF49ICh5ID4+PiB0aGlzLl9sKTtcclxuICAgICAgICAgICAgcmV0dXJuIHkgPj4+IDA7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm4gYSByYW5kb20gZmxvYXRpbmcgcG9pbnQgbnVtYmVyIGJldHdlZW4gWzAsIDEpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFuZG9tLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uZXh0SW50KCkgKiAoMS4wIC8gNDI5NDk2NzI5Ni4wKTsgLy8gZGl2aWRlZCBieSAyXjMyXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm4gYSByYW5kb20gZmxvYXRpbmcgcG9pbnQgaW4gcmFuZ2UgW21pbiwgbWF4KSBtaW4gaXMgaW5jbHVkZWQsIG1heCBpcyBub3QgaW5jbHVkZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5kb20ucHJvdG90eXBlLmZsb2F0aW5nID0gZnVuY3Rpb24gKG1pbiwgbWF4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAobWF4IC0gbWluKSAqIHRoaXMubmV4dCgpICsgbWluO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJuIGEgcmFuZG9tIGludGVnZXIgaW4gcmFuZ2UgW21pbiwgbWF4XSBtaW4gaXMgaW5jbHVkZWQsIG1heCBpcyBpbmNsdWRlZC5cclxuICAgICAgICAgKiBJbXBsZW1lbnRlZCB3aXRoIHJlamVjdGlvbiBzYW1wbGluZywgc2VlIGh0dHBzOi8vbWVkaXVtLmNvbS9AYmV0YWJsZS90aWZ1LWJ5LXVzaW5nLW1hdGgtcmFuZG9tLWYxYzMwOGM0ZmQ5ZCMuaTEzdGRpdTVhXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFuZG9tLnByb3RvdHlwZS5pbnRlZ2VyID0gZnVuY3Rpb24gKG1pbiwgbWF4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKChtYXggLSBtaW4gKyAxKSAqIHRoaXMubmV4dCgpICsgbWluKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBvciBmYWxzZSByYW5kb21seSB3aXRoIDUwLzUwIG9kZHMgYnkgZGVmYXVsdC5cclxuICAgICAgICAgKiBCeSBkZWZhdWx0IHRoZSBsaWtlbGlob29kIG9mIHJldHVybmluZyBhIHRydWUgaXMgLjUgKDUwJSkuXHJcbiAgICAgICAgICogQHBhcmFtIGxpa2VsaWhvb2QgdGFrZXMgdmFsdWVzIGJldHdlZW4gWzAsIDFdXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFuZG9tLnByb3RvdHlwZS5ib29sID0gZnVuY3Rpb24gKGxpa2VsaWhvb2QpIHtcclxuICAgICAgICAgICAgaWYgKGxpa2VsaWhvb2QgPT09IHZvaWQgMCkgeyBsaWtlbGlob29kID0gLjU7IH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dCgpIDw9IGxpa2VsaWhvb2Q7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIG9uZSBlbGVtZW50IGZyb20gYW4gYXJyYXkgYXQgcmFuZG9tXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFuZG9tLnByb3RvdHlwZS5waWNrT25lID0gZnVuY3Rpb24gKGFycmF5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcnJheVt0aGlzLmludGVnZXIoMCwgYXJyYXkubGVuZ3RoIC0gMSldO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIG5ldyBhcnJheSByYW5kb20gcGlja2luZyBlbGVtZW50cyBmcm9tIHRoZSBvcmlnaW5hbFxyXG4gICAgICAgICAqIEBwYXJhbSBhcnJheSBPcmlnaW5hbCBhcnJheSB0byBwaWNrIGZyb21cclxuICAgICAgICAgKiBAcGFyYW0gbnVtUGlja3MgY2FuIGJlIGFueSBwb3NpdGl2ZSBudW1iZXJcclxuICAgICAgICAgKiBAcGFyYW0gYWxsb3dEdXBsaWNhdGVzIGluZGljYXRlcyB3aGV0aGVyIHRoZSByZXR1cm5lZCBzZXQgaXMgYWxsb3dlZCBkdXBsaWNhdGVzIChpdCBkb2VzIG5vdCBtZWFuIHRoZXJlIHdpbGwgYWx3YXlzIGJlIGR1cGxpY2F0ZXNcclxuICAgICAgICAgKiBqdXN0IHRoYXQgaXQgaXMgcG9zc2libGUpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFuZG9tLnByb3RvdHlwZS5waWNrU2V0ID0gZnVuY3Rpb24gKGFycmF5LCBudW1QaWNrcywgYWxsb3dEdXBsaWNhdGVzKSB7XHJcbiAgICAgICAgICAgIGlmIChhbGxvd0R1cGxpY2F0ZXMgPT09IHZvaWQgMCkgeyBhbGxvd0R1cGxpY2F0ZXMgPSBmYWxzZTsgfVxyXG4gICAgICAgICAgICBpZiAoYWxsb3dEdXBsaWNhdGVzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGlja1NldFdpdGhEdXBsaWNhdGVzKGFycmF5LCBudW1QaWNrcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGlja1NldFdpdGhvdXREdXBsaWNhdGVzKGFycmF5LCBudW1QaWNrcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBuZXcgYXJyYXkgcmFuZG9tbHkgcGlja2luZyBlbGVtZW50cyBpbiB0aGUgb3JpZ2luYWwgKG5vdCByZXVzZWQpXHJcbiAgICAgICAgICogQHBhcmFtIG51bVBpY2tzIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGFycmF5LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmRvbS5wcm90b3R5cGUuX3BpY2tTZXRXaXRob3V0RHVwbGljYXRlcyA9IGZ1bmN0aW9uIChhcnJheSwgbnVtUGlja3MpIHtcclxuICAgICAgICAgICAgaWYgKG51bVBpY2tzID4gYXJyYXkubGVuZ3RoIHx8IG51bVBpY2tzIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG51bWJlciBvZiBlbGVtZW50cyB0byBwaWNrLCBtdXN0IHBpY2sgYSB2YWx1ZSAwIDwgbiA8PSBsZW5ndGgnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobnVtUGlja3MgPT09IGFycmF5Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkobnVtUGlja3MpO1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudFBpY2sgPSAwO1xyXG4gICAgICAgICAgICB2YXIgdGVtcEFycmF5ID0gYXJyYXkuc2xpY2UoMCk7XHJcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50UGljayA8IG51bVBpY2tzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmludGVnZXIoMCwgdGVtcEFycmF5Lmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0W2N1cnJlbnRQaWNrKytdID0gdGVtcEFycmF5W2luZGV4XTtcclxuICAgICAgICAgICAgICAgIHRlbXBBcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgbmV3IGFycmF5IHJhbmRvbSBwaWNraW5nIGVsZW1lbnRzIGZyb20gdGhlIG9yaWdpbmFsIGFsbG93aW5nIGR1cGxpY2F0ZXNcclxuICAgICAgICAgKiBAcGFyYW0gbnVtUGlja3MgY2FuIGJlIGFueSBwb3NpdGl2ZSBudW1iZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5kb20ucHJvdG90eXBlLl9waWNrU2V0V2l0aER1cGxpY2F0ZXMgPSBmdW5jdGlvbiAoYXJyYXksIG51bVBpY2tzKSB7XHJcbiAgICAgICAgICAgIC8vIFR5cGVzY3JpcHQgbnVtYmVycyBhcmUgYWxsIGZsb2F0aW5nIHBvaW50LCBzbyBkbyB3ZSBhZGQgY2hlY2sgZm9yIGludD8gKG9yIGZsb29yIHRoZSBpbnB1dD8pXHJcbiAgICAgICAgICAgIGlmIChudW1QaWNrcyA8IDApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBudW1iZXIgb2YgZWxlbWVudHMgdG8gcGljaywgbXVzdCBwaWNrIGEgdmFsdWUgMCA8PSBuIDwgTUFYX0lOVCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkobnVtUGlja3MpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVBpY2tzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMucGlja09uZShhcnJheSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgbmV3IGFycmF5IHRoYXQgaGFzIGl0cyBlbGVtZW50cyBzaHVmZmxlZC4gVXNpbmcgdGhlIEZpc2hlci9ZYXRlcyBtZXRob2RcclxuICAgICAgICAgKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXIlRTIlODAlOTNZYXRlc19zaHVmZmxlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFuZG9tLnByb3RvdHlwZS5zaHVmZmxlID0gZnVuY3Rpb24gKGFycmF5KSB7XHJcbiAgICAgICAgICAgIHZhciB0ZW1wQXJyYXkgPSBhcnJheS5zbGljZSgwKTtcclxuICAgICAgICAgICAgdmFyIHN3YXAgPSBudWxsO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlbXBBcnJheS5sZW5ndGggLSAyOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciByYW5kb21JbmRleCA9IHRoaXMuaW50ZWdlcihpLCB0ZW1wQXJyYXkubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgICAgICBzd2FwID0gdGVtcEFycmF5W2ldO1xyXG4gICAgICAgICAgICAgICAgdGVtcEFycmF5W2ldID0gdGVtcEFycmF5W3JhbmRvbUluZGV4XTtcclxuICAgICAgICAgICAgICAgIHRlbXBBcnJheVtyYW5kb21JbmRleF0gPSBzd2FwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0ZW1wQXJyYXk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZW5lcmF0ZSBhIGxpc3Qgb2YgcmFuZG9tIGludGVnZXIgbnVtYmVyc1xyXG4gICAgICAgICAqIEBwYXJhbSBsZW5ndGggdGhlIGxlbmd0aCBvZiB0aGUgZmluYWwgYXJyYXlcclxuICAgICAgICAgKiBAcGFyYW0gbWluIHRoZSBtaW5pbXVtIGludGVnZXIgbnVtYmVyIHRvIGdlbmVyYXRlIGluY2x1c2l2ZVxyXG4gICAgICAgICAqIEBwYXJhbSBtYXggdGhlIG1heGltdW0gaW50ZWdlciBudW1iZXIgdG8gZ2VuZXJhdGUgaW5jbHVzaXZlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFuZG9tLnByb3RvdHlwZS5yYW5nZSA9IGZ1bmN0aW9uIChsZW5ndGgsIG1pbiwgbWF4KSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkobGVuZ3RoKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gdGhpcy5pbnRlZ2VyKG1pbiwgbWF4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIGEgZDQgZGljZSByb2xsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFuZG9tLnByb3RvdHlwZS5kNCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZWdlcigxLCA0KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiBhIGQ2IGRpY2Ugcm9sbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmRvbS5wcm90b3R5cGUuZDYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVnZXIoMSwgNik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYSBkOCBkaWNlIHJvbGxcclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5kb20ucHJvdG90eXBlLmQ4ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlZ2VyKDEsIDgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIGEgZDEwIGRpY2Ugcm9sbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmRvbS5wcm90b3R5cGUuZDEwID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlZ2VyKDEsIDEwKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiBhIGQxMiBkaWNlIHJvbGxcclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5kb20ucHJvdG90eXBlLmQxMiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZWdlcigxLCAxMik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYSBkMjAgZGljZSByb2xsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFuZG9tLnByb3RvdHlwZS5kMjAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVnZXIoMSwgMjApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFJhbmRvbTtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLlJhbmRvbSA9IFJhbmRvbTtcclxufSk7XHJcbmRlZmluZShcIkNvbGxpc2lvbi9TaWRlXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEFuIGVudW0gdGhhdCBkZXNjcmliZXMgdGhlIHNpZGVzIG9mIGFuIEFjdG9yIGZvciBjb2xsaXNpb25cclxuICAgICAqL1xyXG4gICAgdmFyIFNpZGU7XHJcbiAgICAoZnVuY3Rpb24gKFNpZGUpIHtcclxuICAgICAgICBTaWRlW1NpZGVbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcclxuICAgICAgICBTaWRlW1NpZGVbXCJUb3BcIl0gPSAxXSA9IFwiVG9wXCI7XHJcbiAgICAgICAgU2lkZVtTaWRlW1wiQm90dG9tXCJdID0gMl0gPSBcIkJvdHRvbVwiO1xyXG4gICAgICAgIFNpZGVbU2lkZVtcIkxlZnRcIl0gPSAzXSA9IFwiTGVmdFwiO1xyXG4gICAgICAgIFNpZGVbU2lkZVtcIlJpZ2h0XCJdID0gNF0gPSBcIlJpZ2h0XCI7XHJcbiAgICB9KShTaWRlID0gZXhwb3J0cy5TaWRlIHx8IChleHBvcnRzLlNpZGUgPSB7fSkpO1xyXG59KTtcclxuZGVmaW5lKFwiVXRpbC9VdGlsXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiQWxnZWJyYVwiLCBcIk1hdGgvUmFuZG9tXCIsIFwiQ29sbGlzaW9uL1NpZGVcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBBbGdlYnJhXzIsIFJhbmRvbV8xLCBTaWRlXzEpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUd28gUEkgY29uc3RhbnRcclxuICAgICAqL1xyXG4gICAgZXhwb3J0cy5Ud29QSSA9IE1hdGguUEkgKiAyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBNZXJnZXMgb25lIG9yIG1vcmUgb2JqZWN0cyBpbnRvIGEgc2luZ2xlIHRhcmdldCBvYmplY3RcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBNZXJnZWQgb2JqZWN0IHdpdGggcHJvcGVydGllcyBmcm9tIG90aGVyIG9iamVjdHNcclxuICAgICAqIEBjcmVkaXQgaHR0cHM6Ly9nb21ha2V0aGluZ3MuY29tL3ZhbmlsbGEtamF2YXNjcmlwdC12ZXJzaW9uLW9mLWpxdWVyeS1leHRlbmQvXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGV4dGVuZCgpIHtcclxuICAgICAgICB2YXIgZXh0ZW5kZWQgPSB7fTtcclxuICAgICAgICB2YXIgZGVlcCA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcclxuICAgICAgICAvLyBDaGVjayBpZiBhIGRlZXAgbWVyZ2VcclxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZ3VtZW50c1swXSkgPT09ICdbb2JqZWN0IEJvb2xlYW5dJykge1xyXG4gICAgICAgICAgICBkZWVwID0gYXJndW1lbnRzWzBdO1xyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE1lcmdlIHRoZSBvYmplY3QgaW50byB0aGUgZXh0ZW5kZWQgb2JqZWN0XHJcbiAgICAgICAgdmFyIGFzc2lnbkV4aXN0cyA9IHR5cGVvZiBPYmplY3QuYXNzaWduID09PSAnZnVuY3Rpb24nO1xyXG4gICAgICAgIHZhciBtZXJnZSA9IG51bGw7XHJcbiAgICAgICAgaWYgKCFhc3NpZ25FeGlzdHMpIHtcclxuICAgICAgICAgICAgbWVyZ2UgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBkZWVwIG1lcmdlIGFuZCBwcm9wZXJ0eSBpcyBhbiBvYmplY3QsIG1lcmdlIHByb3BlcnRpZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZXAgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9ialtwcm9wXSkgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbmRlZFtwcm9wXSA9IGV4dGVuZCh0cnVlLCBleHRlbmRlZFtwcm9wXSwgb2JqW3Byb3BdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuZGVkW3Byb3BdID0gb2JqW3Byb3BdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbWVyZ2UgPSBPYmplY3QuYXNzaWduO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBMb29wIHRocm91Z2ggZWFjaCBvYmplY3QgYW5kIGNvbmR1Y3QgYSBtZXJnZVxyXG4gICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIG9iaiA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgaWYgKCFhc3NpZ25FeGlzdHMpIHtcclxuICAgICAgICAgICAgICAgIG1lcmdlKG9iaik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtZXJnZShleHRlbmRlZCwgb2JqKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXh0ZW5kZWQ7XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLmV4dGVuZCA9IGV4dGVuZDtcclxuICAgIGZ1bmN0aW9uIGJhc2U2NEVuY29kZShpbnB1dFN0cikge1xyXG4gICAgICAgIHZhciBiNjQgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xyXG4gICAgICAgIHZhciBvdXRwdXRTdHIgPSAnJztcclxuICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgd2hpbGUgKGkgPCBpbnB1dFN0ci5sZW5ndGgpIHtcclxuICAgICAgICAgICAgLy9hbGwgdGhyZWUgXCImIDB4ZmZcIiBhZGRlZCBiZWxvdyBhcmUgdGhlcmUgdG8gZml4IGEga25vd24gYnVnXHJcbiAgICAgICAgICAgIC8vd2l0aCBieXRlcyByZXR1cm5lZCBieSB4aHIucmVzcG9uc2VUZXh0XHJcbiAgICAgICAgICAgIHZhciBieXRlMSA9IGlucHV0U3RyLmNoYXJDb2RlQXQoaSsrKSAmIDB4ZmY7XHJcbiAgICAgICAgICAgIHZhciBieXRlMiA9IGlucHV0U3RyLmNoYXJDb2RlQXQoaSsrKSAmIDB4ZmY7XHJcbiAgICAgICAgICAgIHZhciBieXRlMyA9IGlucHV0U3RyLmNoYXJDb2RlQXQoaSsrKSAmIDB4ZmY7XHJcbiAgICAgICAgICAgIHZhciBlbmMxID0gYnl0ZTEgPj4gMjtcclxuICAgICAgICAgICAgdmFyIGVuYzIgPSAoKGJ5dGUxICYgMykgPDwgNCkgfCAoYnl0ZTIgPj4gNCk7XHJcbiAgICAgICAgICAgIHZhciBlbmMzLCBlbmM0O1xyXG4gICAgICAgICAgICBpZiAoaXNOYU4oYnl0ZTIpKSB7XHJcbiAgICAgICAgICAgICAgICBlbmMzID0gZW5jNCA9IDY0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZW5jMyA9ICgoYnl0ZTIgJiAxNSkgPDwgMikgfCAoYnl0ZTMgPj4gNik7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4oYnl0ZTMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5jNCA9IDY0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5jNCA9IGJ5dGUzICYgNjM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3V0cHV0U3RyICs9IGI2NC5jaGFyQXQoZW5jMSkgKyBiNjQuY2hhckF0KGVuYzIpICsgYjY0LmNoYXJBdChlbmMzKSArIGI2NC5jaGFyQXQoZW5jNCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXRwdXRTdHI7XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLmJhc2U2NEVuY29kZSA9IGJhc2U2NEVuY29kZTtcclxuICAgIC8qKlxyXG4gICAgICogQ2xhbXBzIGEgdmFsdWUgYmV0d2VlbiBhIG1pbiBhbmQgbWF4IGluY2x1c2l2ZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjbGFtcCh2YWwsIG1pbiwgbWF4KSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG1pbiwgdmFsKSwgbWF4KTtcclxuICAgIH1cclxuICAgIGV4cG9ydHMuY2xhbXAgPSBjbGFtcDtcclxuICAgIGZ1bmN0aW9uIHJhbmRvbUluUmFuZ2UobWluLCBtYXgsIHJhbmRvbSkge1xyXG4gICAgICAgIGlmIChyYW5kb20gPT09IHZvaWQgMCkgeyByYW5kb20gPSBuZXcgUmFuZG9tXzEuUmFuZG9tKCk7IH1cclxuICAgICAgICByZXR1cm4gcmFuZG9tID8gcmFuZG9tLmZsb2F0aW5nKG1pbiwgbWF4KSA6IG1pbiArIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKTtcclxuICAgIH1cclxuICAgIGV4cG9ydHMucmFuZG9tSW5SYW5nZSA9IHJhbmRvbUluUmFuZ2U7XHJcbiAgICBmdW5jdGlvbiByYW5kb21JbnRJblJhbmdlKG1pbiwgbWF4LCByYW5kb20pIHtcclxuICAgICAgICBpZiAocmFuZG9tID09PSB2b2lkIDApIHsgcmFuZG9tID0gbmV3IFJhbmRvbV8xLlJhbmRvbSgpOyB9XHJcbiAgICAgICAgcmV0dXJuIHJhbmRvbSA/IHJhbmRvbS5pbnRlZ2VyKG1pbiwgbWF4KSA6IE1hdGgucm91bmQocmFuZG9tSW5SYW5nZShtaW4sIG1heCkpO1xyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5yYW5kb21JbnRJblJhbmdlID0gcmFuZG9tSW50SW5SYW5nZTtcclxuICAgIGZ1bmN0aW9uIGNhbm9uaWNhbGl6ZUFuZ2xlKGFuZ2xlKSB7XHJcbiAgICAgICAgdmFyIHRtcEFuZ2xlID0gYW5nbGU7XHJcbiAgICAgICAgaWYgKGFuZ2xlID4gZXhwb3J0cy5Ud29QSSkge1xyXG4gICAgICAgICAgICB3aGlsZSAodG1wQW5nbGUgPiBleHBvcnRzLlR3b1BJKSB7XHJcbiAgICAgICAgICAgICAgICB0bXBBbmdsZSAtPSBleHBvcnRzLlR3b1BJO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhbmdsZSA8IDApIHtcclxuICAgICAgICAgICAgd2hpbGUgKHRtcEFuZ2xlIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgdG1wQW5nbGUgKz0gZXhwb3J0cy5Ud29QSTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdG1wQW5nbGU7XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLmNhbm9uaWNhbGl6ZUFuZ2xlID0gY2Fub25pY2FsaXplQW5nbGU7XHJcbiAgICBmdW5jdGlvbiB0b0RlZ3JlZXMocmFkaWFucykge1xyXG4gICAgICAgIHJldHVybiAxODAgLyBNYXRoLlBJICogcmFkaWFucztcclxuICAgIH1cclxuICAgIGV4cG9ydHMudG9EZWdyZWVzID0gdG9EZWdyZWVzO1xyXG4gICAgZnVuY3Rpb24gdG9SYWRpYW5zKGRlZ3JlZXMpIHtcclxuICAgICAgICByZXR1cm4gZGVncmVlcyAvIDE4MCAqIE1hdGguUEk7XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLnRvUmFkaWFucyA9IHRvUmFkaWFucztcclxuICAgIGZ1bmN0aW9uIGdldFBvc2l0aW9uKGVsKSB7XHJcbiAgICAgICAgdmFyIG9MZWZ0ID0gMCwgb1RvcCA9IDA7XHJcbiAgICAgICAgdmFyIGNhbGNPZmZzZXRMZWZ0ID0gZnVuY3Rpb24gKHBhcmVudCkge1xyXG4gICAgICAgICAgICBvTGVmdCArPSBwYXJlbnQub2Zmc2V0TGVmdDtcclxuICAgICAgICAgICAgaWYgKHBhcmVudC5vZmZzZXRQYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGNhbGNPZmZzZXRMZWZ0KHBhcmVudC5vZmZzZXRQYXJlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgY2FsY09mZnNldFRvcCA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgb1RvcCArPSBwYXJlbnQub2Zmc2V0VG9wO1xyXG4gICAgICAgICAgICBpZiAocGFyZW50Lm9mZnNldFBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgY2FsY09mZnNldFRvcChwYXJlbnQub2Zmc2V0UGFyZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY2FsY09mZnNldExlZnQoZWwpO1xyXG4gICAgICAgIGNhbGNPZmZzZXRUb3AoZWwpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQWxnZWJyYV8yLlZlY3RvcihvTGVmdCwgb1RvcCk7XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLmdldFBvc2l0aW9uID0gZ2V0UG9zaXRpb247XHJcbiAgICBmdW5jdGlvbiBhZGRJdGVtVG9BcnJheShpdGVtLCBhcnJheSkge1xyXG4gICAgICAgIGlmIChhcnJheS5pbmRleE9mKGl0ZW0pID09PSAtMSkge1xyXG4gICAgICAgICAgICBhcnJheS5wdXNoKGl0ZW0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5hZGRJdGVtVG9BcnJheSA9IGFkZEl0ZW1Ub0FycmF5O1xyXG4gICAgZnVuY3Rpb24gcmVtb3ZlSXRlbUZyb21BcnJheShpdGVtLCBhcnJheSkge1xyXG4gICAgICAgIHZhciBpbmRleCA9IC0xO1xyXG4gICAgICAgIGlmICgoaW5kZXggPSBhcnJheS5pbmRleE9mKGl0ZW0pKSA+IC0xKSB7XHJcbiAgICAgICAgICAgIGFycmF5LnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLnJlbW92ZUl0ZW1Gcm9tQXJyYXkgPSByZW1vdmVJdGVtRnJvbUFycmF5O1xyXG4gICAgZnVuY3Rpb24gY29udGFpbnMoYXJyYXksIG9iaikge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGFycmF5W2ldID09PSBvYmopIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGV4cG9ydHMuY29udGFpbnMgPSBjb250YWlucztcclxuICAgIGZ1bmN0aW9uIGdldE9wcG9zaXRlU2lkZShzaWRlKSB7XHJcbiAgICAgICAgaWYgKHNpZGUgPT09IFNpZGVfMS5TaWRlLlRvcCkge1xyXG4gICAgICAgICAgICByZXR1cm4gU2lkZV8xLlNpZGUuQm90dG9tO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2lkZSA9PT0gU2lkZV8xLlNpZGUuQm90dG9tKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTaWRlXzEuU2lkZS5Ub3A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaWRlID09PSBTaWRlXzEuU2lkZS5MZWZ0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTaWRlXzEuU2lkZS5SaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNpZGUgPT09IFNpZGVfMS5TaWRlLlJpZ2h0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTaWRlXzEuU2lkZS5MZWZ0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gU2lkZV8xLlNpZGUuTm9uZTtcclxuICAgIH1cclxuICAgIGV4cG9ydHMuZ2V0T3Bwb3NpdGVTaWRlID0gZ2V0T3Bwb3NpdGVTaWRlO1xyXG4gICAgZnVuY3Rpb24gZ2V0U2lkZUZyb21WZWN0b3IoZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIGRpcmVjdGlvbnMgPSBbQWxnZWJyYV8yLlZlY3Rvci5MZWZ0LCBBbGdlYnJhXzIuVmVjdG9yLlJpZ2h0LCBBbGdlYnJhXzIuVmVjdG9yLlVwLCBBbGdlYnJhXzIuVmVjdG9yLkRvd25dO1xyXG4gICAgICAgIHZhciBkaXJlY3Rpb25FbnVtID0gW1NpZGVfMS5TaWRlLkxlZnQsIFNpZGVfMS5TaWRlLlJpZ2h0LCBTaWRlXzEuU2lkZS5Ub3AsIFNpZGVfMS5TaWRlLkJvdHRvbV07XHJcbiAgICAgICAgdmFyIG1heCA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgIHZhciBtYXhJbmRleCA9IC0xO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyZWN0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uc1tpXS5kb3QoZGlyZWN0aW9uKSA+IG1heCkge1xyXG4gICAgICAgICAgICAgICAgbWF4ID0gZGlyZWN0aW9uc1tpXS5kb3QoZGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIG1heEluZGV4ID0gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGlyZWN0aW9uRW51bVttYXhJbmRleF07XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLmdldFNpZGVGcm9tVmVjdG9yID0gZ2V0U2lkZUZyb21WZWN0b3I7XHJcbiAgICAvKipcclxuICAgICAqIEV4Y2FsaWJ1cidzIGR5bmFtaWNhbGx5IHJlc2l6aW5nIGNvbGxlY3Rpb25cclxuICAgICAqL1xyXG4gICAgdmFyIENvbGxlY3Rpb24gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBpbml0aWFsU2l6ZSAgSW5pdGlhbCBzaXplIG9mIHRoZSBpbnRlcm5hbCBiYWNraW5nIGFycmF5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gQ29sbGVjdGlvbihpbml0aWFsU2l6ZSkge1xyXG4gICAgICAgICAgICBpZiAoaW5pdGlhbFNpemUgPT09IHZvaWQgMCkgeyBpbml0aWFsU2l6ZSA9IENvbGxlY3Rpb24uRGVmYXVsdFNpemU7IH1cclxuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxBcnJheSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZFBvaW50ZXIgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbEFycmF5ID0gbmV3IEFycmF5KGluaXRpYWxTaXplKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuX3Jlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG5ld1NpemUgPSB0aGlzLl9pbnRlcm5hbEFycmF5Lmxlbmd0aCAqIDI7XHJcbiAgICAgICAgICAgIHZhciBuZXdBcnJheSA9IG5ldyBBcnJheShuZXdTaXplKTtcclxuICAgICAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5jb3VudCgpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIG5ld0FycmF5W2ldID0gdGhpcy5faW50ZXJuYWxBcnJheVtpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5faW50ZXJuYWxBcnJheTtcclxuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxBcnJheSA9IG5ld0FycmF5O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHVzaCBlbGVtZW50cyB0byB0aGUgZW5kIG9mIHRoZSBjb2xsZWN0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9lbmRQb2ludGVyID09PSB0aGlzLl9pbnRlcm5hbEFycmF5Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzaXplKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsQXJyYXlbdGhpcy5fZW5kUG9pbnRlcisrXSA9IGVsZW1lbnQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGVsZW1lbnRzIGZyb20gdGhlIGVuZCBvZiB0aGUgY29sbGVjdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fZW5kUG9pbnRlciA9IHRoaXMuX2VuZFBvaW50ZXIgLSAxIDwgMCA/IDAgOiB0aGlzLl9lbmRQb2ludGVyIC0gMTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsQXJyYXlbdGhpcy5fZW5kUG9pbnRlcl07XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjb3VudCBvZiB0aGUgY29sbGVjdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZW5kUG9pbnRlcjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVtcHRpZXMgdGhlIGNvbGxlY3Rpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fZW5kUG9pbnRlciA9IDA7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBzaXplIG9mIHRoZSBpbnRlcm5hbCBiYWNraW5nIGFycmF5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuaW50ZXJuYWxTaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxBcnJheS5sZW5ndGg7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGFuIGVsZW1lbnQgYXQgYSBzcGVjaWZpYyBpbmRleFxyXG4gICAgICAgICAqIEBwYXJhbSBpbmRleCAgSW5kZXggb2YgZWxlbWVudCB0byByZXRyaWV2ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmVsZW1lbnRBdCA9IGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gdGhpcy5jb3VudCgpKSB7XHJcbiAgICAgICAgICAgICAgICAvL0xvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKCdJbnZhbGlkIHBhcmFtZXRlcjogJyArIGluZGV4KTtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbmRleCAnICsgaW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbEFycmF5W2luZGV4XTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluc2VydHMgYW4gZWxlbWVudCBhdCBhIHNwZWNpZmljIGluZGV4XHJcbiAgICAgICAgICogQHBhcmFtIGluZGV4ICBJbmRleCB0byBpbnNlcnQgdGhlIGVsZW1lbnRcclxuICAgICAgICAgKiBAcGFyYW0gdmFsdWUgIEVsZW1lbnQgdG8gaW5zZXJ0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKGluZGV4LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gdGhpcy5jb3VudCgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNpemUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxBcnJheVtpbmRleF0gPSB2YWx1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgYW4gZWxlbWVudCBhdCBhIHNwZWNpZmljIGluZGV4XHJcbiAgICAgICAgICogQHBhcmFtIGluZGV4ICBJbmRleCBvZiBlbGVtZW50IHRvIHJlbW92ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgICAgICB2YXIgY291bnQgPSB0aGlzLmNvdW50KCk7XHJcbiAgICAgICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgLy9Mb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcignSW52YWxpZCBwYXJhbWV0ZXI6ICcgKyBpbmRleCk7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGFyYW1ldGVyICcgKyBpbmRleCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gTyhuKSBTaGlmdFxyXG4gICAgICAgICAgICB2YXIgcmVtb3ZlZCA9IHRoaXMuX2ludGVybmFsQXJyYXlbaW5kZXhdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gaW5kZXg7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcm5hbEFycmF5W2ldID0gdGhpcy5faW50ZXJuYWxBcnJheVtpICsgMV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fZW5kUG9pbnRlci0tO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVtb3ZlZDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgYW4gZWxlbWVudCBieSByZWZlcmVuY2VcclxuICAgICAgICAgKiBAcGFyYW0gZWxlbWVudCAgRWxlbWVudCB0byByZXRyaWV2ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLnJlbW92ZUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9pbnRlcm5hbEFycmF5LmluZGV4T2YoZWxlbWVudCk7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGluZGV4KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBhcnJheSByZXByZXNlbnRpbmcgdGhlIGNvbGxlY3Rpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxBcnJheS5zbGljZSgwLCB0aGlzLl9lbmRQb2ludGVyKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEl0ZXJhdGUgb3ZlciBldmVyeSBlbGVtZW50IGluIHRoZSBjb2xsZWN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIGZ1bmMgIENhbGxiYWNrIHRvIGNhbGwgZm9yIGVhY2ggZWxlbWVudCBwYXNzaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBlbGVtZW50IGFuZCBpdHMgaW5kZXgsIHJldHVybmVkIHZhbHVlcyBhcmUgaWdub3JlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoZnVuYykge1xyXG4gICAgICAgICAgICB2YXIgaSA9IDAsIGNvdW50ID0gdGhpcy5jb3VudCgpO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBmdW5jLmNhbGwodGhpcywgdGhpcy5faW50ZXJuYWxBcnJheVtpXSwgaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE11dGF0ZSBldmVyeSBlbGVtZW50IGluIHRoZSBjb2xsZWN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIGZ1bmMgIENhbGxiYWNrIHRvIGNhbGwgZm9yIGVhY2ggZWxlbWVudCBwYXNzaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBlbGVtZW50IGFuZCBpdHMgaW5kZXgsIGFueSB2YWx1ZXMgcmV0dXJuZWQgbXV0YXRlXHJcbiAgICAgICAgICogdGhlIGNvbGxlY3Rpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoZnVuYykge1xyXG4gICAgICAgICAgICB2YXIgY291bnQgPSB0aGlzLmNvdW50KCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxBcnJheVtpXSA9IGZ1bmMuY2FsbCh0aGlzLCB0aGlzLl9pbnRlcm5hbEFycmF5W2ldLCBpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIENvbGxlY3Rpb247XHJcbiAgICB9KCkpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZhdWx0IGNvbGxlY3Rpb24gc2l6ZVxyXG4gICAgICovXHJcbiAgICBDb2xsZWN0aW9uLkRlZmF1bHRTaXplID0gMjAwO1xyXG4gICAgZXhwb3J0cy5Db2xsZWN0aW9uID0gQ29sbGVjdGlvbjtcclxufSk7XHJcbmRlZmluZShcIkNhbWVyYVwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIlV0aWwvRWFzaW5nRnVuY3Rpb25zXCIsIFwiUHJvbWlzZXNcIiwgXCJBbGdlYnJhXCIsIFwiVXRpbC9VdGlsXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgRWFzaW5nRnVuY3Rpb25zXzEsIFByb21pc2VzXzEsIEFsZ2VicmFfMywgVXRpbF8xKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogQ29udGFpbmVyIHRvIGhvdXNlIGNvbnZlbmllbmNlIHN0cmF0ZWd5IG1ldGhvZHNcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICB2YXIgU3RyYXRlZ3lDb250YWluZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIFN0cmF0ZWd5Q29udGFpbmVyKGNhbWVyYSkge1xyXG4gICAgICAgICAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhbmQgYWRkcyB0aGUgW1tMb2NrQ2FtZXJhVG9BY3RvclN0cmF0ZWd5XV0gb24gdGhlIGN1cnJlbnQgY2FtZXJhLlxyXG4gICAgICAgICAqIEBwYXJhbSBhY3RvciBUaGUgYWN0b3IgdG8gbG9jayB0aGUgY2FtZXJhIHRvXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU3RyYXRlZ3lDb250YWluZXIucHJvdG90eXBlLmxvY2tUb0FjdG9yID0gZnVuY3Rpb24gKGFjdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhLmFkZFN0cmF0ZWd5KG5ldyBMb2NrQ2FtZXJhVG9BY3RvclN0cmF0ZWd5KGFjdG9yKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGFuZCBhZGRzIHRoZSBbW0xvY2tDYW1lcmFUb0FjdG9yQXhpc1N0cmF0ZWd5XV0gb24gdGhlIGN1cnJlbnQgY2FtZXJhXHJcbiAgICAgICAgICogQHBhcmFtIGFjdG9yIFRoZSBhY3RvciB0byBsb2NrIHRoZSBjYW1lcmEgdG9cclxuICAgICAgICAgKiBAcGFyYW0gYXhpcyBUaGUgYXhpcyB0byBmb2xsb3cgdGhlIGFjdG9yIG9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU3RyYXRlZ3lDb250YWluZXIucHJvdG90eXBlLmxvY2tUb0FjdG9yQXhpcyA9IGZ1bmN0aW9uIChhY3RvciwgYXhpcykge1xyXG4gICAgICAgICAgICB0aGlzLmNhbWVyYS5hZGRTdHJhdGVneShuZXcgTG9ja0NhbWVyYVRvQWN0b3JBeGlzU3RyYXRlZ3koYWN0b3IsIGF4aXMpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYW5kIGFkZHMgdGhlIFtbRWxhc3RpY1RvQWN0b3JTdHJhdGVneV1dIG9uIHRoZSBjdXJyZW50IGNhbWVyYVxyXG4gICAgICAgICAqIElmIGNhbWVyYUVsYXN0aWNpdHkgPCBjYW1lcmFGcmljdGlvbiA8IDEuMCwgdGhlIGJlaGF2aW9yIHdpbGwgYmUgYSBkYW1wZW5lZCBzcHJpbmcgdGhhdCB3aWxsIHNsb3dseSBlbmQgYXQgdGhlIHRhcmdldCB3aXRob3V0IGJvdW5jaW5nXHJcbiAgICAgICAgICogSWYgY2FtZXJhRnJpY3Rpb24gPCBjYW1lcmFFbGFzdGljaXR5IDwgMS4wLCB0aGUgYmVoYXZpb3Igd2lsbCBiZSBhbiBvc2NpbGxhdGlvbmcgc3ByaW5nIHRoYXQgd2lsbCBvdmVyXHJcbiAgICAgICAgICogY29ycmVjdCBhbmQgYm91bmNlIGFyb3VuZCB0aGUgdGFyZ2V0XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRhcmdldCBhY3RvciB0byBlbGFzdGljYWxseSBmb2xsb3dcclxuICAgICAgICAgKiBAcGFyYW0gY2FtZXJhRWxhc3RpY2l0eSBbMCAtIDEuMF0gVGhlIGhpZ2hlciB0aGUgZWxhc3RpY2l0eSB0aGUgbW9yZSBmb3JjZSB0aGF0IHdpbGwgZHJpdmUgdGhlIGNhbWVyYSB0b3dhcmRzIHRoZSB0YXJnZXRcclxuICAgICAgICAgKiBAcGFyYW0gY2FtZXJhRnJpY3Rpb24gWzAgLSAxLjBdIFRoZSBoaWdoZXIgdGhlIGZyaWN0aW9uIHRoZSBtb3JlIHRoYXQgdGhlIGNhbWVyYSB3aWxsIHJlc2lzdCBtb3Rpb24gdG93YXJkcyB0aGUgdGFyZ2V0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU3RyYXRlZ3lDb250YWluZXIucHJvdG90eXBlLmVsYXN0aWNUb0FjdG9yID0gZnVuY3Rpb24gKGFjdG9yLCBjYW1lcmFFbGFzdGljaXR5LCBjYW1lcmFGcmljdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLmNhbWVyYS5hZGRTdHJhdGVneShuZXcgRWxhc3RpY1RvQWN0b3JTdHJhdGVneShhY3RvciwgY2FtZXJhRWxhc3RpY2l0eSwgY2FtZXJhRnJpY3Rpb24pKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYW5kIGFkZHMgdGhlIFtbUmFkaXVzQXJvdW5kQWN0b3JTdHJhdGVneV1dIG9uIHRoZSBjdXJyZW50IGNhbWVyYVxyXG4gICAgICAgICAqIEBwYXJhbSB0YXJnZXQgVGFyZ2V0IGFjdG9yIHRvIGZvbGxvdyB3aGVuIGl0IGlzIFwicmFkaXVzXCIgcGl4ZWxzIGF3YXlcclxuICAgICAgICAgKiBAcGFyYW0gcmFkaXVzIE51bWJlciBvZiBwaXhlbHMgYXdheSBiZWZvcmUgdGhlIGNhbWVyYSB3aWxsIGZvbGxvd1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFN0cmF0ZWd5Q29udGFpbmVyLnByb3RvdHlwZS5yYWRpdXNBcm91bmRBY3RvciA9IGZ1bmN0aW9uIChhY3RvciwgcmFkaXVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhLmFkZFN0cmF0ZWd5KG5ldyBSYWRpdXNBcm91bmRBY3RvclN0cmF0ZWd5KGFjdG9yLCByYWRpdXMpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBTdHJhdGVneUNvbnRhaW5lcjtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLlN0cmF0ZWd5Q29udGFpbmVyID0gU3RyYXRlZ3lDb250YWluZXI7XHJcbiAgICAvKipcclxuICAgICAqIENhbWVyYSBheGlzIGVudW1cclxuICAgICAqL1xyXG4gICAgdmFyIEF4aXM7XHJcbiAgICAoZnVuY3Rpb24gKEF4aXMpIHtcclxuICAgICAgICBBeGlzW0F4aXNbXCJYXCJdID0gMF0gPSBcIlhcIjtcclxuICAgICAgICBBeGlzW0F4aXNbXCJZXCJdID0gMV0gPSBcIllcIjtcclxuICAgIH0pKEF4aXMgPSBleHBvcnRzLkF4aXMgfHwgKGV4cG9ydHMuQXhpcyA9IHt9KSk7XHJcbiAgICAvKipcclxuICAgICAqIExvY2sgYSBjYW1lcmEgdG8gdGhlIGV4YWN0IHgveSBwb3N0aXRpb24gb2YgYW4gYWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHZhciBMb2NrQ2FtZXJhVG9BY3RvclN0cmF0ZWd5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBMb2NrQ2FtZXJhVG9BY3RvclN0cmF0ZWd5KHRhcmdldCkge1xyXG4gICAgICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgdGhpcy5hY3Rpb24gPSBmdW5jdGlvbiAodGFyZ2V0LCBfY2FtLCBfZW5nLCBfZGVsdGEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjZW50ZXIgPSB0YXJnZXQuZ2V0Q2VudGVyKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2VudGVyO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gTG9ja0NhbWVyYVRvQWN0b3JTdHJhdGVneTtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkxvY2tDYW1lcmFUb0FjdG9yU3RyYXRlZ3kgPSBMb2NrQ2FtZXJhVG9BY3RvclN0cmF0ZWd5O1xyXG4gICAgLyoqXHJcbiAgICAgKiBMb2NrIGEgY2FtZXJhIHRvIGEgc3BlY2lmaWMgYXhpcyBhcm91bmQgYW4gYWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHZhciBMb2NrQ2FtZXJhVG9BY3RvckF4aXNTdHJhdGVneSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gTG9ja0NhbWVyYVRvQWN0b3JBeGlzU3RyYXRlZ3kodGFyZ2V0LCBheGlzKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICB0aGlzLmF4aXMgPSBheGlzO1xyXG4gICAgICAgICAgICB0aGlzLmFjdGlvbiA9IGZ1bmN0aW9uICh0YXJnZXQsIGNhbSwgX2VuZywgX2RlbHRhKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2VudGVyID0gdGFyZ2V0LmdldENlbnRlcigpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRGb2N1cyA9IGNhbS5nZXRGb2N1cygpO1xyXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmF4aXMgPT09IEF4aXMuWCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWxnZWJyYV8zLlZlY3RvcihjZW50ZXIueCwgY3VycmVudEZvY3VzLnkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBbGdlYnJhXzMuVmVjdG9yKGN1cnJlbnRGb2N1cy54LCBjZW50ZXIueSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBMb2NrQ2FtZXJhVG9BY3RvckF4aXNTdHJhdGVneTtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkxvY2tDYW1lcmFUb0FjdG9yQXhpc1N0cmF0ZWd5ID0gTG9ja0NhbWVyYVRvQWN0b3JBeGlzU3RyYXRlZ3k7XHJcbiAgICAvKipcclxuICAgICAqIFVzaW5nIFtIb29rJ3MgbGF3XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ib29rZSdzX2xhdyksIGVsYXN0aWNhbGx5IG1vdmUgdGhlIGNhbWVyYSB0b3dhcmRzIHRoZSB0YXJnZXQgYWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHZhciBFbGFzdGljVG9BY3RvclN0cmF0ZWd5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiBjYW1lcmFFbGFzdGljaXR5IDwgY2FtZXJhRnJpY3Rpb24gPCAxLjAsIHRoZSBiZWhhdmlvciB3aWxsIGJlIGEgZGFtcGVuZWQgc3ByaW5nIHRoYXQgd2lsbCBzbG93bHkgZW5kIGF0IHRoZSB0YXJnZXQgd2l0aG91dCBib3VuY2luZ1xyXG4gICAgICAgICAqIElmIGNhbWVyYUZyaWN0aW9uIDwgY2FtZXJhRWxhc3RpY2l0eSA8IDEuMCwgdGhlIGJlaGF2aW9yIHdpbGwgYmUgYW4gb3NjaWxsYXRpb25nIHNwcmluZyB0aGF0IHdpbGwgb3ZlclxyXG4gICAgICAgICAqIGNvcnJlY3QgYW5kIGJvdW5jZSBhcm91bmQgdGhlIHRhcmdldFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHRhcmdldCBUYXJnZXQgYWN0b3IgdG8gZWxhc3RpY2FsbHkgZm9sbG93XHJcbiAgICAgICAgICogQHBhcmFtIGNhbWVyYUVsYXN0aWNpdHkgWzAgLSAxLjBdIFRoZSBoaWdoZXIgdGhlIGVsYXN0aWNpdHkgdGhlIG1vcmUgZm9yY2UgdGhhdCB3aWxsIGRyaXZlIHRoZSBjYW1lcmEgdG93YXJkcyB0aGUgdGFyZ2V0XHJcbiAgICAgICAgICogQHBhcmFtIGNhbWVyYUZyaWN0aW9uIFswIC0gMS4wXSBUaGUgaGlnaGVyIHRoZSBmcmljdGlvbiB0aGUgbW9yZSB0aGF0IHRoZSBjYW1lcmEgd2lsbCByZXNpc3QgbW90aW9uIHRvd2FyZHMgdGhlIHRhcmdldFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIEVsYXN0aWNUb0FjdG9yU3RyYXRlZ3kodGFyZ2V0LCBjYW1lcmFFbGFzdGljaXR5LCBjYW1lcmFGcmljdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgdGhpcy5jYW1lcmFFbGFzdGljaXR5ID0gY2FtZXJhRWxhc3RpY2l0eTtcclxuICAgICAgICAgICAgdGhpcy5jYW1lcmFGcmljdGlvbiA9IGNhbWVyYUZyaWN0aW9uO1xyXG4gICAgICAgICAgICB0aGlzLmFjdGlvbiA9IGZ1bmN0aW9uICh0YXJnZXQsIGNhbSwgX2VuZywgX2RlbHRhKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSB0YXJnZXQuZ2V0Q2VudGVyKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZm9jdXMgPSBjYW0uZ2V0Rm9jdXMoKTtcclxuICAgICAgICAgICAgICAgIHZhciBjYW1lcmFWZWwgPSBuZXcgQWxnZWJyYV8zLlZlY3RvcihjYW0uZHgsIGNhbS5keSk7XHJcbiAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHN0cmVjaCB2ZWN0b3IsIHVzaW5nIHRoZSBzcHJpbmcgZXF1YXRpb25cclxuICAgICAgICAgICAgICAgIC8vIEYgPSBrWFxyXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSG9va2Unc19sYXdcclxuICAgICAgICAgICAgICAgIC8vIEFwcGx5IHRvIHRoZSBjdXJyZW50IGNhbWVyYSB2ZWxvY2l0eVxyXG4gICAgICAgICAgICAgICAgdmFyIHN0cmV0Y2ggPSBwb3NpdGlvbi5zdWIoZm9jdXMpLnNjYWxlKF90aGlzLmNhbWVyYUVsYXN0aWNpdHkpOyAvLyBzdHJldGNoIGlzIFhcclxuICAgICAgICAgICAgICAgIGNhbWVyYVZlbCA9IGNhbWVyYVZlbC5hZGQoc3RyZXRjaCk7XHJcbiAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGZyaWN0aW9uICgtMSB0byBhcHBseSBhIGZvcmNlIGluIHRoZSBvcHBvc2l0aW9uIG9mIG1vdGlvbilcclxuICAgICAgICAgICAgICAgIC8vIEFwcGx5IHRvIHRoZSBjdXJyZW50IGNhbWVyYSB2ZWxvY2l0eVxyXG4gICAgICAgICAgICAgICAgdmFyIGZyaWN0aW9uID0gY2FtZXJhVmVsLnNjYWxlKC0xKS5zY2FsZShfdGhpcy5jYW1lcmFGcmljdGlvbik7XHJcbiAgICAgICAgICAgICAgICBjYW1lcmFWZWwgPSBjYW1lcmFWZWwuYWRkKGZyaWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBwb3NpdGlvbiBieSB2ZWxvY2l0eSBkZWx0YXNcclxuICAgICAgICAgICAgICAgIGZvY3VzID0gZm9jdXMuYWRkKGNhbWVyYVZlbCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9jdXM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBFbGFzdGljVG9BY3RvclN0cmF0ZWd5O1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuRWxhc3RpY1RvQWN0b3JTdHJhdGVneSA9IEVsYXN0aWNUb0FjdG9yU3RyYXRlZ3k7XHJcbiAgICB2YXIgUmFkaXVzQXJvdW5kQWN0b3JTdHJhdGVneSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRhcmdldCBhY3RvciB0byBmb2xsb3cgd2hlbiBpdCBpcyBcInJhZGl1c1wiIHBpeGVscyBhd2F5XHJcbiAgICAgICAgICogQHBhcmFtIHJhZGl1cyBOdW1iZXIgb2YgcGl4ZWxzIGF3YXkgYmVmb3JlIHRoZSBjYW1lcmEgd2lsbCBmb2xsb3dcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBSYWRpdXNBcm91bmRBY3RvclN0cmF0ZWd5KHRhcmdldCwgcmFkaXVzKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cztcclxuICAgICAgICAgICAgdGhpcy5hY3Rpb24gPSBmdW5jdGlvbiAodGFyZ2V0LCBjYW0sIF9lbmcsIF9kZWx0YSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gdGFyZ2V0LmdldENlbnRlcigpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZvY3VzID0gY2FtLmdldEZvY3VzKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gcG9zaXRpb24uc3ViKGZvY3VzKTtcclxuICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IGRpcmVjdGlvbi5tYWduaXR1ZGUoKTtcclxuICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZSA+PSBfdGhpcy5yYWRpdXMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gZGlzdGFuY2UgLSBfdGhpcy5yYWRpdXM7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvY3VzLmFkZChkaXJlY3Rpb24ubm9ybWFsaXplKCkuc2NhbGUob2Zmc2V0KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9jdXM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBSYWRpdXNBcm91bmRBY3RvclN0cmF0ZWd5O1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuUmFkaXVzQXJvdW5kQWN0b3JTdHJhdGVneSA9IFJhZGl1c0Fyb3VuZEFjdG9yU3RyYXRlZ3k7XHJcbiAgICAvKipcclxuICAgICAqIENhbWVyYXNcclxuICAgICAqXHJcbiAgICAgKiBbW0Jhc2VDYW1lcmFdXSBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgYWxsIEV4Y2FsaWJ1ciBjYW1lcmFzLiBDYW1lcmFzIGFyZSB1c2VkXHJcbiAgICAgKiB0byBtb3ZlIGFyb3VuZCB5b3VyIGdhbWUgYW5kIHNldCBmb2N1cy4gVGhleSBhcmUgdXNlZCB0byBkZXRlcm1pbmVcclxuICAgICAqIHdoYXQgaXMgXCJvZmYgc2NyZWVuXCIgYW5kIGNhbiBiZSB1c2VkIHRvIHNjYWxlIHRoZSBnYW1lLlxyXG4gICAgICpcclxuICAgICAqIFtbaW5jbHVkZTpDYW1lcmFzLm1kXV1cclxuICAgICAqL1xyXG4gICAgdmFyIEJhc2VDYW1lcmEgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIEJhc2VDYW1lcmEoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbWVyYVN0cmF0ZWdpZXMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5zdHJhdGVneSA9IG5ldyBTdHJhdGVneUNvbnRhaW5lcih0aGlzKTtcclxuICAgICAgICAgICAgLy8gY2FtZXJhIHBoeXNpY2FsIHF1YW50aXRpZXNcclxuICAgICAgICAgICAgdGhpcy56ID0gMTtcclxuICAgICAgICAgICAgdGhpcy5keCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuZHkgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmR6ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5heCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuYXkgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmF6ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbiA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMucnggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl94ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5feSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbWVyYU1vdmluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50TGVycFRpbWUgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9sZXJwRHVyYXRpb24gPSAxMDAwOyAvLyAxIHNlY29uZCAgIFxyXG4gICAgICAgICAgICB0aGlzLl9sZXJwU3RhcnQgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl9sZXJwRW5kID0gbnVsbDtcclxuICAgICAgICAgICAgLy9jYW1lcmEgZWZmZWN0c1xyXG4gICAgICAgICAgICB0aGlzLl9pc1NoYWtpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fc2hha2VNYWduaXR1ZGVYID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fc2hha2VNYWduaXR1ZGVZID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fc2hha2VEdXJhdGlvbiA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2VsYXBzZWRTaGFrZVRpbWUgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl94U2hha2UgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl95U2hha2UgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9pc1pvb21pbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fbWF4Wm9vbVNjYWxlID0gMTtcclxuICAgICAgICAgICAgdGhpcy5fem9vbUluY3JlbWVudCA9IDAuMDE7XHJcbiAgICAgICAgICAgIHRoaXMuX2Vhc2luZyA9IEVhc2luZ0Z1bmN0aW9uc18xLkVhc2luZ0Z1bmN0aW9ucy5FYXNlSW5PdXRDdWJpYztcclxuICAgICAgICB9XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VDYW1lcmEucHJvdG90eXBlLCBcInhcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0IHRoZSBjYW1lcmEncyB4IHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl94O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0IHRoZSBjYW1lcmEncyB4IHBvc2l0aW9uIChjYW5ub3QgYmUgc2V0IHdoZW4gZm9sbG93aW5nIGFuIFtbQWN0b3JdXSBvciB3aGVuIG1vdmluZylcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2ZvbGxvdyAmJiAhdGhpcy5fY2FtZXJhTW92aW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5feCA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZUNhbWVyYS5wcm90b3R5cGUsIFwieVwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXQgdGhlIGNhbWVyYSdzIHkgcG9zaXRpb25cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3k7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXQgdGhlIGNhbWVyYSdzIHkgcG9zaXRpb24gKGNhbm5vdCBiZSBzZXQgd2hlbiBmb2xsb3dpbmcgYW4gW1tBY3Rvcl1dIG9yIHdoZW4gbW92aW5nKVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fZm9sbG93ICYmICF0aGlzLl9jYW1lcmFNb3ZpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl95ID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlQ2FtZXJhLnByb3RvdHlwZSwgXCJwb3NcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0IHRoZSBjYW1lcmEncyBwb3NpdGlvbiBhcyBhIHZlY3RvclxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFsZ2VicmFfMy5WZWN0b3IodGhpcy54LCB0aGlzLnkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0IHRoZSBjYW1lcmFzIHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy54ID0gdmFsdWUueDtcclxuICAgICAgICAgICAgICAgIHRoaXMueSA9IHZhbHVlLnk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlQ2FtZXJhLnByb3RvdHlwZSwgXCJ2ZWxcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0IHRoZSBjYW1lcmEncyB2ZWxvY2l0eSBhcyBhIHZlY3RvclxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFsZ2VicmFfMy5WZWN0b3IodGhpcy5keCwgdGhpcy5keSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXQgdGhlIGNhbWVyYSdzIHZlbG9jaXR5XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5keCA9IHZhbHVlLng7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmR5ID0gdmFsdWUueTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgZm9jYWwgcG9pbnQgb2YgdGhlIGNhbWVyYSwgYSBuZXcgcG9pbnQgZ2l2aW5nIHRoZSB4IGFuZCB5IHBvc2l0aW9uIG9mIHRoZSBjYW1lcmFcclxuICAgICAgICAgKi9cclxuICAgICAgICBCYXNlQ2FtZXJhLnByb3RvdHlwZS5nZXRGb2N1cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbGdlYnJhXzMuVmVjdG9yKHRoaXMueCwgdGhpcy55KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgbW92ZXMgdGhlIGNhbWVyYSBmb2NhbCBwb2ludCB0byB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uIHVzaW5nIHNwZWNpZmllZCBlYXNpbmcgZnVuY3Rpb24uIENhbm5vdCBtb3ZlIHdoZW4gZm9sbG93aW5nIGFuIEFjdG9yLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHBvcyBUaGUgdGFyZ2V0IHBvc2l0aW9uIHRvIG1vdmUgdG9cclxuICAgICAgICAgKiBAcGFyYW0gZHVyYXRpb24gVGhlIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcyB0aGUgbW92ZSBzaG91bGQgbGFzdFxyXG4gICAgICAgICAqIEBwYXJhbSBbZWFzaW5nRm5dIEFuIG9wdGlvbmFsIGVhc2luZyBmdW5jdGlvbiAoW1tleC5FYXNpbmdGdW5jdGlvbnMuRWFzZUluT3V0Q3ViaWNdXSBieSBkZWZhdWx0KVxyXG4gICAgICAgICAqIEByZXR1cm5zIEEgW1tQcm9taXNlXV0gdGhhdCByZXNvbHZlcyB3aGVuIG1vdmVtZW50IGlzIGZpbmlzaGVkLCBpbmNsdWRpbmcgaWYgaXQncyBpbnRlcnJ1cHRlZC5cclxuICAgICAgICAgKiAgICAgICAgICBUaGUgW1tQcm9taXNlXV0gdmFsdWUgaXMgdGhlIFtbVmVjdG9yXV0gb2YgdGhlIHRhcmdldCBwb3NpdGlvbi4gSXQgd2lsbCBiZSByZWplY3RlZCBpZiBhIG1vdmUgY2Fubm90IGJlIG1hZGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQmFzZUNhbWVyYS5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uIChwb3MsIGR1cmF0aW9uLCBlYXNpbmdGbikge1xyXG4gICAgICAgICAgICBpZiAoZWFzaW5nRm4gPT09IHZvaWQgMCkgeyBlYXNpbmdGbiA9IEVhc2luZ0Z1bmN0aW9uc18xLkVhc2luZ0Z1bmN0aW9ucy5FYXNlSW5PdXRDdWJpYzsgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGVhc2luZ0ZuICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyAnUGxlYXNlIHNwZWNpZnkgYW4gRWFzaW5nRnVuY3Rpb24nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNhbm5vdCBtb3ZlIHdoZW4gZm9sbG93aW5nIGFuIGFjdG9yXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9mb2xsb3cpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZXNfMS5Qcm9taXNlKCkucmVqZWN0KHBvcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcmVzb2x2ZSBleGlzdGluZyBwcm9taXNlLCBpZiBhbnlcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2xlcnBQcm9taXNlICYmIHRoaXMuX2xlcnBQcm9taXNlLnN0YXRlKCkgPT09IFByb21pc2VzXzEuUHJvbWlzZVN0YXRlLlBlbmRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xlcnBQcm9taXNlLnJlc29sdmUocG9zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9sZXJwUHJvbWlzZSA9IG5ldyBQcm9taXNlc18xLlByb21pc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5fbGVycFN0YXJ0ID0gdGhpcy5nZXRGb2N1cygpLmNsb25lKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2xlcnBEdXJhdGlvbiA9IGR1cmF0aW9uO1xyXG4gICAgICAgICAgICB0aGlzLl9sZXJwRW5kID0gcG9zO1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50TGVycFRpbWUgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9jYW1lcmFNb3ZpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9lYXNpbmcgPSBlYXNpbmdGbjtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xlcnBQcm9taXNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgY2FtZXJhIHRvIHNoYWtlIGF0IHRoZSBzcGVjaWZpZWQgbWFnbml0dWRlcyBmb3IgdGhlIHNwZWNpZmllZCBkdXJhdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSBtYWduaXR1ZGVYICBUaGUgeCBtYWduaXR1ZGUgb2YgdGhlIHNoYWtlXHJcbiAgICAgICAgICogQHBhcmFtIG1hZ25pdHVkZVkgIFRoZSB5IG1hZ25pdHVkZSBvZiB0aGUgc2hha2VcclxuICAgICAgICAgKiBAcGFyYW0gZHVyYXRpb24gICAgVGhlIGR1cmF0aW9uIG9mIHRoZSBzaGFrZSBpbiBtaWxsaXNlY29uZHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBCYXNlQ2FtZXJhLnByb3RvdHlwZS5zaGFrZSA9IGZ1bmN0aW9uIChtYWduaXR1ZGVYLCBtYWduaXR1ZGVZLCBkdXJhdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLl9pc1NoYWtpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9zaGFrZU1hZ25pdHVkZVggPSBtYWduaXR1ZGVYO1xyXG4gICAgICAgICAgICB0aGlzLl9zaGFrZU1hZ25pdHVkZVkgPSBtYWduaXR1ZGVZO1xyXG4gICAgICAgICAgICB0aGlzLl9zaGFrZUR1cmF0aW9uID0gZHVyYXRpb247XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBab29tcyB0aGUgY2FtZXJhIGluIG9yIG91dCBieSB0aGUgc3BlY2lmaWVkIHNjYWxlIG92ZXIgdGhlIHNwZWNpZmllZCBkdXJhdGlvbi5cclxuICAgICAgICAgKiBJZiBubyBkdXJhdGlvbiBpcyBzcGVjaWZpZWQsIGl0IHRha2UgZWZmZWN0IGltbWVkaWF0ZWx5LlxyXG4gICAgICAgICAqIEBwYXJhbSBzY2FsZSAgICBUaGUgc2NhbGUgb2YgdGhlIHpvb21cclxuICAgICAgICAgKiBAcGFyYW0gZHVyYXRpb24gVGhlIGR1cmF0aW9uIG9mIHRoZSB6b29tIGluIG1pbGxpc2Vjb25kc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJhc2VDYW1lcmEucHJvdG90eXBlLnpvb20gPSBmdW5jdGlvbiAoc2NhbGUsIGR1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmIChkdXJhdGlvbiA9PT0gdm9pZCAwKSB7IGR1cmF0aW9uID0gMDsgfVxyXG4gICAgICAgICAgICB0aGlzLl96b29tUHJvbWlzZSA9IG5ldyBQcm9taXNlc18xLlByb21pc2UoKTtcclxuICAgICAgICAgICAgaWYgKGR1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1pvb21pbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWF4Wm9vbVNjYWxlID0gc2NhbGU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl96b29tSW5jcmVtZW50ID0gKHNjYWxlIC0gdGhpcy56KSAvIGR1cmF0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faXNab29taW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnogPSBzY2FsZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3pvb21Qcm9taXNlLnJlc29sdmUodHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3pvb21Qcm9taXNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgY3VycmVudCB6b29tIHNjYWxlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQmFzZUNhbWVyYS5wcm90b3R5cGUuZ2V0Wm9vbSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuejtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYSBuZXcgY2FtZXJhIHN0cmF0ZWd5IHRvIHRoaXMgY2FtZXJhXHJcbiAgICAgICAgICogQHBhcmFtIGNhbWVyYVN0cmF0ZWd5IEluc3RhbmNlIG9mIGFuIFtbSUNhbWVyYVN0cmF0ZWd5XV1cclxuICAgICAgICAgKi9cclxuICAgICAgICBCYXNlQ2FtZXJhLnByb3RvdHlwZS5hZGRTdHJhdGVneSA9IGZ1bmN0aW9uIChjYW1lcmFTdHJhdGVneSkge1xyXG4gICAgICAgICAgICB0aGlzLl9jYW1lcmFTdHJhdGVnaWVzLnB1c2goY2FtZXJhU3RyYXRlZ3kpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlcyBhIGNhbWVyYSBzdHJhdGVneSBieSByZWZlcmVuY2VcclxuICAgICAgICAgKiBAcGFyYW0gY2FtZXJhU3RyYXRlZ3kgSW5zdGFuY2Ugb2YgYW4gW1tJQ2FtZXJhU3RyYXRlZ3ldXVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJhc2VDYW1lcmEucHJvdG90eXBlLnJlbW92ZVN0cmF0ZWd5ID0gZnVuY3Rpb24gKGNhbWVyYVN0cmF0ZWd5KSB7XHJcbiAgICAgICAgICAgIFV0aWxfMS5yZW1vdmVJdGVtRnJvbUFycmF5KGNhbWVyYVN0cmF0ZWd5LCB0aGlzLl9jYW1lcmFTdHJhdGVnaWVzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENsZWFycyBhbGwgY2FtZXJhIHN0cmF0ZWdpZXMgZnJvbSB0aGUgY2FtZXJhXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQmFzZUNhbWVyYS5wcm90b3R5cGUuY2xlYXJBbGxTdHJhdGVnaWVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9jYW1lcmFTdHJhdGVnaWVzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBCYXNlQ2FtZXJhLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoX2VuZ2luZSwgZGVsdGEpIHtcclxuICAgICAgICAgICAgLy8gVXBkYXRlIHBsYWNlbWVudHMgYmFzZWQgb24gbGluZWFyIGFsZ2VicmFcclxuICAgICAgICAgICAgdGhpcy5feCArPSB0aGlzLmR4ICogZGVsdGEgLyAxMDAwO1xyXG4gICAgICAgICAgICB0aGlzLl95ICs9IHRoaXMuZHkgKiBkZWx0YSAvIDEwMDA7XHJcbiAgICAgICAgICAgIHRoaXMueiArPSB0aGlzLmR6ICogZGVsdGEgLyAxMDAwO1xyXG4gICAgICAgICAgICB0aGlzLmR4ICs9IHRoaXMuYXggKiBkZWx0YSAvIDEwMDA7XHJcbiAgICAgICAgICAgIHRoaXMuZHkgKz0gdGhpcy5heSAqIGRlbHRhIC8gMTAwMDtcclxuICAgICAgICAgICAgdGhpcy5keiArPSB0aGlzLmF6ICogZGVsdGEgLyAxMDAwO1xyXG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uICs9IHRoaXMucnggKiBkZWx0YSAvIDEwMDA7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1pvb21pbmcpIHtcclxuICAgICAgICAgICAgICAgIHZhciBuZXdab29tID0gdGhpcy56ICsgdGhpcy5fem9vbUluY3JlbWVudCAqIGRlbHRhO1xyXG4gICAgICAgICAgICAgICAgdGhpcy56ID0gbmV3Wm9vbTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl96b29tSW5jcmVtZW50ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdab29tID49IHRoaXMuX21heFpvb21TY2FsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pc1pvb21pbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy56ID0gdGhpcy5fbWF4Wm9vbVNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl96b29tUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdab29tIDw9IHRoaXMuX21heFpvb21TY2FsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pc1pvb21pbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy56ID0gdGhpcy5fbWF4Wm9vbVNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl96b29tUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5fY2FtZXJhTW92aW5nKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudExlcnBUaW1lIDwgdGhpcy5fbGVycER1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xlcnBFbmQueCA8IHRoaXMuX2xlcnBTdGFydC54KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ggPSB0aGlzLl9sZXJwU3RhcnQueCAtICh0aGlzLl9lYXNpbmcodGhpcy5fY3VycmVudExlcnBUaW1lLCB0aGlzLl9sZXJwRW5kLngsIHRoaXMuX2xlcnBTdGFydC54LCB0aGlzLl9sZXJwRHVyYXRpb24pIC0gdGhpcy5fbGVycEVuZC54KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ggPSB0aGlzLl9lYXNpbmcodGhpcy5fY3VycmVudExlcnBUaW1lLCB0aGlzLl9sZXJwU3RhcnQueCwgdGhpcy5fbGVycEVuZC54LCB0aGlzLl9sZXJwRHVyYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbGVycEVuZC55IDwgdGhpcy5fbGVycFN0YXJ0LnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5feSA9IHRoaXMuX2xlcnBTdGFydC55IC0gKHRoaXMuX2Vhc2luZyh0aGlzLl9jdXJyZW50TGVycFRpbWUsIHRoaXMuX2xlcnBFbmQueSwgdGhpcy5fbGVycFN0YXJ0LnksIHRoaXMuX2xlcnBEdXJhdGlvbikgLSB0aGlzLl9sZXJwRW5kLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5feSA9IHRoaXMuX2Vhc2luZyh0aGlzLl9jdXJyZW50TGVycFRpbWUsIHRoaXMuX2xlcnBTdGFydC55LCB0aGlzLl9sZXJwRW5kLnksIHRoaXMuX2xlcnBEdXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRMZXJwVGltZSArPSBkZWx0YTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ggPSB0aGlzLl9sZXJwRW5kLng7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5feSA9IHRoaXMuX2xlcnBFbmQueTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sZXJwUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2xlcnBFbmQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xlcnBTdGFydCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGVycEVuZCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudExlcnBUaW1lID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYW1lcmFNb3ZpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNEb25lU2hha2luZygpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1NoYWtpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VsYXBzZWRTaGFrZVRpbWUgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2hha2VNYWduaXR1ZGVYID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NoYWtlTWFnbml0dWRlWSA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zaGFrZUR1cmF0aW9uID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3hTaGFrZSA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl95U2hha2UgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZWxhcHNlZFNoYWtlVGltZSArPSBkZWx0YTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3hTaGFrZSA9IChNYXRoLnJhbmRvbSgpICogdGhpcy5fc2hha2VNYWduaXR1ZGVYIHwgMCkgKyAxO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5feVNoYWtlID0gKE1hdGgucmFuZG9tKCkgKiB0aGlzLl9zaGFrZU1hZ25pdHVkZVkgfCAwKSArIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuX2NhbWVyYVN0cmF0ZWdpZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcyA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gcy5hY3Rpb24uY2FsbChzLCBzLnRhcmdldCwgdGhpcywgX2VuZ2luZSwgZGVsdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcHBsaWVzIHRoZSByZWxldmFudCB0cmFuc2Zvcm1hdGlvbnMgdG8gdGhlIGdhbWUgY2FudmFzIHRvIFwibW92ZVwiIG9yIGFwcGx5IGVmZmVjdHMgdG8gdGhlIENhbWVyYVxyXG4gICAgICAgICAqIEBwYXJhbSBjdHggICAgQ2FudmFzIGNvbnRleHQgdG8gYXBwbHkgdHJhbnNmb3JtYXRpb25zXHJcbiAgICAgICAgICogQHBhcmFtIGRlbHRhICBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgbGFzdCB1cGRhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBCYXNlQ2FtZXJhLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gICAgICAgICAgICB2YXIgZm9jdXMgPSB0aGlzLmdldEZvY3VzKCk7XHJcbiAgICAgICAgICAgIHZhciBjYW52YXNXaWR0aCA9IGN0eC5jYW52YXMud2lkdGg7XHJcbiAgICAgICAgICAgIHZhciBjYW52YXNIZWlnaHQgPSBjdHguY2FudmFzLmhlaWdodDtcclxuICAgICAgICAgICAgdmFyIHBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcclxuICAgICAgICAgICAgdmFyIHpvb20gPSB0aGlzLmdldFpvb20oKTtcclxuICAgICAgICAgICAgdmFyIG5ld0NhbnZhc1dpZHRoID0gKGNhbnZhc1dpZHRoIC8gem9vbSkgLyBwaXhlbFJhdGlvO1xyXG4gICAgICAgICAgICB2YXIgbmV3Q2FudmFzSGVpZ2h0ID0gKGNhbnZhc0hlaWdodCAvIHpvb20pIC8gcGl4ZWxSYXRpbztcclxuICAgICAgICAgICAgY3R4LnNjYWxlKHpvb20sIHpvb20pO1xyXG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKC1mb2N1cy54ICsgbmV3Q2FudmFzV2lkdGggLyAyICsgdGhpcy5feFNoYWtlLCAtZm9jdXMueSArIG5ld0NhbnZhc0hlaWdodCAvIDIgKyB0aGlzLl95U2hha2UpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQmFzZUNhbWVyYS5wcm90b3R5cGUuZGVidWdEcmF3ID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gICAgICAgICAgICB2YXIgZm9jdXMgPSB0aGlzLmdldEZvY3VzKCk7XHJcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAncmVkJztcclxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ3doaXRlJztcclxuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDM7XHJcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgY3R4LmFyYyhmb2N1cy54LCBmb2N1cy55LCAxNSwgMCwgTWF0aC5QSSAqIDIpO1xyXG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHguYXJjKGZvY3VzLngsIGZvY3VzLnksIDUsIDAsIE1hdGguUEkgKiAyKTtcclxuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBCYXNlQ2FtZXJhLnByb3RvdHlwZS5faXNEb25lU2hha2luZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICEodGhpcy5faXNTaGFraW5nKSB8fCAodGhpcy5fZWxhcHNlZFNoYWtlVGltZSA+PSB0aGlzLl9zaGFrZUR1cmF0aW9uKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBCYXNlQ2FtZXJhO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuQmFzZUNhbWVyYSA9IEJhc2VDYW1lcmE7XHJcbn0pO1xyXG5kZWZpbmUoXCJDb25maWd1cmFibGVcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIGZ1bmN0aW9uIENvbmZpZ3VyYWJsZShiYXNlKSB7XHJcbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhjbGFzc18xLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBjbGFzc18xKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3MpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAvL2dldCB0aGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0aGF0IGFyZW4ndCB1bmRlZmluZWQuIFRTIHBhc3NlcyBhIHZhbHVlIHRvIGFsbCBwYXJhbWV0ZXJzXHJcbiAgICAgICAgICAgICAgICAvL29mIHdoYXRldmVyIGN0b3IgaXMgdGhlIGltcGxlbWVudGF0aW9uLCBzbyBhcmdzLmxlbmd0aCBkb2Vzbid0IHdvcmsgaGVyZS5cclxuICAgICAgICAgICAgICAgIHZhciBzaXplID0gYXJncy5maWx0ZXIoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkOyB9KS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZSA9PT0gMSAmJiBhcmdzWzBdICYmIHR5cGVvZiBhcmdzWzBdID09PSAnb2JqZWN0JyAmJiAhKGFyZ3NbMF0gaW5zdGFuY2VvZiBBcnJheSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hc3NpZ24oYXJnc1swXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuYXNzaWduID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICAvL3NldCB0aGUgdmFsdWUgb2YgZXZlcnkgcHJvcGVydHkgdGhhdCB3YXMgcGFzc2VkIGluLFxyXG4gICAgICAgICAgICAgICAgLy9pZiB0aGUgY29uc3RydWN0b3IgcHJldmlvdXNseSBzZXQgdGhpcyB2YWx1ZSwgaXQgd2lsbCBiZSBvdmVycmlkZGVuIGhlcmVcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgaW4gcHJvcHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXNba10gIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trXSA9IHByb3BzW2tdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIGNsYXNzXzE7XHJcbiAgICAgICAgfShiYXNlKSk7XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLkNvbmZpZ3VyYWJsZSA9IENvbmZpZ3VyYWJsZTtcclxufSk7XHJcbmRlZmluZShcIkRlYnVnRmxhZ3NcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxufSk7XHJcbmRlZmluZShcIkRyYXdpbmcvQ29sb3JcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogUHJvdmlkZXMgc3RhbmRhcmQgY29sb3JzIChlLmcuIFtbQ29sb3IuQmxhY2tdXSlcclxuICAgICAqIGJ1dCB5b3UgY2FuIGFsc28gY3JlYXRlIGN1c3RvbSBjb2xvcnMgdXNpbmcgUkdCLCBIU0wsIG9yIEhleC4gQWxzbyBwcm92aWRlc1xyXG4gICAgICogdXNlZnVsIGNvbG9yIG9wZXJhdGlvbnMgbGlrZSBbW0NvbG9yLmxpZ2h0ZW5dXSwgW1tDb2xvci5kYXJrZW5dXSwgYW5kIG1vcmUuXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOkNvbG9ycy5tZF1dXHJcbiAgICAgKi9cclxuICAgIHZhciBDb2xvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBDb2xvciBmcm9tIGFuIHIsIGcsIGIsIGFcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSByICBUaGUgcmVkIGNvbXBvbmVudCBvZiBjb2xvciAoMC0yNTUpXHJcbiAgICAgICAgICogQHBhcmFtIGcgIFRoZSBncmVlbiBjb21wb25lbnQgb2YgY29sb3IgKDAtMjU1KVxyXG4gICAgICAgICAqIEBwYXJhbSBiICBUaGUgYmx1ZSBjb21wb25lbnQgb2YgY29sb3IgKDAtMjU1KVxyXG4gICAgICAgICAqIEBwYXJhbSBhICBUaGUgYWxwaGEgY29tcG9uZW50IG9mIGNvbG9yICgwLTEuMClcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBDb2xvcihyLCBnLCBiLCBhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuciA9IHI7XHJcbiAgICAgICAgICAgIHRoaXMuZyA9IGc7XHJcbiAgICAgICAgICAgIHRoaXMuYiA9IGI7XHJcbiAgICAgICAgICAgIHRoaXMuYSA9IChhICE9IG51bGwgPyBhIDogMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgQ29sb3IgZnJvbSBhbiByLCBnLCBiLCBhXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gciAgVGhlIHJlZCBjb21wb25lbnQgb2YgY29sb3IgKDAtMjU1KVxyXG4gICAgICAgICAqIEBwYXJhbSBnICBUaGUgZ3JlZW4gY29tcG9uZW50IG9mIGNvbG9yICgwLTI1NSlcclxuICAgICAgICAgKiBAcGFyYW0gYiAgVGhlIGJsdWUgY29tcG9uZW50IG9mIGNvbG9yICgwLTI1NSlcclxuICAgICAgICAgKiBAcGFyYW0gYSAgVGhlIGFscGhhIGNvbXBvbmVudCBvZiBjb2xvciAoMC0xLjApXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sb3IuZnJvbVJHQiA9IGZ1bmN0aW9uIChyLCBnLCBiLCBhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IociwgZywgYiwgYSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IGluc2NhbmNlIG9mIENvbG9yIGZyb20gYSBoZXggc3RyaW5nXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gaGV4ICBDU1MgY29sb3Igc3RyaW5nIG9mIHRoZSBmb3JtICNmZmZmZmYsIHRoZSBhbHBoYSBjb21wb25lbnQgaXMgb3B0aW9uYWxcclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xvci5mcm9tSGV4ID0gZnVuY3Rpb24gKGhleCkge1xyXG4gICAgICAgICAgICB2YXIgaGV4UmVnRXggPSAvXiM/KFswLTlhLWZdezJ9KShbMC05YS1mXXsyfSkoWzAtOWEtZl17Mn0pKFswLTlhLWZdezJ9KT8kL2k7XHJcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChtYXRjaCA9IGhleC5tYXRjaChoZXhSZWdFeCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciByID0gcGFyc2VJbnQobWF0Y2hbMV0sIDE2KTtcclxuICAgICAgICAgICAgICAgIHZhciBnID0gcGFyc2VJbnQobWF0Y2hbMl0sIDE2KTtcclxuICAgICAgICAgICAgICAgIHZhciBiID0gcGFyc2VJbnQobWF0Y2hbM10sIDE2KTtcclxuICAgICAgICAgICAgICAgIHZhciBhID0gMTtcclxuICAgICAgICAgICAgICAgIGlmIChtYXRjaFs0XSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGEgPSBwYXJzZUludChtYXRjaFs0XSwgMTYpIC8gMjU1O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihyLCBnLCBiLCBhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nOiAnICsgaGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRzIGEgbmV3IGluc3RhbmNlIG9mIENvbG9yIGZyb20gaHNsYSB2YWx1ZXNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBoICBIdWUgaXMgcmVwcmVzZW50ZWQgWzAtMV1cclxuICAgICAgICAgKiBAcGFyYW0gcyAgU2F0dXJhdGlvbiBpcyByZXByZXNlbnRlZCBbMC0xXVxyXG4gICAgICAgICAqIEBwYXJhbSBsICBMdW1pbmFuY2UgaXMgcmVwcmVzZW50ZWQgWzAtMV1cclxuICAgICAgICAgKiBAcGFyYW0gYSAgQWxwaGEgaXMgcmVwcmVzZW50ZWQgWzAtMV1cclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xvci5mcm9tSFNMID0gZnVuY3Rpb24gKGgsIHMsIGwsIGEpIHtcclxuICAgICAgICAgICAgaWYgKGEgPT09IHZvaWQgMCkgeyBhID0gMS4wOyB9XHJcbiAgICAgICAgICAgIHZhciB0ZW1wID0gbmV3IEhTTENvbG9yKGgsIHMsIGwsIGEpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGVtcC50b1JHQkEoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExpZ2h0ZW5zIHRoZSBjdXJyZW50IGNvbG9yIGJ5IGEgc3BlY2lmaWVkIGFtb3VudFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGZhY3RvciAgVGhlIGFtb3VudCB0byBsaWdodGVuIGJ5IFswLTFdXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sb3IucHJvdG90eXBlLmxpZ2h0ZW4gPSBmdW5jdGlvbiAoZmFjdG9yKSB7XHJcbiAgICAgICAgICAgIGlmIChmYWN0b3IgPT09IHZvaWQgMCkgeyBmYWN0b3IgPSAwLjE7IH1cclxuICAgICAgICAgICAgdmFyIHRlbXAgPSBIU0xDb2xvci5mcm9tUkdCQSh0aGlzLnIsIHRoaXMuZywgdGhpcy5iLCB0aGlzLmEpO1xyXG4gICAgICAgICAgICB0ZW1wLmwgKz0gKHRlbXAubCAqIGZhY3Rvcik7XHJcbiAgICAgICAgICAgIHJldHVybiB0ZW1wLnRvUkdCQSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGFya2VucyB0aGUgY3VycmVudCBjb2xvciBieSBhIHNwZWNpZmllZCBhbW91bnRcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBmYWN0b3IgIFRoZSBhbW91bnQgdG8gZGFya2VuIGJ5IFswLTFdXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sb3IucHJvdG90eXBlLmRhcmtlbiA9IGZ1bmN0aW9uIChmYWN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKGZhY3RvciA9PT0gdm9pZCAwKSB7IGZhY3RvciA9IDAuMTsgfVxyXG4gICAgICAgICAgICB2YXIgdGVtcCA9IEhTTENvbG9yLmZyb21SR0JBKHRoaXMuciwgdGhpcy5nLCB0aGlzLmIsIHRoaXMuYSk7XHJcbiAgICAgICAgICAgIHRlbXAubCAtPSAodGVtcC5sICogZmFjdG9yKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRlbXAudG9SR0JBKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTYXR1cmF0ZXMgdGhlIGN1cnJlbnQgY29sb3IgYnkgYSBzcGVjaWZpZWQgYW1vdW50XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gZmFjdG9yICBUaGUgYW1vdW50IHRvIHNhdHVyYXRlIGJ5IFswLTFdXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sb3IucHJvdG90eXBlLnNhdHVyYXRlID0gZnVuY3Rpb24gKGZhY3Rvcikge1xyXG4gICAgICAgICAgICBpZiAoZmFjdG9yID09PSB2b2lkIDApIHsgZmFjdG9yID0gMC4xOyB9XHJcbiAgICAgICAgICAgIHZhciB0ZW1wID0gSFNMQ29sb3IuZnJvbVJHQkEodGhpcy5yLCB0aGlzLmcsIHRoaXMuYiwgdGhpcy5hKTtcclxuICAgICAgICAgICAgdGVtcC5zICs9ICh0ZW1wLnMgKiBmYWN0b3IpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGVtcC50b1JHQkEoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlc2F0dXJhdGVzIHRoZSBjdXJyZW50IGNvbG9yIGJ5IGEgc3BlY2lmaWVkIGFtb3VudFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGZhY3RvciAgVGhlIGFtb3VudCB0byBkZXNhdHVyYXRlIGJ5IFswLTFdXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sb3IucHJvdG90eXBlLmRlc2F0dXJhdGUgPSBmdW5jdGlvbiAoZmFjdG9yKSB7XHJcbiAgICAgICAgICAgIGlmIChmYWN0b3IgPT09IHZvaWQgMCkgeyBmYWN0b3IgPSAwLjE7IH1cclxuICAgICAgICAgICAgdmFyIHRlbXAgPSBIU0xDb2xvci5mcm9tUkdCQSh0aGlzLnIsIHRoaXMuZywgdGhpcy5iLCB0aGlzLmEpO1xyXG4gICAgICAgICAgICB0ZW1wLnMgLT0gKHRlbXAucyAqIGZhY3Rvcik7XHJcbiAgICAgICAgICAgIHJldHVybiB0ZW1wLnRvUkdCQSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTXVsdGlwbGllcyBhIGNvbG9yIGJ5IGFub3RoZXIsIHJlc3VsdHMgaW4gYSBkYXJrZXIgY29sb3JcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBjb2xvciAgVGhlIG90aGVyIGNvbG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sb3IucHJvdG90eXBlLm11bGl0aXBseSA9IGZ1bmN0aW9uIChjb2xvcikge1xyXG4gICAgICAgICAgICB2YXIgbmV3UiA9ICgoY29sb3IuciAvIDI1NSAqIHRoaXMuciAvIDI1NSkgKiAyNTUpO1xyXG4gICAgICAgICAgICB2YXIgbmV3RyA9ICgoY29sb3IuZyAvIDI1NSAqIHRoaXMuZyAvIDI1NSkgKiAyNTUpO1xyXG4gICAgICAgICAgICB2YXIgbmV3QiA9ICgoY29sb3IuYiAvIDI1NSAqIHRoaXMuYiAvIDI1NSkgKiAyNTUpO1xyXG4gICAgICAgICAgICB2YXIgbmV3QSA9IChjb2xvci5hICogdGhpcy5hKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihuZXdSLCBuZXdHLCBuZXdCLCBuZXdBKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNjcmVlbnMgYSBjb2xvciBieSBhbm90aGVyLCByZXN1bHRzIGluIGEgbGlnaHRlciBjb2xvclxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGNvbG9yICBUaGUgb3RoZXIgY29sb3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xvci5wcm90b3R5cGUuc2NyZWVuID0gZnVuY3Rpb24gKGNvbG9yKSB7XHJcbiAgICAgICAgICAgIHZhciBjb2xvcjEgPSBjb2xvci5pbnZlcnQoKTtcclxuICAgICAgICAgICAgdmFyIGNvbG9yMiA9IGNvbG9yLmludmVydCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gY29sb3IxLm11bGl0aXBseShjb2xvcjIpLmludmVydCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW52ZXJ0cyB0aGUgY3VycmVudCBjb2xvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbG9yLnByb3RvdHlwZS5pbnZlcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IoMjU1IC0gdGhpcy5yLCAyNTUgLSB0aGlzLmcsIDI1NSAtIHRoaXMuYiwgMS4wIC0gdGhpcy5hKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEF2ZXJhZ2VzIHRoZSBjdXJyZW50IGNvbG9yIHdpdGggYW5vdGhlclxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGNvbG9yICBUaGUgb3RoZXIgY29sb3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xvci5wcm90b3R5cGUuYXZlcmFnZSA9IGZ1bmN0aW9uIChjb2xvcikge1xyXG4gICAgICAgICAgICB2YXIgbmV3UiA9IChjb2xvci5yICsgdGhpcy5yKSAvIDI7XHJcbiAgICAgICAgICAgIHZhciBuZXdHID0gKGNvbG9yLmcgKyB0aGlzLmcpIC8gMjtcclxuICAgICAgICAgICAgdmFyIG5ld0IgPSAoY29sb3IuYiArIHRoaXMuYikgLyAyO1xyXG4gICAgICAgICAgICB2YXIgbmV3QSA9IChjb2xvci5hICsgdGhpcy5hKSAvIDI7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IobmV3UiwgbmV3RywgbmV3QiwgbmV3QSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgQ1NTIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIGNvbG9yLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGZvcm1hdCBDb2xvciByZXByZXNlbnRhdGlvbiwgYWNjZXB0czogcmdiLCBoc2wsIG9yIGhleFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbG9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcclxuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gdm9pZCAwKSB7IGZvcm1hdCA9ICdyZ2InOyB9XHJcbiAgICAgICAgICAgIHN3aXRjaCAoZm9ybWF0KSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdyZ2InOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvUkdCQSgpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnaHNsJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0hTTEEoKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2hleCc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9IZXgoKTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIENvbG9yIGZvcm1hdCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIEhleCBWYWx1ZSBvZiBhIGNvbG9yIGNvbXBvbmVudFxyXG4gICAgICAgICAqIEBwYXJhbSBjIGNvbG9yIGNvbXBvbmVudFxyXG4gICAgICAgICAqIEBzZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTYyMzgzOC9yZ2ItdG8taGV4LWFuZC1oZXgtdG8tcmdiXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sb3IucHJvdG90eXBlLl9jb21wb25lbnRUb0hleCA9IGZ1bmN0aW9uIChjKSB7XHJcbiAgICAgICAgICAgIHZhciBoZXggPSBjLnRvU3RyaW5nKDE2KTtcclxuICAgICAgICAgICAgcmV0dXJuIGhleC5sZW5ndGggPT09IDEgPyAnMCcgKyBoZXggOiBoZXg7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm4gSGV4IHJlcHJlc2VudGF0aW9uIG9mIGEgY29sb3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sb3IucHJvdG90eXBlLnRvSGV4ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJyMnICsgdGhpcy5fY29tcG9uZW50VG9IZXgodGhpcy5yKSArIHRoaXMuX2NvbXBvbmVudFRvSGV4KHRoaXMuZykgKyB0aGlzLl9jb21wb25lbnRUb0hleCh0aGlzLmIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJuIFJHQkEgcmVwcmVzZW50YXRpb24gb2YgYSBjb2xvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xvci5wcm90b3R5cGUudG9SR0JBID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gU3RyaW5nKHRoaXMuci50b0ZpeGVkKDApKSArICcsICcgKyBTdHJpbmcodGhpcy5nLnRvRml4ZWQoMCkpICsgJywgJyArIFN0cmluZyh0aGlzLmIudG9GaXhlZCgwKSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmEgIT09IHVuZGVmaW5lZCB8fCB0aGlzLmEgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAncmdiYSgnICsgcmVzdWx0ICsgJywgJyArIFN0cmluZyh0aGlzLmEpICsgJyknO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAncmdiKCcgKyByZXN1bHQgKyAnKSc7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm4gSFNMQSByZXByZXNlbnRhdGlvbiBvZiBhIGNvbG9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbG9yLnByb3RvdHlwZS50b0hTTEEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBIU0xDb2xvci5mcm9tUkdCQSh0aGlzLnIsIHRoaXMuZywgdGhpcy5iLCB0aGlzLmEpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgQ1NTIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIGNvbG9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbG9yLnByb3RvdHlwZS5maWxsU3R5bGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIGN1cnJlbnQgY29sb3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sb3IucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKHRoaXMuciwgdGhpcy5nLCB0aGlzLmIsIHRoaXMuYSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gQ29sb3I7XHJcbiAgICB9KCkpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBCbGFjayAoIzAwMDAwMClcclxuICAgICAqL1xyXG4gICAgQ29sb3IuQmxhY2sgPSBDb2xvci5mcm9tSGV4KCcjMDAwMDAwJyk7XHJcbiAgICAvKipcclxuICAgICAqIFdoaXRlICgjRkZGRkZGKVxyXG4gICAgICovXHJcbiAgICBDb2xvci5XaGl0ZSA9IENvbG9yLmZyb21IZXgoJyNGRkZGRkYnKTtcclxuICAgIC8qKlxyXG4gICAgICogR3JheSAoIzgwODA4MClcclxuICAgICAqL1xyXG4gICAgQ29sb3IuR3JheSA9IENvbG9yLmZyb21IZXgoJyM4MDgwODAnKTtcclxuICAgIC8qKlxyXG4gICAgICogTGlnaHQgZ3JheSAoI0QzRDNEMylcclxuICAgICAqL1xyXG4gICAgQ29sb3IuTGlnaHRHcmF5ID0gQ29sb3IuZnJvbUhleCgnI0QzRDNEMycpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEYXJrIGdyYXkgKCNBOUE5QTkpXHJcbiAgICAgKi9cclxuICAgIENvbG9yLkRhcmtHcmF5ID0gQ29sb3IuZnJvbUhleCgnI0E5QTlBOScpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBZZWxsb3cgKCNGRkZGMDApXHJcbiAgICAgKi9cclxuICAgIENvbG9yLlllbGxvdyA9IENvbG9yLmZyb21IZXgoJyNGRkZGMDAnKTtcclxuICAgIC8qKlxyXG4gICAgICogT3JhbmdlICgjRkZBNTAwKVxyXG4gICAgICovXHJcbiAgICBDb2xvci5PcmFuZ2UgPSBDb2xvci5mcm9tSGV4KCcjRkZBNTAwJyk7XHJcbiAgICAvKipcclxuICAgICAqIFJlZCAoI0ZGMDAwMClcclxuICAgICAqL1xyXG4gICAgQ29sb3IuUmVkID0gQ29sb3IuZnJvbUhleCgnI0ZGMDAwMCcpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBWZXJtaWxsaW9uICgjRkY1QjMxKVxyXG4gICAgICovXHJcbiAgICBDb2xvci5WZXJtaWxsaW9uID0gQ29sb3IuZnJvbUhleCgnI0ZGNUIzMScpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSb3NlICgjRkYwMDdGKVxyXG4gICAgICovXHJcbiAgICBDb2xvci5Sb3NlID0gQ29sb3IuZnJvbUhleCgnI0ZGMDA3RicpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBNYWdlbnRhICgjRkYwMEZGKVxyXG4gICAgICovXHJcbiAgICBDb2xvci5NYWdlbnRhID0gQ29sb3IuZnJvbUhleCgnI0ZGMDBGRicpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBWaW9sZXQgKCM3RjAwRkYpXHJcbiAgICAgKi9cclxuICAgIENvbG9yLlZpb2xldCA9IENvbG9yLmZyb21IZXgoJyM3RjAwRkYnKTtcclxuICAgIC8qKlxyXG4gICAgICogQmx1ZSAoIzAwMDBGRilcclxuICAgICAqL1xyXG4gICAgQ29sb3IuQmx1ZSA9IENvbG9yLmZyb21IZXgoJyMwMDAwRkYnKTtcclxuICAgIC8qKlxyXG4gICAgICogQXp1cmUgKCMwMDdGRkYpXHJcbiAgICAgKi9cclxuICAgIENvbG9yLkF6dXJlID0gQ29sb3IuZnJvbUhleCgnIzAwN0ZGRicpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDeWFuICgjMDBGRkZGKVxyXG4gICAgICovXHJcbiAgICBDb2xvci5DeWFuID0gQ29sb3IuZnJvbUhleCgnIzAwRkZGRicpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBWaXJpZGlhbiAoIzU5OTc4RilcclxuICAgICAqL1xyXG4gICAgQ29sb3IuVmlyaWRpYW4gPSBDb2xvci5mcm9tSGV4KCcjNTk5NzhGJyk7XHJcbiAgICAvKipcclxuICAgICAqIEdyZWVuICgjMDBGRjAwKVxyXG4gICAgICovXHJcbiAgICBDb2xvci5HcmVlbiA9IENvbG9yLmZyb21IZXgoJyMwMEZGMDAnKTtcclxuICAgIC8qKlxyXG4gICAgICogQ2hhcnRyZXVzZSAoIzdGRkYwMClcclxuICAgICAqL1xyXG4gICAgQ29sb3IuQ2hhcnRyZXVzZSA9IENvbG9yLmZyb21IZXgoJyM3RkZGMDAnKTtcclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNwYXJlbnQgKCNGRkZGRkYwMClcclxuICAgICAqL1xyXG4gICAgQ29sb3IuVHJhbnNwYXJlbnQgPSBDb2xvci5mcm9tSGV4KCcjRkZGRkZGMDAnKTtcclxuICAgIGV4cG9ydHMuQ29sb3IgPSBDb2xvcjtcclxuICAgIC8qKlxyXG4gICAgICogSW50ZXJuYWwgSFNMIENvbG9yIHJlcHJlc2VudGF0aW9uXHJcbiAgICAgKlxyXG4gICAgICogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IU0xfYW5kX0hTVlxyXG4gICAgICogaHR0cDovL2F4b25mbHV4LmNvbS9oYW5keS1yZ2ItdG8taHNsLWFuZC1yZ2ItdG8taHN2LWNvbG9yLW1vZGVsLWNcclxuICAgICAqL1xyXG4gICAgdmFyIEhTTENvbG9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBIU0xDb2xvcihoLCBzLCBsLCBhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaCA9IGg7XHJcbiAgICAgICAgICAgIHRoaXMucyA9IHM7XHJcbiAgICAgICAgICAgIHRoaXMubCA9IGw7XHJcbiAgICAgICAgICAgIHRoaXMuYSA9IGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEhTTENvbG9yLmh1ZTJyZ2IgPSBmdW5jdGlvbiAocCwgcSwgdCkge1xyXG4gICAgICAgICAgICBpZiAodCA8IDApIHtcclxuICAgICAgICAgICAgICAgIHQgKz0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIHQgLT0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodCA8IDEgLyA2KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodCA8IDEgLyAyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodCA8IDIgLyAzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBIU0xDb2xvci5mcm9tUkdCQSA9IGZ1bmN0aW9uIChyLCBnLCBiLCBhKSB7XHJcbiAgICAgICAgICAgIHIgLz0gMjU1O1xyXG4gICAgICAgICAgICBnIC89IDI1NTtcclxuICAgICAgICAgICAgYiAvPSAyNTU7XHJcbiAgICAgICAgICAgIHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKSwgbWluID0gTWF0aC5taW4ociwgZywgYik7XHJcbiAgICAgICAgICAgIHZhciBoLCBzLCBsID0gKG1heCArIG1pbikgLyAyO1xyXG4gICAgICAgICAgICBpZiAobWF4ID09PSBtaW4pIHtcclxuICAgICAgICAgICAgICAgIGggPSBzID0gMDsgLy8gYWNocm9tYXRpY1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBtYXggLSBtaW47XHJcbiAgICAgICAgICAgICAgICBzID0gbCA+IDAuNSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbik7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG1heCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgcjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaCA9IChnIC0gYikgLyBkICsgKGcgPCBiID8gNiA6IDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIGc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSAoYiAtIHIpIC8gZCArIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgYjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaCA9IChyIC0gZykgLyBkICsgNDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBoIC89IDY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBIU0xDb2xvcihoLCBzLCBsLCBhKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEhTTENvbG9yLnByb3RvdHlwZS50b1JHQkEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciByLCBnLCBiO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByID0gZyA9IGIgPSB0aGlzLmw7IC8vIGFjaHJvbWF0aWNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBxID0gdGhpcy5sIDwgMC41ID8gdGhpcy5sICogKDEgKyB0aGlzLnMpIDogdGhpcy5sICsgdGhpcy5zIC0gdGhpcy5sICogdGhpcy5zO1xyXG4gICAgICAgICAgICAgICAgdmFyIHAgPSAyICogdGhpcy5sIC0gcTtcclxuICAgICAgICAgICAgICAgIHIgPSBIU0xDb2xvci5odWUycmdiKHAsIHEsIHRoaXMuaCArIDEgLyAzKTtcclxuICAgICAgICAgICAgICAgIGcgPSBIU0xDb2xvci5odWUycmdiKHAsIHEsIHRoaXMuaCk7XHJcbiAgICAgICAgICAgICAgICBiID0gSFNMQ29sb3IuaHVlMnJnYihwLCBxLCB0aGlzLmggLSAxIC8gMyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihyICogMjU1LCBnICogMjU1LCBiICogMjU1LCB0aGlzLmEpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgSFNMQ29sb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgaCA9IHRoaXMuaC50b0ZpeGVkKDApLCBzID0gdGhpcy5zLnRvRml4ZWQoMCksIGwgPSB0aGlzLmwudG9GaXhlZCgwKSwgYSA9IHRoaXMuYS50b0ZpeGVkKDApO1xyXG4gICAgICAgICAgICByZXR1cm4gXCJoc2xhKFwiICsgaCArIFwiLCBcIiArIHMgKyBcIiwgXCIgKyBsICsgXCIsIFwiICsgYSArIFwiKVwiO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEhTTENvbG9yO1xyXG4gICAgfSgpKTtcclxufSk7XHJcbmRlZmluZShcIkNvbGxpc2lvbi9Db2xsaXNpb25Db250YWN0XCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiQWN0b3JcIiwgXCJBbGdlYnJhXCIsIFwiUGh5c2ljc1wiLCBcIkV2ZW50c1wiLCBcIlV0aWwvVXRpbFwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIEFjdG9yXzEsIEFsZ2VicmFfNCwgUGh5c2ljc18xLCBFdmVudHNfMSwgVXRpbCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIENvbGxpc2lvbiBjb250YWN0cyBhcmUgdXNlZCBpbnRlcm5hbGx5IGJ5IEV4Y2FsaWJ1ciB0byByZXNvbHZlIGNvbGxpc2lvbiBiZXR3ZWVuIGFjdG9ycy4gVGhpc1xyXG4gICAgICogUGFpciBwcmV2ZW50cyBjb2xsaXNpb25zIGZyb20gYmVpbmcgZXZhbHVhdGVkIG1vcmUgdGhhbiBvbmUgdGltZVxyXG4gICAgICovXHJcbiAgICB2YXIgQ29sbGlzaW9uQ29udGFjdCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gQ29sbGlzaW9uQ29udGFjdChib2R5QSwgYm9keUIsIG10diwgcG9pbnQsIG5vcm1hbCkge1xyXG4gICAgICAgICAgICB0aGlzLmJvZHlBID0gYm9keUE7XHJcbiAgICAgICAgICAgIHRoaXMuYm9keUIgPSBib2R5QjtcclxuICAgICAgICAgICAgdGhpcy5tdHYgPSBtdHY7XHJcbiAgICAgICAgICAgIHRoaXMucG9pbnQgPSBwb2ludDtcclxuICAgICAgICAgICAgdGhpcy5ub3JtYWwgPSBub3JtYWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIENvbGxpc2lvbkNvbnRhY3QucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAoc3RyYXRlZ3kpIHtcclxuICAgICAgICAgICAgaWYgKHN0cmF0ZWd5ID09PSBQaHlzaWNzXzEuQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5LlJpZ2lkQm9keSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZVJpZ2lkQm9keUNvbGxpc2lvbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0cmF0ZWd5ID09PSBQaHlzaWNzXzEuQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5LkJveCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZUJveENvbGxpc2lvbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGNvbGxpc2lvbiByZXNvbHV0aW9uIHN0cmF0ZWd5Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIENvbGxpc2lvbkNvbnRhY3QucHJvdG90eXBlLl9hcHBseUJveEltcHVsc2UgPSBmdW5jdGlvbiAoYm9keUEsIGJvZHlCLCBtdHYpIHtcclxuICAgICAgICAgICAgaWYgKGJvZHlBLmNvbGxpc2lvblR5cGUgPT09IEFjdG9yXzEuQ29sbGlzaW9uVHlwZS5BY3RpdmUgJiZcclxuICAgICAgICAgICAgICAgIGJvZHlCLmNvbGxpc2lvblR5cGUgIT09IEFjdG9yXzEuQ29sbGlzaW9uVHlwZS5QYXNzaXZlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZXNvbHZlIG92ZXJsYXBzXHJcbiAgICAgICAgICAgICAgICBpZiAoYm9keUEuY29sbGlzaW9uVHlwZSA9PT0gQWN0b3JfMS5Db2xsaXNpb25UeXBlLkFjdGl2ZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlCLmNvbGxpc2lvblR5cGUgPT09IEFjdG9yXzEuQ29sbGlzaW9uVHlwZS5BY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBzcGxpdCBvdmVybGFwcyBpZiBib3RoIGFyZSBBY3RpdmVcclxuICAgICAgICAgICAgICAgICAgICBtdHYgPSBtdHYuc2NhbGUoLjUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgbXR2XHJcbiAgICAgICAgICAgICAgICBib2R5QS5wb3MueSArPSBtdHYueTtcclxuICAgICAgICAgICAgICAgIGJvZHlBLnBvcy54ICs9IG10di54O1xyXG4gICAgICAgICAgICAgICAgLy8gbm9uLXplcm8gaW50ZXJzZWN0aW9uIG9uIHRoZSB5IGF4aXNcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm10di54ICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZlbFggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGJvdGggYm9kaWVzIGFyZSB0cmF2ZWxpbmcgaW4gdGhlIHNhbWUgZGlyZWN0aW9uIChuZWdhdGl2ZSBvciBwb3NpdGl2ZSlcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYm9keUEudmVsLnggPCAwICYmIGJvZHlCLnZlbC54IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWxYID0gTWF0aC5taW4oYm9keUEudmVsLngsIGJvZHlCLnZlbC54KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYm9keUEudmVsLnggPiAwICYmIGJvZHlCLnZlbC54ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWxYID0gTWF0aC5tYXgoYm9keUEudmVsLngsIGJvZHlCLnZlbC54KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYm9keUIuY29sbGlzaW9uVHlwZSA9PT0gQWN0b3JfMS5Db2xsaXNpb25UeXBlLkZpeGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJvZGllcyBhcmUgdHJhdmVsaW5nIGluIG9wcG9zaXRlIGRpcmVjdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJvZHlBLnBvcy5zdWIoYm9keUIucG9zKS5kb3QoYm9keUEudmVsKSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlbFggPSBib2R5QS52ZWwueDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJvZHlBIGlzIGhlYWRpbmcgdG93YXJkcyBiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWxYID0gYm9keUIudmVsLng7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keUEudmVsLnggPSB2ZWxYO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubXR2LnkgIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmVsWSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYm90aCBib2RpZXMgYXJlIHRyYXZlbGluZyBpbiB0aGUgc2FtZSBkaXJlY3Rpb24gKG5lZ2F0aXZlIG9yIHBvc2l0aXZlKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChib2R5QS52ZWwueSA8IDAgJiYgYm9keUIudmVsLnkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlbFkgPSBNYXRoLm1pbihib2R5QS52ZWwueSwgYm9keUIudmVsLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChib2R5QS52ZWwueSA+IDAgJiYgYm9keUIudmVsLnkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlbFkgPSBNYXRoLm1heChib2R5QS52ZWwueSwgYm9keUIudmVsLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChib2R5Qi5jb2xsaXNpb25UeXBlID09PSBBY3Rvcl8xLkNvbGxpc2lvblR5cGUuRml4ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYm9kaWVzIGFyZSB0cmF2ZWxpbmcgaW4gb3Bwb3NpdGUgZGlyZWN0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYm9keUEucG9zLnN1Yihib2R5Qi5wb3MpLmRvdChib2R5QS52ZWwpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVsWSA9IGJvZHlBLnZlbC55O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYm9keUEgaXMgaGVhZGluZyB0b3dhcmRzIGJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlbFkgPSBib2R5Qi52ZWwueTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBib2R5QS52ZWwueSA9IHZlbFk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBib2R5QS5lbWl0KCdwb3N0Y29sbGlzaW9uJywgbmV3IEV2ZW50c18xLlBvc3RDb2xsaXNpb25FdmVudChib2R5QSwgYm9keUIsIFV0aWwuZ2V0U2lkZUZyb21WZWN0b3IobXR2KSwgbXR2KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIENvbGxpc2lvbkNvbnRhY3QucHJvdG90eXBlLl9yZXNvbHZlQm94Q29sbGlzaW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYm9keUEgPSB0aGlzLmJvZHlBLmJvZHkuYWN0b3I7XHJcbiAgICAgICAgICAgIHZhciBib2R5QiA9IHRoaXMuYm9keUIuYm9keS5hY3RvcjtcclxuICAgICAgICAgICAgdmFyIHNpZGUgPSBVdGlsLmdldFNpZGVGcm9tVmVjdG9yKHRoaXMubXR2KTtcclxuICAgICAgICAgICAgdmFyIG10diA9IHRoaXMubXR2Lm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAvLyBQdWJsaXNoIGNvbGxpc2lvbiBldmVudHMgb24gYm90aCBwYXJ0aWNpcGFudHNcclxuICAgICAgICAgICAgYm9keUEuZW1pdCgncHJlY29sbGlzaW9uJywgbmV3IEV2ZW50c18xLlByZUNvbGxpc2lvbkV2ZW50KGJvZHlBLCBib2R5Qiwgc2lkZSwgbXR2KSk7XHJcbiAgICAgICAgICAgIGJvZHlCLmVtaXQoJ3ByZWNvbGxpc2lvbicsIG5ldyBFdmVudHNfMS5QcmVDb2xsaXNpb25FdmVudChib2R5QiwgYm9keUEsIFV0aWwuZ2V0T3Bwb3NpdGVTaWRlKHNpZGUpLCBtdHYubmVnYXRlKCkpKTtcclxuICAgICAgICAgICAgdGhpcy5fYXBwbHlCb3hJbXB1bHNlKGJvZHlBLCBib2R5QiwgbXR2KTtcclxuICAgICAgICAgICAgdGhpcy5fYXBwbHlCb3hJbXB1bHNlKGJvZHlCLCBib2R5QSwgbXR2Lm5lZ2F0ZSgpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIENvbGxpc2lvbkNvbnRhY3QucHJvdG90eXBlLl9yZXNvbHZlUmlnaWRCb2R5Q29sbGlzaW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBwZXJmb3JtIGNvbGxpc29uIG9uIGJvdW5kaW5nIGFyZWFzXHJcbiAgICAgICAgICAgIHZhciBib2R5QSA9IHRoaXMuYm9keUEuYm9keTtcclxuICAgICAgICAgICAgdmFyIGJvZHlCID0gdGhpcy5ib2R5Qi5ib2R5O1xyXG4gICAgICAgICAgICB2YXIgbXR2ID0gdGhpcy5tdHY7IC8vIG5vcm1hbCBwb2ludGluZyBhd2F5IGZyb20gYm9keUFcclxuICAgICAgICAgICAgdmFyIG5vcm1hbCA9IHRoaXMubm9ybWFsOyAvLyBub3JtYWwgcG9pbnRpbmcgYXdheSBmcm9tIGJvZHlBXHJcbiAgICAgICAgICAgIGlmIChib2R5QS5hY3RvciA9PT0gYm9keUIuYWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBQdWJsaXNoIGNvbGxpc2lvbiBldmVudHMgb24gYm90aCBwYXJ0aWNpcGFudHNcclxuICAgICAgICAgICAgdmFyIHNpZGUgPSBVdGlsLmdldFNpZGVGcm9tVmVjdG9yKHRoaXMubXR2KTtcclxuICAgICAgICAgICAgYm9keUEuYWN0b3IuZW1pdCgncHJlY29sbGlzaW9uJywgbmV3IEV2ZW50c18xLlByZUNvbGxpc2lvbkV2ZW50KHRoaXMuYm9keUEuYm9keS5hY3RvciwgdGhpcy5ib2R5Qi5ib2R5LmFjdG9yLCBzaWRlLCB0aGlzLm10dikpO1xyXG4gICAgICAgICAgICBib2R5Qi5hY3Rvci5lbWl0KCdwcmVjb2xsaXNpb24nLCBuZXcgRXZlbnRzXzEuUHJlQ29sbGlzaW9uRXZlbnQodGhpcy5ib2R5Qi5ib2R5LmFjdG9yLCB0aGlzLmJvZHlBLmJvZHkuYWN0b3IsIFV0aWwuZ2V0T3Bwb3NpdGVTaWRlKHNpZGUpLCB0aGlzLm10di5uZWdhdGUoKSkpO1xyXG4gICAgICAgICAgICAvLyBJZiBhbnkgb2YgdGhlIHBhcnRpY2lwYW50cyBhcmUgcGFzc2l2ZSB0aGVuIHNob3J0IGNpcmN1aXRcclxuICAgICAgICAgICAgaWYgKGJvZHlBLmFjdG9yLmNvbGxpc2lvblR5cGUgPT09IEFjdG9yXzEuQ29sbGlzaW9uVHlwZS5QYXNzaXZlIHx8XHJcbiAgICAgICAgICAgICAgICBib2R5Qi5hY3Rvci5jb2xsaXNpb25UeXBlID09PSBBY3Rvcl8xLkNvbGxpc2lvblR5cGUuUGFzc2l2ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpbnZNYXNzQSA9IGJvZHlBLmFjdG9yLmNvbGxpc2lvblR5cGUgPT09IEFjdG9yXzEuQ29sbGlzaW9uVHlwZS5GaXhlZCA/IDAgOiAxIC8gYm9keUEubWFzcztcclxuICAgICAgICAgICAgdmFyIGludk1hc3NCID0gYm9keUIuYWN0b3IuY29sbGlzaW9uVHlwZSA9PT0gQWN0b3JfMS5Db2xsaXNpb25UeXBlLkZpeGVkID8gMCA6IDEgLyBib2R5Qi5tYXNzO1xyXG4gICAgICAgICAgICB2YXIgaW52TW9pQSA9IGJvZHlBLmFjdG9yLmNvbGxpc2lvblR5cGUgPT09IEFjdG9yXzEuQ29sbGlzaW9uVHlwZS5GaXhlZCA/IDAgOiAxIC8gYm9keUEubW9pO1xyXG4gICAgICAgICAgICB2YXIgaW52TW9pQiA9IGJvZHlCLmFjdG9yLmNvbGxpc2lvblR5cGUgPT09IEFjdG9yXzEuQ29sbGlzaW9uVHlwZS5GaXhlZCA/IDAgOiAxIC8gYm9keUIubW9pO1xyXG4gICAgICAgICAgICAvLyBhdmVyYWdlIHJlc3RpdHV0aW9uIG1vcmUgcmVsaXN0aWNcclxuICAgICAgICAgICAgdmFyIGNvZWZSZXN0aXR1dGlvbiA9IE1hdGgubWluKGJvZHlBLnJlc3RpdHV0aW9uLCBib2R5Qi5yZXN0aXR1dGlvbik7XHJcbiAgICAgICAgICAgIHZhciBjb2VmRnJpY3Rpb24gPSBNYXRoLm1pbihib2R5QS5mcmljdGlvbiwgYm9keUIuZnJpY3Rpb24pO1xyXG4gICAgICAgICAgICBub3JtYWwgPSBub3JtYWwubm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgIHZhciB0YW5nZW50ID0gbm9ybWFsLm5vcm1hbCgpLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICB2YXIgcmEgPSB0aGlzLnBvaW50LnN1Yih0aGlzLmJvZHlBLmdldENlbnRlcigpKTsgLy8gcG9pbnQgcmVsYXRpdmUgdG8gYm9keUEgcG9zaXRpb25cclxuICAgICAgICAgICAgdmFyIHJiID0gdGhpcy5wb2ludC5zdWIodGhpcy5ib2R5Qi5nZXRDZW50ZXIoKSk7IC8vLyBwb2ludCByZWxhdGl2ZSB0byBib2R5QlxyXG4gICAgICAgICAgICAvLyBSZWxhdGl2ZSB2ZWxvY2l0eSBpbiBsaW5lYXIgdGVybXNcclxuICAgICAgICAgICAgLy8gQW5ndWxhciB0byBsaW5lYXIgdmVsb2NpdHkgZm9ybXVsYSAtPiBvbWVnYSA9IHYvclxyXG4gICAgICAgICAgICB2YXIgcnYgPSBib2R5Qi52ZWwuYWRkKHJiLmNyb3NzKC1ib2R5Qi5yeCkpLnN1Yihib2R5QS52ZWwuc3ViKHJhLmNyb3NzKGJvZHlBLnJ4KSkpO1xyXG4gICAgICAgICAgICB2YXIgcnZOb3JtYWwgPSBydi5kb3Qobm9ybWFsKTtcclxuICAgICAgICAgICAgdmFyIHJ2VGFuZ2VudCA9IHJ2LmRvdCh0YW5nZW50KTtcclxuICAgICAgICAgICAgdmFyIHJhVGFuZ2VudCA9IHJhLmRvdCh0YW5nZW50KTtcclxuICAgICAgICAgICAgdmFyIHJhTm9ybWFsID0gcmEuZG90KG5vcm1hbCk7XHJcbiAgICAgICAgICAgIHZhciByYlRhbmdlbnQgPSByYi5kb3QodGFuZ2VudCk7XHJcbiAgICAgICAgICAgIHZhciByYk5vcm1hbCA9IHJiLmRvdChub3JtYWwpO1xyXG4gICAgICAgICAgICAvLyBJZiBvYmplY3RzIGFyZSBtb3ZpbmcgYXdheSBpZ25vcmVcclxuICAgICAgICAgICAgaWYgKHJ2Tm9ybWFsID4gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIENvbGxpc2lvbiBpbXB1bHNlIGZvcm11bGEgZnJvbSBDaHJpcyBIZWNrZXJcclxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29sbGlzaW9uX3Jlc3BvbnNlXHJcbiAgICAgICAgICAgIHZhciBpbXB1bHNlID0gLSgoMSArIGNvZWZSZXN0aXR1dGlvbikgKiBydk5vcm1hbCkgL1xyXG4gICAgICAgICAgICAgICAgKChpbnZNYXNzQSArIGludk1hc3NCKSArIGludk1vaUEgKiByYVRhbmdlbnQgKiByYVRhbmdlbnQgKyBpbnZNb2lCICogcmJUYW5nZW50ICogcmJUYW5nZW50KTtcclxuICAgICAgICAgICAgaWYgKGJvZHlBLmFjdG9yLmNvbGxpc2lvblR5cGUgPT09IEFjdG9yXzEuQ29sbGlzaW9uVHlwZS5GaXhlZCkge1xyXG4gICAgICAgICAgICAgICAgYm9keUIudmVsID0gYm9keUIudmVsLmFkZChub3JtYWwuc2NhbGUoaW1wdWxzZSAqIGludk1hc3NCKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoUGh5c2ljc18xLlBoeXNpY3MuYWxsb3dSaWdpZEJvZHlSb3RhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlCLnJ4IC09IGltcHVsc2UgKiBpbnZNb2lCICogLXJiLmNyb3NzKG5vcm1hbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBib2R5Qi5hZGRNdHYobXR2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChib2R5Qi5hY3Rvci5jb2xsaXNpb25UeXBlID09PSBBY3Rvcl8xLkNvbGxpc2lvblR5cGUuRml4ZWQpIHtcclxuICAgICAgICAgICAgICAgIGJvZHlBLnZlbCA9IGJvZHlBLnZlbC5zdWIobm9ybWFsLnNjYWxlKGltcHVsc2UgKiBpbnZNYXNzQSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKFBoeXNpY3NfMS5QaHlzaWNzLmFsbG93UmlnaWRCb2R5Um90YXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBib2R5QS5yeCArPSBpbXB1bHNlICogaW52TW9pQSAqIC1yYS5jcm9zcyhub3JtYWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYm9keUEuYWRkTXR2KG10di5uZWdhdGUoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBib2R5Qi52ZWwgPSBib2R5Qi52ZWwuYWRkKG5vcm1hbC5zY2FsZShpbXB1bHNlICogaW52TWFzc0IpKTtcclxuICAgICAgICAgICAgICAgIGJvZHlBLnZlbCA9IGJvZHlBLnZlbC5zdWIobm9ybWFsLnNjYWxlKGltcHVsc2UgKiBpbnZNYXNzQSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKFBoeXNpY3NfMS5QaHlzaWNzLmFsbG93UmlnaWRCb2R5Um90YXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBib2R5Qi5yeCAtPSBpbXB1bHNlICogaW52TW9pQiAqIC1yYi5jcm9zcyhub3JtYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlBLnJ4ICs9IGltcHVsc2UgKiBpbnZNb2lBICogLXJhLmNyb3NzKG5vcm1hbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCB0aGUgbXR2IGluIGhhbGYgZm9yIHRoZSB0d28gYm9kaWVzLCBwb3RlbnRpYWxseSB3ZSBjb3VsZCBkbyBzb21ldGhpbmcgc21hcnRlciBoZXJlXHJcbiAgICAgICAgICAgICAgICBib2R5Qi5hZGRNdHYobXR2LnNjYWxlKC41KSk7XHJcbiAgICAgICAgICAgICAgICBib2R5QS5hZGRNdHYobXR2LnNjYWxlKC0uNSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEZyaWN0aW9uIHBvcnRpb24gb2YgaW1wdWxzZVxyXG4gICAgICAgICAgICBpZiAoY29lZkZyaWN0aW9uICYmIHJ2VGFuZ2VudCkge1xyXG4gICAgICAgICAgICAgICAgLy8gQ29sdW1iIG1vZGVsIG9mIGZyaWN0aW9uLCBmb3JtdWxhIGZvciBpbXB1bHNlIGR1ZSB0byBmcmljdGlvbiBmcm9tICBcclxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbGxpc2lvbl9yZXNwb25zZVxyXG4gICAgICAgICAgICAgICAgLy8gdGFuZ2VudCBmb3JjZSBleGVydGVkIGJ5IGJvZHkgb24gYW5vdGhlciBpbiBjb250YWN0XHJcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHJ2LnN1Yihub3JtYWwuc2NhbGUocnYuZG90KG5vcm1hbCkpKS5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgICAgIC8vIGltcHVsc2UgaW4gdGhlIGRpcmVjdGlvbiBvZiB0YW5nZW50IGZvcmNlXHJcbiAgICAgICAgICAgICAgICB2YXIganQgPSBydi5kb3QodCkgLyAoaW52TWFzc0EgKyBpbnZNYXNzQiArIHJhTm9ybWFsICogcmFOb3JtYWwgKiBpbnZNb2lBICsgcmJOb3JtYWwgKiByYk5vcm1hbCAqIGludk1vaUIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZyaWN0aW9uSW1wdWxzZSA9IG5ldyBBbGdlYnJhXzQuVmVjdG9yKDAsIDApO1xyXG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGp0KSA8PSBpbXB1bHNlICogY29lZkZyaWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnJpY3Rpb25JbXB1bHNlID0gdC5zY2FsZShqdCkubmVnYXRlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmcmljdGlvbkltcHVsc2UgPSB0LnNjYWxlKC1pbXB1bHNlICogY29lZkZyaWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChib2R5QS5hY3Rvci5jb2xsaXNpb25UeXBlID09PSBBY3Rvcl8xLkNvbGxpc2lvblR5cGUuRml4ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhcHBseSBmcmljdGlvbmFsIGltcHVsc2VcclxuICAgICAgICAgICAgICAgICAgICBib2R5Qi52ZWwgPSBib2R5Qi52ZWwuYWRkKGZyaWN0aW9uSW1wdWxzZS5zY2FsZShpbnZNYXNzQikpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChQaHlzaWNzXzEuUGh5c2ljcy5hbGxvd1JpZ2lkQm9keVJvdGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlCLnJ4ICs9IGZyaWN0aW9uSW1wdWxzZS5kb3QodCkgKiBpbnZNb2lCICogcmIuY3Jvc3ModCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYm9keUIuYWN0b3IuY29sbGlzaW9uVHlwZSA9PT0gQWN0b3JfMS5Db2xsaXNpb25UeXBlLkZpeGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXBwbHkgZnJpY3Rpb25hbCBpbXB1bHNlXHJcbiAgICAgICAgICAgICAgICAgICAgYm9keUEudmVsID0gYm9keUEudmVsLnN1YihmcmljdGlvbkltcHVsc2Uuc2NhbGUoaW52TWFzc0EpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoUGh5c2ljc18xLlBoeXNpY3MuYWxsb3dSaWdpZEJvZHlSb3RhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5QS5yeCAtPSBmcmljdGlvbkltcHVsc2UuZG90KHQpICogaW52TW9pQSAqIHJhLmNyb3NzKHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFwcGx5IGZyaWN0aW9uYWwgaW1wdWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlCLnZlbCA9IGJvZHlCLnZlbC5hZGQoZnJpY3Rpb25JbXB1bHNlLnNjYWxlKGludk1hc3NCKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keUEudmVsID0gYm9keUEudmVsLnN1YihmcmljdGlvbkltcHVsc2Uuc2NhbGUoaW52TWFzc0EpKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhcHBseSBmcmljdGlvbmFsIGltcHVsc2VcclxuICAgICAgICAgICAgICAgICAgICBpZiAoUGh5c2ljc18xLlBoeXNpY3MuYWxsb3dSaWdpZEJvZHlSb3RhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5Qi5yeCArPSBmcmljdGlvbkltcHVsc2UuZG90KHQpICogaW52TW9pQiAqIHJiLmNyb3NzKHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5QS5yeCAtPSBmcmljdGlvbkltcHVsc2UuZG90KHQpICogaW52TW9pQSAqIHJhLmNyb3NzKHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBib2R5QS5hY3Rvci5lbWl0KCdwb3N0Y29sbGlzaW9uJywgbmV3IEV2ZW50c18xLlBvc3RDb2xsaXNpb25FdmVudCh0aGlzLmJvZHlBLmJvZHkuYWN0b3IsIHRoaXMuYm9keUIuYm9keS5hY3Rvciwgc2lkZSwgdGhpcy5tdHYpKTtcclxuICAgICAgICAgICAgYm9keUIuYWN0b3IuZW1pdCgncG9zdGNvbGxpc2lvbicsIG5ldyBFdmVudHNfMS5Qb3N0Q29sbGlzaW9uRXZlbnQodGhpcy5ib2R5Qi5ib2R5LmFjdG9yLCB0aGlzLmJvZHlBLmJvZHkuYWN0b3IsIFV0aWwuZ2V0T3Bwb3NpdGVTaWRlKHNpZGUpLCB0aGlzLm10di5uZWdhdGUoKSkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIENvbGxpc2lvbkNvbnRhY3Q7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5Db2xsaXNpb25Db250YWN0ID0gQ29sbGlzaW9uQ29udGFjdDtcclxufSk7XHJcbmRlZmluZShcIkNvbGxpc2lvbi9JQ29sbGlzaW9uQXJlYVwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG59KTtcclxuZGVmaW5lKFwiQ29sbGlzaW9uL0NpcmNsZUFyZWFcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJDb2xsaXNpb24vQm91bmRpbmdCb3hcIiwgXCJDb2xsaXNpb24vUG9seWdvbkFyZWFcIiwgXCJDb2xsaXNpb24vRWRnZUFyZWFcIiwgXCJDb2xsaXNpb24vQ29sbGlzaW9uSnVtcFRhYmxlXCIsIFwiQWxnZWJyYVwiLCBcIlBoeXNpY3NcIiwgXCJEcmF3aW5nL0NvbG9yXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgQm91bmRpbmdCb3hfMSwgUG9seWdvbkFyZWFfMSwgRWRnZUFyZWFfMSwgQ29sbGlzaW9uSnVtcFRhYmxlXzEsIEFsZ2VicmFfNSwgUGh5c2ljc18yLCBDb2xvcl8xKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBpcyBhIGNpcmNsZSBjb2xsaXNpb24gYXJlYSBmb3IgdGhlIGV4Y2FsaWJ1ciByaWdpZCBib2R5IHBoeXNpY3Mgc2ltdWxhdGlvblxyXG4gICAgICovXHJcbiAgICB2YXIgQ2lyY2xlQXJlYSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gQ2lyY2xlQXJlYShvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGlzIGlzIHRoZSBjZW50ZXIgcG9zaXRpb24gb2YgdGhlIGNpcmNsZSwgcmVsYXRpdmUgdG8gdGhlIGJvZHkgcG9zaXRpb25cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMucG9zID0gQWxnZWJyYV81LlZlY3Rvci5aZXJvLmNsb25lKCk7XHJcbiAgICAgICAgICAgIHRoaXMucG9zID0gb3B0aW9ucy5wb3MgfHwgQWxnZWJyYV81LlZlY3Rvci5aZXJvLmNsb25lKCk7XHJcbiAgICAgICAgICAgIHRoaXMucmFkaXVzID0gb3B0aW9ucy5yYWRpdXMgfHwgMDtcclxuICAgICAgICAgICAgdGhpcy5ib2R5ID0gb3B0aW9ucy5ib2R5IHx8IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCB0aGUgY2VudGVyIG9mIHRoZSBjb2xsaXNpb24gYXJlYSBpbiB3b3JsZCBjb29yZGluYXRlc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENpcmNsZUFyZWEucHJvdG90eXBlLmdldENlbnRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYm9keSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zLmFkZCh0aGlzLmJvZHkucG9zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3M7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZXN0cyBpZiBhIHBvaW50IGlzIGNvbnRhaW5lZCBpbiB0aGlzIGNvbGxpc2lvbiBhcmVhXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2lyY2xlQXJlYS5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAocG9pbnQpIHtcclxuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gdGhpcy5ib2R5LnBvcy5kaXN0YW5jZShwb2ludCk7XHJcbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8PSB0aGlzLnJhZGl1cykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FzdHMgYSByYXkgYXQgdGhlIENpcmNsZUFyZWEgYW5kIHJldHVybnMgdGhlIG5lYXJlc3QgcG9pbnQgb2YgY29sbGlzaW9uXHJcbiAgICAgICAgICogQHBhcmFtIHJheVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENpcmNsZUFyZWEucHJvdG90eXBlLnJheUNhc3QgPSBmdW5jdGlvbiAocmF5LCBtYXgpIHtcclxuICAgICAgICAgICAgaWYgKG1heCA9PT0gdm9pZCAwKSB7IG1heCA9IEluZmluaXR5OyB9XHJcbiAgICAgICAgICAgIC8vaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGluZSVFMiU4MCU5M3NwaGVyZV9pbnRlcnNlY3Rpb25cclxuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmdldENlbnRlcigpO1xyXG4gICAgICAgICAgICB2YXIgZGlyID0gcmF5LmRpcjtcclxuICAgICAgICAgICAgdmFyIG9yaWcgPSByYXkucG9zO1xyXG4gICAgICAgICAgICB2YXIgZGlzY3JpbWluYW50ID0gTWF0aC5zcXJ0KE1hdGgucG93KGRpci5kb3Qob3JpZy5zdWIoYykpLCAyKSAtXHJcbiAgICAgICAgICAgICAgICBNYXRoLnBvdyhvcmlnLnN1YihjKS5kaXN0YW5jZSgpLCAyKSArXHJcbiAgICAgICAgICAgICAgICBNYXRoLnBvdyh0aGlzLnJhZGl1cywgMikpO1xyXG4gICAgICAgICAgICBpZiAoZGlzY3JpbWluYW50IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gbm8gaW50ZXJzZWN0aW9uXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciB0b2kgPSAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpc2NyaW1pbmFudCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvaSA9IC1kaXIuZG90KG9yaWcuc3ViKGMpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9pID4gMCAmJiB0b2kgPCBtYXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJheS5nZXRQb2ludCh0b2kpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0b2kxID0gLWRpci5kb3Qob3JpZy5zdWIoYykpICsgZGlzY3JpbWluYW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0b2kyID0gLWRpci5kb3Qob3JpZy5zdWIoYykpIC0gZGlzY3JpbWluYW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtaW50b2kgPSBNYXRoLm1pbih0b2kxLCB0b2kyKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWludG9pIDw9IG1heCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmF5LmdldFBvaW50KG1pbnRvaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAaW5oZXJpdGRvY1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENpcmNsZUFyZWEucHJvdG90eXBlLmNvbGxpZGUgPSBmdW5jdGlvbiAoYXJlYSkge1xyXG4gICAgICAgICAgICBpZiAoYXJlYSBpbnN0YW5jZW9mIENpcmNsZUFyZWEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDb2xsaXNpb25KdW1wVGFibGVfMS5Db2xsaXNpb25KdW1wVGFibGUuQ29sbGlkZUNpcmNsZUNpcmNsZSh0aGlzLCBhcmVhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChhcmVhIGluc3RhbmNlb2YgUG9seWdvbkFyZWFfMS5Qb2x5Z29uQXJlYSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbGxpc2lvbkp1bXBUYWJsZV8xLkNvbGxpc2lvbkp1bXBUYWJsZS5Db2xsaWRlQ2lyY2xlUG9seWdvbih0aGlzLCBhcmVhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChhcmVhIGluc3RhbmNlb2YgRWRnZUFyZWFfMS5FZGdlQXJlYSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbGxpc2lvbkp1bXBUYWJsZV8xLkNvbGxpc2lvbkp1bXBUYWJsZS5Db2xsaWRlQ2lyY2xlRWRnZSh0aGlzLCBhcmVhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNpcmNsZSBjb3VsZCBub3QgY29sbGlkZSB3aXRoIHVua25vd24gSUNvbGxpc2lvbkFyZWEgXCIgKyB0eXBlb2YgYXJlYSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZpbmQgdGhlIHBvaW50IG9uIHRoZSBzaGFwZSBmdXJ0aGVzdCBpbiB0aGUgZGlyZWN0aW9uIHNwZWNpZmllZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENpcmNsZUFyZWEucHJvdG90eXBlLmdldEZ1cnRoZXN0UG9pbnQgPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENlbnRlcigpLmFkZChkaXJlY3Rpb24ubm9ybWFsaXplKCkuc2NhbGUodGhpcy5yYWRpdXMpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCB0aGUgYXhpcyBhbGlnbmVkIGJvdW5kaW5nIGJveCBmb3IgdGhlIGNpcmNsZSBhcmVhXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2lyY2xlQXJlYS5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJvdW5kaW5nQm94XzEuQm91bmRpbmdCb3godGhpcy5wb3MueCArIHRoaXMuYm9keS5wb3MueCAtIHRoaXMucmFkaXVzLCB0aGlzLnBvcy55ICsgdGhpcy5ib2R5LnBvcy55IC0gdGhpcy5yYWRpdXMsIHRoaXMucG9zLnggKyB0aGlzLmJvZHkucG9zLnggKyB0aGlzLnJhZGl1cywgdGhpcy5wb3MueSArIHRoaXMuYm9keS5wb3MueSArIHRoaXMucmFkaXVzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCBheGlzIG5vdCBpbXBsZW1lbnRlZCBvbiBjaXJjbGVzLCBzaW5jZSB0aGVyZSBhcmUgaW5maW5pdGUgYXhpcyBpbiBhIGNpcmNsZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENpcmNsZUFyZWEucHJvdG90eXBlLmdldEF4ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgbW9tZW50IG9mIGluZXJ0aWEgb2YgYSBjaXJjbGUgZ2l2ZW4gaXQncyBtYXNzXHJcbiAgICAgICAgICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGlzdF9vZl9tb21lbnRzX29mX2luZXJ0aWFcclxuICAgICAgICAgKi9cclxuICAgICAgICBDaXJjbGVBcmVhLnByb3RvdHlwZS5nZXRNb21lbnRPZkluZXJ0aWEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBtYXNzID0gdGhpcy5ib2R5ID8gdGhpcy5ib2R5Lm1hc3MgOiBQaHlzaWNzXzIuUGh5c2ljcy5kZWZhdWx0TWFzcztcclxuICAgICAgICAgICAgcmV0dXJuIChtYXNzICogdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cykgLyAyO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVzdHMgdGhlIHNlcGFyYXRpbmcgYXhpcyB0aGVvcmVtIGZvciBjaXJjbGVzIGFnYWluc3QgcG9seWdvbnNcclxuICAgICAgICAgKi9cclxuICAgICAgICBDaXJjbGVBcmVhLnByb3RvdHlwZS50ZXN0U2VwYXJhdGluZ0F4aXNUaGVvcmVtID0gZnVuY3Rpb24gKHBvbHlnb24pIHtcclxuICAgICAgICAgICAgdmFyIGF4ZXMgPSBwb2x5Z29uLmdldEF4ZXMoKTtcclxuICAgICAgICAgICAgdmFyIHBjID0gcG9seWdvbi5nZXRDZW50ZXIoKTtcclxuICAgICAgICAgICAgLy8gU3BlY2lhbCBTQVQgd2l0aCBjaXJjbGVzXHJcbiAgICAgICAgICAgIHZhciBjbG9zZXN0UG9pbnRPblBvbHkgPSBwb2x5Z29uLmdldEZ1cnRoZXN0UG9pbnQodGhpcy5wb3Muc3ViKHBjKSk7XHJcbiAgICAgICAgICAgIGF4ZXMucHVzaCh0aGlzLnBvcy5zdWIoY2xvc2VzdFBvaW50T25Qb2x5KS5ub3JtYWxpemUoKSk7XHJcbiAgICAgICAgICAgIHZhciBtaW5PdmVybGFwID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICAgICAgdmFyIG1pbkF4aXMgPSBudWxsO1xyXG4gICAgICAgICAgICB2YXIgbWluSW5kZXggPSAtMTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBheGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJvajEgPSBwb2x5Z29uLnByb2plY3QoYXhlc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJvajIgPSB0aGlzLnByb2plY3QoYXhlc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3ZlcmxhcCA9IHByb2oxLmdldE92ZXJsYXAocHJvajIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXAgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJsYXAgPCBtaW5PdmVybGFwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbk92ZXJsYXAgPSBvdmVybGFwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5BeGlzID0gYXhlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluSW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWluSW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbWluQXhpcy5ub3JtYWxpemUoKS5zY2FsZShtaW5PdmVybGFwKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgQ2lyY2xlQXJlYS5wcm90b3R5cGUucmVjYWxjID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBjaXJjbGVzIGRvbid0IGNhY2hlXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcm9qZWN0IHRoZSBjaXJjbGUgYWxvbmcgYSBzcGVjaWZpZWQgYXhpc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENpcmNsZUFyZWEucHJvdG90eXBlLnByb2plY3QgPSBmdW5jdGlvbiAoYXhpcykge1xyXG4gICAgICAgICAgICB2YXIgc2NhbGFycyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgcG9pbnQgPSB0aGlzLmdldENlbnRlcigpO1xyXG4gICAgICAgICAgICB2YXIgZG90UHJvZHVjdCA9IHBvaW50LmRvdChheGlzKTtcclxuICAgICAgICAgICAgc2NhbGFycy5wdXNoKGRvdFByb2R1Y3QpO1xyXG4gICAgICAgICAgICBzY2FsYXJzLnB1c2goZG90UHJvZHVjdCArIHRoaXMucmFkaXVzKTtcclxuICAgICAgICAgICAgc2NhbGFycy5wdXNoKGRvdFByb2R1Y3QgLSB0aGlzLnJhZGl1cyk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWxnZWJyYV81LlByb2plY3Rpb24oTWF0aC5taW4uYXBwbHkoTWF0aCwgc2NhbGFycyksIE1hdGgubWF4LmFwcGx5KE1hdGgsIHNjYWxhcnMpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgQ2lyY2xlQXJlYS5wcm90b3R5cGUuZGVidWdEcmF3ID0gZnVuY3Rpb24gKGN0eCwgY29sb3IpIHtcclxuICAgICAgICAgICAgaWYgKGNvbG9yID09PSB2b2lkIDApIHsgY29sb3IgPSBDb2xvcl8xLkNvbG9yLkdyZWVuLmNsb25lKCk7IH1cclxuICAgICAgICAgICAgdmFyIHBvcyA9IHRoaXMuYm9keSA/IHRoaXMuYm9keS5wb3MuYWRkKHRoaXMucG9zKSA6IHRoaXMucG9zO1xyXG4gICAgICAgICAgICB2YXIgcm90YXRpb24gPSB0aGlzLmJvZHkgPyB0aGlzLmJvZHkucm90YXRpb24gOiAwO1xyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGN0eC5hcmMocG9zLngsIHBvcy55LCB0aGlzLnJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xyXG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHgubW92ZVRvKHBvcy54LCBwb3MueSk7XHJcbiAgICAgICAgICAgIGN0eC5saW5lVG8oTWF0aC5jb3Mocm90YXRpb24pICogdGhpcy5yYWRpdXMgKyBwb3MueCwgTWF0aC5zaW4ocm90YXRpb24pICogdGhpcy5yYWRpdXMgKyBwb3MueSk7XHJcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIENpcmNsZUFyZWE7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5DaXJjbGVBcmVhID0gQ2lyY2xlQXJlYTtcclxufSk7XHJcbmRlZmluZShcIkNvbGxpc2lvbi9Db2xsaXNpb25KdW1wVGFibGVcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJDb2xsaXNpb24vQ29sbGlzaW9uQ29udGFjdFwiLCBcIkNvbGxpc2lvbi9Qb2x5Z29uQXJlYVwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIENvbGxpc2lvbkNvbnRhY3RfMSwgUG9seWdvbkFyZWFfMikge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICBleHBvcnRzLkNvbGxpc2lvbkp1bXBUYWJsZSA9IHtcclxuICAgICAgICBDb2xsaWRlQ2lyY2xlQ2lyY2xlOiBmdW5jdGlvbiAoY2lyY2xlQSwgY2lyY2xlQikge1xyXG4gICAgICAgICAgICB2YXIgcmFkaXVzID0gY2lyY2xlQS5yYWRpdXMgKyBjaXJjbGVCLnJhZGl1cztcclxuICAgICAgICAgICAgdmFyIGNpcmNsZUFQb3MgPSBjaXJjbGVBLmJvZHkucG9zLmFkZChjaXJjbGVBLnBvcyk7XHJcbiAgICAgICAgICAgIHZhciBjaXJjbGVCUG9zID0gY2lyY2xlQi5ib2R5LnBvcy5hZGQoY2lyY2xlQi5wb3MpO1xyXG4gICAgICAgICAgICBpZiAoY2lyY2xlQVBvcy5kaXN0YW5jZShjaXJjbGVCUG9zKSA+IHJhZGl1cykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGF4aXNPZkNvbGxpc2lvbiA9IGNpcmNsZUJQb3Muc3ViKGNpcmNsZUFQb3MpLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICB2YXIgbXZ0ID0gYXhpc09mQ29sbGlzaW9uLnNjYWxlKHJhZGl1cyAtIGNpcmNsZUJQb3MuZGlzdGFuY2UoY2lyY2xlQVBvcykpO1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRPZkNvbGxpc2lvbiA9IGNpcmNsZUEuZ2V0RnVydGhlc3RQb2ludChheGlzT2ZDb2xsaXNpb24pO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbGxpc2lvbkNvbnRhY3RfMS5Db2xsaXNpb25Db250YWN0KGNpcmNsZUEsIGNpcmNsZUIsIG12dCwgcG9pbnRPZkNvbGxpc2lvbiwgYXhpc09mQ29sbGlzaW9uKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIENvbGxpZGVDaXJjbGVQb2x5Z29uOiBmdW5jdGlvbiAoY2lyY2xlLCBwb2x5Z29uKSB7XHJcbiAgICAgICAgICAgIHZhciBtaW5BeGlzID0gY2lyY2xlLnRlc3RTZXBhcmF0aW5nQXhpc1RoZW9yZW0ocG9seWdvbik7XHJcbiAgICAgICAgICAgIGlmICghbWluQXhpcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoYXQgdGhlIG1pbkF4aXMgaXMgcG9pbnRpbmcgYXdheSBmcm9tIGNpcmNsZVxyXG4gICAgICAgICAgICB2YXIgc2FtZWRpciA9IG1pbkF4aXMuZG90KHBvbHlnb24uZ2V0Q2VudGVyKCkuc3ViKGNpcmNsZS5nZXRDZW50ZXIoKSkpO1xyXG4gICAgICAgICAgICBtaW5BeGlzID0gc2FtZWRpciA8IDAgPyBtaW5BeGlzLm5lZ2F0ZSgpIDogbWluQXhpcztcclxuICAgICAgICAgICAgdmFyIHZlcnRzID0gW107XHJcbiAgICAgICAgICAgIHZhciBwb2ludDEgPSBwb2x5Z29uLmdldEZ1cnRoZXN0UG9pbnQobWluQXhpcy5uZWdhdGUoKSk7XHJcbiAgICAgICAgICAgIHZhciBwb2ludDIgPSBjaXJjbGUuZ2V0RnVydGhlc3RQb2ludChtaW5BeGlzKTsgLy8uYWRkKGNjKTtcclxuICAgICAgICAgICAgaWYgKGNpcmNsZS5jb250YWlucyhwb2ludDEpKSB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0cy5wdXNoKHBvaW50MSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHBvbHlnb24uY29udGFpbnMocG9pbnQyKSkge1xyXG4gICAgICAgICAgICAgICAgdmVydHMucHVzaChwb2ludDIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2ZXJ0cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sbGlzaW9uQ29udGFjdF8xLkNvbGxpc2lvbkNvbnRhY3QoY2lyY2xlLCBwb2x5Z29uLCBtaW5BeGlzLCB2ZXJ0cy5sZW5ndGggPT09IDIgPyB2ZXJ0c1swXS5hdmVyYWdlKHZlcnRzWzFdKSA6IHZlcnRzWzBdLCBtaW5BeGlzLm5vcm1hbGl6ZSgpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIENvbGxpZGVDaXJjbGVFZGdlOiBmdW5jdGlvbiAoY2lyY2xlLCBlZGdlKSB7XHJcbiAgICAgICAgICAgIC8vIGNlbnRlciBvZiB0aGUgY2lyY2xlXHJcbiAgICAgICAgICAgIHZhciBjYyA9IGNpcmNsZS5nZXRDZW50ZXIoKTtcclxuICAgICAgICAgICAgLy8gdmVjdG9yIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGVkZ2VcclxuICAgICAgICAgICAgdmFyIGUgPSBlZGdlLmVuZC5zdWIoZWRnZS5iZWdpbik7XHJcbiAgICAgICAgICAgIC8vIGFtb3VudCBvZiBvdmVybGFwIHdpdGggdGhlIGNpcmNsZSdzIGNlbnRlciBhbG9uZyB0aGUgZWRnZSBkaXJlY3Rpb25cclxuICAgICAgICAgICAgdmFyIHUgPSBlLmRvdChlZGdlLmVuZC5zdWIoY2MpKTtcclxuICAgICAgICAgICAgdmFyIHYgPSBlLmRvdChjYy5zdWIoZWRnZS5iZWdpbikpO1xyXG4gICAgICAgICAgICAvLyBQb3RlbnRpYWwgcmVnaW9uIEEgY29sbGlzaW9uIChjaXJjbGUgaXMgb24gdGhlIGxlZnQgc2lkZSBvZiB0aGUgZWRnZSwgYmVmb3JlIHRoZSBiZWdpbm5pbmcpXHJcbiAgICAgICAgICAgIGlmICh2IDw9IDApIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYSA9IGVkZ2UuYmVnaW4uc3ViKGNjKTtcclxuICAgICAgICAgICAgICAgIHZhciBkZGEgPSBkYS5kb3QoZGEpOyAvLyBxdWljayBhbmQgZGlydHkgd2F5IG9mIGNhbGMnbiBkaXN0YW5jZSBpbiByXjIgdGVybXMgc2F2ZXMgc29tZSBzcXJ0c1xyXG4gICAgICAgICAgICAgICAgLy8gc2F2ZSBzb21lIHNxcnRzXHJcbiAgICAgICAgICAgICAgICBpZiAoZGRhID4gY2lyY2xlLnJhZGl1cyAqIGNpcmNsZS5yYWRpdXMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gbm8gY29sbGlzaW9uXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbGxpc2lvbkNvbnRhY3RfMS5Db2xsaXNpb25Db250YWN0KGNpcmNsZSwgZWRnZSwgZGEubm9ybWFsaXplKCkuc2NhbGUoY2lyY2xlLnJhZGl1cyAtIE1hdGguc3FydChkZGEpKSwgZWRnZS5iZWdpbiwgZGEubm9ybWFsaXplKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFBvdGVudGlhbCByZWdpb24gQiBjb2xsaXNpb24gKGNpcmNsZSBpcyBvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgZWRnZSwgYWZ0ZXIgdGhlIGVuZClcclxuICAgICAgICAgICAgaWYgKHUgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRiID0gZWRnZS5lbmQuc3ViKGNjKTtcclxuICAgICAgICAgICAgICAgIHZhciBkZGIgPSBkYi5kb3QoZGIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRkYiA+IGNpcmNsZS5yYWRpdXMgKiBjaXJjbGUucmFkaXVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbGxpc2lvbkNvbnRhY3RfMS5Db2xsaXNpb25Db250YWN0KGNpcmNsZSwgZWRnZSwgZGIubm9ybWFsaXplKCkuc2NhbGUoY2lyY2xlLnJhZGl1cyAtIE1hdGguc3FydChkZGIpKSwgZWRnZS5lbmQsIGRiLm5vcm1hbGl6ZSgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgcG90ZW50aWFsIHJlZ2lvbiBBQiBjb2xsaXNpb24gKGNpcmNsZSBpcyBpbiB0aGUgbWlkZGxlIG9mIHRoZSBlZGdlIGJldHdlZW4gdGhlIGJlZ2lubmluZyBhbmQgZW5kKVxyXG4gICAgICAgICAgICB2YXIgZGVuID0gZS5kb3QoZSk7XHJcbiAgICAgICAgICAgIHZhciBwb2ludE9uRWRnZSA9IChlZGdlLmJlZ2luLnNjYWxlKHUpLmFkZChlZGdlLmVuZC5zY2FsZSh2KSkpLnNjYWxlKDEgLyBkZW4pO1xyXG4gICAgICAgICAgICB2YXIgZCA9IGNjLnN1Yihwb2ludE9uRWRnZSk7XHJcbiAgICAgICAgICAgIHZhciBkZCA9IGQuZG90KGQpO1xyXG4gICAgICAgICAgICBpZiAoZGQgPiBjaXJjbGUucmFkaXVzICogY2lyY2xlLnJhZGl1cykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIG5vIGNvbGxpc2lvblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBuID0gZS5wZXJwZW5kaWN1bGFyKCk7XHJcbiAgICAgICAgICAgIC8vIGZsaXAgY29ycmVjdCBkaXJlY3Rpb25cclxuICAgICAgICAgICAgaWYgKG4uZG90KGNjLnN1YihlZGdlLmJlZ2luKSkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBuLnggPSAtbi54O1xyXG4gICAgICAgICAgICAgICAgbi55ID0gLW4ueTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuID0gbi5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgdmFyIG12dCA9IG4uc2NhbGUoTWF0aC5hYnMoY2lyY2xlLnJhZGl1cyAtIE1hdGguc3FydChkZCkpKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xsaXNpb25Db250YWN0XzEuQ29sbGlzaW9uQ29udGFjdChjaXJjbGUsIGVkZ2UsIG12dC5uZWdhdGUoKSwgcG9pbnRPbkVkZ2UsIG4ubmVnYXRlKCkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgQ29sbGlkZUVkZ2VFZGdlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIEVkZ2UtZWRnZSBjb2xsaXNpb24gZG9lc24ndCBtYWtlIHNlbnNlXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgQ29sbGlkZVBvbHlnb25FZGdlOiBmdW5jdGlvbiAocG9seWdvbiwgZWRnZSkge1xyXG4gICAgICAgICAgICAvLyAzIGNhc2VzOlxyXG4gICAgICAgICAgICAvLyAoMSkgUG9seWdvbiBsYW5kcyBvbiB0aGUgZnVsbCBmYWNlXHJcbiAgICAgICAgICAgIC8vICgyKSBQb2x5Z29uIGxhbmRzIG9uIHRoZSByaWdodCBwb2ludFxyXG4gICAgICAgICAgICAvLyAoMykgUG9seWdvbiBsYW5kcyBvbiB0aGUgbGVmdCBwb2ludFxyXG4gICAgICAgICAgICB2YXIgZSA9IGVkZ2UuZW5kLnN1YihlZGdlLmJlZ2luKTtcclxuICAgICAgICAgICAgdmFyIGVkZ2VOb3JtYWwgPSBlLm5vcm1hbCgpO1xyXG4gICAgICAgICAgICBpZiAocG9seWdvbi5jb250YWlucyhlZGdlLmJlZ2luKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hID0gcG9seWdvbi5nZXRDbG9zZXN0RmFjZShlZGdlLmJlZ2luKSwgbXR2ID0gX2EuZGlzdGFuY2UsIGZhY2UgPSBfYS5mYWNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKG10dikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29sbGlzaW9uQ29udGFjdF8xLkNvbGxpc2lvbkNvbnRhY3QocG9seWdvbiwgZWRnZSwgbXR2Lm5lZ2F0ZSgpLCBlZGdlLmJlZ2luLmFkZChtdHYubmVnYXRlKCkpLCBmYWNlLm5vcm1hbCgpLm5lZ2F0ZSgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocG9seWdvbi5jb250YWlucyhlZGdlLmVuZCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfYiA9IHBvbHlnb24uZ2V0Q2xvc2VzdEZhY2UoZWRnZS5lbmQpLCBtdHYgPSBfYi5kaXN0YW5jZSwgZmFjZSA9IF9iLmZhY2U7XHJcbiAgICAgICAgICAgICAgICBpZiAobXR2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xsaXNpb25Db250YWN0XzEuQ29sbGlzaW9uQ29udGFjdChwb2x5Z29uLCBlZGdlLCBtdHYubmVnYXRlKCksIGVkZ2UuZW5kLmFkZChtdHYubmVnYXRlKCkpLCBmYWNlLm5vcm1hbCgpLm5lZ2F0ZSgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcGMgPSBwb2x5Z29uLmdldENlbnRlcigpO1xyXG4gICAgICAgICAgICB2YXIgZWMgPSBlZGdlLmdldENlbnRlcigpO1xyXG4gICAgICAgICAgICB2YXIgZGlyID0gZWMuc3ViKHBjKS5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgLy8gYnVpbGQgYSB0ZW1wb3JhcnkgcG9seWdvbiBmcm9tIHRoZSBlZGdlIHRvIHVzZSBTQVRcclxuICAgICAgICAgICAgdmFyIGxpbmVQb2x5ID0gbmV3IFBvbHlnb25BcmVhXzIuUG9seWdvbkFyZWEoe1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgZWRnZS5iZWdpbixcclxuICAgICAgICAgICAgICAgICAgICBlZGdlLmVuZCxcclxuICAgICAgICAgICAgICAgICAgICBlZGdlLmVuZC5hZGQoZGlyLnNjYWxlKDMwKSksXHJcbiAgICAgICAgICAgICAgICAgICAgZWRnZS5iZWdpbi5hZGQoZGlyLnNjYWxlKDMwKSlcclxuICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHZhciBtaW5BeGlzID0gcG9seWdvbi50ZXN0U2VwYXJhdGluZ0F4aXNUaGVvcmVtKGxpbmVQb2x5KTtcclxuICAgICAgICAgICAgLy8gbm8gbWluQXhpcywgbm8gb3ZlcmxhcCwgbm8gY29sbGlzaW9uXHJcbiAgICAgICAgICAgIGlmICghbWluQXhpcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZmxpcCB0aGUgbm9ybWFsIGFuZCBheGlzIHRvIGFsd2F5cyBoYXZlIHBvc2l0aXZlIGNvbGxpc2lvbnNcclxuICAgICAgICAgICAgZWRnZU5vcm1hbCA9IGVkZ2VOb3JtYWwuZG90KGRpcikgPCAwID8gZWRnZU5vcm1hbC5uZWdhdGUoKSA6IGVkZ2VOb3JtYWw7XHJcbiAgICAgICAgICAgIG1pbkF4aXMgPSBtaW5BeGlzLmRvdChkaXIpIDwgMCA/IG1pbkF4aXMubmVnYXRlKCkgOiBtaW5BeGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbGxpc2lvbkNvbnRhY3RfMS5Db2xsaXNpb25Db250YWN0KHBvbHlnb24sIGVkZ2UsIG1pbkF4aXMsIHBvbHlnb24uZ2V0RnVydGhlc3RQb2ludChlZGdlTm9ybWFsKSwgZWRnZU5vcm1hbCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBDb2xsaWRlUG9seWdvblBvbHlnb246IGZ1bmN0aW9uIChwb2x5QSwgcG9seUIpIHtcclxuICAgICAgICAgICAgLy8gZG8gYSBTQVQgdGVzdCB0byBmaW5kIGEgbWluIGF4aXMgaWYgaXQgZXhpc3RzXHJcbiAgICAgICAgICAgIHZhciBtaW5BeGlzID0gcG9seUEudGVzdFNlcGFyYXRpbmdBeGlzVGhlb3JlbShwb2x5Qik7XHJcbiAgICAgICAgICAgIC8vIG5vIG92ZXJsYXAsIG5vIGNvbGxpc2lvbiByZXR1cm4gbnVsbFxyXG4gICAgICAgICAgICBpZiAoIW1pbkF4aXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGF0IG1pbkF4aXMgaXMgcG9pbnRpbmcgZnJvbSBBIC0+IEJcclxuICAgICAgICAgICAgdmFyIHNhbWVEaXIgPSBtaW5BeGlzLmRvdChwb2x5Qi5nZXRDZW50ZXIoKS5zdWIocG9seUEuZ2V0Q2VudGVyKCkpKTtcclxuICAgICAgICAgICAgbWluQXhpcyA9IHNhbWVEaXIgPCAwID8gbWluQXhpcy5uZWdhdGUoKSA6IG1pbkF4aXM7XHJcbiAgICAgICAgICAgIC8vIGZpbmQgcm91Z2ggcG9pbnQgb2YgY29sbGlzaW9uXHJcbiAgICAgICAgICAgIC8vIHRvZG8gdGhpcyBjb3VsZCBiZSBiZXR0ZXJcclxuICAgICAgICAgICAgdmFyIHZlcnRzID0gW107XHJcbiAgICAgICAgICAgIHZhciBwb2ludEEgPSBwb2x5QS5nZXRGdXJ0aGVzdFBvaW50KG1pbkF4aXMpO1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRCID0gcG9seUIuZ2V0RnVydGhlc3RQb2ludChtaW5BeGlzLm5lZ2F0ZSgpKTtcclxuICAgICAgICAgICAgaWYgKHBvbHlCLmNvbnRhaW5zKHBvaW50QSkpIHtcclxuICAgICAgICAgICAgICAgIHZlcnRzLnB1c2gocG9pbnRBKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocG9seUEuY29udGFpbnMocG9pbnRCKSkge1xyXG4gICAgICAgICAgICAgICAgdmVydHMucHVzaChwb2ludEIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIG5vIGNhbmRpZGF0ZXMsIHBpY2sgc29tZXRoaW5nXHJcbiAgICAgICAgICAgIGlmICh2ZXJ0cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHZlcnRzLnB1c2gocG9pbnRCKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY29udGFjdCA9IHZlcnRzLmxlbmd0aCA9PT0gMiA/IHZlcnRzWzBdLmFkZCh2ZXJ0c1sxXSkuc2NhbGUoLjUpIDogdmVydHNbMF07XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sbGlzaW9uQ29udGFjdF8xLkNvbGxpc2lvbkNvbnRhY3QocG9seUEsIHBvbHlCLCBtaW5BeGlzLCBjb250YWN0LCBtaW5BeGlzLm5vcm1hbGl6ZSgpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59KTtcclxuZGVmaW5lKFwiQ29sbGlzaW9uL1BvbHlnb25BcmVhXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiRHJhd2luZy9Db2xvclwiLCBcIlBoeXNpY3NcIiwgXCJDb2xsaXNpb24vQm91bmRpbmdCb3hcIiwgXCJDb2xsaXNpb24vRWRnZUFyZWFcIiwgXCJDb2xsaXNpb24vQ29sbGlzaW9uSnVtcFRhYmxlXCIsIFwiQ29sbGlzaW9uL0NpcmNsZUFyZWFcIiwgXCJBbGdlYnJhXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgQ29sb3JfMiwgUGh5c2ljc18zLCBCb3VuZGluZ0JveF8yLCBFZGdlQXJlYV8yLCBDb2xsaXNpb25KdW1wVGFibGVfMiwgQ2lyY2xlQXJlYV8xLCBBbGdlYnJhXzYpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQb2x5Z29uIGNvbGxpc2lvbiBhcmVhIGZvciBkZXRlY3RpbmcgY29sbGlzaW9ucyBmb3IgYWN0b3JzLCBvciBpbmRlcGVuZGVudGx5XHJcbiAgICAgKi9cclxuICAgIHZhciBQb2x5Z29uQXJlYSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gUG9seWdvbkFyZWEob3B0aW9ucykge1xyXG4gICAgICAgICAgICB0aGlzLl90cmFuc2Zvcm1lZFBvaW50cyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLl9heGVzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuX3NpZGVzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMucG9zID0gb3B0aW9ucy5wb3MgfHwgQWxnZWJyYV82LlZlY3Rvci5aZXJvLmNsb25lKCk7XHJcbiAgICAgICAgICAgIHZhciB3aW5kaW5nID0gISFvcHRpb25zLmNsb2Nrd2lzZVdpbmRpbmc7XHJcbiAgICAgICAgICAgIHRoaXMucG9pbnRzID0gKHdpbmRpbmcgPyBvcHRpb25zLnBvaW50cy5yZXZlcnNlKCkgOiBvcHRpb25zLnBvaW50cykgfHwgW107XHJcbiAgICAgICAgICAgIHRoaXMuYm9keSA9IG9wdGlvbnMuYm9keSB8fCBudWxsO1xyXG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgaW5pdGlhbCB0cmFuc2Zvcm1hdGlvblxyXG4gICAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVUcmFuc2Zvcm1hdGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgdGhlIGNlbnRlciBvZiB0aGUgY29sbGlzaW9uIGFyZWEgaW4gd29ybGQgY29vcmRpbmF0ZXNcclxuICAgICAgICAgKi9cclxuICAgICAgICBQb2x5Z29uQXJlYS5wcm90b3R5cGUuZ2V0Q2VudGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5ib2R5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5LnBvcy5hZGQodGhpcy5wb3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIHVuZGVybHlpbmcgdHJhbnNmb3JtYXRpb24gZnJvbSB0aGUgYm9keSByZWxhdGl2ZSBzcGFjZSB0byB3b3JsZCBzcGFjZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBvbHlnb25BcmVhLnByb3RvdHlwZS5fY2FsY3VsYXRlVHJhbnNmb3JtYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLmJvZHkgPyB0aGlzLmJvZHkucG9zLmFkZCh0aGlzLnBvcykgOiB0aGlzLnBvcztcclxuICAgICAgICAgICAgdmFyIGFuZ2xlID0gdGhpcy5ib2R5ID8gdGhpcy5ib2R5LnJvdGF0aW9uIDogMDtcclxuICAgICAgICAgICAgdmFyIGxlbiA9IHRoaXMucG9pbnRzLmxlbmd0aDtcclxuICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtZWRQb2ludHMubGVuZ3RoID0gMDsgLy8gY2xlYXIgb3V0IG9sZCB0cmFuc2Zvcm1cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtZWRQb2ludHNbaV0gPSB0aGlzLnBvaW50c1tpXS5yb3RhdGUoYW5nbGUpLmFkZChwb3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBwb2ludHMgdGhhdCBtYWtlIHVwIHRoZSBwb2x5Z29uIGluIHdvcmxkIHNwYWNlLCBmcm9tIGFjdG9yIHJlbGF0aXZlIHNwYWNlIChpZiBzcGVjaWZpZWQpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUG9seWdvbkFyZWEucHJvdG90eXBlLmdldFRyYW5zZm9ybWVkUG9pbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RyYW5zZm9ybWVkUG9pbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FsY3VsYXRlVHJhbnNmb3JtYXRpb24oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFuc2Zvcm1lZFBvaW50cztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIHNpZGVzIG9mIHRoZSBwb2x5Z29uIGluIHdvcmxkIHNwYWNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUG9seWdvbkFyZWEucHJvdG90eXBlLmdldFNpZGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fc2lkZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2lkZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGxpbmVzID0gW107XHJcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnRzKCk7XHJcbiAgICAgICAgICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKG5ldyBBbGdlYnJhXzYuTGluZShwb2ludHNbaV0sIHBvaW50c1soaSAtIDEgKyBsZW4pICUgbGVuXSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3NpZGVzID0gbGluZXM7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaWRlcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIFBvbHlnb25BcmVhLnByb3RvdHlwZS5yZWNhbGMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NpZGVzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2F4ZXMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtZWRQb2ludHMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgdGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50cygpO1xyXG4gICAgICAgICAgICB0aGlzLmdldEF4ZXMoKTtcclxuICAgICAgICAgICAgdGhpcy5nZXRTaWRlcygpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVzdHMgaWYgYSBwb2ludCBpcyBjb250YWluZWQgaW4gdGhpcyBjb2xsaXNpb24gYXJlYSBpbiB3b3JsZCBzcGFjZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBvbHlnb25BcmVhLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gICAgICAgICAgICAvLyBBbHdheXMgY2FzdCB0byB0aGUgcmlnaHQsIGFzIGxvbmcgYXMgd2UgY2FzdCBpbiBhIGNvbnNpdGVudCBmaXhlZCBkaXJlY3Rpb24gd2VcclxuICAgICAgICAgICAgLy8gd2lsbCBiZSBmaW5lXHJcbiAgICAgICAgICAgIHZhciB0ZXN0UmF5ID0gbmV3IEFsZ2VicmFfNi5SYXkocG9pbnQsIG5ldyBBbGdlYnJhXzYuVmVjdG9yKDEsIDApKTtcclxuICAgICAgICAgICAgdmFyIGludGVyc2VjdENvdW50ID0gdGhpcy5nZXRTaWRlcygpLnJlZHVjZShmdW5jdGlvbiAoYWNjdW0sIHNpZGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0ZXN0UmF5LmludGVyc2VjdChzaWRlKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjY3VtICsgMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bTtcclxuICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgICAgIGlmIChpbnRlcnNlY3RDb3VudCAlIDIgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBjb2xsaXNpb24gY29udGFjdCBpZiB0aGUgMiBjb2xsaXNpb24gYXJlYXMgY29sbGlkZSwgb3RoZXJ3aXNlIGNvbGxpZGUgd2lsbFxyXG4gICAgICAgICAqIHJldHVybiBudWxsLlxyXG4gICAgICAgICAqIEBwYXJhbSBhcmVhXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUG9seWdvbkFyZWEucHJvdG90eXBlLmNvbGxpZGUgPSBmdW5jdGlvbiAoYXJlYSkge1xyXG4gICAgICAgICAgICBpZiAoYXJlYSBpbnN0YW5jZW9mIENpcmNsZUFyZWFfMS5DaXJjbGVBcmVhKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29sbGlzaW9uSnVtcFRhYmxlXzIuQ29sbGlzaW9uSnVtcFRhYmxlLkNvbGxpZGVDaXJjbGVQb2x5Z29uKGFyZWEsIHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGFyZWEgaW5zdGFuY2VvZiBQb2x5Z29uQXJlYSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbGxpc2lvbkp1bXBUYWJsZV8yLkNvbGxpc2lvbkp1bXBUYWJsZS5Db2xsaWRlUG9seWdvblBvbHlnb24odGhpcywgYXJlYSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYXJlYSBpbnN0YW5jZW9mIEVkZ2VBcmVhXzIuRWRnZUFyZWEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDb2xsaXNpb25KdW1wVGFibGVfMi5Db2xsaXNpb25KdW1wVGFibGUuQ29sbGlkZVBvbHlnb25FZGdlKHRoaXMsIGFyZWEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG9seWdvbiBjb3VsZCBub3QgY29sbGlkZSB3aXRoIHVua25vd24gSUNvbGxpc2lvbkFyZWEgXCIgKyB0eXBlb2YgYXJlYSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZpbmQgdGhlIHBvaW50IG9uIHRoZSBzaGFwZSBmdXJ0aGVzdCBpbiB0aGUgZGlyZWN0aW9uIHNwZWNpZmllZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBvbHlnb25BcmVhLnByb3RvdHlwZS5nZXRGdXJ0aGVzdFBvaW50ID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgcHRzID0gdGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50cygpO1xyXG4gICAgICAgICAgICB2YXIgZnVydGhlc3RQb2ludCA9IG51bGw7XHJcbiAgICAgICAgICAgIHZhciBtYXhEaXN0YW5jZSA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHB0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gZGlyZWN0aW9uLmRvdChwdHNbaV0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlID4gbWF4RGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXhEaXN0YW5jZSA9IGRpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1cnRoZXN0UG9pbnQgPSBwdHNbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZ1cnRoZXN0UG9pbnQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGaW5kcyB0aGUgY2xvc2VzIGZhY2UgdG8gdGhlIHBvaW50IHVzaW5nIHBlcnBlbmRpY3VsYXIgZGlzdGFuY2VcclxuICAgICAgICAgKiBAcGFyYW0gcG9pbnQgcG9pbnQgdG8gdGVzdCBhZ2FpbnN0IHBvbHlnb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBQb2x5Z29uQXJlYS5wcm90b3R5cGUuZ2V0Q2xvc2VzdEZhY2UgPSBmdW5jdGlvbiAocG9pbnQpIHtcclxuICAgICAgICAgICAgdmFyIHNpZGVzID0gdGhpcy5nZXRTaWRlcygpO1xyXG4gICAgICAgICAgICB2YXIgbWluID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xyXG4gICAgICAgICAgICB2YXIgZmFjZUluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IC0xO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGlzdCA9IHNpZGVzW2ldLmRpc3RhbmNlVG9Qb2ludChwb2ludCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlzdCA8IG1pbikge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGRpc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgZmFjZUluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IGRpc3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGZhY2VJbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2U6IHNpZGVzW2ZhY2VJbmRleF0ubm9ybWFsKCkuc2NhbGUoZGlzdGFuY2UpLFxyXG4gICAgICAgICAgICAgICAgICAgIGZhY2U6IHNpZGVzW2ZhY2VJbmRleF1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgdGhlIGF4aXMgYWxpZ25lZCBib3VuZGluZyBib3ggZm9yIHRoZSBwb2x5Z29uIGFyZWFcclxuICAgICAgICAgKi9cclxuICAgICAgICBQb2x5Z29uQXJlYS5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyB0b2RvIHRoZXJlIGlzIGEgZmFzdGVyIHdheSB0byBkbyB0aGlzXHJcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnRzKCk7XHJcbiAgICAgICAgICAgIHZhciBtaW5YID0gcG9pbnRzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3Vycikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKHByZXYsIGN1cnIueCk7XHJcbiAgICAgICAgICAgIH0sIDk5OTk5OTk5OSk7XHJcbiAgICAgICAgICAgIHZhciBtYXhYID0gcG9pbnRzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3Vycikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHByZXYsIGN1cnIueCk7XHJcbiAgICAgICAgICAgIH0sIC05OTk5OTk5OSk7XHJcbiAgICAgICAgICAgIHZhciBtaW5ZID0gcG9pbnRzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3Vycikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKHByZXYsIGN1cnIueSk7XHJcbiAgICAgICAgICAgIH0sIDk5OTk5OTk5OTkpO1xyXG4gICAgICAgICAgICB2YXIgbWF4WSA9IHBvaW50cy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cnIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChwcmV2LCBjdXJyLnkpO1xyXG4gICAgICAgICAgICB9LCAtOTk5OTk5OTk5OSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3hfMi5Cb3VuZGluZ0JveChtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCB0aGUgbW9tZW50IG9mIGluZXJ0aWEgZm9yIGFuIGFyYml0cmFyeSBwb2x5Z29uXHJcbiAgICAgICAgICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGlzdF9vZl9tb21lbnRzX29mX2luZXJ0aWFcclxuICAgICAgICAgKi9cclxuICAgICAgICBQb2x5Z29uQXJlYS5wcm90b3R5cGUuZ2V0TW9tZW50T2ZJbmVydGlhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbWFzcyA9IHRoaXMuYm9keSA/IHRoaXMuYm9keS5tYXNzIDogUGh5c2ljc18zLlBoeXNpY3MuZGVmYXVsdE1hc3M7XHJcbiAgICAgICAgICAgIHZhciBudW1lcmF0b3IgPSAwO1xyXG4gICAgICAgICAgICB2YXIgZGVub21pbmF0b3IgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucG9pbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXBsdXNvbmUgPSAoaSArIDEpICUgdGhpcy5wb2ludHMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNyb3NzVGVybSA9IHRoaXMucG9pbnRzW2lwbHVzb25lXS5jcm9zcyh0aGlzLnBvaW50c1tpXSk7XHJcbiAgICAgICAgICAgICAgICBudW1lcmF0b3IgKz0gY3Jvc3NUZXJtICogKHRoaXMucG9pbnRzW2ldLmRvdCh0aGlzLnBvaW50c1tpXSkgK1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnRzW2ldLmRvdCh0aGlzLnBvaW50c1tpcGx1c29uZV0pICtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvaW50c1tpcGx1c29uZV0uZG90KHRoaXMucG9pbnRzW2lwbHVzb25lXSkpO1xyXG4gICAgICAgICAgICAgICAgZGVub21pbmF0b3IgKz0gY3Jvc3NUZXJtO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAobWFzcyAvIDYpICogKG51bWVyYXRvciAvIGRlbm9taW5hdG9yKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhc3RzIGEgcmF5IGludG8gdGhlIHBvbHlnb24gYW5kIHJldHVybnMgYSB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBwb2ludCBvZiBjb250YWN0IChpbiB3b3JsZCBzcGFjZSkgb3IgbnVsbCBpZiBubyBjb2xsaXNpb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUG9seWdvbkFyZWEucHJvdG90eXBlLnJheUNhc3QgPSBmdW5jdGlvbiAocmF5LCBtYXgpIHtcclxuICAgICAgICAgICAgaWYgKG1heCA9PT0gdm9pZCAwKSB7IG1heCA9IEluZmluaXR5OyB9XHJcbiAgICAgICAgICAgIC8vIGZpbmQgdGhlIG1pbmltdW0gY29udGFjdCB0aW1lIGdyZWF0ZXIgdGhhbiAwXHJcbiAgICAgICAgICAgIC8vIGNvbnRhY3QgdGltZXMgbGVzcyB0aGFuIDAgYXJlIGJlaGluZCB0aGUgcmF5IGFuZCB3ZSBkb24ndCB3YW50IHRob3NlXHJcbiAgICAgICAgICAgIHZhciBzaWRlcyA9IHRoaXMuZ2V0U2lkZXMoKTtcclxuICAgICAgICAgICAgdmFyIGxlbiA9IHNpZGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgdmFyIG1pbkNvbnRhY3RUaW1lID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICAgICAgdmFyIGNvbnRhY3RJbmRleCA9IC0xO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udGFjdFRpbWUgPSByYXkuaW50ZXJzZWN0KHNpZGVzW2ldKTtcclxuICAgICAgICAgICAgICAgIGlmIChjb250YWN0VGltZSA+PSAwICYmIGNvbnRhY3RUaW1lIDwgbWluQ29udGFjdFRpbWUgJiYgY29udGFjdFRpbWUgPD0gbWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluQ29udGFjdFRpbWUgPSBjb250YWN0VGltZTtcclxuICAgICAgICAgICAgICAgICAgICBjb250YWN0SW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNvbnRhY3Qgd2FzIGZvdW5kXHJcbiAgICAgICAgICAgIGlmIChjb250YWN0SW5kZXggPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJheS5nZXRQb2ludChtaW5Db250YWN0VGltZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gbm8gY29udGFjdCBmb3VuZFxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCB0aGUgYXhpcyBhc3NvY2lhdGVkIHdpdGggdGhlIGVkZ2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBQb2x5Z29uQXJlYS5wcm90b3R5cGUuZ2V0QXhlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2F4ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYXhlcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYXhlcyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50cygpO1xyXG4gICAgICAgICAgICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgYXhlcy5wdXNoKHBvaW50c1tpXS5zdWIocG9pbnRzWyhpICsgMSkgJSBsZW5dKS5ub3JtYWwoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fYXhlcyA9IGF4ZXM7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9heGVzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGVyZm9ybSBTZXBhcmF0aW5nIEF4aXMgdGVzdCBhZ2FpbnN0IGFub3RoZXIgcG9seWdvbiwgcmV0dXJucyBudWxsIGlmIG5vIG92ZXJsYXAgaW4gcG9seXNcclxuICAgICAgICAgKiBSZWZlcmVuY2UgaHR0cDovL3d3dy5keW40ai5vcmcvMjAxMC8wMS9zYXQvXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUG9seWdvbkFyZWEucHJvdG90eXBlLnRlc3RTZXBhcmF0aW5nQXhpc1RoZW9yZW0gPSBmdW5jdGlvbiAob3RoZXIpIHtcclxuICAgICAgICAgICAgdmFyIHBvbHkxID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIHBvbHkyID0gb3RoZXI7XHJcbiAgICAgICAgICAgIHZhciBheGVzID0gcG9seTEuZ2V0QXhlcygpLmNvbmNhdChwb2x5Mi5nZXRBeGVzKCkpO1xyXG4gICAgICAgICAgICB2YXIgbWluT3ZlcmxhcCA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgICAgIHZhciBtaW5BeGlzID0gbnVsbDtcclxuICAgICAgICAgICAgdmFyIG1pbkluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHByb2oxID0gcG9seTEucHJvamVjdChheGVzW2ldKTtcclxuICAgICAgICAgICAgICAgIHZhciBwcm9qMiA9IHBvbHkyLnByb2plY3QoYXhlc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3ZlcmxhcCA9IHByb2oxLmdldE92ZXJsYXAocHJvajIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXAgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJsYXAgPCBtaW5PdmVybGFwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbk92ZXJsYXAgPSBvdmVybGFwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5BeGlzID0gYXhlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluSW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBTYW5pdHkgY2hlY2tcclxuICAgICAgICAgICAgaWYgKG1pbkluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1pbkF4aXMubm9ybWFsaXplKCkuc2NhbGUobWluT3ZlcmxhcCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcm9qZWN0IHRoZSBlZGdlcyBvZiB0aGUgcG9seWdvbiBhbG9uZyBhIHNwZWNpZmllZCBheGlzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUG9seWdvbkFyZWEucHJvdG90eXBlLnByb2plY3QgPSBmdW5jdGlvbiAoYXhpcykge1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50cygpO1xyXG4gICAgICAgICAgICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aDtcclxuICAgICAgICAgICAgdmFyIG1pbiA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgICAgIHZhciBtYXggPSAtTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNjYWxhciA9IHBvaW50c1tpXS5kb3QoYXhpcyk7XHJcbiAgICAgICAgICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIHNjYWxhcik7XHJcbiAgICAgICAgICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHNjYWxhcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbGdlYnJhXzYuUHJvamVjdGlvbihtaW4sIG1heCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIFBvbHlnb25BcmVhLnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY3R4LCBjb2xvcikge1xyXG4gICAgICAgICAgICBpZiAoY29sb3IgPT09IHZvaWQgMCkgeyBjb2xvciA9IENvbG9yXzIuQ29sb3IuUmVkLmNsb25lKCk7IH1cclxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvci50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIHN1cHBsaWVkIHBvaW50cyBhbmQgY29uc3RydWN0IGEgJ3BvbHlnb24nXHJcbiAgICAgICAgICAgIHZhciBmaXJzdFBvaW50ID0gdGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50cygpWzBdO1xyXG4gICAgICAgICAgICBjdHgubW92ZVRvKGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55KTtcclxuICAgICAgICAgICAgdGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50cygpLmZvckVhY2goZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHBvaW50LngsIHBvaW50LnkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY3R4LmxpbmVUbyhmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSk7XHJcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFBvbHlnb25BcmVhO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuUG9seWdvbkFyZWEgPSBQb2x5Z29uQXJlYTtcclxufSk7XHJcbmRlZmluZShcIkNvbGxpc2lvbi9Cb3VuZGluZ0JveFwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkNvbGxpc2lvbi9Qb2x5Z29uQXJlYVwiLCBcIkFsZ2VicmFcIiwgXCJEcmF3aW5nL0NvbG9yXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgUG9seWdvbkFyZWFfMywgQWxnZWJyYV83LCBDb2xvcl8zKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogQXhpcyBBbGlnbmVkIGNvbGxpc2lvbiBwcmltaXRpdmUgZm9yIEV4Y2FsaWJ1ci5cclxuICAgICAqL1xyXG4gICAgdmFyIEJvdW5kaW5nQm94ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gbGVmdCAgICB4IGNvb3JkaW5hdGUgb2YgdGhlIGxlZnQgZWRnZVxyXG4gICAgICAgICAqIEBwYXJhbSB0b3AgICAgIHkgY29vcmRpbmF0ZSBvZiB0aGUgdG9wIGVkZ2VcclxuICAgICAgICAgKiBAcGFyYW0gcmlnaHQgICB4IGNvb3JkaW5hdGUgb2YgdGhlIHJpZ2h0IGVkZ2VcclxuICAgICAgICAgKiBAcGFyYW0gYm90dG9tICB5IGNvb3JkaW5hdGUgb2YgdGhlIGJvdHRvbSBlZGdlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gQm91bmRpbmdCb3gobGVmdCwgdG9wLCByaWdodCwgYm90dG9tKSB7XHJcbiAgICAgICAgICAgIGlmIChsZWZ0ID09PSB2b2lkIDApIHsgbGVmdCA9IDA7IH1cclxuICAgICAgICAgICAgaWYgKHRvcCA9PT0gdm9pZCAwKSB7IHRvcCA9IDA7IH1cclxuICAgICAgICAgICAgaWYgKHJpZ2h0ID09PSB2b2lkIDApIHsgcmlnaHQgPSAwOyB9XHJcbiAgICAgICAgICAgIGlmIChib3R0b20gPT09IHZvaWQgMCkgeyBib3R0b20gPSAwOyB9XHJcbiAgICAgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XHJcbiAgICAgICAgICAgIHRoaXMudG9wID0gdG9wO1xyXG4gICAgICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XHJcbiAgICAgICAgICAgIHRoaXMuYm90dG9tID0gYm90dG9tO1xyXG4gICAgICAgIH1cclxuICAgICAgICBCb3VuZGluZ0JveC5mcm9tUG9pbnRzID0gZnVuY3Rpb24gKHBvaW50cykge1xyXG4gICAgICAgICAgICB2YXIgbWluWCA9IEluZmluaXR5O1xyXG4gICAgICAgICAgICB2YXIgbWluWSA9IEluZmluaXR5O1xyXG4gICAgICAgICAgICB2YXIgbWF4WCA9IC1JbmZpbml0eTtcclxuICAgICAgICAgICAgdmFyIG1heFkgPSAtSW5maW5pdHk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocG9pbnRzW2ldLnggPCBtaW5YKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluWCA9IHBvaW50c1tpXS54O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHBvaW50c1tpXS54ID4gbWF4WCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1heFggPSBwb2ludHNbaV0ueDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChwb2ludHNbaV0ueSA8IG1pblkpIHtcclxuICAgICAgICAgICAgICAgICAgICBtaW5ZID0gcG9pbnRzW2ldLnk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocG9pbnRzW2ldLnkgPiBtYXhZKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4WSA9IHBvaW50c1tpXS55O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3gobWluWCwgbWluWSwgbWF4WCwgbWF4WSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjYWxjdWxhdGVkIHdpZHRoIG9mIHRoZSBib3VuZGluZyBib3hcclxuICAgICAgICAgKi9cclxuICAgICAgICBCb3VuZGluZ0JveC5wcm90b3R5cGUuZ2V0V2lkdGggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJpZ2h0IC0gdGhpcy5sZWZ0O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgY2FsY3VsYXRlZCBoZWlnaHQgb2YgdGhlIGJvdW5kaW5nIGJveFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJvdW5kaW5nQm94LnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJvdHRvbSAtIHRoaXMudG9wO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUm90YXRlcyBhIGJvdW5kaW5nIGJveCBieSBhbmQgYW5nbGUgYW5kIGFyb3VuZCBhIHBvaW50LCBpZiBubyBwb2ludCBpcyBzcGVjaWZpZWQgKDAsIDApIGlzIHVzZWQgYnkgZGVmYXVsdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJvdW5kaW5nQm94LnByb3RvdHlwZS5yb3RhdGUgPSBmdW5jdGlvbiAoYW5nbGUsIHBvaW50KSB7XHJcbiAgICAgICAgICAgIGlmIChwb2ludCA9PT0gdm9pZCAwKSB7IHBvaW50ID0gQWxnZWJyYV83LlZlY3Rvci5aZXJvLmNsb25lKCk7IH1cclxuICAgICAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMuZ2V0UG9pbnRzKCkubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLnJvdGF0ZShhbmdsZSwgcG9pbnQpOyB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIEJvdW5kaW5nQm94LmZyb21Qb2ludHMocG9pbnRzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIHBlcmltZXRlciBvZiB0aGUgYm91bmRpbmcgYm94XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQm91bmRpbmdCb3gucHJvdG90eXBlLmdldFBlcmltZXRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHd4ID0gdGhpcy5nZXRXaWR0aCgpO1xyXG4gICAgICAgICAgICB2YXIgd3kgPSB0aGlzLmdldEhlaWdodCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gMiAqICh3eCArIHd5KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEJvdW5kaW5nQm94LnByb3RvdHlwZS5nZXRQb2ludHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gW107XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChuZXcgQWxnZWJyYV83LlZlY3Rvcih0aGlzLmxlZnQsIHRoaXMudG9wKSk7XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChuZXcgQWxnZWJyYV83LlZlY3Rvcih0aGlzLnJpZ2h0LCB0aGlzLnRvcCkpO1xyXG4gICAgICAgICAgICByZXN1bHRzLnB1c2gobmV3IEFsZ2VicmFfNy5WZWN0b3IodGhpcy5yaWdodCwgdGhpcy5ib3R0b20pKTtcclxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKG5ldyBBbGdlYnJhXzcuVmVjdG9yKHRoaXMubGVmdCwgdGhpcy5ib3R0b20pKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgUG9seWdvbiBjb2xsaXNpb24gYXJlYSBmcm9tIHRoZSBwb2ludHMgb2YgdGhlIGJvdW5kaW5nIGJveFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJvdW5kaW5nQm94LnByb3RvdHlwZS50b1BvbHlnb24gPSBmdW5jdGlvbiAoYWN0b3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2x5Z29uQXJlYV8zLlBvbHlnb25BcmVhKHtcclxuICAgICAgICAgICAgICAgIGJvZHk6IGFjdG9yID8gYWN0b3IuYm9keSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBwb2ludHM6IHRoaXMuZ2V0UG9pbnRzKCksXHJcbiAgICAgICAgICAgICAgICBwb3M6IEFsZ2VicmFfNy5WZWN0b3IuWmVyby5jbG9uZSgpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgcmF5IGludGVyc2VjdHMgd2l0aCBhIGJvdW5kaW5nIGJveFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJvdW5kaW5nQm94LnByb3RvdHlwZS5yYXlDYXN0ID0gZnVuY3Rpb24gKHJheSwgZmFyQ2xpcERpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIGlmIChmYXJDbGlwRGlzdGFuY2UgPT09IHZvaWQgMCkgeyBmYXJDbGlwRGlzdGFuY2UgPSBJbmZpbml0eTsgfVxyXG4gICAgICAgICAgICAvLyBhbGdvcml0aG0gZnJvbSBodHRwczovL3RhdmlhbmF0b3IuY29tL2Zhc3QtYnJhbmNobGVzcy1yYXlib3VuZGluZy1ib3gtaW50ZXJzZWN0aW9ucy8gXHJcbiAgICAgICAgICAgIHZhciB0bWluID0gLUluZmluaXR5O1xyXG4gICAgICAgICAgICB2YXIgdG1heCA9ICtJbmZpbml0eTtcclxuICAgICAgICAgICAgdmFyIHhpbnYgPSByYXkuZGlyLnggPT09IDAgPyBOdW1iZXIuTUFYX1ZBTFVFIDogKDEgLyByYXkuZGlyLngpO1xyXG4gICAgICAgICAgICB2YXIgeWludiA9IHJheS5kaXIueSA9PT0gMCA/IE51bWJlci5NQVhfVkFMVUUgOiAoMSAvIHJheS5kaXIueSk7XHJcbiAgICAgICAgICAgIHZhciB0eDEgPSAodGhpcy5sZWZ0IC0gcmF5LnBvcy54KSAqIHhpbnY7XHJcbiAgICAgICAgICAgIHZhciB0eDIgPSAodGhpcy5yaWdodCAtIHJheS5wb3MueCkgKiB4aW52O1xyXG4gICAgICAgICAgICB0bWluID0gTWF0aC5taW4odHgxLCB0eDIpO1xyXG4gICAgICAgICAgICB0bWF4ID0gTWF0aC5tYXgodHgxLCB0eDIpO1xyXG4gICAgICAgICAgICB2YXIgdHkxID0gKHRoaXMudG9wIC0gcmF5LnBvcy55KSAqIHlpbnY7XHJcbiAgICAgICAgICAgIHZhciB0eTIgPSAodGhpcy5ib3R0b20gLSByYXkucG9zLnkpICogeWludjtcclxuICAgICAgICAgICAgdG1pbiA9IE1hdGgubWF4KHRtaW4sIE1hdGgubWluKHR5MSwgdHkyKSk7XHJcbiAgICAgICAgICAgIHRtYXggPSBNYXRoLm1pbih0bWF4LCBNYXRoLm1heCh0eTEsIHR5MikpO1xyXG4gICAgICAgICAgICByZXR1cm4gdG1heCA+PSBNYXRoLm1heCgwLCB0bWluKSAmJiB0bWluIDwgZmFyQ2xpcERpc3RhbmNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQm91bmRpbmdCb3gucHJvdG90eXBlLnJheUNhc3RUaW1lID0gZnVuY3Rpb24gKHJheSwgZmFyQ2xpcERpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIGlmIChmYXJDbGlwRGlzdGFuY2UgPT09IHZvaWQgMCkgeyBmYXJDbGlwRGlzdGFuY2UgPSBJbmZpbml0eTsgfVxyXG4gICAgICAgICAgICAvLyBhbGdvcml0aG0gZnJvbSBodHRwczovL3RhdmlhbmF0b3IuY29tL2Zhc3QtYnJhbmNobGVzcy1yYXlib3VuZGluZy1ib3gtaW50ZXJzZWN0aW9ucy8gXHJcbiAgICAgICAgICAgIHZhciB0bWluID0gLUluZmluaXR5O1xyXG4gICAgICAgICAgICB2YXIgdG1heCA9ICtJbmZpbml0eTtcclxuICAgICAgICAgICAgdmFyIHhpbnYgPSByYXkuZGlyLnggPT09IDAgPyBOdW1iZXIuTUFYX1ZBTFVFIDogKDEgLyByYXkuZGlyLngpO1xyXG4gICAgICAgICAgICB2YXIgeWludiA9IHJheS5kaXIueSA9PT0gMCA/IE51bWJlci5NQVhfVkFMVUUgOiAoMSAvIHJheS5kaXIueSk7XHJcbiAgICAgICAgICAgIHZhciB0eDEgPSAodGhpcy5sZWZ0IC0gcmF5LnBvcy54KSAqIHhpbnY7XHJcbiAgICAgICAgICAgIHZhciB0eDIgPSAodGhpcy5yaWdodCAtIHJheS5wb3MueCkgKiB4aW52O1xyXG4gICAgICAgICAgICB0bWluID0gTWF0aC5taW4odHgxLCB0eDIpO1xyXG4gICAgICAgICAgICB0bWF4ID0gTWF0aC5tYXgodHgxLCB0eDIpO1xyXG4gICAgICAgICAgICB2YXIgdHkxID0gKHRoaXMudG9wIC0gcmF5LnBvcy55KSAqIHlpbnY7XHJcbiAgICAgICAgICAgIHZhciB0eTIgPSAodGhpcy5ib3R0b20gLSByYXkucG9zLnkpICogeWludjtcclxuICAgICAgICAgICAgdG1pbiA9IE1hdGgubWF4KHRtaW4sIE1hdGgubWluKHR5MSwgdHkyKSk7XHJcbiAgICAgICAgICAgIHRtYXggPSBNYXRoLm1pbih0bWF4LCBNYXRoLm1heCh0eTEsIHR5MikpO1xyXG4gICAgICAgICAgICBpZiAodG1heCA+PSBNYXRoLm1heCgwLCB0bWluKSAmJiB0bWluIDwgZmFyQ2xpcERpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdG1pbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBCb3VuZGluZ0JveC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBBbGdlYnJhXzcuVmVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMubGVmdCA8PSB2YWwueCAmJiB0aGlzLnRvcCA8PSB2YWwueSAmJiB0aGlzLmJvdHRvbSA+PSB2YWwueSAmJiB0aGlzLnJpZ2h0ID49IHZhbC54KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBCb3VuZGluZ0JveCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGVmdCA8IHZhbC5sZWZ0ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b3AgPCB2YWwudG9wICYmXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsLmJvdHRvbSA8IHRoaXMuYm90dG9tICYmXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsLnJpZ2h0IDwgdGhpcy5yaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbWJpbmVzIHRoaXMgYm91bmRpbmcgYm94IGFuZCBhbm90aGVyIHRvZ2V0aGVyIHJldHVybmluZyBhIG5ldyBib3VuZGluZyBib3hcclxuICAgICAgICAgKiBAcGFyYW0gb3RoZXIgIFRoZSBib3VuZGluZyBib3ggdG8gY29tYmluZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJvdW5kaW5nQm94LnByb3RvdHlwZS5jb21iaW5lID0gZnVuY3Rpb24gKG90aGVyKSB7XHJcbiAgICAgICAgICAgIHZhciBjb21wb3NpdGVCQiA9IG5ldyBCb3VuZGluZ0JveChNYXRoLm1pbih0aGlzLmxlZnQsIG90aGVyLmxlZnQpLCBNYXRoLm1pbih0aGlzLnRvcCwgb3RoZXIudG9wKSwgTWF0aC5tYXgodGhpcy5yaWdodCwgb3RoZXIucmlnaHQpLCBNYXRoLm1heCh0aGlzLmJvdHRvbSwgb3RoZXIuYm90dG9tKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wb3NpdGVCQjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRlc3Qgd2V0aGVyIHRoaXMgYm91bmRpbmcgYm94IGNvbGxpZGVzIHdpdGggYW5vdGhlciByZXR1cm5pbmcsXHJcbiAgICAgICAgICogdGhlIGludGVyc2VjdGlvbiB2ZWN0b3IgdGhhdCBjYW4gYmUgdXNlZCB0byByZXNvbHZlIHRoZSBjb2xsaXNpb24uIElmIHRoZXJlXHJcbiAgICAgICAgICogaXMgbm8gY29sbGlzaW9uIG51bGwgaXMgcmV0dXJuZWQuXHJcbiAgICAgICAgICogQHBhcmFtIGNvbGxpZGFibGUgIE90aGVyIGNvbGxpZGFibGUgdG8gdGVzdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJvdW5kaW5nQm94LnByb3RvdHlwZS5jb2xsaWRlcyA9IGZ1bmN0aW9uIChjb2xsaWRhYmxlKSB7XHJcbiAgICAgICAgICAgIGlmIChjb2xsaWRhYmxlIGluc3RhbmNlb2YgQm91bmRpbmdCb3gpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvdGhlciA9IGNvbGxpZGFibGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgdG90YWxCb3VuZGluZ0JveCA9IHRoaXMuY29tYmluZShvdGhlcik7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdG90YWwgYm91bmRpbmcgYm94IGlzIGxlc3MgdGhhbiB0aGUgc3VtIG9mIHRoZSAyIGJvdW5kcyB0aGVuIHRoZXJlIGlzIGNvbGxpc2lvblxyXG4gICAgICAgICAgICAgICAgaWYgKHRvdGFsQm91bmRpbmdCb3guZ2V0V2lkdGgoKSA8IG90aGVyLmdldFdpZHRoKCkgKyB0aGlzLmdldFdpZHRoKCkgJiZcclxuICAgICAgICAgICAgICAgICAgICB0b3RhbEJvdW5kaW5nQm94LmdldEhlaWdodCgpIDwgb3RoZXIuZ2V0SGVpZ2h0KCkgKyB0aGlzLmdldEhlaWdodCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29sbGlzaW9uXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG92ZXJsYXBYID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yaWdodCA+PSBvdGhlci5sZWZ0ICYmIHRoaXMucmlnaHQgPD0gb3RoZXIucmlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcFggPSBvdGhlci5sZWZ0IC0gdGhpcy5yaWdodDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXBYID0gb3RoZXIucmlnaHQgLSB0aGlzLmxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvdmVybGFwWSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudG9wIDw9IG90aGVyLmJvdHRvbSAmJiB0aGlzLnRvcCA+PSBvdGhlci50b3ApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcFkgPSBvdGhlci5ib3R0b20gLSB0aGlzLnRvcDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXBZID0gb3RoZXIudG9wIC0gdGhpcy5ib3R0b207XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhvdmVybGFwWCkgPCBNYXRoLmFicyhvdmVybGFwWSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBbGdlYnJhXzcuVmVjdG9yKG92ZXJsYXBYLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWxnZWJyYV83LlZlY3RvcigwLCBvdmVybGFwWSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIEJvdW5kaW5nQm94LnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY3R4LCBjb2xvcikge1xyXG4gICAgICAgICAgICBpZiAoY29sb3IgPT09IHZvaWQgMCkgeyBjb2xvciA9IENvbG9yXzMuQ29sb3IuWWVsbG93OyB9XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2VSZWN0KHRoaXMubGVmdCwgdGhpcy50b3AsIHRoaXMuZ2V0V2lkdGgoKSwgdGhpcy5nZXRIZWlnaHQoKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gQm91bmRpbmdCb3g7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5Cb3VuZGluZ0JveCA9IEJvdW5kaW5nQm94O1xyXG59KTtcclxuZGVmaW5lKFwiQ29sbGlzaW9uL0VkZ2VBcmVhXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiQ29sbGlzaW9uL0JvdW5kaW5nQm94XCIsIFwiQ29sbGlzaW9uL0NvbGxpc2lvbkp1bXBUYWJsZVwiLCBcIkNvbGxpc2lvbi9DaXJjbGVBcmVhXCIsIFwiQ29sbGlzaW9uL1BvbHlnb25BcmVhXCIsIFwiQWxnZWJyYVwiLCBcIlBoeXNpY3NcIiwgXCJEcmF3aW5nL0NvbG9yXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgQm91bmRpbmdCb3hfMywgQ29sbGlzaW9uSnVtcFRhYmxlXzMsIENpcmNsZUFyZWFfMiwgUG9seWdvbkFyZWFfNCwgQWxnZWJyYV84LCBQaHlzaWNzXzQsIENvbG9yXzQpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgdmFyIEVkZ2VBcmVhID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBFZGdlQXJlYShvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmVnaW4gPSBvcHRpb25zLmJlZ2luIHx8IEFsZ2VicmFfOC5WZWN0b3IuWmVyby5jbG9uZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmVuZCA9IG9wdGlvbnMuZW5kIHx8IEFsZ2VicmFfOC5WZWN0b3IuWmVyby5jbG9uZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBvcHRpb25zLmJvZHkgfHwgbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5wb3MgPSB0aGlzLmdldENlbnRlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgdGhlIGNlbnRlciBvZiB0aGUgY29sbGlzaW9uIGFyZWEgaW4gd29ybGQgY29vcmRpbmF0ZXNcclxuICAgICAgICAgKi9cclxuICAgICAgICBFZGdlQXJlYS5wcm90b3R5cGUuZ2V0Q2VudGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5iZWdpbi5hdmVyYWdlKHRoaXMuZW5kKS5hZGQodGhpcy5fZ2V0Qm9keVBvcygpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHBvcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIEVkZ2VBcmVhLnByb3RvdHlwZS5fZ2V0Qm9keVBvcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGJvZHlQb3MgPSBBbGdlYnJhXzguVmVjdG9yLlplcm8uY2xvbmUoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYm9keS5wb3MpIHtcclxuICAgICAgICAgICAgICAgIGJvZHlQb3MgPSB0aGlzLmJvZHkucG9zO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBib2R5UG9zO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRWRnZUFyZWEucHJvdG90eXBlLl9nZXRUcmFuc2Zvcm1lZEJlZ2luID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYW5nbGUgPSB0aGlzLmJvZHkgPyB0aGlzLmJvZHkucm90YXRpb24gOiAwO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iZWdpbi5yb3RhdGUoYW5nbGUpLmFkZCh0aGlzLl9nZXRCb2R5UG9zKCkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRWRnZUFyZWEucHJvdG90eXBlLl9nZXRUcmFuc2Zvcm1lZEVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGFuZ2xlID0gdGhpcy5ib2R5ID8gdGhpcy5ib2R5LnJvdGF0aW9uIDogMDtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5kLnJvdGF0ZShhbmdsZSkuYWRkKHRoaXMuX2dldEJvZHlQb3MoKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBzbG9wZSBvZiB0aGUgbGluZSBpbiB0aGUgZm9ybSBvZiBhIHZlY3RvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVkZ2VBcmVhLnByb3RvdHlwZS5nZXRTbG9wZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGJlZ2luID0gdGhpcy5fZ2V0VHJhbnNmb3JtZWRCZWdpbigpO1xyXG4gICAgICAgICAgICB2YXIgZW5kID0gdGhpcy5fZ2V0VHJhbnNmb3JtZWRFbmQoKTtcclxuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gYmVnaW4uZGlzdGFuY2UoZW5kKTtcclxuICAgICAgICAgICAgcmV0dXJuIGVuZC5zdWIoYmVnaW4pLnNjYWxlKDEgLyBkaXN0YW5jZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIGxpbmUgc2VnbWVudCBpbiBwaXhlbHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBFZGdlQXJlYS5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYmVnaW4gPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZEJlZ2luKCk7XHJcbiAgICAgICAgICAgIHZhciBlbmQgPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZEVuZCgpO1xyXG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBiZWdpbi5kaXN0YW5jZShlbmQpO1xyXG4gICAgICAgICAgICByZXR1cm4gZGlzdGFuY2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZXN0cyBpZiBhIHBvaW50IGlzIGNvbnRhaW5lZCBpbiB0aGlzIGNvbGxpc2lvbiBhcmVhXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRWRnZUFyZWEucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAaW5oZXJpdGRvY1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVkZ2VBcmVhLnByb3RvdHlwZS5yYXlDYXN0ID0gZnVuY3Rpb24gKHJheSwgbWF4KSB7XHJcbiAgICAgICAgICAgIGlmIChtYXggPT09IHZvaWQgMCkgeyBtYXggPSBJbmZpbml0eTsgfVxyXG4gICAgICAgICAgICB2YXIgbnVtZXJhdG9yID0gdGhpcy5fZ2V0VHJhbnNmb3JtZWRCZWdpbigpLnN1YihyYXkucG9zKTtcclxuICAgICAgICAgICAgLy8gVGVzdCBpcyBsaW5lIGFuZCByYXkgYXJlIHBhcmFsbGVsIGFuZCBub24gaW50ZXJzZWN0aW5nXHJcbiAgICAgICAgICAgIGlmIChyYXkuZGlyLmNyb3NzKHRoaXMuZ2V0U2xvcGUoKSkgPT09IDAgJiYgbnVtZXJhdG9yLmNyb3NzKHJheS5kaXIpICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBMaW5lcyBhcmUgcGFyYWxsZWxcclxuICAgICAgICAgICAgdmFyIGRpdmlzb3IgPSAocmF5LmRpci5jcm9zcyh0aGlzLmdldFNsb3BlKCkpKTtcclxuICAgICAgICAgICAgaWYgKGRpdmlzb3IgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB0ID0gbnVtZXJhdG9yLmNyb3NzKHRoaXMuZ2V0U2xvcGUoKSkgLyBkaXZpc29yO1xyXG4gICAgICAgICAgICBpZiAodCA+PSAwICYmIHQgPD0gbWF4KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdSA9IChudW1lcmF0b3IuY3Jvc3MocmF5LmRpcikgLyBkaXZpc29yKSAvIHRoaXMuZ2V0TGVuZ3RoKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodSA+PSAwICYmIHUgPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByYXkuZ2V0UG9pbnQodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAaW5oZXJpdGRvY1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVkZ2VBcmVhLnByb3RvdHlwZS5jb2xsaWRlID0gZnVuY3Rpb24gKGFyZWEpIHtcclxuICAgICAgICAgICAgaWYgKGFyZWEgaW5zdGFuY2VvZiBDaXJjbGVBcmVhXzIuQ2lyY2xlQXJlYSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbGxpc2lvbkp1bXBUYWJsZV8zLkNvbGxpc2lvbkp1bXBUYWJsZS5Db2xsaWRlQ2lyY2xlRWRnZShhcmVhLCB0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChhcmVhIGluc3RhbmNlb2YgUG9seWdvbkFyZWFfNC5Qb2x5Z29uQXJlYSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbGxpc2lvbkp1bXBUYWJsZV8zLkNvbGxpc2lvbkp1bXBUYWJsZS5Db2xsaWRlUG9seWdvbkVkZ2UoYXJlYSwgdGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYXJlYSBpbnN0YW5jZW9mIEVkZ2VBcmVhKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29sbGlzaW9uSnVtcFRhYmxlXzMuQ29sbGlzaW9uSnVtcFRhYmxlLkNvbGxpZGVFZGdlRWRnZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWRnZSBjb3VsZCBub3QgY29sbGlkZSB3aXRoIHVua25vd24gSUNvbGxpc2lvbkFyZWEgXCIgKyB0eXBlb2YgYXJlYSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZpbmQgdGhlIHBvaW50IG9uIHRoZSBzaGFwZSBmdXJ0aGVzdCBpbiB0aGUgZGlyZWN0aW9uIHNwZWNpZmllZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVkZ2VBcmVhLnByb3RvdHlwZS5nZXRGdXJ0aGVzdFBvaW50ID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWRCZWdpbiA9IHRoaXMuX2dldFRyYW5zZm9ybWVkQmVnaW4oKTtcclxuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkRW5kID0gdGhpcy5fZ2V0VHJhbnNmb3JtZWRFbmQoKTtcclxuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbi5kb3QodHJhbnNmb3JtZWRCZWdpbikgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWRCZWdpbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZEVuZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IHRoZSBheGlzIGFsaWduZWQgYm91bmRpbmcgYm94IGZvciB0aGUgY2lyY2xlIGFyZWFcclxuICAgICAgICAgKi9cclxuICAgICAgICBFZGdlQXJlYS5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWRCZWdpbiA9IHRoaXMuX2dldFRyYW5zZm9ybWVkQmVnaW4oKTtcclxuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkRW5kID0gdGhpcy5fZ2V0VHJhbnNmb3JtZWRFbmQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveF8zLkJvdW5kaW5nQm94KE1hdGgubWluKHRyYW5zZm9ybWVkQmVnaW4ueCwgdHJhbnNmb3JtZWRFbmQueCksIE1hdGgubWluKHRyYW5zZm9ybWVkQmVnaW4ueSwgdHJhbnNmb3JtZWRFbmQueSksIE1hdGgubWF4KHRyYW5zZm9ybWVkQmVnaW4ueCwgdHJhbnNmb3JtZWRFbmQueCksIE1hdGgubWF4KHRyYW5zZm9ybWVkQmVnaW4ueSwgdHJhbnNmb3JtZWRFbmQueSkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IHRoZSBheGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZWRnZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVkZ2VBcmVhLnByb3RvdHlwZS5nZXRBeGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMuX2dldFRyYW5zZm9ybWVkRW5kKCkuc3ViKHRoaXMuX2dldFRyYW5zZm9ybWVkQmVnaW4oKSk7XHJcbiAgICAgICAgICAgIHZhciBlZGdlTm9ybWFsID0gZS5ub3JtYWwoKTtcclxuICAgICAgICAgICAgdmFyIGF4ZXMgPSBbXTtcclxuICAgICAgICAgICAgYXhlcy5wdXNoKGVkZ2VOb3JtYWwpO1xyXG4gICAgICAgICAgICBheGVzLnB1c2goZWRnZU5vcm1hbC5uZWdhdGUoKSk7XHJcbiAgICAgICAgICAgIGF4ZXMucHVzaChlZGdlTm9ybWFsLm5vcm1hbCgpKTtcclxuICAgICAgICAgICAgYXhlcy5wdXNoKGVkZ2VOb3JtYWwubm9ybWFsKCkubmVnYXRlKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gYXhlcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCB0aGUgbW9tZW50IG9mIGluZXJ0aWEgZm9yIGFuIGVkZ2VcclxuICAgICAgICAgKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaXN0X29mX21vbWVudHNfb2ZfaW5lcnRpYVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVkZ2VBcmVhLnByb3RvdHlwZS5nZXRNb21lbnRPZkluZXJ0aWEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBtYXNzID0gdGhpcy5ib2R5ID8gdGhpcy5ib2R5Lm1hc3MgOiBQaHlzaWNzXzQuUGh5c2ljcy5kZWZhdWx0TWFzcztcclxuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuZW5kLnN1Yih0aGlzLmJlZ2luKS5kaXN0YW5jZSgpIC8gMjtcclxuICAgICAgICAgICAgcmV0dXJuIG1hc3MgKiBsZW5ndGggKiBsZW5ndGg7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAaW5oZXJpdGRvY1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVkZ2VBcmVhLnByb3RvdHlwZS5yZWNhbGMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIGVkZ2VzIGRvbid0IGhhdmUgYW55IGNhY2hlZCBkYXRhXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcm9qZWN0IHRoZSBlZGdlIGFsb25nIGEgc3BlY2lmaWVkIGF4aXNcclxuICAgICAgICAgKi9cclxuICAgICAgICBFZGdlQXJlYS5wcm90b3R5cGUucHJvamVjdCA9IGZ1bmN0aW9uIChheGlzKSB7XHJcbiAgICAgICAgICAgIHZhciBzY2FsYXJzID0gW107XHJcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSBbdGhpcy5fZ2V0VHJhbnNmb3JtZWRCZWdpbigpLCB0aGlzLl9nZXRUcmFuc2Zvcm1lZEVuZCgpXTtcclxuICAgICAgICAgICAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHNjYWxhcnMucHVzaChwb2ludHNbaV0uZG90KGF4aXMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFsZ2VicmFfOC5Qcm9qZWN0aW9uKE1hdGgubWluLmFwcGx5KE1hdGgsIHNjYWxhcnMpLCBNYXRoLm1heC5hcHBseShNYXRoLCBzY2FsYXJzKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIEVkZ2VBcmVhLnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY3R4LCBjb2xvcikge1xyXG4gICAgICAgICAgICBpZiAoY29sb3IgPT09IHZvaWQgMCkgeyBjb2xvciA9IENvbG9yXzQuQ29sb3IuUmVkLmNsb25lKCk7IH1cclxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3IudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHgubW92ZVRvKHRoaXMuYmVnaW4ueCwgdGhpcy5iZWdpbi55KTtcclxuICAgICAgICAgICAgY3R4LmxpbmVUbyh0aGlzLmVuZC54LCB0aGlzLmVuZC55KTtcclxuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gRWRnZUFyZWE7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5FZGdlQXJlYSA9IEVkZ2VBcmVhO1xyXG59KTtcclxuZGVmaW5lKFwiVXRpbC9EcmF3VXRpbFwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkRyYXdpbmcvQ29sb3JcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBDb2xvcl81KSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogRHJhdyBhIGxpbmUgb24gY2FudmFzIGNvbnRleHRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IFRoZSBjYW52YXMgY29udGV4dFxyXG4gICAgICogQHBhcmFtIGNvbG9yIFRoZSBjb2xvciBvZiB0aGUgbGluZVxyXG4gICAgICogQHBhcmFtIHgxIFRoZSBzdGFydCB4IGNvb3JkaW5hdGVcclxuICAgICAqIEBwYXJhbSB5MSBUaGUgc3RhcnQgeSBjb29yZGluYXRlXHJcbiAgICAgKiBAcGFyYW0geDIgVGhlIGVuZGluZyB4IGNvb3JkaW5hdGVcclxuICAgICAqIEBwYXJhbSB5MiBUaGUgZW5kaW5nIHkgY29vcmRpbmF0ZVxyXG4gICAgICogQHBhcmFtIHRoaWNrbmVzcyBUaGUgbGluZSB0aGlja25lc3NcclxuICAgICAqIEBwYXJhbSBjYXAgVGhlIFtbTGluZUNhcFN0eWxlXV0gKGJ1dHQsIHJvdW5kLCBvciBzcXVhcmUpXHJcbiAgICAgKi9cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICBmdW5jdGlvbiBsaW5lKGN0eCwgY29sb3IsIHgxLCB5MSwgeDIsIHkyLCB0aGlja25lc3MsIGNhcCkge1xyXG4gICAgICAgIGlmIChjb2xvciA9PT0gdm9pZCAwKSB7IGNvbG9yID0gQ29sb3JfNS5Db2xvci5SZWQuY2xvbmUoKTsgfVxyXG4gICAgICAgIGlmICh0aGlja25lc3MgPT09IHZvaWQgMCkgeyB0aGlja25lc3MgPSAxOyB9XHJcbiAgICAgICAgaWYgKGNhcCA9PT0gdm9pZCAwKSB7IGNhcCA9ICdidXR0JzsgfVxyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICBjdHgubGluZVdpZHRoID0gdGhpY2tuZXNzO1xyXG4gICAgICAgIGN0eC5saW5lQ2FwID0gY2FwO1xyXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xyXG4gICAgICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcclxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5saW5lID0gbGluZTtcclxuICAgIC8qKlxyXG4gICAgICogRHJhdyB0aGUgdmVjdG9yIGFzIGEgcG9pbnQgb250byB0aGUgY2FudmFzLlxyXG4gICAgICovXHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgZnVuY3Rpb24gcG9pbnQoY3R4LCBjb2xvciwgcG9pbnQpIHtcclxuICAgICAgICBpZiAoY29sb3IgPT09IHZvaWQgMCkgeyBjb2xvciA9IENvbG9yXzUuQ29sb3IuUmVkLmNsb25lKCk7IH1cclxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3IudG9TdHJpbmcoKTtcclxuICAgICAgICBjdHguYXJjKHBvaW50LngsIHBvaW50LnksIDUsIDAsIE1hdGguUEkgKiAyKTtcclxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5wb2ludCA9IHBvaW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IHRoZSB2ZWN0b3IgYXMgYSBsaW5lIG9udG8gdGhlIGNhbnZhcyBzdGFydGluZyBhIG9yaWdpbiBwb2ludC5cclxuICAgICAqL1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIGZ1bmN0aW9uIHZlY3RvcihjdHgsIGNvbG9yLCBvcmlnaW4sIHZlY3Rvciwgc2NhbGUpIHtcclxuICAgICAgICBpZiAoc2NhbGUgPT09IHZvaWQgMCkgeyBzY2FsZSA9IDEuMDsgfVxyXG4gICAgICAgIHZhciBjID0gY29sb3IgPyBjb2xvci50b1N0cmluZygpIDogJ2JsdWUnO1xyXG4gICAgICAgIHZhciB2ID0gdmVjdG9yLnNjYWxlKHNjYWxlKTtcclxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gYztcclxuICAgICAgICBjdHgubW92ZVRvKG9yaWdpbi54LCBvcmlnaW4ueSk7XHJcbiAgICAgICAgY3R4LmxpbmVUbyhvcmlnaW4ueCArIHYueCwgb3JpZ2luLnkgKyB2LnkpO1xyXG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLnZlY3RvciA9IHZlY3RvcjtcclxuICAgIC8qKlxyXG4gICAgICogRHJhdyBhIHJvdW5kIHJlY3RhbmdsZSBvbiBhIGNhbnZhcyBjb250ZXh0XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCBUaGUgY2FudmFzIGNvbnRleHRcclxuICAgICAqIEBwYXJhbSB4IFRoZSB0b3AtbGVmdCB4IGNvb3JkaW5hdGVcclxuICAgICAqIEBwYXJhbSB5IFRoZSB0b3AtbGVmdCB5IGNvb3JkaW5hdGVcclxuICAgICAqIEBwYXJhbSB3aWR0aCBUaGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZVxyXG4gICAgICogQHBhcmFtIGhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcclxuICAgICAqIEBwYXJhbSByYWRpdXMgVGhlIGJvcmRlciByYWRpdXMgb2YgdGhlIHJlY3RhbmdsZVxyXG4gICAgICogQHBhcmFtIGZpbGwgVGhlIFtbQ29sb3JdXSB0byBmaWxsIHJlY3RhbmdsZSB3aXRoXHJcbiAgICAgKiBAcGFyYW0gc3Ryb2tlIFRoZSBbW0NvbG9yXV0gdG8gc3Ryb2tlIHJlY3RhbmdsZSB3aXRoXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHJvdW5kUmVjdChjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cywgc3Ryb2tlLCBmaWxsKSB7XHJcbiAgICAgICAgaWYgKHJhZGl1cyA9PT0gdm9pZCAwKSB7IHJhZGl1cyA9IDU7IH1cclxuICAgICAgICBpZiAoc3Ryb2tlID09PSB2b2lkIDApIHsgc3Ryb2tlID0gQ29sb3JfNS5Db2xvci5XaGl0ZTsgfVxyXG4gICAgICAgIGlmIChmaWxsID09PSB2b2lkIDApIHsgZmlsbCA9IG51bGw7IH1cclxuICAgICAgICB2YXIgYnI7XHJcbiAgICAgICAgaWYgKHR5cGVvZiByYWRpdXMgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIGJyID0geyB0bDogcmFkaXVzLCB0cjogcmFkaXVzLCBicjogcmFkaXVzLCBibDogcmFkaXVzIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgZGVmYXVsdFJhZGl1cyA9IHsgdGw6IDAsIHRyOiAwLCBicjogMCwgYmw6IDAgfTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBkZWZhdWx0UmFkaXVzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVmYXVsdFJhZGl1cy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzaWRlID0gcHJvcDtcclxuICAgICAgICAgICAgICAgICAgICBicltzaWRlXSA9IHJhZGl1c1tzaWRlXSB8fCBkZWZhdWx0UmFkaXVzW3NpZGVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICBjdHgubW92ZVRvKHggKyBici50bCwgeSk7XHJcbiAgICAgICAgY3R4LmxpbmVUbyh4ICsgd2lkdGggLSBici50ciwgeSk7XHJcbiAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyBici50cik7XHJcbiAgICAgICAgY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSBici5icik7XHJcbiAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSBici5iciwgeSArIGhlaWdodCk7XHJcbiAgICAgICAgY3R4LmxpbmVUbyh4ICsgYnIuYmwsIHkgKyBoZWlnaHQpO1xyXG4gICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSBici5ibCk7XHJcbiAgICAgICAgY3R4LmxpbmVUbyh4LCB5ICsgYnIudGwpO1xyXG4gICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHksIHggKyBici50bCwgeSk7XHJcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIGlmIChmaWxsKSB7XHJcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdHJva2UpIHtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLnJvdW5kUmVjdCA9IHJvdW5kUmVjdDtcclxuICAgIGZ1bmN0aW9uIGNpcmNsZShjdHgsIHgsIHksIHJhZGl1cywgc3Ryb2tlLCBmaWxsKSB7XHJcbiAgICAgICAgaWYgKHN0cm9rZSA9PT0gdm9pZCAwKSB7IHN0cm9rZSA9IENvbG9yXzUuQ29sb3IuV2hpdGU7IH1cclxuICAgICAgICBpZiAoZmlsbCA9PT0gdm9pZCAwKSB7IGZpbGwgPSBudWxsOyB9XHJcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzLCAwLCBNYXRoLlBJICogMik7XHJcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIGlmIChmaWxsKSB7XHJcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdHJva2UpIHtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLmNpcmNsZSA9IGNpcmNsZTtcclxufSk7XHJcbmRlZmluZShcIkNvbGxpc2lvbi9Cb2R5XCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiUGh5c2ljc1wiLCBcIkNvbGxpc2lvbi9FZGdlQXJlYVwiLCBcIkNvbGxpc2lvbi9DaXJjbGVBcmVhXCIsIFwiQ29sbGlzaW9uL1BvbHlnb25BcmVhXCIsIFwiQ29sbGlzaW9uL1BhaXJcIiwgXCJBbGdlYnJhXCIsIFwiRHJhd2luZy9Db2xvclwiLCBcIlV0aWwvRHJhd1V0aWxcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBQaHlzaWNzXzUsIEVkZ2VBcmVhXzMsIENpcmNsZUFyZWFfMywgUG9seWdvbkFyZWFfNSwgUGFpcl8xLCBBbGdlYnJhXzksIENvbG9yXzYsIERyYXdVdGlsKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIHZhciBCb2R5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHBoeXNpY3MgYm9keSBhc3NvY2lhdGVkIHdpdGggYW4gYWN0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBCb2R5KGFjdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0b3IgPSBhY3RvcjtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFtbSUNvbGxpc2lvbkFyZWF8Q29sbGlzaW9uIGFyZWFdXSBvZiB0aGlzIHBoeXNpY3MgYm9keSwgZGVmaW5lcyB0aGUgc2hhcGUgZm9yIHJpZ2lkIGJvZHkgY29sbGlzaW9uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmNvbGxpc2lvbkFyZWEgPSBudWxsO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlICh4LCB5KSBwb3NpdGlvbiBvZiB0aGUgYWN0b3IgdGhpcyB3aWxsIGJlIGluIHRoZSBtaWRkbGUgb2YgdGhlIGFjdG9yIGlmIHRoZVxyXG4gICAgICAgICAgICAgKiBbW0FjdG9yLmFuY2hvcl1dIGlzIHNldCB0byAoMC41LCAwLjUpIHdoaWNoIGlzIGRlZmF1bHQuXHJcbiAgICAgICAgICAgICAqIElmIHlvdSB3YW50IHRoZSAoeCwgeSkgcG9zaXRpb24gdG8gYmUgdGhlIHRvcCBsZWZ0IG9mIHRoZSBhY3RvciBzcGVjaWZ5IGFuIGFuY2hvciBvZiAoMCwgMCkuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnBvcyA9IG5ldyBBbGdlYnJhXzkuVmVjdG9yKDAsIDApO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIHBvc2l0aW9uIG9mIHRoZSBhY3RvciBsYXN0IGZyYW1lICh4LCB5KSBpbiBwaXhlbHNcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMub2xkUG9zID0gbmV3IEFsZ2VicmFfOS5WZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgY3VycmVudCB2ZWxvY2l0eSB2ZWN0b3IgKHZ4LCB2eSkgb2YgdGhlIGFjdG9yIGluIHBpeGVscy9zZWNvbmRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMudmVsID0gbmV3IEFsZ2VicmFfOS5WZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgdmVsb2NpdHkgb2YgdGhlIGFjdG9yIGxhc3QgZnJhbWUgKHZ4LCB2eSkgaW4gcGl4ZWxzL3NlY29uZFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5vbGRWZWwgPSBuZXcgQWxnZWJyYV85LlZlY3RvcigwLCAwKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBjdXJyZXQgYWNjZWxlcmF0aW9uIHZlY3RvciAoYXgsIGF5KSBvZiB0aGUgYWN0b3IgaW4gcGl4ZWxzL3NlY29uZC9zZWNvbmQuIEFuIGFjY2VsZXJhdGlvbiBwb2ludGluZyBkb3duIHN1Y2ggYXMgKDAsIDEwMCkgbWF5XHJcbiAgICAgICAgICAgICAqIGJlIHVzZWZ1bCB0byBzaW11bGF0ZSBhIGdyYXZpdGF0aW9uYWwgZWZmZWN0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5hY2MgPSBuZXcgQWxnZWJyYV85LlZlY3RvcigwLCAwKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBjdXJyZW50IHRvcnF1ZSBhcHBsaWVkIHRvIHRoZSBhY3RvclxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy50b3JxdWUgPSAwO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGN1cnJlbnQgbWFzcyBvZiB0aGUgYWN0b3IsIG1hc3MgY2FuIGJlIHRob3VnaHQgb2YgYXMgdGhlIHJlc2lzdGFuY2UgdG8gYWNjZWxlcmF0aW9uLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5tYXNzID0gMS4wO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGN1cnJlbnQgbW9tZW50IG9mIGluZXJ0aWEsIG1vaSBjYW4gYmUgdGhvdWdodCBvZiBhcyB0aGUgcmVzaXN0YW5jZSB0byByb3RhdGlvbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMubW9pID0gMTAwMDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBjdXJyZW50IFwibW90aW9uXCIgb2YgdGhlIGFjdG9yLCB1c2VkIHRvIGNhbGN1bGF0ZWQgc2xlZXAgaW4gdGhlIHBoeXNpY3Mgc2ltdWxhdGlvblxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5tb3Rpb24gPSAxMDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBjb2VmZmljaWVudCBvZiBmcmljdGlvbiBvbiB0aGlzIGFjdG9yXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmZyaWN0aW9uID0gLjk5O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGNvZWZmaWNpZW50IG9mIHJlc3RpdHV0aW9uIG9mIHRoaXMgYWN0b3IsIHJlcHJlc2VudHMgdGhlIGFtb3VudCBvZiBlbmVyZ3kgcHJlc2VydmVkIGFmdGVyIGNvbGxpc2lvblxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5yZXN0aXR1dGlvbiA9IC4yO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIHJvdGF0aW9uIG9mIHRoZSBhY3RvciBpbiByYWRpYW5zXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uID0gMDsgLy8gcmFkaWFuc1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIHJvdGF0aW9uYWwgdmVsb2NpdHkgb2YgdGhlIGFjdG9yIGluIHJhZGlhbnMvc2Vjb25kXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnJ4ID0gMDsgLy9yYWRpYW5zL3NlY1xyXG4gICAgICAgICAgICB0aGlzLl90b3RhbE10diA9IEFsZ2VicmFfOS5WZWN0b3IuWmVyby5jbG9uZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGQgbWluaW11bSB0cmFuc2xhdGlvbiB2ZWN0b3JzIGFjY3VtdWxhdGVkIGR1cmluZyB0aGUgY3VycmVudCBmcmFtZSB0byByZXNvbHZlIGNvbGxpc2lvbnMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQm9keS5wcm90b3R5cGUuYWRkTXR2ID0gZnVuY3Rpb24gKG10dikge1xyXG4gICAgICAgICAgICB0aGlzLl90b3RhbE10di5hZGRFcXVhbChtdHYpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXBwbGllcyB0aGUgYWNjdW11bGF0ZWQgdHJhbnNsYXRpb24gdmVjdG9ycyB0byB0aGUgYWN0b3JzIHBvc2l0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQm9keS5wcm90b3R5cGUuYXBwbHlNdHYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9zLmFkZEVxdWFsKHRoaXMuX3RvdGFsTXR2KTtcclxuICAgICAgICAgICAgdGhpcy5fdG90YWxNdHYuc2V0VG8oMCwgMCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBib2R5J3MgW1tCb3VuZGluZ0JveF1dIGNhbGN1bGF0ZWQgZm9yIHRoaXMgaW5zdGFudCBpbiB3b3JsZCBzcGFjZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBCb2R5LnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChQaHlzaWNzXzUuUGh5c2ljcy5jb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kgPT09IFBoeXNpY3NfNS5Db2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kuQm94KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hY3Rvci5nZXRCb3VuZHMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbGxpc2lvbkFyZWEuZ2V0Qm91bmRzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIGFjdG9yJ3MgW1tCb3VuZGluZ0JveF1dIHJlbGF0aXZlIHRvIHRoZSBhY3RvcnMgcG9zaXRpb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQm9keS5wcm90b3R5cGUuZ2V0UmVsYXRpdmVCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChQaHlzaWNzXzUuUGh5c2ljcy5jb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kgPT09IFBoeXNpY3NfNS5Db2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kuQm94KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hY3Rvci5nZXRSZWxhdGl2ZUJvdW5kcygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0b3IuZ2V0UmVsYXRpdmVCb3VuZHMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXBkYXRlcyB0aGUgY29sbGlzaW9uIGFyZWEgZ2VvbWV0cnkgYW5kIGludGVybmFsIGNhY2hlc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJvZHkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29sbGlzaW9uQXJlYSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25BcmVhLnJlY2FsYygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHVwIGEgYm94IGNvbGxpc2lvbiBhcmVhIGJhc2VkIG9uIHRoZSBjdXJyZW50IGJvdW5kcyBvZiB0aGUgYXNzb2NpYXRlZCBhY3RvciBvZiB0aGlzIHBoeXNpY3MgYm9keS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEJ5IGRlZmF1bHQsIHRoZSBib3ggaXMgY2VudGVyIGlzIGF0ICgwLCAwKSB3aGljaCBtZWFucyBpdCBpcyBjZW50ZXJlZCBhcm91bmQgdGhlIGFjdG9ycyBhbmNob3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQm9keS5wcm90b3R5cGUudXNlQm94Q29sbGlzaW9uID0gZnVuY3Rpb24gKGNlbnRlcikge1xyXG4gICAgICAgICAgICBpZiAoY2VudGVyID09PSB2b2lkIDApIHsgY2VudGVyID0gQWxnZWJyYV85LlZlY3Rvci5aZXJvLmNsb25lKCk7IH1cclxuICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25BcmVhID0gbmV3IFBvbHlnb25BcmVhXzUuUG9seWdvbkFyZWEoe1xyXG4gICAgICAgICAgICAgICAgYm9keTogdGhpcyxcclxuICAgICAgICAgICAgICAgIHBvaW50czogdGhpcy5hY3Rvci5nZXRSZWxhdGl2ZUJvdW5kcygpLmdldFBvaW50cygpLFxyXG4gICAgICAgICAgICAgICAgcG9zOiBjZW50ZXIgLy8gcG9zaXRpb24gcmVsYXRpdmUgdG8gYWN0b3JcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIGluIGNhc2Ugb2YgYSBuYW4gbW9pLCBjb2FsZXNjZSB0byBhIHNhZmUgZGVmYXVsdFxyXG4gICAgICAgICAgICB0aGlzLm1vaSA9IHRoaXMuY29sbGlzaW9uQXJlYS5nZXRNb21lbnRPZkluZXJ0aWEoKSB8fCB0aGlzLm1vaTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdXAgYSBwb2x5Z29uIGNvbGxpc2lvbiBhcmVhIGJhc2VkIG9uIGEgbGlzdCBvZiBvZiBwb2ludHMgcmVsYXRpdmUgdG8gdGhlIGFuY2hvciBvZiB0aGUgYXNzb2NpYXRlZCBhY3RvciBvZiB0aGlzIHBoeXNpY3MgYm9keS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIE9ubHkgW2NvbnZleCBwb2x5Z29uXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db252ZXhfcG9seWdvbikgZGVmaW5pdGlvbnMgYXJlIHN1cHBvcnRlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEJ5IGRlZmF1bHQsIHRoZSBib3ggaXMgY2VudGVyIGlzIGF0ICgwLCAwKSB3aGljaCBtZWFucyBpdCBpcyBjZW50ZXJlZCBhcm91bmQgdGhlIGFjdG9ycyBhbmNob3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQm9keS5wcm90b3R5cGUudXNlUG9seWdvbkNvbGxpc2lvbiA9IGZ1bmN0aW9uIChwb2ludHMsIGNlbnRlcikge1xyXG4gICAgICAgICAgICBpZiAoY2VudGVyID09PSB2b2lkIDApIHsgY2VudGVyID0gQWxnZWJyYV85LlZlY3Rvci5aZXJvLmNsb25lKCk7IH1cclxuICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25BcmVhID0gbmV3IFBvbHlnb25BcmVhXzUuUG9seWdvbkFyZWEoe1xyXG4gICAgICAgICAgICAgICAgYm9keTogdGhpcyxcclxuICAgICAgICAgICAgICAgIHBvaW50czogcG9pbnRzLFxyXG4gICAgICAgICAgICAgICAgcG9zOiBjZW50ZXIgLy8gcG9zaXRpb24gcmVsYXRpdmUgdG8gYWN0b3JcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIGluIGNhc2Ugb2YgYSBuYW4gbW9pLCBjb2xsZXNjZSB0byBhIHNhZmUgZGVmYXVsdFxyXG4gICAgICAgICAgICB0aGlzLm1vaSA9IHRoaXMuY29sbGlzaW9uQXJlYS5nZXRNb21lbnRPZkluZXJ0aWEoKSB8fCB0aGlzLm1vaTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdXAgYSBbW0NpcmNsZUFyZWF8Y2lyY2xlIGNvbGxpc2lvbiBhcmVhXV0gd2l0aCBhIHNwZWNpZmllZCByYWRpdXMgaW4gcGl4ZWxzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQnkgZGVmYXVsdCwgdGhlIGJveCBpcyBjZW50ZXIgaXMgYXQgKDAsIDApIHdoaWNoIG1lYW5zIGl0IGlzIGNlbnRlcmVkIGFyb3VuZCB0aGUgYWN0b3JzIGFuY2hvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBCb2R5LnByb3RvdHlwZS51c2VDaXJjbGVDb2xsaXNpb24gPSBmdW5jdGlvbiAocmFkaXVzLCBjZW50ZXIpIHtcclxuICAgICAgICAgICAgaWYgKGNlbnRlciA9PT0gdm9pZCAwKSB7IGNlbnRlciA9IEFsZ2VicmFfOS5WZWN0b3IuWmVyby5jbG9uZSgpOyB9XHJcbiAgICAgICAgICAgIGlmICghcmFkaXVzKSB7XHJcbiAgICAgICAgICAgICAgICByYWRpdXMgPSB0aGlzLmFjdG9yLmdldFdpZHRoKCkgLyAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uQXJlYSA9IG5ldyBDaXJjbGVBcmVhXzMuQ2lyY2xlQXJlYSh7XHJcbiAgICAgICAgICAgICAgICBib2R5OiB0aGlzLFxyXG4gICAgICAgICAgICAgICAgcmFkaXVzOiByYWRpdXMsXHJcbiAgICAgICAgICAgICAgICBwb3M6IGNlbnRlclxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5tb2kgPSB0aGlzLmNvbGxpc2lvbkFyZWEuZ2V0TW9tZW50T2ZJbmVydGlhKCkgfHwgdGhpcy5tb2k7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHVwIGFuIFtbRWRnZUFyZWF8ZWRnZSBjb2xsaXNpb25dXSB3aXRoIGEgc3RhcnQgcG9pbnQgYW5kIGFuIGVuZCBwb2ludCByZWxhdGl2ZSB0byB0aGUgYW5jaG9yIG9mIHRoZSBhc3NvY2lhdGVkIGFjdG9yXHJcbiAgICAgICAgICogb2YgdGhpcyBwaHlzaWNzIGJvZHkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBCeSBkZWZhdWx0LCB0aGUgYm94IGlzIGNlbnRlciBpcyBhdCAoMCwgMCkgd2hpY2ggbWVhbnMgaXQgaXMgY2VudGVyZWQgYXJvdW5kIHRoZSBhY3RvcnMgYW5jaG9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJvZHkucHJvdG90eXBlLnVzZUVkZ2VDb2xsaXNpb24gPSBmdW5jdGlvbiAoYmVnaW4sIGVuZCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbGxpc2lvbkFyZWEgPSBuZXcgRWRnZUFyZWFfMy5FZGdlQXJlYSh7XHJcbiAgICAgICAgICAgICAgICBiZWdpbjogYmVnaW4sXHJcbiAgICAgICAgICAgICAgICBlbmQ6IGVuZCxcclxuICAgICAgICAgICAgICAgIGJvZHk6IHRoaXNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMubW9pID0gdGhpcy5jb2xsaXNpb25BcmVhLmdldE1vbWVudE9mSW5lcnRpYSgpIHx8IHRoaXMubW9pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBCb2R5LnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgICAgICAgICAgIC8vIERyYXcgbW90aW9uIHZlY3RvcnNcclxuICAgICAgICAgICAgaWYgKFBoeXNpY3NfNS5QaHlzaWNzLnNob3dNb3Rpb25WZWN0b3JzKSB7XHJcbiAgICAgICAgICAgICAgICBEcmF3VXRpbC52ZWN0b3IoY3R4LCBDb2xvcl82LkNvbG9yLlllbGxvdywgdGhpcy5wb3MsICh0aGlzLmFjYy5hZGQoUGh5c2ljc181LlBoeXNpY3MuYWNjKSkpO1xyXG4gICAgICAgICAgICAgICAgRHJhd1V0aWwudmVjdG9yKGN0eCwgQ29sb3JfNi5Db2xvci5SZWQsIHRoaXMucG9zLCAodGhpcy52ZWwpKTtcclxuICAgICAgICAgICAgICAgIERyYXdVdGlsLnBvaW50KGN0eCwgQ29sb3JfNi5Db2xvci5SZWQsIHRoaXMucG9zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoUGh5c2ljc181LlBoeXNpY3Muc2hvd0JvdW5kcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRCb3VuZHMoKS5kZWJ1Z0RyYXcoY3R4LCBDb2xvcl82LkNvbG9yLlllbGxvdyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKFBoeXNpY3NfNS5QaHlzaWNzLnNob3dBcmVhKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbGxpc2lvbkFyZWEuZGVidWdEcmF3KGN0eCwgQ29sb3JfNi5Db2xvci5HcmVlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGlzIGJvZHkgY29sbGlkZWQgd2l0aFxyXG4gICAgICAgICAqIG9yIHdhcyBpbiBzdGF0aW9uYXJ5IGNvbnRhY3Qgd2l0aFxyXG4gICAgICAgICAqIHRoZSBib2R5IG9mIHRoZSBvdGhlciBbW0FjdG9yXV1cclxuICAgICAgICAgKi9cclxuICAgICAgICBCb2R5LnByb3RvdHlwZS50b3VjaGluZyA9IGZ1bmN0aW9uIChvdGhlcikge1xyXG4gICAgICAgICAgICB2YXIgcGFpciA9IG5ldyBQYWlyXzEuUGFpcih0aGlzLCBvdGhlci5ib2R5KTtcclxuICAgICAgICAgICAgcGFpci5jb2xsaWRlKCk7XHJcbiAgICAgICAgICAgIGlmIChwYWlyLmNvbGxpc2lvbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEJvZHk7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5Cb2R5ID0gQm9keTtcclxufSk7XHJcbmRlZmluZShcIkNvbGxpc2lvbi9QYWlyXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiUGh5c2ljc1wiLCBcIkRyYXdpbmcvQ29sb3JcIiwgXCJBY3RvclwiLCBcIlV0aWwvRHJhd1V0aWxcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBQaHlzaWNzXzYsIENvbG9yXzcsIEFjdG9yXzIsIERyYXdVdGlsKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogTW9kZWxzIGEgcG90ZW50aWFsIGNvbGxpc2lvbiBiZXR3ZWVuIDIgYm9kaWVzXHJcbiAgICAgKi9cclxuICAgIHZhciBQYWlyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBQYWlyKGJvZHlBLCBib2R5Qikge1xyXG4gICAgICAgICAgICB0aGlzLmJvZHlBID0gYm9keUE7XHJcbiAgICAgICAgICAgIHRoaXMuYm9keUIgPSBib2R5QjtcclxuICAgICAgICAgICAgdGhpcy5pZCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5pZCA9IFBhaXIuY2FsY3VsYXRlUGFpckhhc2goYm9keUEsIGJvZHlCKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBhaXIucHJvdG90eXBlLCBcImNhbkNvbGxpZGVcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBpdCBpcyBwb3NzaWJsZSBmb3IgdGhlIHBhaXJzIHRvIGNvbGxpZGVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFjdG9yQSA9IHRoaXMuYm9keUEuYWN0b3I7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWN0b3JCID0gdGhpcy5ib2R5Qi5hY3RvcjtcclxuICAgICAgICAgICAgICAgIC8vIGlmIGJvdGggYXJlIGZpeGVkIHNob3J0IGNpcmN1aXRcclxuICAgICAgICAgICAgICAgIGlmIChhY3RvckEuY29sbGlzaW9uVHlwZSA9PT0gQWN0b3JfMi5Db2xsaXNpb25UeXBlLkZpeGVkICYmIGFjdG9yQi5jb2xsaXNpb25UeXBlID09PSBBY3Rvcl8yLkNvbGxpc2lvblR5cGUuRml4ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgb3RoZXIgaXMgcHJldmVudCBjb2xsaXNpb24gb3IgaXMgZGVhZCBzaG9ydCBjaXJjdWl0XHJcbiAgICAgICAgICAgICAgICBpZiAoYWN0b3JCLmNvbGxpc2lvblR5cGUgPT09IEFjdG9yXzIuQ29sbGlzaW9uVHlwZS5QcmV2ZW50Q29sbGlzaW9uIHx8IGFjdG9yQi5pc0tpbGxlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJ1bnMgdGhlIGNvbGxpc29uIGludGVyc2VjdGlvbiBsb2dpYyBvbiB0aGUgbWVtYmVycyBvZiB0aGlzIHBhaXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBQYWlyLnByb3RvdHlwZS5jb2xsaWRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbGxpc2lvbiA9IHRoaXMuYm9keUEuY29sbGlzaW9uQXJlYS5jb2xsaWRlKHRoaXMuYm9keUIuY29sbGlzaW9uQXJlYSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXNvdmxlcyB0aGUgY29sbGlzaW9uIGJvZHkgcG9zaXRpb24gYW5kIHZlbG9jaXR5IGlmIGEgY29sbGlzaW9uIG9jY3VyZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBQYWlyLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gKHN0cmF0ZWd5KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbGxpc2lvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsaXNpb24ucmVzb2x2ZShzdHJhdGVneSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIHVuaXF1ZSBwYWlyIGhhc2ggaWQgZm9yIHRoaXMgY29sbGlzaW9uIHBhaXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBQYWlyLmNhbGN1bGF0ZVBhaXJIYXNoID0gZnVuY3Rpb24gKGJvZHlBLCBib2R5Qikge1xyXG4gICAgICAgICAgICBpZiAoYm9keUEuYWN0b3IuaWQgPCBib2R5Qi5hY3Rvci5pZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiI1wiICsgYm9keUEuYWN0b3IuaWQgKyBcIitcIiArIGJvZHlCLmFjdG9yLmlkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiI1wiICsgYm9keUIuYWN0b3IuaWQgKyBcIitcIiArIGJvZHlBLmFjdG9yLmlkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIFBhaXIucHJvdG90eXBlLmRlYnVnRHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29sbGlzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoUGh5c2ljc182LlBoeXNpY3Muc2hvd0NvbnRhY3RzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgRHJhd1V0aWwucG9pbnQoY3R4LCBDb2xvcl83LkNvbG9yLlJlZCwgdGhpcy5jb2xsaXNpb24ucG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKFBoeXNpY3NfNi5QaHlzaWNzLnNob3dDb2xsaXNpb25Ob3JtYWxzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgRHJhd1V0aWwudmVjdG9yKGN0eCwgQ29sb3JfNy5Db2xvci5DeWFuLCB0aGlzLmNvbGxpc2lvbi5wb2ludCwgdGhpcy5jb2xsaXNpb24ubm9ybWFsLCAzMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBQYWlyO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuUGFpciA9IFBhaXI7XHJcbn0pO1xyXG5kZWZpbmUoXCJEZWJ1Z1wiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWJ1ZyBzdGF0aXN0aWNzIGFuZCBmbGFncyBmb3IgRXhjYWxpYnVyLiBJZiBwb2xsaW5nIHRoZXNlIHZhbHVlcywgaXQgd291bGQgYmVcclxuICAgICAqIGJlc3QgdG8gZG8gc28gb24gdGhlIGBwb3N0dXBkYXRlYCBldmVudCBmb3IgW1tFbmdpbmVdXSwgYWZ0ZXIgYWxsIHZhbHVlcyBoYXZlIGJlZW5cclxuICAgICAqIHVwZGF0ZWQgZHVyaW5nIGEgZnJhbWUuXHJcbiAgICAgKi9cclxuICAgIHZhciBEZWJ1ZyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gRGVidWcoKSB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQZXJmb3JtYW5jZSBzdGF0aXN0aWNzXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRzID0ge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBDdXJyZW50IGZyYW1lIHN0YXRpc3RpY3MuIEVuZ2luZSByZXVzZXMgdGhpcyBpbnN0YW5jZSwgdXNlIFtbRnJhbWVTdGF0cy5jbG9uZV1dIHRvIGNvcHkgZnJhbWUgc3RhdHMuXHJcbiAgICAgICAgICAgICAgICAgKiBCZXN0IGFjY2Vzc2VkIG9uIFtbcG9zdGZyYW1lXV0gZXZlbnQuIFNlZSBbW0lGcmFtZVN0YXRzXV1cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgY3VyckZyYW1lOiBuZXcgRnJhbWVTdGF0cygpLFxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBQcmV2aW91cyBmcmFtZSBzdGF0aXN0aWNzLiBFbmdpbmUgcmV1c2VzIHRoaXMgaW5zdGFuY2UsIHVzZSBbW0ZyYW1lU3RhdHMuY2xvbmVdXSB0byBjb3B5IGZyYW1lIHN0YXRzLlxyXG4gICAgICAgICAgICAgICAgICogQmVzdCBhY2Nlc3NlZCBvbiBbW3ByZWZyYW1lXV0gZXZlbnQuIEJlc3QgaW5zcGVjdGVkIG9uIGVuZ2luZSBldmVudCBgcHJlZnJhbWVgLiBTZWUgW1tJRnJhbWVTdGF0c11dXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHByZXZGcmFtZTogbmV3IEZyYW1lU3RhdHMoKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gRGVidWc7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5EZWJ1ZyA9IERlYnVnO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbXBsZW1lbnRhdGlvbiBvZiBhIGZyYW1lJ3Mgc3RhdHMuIE1lYW50IHRvIGhhdmUgdmFsdWVzIGNvcGllZCB2aWEgW1tGcmFtZVN0YXRzLnJlc2V0XV0sIGF2b2lkXHJcbiAgICAgKiBjcmVhdGluZyBpbnN0YW5jZXMgb2YgdGhpcyBldmVyeSBmcmFtZS5cclxuICAgICAqL1xyXG4gICAgdmFyIEZyYW1lU3RhdHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIEZyYW1lU3RhdHMoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lkID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fZGVsdGEgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9mcHMgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RvclN0YXRzID0ge1xyXG4gICAgICAgICAgICAgICAgYWxpdmU6IDAsXHJcbiAgICAgICAgICAgICAgICBraWxsZWQ6IDAsXHJcbiAgICAgICAgICAgICAgICB1aTogMCxcclxuICAgICAgICAgICAgICAgIGdldCByZW1haW5pbmcoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWxpdmUgLSB0aGlzLmtpbGxlZDtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBnZXQgdG90YWwoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtYWluaW5nICsgdGhpcy51aTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5fZHVyYXRpb25TdGF0cyA9IHtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZTogMCxcclxuICAgICAgICAgICAgICAgIGRyYXc6IDAsXHJcbiAgICAgICAgICAgICAgICBnZXQgdG90YWwoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlICsgdGhpcy5kcmF3O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLl9waHlzaWNzU3RhdHMgPSBuZXcgUGh5c2ljc1N0YXRzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFplcm8gb3V0IHZhbHVlcyBvciBjbG9uZSBvdGhlciBJRnJhbWVTdGF0IHN0YXRzLiBBbGxvd3MgaW5zdGFuY2UgcmV1c2UuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gW290aGVyU3RhdHNdIE9wdGlvbmFsIHN0YXRzIHRvIGNsb25lXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRnJhbWVTdGF0cy5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAob3RoZXJTdGF0cykge1xyXG4gICAgICAgICAgICBpZiAob3RoZXJTdGF0cykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pZCA9IG90aGVyU3RhdHMuaWQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlbHRhID0gb3RoZXJTdGF0cy5kZWx0YTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnBzID0gb3RoZXJTdGF0cy5mcHM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFjdG9ycy5hbGl2ZSA9IG90aGVyU3RhdHMuYWN0b3JzLmFsaXZlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hY3RvcnMua2lsbGVkID0gb3RoZXJTdGF0cy5hY3RvcnMua2lsbGVkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hY3RvcnMudWkgPSBvdGhlclN0YXRzLmFjdG9ycy51aTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZHVyYXRpb24udXBkYXRlID0gb3RoZXJTdGF0cy5kdXJhdGlvbi51cGRhdGU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmR1cmF0aW9uLmRyYXcgPSBvdGhlclN0YXRzLmR1cmF0aW9uLmRyYXc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9waHlzaWNzU3RhdHMucmVzZXQob3RoZXJTdGF0cy5waHlzaWNzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaWQgPSB0aGlzLmRlbHRhID0gdGhpcy5mcHMgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hY3RvcnMuYWxpdmUgPSB0aGlzLmFjdG9ycy5raWxsZWQgPSB0aGlzLmFjdG9ycy51aSA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmR1cmF0aW9uLnVwZGF0ZSA9IHRoaXMuZHVyYXRpb24uZHJhdyA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9waHlzaWNzU3RhdHMucmVzZXQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJvdmlkZXMgYSBjbG9uZSBvZiB0aGlzIGluc3RhbmNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEZyYW1lU3RhdHMucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZnMgPSBuZXcgRnJhbWVTdGF0cygpO1xyXG4gICAgICAgICAgICBmcy5yZXNldCh0aGlzKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZyYW1lU3RhdHMucHJvdG90eXBlLCBcImlkXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIGZyYW1lJ3MgaWRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lkO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0cyB0aGUgZnJhbWUncyBpZFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2lkID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGcmFtZVN0YXRzLnByb3RvdHlwZSwgXCJkZWx0YVwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBmcmFtZSdzIGRlbHRhICh0aW1lIHNpbmNlIGxhc3QgZnJhbWUpXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWx0YTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHMgdGhlIGZyYW1lJ3MgZGVsdGEgKHRpbWUgc2luY2UgbGFzdCBmcmFtZSkuIEludGVybmFsIHVzZSBvbmx5LlxyXG4gICAgICAgICAgICAgKiBAaW50ZXJuYWxcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWx0YSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnJhbWVTdGF0cy5wcm90b3R5cGUsIFwiZnBzXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIGZyYW1lJ3MgZnJhbWVzLXBlci1zZWNvbmQgKEZQUylcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZwcztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHMgdGhlIGZyYW1lJ3MgZnJhbWVzLXBlci1zZWNvbmQgKEZQUykuIEludGVybmFsIHVzZSBvbmx5LlxyXG4gICAgICAgICAgICAgKiBAaW50ZXJuYWxcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mcHMgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZyYW1lU3RhdHMucHJvdG90eXBlLCBcImFjdG9yc1wiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBmcmFtZSdzIGFjdG9yIHN0YXRpc3RpY3NcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FjdG9yU3RhdHM7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGcmFtZVN0YXRzLnByb3RvdHlwZSwgXCJkdXJhdGlvblwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBmcmFtZSdzIGR1cmF0aW9uIHN0YXRpc3RpY3NcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2R1cmF0aW9uU3RhdHM7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGcmFtZVN0YXRzLnByb3RvdHlwZSwgXCJwaHlzaWNzXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIGZyYW1lJ3MgcGh5c2ljcyBzdGF0aXN0aWNzXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9waHlzaWNzU3RhdHM7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBGcmFtZVN0YXRzO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuRnJhbWVTdGF0cyA9IEZyYW1lU3RhdHM7XHJcbiAgICB2YXIgUGh5c2ljc1N0YXRzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBQaHlzaWNzU3RhdHMoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BhaXJzID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fY29sbGlzaW9ucyA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbGxpZGVyc0hhc2ggPSB7fTtcclxuICAgICAgICAgICAgdGhpcy5fZmFzdEJvZGllcyA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2Zhc3RCb2R5Q29sbGlzaW9ucyA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2Jyb2FkcGhhc2UgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9uYXJyb3dwaGFzZSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFplcm8gb3V0IHZhbHVlcyBvciBjbG9uZSBvdGhlciBJUGh5c2ljc1N0YXRzIHN0YXRzLiBBbGxvd3MgaW5zdGFuY2UgcmV1c2UuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gW290aGVyU3RhdHNdIE9wdGlvbmFsIHN0YXRzIHRvIGNsb25lXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUGh5c2ljc1N0YXRzLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIChvdGhlclN0YXRzKSB7XHJcbiAgICAgICAgICAgIGlmIChvdGhlclN0YXRzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhaXJzID0gb3RoZXJTdGF0cy5wYWlycztcclxuICAgICAgICAgICAgICAgIHRoaXMuY29sbGlzaW9ucyA9IG90aGVyU3RhdHMuY29sbGlzaW9ucztcclxuICAgICAgICAgICAgICAgIHRoaXMuY29sbGlkZXJzSGFzaCA9IG90aGVyU3RhdHMuY29sbGlkZXJzSGFzaDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmFzdEJvZGllcyA9IG90aGVyU3RhdHMuZmFzdEJvZGllcztcclxuICAgICAgICAgICAgICAgIHRoaXMuZmFzdEJvZHlDb2xsaXNpb25zID0gb3RoZXJTdGF0cy5mYXN0Qm9keUNvbGxpc2lvbnM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJyb2FkcGhhc2UgPSBvdGhlclN0YXRzLmJyb2FkcGhhc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5hcnJvd3BoYXNlID0gb3RoZXJTdGF0cy5uYXJyb3dwaGFzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFpcnMgPSB0aGlzLmNvbGxpc2lvbnMgPSB0aGlzLmZhc3RCb2RpZXMgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mYXN0Qm9keUNvbGxpc2lvbnMgPSB0aGlzLmJyb2FkcGhhc2UgPSB0aGlzLm5hcnJvd3BoYXNlID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29sbGlkZXJzSGFzaCA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcm92aWRlcyBhIGNsb25lIG9mIHRoaXMgaW5zdGFuY2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUGh5c2ljc1N0YXRzLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHBzID0gbmV3IFBoeXNpY3NTdGF0cygpO1xyXG4gICAgICAgICAgICBwcy5yZXNldCh0aGlzKTtcclxuICAgICAgICAgICAgcmV0dXJuIHBzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBoeXNpY3NTdGF0cy5wcm90b3R5cGUsIFwicGFpcnNcIiwge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYWlycztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BhaXJzID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQaHlzaWNzU3RhdHMucHJvdG90eXBlLCBcImNvbGxpc2lvbnNcIiwge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2xsaXNpb25zO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY29sbGlzaW9ucyA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGh5c2ljc1N0YXRzLnByb3RvdHlwZSwgXCJjb2xsaWRlcnNIYXNoXCIsIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sbGlkZXJzSGFzaDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoY29sbGlkZXJzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xsaWRlcnNIYXNoID0gY29sbGlkZXJzO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGh5c2ljc1N0YXRzLnByb3RvdHlwZSwgXCJmYXN0Qm9kaWVzXCIsIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmFzdEJvZGllcztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Zhc3RCb2RpZXMgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBoeXNpY3NTdGF0cy5wcm90b3R5cGUsIFwiZmFzdEJvZHlDb2xsaXNpb25zXCIsIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmFzdEJvZHlDb2xsaXNpb25zO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZmFzdEJvZHlDb2xsaXNpb25zID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQaHlzaWNzU3RhdHMucHJvdG90eXBlLCBcImJyb2FkcGhhc2VcIiwge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9icm9hZHBoYXNlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYnJvYWRwaGFzZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGh5c2ljc1N0YXRzLnByb3RvdHlwZSwgXCJuYXJyb3dwaGFzZVwiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hcnJvd3BoYXNlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbmFycm93cGhhc2UgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIFBoeXNpY3NTdGF0cztcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLlBoeXNpY3NTdGF0cyA9IFBoeXNpY3NTdGF0cztcclxufSk7XHJcbmRlZmluZShcIkludGVyZmFjZXMvSUV2ZW50ZWRcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxufSk7XHJcbmRlZmluZShcIkV2ZW50RGlzcGF0Y2hlclwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkV2ZW50c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIEV2ZW50c18yKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogRXhjYWxpYnVyJ3MgaW50ZXJuYWwgZXZlbnQgZGlzcGF0Y2hlciBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAqIENhbGxiYWNrcyBhcmUgZmlyZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgYW4gZXZlbnQgaXMgcHVibGlzaGVkLlxyXG4gICAgICogVHlwaWNhbGx5IHlvdSB3aWxsIHVzZSBbW0NsYXNzLmV2ZW50RGlzcGF0Y2hlcl1dIHNpbmNlIG1vc3QgY2xhc3NlcyBpblxyXG4gICAgICogRXhjYWxpYnVyIGluaGVyaXQgZnJvbSBbW0NsYXNzXV0uIFlvdSB3aWxsIHJhcmVseSBjcmVhdGUgYW4gYEV2ZW50RGlzcGF0Y2hlcmBcclxuICAgICAqIHlvdXJzZWxmLlxyXG4gICAgICpcclxuICAgICAqIFtbaW5jbHVkZTpFdmVudHMubWRdXVxyXG4gICAgICovXHJcbiAgICB2YXIgRXZlbnREaXNwYXRjaGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0ICBUaGUgb2JqZWN0IHRoYXQgd2lsbCBiZSB0aGUgcmVjaXBpZW50IG9mIGV2ZW50cyBmcm9tIHRoaXMgZXZlbnQgZGlzcGF0Y2hlclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIEV2ZW50RGlzcGF0Y2hlcih0YXJnZXQpIHtcclxuICAgICAgICAgICAgdGhpcy5faGFuZGxlcnMgPSB7fTtcclxuICAgICAgICAgICAgdGhpcy5fd2lyZWRFdmVudERpc3BhdGNoZXJzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW1pdHMgYW4gZXZlbnQgZm9yIHRhcmdldFxyXG4gICAgICAgICAqIEBwYXJhbSBldmVudE5hbWUgIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBwdWJsaXNoXHJcbiAgICAgICAgICogQHBhcmFtIGV2ZW50ICAgICAgT3B0aW9uYWxseSBwYXNzIGFuIGV2ZW50IGRhdGEgb2JqZWN0IHRvIHRoZSBoYW5kbGVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgZXZlbnQpIHtcclxuICAgICAgICAgICAgaWYgKCFldmVudE5hbWUpIHtcclxuICAgICAgICAgICAgICAgIC8vIGtleSBub3QgbWFwcGVkXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZXZlbnROYW1lID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl90YXJnZXQ7XHJcbiAgICAgICAgICAgIGlmICghZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50ID0gbmV3IEV2ZW50c18yLkdhbWVFdmVudCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgdmFyIGksIGxlbjtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV0pIHtcclxuICAgICAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgbGVuID0gdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV1baV0uY2FsbCh0YXJnZXQsIGV2ZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgICAgbGVuID0gdGhpcy5fd2lyZWRFdmVudERpc3BhdGNoZXJzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3dpcmVkRXZlbnREaXNwYXRjaGVyc1tpXS5lbWl0KGV2ZW50TmFtZSwgZXZlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTdWJzY3JpYmUgYW4gZXZlbnQgaGFuZGxlciB0byBhIHBhcnRpY3VsYXIgZXZlbnQgbmFtZSwgbXVsdGlwbGUgaGFuZGxlcnMgcGVyIGV2ZW50IG5hbWUgYXJlIGFsbG93ZWQuXHJcbiAgICAgICAgICogQHBhcmFtIGV2ZW50TmFtZSAgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHN1YnNjcmliZSB0b1xyXG4gICAgICAgICAqIEBwYXJhbSBoYW5kbGVyICAgIFRoZSBoYW5kbGVyIGNhbGxiYWNrIHRvIGZpcmUgb24gdGhpcyBldmVudFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIGV2ZW50TmFtZSA9IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV0pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV0gPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdLnB1c2goaGFuZGxlcik7XHJcbiAgICAgICAgICAgIC8vIG1ldGEgZXZlbnQgaGFuZGxlcnNcclxuICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSAhPT0gJ3Vuc3Vic2NyaWJlJyAmJiBldmVudE5hbWUgIT09ICdzdWJzY3JpYmUnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3N1YnNjcmliZScsIG5ldyBFdmVudHNfMi5TdWJzY3JpYmVFdmVudChldmVudE5hbWUsIGhhbmRsZXIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVW5zdWJzY3JpYmUgYW4gZXZlbnQgaGFuZGxlcihzKSBmcm9tIGFuIGV2ZW50LiBJZiBhIHNwZWNpZmljIGhhbmRsZXJcclxuICAgICAgICAgKiBpcyBzcGVjaWZpZWQgZm9yIGFuIGV2ZW50LCBvbmx5IHRoYXQgaGFuZGxlciB3aWxsIGJlIHVuc3Vic2NyaWJlZC5cclxuICAgICAgICAgKiBPdGhlcndpc2UgYWxsIGhhbmRsZXJzIHdpbGwgYmUgdW5zdWJzY3JpYmVkIGZvciB0aGF0IGV2ZW50LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGV2ZW50TmFtZSAgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHVuc3Vic2NyaWJlXHJcbiAgICAgICAgICogQHBhcmFtIGhhbmRsZXIgICAgT3B0aW9uYWxseSB0aGUgc3BlY2lmaWMgaGFuZGxlciB0byB1bnN1YnNjcmliZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIGV2ZW50TmFtZSA9IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICB2YXIgZXZlbnRIYW5kbGVycyA9IHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV07XHJcbiAgICAgICAgICAgIGlmIChldmVudEhhbmRsZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiBubyBleHBsaWNpdCBoYW5kbGVyIGlzIGdpdmUgd2l0aCB0aGUgZXZlbnQgbmFtZSBjbGVhciBhbGwgaGFuZGxlcnNcclxuICAgICAgICAgICAgICAgIGlmICghaGFuZGxlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV0ubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGV2ZW50SGFuZGxlcnMuaW5kZXhPZihoYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gbWV0YSBldmVudCBoYW5kbGVyc1xyXG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lICE9PSAndW5zdWJzY3JpYmUnICYmIGV2ZW50TmFtZSAhPT0gJ3N1YnNjcmliZScpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgndW5zdWJzY3JpYmUnLCBuZXcgRXZlbnRzXzIuVW5zdWJzY3JpYmVFdmVudChldmVudE5hbWUsIGhhbmRsZXIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogT25jZSBsaXN0ZW5zIHRvIGFuIGV2ZW50IG9uZSB0aW1lLCB0aGVuIHVuc3Vic2NyaWJlcyBmcm9tIHRoYXQgZXZlbnRcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBldmVudE5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHN1YnNjcmliZSB0byBvbmNlXHJcbiAgICAgICAgICogQHBhcmFtIGhhbmRsZXIgICBUaGUgaGFuZGxlciBvZiB0aGUgZXZlbnQgdGhhdCB3aWxsIGJlIGF1dG8gdW5zdWJzY3JpYmVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgbWV0YUhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBldiA9IGV2ZW50IHx8IG5ldyBFdmVudHNfMi5HYW1lRXZlbnQoKTtcclxuICAgICAgICAgICAgICAgIGV2LnRhcmdldCA9IGV2LnRhcmdldCB8fCBfdGhpcy5fdGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgX3RoaXMub2ZmKGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmNhbGwoZXYudGFyZ2V0LCBldik7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMub24oZXZlbnROYW1lLCBtZXRhSGFuZGxlcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaXJlcyB0aGlzIGV2ZW50IGRpc3BhdGNoZXIgdG8gYWxzbyByZWNpZXZlIGV2ZW50cyBmcm9tIGFub3RoZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlLndpcmUgPSBmdW5jdGlvbiAoZXZlbnREaXNwYXRjaGVyKSB7XHJcbiAgICAgICAgICAgIGV2ZW50RGlzcGF0Y2hlci5fd2lyZWRFdmVudERpc3BhdGNoZXJzLnB1c2godGhpcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVbndpcmVzIHRoaXMgZXZlbnQgZGlzcGF0Y2hlciBmcm9tIGFub3RoZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlLnVud2lyZSA9IGZ1bmN0aW9uIChldmVudERpc3BhdGNoZXIpIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gZXZlbnREaXNwYXRjaGVyLl93aXJlZEV2ZW50RGlzcGF0Y2hlcnMuaW5kZXhPZih0aGlzKTtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50RGlzcGF0Y2hlci5fd2lyZWRFdmVudERpc3BhdGNoZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBFdmVudERpc3BhdGNoZXI7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5FdmVudERpc3BhdGNoZXIgPSBFdmVudERpc3BhdGNoZXI7XHJcbn0pO1xyXG5kZWZpbmUoXCJBY3Rpb25zL0FjdGlvbkNvbnRleHRcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJBY3Rpb25zL0FjdGlvblwiLCBcIlByb21pc2VzXCIsIFwiVXRpbC9FYXNpbmdGdW5jdGlvbnNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBBY3Rpb25zLCBQcm9taXNlc18yLCBFYXNpbmdGdW5jdGlvbnNfMikge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmbHVlbnQgQWN0aW9uIEFQSSBhbGxvd3MgeW91IHRvIHBlcmZvcm0gXCJhY3Rpb25zXCIgb25cclxuICAgICAqIFtbQWN0b3J8QWN0b3JzXV0gc3VjaCBhcyBmb2xsb3dpbmcsIG1vdmluZywgcm90YXRpbmcsIGFuZFxyXG4gICAgICogbW9yZS4gWW91IGNhbiBpbXBsZW1lbnQgeW91ciBvd24gYWN0aW9ucyBieSBpbXBsZW1lbnRpbmdcclxuICAgICAqIHRoZSBbW0lBY3Rpb25dXSBpbnRlcmZhY2UuXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOkFjdGlvbnMubWRdXVxyXG4gICAgICovXHJcbiAgICB2YXIgQWN0aW9uQ29udGV4dCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gQWN0aW9uQ29udGV4dCgpIHtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3JzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlcyA9IFtdO1xyXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RvcnMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWVzID0gdGhpcy5fYWN0b3JzLm1hcChmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhLmFjdGlvblF1ZXVlO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2xlYXJzIGFsbCBxdWV1ZWQgYWN0aW9ucyBmcm9tIHRoZSBBY3RvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdGlvbkNvbnRleHQucHJvdG90eXBlLmNsZWFyQWN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9xdWV1ZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWVzW2ldLmNsZWFyQWN0aW9ucygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBY3Rpb25Db250ZXh0LnByb3RvdHlwZS5hZGRBY3RvclRvQ29udGV4dCA9IGZ1bmN0aW9uIChhY3Rvcikge1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RvcnMucHVzaChhY3Rvcik7XHJcbiAgICAgICAgICAgIC8vIGlmIHdlIHJ1biBpbnRvIHByb2JsZW1zIHJlcGxhY2UgdGhlIGxpbmUgYmVsb3cgd2l0aDpcclxuICAgICAgICAgICAgdGhpcy5fcXVldWVzLnB1c2goYWN0b3IuYWN0aW9uUXVldWUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQWN0aW9uQ29udGV4dC5wcm90b3R5cGUucmVtb3ZlQWN0b3JGcm9tQ29udGV4dCA9IGZ1bmN0aW9uIChhY3Rvcikge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9hY3RvcnMuaW5kZXhPZihhY3Rvcik7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RvcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIG1vdmUgYW4gYWN0b3IgdG8gdGhlIHNwZWNpZmllZCBgeGAgYW5kIGB5YCBwb3NpdGlvbiBvdmVyIHRoZVxyXG4gICAgICAgICAqIHNwZWNpZmllZCBkdXJhdGlvbiB1c2luZyBhIGdpdmVuIFtbRWFzaW5nRnVuY3Rpb25zXV0gYW5kIHJldHVybiBiYWNrIHRoZSBhY3Rvci4gVGhpc1xyXG4gICAgICAgICAqIG1ldGhvZCBpcyBwYXJ0IG9mIHRoZSBhY3RvciAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZy5cclxuICAgICAgICAgKiBAcGFyYW0geCAgICAgICAgIFRoZSB4IGxvY2F0aW9uIHRvIG1vdmUgdGhlIGFjdG9yIHRvXHJcbiAgICAgICAgICogQHBhcmFtIHkgICAgICAgICBUaGUgeSBsb2NhdGlvbiB0byBtb3ZlIHRoZSBhY3RvciB0b1xyXG4gICAgICAgICAqIEBwYXJhbSBkdXJhdGlvbiAgVGhlIHRpbWUgaXQgc2hvdWxkIHRha2UgdGhlIGFjdG9yIHRvIG1vdmUgdG8gdGhlIG5ldyBsb2NhdGlvbiBpbiBtaWxsaXNlY29uZHNcclxuICAgICAgICAgKiBAcGFyYW0gZWFzaW5nRmNuIFVzZSBbW0Vhc2luZ0Z1bmN0aW9uc11dIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIHRvIHVzZSB0byBjYWxjdWxhdGUgcG9zaXRpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3Rpb25Db250ZXh0LnByb3RvdHlwZS5lYXNlVG8gPSBmdW5jdGlvbiAoeCwgeSwgZHVyYXRpb24sIGVhc2luZ0Zjbikge1xyXG4gICAgICAgICAgICBpZiAoZWFzaW5nRmNuID09PSB2b2lkIDApIHsgZWFzaW5nRmNuID0gRWFzaW5nRnVuY3Rpb25zXzIuRWFzaW5nRnVuY3Rpb25zLkxpbmVhcjsgfVxyXG4gICAgICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3F1ZXVlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZXNbaV0uYWRkKG5ldyBBY3Rpb25zLkVhc2VUbyh0aGlzLl9hY3RvcnNbaV0sIHgsIHksIGR1cmF0aW9uLCBlYXNpbmdGY24pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgbW92ZSBhbiBhY3RvciB0byB0aGUgc3BlY2lmaWVkIHggYW5kIHkgcG9zaXRpb24gYXQgdGhlXHJcbiAgICAgICAgICogc3BlZWQgc3BlY2lmaWVkIChpbiBwaXhlbHMgcGVyIHNlY29uZCkgYW5kIHJldHVybiBiYWNrIHRoZSBhY3Rvci4gVGhpc1xyXG4gICAgICAgICAqIG1ldGhvZCBpcyBwYXJ0IG9mIHRoZSBhY3RvciAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZy5cclxuICAgICAgICAgKiBAcGFyYW0geCAgICAgIFRoZSB4IGxvY2F0aW9uIHRvIG1vdmUgdGhlIGFjdG9yIHRvXHJcbiAgICAgICAgICogQHBhcmFtIHkgICAgICBUaGUgeSBsb2NhdGlvbiB0byBtb3ZlIHRoZSBhY3RvciB0b1xyXG4gICAgICAgICAqIEBwYXJhbSBzcGVlZCAgVGhlIHNwZWVkIGluIHBpeGVscyBwZXIgc2Vjb25kIHRvIG1vdmVcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3Rpb25Db250ZXh0LnByb3RvdHlwZS5tb3ZlVG8gPSBmdW5jdGlvbiAoeCwgeSwgc3BlZWQpIHtcclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9xdWV1ZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWVzW2ldLmFkZChuZXcgQWN0aW9ucy5Nb3ZlVG8odGhpcy5fYWN0b3JzW2ldLCB4LCB5LCBzcGVlZCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCBtb3ZlIGFuIGFjdG9yIHRvIHRoZSBzcGVjaWZpZWQgeCBhbmQgeSBwb3NpdGlvbiBieSBhXHJcbiAgICAgICAgICogY2VydGFpbiB0aW1lIChpbiBtaWxsaXNlY29uZHMpLiBUaGlzIG1ldGhvZCBpcyBwYXJ0IG9mIHRoZSBhY3RvclxyXG4gICAgICAgICAqICdBY3Rpb24nIGZsdWVudCBBUEkgYWxsb3dpbmcgYWN0aW9uIGNoYWluaW5nLlxyXG4gICAgICAgICAqIEBwYXJhbSB4ICAgICBUaGUgeCBsb2NhdGlvbiB0byBtb3ZlIHRoZSBhY3RvciB0b1xyXG4gICAgICAgICAqIEBwYXJhbSB5ICAgICBUaGUgeSBsb2NhdGlvbiB0byBtb3ZlIHRoZSBhY3RvciB0b1xyXG4gICAgICAgICAqIEBwYXJhbSB0aW1lICBUaGUgdGltZSBpdCBzaG91bGQgdGFrZSB0aGUgYWN0b3IgdG8gbW92ZSB0byB0aGUgbmV3IGxvY2F0aW9uIGluIG1pbGxpc2Vjb25kc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdGlvbkNvbnRleHQucHJvdG90eXBlLm1vdmVCeSA9IGZ1bmN0aW9uICh4LCB5LCB0aW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gMCwgbGVuID0gdGhpcy5fcXVldWVzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlc1tpXS5hZGQobmV3IEFjdGlvbnMuTW92ZUJ5KHRoaXMuX2FjdG9yc1tpXSwgeCwgeSwgdGltZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCByb3RhdGUgYW4gYWN0b3IgdG8gdGhlIHNwZWNpZmllZCBhbmdsZSBhdCB0aGUgc3BlZWRcclxuICAgICAgICAgKiBzcGVjaWZpZWQgKGluIHJhZGlhbnMgcGVyIHNlY29uZCkgYW5kIHJldHVybiBiYWNrIHRoZSBhY3Rvci4gVGhpc1xyXG4gICAgICAgICAqIG1ldGhvZCBpcyBwYXJ0IG9mIHRoZSBhY3RvciAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZy5cclxuICAgICAgICAgKiBAcGFyYW0gYW5nbGVSYWRpYW5zICBUaGUgYW5nbGUgdG8gcm90YXRlIHRvIGluIHJhZGlhbnNcclxuICAgICAgICAgKiBAcGFyYW0gc3BlZWQgICAgICAgICBUaGUgYW5ndWxhciB2ZWxvY2l0eSBvZiB0aGUgcm90YXRpb24gc3BlY2lmaWVkIGluIHJhZGlhbnMgcGVyIHNlY29uZFxyXG4gICAgICAgICAqIEBwYXJhbSByb3RhdGlvblR5cGUgIFRoZSBbW1JvdGF0aW9uVHlwZV1dIHRvIHVzZSBmb3IgdGhpcyByb3RhdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdGlvbkNvbnRleHQucHJvdG90eXBlLnJvdGF0ZVRvID0gZnVuY3Rpb24gKGFuZ2xlUmFkaWFucywgc3BlZWQsIHJvdGF0aW9uVHlwZSkge1xyXG4gICAgICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3F1ZXVlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZXNbaV0uYWRkKG5ldyBBY3Rpb25zLlJvdGF0ZVRvKHRoaXMuX2FjdG9yc1tpXSwgYW5nbGVSYWRpYW5zLCBzcGVlZCwgcm90YXRpb25UeXBlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHJvdGF0ZSBhbiBhY3RvciB0byB0aGUgc3BlY2lmaWVkIGFuZ2xlIGJ5IGEgY2VydGFpblxyXG4gICAgICAgICAqIHRpbWUgKGluIG1pbGxpc2Vjb25kcykgYW5kIHJldHVybiBiYWNrIHRoZSBhY3Rvci4gVGhpcyBtZXRob2QgaXMgcGFydFxyXG4gICAgICAgICAqIG9mIHRoZSBhY3RvciAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZy5cclxuICAgICAgICAgKiBAcGFyYW0gYW5nbGVSYWRpYW5zICBUaGUgYW5nbGUgdG8gcm90YXRlIHRvIGluIHJhZGlhbnNcclxuICAgICAgICAgKiBAcGFyYW0gdGltZSAgICAgICAgICBUaGUgdGltZSBpdCBzaG91bGQgdGFrZSB0aGUgYWN0b3IgdG8gY29tcGxldGUgdGhlIHJvdGF0aW9uIGluIG1pbGxpc2Vjb25kc1xyXG4gICAgICAgICAqIEBwYXJhbSByb3RhdGlvblR5cGUgIFRoZSBbW1JvdGF0aW9uVHlwZV1dIHRvIHVzZSBmb3IgdGhpcyByb3RhdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdGlvbkNvbnRleHQucHJvdG90eXBlLnJvdGF0ZUJ5ID0gZnVuY3Rpb24gKGFuZ2xlUmFkaWFucywgdGltZSwgcm90YXRpb25UeXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gMCwgbGVuID0gdGhpcy5fcXVldWVzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlc1tpXS5hZGQobmV3IEFjdGlvbnMuUm90YXRlQnkodGhpcy5fYWN0b3JzW2ldLCBhbmdsZVJhZGlhbnMsIHRpbWUsIHJvdGF0aW9uVHlwZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCBzY2FsZSBhbiBhY3RvciB0byB0aGUgc3BlY2lmaWVkIHNpemUgYXQgdGhlIHNwZWVkXHJcbiAgICAgICAgICogc3BlY2lmaWVkIChpbiBtYWduaXR1ZGUgaW5jcmVhc2UgcGVyIHNlY29uZCkgYW5kIHJldHVybiBiYWNrIHRoZVxyXG4gICAgICAgICAqIGFjdG9yLiBUaGlzIG1ldGhvZCBpcyBwYXJ0IG9mIHRoZSBhY3RvciAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nXHJcbiAgICAgICAgICogYWN0aW9uIGNoYWluaW5nLlxyXG4gICAgICAgICAqIEBwYXJhbSBzaXplWCAgIFRoZSBzY2FsaW5nIGZhY3RvciB0byBhcHBseSBvbiBYIGF4aXNcclxuICAgICAgICAgKiBAcGFyYW0gc2l6ZVkgICBUaGUgc2NhbGluZyBmYWN0b3IgdG8gYXBwbHkgb24gWSBheGlzXHJcbiAgICAgICAgICogQHBhcmFtIHNwZWVkWCAgVGhlIHNwZWVkIG9mIHNjYWxpbmcgc3BlY2lmaWVkIGluIG1hZ25pdHVkZSBpbmNyZWFzZSBwZXIgc2Vjb25kIG9uIFggYXhpc1xyXG4gICAgICAgICAqIEBwYXJhbSBzcGVlZFkgIFRoZSBzcGVlZCBvZiBzY2FsaW5nIHNwZWNpZmllZCBpbiBtYWduaXR1ZGUgaW5jcmVhc2UgcGVyIHNlY29uZCBvbiBZIGF4aXNcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3Rpb25Db250ZXh0LnByb3RvdHlwZS5zY2FsZVRvID0gZnVuY3Rpb24gKHNpemVYLCBzaXplWSwgc3BlZWRYLCBzcGVlZFkpIHtcclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9xdWV1ZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWVzW2ldLmFkZChuZXcgQWN0aW9ucy5TY2FsZVRvKHRoaXMuX2FjdG9yc1tpXSwgc2l6ZVgsIHNpemVZLCBzcGVlZFgsIHNwZWVkWSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCBzY2FsZSBhbiBhY3RvciB0byB0aGUgc3BlY2lmaWVkIHNpemUgYnkgYSBjZXJ0YWluIHRpbWVcclxuICAgICAgICAgKiAoaW4gbWlsbGlzZWNvbmRzKSBhbmQgcmV0dXJuIGJhY2sgdGhlIGFjdG9yLiBUaGlzIG1ldGhvZCBpcyBwYXJ0IG9mIHRoZVxyXG4gICAgICAgICAqIGFjdG9yICdBY3Rpb24nIGZsdWVudCBBUEkgYWxsb3dpbmcgYWN0aW9uIGNoYWluaW5nLlxyXG4gICAgICAgICAqIEBwYXJhbSBzaXplWCAgIFRoZSBzY2FsaW5nIGZhY3RvciB0byBhcHBseSBvbiBYIGF4aXNcclxuICAgICAgICAgKiBAcGFyYW0gc2l6ZVkgICBUaGUgc2NhbGluZyBmYWN0b3IgdG8gYXBwbHkgb24gWSBheGlzXHJcbiAgICAgICAgICogQHBhcmFtIHRpbWUgICAgVGhlIHRpbWUgaXQgc2hvdWxkIHRha2UgdG8gY29tcGxldGUgdGhlIHNjYWxpbmcgaW4gbWlsbGlzZWNvbmRzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0aW9uQ29udGV4dC5wcm90b3R5cGUuc2NhbGVCeSA9IGZ1bmN0aW9uIChzaXplWCwgc2l6ZVksIHRpbWUpIHtcclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9xdWV1ZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWVzW2ldLmFkZChuZXcgQWN0aW9ucy5TY2FsZUJ5KHRoaXMuX2FjdG9yc1tpXSwgc2l6ZVgsIHNpemVZLCB0aW1lKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGNhdXNlIGFuIGFjdG9yIHRvIGJsaW5rIChiZWNvbWUgdmlzaWJsZSBhbmQgbm90XHJcbiAgICAgICAgICogdmlzaWJsZSkuIE9wdGlvbmFsbHksIHlvdSBtYXkgc3BlY2lmeSB0aGUgbnVtYmVyIG9mIGJsaW5rcy4gU3BlY2lmeSB0aGUgYW1vdW50IG9mIHRpbWVcclxuICAgICAgICAgKiB0aGUgYWN0b3Igc2hvdWxkIGJlIHZpc2libGUgcGVyIGJsaW5rLCBhbmQgdGhlIGFtb3VudCBvZiB0aW1lIG5vdCB2aXNpYmxlLlxyXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGlzIHBhcnQgb2YgdGhlIGFjdG9yICdBY3Rpb24nIGZsdWVudCBBUEkgYWxsb3dpbmcgYWN0aW9uIGNoYWluaW5nLlxyXG4gICAgICAgICAqIEBwYXJhbSB0aW1lVmlzaWJsZSAgICAgVGhlIGFtb3VudCBvZiB0aW1lIHRvIHN0YXkgdmlzaWJsZSBwZXIgYmxpbmsgaW4gbWlsbGlzZWNvbmRzXHJcbiAgICAgICAgICogQHBhcmFtIHRpbWVOb3RWaXNpYmxlICBUaGUgYW1vdW50IG9mIHRpbWUgdG8gc3RheSBub3QgdmlzaWJsZSBwZXIgYmxpbmsgaW4gbWlsbGlzZWNvbmRzXHJcbiAgICAgICAgICogQHBhcmFtIG51bUJsaW5rcyAgICAgICBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGJsaW5rXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0aW9uQ29udGV4dC5wcm90b3R5cGUuYmxpbmsgPSBmdW5jdGlvbiAodGltZVZpc2libGUsIHRpbWVOb3RWaXNpYmxlLCBudW1CbGlua3MpIHtcclxuICAgICAgICAgICAgaWYgKG51bUJsaW5rcyA9PT0gdm9pZCAwKSB7IG51bUJsaW5rcyA9IDE7IH1cclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9xdWV1ZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWVzW2ldLmFkZChuZXcgQWN0aW9ucy5CbGluayh0aGlzLl9hY3RvcnNbaV0sIHRpbWVWaXNpYmxlLCB0aW1lTm90VmlzaWJsZSwgbnVtQmxpbmtzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGNhdXNlIGFuIGFjdG9yJ3Mgb3BhY2l0eSB0byBjaGFuZ2UgZnJvbSBpdHMgY3VycmVudCB2YWx1ZVxyXG4gICAgICAgICAqIHRvIHRoZSBwcm92aWRlZCB2YWx1ZSBieSBhIHNwZWNpZmllZCB0aW1lIChpbiBtaWxsaXNlY29uZHMpLiBUaGlzIG1ldGhvZCBpc1xyXG4gICAgICAgICAqIHBhcnQgb2YgdGhlIGFjdG9yICdBY3Rpb24nIGZsdWVudCBBUEkgYWxsb3dpbmcgYWN0aW9uIGNoYWluaW5nLlxyXG4gICAgICAgICAqIEBwYXJhbSBvcGFjaXR5ICBUaGUgZW5kaW5nIG9wYWNpdHlcclxuICAgICAgICAgKiBAcGFyYW0gdGltZSAgICAgVGhlIHRpbWUgaXQgc2hvdWxkIHRha2UgdG8gZmFkZSB0aGUgYWN0b3IgKGluIG1pbGxpc2Vjb25kcylcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3Rpb25Db250ZXh0LnByb3RvdHlwZS5mYWRlID0gZnVuY3Rpb24gKG9wYWNpdHksIHRpbWUpIHtcclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9xdWV1ZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWVzW2ldLmFkZChuZXcgQWN0aW9ucy5GYWRlKHRoaXMuX2FjdG9yc1tpXSwgb3BhY2l0eSwgdGltZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCBkZWxheSB0aGUgbmV4dCBhY3Rpb24gZnJvbSBleGVjdXRpbmcgZm9yIGEgY2VydGFpblxyXG4gICAgICAgICAqIGFtb3VudCBvZiB0aW1lIChpbiBtaWxsaXNlY29uZHMpLiBUaGlzIG1ldGhvZCBpcyBwYXJ0IG9mIHRoZSBhY3RvclxyXG4gICAgICAgICAqICdBY3Rpb24nIGZsdWVudCBBUEkgYWxsb3dpbmcgYWN0aW9uIGNoYWluaW5nLlxyXG4gICAgICAgICAqIEBwYXJhbSB0aW1lICBUaGUgYW1vdW50IG9mIHRpbWUgdG8gZGVsYXkgdGhlIG5leHQgYWN0aW9uIGluIHRoZSBxdWV1ZSBmcm9tIGV4ZWN1dGluZyBpbiBtaWxsaXNlY29uZHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3Rpb25Db250ZXh0LnByb3RvdHlwZS5kZWxheSA9IGZ1bmN0aW9uICh0aW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gMCwgbGVuID0gdGhpcy5fcXVldWVzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlc1tpXS5hZGQobmV3IEFjdGlvbnMuRGVsYXkodGhpcy5fYWN0b3JzW2ldLCB0aW1lKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGFkZCBhbiBhY3Rpb24gdG8gdGhlIHF1ZXVlIHRoYXQgd2lsbCByZW1vdmUgdGhlIGFjdG9yIGZyb20gdGhlXHJcbiAgICAgICAgICogc2NlbmUgb25jZSBpdCBoYXMgY29tcGxldGVkIGl0cyBwcmV2aW91cyBhY3Rpb25zLiBBbnkgYWN0aW9ucyBvbiB0aGVcclxuICAgICAgICAgKiBhY3Rpb24gcXVldWUgYWZ0ZXIgdGhpcyBhY3Rpb24gd2lsbCBub3QgYmUgZXhlY3V0ZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0aW9uQ29udGV4dC5wcm90b3R5cGUuZGllID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3F1ZXVlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZXNbaV0uYWRkKG5ldyBBY3Rpb25zLkRpZSh0aGlzLl9hY3RvcnNbaV0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGFsbG93cyB5b3UgdG8gY2FsbCBhbiBhcmJpdHJhcnkgbWV0aG9kIGFzIHRoZSBuZXh0IGFjdGlvbiBpbiB0aGVcclxuICAgICAgICAgKiBhY3Rpb24gcXVldWUuIFRoaXMgaXMgdXNlZnVsIGlmIHlvdSB3YW50IHRvIGV4ZWN1dGUgY29kZSBpbiBhZnRlciBhIHNwZWNpZmljXHJcbiAgICAgICAgICogYWN0aW9uLCBpLmUgQW4gYWN0b3IgYXJyaXZlcyBhdCBhIGRlc3RpbmF0aW9uIGFmdGVyIHRyYXZlcnNpbmcgYSBwYXRoXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0aW9uQ29udGV4dC5wcm90b3R5cGUuY2FsbE1ldGhvZCA9IGZ1bmN0aW9uIChtZXRob2QpIHtcclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9xdWV1ZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWVzW2ldLmFkZChuZXcgQWN0aW9ucy5DYWxsTWV0aG9kKHRoaXMuX2FjdG9yc1tpXSwgbWV0aG9kKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGNhdXNlIHRoZSBhY3RvciB0byByZXBlYXQgYWxsIG9mIHRoZSBwcmV2aW91c2x5XHJcbiAgICAgICAgICogY2FsbGVkIGFjdGlvbnMgYSBjZXJ0YWluIG51bWJlciBvZiB0aW1lcy4gSWYgdGhlIG51bWJlciBvZiByZXBlYXRzXHJcbiAgICAgICAgICogaXMgbm90IHNwZWNpZmllZCBpdCB3aWxsIHJlcGVhdCBmb3JldmVyLiBUaGlzIG1ldGhvZCBpcyBwYXJ0IG9mXHJcbiAgICAgICAgICogdGhlIGFjdG9yICdBY3Rpb24nIGZsdWVudCBBUEkgYWxsb3dpbmcgYWN0aW9uIGNoYWluaW5nXHJcbiAgICAgICAgICogQHBhcmFtIHRpbWVzICBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCBhbGwgdGhlIHByZXZpb3VzIGFjdGlvbnMgaW4gdGhlIGFjdGlvbiBxdWV1ZS4gSWYgbm90aGluZyBpcyBzcGVjaWZpZWQgdGhlIGFjdGlvbnNcclxuICAgICAgICAgKiB3aWxsIHJlcGVhdCBmb3JldmVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0aW9uQ29udGV4dC5wcm90b3R5cGUucmVwZWF0ID0gZnVuY3Rpb24gKHRpbWVzKSB7XHJcbiAgICAgICAgICAgIGlmICghdGltZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVwZWF0Rm9yZXZlcigpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9xdWV1ZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWVzW2ldLmFkZChuZXcgQWN0aW9ucy5SZXBlYXQodGhpcy5fYWN0b3JzW2ldLCB0aW1lcywgdGhpcy5fYWN0b3JzW2ldLmFjdGlvblF1ZXVlLmdldEFjdGlvbnMoKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCBjYXVzZSB0aGUgYWN0b3IgdG8gcmVwZWF0IGFsbCBvZiB0aGUgcHJldmlvdXNseVxyXG4gICAgICAgICAqIGNhbGxlZCBhY3Rpb25zIGZvcmV2ZXIuIFRoaXMgbWV0aG9kIGlzIHBhcnQgb2YgdGhlIGFjdG9yICdBY3Rpb24nXHJcbiAgICAgICAgICogZmx1ZW50IEFQSSBhbGxvd2luZyBhY3Rpb24gY2hhaW5pbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0aW9uQ29udGV4dC5wcm90b3R5cGUucmVwZWF0Rm9yZXZlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9xdWV1ZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWVzW2ldLmFkZChuZXcgQWN0aW9ucy5SZXBlYXRGb3JldmVyKHRoaXMuX2FjdG9yc1tpXSwgdGhpcy5fYWN0b3JzW2ldLmFjdGlvblF1ZXVlLmdldEFjdGlvbnMoKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCBjYXVzZSB0aGUgYWN0b3IgdG8gZm9sbG93IGFub3RoZXIgYXQgYSBzcGVjaWZpZWQgZGlzdGFuY2VcclxuICAgICAgICAgKiBAcGFyYW0gYWN0b3IgICAgICAgICAgIFRoZSBhY3RvciB0byBmb2xsb3dcclxuICAgICAgICAgKiBAcGFyYW0gZm9sbG93RGlzdGFuY2UgIFRoZSBkaXN0YW5jZSB0byBtYWludGFpbiB3aGVuIGZvbGxvd2luZywgaWYgbm90IHNwZWNpZmllZCB0aGUgYWN0b3Igd2lsbCBmb2xsb3cgYXQgdGhlIGN1cnJlbnQgZGlzdGFuY2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0aW9uQ29udGV4dC5wcm90b3R5cGUuZm9sbG93ID0gZnVuY3Rpb24gKGFjdG9yLCBmb2xsb3dEaXN0YW5jZSkge1xyXG4gICAgICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3F1ZXVlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZm9sbG93RGlzdGFuY2UgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlc1tpXS5hZGQobmV3IEFjdGlvbnMuRm9sbG93KHRoaXMuX2FjdG9yc1tpXSwgYWN0b3IpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlc1tpXS5hZGQobmV3IEFjdGlvbnMuRm9sbG93KHRoaXMuX2FjdG9yc1tpXSwgYWN0b3IsIGZvbGxvd0Rpc3RhbmNlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGNhdXNlIHRoZSBhY3RvciB0byBtb3ZlIHRvd2FyZHMgYW5vdGhlciB1bnRpbCB0aGV5XHJcbiAgICAgICAgICogY29sbGlkZSBcIm1lZXRcIiBhdCBhIHNwZWNpZmllZCBzcGVlZC5cclxuICAgICAgICAgKiBAcGFyYW0gYWN0b3IgIFRoZSBhY3RvciB0byBtZWV0XHJcbiAgICAgICAgICogQHBhcmFtIHNwZWVkICBUaGUgc3BlZWQgaW4gcGl4ZWxzIHBlciBzZWNvbmQgdG8gbW92ZSwgaWYgbm90IHNwZWNpZmllZCBpdCB3aWxsIG1hdGNoIHRoZSBzcGVlZCBvZiB0aGUgb3RoZXIgYWN0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3Rpb25Db250ZXh0LnByb3RvdHlwZS5tZWV0ID0gZnVuY3Rpb24gKGFjdG9yLCBzcGVlZCkge1xyXG4gICAgICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3F1ZXVlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3BlZWQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlc1tpXS5hZGQobmV3IEFjdGlvbnMuTWVldCh0aGlzLl9hY3RvcnNbaV0sIGFjdG9yKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZXNbaV0uYWRkKG5ldyBBY3Rpb25zLk1lZXQodGhpcy5fYWN0b3JzW2ldLCBhY3Rvciwgc3BlZWQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgY3VycmVudCBhY3Rpb24gcXVldWUgdXAgdG8gbm93XHJcbiAgICAgICAgICogaXMgZmluaXNoZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0aW9uQ29udGV4dC5wcm90b3R5cGUuYXNQcm9taXNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSB0aGlzLl9xdWV1ZXMubWFwKGZ1bmN0aW9uIChxLCBpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IG5ldyBQcm9taXNlc18yLlByb21pc2UoKTtcclxuICAgICAgICAgICAgICAgIHEuYWRkKG5ldyBBY3Rpb25zLkNhbGxNZXRob2QoX3RoaXMuX2FjdG9yc1tpXSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXAucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRlbXA7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZXNfMi5Qcm9taXNlLmpvaW4uYXBwbHkodGhpcywgcHJvbWlzZXMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEFjdGlvbkNvbnRleHQ7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5BY3Rpb25Db250ZXh0ID0gQWN0aW9uQ29udGV4dDtcclxufSk7XHJcbmRlZmluZShcIlV0aWwvTG9nXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIExvZ2dpbmcgbGV2ZWwgdGhhdCBFeGNhbGlidXIgd2lsbCB0YWdcclxuICAgICAqL1xyXG4gICAgdmFyIExvZ0xldmVsO1xyXG4gICAgKGZ1bmN0aW9uIChMb2dMZXZlbCkge1xyXG4gICAgICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiRGVidWdcIl0gPSAwXSA9IFwiRGVidWdcIjtcclxuICAgICAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkluZm9cIl0gPSAxXSA9IFwiSW5mb1wiO1xyXG4gICAgICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiV2FyblwiXSA9IDJdID0gXCJXYXJuXCI7XHJcbiAgICAgICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJFcnJvclwiXSA9IDNdID0gXCJFcnJvclwiO1xyXG4gICAgICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiRmF0YWxcIl0gPSA0XSA9IFwiRmF0YWxcIjtcclxuICAgIH0pKExvZ0xldmVsID0gZXhwb3J0cy5Mb2dMZXZlbCB8fCAoZXhwb3J0cy5Mb2dMZXZlbCA9IHt9KSk7XHJcbiAgICAvKipcclxuICAgICAqIFN0YXRpYyBzaW5nbGV0b24gdGhhdCByZXByZXNlbnRzIHRoZSBsb2dnaW5nIGZhY2lsaXR5IGZvciBFeGNhbGlidXIuXHJcbiAgICAgKiBFeGNhbGlidXIgY29tZXMgYnVpbHQtaW4gd2l0aCBhIFtbQ29uc29sZUFwcGVuZGVyXV0gYW5kIFtbU2NyZWVuQXBwZW5kZXJdXS5cclxuICAgICAqIERlcml2ZSBmcm9tIFtbSUFwcGVuZGVyXV0gdG8gY3JlYXRlIHlvdXIgb3duIGxvZ2dpbmcgYXBwZW5kZXJzLlxyXG4gICAgICpcclxuICAgICAqIFtbaW5jbHVkZTpMb2dnZXIubWRdXVxyXG4gICAgICovXHJcbiAgICB2YXIgTG9nZ2VyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBMb2dnZXIoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FwcGVuZGVycyA9IFtdO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBkZWZhdWx0IGxvZ2dpbmcgbGV2ZWwuIEV4Y2FsaWJ1ciB3aWxsIG9ubHkgbG9nXHJcbiAgICAgICAgICAgICAqIG1lc3NhZ2VzIGlmIGVxdWFsIHRvIG9yIGFib3ZlIHRoaXMgbGV2ZWwuIERlZmF1bHQ6IFtbTG9nTGV2ZWwuSW5mb11dXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRMZXZlbCA9IExvZ0xldmVsLkluZm87XHJcbiAgICAgICAgICAgIGlmIChMb2dnZXIuX2luc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvZ2dlciBpcyBhIHNpbmdsZXRvbicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIExvZ2dlci5faW5zdGFuY2UgPSB0aGlzO1xyXG4gICAgICAgICAgICAvLyBEZWZhdWx0IGNvbnNvbGUgYXBwZW5kZXJcclxuICAgICAgICAgICAgTG9nZ2VyLl9pbnN0YW5jZS5hZGRBcHBlbmRlcihuZXcgQ29uc29sZUFwcGVuZGVyKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gTG9nZ2VyLl9pbnN0YW5jZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgY3VycmVudCBzdGF0aWMgaW5zdGFuY2Ugb2YgTG9nZ2VyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoTG9nZ2VyLl9pbnN0YW5jZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBMb2dnZXIuX2luc3RhbmNlID0gbmV3IExvZ2dlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBMb2dnZXIuX2luc3RhbmNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhIG5ldyBbW0lBcHBlbmRlcl1dIHRvIHRoZSBsaXN0IG9mIGFwcGVuZGVycyB0byB3cml0ZSB0b1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExvZ2dlci5wcm90b3R5cGUuYWRkQXBwZW5kZXIgPSBmdW5jdGlvbiAoYXBwZW5kZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fYXBwZW5kZXJzLnB1c2goYXBwZW5kZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2xlYXJzIGFsbCBhcHBlbmRlcnMgZnJvbSB0aGUgbG9nZ2VyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTG9nZ2VyLnByb3RvdHlwZS5jbGVhckFwcGVuZGVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fYXBwZW5kZXJzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMb2dzIGEgbWVzc2FnZSBhdCBhIGdpdmVuIExvZ0xldmVsXHJcbiAgICAgICAgICogQHBhcmFtIGxldmVsICBUaGUgTG9nTGV2ZWxgdG8gbG9nIHRoZSBtZXNzYWdlIGF0XHJcbiAgICAgICAgICogQHBhcmFtIGFyZ3MgICBBbiBhcnJheSBvZiBhcmd1bWVudHMgdG8gd3JpdGUgdG8gYW4gYXBwZW5kZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBMb2dnZXIucHJvdG90eXBlLl9sb2cgPSBmdW5jdGlvbiAobGV2ZWwsIGFyZ3MpIHtcclxuICAgICAgICAgICAgaWYgKGxldmVsID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGxldmVsID0gdGhpcy5kZWZhdWx0TGV2ZWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9hcHBlbmRlcnMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxldmVsID49IHRoaXMuZGVmYXVsdExldmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXBwZW5kZXJzW2ldLmxvZyhsZXZlbCwgYXJncyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdyaXRlcyBhIGxvZyBtZXNzYWdlIGF0IHRoZSBbW0xvZ0xldmVsLkRlYnVnXV0gbGV2ZWxcclxuICAgICAgICAgKiBAcGFyYW0gYXJncyAgQWNjZXB0cyBhbnkgbnVtYmVyIG9mIGFyZ3VtZW50c1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExvZ2dlci5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbG9nKExvZ0xldmVsLkRlYnVnLCBhcmdzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdyaXRlcyBhIGxvZyBtZXNzYWdlIGF0IHRoZSBbW0xvZ0xldmVsLkluZm9dXSBsZXZlbFxyXG4gICAgICAgICAqIEBwYXJhbSBhcmdzICBBY2NlcHRzIGFueSBudW1iZXIgb2YgYXJndW1lbnRzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTG9nZ2VyLnByb3RvdHlwZS5pbmZvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZyhMb2dMZXZlbC5JbmZvLCBhcmdzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdyaXRlcyBhIGxvZyBtZXNzYWdlIGF0IHRoZSBbW0xvZ0xldmVsLldhcm5dXSBsZXZlbFxyXG4gICAgICAgICAqIEBwYXJhbSBhcmdzICBBY2NlcHRzIGFueSBudW1iZXIgb2YgYXJndW1lbnRzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTG9nZ2VyLnByb3RvdHlwZS53YXJuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZyhMb2dMZXZlbC5XYXJuLCBhcmdzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdyaXRlcyBhIGxvZyBtZXNzYWdlIGF0IHRoZSBbW0xvZ0xldmVsLkVycm9yXV0gbGV2ZWxcclxuICAgICAgICAgKiBAcGFyYW0gYXJncyAgQWNjZXB0cyBhbnkgbnVtYmVyIG9mIGFyZ3VtZW50c1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExvZ2dlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbG9nKExvZ0xldmVsLkVycm9yLCBhcmdzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdyaXRlcyBhIGxvZyBtZXNzYWdlIGF0IHRoZSBbW0xvZ0xldmVsLkZhdGFsXV0gbGV2ZWxcclxuICAgICAgICAgKiBAcGFyYW0gYXJncyAgQWNjZXB0cyBhbnkgbnVtYmVyIG9mIGFyZ3VtZW50c1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExvZ2dlci5wcm90b3R5cGUuZmF0YWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbG9nKExvZ0xldmVsLkZhdGFsLCBhcmdzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBMb2dnZXI7XHJcbiAgICB9KCkpO1xyXG4gICAgTG9nZ2VyLl9pbnN0YW5jZSA9IG51bGw7XHJcbiAgICBleHBvcnRzLkxvZ2dlciA9IExvZ2dlcjtcclxuICAgIC8qKlxyXG4gICAgICogQ29uc29sZSBhcHBlbmRlciBmb3IgYnJvd3NlcnMgKGkuZS4gYGNvbnNvbGUubG9nYClcclxuICAgICAqL1xyXG4gICAgdmFyIENvbnNvbGVBcHBlbmRlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gQ29uc29sZUFwcGVuZGVyKCkge1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMb2dzIGEgbWVzc2FnZSBhdCB0aGUgZ2l2ZW4gW1tMb2dMZXZlbF1dXHJcbiAgICAgICAgICogQHBhcmFtIGxldmVsICBMZXZlbCB0byBsb2cgYXRcclxuICAgICAgICAgKiBAcGFyYW0gYXJncyAgIEFyZ3VtZW50cyB0byBsb2dcclxuICAgICAgICAgKi9cclxuICAgICAgICBDb25zb2xlQXBwZW5kZXIucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uIChsZXZlbCwgYXJncykge1xyXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgY29uc29sZSBzdXBwb3J0XHJcbiAgICAgICAgICAgIGlmICghY29uc29sZSAmJiAhY29uc29sZS5sb2cgJiYgY29uc29sZS53YXJuICYmIGNvbnNvbGUuZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIC8vIHRvZG8gbWF5YmUgZG8gc29tZXRoaW5nIGJldHRlciB0aGFuIG5vdGhpbmdcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgY29uc29sZSBhcmdzIGFycmF5XHJcbiAgICAgICAgICAgIHZhciBjb25zb2xlQXJncyA9IFtdO1xyXG4gICAgICAgICAgICBjb25zb2xlQXJncy51bnNoaWZ0LmFwcGx5KGNvbnNvbGVBcmdzLCBhcmdzKTtcclxuICAgICAgICAgICAgY29uc29sZUFyZ3MudW5zaGlmdCgnWycgKyBMb2dMZXZlbFtsZXZlbF0gKyAnXSA6ICcpO1xyXG4gICAgICAgICAgICBpZiAobGV2ZWwgPCBMb2dMZXZlbC5XYXJuKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDYWxsIC5sb2cgZm9yIERlYnVnL0luZm9cclxuICAgICAgICAgICAgICAgIGlmIChjb25zb2xlLmxvZy5hcHBseSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgcmVxdWlyZWQgb24gc29tZSBvbGRlciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgYXBwbHkgb24gY29uc29sZS5sb2cgOihcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBjb25zb2xlQXJncyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhjb25zb2xlQXJncy5qb2luKCcgJykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGxldmVsIDwgTG9nTGV2ZWwuRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIC8vIENhbGwgLndhcm4gZm9yIFdhcm5cclxuICAgICAgICAgICAgICAgIGlmIChjb25zb2xlLndhcm4uYXBwbHkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgY29uc29sZUFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGNvbnNvbGVBcmdzLmpvaW4oJyAnKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDYWxsIC5lcnJvciBmb3IgRXJyb3IvRmF0YWxcclxuICAgICAgICAgICAgICAgIGlmIChjb25zb2xlLmVycm9yLmFwcGx5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvci5hcHBseShjb25zb2xlLCBjb25zb2xlQXJncyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGNvbnNvbGVBcmdzLmpvaW4oJyAnKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBDb25zb2xlQXBwZW5kZXI7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5Db25zb2xlQXBwZW5kZXIgPSBDb25zb2xlQXBwZW5kZXI7XHJcbiAgICAvKipcclxuICAgICAqIE9uLXNjcmVlbiAoY2FudmFzKSBhcHBlbmRlclxyXG4gICAgICovXHJcbiAgICB2YXIgU2NyZWVuQXBwZW5kZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB3aWR0aCAgIFdpZHRoIG9mIHRoZSBzY3JlZW4gYXBwZW5kZXIgaW4gcGl4ZWxzXHJcbiAgICAgICAgICogQHBhcmFtIGhlaWdodCAgSGVpZ2h0IG9mIHRoZSBzY3JlZW4gYXBwZW5kZXIgaW4gcGl4ZWxzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gU2NyZWVuQXBwZW5kZXIod2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgICAgICAvLyBAdG9kbyBDbGVhbiB0aGlzIHVwXHJcbiAgICAgICAgICAgIHRoaXMuX21lc3NhZ2VzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgICAgICB0aGlzLl9jYW52YXMud2lkdGggPSB3aWR0aCB8fCB3aW5kb3cuaW5uZXJXaWR0aDtcclxuICAgICAgICAgICAgdGhpcy5fY2FudmFzLmhlaWdodCA9IGhlaWdodCB8fCB3aW5kb3cuaW5uZXJIZWlnaHQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcbiAgICAgICAgICAgIHRoaXMuX2N0eCA9IHRoaXMuX2NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX2NhbnZhcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExvZ3MgYSBtZXNzYWdlIGF0IHRoZSBnaXZlbiBbW0xvZ0xldmVsXV1cclxuICAgICAgICAgKiBAcGFyYW0gbGV2ZWwgIExldmVsIHRvIGxvZyBhdFxyXG4gICAgICAgICAqIEBwYXJhbSBhcmdzICAgQXJndW1lbnRzIHRvIGxvZ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNjcmVlbkFwcGVuZGVyLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAobGV2ZWwsIGFyZ3MpIHtcclxuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBhcmdzLmpvaW4oJywnKTtcclxuICAgICAgICAgICAgdGhpcy5fY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLl9jYW52YXMud2lkdGgsIHRoaXMuX2NhbnZhcy5oZWlnaHQpO1xyXG4gICAgICAgICAgICB0aGlzLl9tZXNzYWdlcy51bnNoaWZ0KCdbJyArIExvZ0xldmVsW2xldmVsXSArICddIDogJyArIG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB2YXIgcG9zID0gMTA7XHJcbiAgICAgICAgICAgIHZhciBvcGFjaXR5ID0gMS4wO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX21lc3NhZ2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jdHguZmlsbFN0eWxlID0gJ3JnYmEoMjU1LDI1NSwyNTUsJyArIG9wYWNpdHkudG9GaXhlZCgyKSArICcpJztcclxuICAgICAgICAgICAgICAgIHRoaXMuX2N0eC5maWxsVGV4dCh0aGlzLl9tZXNzYWdlc1tpXSwgMjAwLCBwb3MpO1xyXG4gICAgICAgICAgICAgICAgcG9zICs9IDEwO1xyXG4gICAgICAgICAgICAgICAgb3BhY2l0eSA9IG9wYWNpdHkgPiAwID8gb3BhY2l0eSAtIC4wNSA6IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBTY3JlZW5BcHBlbmRlcjtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLlNjcmVlbkFwcGVuZGVyID0gU2NyZWVuQXBwZW5kZXI7XHJcbn0pO1xyXG5kZWZpbmUoXCJBY3Rpb25zL0lBY3Rpb25hYmxlXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbn0pO1xyXG5kZWZpbmUoXCJHcm91cFwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkFsZ2VicmFcIiwgXCJBY3Rpb25zL0FjdGlvbkNvbnRleHRcIiwgXCJBY3RvclwiLCBcIlV0aWwvTG9nXCIsIFwiQ2xhc3NcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBBbGdlYnJhXzEwLCBBY3Rpb25Db250ZXh0XzEsIEFjdG9yXzMsIExvZ18xLCBDbGFzc18xKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogR3JvdXBzIGFyZSB1c2VkIGZvciBsb2dpY2FsbHkgZ3JvdXBpbmcgQWN0b3JzIHNvIHRoZXkgY2FuIGJlIGFjdGVkIHVwb25cclxuICAgICAqIGluIGJ1bGsuXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOkdyb3Vwcy5tZF1dXHJcbiAgICAgKi9cclxuICAgIHZhciBHcm91cCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKEdyb3VwLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIEdyb3VwKG5hbWUsIHNjZW5lKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgICAgICBfdGhpcy5zY2VuZSA9IHNjZW5lO1xyXG4gICAgICAgICAgICBfdGhpcy5fbG9nZ2VyID0gTG9nXzEuTG9nZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgICAgIF90aGlzLl9tZW1iZXJzID0gW107XHJcbiAgICAgICAgICAgIF90aGlzLmFjdGlvbnMgPSBuZXcgQWN0aW9uQ29udGV4dF8xLkFjdGlvbkNvbnRleHQoKTtcclxuICAgICAgICAgICAgaWYgKHNjZW5lID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuZXJyb3IoJ0ludmFsaWQgY29uc3RydWN0b3IgYXJndW1lbnRzIHBhc3NlZCB0byBHcm91cDogJywgbmFtZSwgJywgc2NlbmUgbXVzdCBub3QgYmUgbnVsbCEnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBleGlzdGluZ0dyb3VwID0gc2NlbmUuZ3JvdXBzW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nR3JvdXApIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLndhcm4oJ0dyb3VwIHdpdGggbmFtZScsIG5hbWUsICdhbHJlYWR5IGV4aXN0cy4gVGhpcyBuZXcgZ3JvdXAgd2lsbCByZXBsYWNlIGl0LicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2NlbmUuZ3JvdXBzW25hbWVdID0gX3RoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBHcm91cC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGFjdG9yT3JBY3RvcnMpIHtcclxuICAgICAgICAgICAgaWYgKGFjdG9yT3JBY3RvcnMgaW5zdGFuY2VvZiBBY3Rvcl8zLkFjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBhY3Rvck9yQWN0b3JzID0gW10uY29uY2F0KGFjdG9yT3JBY3RvcnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpID0gMCwgbGVuID0gYWN0b3JPckFjdG9ycy5sZW5ndGgsIGdyb3VwSWR4O1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgZ3JvdXBJZHggPSB0aGlzLmdldE1lbWJlcnMoKS5pbmRleE9mKGFjdG9yT3JBY3RvcnNbaV0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwSWR4ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21lbWJlcnMucHVzaChhY3Rvck9yQWN0b3JzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLmFkZChhY3Rvck9yQWN0b3JzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGlvbnMuYWRkQWN0b3JUb0NvbnRleHQoYWN0b3JPckFjdG9yc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIud2lyZShhY3Rvck9yQWN0b3JzW2ldLmV2ZW50RGlzcGF0Y2hlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEdyb3VwLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoYWN0b3IpIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fbWVtYmVycy5pbmRleE9mKGFjdG9yKTtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21lbWJlcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5yZW1vdmVBY3RvckZyb21Db250ZXh0KGFjdG9yKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLnVud2lyZShhY3Rvci5ldmVudERpc3BhdGNoZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBHcm91cC5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uIChhcmdzKSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gMCwgbWVtYmVycyA9IHRoaXMuZ2V0TWVtYmVycygpLCBsZW4gPSBtZW1iZXJzLmxlbmd0aDtcclxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgYXJncyBpbnN0YW5jZW9mIEFsZ2VicmFfMTAuVmVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIG1lbWJlcnNbaV0ucG9zLnggKz0gYXJncy54O1xyXG4gICAgICAgICAgICAgICAgICAgIG1lbWJlcnNbaV0ucG9zLnkgKz0gYXJncy55O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInICYmIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IGFyZ3VtZW50c1swXTtcclxuICAgICAgICAgICAgICAgIHZhciB5ID0gYXJndW1lbnRzWzFdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBtZW1iZXJzW2ldLnBvcy54ICs9IHg7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVtYmVyc1tpXS5wb3MueSArPSB5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cyBwYXNzZWQgdG8gZ3JvdXAgbW92ZScsIHRoaXMubmFtZSwgJ2FyZ3M6JywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgR3JvdXAucHJvdG90eXBlLnJvdGF0ZSA9IGZ1bmN0aW9uIChhbmdsZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGFuZ2xlICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cyBwYXNzZWQgdG8gZ3JvdXAgcm90YXRlJywgdGhpcy5uYW1lLCAnYXJnczonLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmdldE1lbWJlcnMoKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBtZW1iZXIgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICBtZW1iZXIucm90YXRpb24gKz0gYW5nbGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEdyb3VwLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIub24oZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEdyb3VwLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLm9mZihldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgR3JvdXAucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAodG9waWMsIGV2ZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLmVtaXQodG9waWMsIGV2ZW50KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEdyb3VwLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChhY3Rvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRNZW1iZXJzKCkuaW5kZXhPZihhY3RvcikgPiAtMTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEdyb3VwLnByb3RvdHlwZS5nZXRNZW1iZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWVtYmVycztcclxuICAgICAgICB9O1xyXG4gICAgICAgIEdyb3VwLnByb3RvdHlwZS5nZXRSYW5kb21NZW1iZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tZW1iZXJzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHRoaXMuX21lbWJlcnMubGVuZ3RoKV07XHJcbiAgICAgICAgfTtcclxuICAgICAgICBHcm91cC5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRNZW1iZXJzKCkubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLmdldEJvdW5kcygpOyB9KS5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cnIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2LmNvbWJpbmUoY3Vycik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEdyb3VwO1xyXG4gICAgfShDbGFzc18xLkNsYXNzKSk7XHJcbiAgICBleHBvcnRzLkdyb3VwID0gR3JvdXA7XHJcbn0pO1xyXG4vKipcclxuICogVGhlc2UgZWZmZWN0cyBjYW4gYmUgYXBwbGllZCB0byBhbnkgYml0bWFwIGltYWdlIGJ1dCBhcmUgbWFpbmx5IHVzZWRcclxuICogZm9yIFtbU3ByaXRlXV0gZWZmZWN0cyBvciBbW0FuaW1hdGlvbl1dIGVmZmVjdHMuXHJcbiAqXHJcbiAqIFtbaW5jbHVkZTpTcHJpdGVFZmZlY3RzLm1kXV1cclxuICovXHJcbmRlZmluZShcIkRyYXdpbmcvU3ByaXRlRWZmZWN0c1wiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkRyYXdpbmcvQ29sb3JcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBDb2xvcl84KSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgXCJHcmF5c2NhbGVcIiBlZmZlY3QgdG8gYSBzcHJpdGUsIHJlbW92aW5nIGNvbG9yIGluZm9ybWF0aW9uLlxyXG4gICAgICovXHJcbiAgICB2YXIgR3JheXNjYWxlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBHcmF5c2NhbGUoKSB7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEdyYXlzY2FsZS5wcm90b3R5cGUudXBkYXRlUGl4ZWwgPSBmdW5jdGlvbiAoeCwgeSwgaW1hZ2VEYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciBmaXJzdFBpeGVsID0gKHggKyB5ICogaW1hZ2VEYXRhLndpZHRoKSAqIDQ7XHJcbiAgICAgICAgICAgIHZhciBwaXhlbCA9IGltYWdlRGF0YS5kYXRhO1xyXG4gICAgICAgICAgICB2YXIgYXZnID0gKHBpeGVsW2ZpcnN0UGl4ZWwgKyAwXSArIHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXSArIHBpeGVsW2ZpcnN0UGl4ZWwgKyAyXSkgLyAzO1xyXG4gICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMF0gPSBhdmc7XHJcbiAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXSA9IGF2ZztcclxuICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDJdID0gYXZnO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEdyYXlzY2FsZTtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkdyYXlzY2FsZSA9IEdyYXlzY2FsZTtcclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgXCJJbnZlcnRcIiBlZmZlY3QgdG8gYSBzcHJpdGUsIGludmVydGluZyB0aGUgcGl4ZWwgY29sb3JzLlxyXG4gICAgICovXHJcbiAgICB2YXIgSW52ZXJ0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBJbnZlcnQoKSB7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEludmVydC5wcm90b3R5cGUudXBkYXRlUGl4ZWwgPSBmdW5jdGlvbiAoeCwgeSwgaW1hZ2VEYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciBmaXJzdFBpeGVsID0gKHggKyB5ICogaW1hZ2VEYXRhLndpZHRoKSAqIDQ7XHJcbiAgICAgICAgICAgIHZhciBwaXhlbCA9IGltYWdlRGF0YS5kYXRhO1xyXG4gICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMF0gPSAyNTUgLSBwaXhlbFtmaXJzdFBpeGVsICsgMF07XHJcbiAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXSA9IDI1NSAtIHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXTtcclxuICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDJdID0gMjU1IC0gcGl4ZWxbZmlyc3RQaXhlbCArIDJdO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEludmVydDtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkludmVydCA9IEludmVydDtcclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgXCJPcGFjaXR5XCIgZWZmZWN0IHRvIGEgc3ByaXRlLCBzZXR0aW5nIHRoZSBhbHBoYSBvZiBhbGwgcGl4ZWxzIHRvIGEgZ2l2ZW4gdmFsdWUuXHJcbiAgICAgKi9cclxuICAgIHZhciBPcGFjaXR5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gb3BhY2l0eSAgVGhlIG5ldyBvcGFjaXR5IG9mIHRoZSBzcHJpdGUgZnJvbSAwLTEuMFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIE9wYWNpdHkob3BhY2l0eSkge1xyXG4gICAgICAgICAgICB0aGlzLm9wYWNpdHkgPSBvcGFjaXR5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBPcGFjaXR5LnByb3RvdHlwZS51cGRhdGVQaXhlbCA9IGZ1bmN0aW9uICh4LCB5LCBpbWFnZURhdGEpIHtcclxuICAgICAgICAgICAgdmFyIGZpcnN0UGl4ZWwgPSAoeCArIHkgKiBpbWFnZURhdGEud2lkdGgpICogNDtcclxuICAgICAgICAgICAgdmFyIHBpeGVsID0gaW1hZ2VEYXRhLmRhdGE7XHJcbiAgICAgICAgICAgIGlmIChwaXhlbFtmaXJzdFBpeGVsICsgM10gIT09IDApIHtcclxuICAgICAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAzXSA9IE1hdGgucm91bmQodGhpcy5vcGFjaXR5ICogcGl4ZWxbZmlyc3RQaXhlbCArIDNdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIE9wYWNpdHk7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5PcGFjaXR5ID0gT3BhY2l0eTtcclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgXCJDb2xvcml6ZVwiIGVmZmVjdCB0byBhIHNwcml0ZSwgY2hhbmdpbmcgdGhlIGNvbG9yIGNoYW5uZWxzIG9mIGFsbCB0aGUgcGl4ZWxzIHRvIGFuXHJcbiAgICAgKiBhdmVyYWdlIG9mIHRoZSBvcmlnaW5hbCBjb2xvciBhbmQgdGhlIHByb3ZpZGVkIGNvbG9yXHJcbiAgICAgKi9cclxuICAgIHZhciBDb2xvcml6ZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIGNvbG9yICBUaGUgY29sb3IgdG8gYXBwbHkgdG8gdGhlIHNwcml0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIENvbG9yaXplKGNvbG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgQ29sb3JpemUucHJvdG90eXBlLnVwZGF0ZVBpeGVsID0gZnVuY3Rpb24gKHgsIHksIGltYWdlRGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgZmlyc3RQaXhlbCA9ICh4ICsgeSAqIGltYWdlRGF0YS53aWR0aCkgKiA0O1xyXG4gICAgICAgICAgICB2YXIgcGl4ZWwgPSBpbWFnZURhdGEuZGF0YTtcclxuICAgICAgICAgICAgaWYgKHBpeGVsW2ZpcnN0UGl4ZWwgKyAzXSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDBdID0gKHBpeGVsW2ZpcnN0UGl4ZWwgKyAwXSArIHRoaXMuY29sb3IucikgLyAyO1xyXG4gICAgICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDFdID0gKHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXSArIHRoaXMuY29sb3IuZykgLyAyO1xyXG4gICAgICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDJdID0gKHBpeGVsW2ZpcnN0UGl4ZWwgKyAyXSArIHRoaXMuY29sb3IuYikgLyAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gQ29sb3JpemU7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5Db2xvcml6ZSA9IENvbG9yaXplO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBcIkxpZ2h0ZW5cIiBlZmZlY3QgdG8gYSBzcHJpdGUsIGNoYW5nZXMgdGhlIGxpZ2h0bmVzcyBvZiB0aGUgY29sb3IgYWNjb3JkaW5nIHRvIEhTTFxyXG4gICAgICovXHJcbiAgICB2YXIgTGlnaHRlbiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIGZhY3RvciAgVGhlIGZhY3RvciBvZiB0aGUgZWZmZWN0IGJldHdlZW4gMC0xXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gTGlnaHRlbihmYWN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKGZhY3RvciA9PT0gdm9pZCAwKSB7IGZhY3RvciA9IDAuMTsgfVxyXG4gICAgICAgICAgICB0aGlzLmZhY3RvciA9IGZhY3RvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgTGlnaHRlbi5wcm90b3R5cGUudXBkYXRlUGl4ZWwgPSBmdW5jdGlvbiAoeCwgeSwgaW1hZ2VEYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciBmaXJzdFBpeGVsID0gKHggKyB5ICogaW1hZ2VEYXRhLndpZHRoKSAqIDQ7XHJcbiAgICAgICAgICAgIHZhciBwaXhlbCA9IGltYWdlRGF0YS5kYXRhO1xyXG4gICAgICAgICAgICB2YXIgY29sb3IgPSBDb2xvcl84LkNvbG9yLmZyb21SR0IocGl4ZWxbZmlyc3RQaXhlbCArIDBdLCBwaXhlbFtmaXJzdFBpeGVsICsgMV0sIHBpeGVsW2ZpcnN0UGl4ZWwgKyAyXSwgcGl4ZWxbZmlyc3RQaXhlbCArIDNdKS5saWdodGVuKHRoaXMuZmFjdG9yKTtcclxuICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDBdID0gY29sb3IucjtcclxuICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDFdID0gY29sb3IuZztcclxuICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDJdID0gY29sb3IuYjtcclxuICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDNdID0gY29sb3IuYTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBMaWdodGVuO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuTGlnaHRlbiA9IExpZ2h0ZW47XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIFwiRGFya2VuXCIgZWZmZWN0IHRvIGEgc3ByaXRlLCBjaGFuZ2VzIHRoZSBkYXJrbmVzcyBvZiB0aGUgY29sb3IgYWNjb3JkaW5nIHRvIEhTTFxyXG4gICAgICovXHJcbiAgICB2YXIgRGFya2VuID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gZmFjdG9yICBUaGUgZmFjdG9yIG9mIHRoZSBlZmZlY3QgYmV0d2VlbiAwLTFcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBEYXJrZW4oZmFjdG9yKSB7XHJcbiAgICAgICAgICAgIGlmIChmYWN0b3IgPT09IHZvaWQgMCkgeyBmYWN0b3IgPSAwLjE7IH1cclxuICAgICAgICAgICAgdGhpcy5mYWN0b3IgPSBmYWN0b3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIERhcmtlbi5wcm90b3R5cGUudXBkYXRlUGl4ZWwgPSBmdW5jdGlvbiAoeCwgeSwgaW1hZ2VEYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciBmaXJzdFBpeGVsID0gKHggKyB5ICogaW1hZ2VEYXRhLndpZHRoKSAqIDQ7XHJcbiAgICAgICAgICAgIHZhciBwaXhlbCA9IGltYWdlRGF0YS5kYXRhO1xyXG4gICAgICAgICAgICB2YXIgY29sb3IgPSBDb2xvcl84LkNvbG9yLmZyb21SR0IocGl4ZWxbZmlyc3RQaXhlbCArIDBdLCBwaXhlbFtmaXJzdFBpeGVsICsgMV0sIHBpeGVsW2ZpcnN0UGl4ZWwgKyAyXSwgcGl4ZWxbZmlyc3RQaXhlbCArIDNdKS5kYXJrZW4odGhpcy5mYWN0b3IpO1xyXG4gICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMF0gPSBjb2xvci5yO1xyXG4gICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMV0gPSBjb2xvci5nO1xyXG4gICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMl0gPSBjb2xvci5iO1xyXG4gICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgM10gPSBjb2xvci5hO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIERhcmtlbjtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkRhcmtlbiA9IERhcmtlbjtcclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgXCJTYXR1cmF0ZVwiIGVmZmVjdCB0byBhIHNwcml0ZSwgc2F0dXJhdGVzIHRoZSBjb2xvciBhY2NvcmRpbmcgdG8gSFNMXHJcbiAgICAgKi9cclxuICAgIHZhciBTYXR1cmF0ZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIGZhY3RvciAgVGhlIGZhY3RvciBvZiB0aGUgZWZmZWN0IGJldHdlZW4gMC0xXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gU2F0dXJhdGUoZmFjdG9yKSB7XHJcbiAgICAgICAgICAgIGlmIChmYWN0b3IgPT09IHZvaWQgMCkgeyBmYWN0b3IgPSAwLjE7IH1cclxuICAgICAgICAgICAgdGhpcy5mYWN0b3IgPSBmYWN0b3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFNhdHVyYXRlLnByb3RvdHlwZS51cGRhdGVQaXhlbCA9IGZ1bmN0aW9uICh4LCB5LCBpbWFnZURhdGEpIHtcclxuICAgICAgICAgICAgdmFyIGZpcnN0UGl4ZWwgPSAoeCArIHkgKiBpbWFnZURhdGEud2lkdGgpICogNDtcclxuICAgICAgICAgICAgdmFyIHBpeGVsID0gaW1hZ2VEYXRhLmRhdGE7XHJcbiAgICAgICAgICAgIHZhciBjb2xvciA9IENvbG9yXzguQ29sb3IuZnJvbVJHQihwaXhlbFtmaXJzdFBpeGVsICsgMF0sIHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXSwgcGl4ZWxbZmlyc3RQaXhlbCArIDJdLCBwaXhlbFtmaXJzdFBpeGVsICsgM10pLnNhdHVyYXRlKHRoaXMuZmFjdG9yKTtcclxuICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDBdID0gY29sb3IucjtcclxuICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDFdID0gY29sb3IuZztcclxuICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDJdID0gY29sb3IuYjtcclxuICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDNdID0gY29sb3IuYTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBTYXR1cmF0ZTtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLlNhdHVyYXRlID0gU2F0dXJhdGU7XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIFwiRGVzYXR1cmF0ZVwiIGVmZmVjdCB0byBhIHNwcml0ZSwgZGVzYXR1cmF0ZXMgdGhlIGNvbG9yIGFjY29yZGluZyB0byBIU0xcclxuICAgICAqL1xyXG4gICAgdmFyIERlc2F0dXJhdGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBmYWN0b3IgIFRoZSBmYWN0b3Igb2YgdGhlIGVmZmVjdCBiZXR3ZWVuIDAtMVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIERlc2F0dXJhdGUoZmFjdG9yKSB7XHJcbiAgICAgICAgICAgIGlmIChmYWN0b3IgPT09IHZvaWQgMCkgeyBmYWN0b3IgPSAwLjE7IH1cclxuICAgICAgICAgICAgdGhpcy5mYWN0b3IgPSBmYWN0b3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIERlc2F0dXJhdGUucHJvdG90eXBlLnVwZGF0ZVBpeGVsID0gZnVuY3Rpb24gKHgsIHksIGltYWdlRGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgZmlyc3RQaXhlbCA9ICh4ICsgeSAqIGltYWdlRGF0YS53aWR0aCkgKiA0O1xyXG4gICAgICAgICAgICB2YXIgcGl4ZWwgPSBpbWFnZURhdGEuZGF0YTtcclxuICAgICAgICAgICAgdmFyIGNvbG9yID0gQ29sb3JfOC5Db2xvci5mcm9tUkdCKHBpeGVsW2ZpcnN0UGl4ZWwgKyAwXSwgcGl4ZWxbZmlyc3RQaXhlbCArIDFdLCBwaXhlbFtmaXJzdFBpeGVsICsgMl0sIHBpeGVsW2ZpcnN0UGl4ZWwgKyAzXSkuZGVzYXR1cmF0ZSh0aGlzLmZhY3Rvcik7XHJcbiAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAwXSA9IGNvbG9yLnI7XHJcbiAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXSA9IGNvbG9yLmc7XHJcbiAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAyXSA9IGNvbG9yLmI7XHJcbiAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAzXSA9IGNvbG9yLmE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gRGVzYXR1cmF0ZTtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkRlc2F0dXJhdGUgPSBEZXNhdHVyYXRlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBcIkZpbGxcIiBlZmZlY3QgdG8gYSBzcHJpdGUsIGNoYW5naW5nIHRoZSBjb2xvciBjaGFubmVscyBvZiBhbGwgbm9uLXRyYW5zcGFyZW50IHBpeGVscyB0byBtYXRjaFxyXG4gICAgICogYSBnaXZlbiBjb2xvclxyXG4gICAgICovXHJcbiAgICB2YXIgRmlsbCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIGNvbG9yICBUaGUgY29sb3IgdG8gYXBwbHkgdG8gdGhlIHNwcml0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIEZpbGwoY29sb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBGaWxsLnByb3RvdHlwZS51cGRhdGVQaXhlbCA9IGZ1bmN0aW9uICh4LCB5LCBpbWFnZURhdGEpIHtcclxuICAgICAgICAgICAgdmFyIGZpcnN0UGl4ZWwgPSAoeCArIHkgKiBpbWFnZURhdGEud2lkdGgpICogNDtcclxuICAgICAgICAgICAgdmFyIHBpeGVsID0gaW1hZ2VEYXRhLmRhdGE7XHJcbiAgICAgICAgICAgIGlmIChwaXhlbFtmaXJzdFBpeGVsICsgM10gIT09IDApIHtcclxuICAgICAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAwXSA9IHRoaXMuY29sb3IucjtcclxuICAgICAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXSA9IHRoaXMuY29sb3IuZztcclxuICAgICAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAyXSA9IHRoaXMuY29sb3IuYjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEZpbGw7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5GaWxsID0gRmlsbDtcclxufSk7XHJcbmRlZmluZShcIkludGVyZmFjZXMvSURyYXdhYmxlXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbn0pO1xyXG5kZWZpbmUoXCJJbnRlcmZhY2VzL0lMb2FkYWJsZVwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG59KTtcclxuZGVmaW5lKFwiUmVzb3VyY2VzL1Jlc291cmNlXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiQ2xhc3NcIiwgXCJQcm9taXNlc1wiLCBcIlV0aWwvTG9nXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgQ2xhc3NfMiwgUHJvbWlzZXNfMywgTG9nXzIpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgW1tSZXNvdXJjZV1dIHR5cGUgYWxsb3dzIGdhbWVzIGJ1aWx0IGluIEV4Y2FsaWJ1ciB0byBsb2FkIGdlbmVyaWMgcmVzb3VyY2VzLlxyXG4gICAgICogRm9yIGFueSB0eXBlIG9mIHJlbW90ZSByZXNvdXJjZSBpdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgW1tSZXNvdXJjZV1dIGZvciBwcmVsb2FkaW5nLlxyXG4gICAgICpcclxuICAgICAqIFtbaW5jbHVkZTpSZXNvdXJjZXMubWRdXVxyXG4gICAgICovXHJcbiAgICB2YXIgUmVzb3VyY2UgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhSZXNvdXJjZSwgX3N1cGVyKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gcGF0aCAgICAgICAgICBQYXRoIHRvIHRoZSByZW1vdGUgcmVzb3VyY2VcclxuICAgICAgICAgKiBAcGFyYW0gcmVzcG9uc2VUeXBlICBUaGUgdHlwZSB0byBleHBlY3QgYXMgYSByZXNwb25zZTogXCJcIiB8IFwiYXJyYXlidWZmZXJcIiB8IFwiYmxvYlwiIHwgXCJkb2N1bWVudFwiIHwgXCJqc29uXCIgfCBcInRleHRcIjtcclxuICAgICAgICAgKiBAcGFyYW0gYnVzdENhY2hlICAgICBXaGV0aGVyIG9yIG5vdCB0byBjYWNoZS1idXN0IHJlcXVlc3RzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gUmVzb3VyY2UocGF0aCwgcmVzcG9uc2VUeXBlLCBidXN0Q2FjaGUpIHtcclxuICAgICAgICAgICAgaWYgKGJ1c3RDYWNoZSA9PT0gdm9pZCAwKSB7IGJ1c3RDYWNoZSA9IHRydWU7IH1cclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMucGF0aCA9IHBhdGg7XHJcbiAgICAgICAgICAgIF90aGlzLnJlc3BvbnNlVHlwZSA9IHJlc3BvbnNlVHlwZTtcclxuICAgICAgICAgICAgX3RoaXMuYnVzdENhY2hlID0gYnVzdENhY2hlO1xyXG4gICAgICAgICAgICBfdGhpcy5kYXRhID0gbnVsbDtcclxuICAgICAgICAgICAgX3RoaXMubG9nZ2VyID0gTG9nXzIuTG9nZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgICAgIF90aGlzLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7IHJldHVybjsgfTtcclxuICAgICAgICAgICAgX3RoaXMub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuOyB9O1xyXG4gICAgICAgICAgICBfdGhpcy5vbmVycm9yID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBSZXNvdXJjZSBpcyBjb21wbGV0ZWx5IGxvYWRlZCBhbmQgaXMgcmVhZHlcclxuICAgICAgICAgKiB0byBiZSBkcmF3bi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBSZXNvdXJjZS5wcm90b3R5cGUuaXNMb2FkZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEgIT09IG51bGw7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBSZXNvdXJjZS5wcm90b3R5cGUud2lyZUVuZ2luZSA9IGZ1bmN0aW9uIChfZW5naW5lKSB7XHJcbiAgICAgICAgICAgIC8vIG92ZXJyaWRlIG1lXHJcbiAgICAgICAgfTtcclxuICAgICAgICBSZXNvdXJjZS5wcm90b3R5cGUuX2NhY2hlQnVzdCA9IGZ1bmN0aW9uICh1cmkpIHtcclxuICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gL1xcP1xcdyo9XFx3Ki87XHJcbiAgICAgICAgICAgIGlmIChxdWVyeS50ZXN0KHVyaSkpIHtcclxuICAgICAgICAgICAgICAgIHVyaSArPSAoJyZfXz0nICsgRGF0ZS5ub3coKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB1cmkgKz0gKCc/X189JyArIERhdGUubm93KCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB1cmk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBSZXNvdXJjZS5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnU3RhcnRlZCBsb2FkaW5nIHJlc291cmNlICcgKyB0aGlzLnBhdGgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQmVnaW4gbG9hZGluZyB0aGUgcmVzb3VyY2UgYW5kIHJldHVybnMgYSBwcm9taXNlIHRvIGJlIHJlc29sdmVkIG9uIGNvbXBsZXRpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBSZXNvdXJjZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGNvbXBsZXRlID0gbmV3IFByb21pc2VzXzMuUHJvbWlzZSgpO1xyXG4gICAgICAgICAgICAvLyBFeGl0IGVhcmx5IGlmIHdlIGFscmVhZHkgaGF2ZSBkYXRhXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdBbHJlYWR5IGhhdmUgZGF0YSBmb3IgcmVzb3VyY2UnLCB0aGlzLnBhdGgpO1xyXG4gICAgICAgICAgICAgICAgY29tcGxldGUucmVzb2x2ZSh0aGlzLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbmNvbXBsZXRlKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGxldGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICAgICAgcmVxdWVzdC5vcGVuKCdHRVQnLCB0aGlzLmJ1c3RDYWNoZSA/IHRoaXMuX2NhY2hlQnVzdCh0aGlzLnBhdGgpIDogdGhpcy5wYXRoLCB0cnVlKTtcclxuICAgICAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSB0aGlzLnJlc3BvbnNlVHlwZTtcclxuICAgICAgICAgICAgcmVxdWVzdC5vbmxvYWRzdGFydCA9IGZ1bmN0aW9uICgpIHsgX3RoaXMuX3N0YXJ0KCk7IH07XHJcbiAgICAgICAgICAgIHJlcXVlc3Qub25wcm9ncmVzcyA9IHRoaXMub25wcm9ncmVzcztcclxuICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gdGhpcy5vbmVycm9yO1xyXG4gICAgICAgICAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIC8vIFhIUiBvbiBmaWxlOi8vIHN1Y2Nlc3Mgc3RhdHVzIGlzIDAsIHN1Y2ggYXMgd2l0aCBQaGFudG9tSlNcclxuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyAhPT0gMCAmJiByZXF1ZXN0LnN0YXR1cyAhPT0gMjAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gbG9hZCByZXNvdXJjZSAnLCBfdGhpcy5wYXRoLCAnIHNlcnZlciByZXNwb25kZWQgd2l0aCBlcnJvciBjb2RlJywgcmVxdWVzdC5zdGF0dXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9uZXJyb3IocmVxdWVzdC5yZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGUucmVzb2x2ZShyZXF1ZXN0LnJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5kYXRhID0gX3RoaXMucHJvY2Vzc0RhdGEocmVxdWVzdC5yZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5vbmNvbXBsZXRlKCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZGVidWcoJ0NvbXBsZXRlZCBsb2FkaW5nIHJlc291cmNlJywgX3RoaXMucGF0aCk7XHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZS5yZXNvbHZlKF90aGlzLmRhdGEpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXF1ZXN0LnNlbmQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgbG9hZGVkIGRhdGEgb25jZSB0aGUgcmVzb3VyY2UgaXMgbG9hZGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVzb3VyY2UucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBkYXRhIGZvciB0aGlzIHJlc291cmNlIGRpcmVjdGx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVzb3VyY2UucHJvdG90eXBlLnNldERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLnByb2Nlc3NEYXRhKGRhdGEpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2QgaXMgbWVhbnQgdG8gYmUgb3ZlcnJpZGVuIHRvIGhhbmRsZSBhbnkgYWRkaXRpb25hbFxyXG4gICAgICAgICAqIHByb2Nlc3NpbmcuIFN1Y2ggYXMgZGVjb2RpbmcgZG93bmxvYWRlZCBhdWRpbyBiaXRzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlc291cmNlLnByb3RvdHlwZS5wcm9jZXNzRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9YTUxIdHRwUmVxdWVzdC9yZXNwb25zZVR5cGVcclxuICAgICAgICAgICAgLy8gQmxvYiByZXF1aXJlcyBhbiBvYmplY3QgdXJsXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3BvbnNlVHlwZSA9PT0gJ2Jsb2InKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChkYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBSZXNvdXJjZTtcclxuICAgIH0oQ2xhc3NfMi5DbGFzcykpO1xyXG4gICAgZXhwb3J0cy5SZXNvdXJjZSA9IFJlc291cmNlO1xyXG59KTtcclxuZGVmaW5lKFwiUmVzb3VyY2VzL1RleHR1cmVcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJSZXNvdXJjZXMvUmVzb3VyY2VcIiwgXCJQcm9taXNlc1wiLCBcIkRyYXdpbmcvU3ByaXRlXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgUmVzb3VyY2VfMSwgUHJvbWlzZXNfNCwgU3ByaXRlXzEpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgW1tUZXh0dXJlXV0gb2JqZWN0IGFsbG93cyBnYW1lcyBidWlsdCBpbiBFeGNhbGlidXIgdG8gbG9hZCBpbWFnZSByZXNvdXJjZXMuXHJcbiAgICAgKiBbW1RleHR1cmVdXSBpcyBhbiBbW0lMb2FkYWJsZV1dIHdoaWNoIG1lYW5zIGl0IGNhbiBiZSBwYXNzZWQgdG8gYSBbW0xvYWRlcl1dXHJcbiAgICAgKiB0byBwcmUtbG9hZCBiZWZvcmUgc3RhcnRpbmcgYSBsZXZlbCBvciBnYW1lLlxyXG4gICAgICpcclxuICAgICAqIFtbaW5jbHVkZTpUZXh0dXJlcy5tZF1dXHJcbiAgICAgKi9cclxuICAgIHZhciBUZXh0dXJlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoVGV4dHVyZSwgX3N1cGVyKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gcGF0aCAgICAgICBQYXRoIHRvIHRoZSBpbWFnZSByZXNvdXJjZVxyXG4gICAgICAgICAqIEBwYXJhbSBidXN0Q2FjaGUgIE9wdGlvbmFsbHkgbG9hZCB0ZXh0dXJlIHdpdGggY2FjaGUgYnVzdGluZ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIFRleHR1cmUocGF0aCwgYnVzdENhY2hlKSB7XHJcbiAgICAgICAgICAgIGlmIChidXN0Q2FjaGUgPT09IHZvaWQgMCkgeyBidXN0Q2FjaGUgPSB0cnVlOyB9XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHBhdGgsICdibG9iJywgYnVzdENhY2hlKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5wYXRoID0gcGF0aDtcclxuICAgICAgICAgICAgX3RoaXMuYnVzdENhY2hlID0gYnVzdENhY2hlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBbW1Byb21pc2VdXSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIFRleHR1cmUgaXMgbG9hZGVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMubG9hZGVkID0gbmV3IFByb21pc2VzXzQuUHJvbWlzZSgpO1xyXG4gICAgICAgICAgICBfdGhpcy5faXNMb2FkZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgX3RoaXMuX3Nwcml0ZSA9IG51bGw7XHJcbiAgICAgICAgICAgIF90aGlzLl9zcHJpdGUgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKF90aGlzLCAwLCAwLCAwLCAwKTtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIFRleHR1cmUgaXMgY29tcGxldGVseSBsb2FkZWQgYW5kIGlzIHJlYWR5XHJcbiAgICAgICAgICogdG8gYmUgZHJhd24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVGV4dHVyZS5wcm90b3R5cGUuaXNMb2FkZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc0xvYWRlZDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJlZ2lucyBsb2FkaW5nIHRoZSB0ZXh0dXJlIGFuZCByZXR1cm5zIGEgcHJvbWlzZSB0byBiZSByZXNvbHZlZCBvbiBjb21wbGV0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVGV4dHVyZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGNvbXBsZXRlID0gbmV3IFByb21pc2VzXzQuUHJvbWlzZSgpO1xyXG4gICAgICAgICAgICB2YXIgbG9hZGVkID0gX3N1cGVyLnByb3RvdHlwZS5sb2FkLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgIGxvYWRlZC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmltYWdlID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5pbWFnZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9pc0xvYWRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMud2lkdGggPSBfdGhpcy5fc3ByaXRlLnN3aWR0aCA9IF90aGlzLl9zcHJpdGUubmF0dXJhbFdpZHRoID0gX3RoaXMuX3Nwcml0ZS53aWR0aCA9IF90aGlzLmltYWdlLm5hdHVyYWxXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5oZWlnaHQgPSBfdGhpcy5fc3ByaXRlLnNoZWlnaHQgPSBfdGhpcy5fc3ByaXRlLm5hdHVyYWxIZWlnaHQgPSBfdGhpcy5fc3ByaXRlLmhlaWdodCA9IF90aGlzLmltYWdlLm5hdHVyYWxIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9hZGVkLnJlc29sdmUoX3RoaXMuaW1hZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlLnJlc29sdmUoX3RoaXMuaW1hZ2UpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5pbWFnZS5zcmMgPSBfc3VwZXIucHJvdG90eXBlLmdldERhdGEuY2FsbChfdGhpcyk7XHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlLnJlamVjdCgnRXJyb3IgbG9hZGluZyB0ZXh0dXJlLicpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVGV4dHVyZS5wcm90b3R5cGUuYXNTcHJpdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zcHJpdGU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gVGV4dHVyZTtcclxuICAgIH0oUmVzb3VyY2VfMS5SZXNvdXJjZSkpO1xyXG4gICAgZXhwb3J0cy5UZXh0dXJlID0gVGV4dHVyZTtcclxufSk7XHJcbmRlZmluZShcIkRyYXdpbmcvU3ByaXRlXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiRHJhd2luZy9TcHJpdGVFZmZlY3RzXCIsIFwiRHJhd2luZy9Db2xvclwiLCBcIlJlc291cmNlcy9UZXh0dXJlXCIsIFwiQWxnZWJyYVwiLCBcIlV0aWwvTG9nXCIsIFwiVXRpbC9VdGlsXCIsIFwiQ29uZmlndXJhYmxlXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgRWZmZWN0cywgQ29sb3JfOSwgVGV4dHVyZV8xLCBBbGdlYnJhXzExLCBMb2dfMywgVXRpbF8yLCBDb25maWd1cmFibGVfMSkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEBoaWRkZW5cclxuICAgICAqL1xyXG4gICAgdmFyIFNwcml0ZUltcGwgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBpbWFnZSAgIFRoZSBiYWNraW5nIGltYWdlIHRleHR1cmUgdG8gYnVpbGQgdGhlIFNwcml0ZVxyXG4gICAgICAgICAqIEBwYXJhbSBzeCAgICAgIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBzcHJpdGVcclxuICAgICAgICAgKiBAcGFyYW0gc3kgICAgICBUaGUgeSBwb3NpdGlvbiBvZiB0aGUgc3ByaXRlXHJcbiAgICAgICAgICogQHBhcmFtIHN3aWR0aCAgVGhlIHdpZHRoIG9mIHRoZSBzcHJpdGUgaW4gcGl4ZWxzXHJcbiAgICAgICAgICogQHBhcmFtIHNoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgc3ByaXRlIGluIHBpeGVsc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIFNwcml0ZUltcGwoaW1hZ2VPckNvbmZpZywgc3gsIHN5LCBzd2lkdGgsIHNoZWlnaHQpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbiA9IDAuMDtcclxuICAgICAgICAgICAgdGhpcy5hbmNob3IgPSBuZXcgQWxnZWJyYV8xMS5WZWN0b3IoMC4wLCAwLjApO1xyXG4gICAgICAgICAgICB0aGlzLnNjYWxlID0gbmV3IEFsZ2VicmFfMTEuVmVjdG9yKDEsIDEpO1xyXG4gICAgICAgICAgICB0aGlzLmxvZ2dlciA9IExvZ18zLkxvZ2dlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRHJhd3MgdGhlIHNwcml0ZSBmbGlwcGVkIHZlcnRpY2FsbHlcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuZmxpcFZlcnRpY2FsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBEcmF3cyB0aGUgc3ByaXRlIGZsaXBwZWQgaG9yaXpvbnRhbGx5XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmZsaXBIb3Jpem9udGFsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuZWZmZWN0cyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLnN4ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5zeSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuc3dpZHRoID0gMDtcclxuICAgICAgICAgICAgdGhpcy5zaGVpZ2h0ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5uYXR1cmFsV2lkdGggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLm5hdHVyYWxIZWlnaHQgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9zcHJpdGVDYW52YXMgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl9zcHJpdGVDdHggPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl9waXhlbERhdGEgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl9waXhlbHNMb2FkZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fZGlydHlFZmZlY3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKHN4IDwgMCB8fCBzeSA8IDAgfHwgc3dpZHRoIDwgMCB8fCBzaGVpZ2h0IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ1Nwcml0ZSBjYW5ub3QgaGF2ZSBhbnkgbmVnYXRpdmUgZGltZW5zaW9ucyB4OicsIHN4LCAneTonLCBzeSwgJ3dpZHRoOicsIHN3aWR0aCwgJ2hlaWdodDonLCBzaGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaW1hZ2UgPSBpbWFnZU9yQ29uZmlnO1xyXG4gICAgICAgICAgICBpZiAoaW1hZ2VPckNvbmZpZyAmJiAhKGltYWdlT3JDb25maWcgaW5zdGFuY2VvZiBUZXh0dXJlXzEuVGV4dHVyZSkpIHtcclxuICAgICAgICAgICAgICAgIHN4ID0gaW1hZ2VPckNvbmZpZy5zeDtcclxuICAgICAgICAgICAgICAgIHN5ID0gaW1hZ2VPckNvbmZpZy5zeTtcclxuICAgICAgICAgICAgICAgIHN3aWR0aCA9IGltYWdlT3JDb25maWcuc3dpZHRoO1xyXG4gICAgICAgICAgICAgICAgc2hlaWdodCA9IGltYWdlT3JDb25maWcuc2hlaWdodDtcclxuICAgICAgICAgICAgICAgIGltYWdlID0gaW1hZ2VPckNvbmZpZy5pbWFnZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnN4ID0gc3ggfHwgMDtcclxuICAgICAgICAgICAgdGhpcy5zeSA9IHN5IHx8IDA7XHJcbiAgICAgICAgICAgIHRoaXMuc3dpZHRoID0gc3dpZHRoIHx8IDA7XHJcbiAgICAgICAgICAgIHRoaXMuc2hlaWdodCA9IHNoZWlnaHQgfHwgMDtcclxuICAgICAgICAgICAgdGhpcy5fdGV4dHVyZSA9IGltYWdlO1xyXG4gICAgICAgICAgICB0aGlzLl9zcHJpdGVDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICAgICAgdGhpcy5fc3ByaXRlQ2FudmFzLndpZHRoID0gc3dpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLl9zcHJpdGVDYW52YXMuaGVpZ2h0ID0gc2hlaWdodDtcclxuICAgICAgICAgICAgdGhpcy5fc3ByaXRlQ3R4ID0gdGhpcy5fc3ByaXRlQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgICAgIHRoaXMuX3RleHR1cmUubG9hZGVkLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3Nwcml0ZUNhbnZhcy53aWR0aCA9IF90aGlzLl9zcHJpdGVDYW52YXMud2lkdGggfHwgX3RoaXMuX3RleHR1cmUuaW1hZ2UubmF0dXJhbFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3Nwcml0ZUNhbnZhcy5oZWlnaHQgPSBfdGhpcy5fc3ByaXRlQ2FudmFzLmhlaWdodCB8fCBfdGhpcy5fdGV4dHVyZS5pbWFnZS5uYXR1cmFsSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvYWRQaXhlbHMoKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9kaXJ0eUVmZmVjdCA9IHRydWU7XHJcbiAgICAgICAgICAgIH0pLmVycm9yKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgdGV4dHVyZSAnLCBfdGhpcy5fdGV4dHVyZS5wYXRoLCBlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSBzd2lkdGg7XHJcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gc2hlaWdodDtcclxuICAgICAgICAgICAgdGhpcy5uYXR1cmFsV2lkdGggPSBzd2lkdGg7XHJcbiAgICAgICAgICAgIHRoaXMubmF0dXJhbEhlaWdodCA9IHNoZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFNwcml0ZUltcGwucHJvdG90eXBlLl9sb2FkUGl4ZWxzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fdGV4dHVyZS5pc0xvYWRlZCgpICYmICF0aGlzLl9waXhlbHNMb2FkZWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBuYXR1cmFsV2lkdGggPSB0aGlzLl90ZXh0dXJlLmltYWdlLm5hdHVyYWxXaWR0aCB8fCAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5hdHVyYWxIZWlnaHQgPSB0aGlzLl90ZXh0dXJlLmltYWdlLm5hdHVyYWxIZWlnaHQgfHwgMDtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN3aWR0aCA+IG5hdHVyYWxXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ1RoZSBzcHJpdGUgd2lkdGgnLCB0aGlzLnN3aWR0aCwgJ2V4Y2VlZHMgdGhlIHdpZHRoJywgbmF0dXJhbFdpZHRoLCAnb2YgdGhlIGJhY2tpbmcgdGV4dHVyZScsIHRoaXMuX3RleHR1cmUucGF0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaGVpZ2h0ID4gbmF0dXJhbEhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ1RoZSBzcHJpdGUgaGVpZ2h0JywgdGhpcy5zaGVpZ2h0LCAnZXhjZWVkcyB0aGUgaGVpZ2h0JywgbmF0dXJhbEhlaWdodCwgJ29mIHRoZSBiYWNraW5nIHRleHR1cmUnLCB0aGlzLl90ZXh0dXJlLnBhdGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3ByaXRlQ3R4LmRyYXdJbWFnZSh0aGlzLl90ZXh0dXJlLmltYWdlLCBVdGlsXzIuY2xhbXAodGhpcy5zeCwgMCwgbmF0dXJhbFdpZHRoKSwgVXRpbF8yLmNsYW1wKHRoaXMuc3ksIDAsIG5hdHVyYWxIZWlnaHQpLCBVdGlsXzIuY2xhbXAodGhpcy5zd2lkdGgsIDAsIG5hdHVyYWxXaWR0aCksIFV0aWxfMi5jbGFtcCh0aGlzLnNoZWlnaHQsIDAsIG5hdHVyYWxIZWlnaHQpLCAwLCAwLCB0aGlzLnN3aWR0aCwgdGhpcy5zaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BpeGVsc0xvYWRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFwcGxpZXMgdGhlIFtbT3BhY2l0eV1dIGVmZmVjdCB0byBhIHNwcml0ZSwgc2V0dGluZyB0aGUgYWxwaGEgb2YgYWxsIHBpeGVscyB0byBhIGdpdmVuIHZhbHVlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU3ByaXRlSW1wbC5wcm90b3R5cGUub3BhY2l0eSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZEVmZmVjdChuZXcgRWZmZWN0cy5PcGFjaXR5KHZhbHVlKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcHBsaWVzIHRoZSBbW0dyYXlzY2FsZV1dIGVmZmVjdCB0byBhIHNwcml0ZSwgcmVtb3ZpbmcgY29sb3IgaW5mb3JtYXRpb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU3ByaXRlSW1wbC5wcm90b3R5cGUuZ3JheXNjYWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZEVmZmVjdChuZXcgRWZmZWN0cy5HcmF5c2NhbGUoKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcHBsaWVzIHRoZSBbW0ludmVydF1dIGVmZmVjdCB0byBhIHNwcml0ZSwgaW52ZXJ0aW5nIHRoZSBwaXhlbCBjb2xvcnMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU3ByaXRlSW1wbC5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZEVmZmVjdChuZXcgRWZmZWN0cy5JbnZlcnQoKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcHBsaWVzIHRoZSBbW0ZpbGxdXSBlZmZlY3QgdG8gYSBzcHJpdGUsIGNoYW5naW5nIHRoZSBjb2xvciBjaGFubmVscyBvZiBhbGwgbm9uLXRyYW5zcGFyZW50IHBpeGVscyB0byBtYXRjaCBhIGdpdmVuIGNvbG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU3ByaXRlSW1wbC5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIChjb2xvcikge1xyXG4gICAgICAgICAgICB0aGlzLmFkZEVmZmVjdChuZXcgRWZmZWN0cy5GaWxsKGNvbG9yKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcHBsaWVzIHRoZSBbW0NvbG9yaXplXV0gZWZmZWN0IHRvIGEgc3ByaXRlLCBjaGFuZ2luZyB0aGUgY29sb3IgY2hhbm5lbHMgb2YgYWxsIHBpeGVscyB0byBiZSB0aGUgYXZlcmFnZSBvZiB0aGUgb3JpZ2luYWwgY29sb3JcclxuICAgICAgICAgKiBhbmQgdGhlIHByb3ZpZGVkIGNvbG9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNwcml0ZUltcGwucHJvdG90eXBlLmNvbG9yaXplID0gZnVuY3Rpb24gKGNvbG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRWZmZWN0KG5ldyBFZmZlY3RzLkNvbG9yaXplKGNvbG9yKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcHBsaWVzIHRoZSBbW0xpZ2h0ZW5dXSBlZmZlY3QgdG8gYSBzcHJpdGUsIGNoYW5nZXMgdGhlIGxpZ2h0bmVzcyBvZiB0aGUgY29sb3IgYWNjb3JkaW5nIHRvIEhTTFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNwcml0ZUltcGwucHJvdG90eXBlLmxpZ2h0ZW4gPSBmdW5jdGlvbiAoZmFjdG9yKSB7XHJcbiAgICAgICAgICAgIGlmIChmYWN0b3IgPT09IHZvaWQgMCkgeyBmYWN0b3IgPSAwLjE7IH1cclxuICAgICAgICAgICAgdGhpcy5hZGRFZmZlY3QobmV3IEVmZmVjdHMuTGlnaHRlbihmYWN0b3IpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFwcGxpZXMgdGhlIFtbRGFya2VuXV0gZWZmZWN0IHRvIGEgc3ByaXRlLCBjaGFuZ2VzIHRoZSBkYXJrbmVzcyBvZiB0aGUgY29sb3IgYWNjb3JkaW5nIHRvIEhTTFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNwcml0ZUltcGwucHJvdG90eXBlLmRhcmtlbiA9IGZ1bmN0aW9uIChmYWN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKGZhY3RvciA9PT0gdm9pZCAwKSB7IGZhY3RvciA9IDAuMTsgfVxyXG4gICAgICAgICAgICB0aGlzLmFkZEVmZmVjdChuZXcgRWZmZWN0cy5EYXJrZW4oZmFjdG9yKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcHBsaWVzIHRoZSBbW1NhdHVyYXRlXV0gZWZmZWN0IHRvIGEgc3ByaXRlLCBzYXR1cmF0ZXMgdGhlIGNvbG9yIGFjY29yZGluZyB0byBIU0xcclxuICAgICAgICAgKi9cclxuICAgICAgICBTcHJpdGVJbXBsLnByb3RvdHlwZS5zYXR1cmF0ZSA9IGZ1bmN0aW9uIChmYWN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKGZhY3RvciA9PT0gdm9pZCAwKSB7IGZhY3RvciA9IDAuMTsgfVxyXG4gICAgICAgICAgICB0aGlzLmFkZEVmZmVjdChuZXcgRWZmZWN0cy5TYXR1cmF0ZShmYWN0b3IpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFwcGxpZXMgdGhlIFtbRGVzYXR1cmF0ZV1dIGVmZmVjdCB0byBhIHNwcml0ZSwgZGVzYXR1cmF0ZXMgdGhlIGNvbG9yIGFjY29yZGluZyB0byBIU0xcclxuICAgICAgICAgKi9cclxuICAgICAgICBTcHJpdGVJbXBsLnByb3RvdHlwZS5kZXNhdHVyYXRlID0gZnVuY3Rpb24gKGZhY3Rvcikge1xyXG4gICAgICAgICAgICBpZiAoZmFjdG9yID09PSB2b2lkIDApIHsgZmFjdG9yID0gMC4xOyB9XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRWZmZWN0KG5ldyBFZmZlY3RzLkRlc2F0dXJhdGUoZmFjdG9yKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgbmV3IFtbSVNwcml0ZUVmZmVjdF1dIHRvIHRoaXMgZHJhd2luZy5cclxuICAgICAgICAgKiBAcGFyYW0gZWZmZWN0ICBFZmZlY3QgdG8gYWRkIHRvIHRoZSB0aGlzIGRyYXdpbmdcclxuICAgICAgICAgKi9cclxuICAgICAgICBTcHJpdGVJbXBsLnByb3RvdHlwZS5hZGRFZmZlY3QgPSBmdW5jdGlvbiAoZWZmZWN0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWZmZWN0cy5wdXNoKGVmZmVjdCk7XHJcbiAgICAgICAgICAgIC8vIFdlIG11c3QgY2hlY2sgaWYgdGhlIHRleHR1cmUgYW5kIHRoZSBiYWNraW5nIHNwcml0ZSBwaXhlbHMgYXJlIGxvYWRlZCBhcyB3ZWxsIGJlZm9yZSBcclxuICAgICAgICAgICAgLy8gYW4gZWZmZWN0IGNhbiBiZSBhcHBsaWVkXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fdGV4dHVyZS5pc0xvYWRlZCgpIHx8ICF0aGlzLl9waXhlbHNMb2FkZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RpcnR5RWZmZWN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5RWZmZWN0cygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTcHJpdGVJbXBsLnByb3RvdHlwZS5yZW1vdmVFZmZlY3QgPSBmdW5jdGlvbiAocGFyYW0pIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4VG9SZW1vdmUgPSAtMTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJhbSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgIGluZGV4VG9SZW1vdmUgPSBwYXJhbTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGluZGV4VG9SZW1vdmUgPSB0aGlzLmVmZmVjdHMuaW5kZXhPZihwYXJhbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gYm91bmRzIGNoZWNrXHJcbiAgICAgICAgICAgIGlmIChpbmRleFRvUmVtb3ZlIDwgMCB8fCBpbmRleFRvUmVtb3ZlID49IHRoaXMuZWZmZWN0cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmVmZmVjdHMuc3BsaWNlKGluZGV4VG9SZW1vdmUsIDEpO1xyXG4gICAgICAgICAgICAvLyBXZSBtdXN0IGNoZWNrIGlmIHRoZSB0ZXh0dXJlIGFuZCB0aGUgYmFja2luZyBzcHJpdGUgcGl4ZWxzIGFyZSBsb2FkZWQgYXMgd2VsbCBiZWZvcmUgXHJcbiAgICAgICAgICAgIC8vIGFuIGVmZmVjdCBjYW4gYmUgYXBwbGllZFxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RleHR1cmUuaXNMb2FkZWQoKSB8fCAhdGhpcy5fcGl4ZWxzTG9hZGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXJ0eUVmZmVjdCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hcHBseUVmZmVjdHMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgU3ByaXRlSW1wbC5wcm90b3R5cGUuX2FwcGx5RWZmZWN0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG5hdHVyYWxXaWR0aCA9IHRoaXMuX3RleHR1cmUuaW1hZ2UubmF0dXJhbFdpZHRoIHx8IDA7XHJcbiAgICAgICAgICAgIHZhciBuYXR1cmFsSGVpZ2h0ID0gdGhpcy5fdGV4dHVyZS5pbWFnZS5uYXR1cmFsSGVpZ2h0IHx8IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3Nwcml0ZUN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5zd2lkdGgsIHRoaXMuc2hlaWdodCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Nwcml0ZUN0eC5kcmF3SW1hZ2UodGhpcy5fdGV4dHVyZS5pbWFnZSwgVXRpbF8yLmNsYW1wKHRoaXMuc3gsIDAsIG5hdHVyYWxXaWR0aCksIFV0aWxfMi5jbGFtcCh0aGlzLnN5LCAwLCBuYXR1cmFsSGVpZ2h0KSwgVXRpbF8yLmNsYW1wKHRoaXMuc3dpZHRoLCAwLCBuYXR1cmFsV2lkdGgpLCBVdGlsXzIuY2xhbXAodGhpcy5zaGVpZ2h0LCAwLCBuYXR1cmFsSGVpZ2h0KSwgMCwgMCwgdGhpcy5zd2lkdGgsIHRoaXMuc2hlaWdodCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3BpeGVsRGF0YSA9IHRoaXMuX3Nwcml0ZUN0eC5nZXRJbWFnZURhdGEoMCwgMCwgdGhpcy5zd2lkdGgsIHRoaXMuc2hlaWdodCk7XHJcbiAgICAgICAgICAgIHZhciBpID0gMCwgeCA9IDAsIHkgPSAwLCBsZW4gPSB0aGlzLmVmZmVjdHMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgeSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHk7IHkgPCB0aGlzLnNoZWlnaHQ7IHkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoeDsgeCA8IHRoaXMuc3dpZHRoOyB4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lZmZlY3RzW2ldLnVwZGF0ZVBpeGVsKHgsIHksIHRoaXMuX3BpeGVsRGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3Nwcml0ZUN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5zd2lkdGgsIHRoaXMuc2hlaWdodCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Nwcml0ZUN0eC5wdXRJbWFnZURhdGEodGhpcy5fcGl4ZWxEYXRhLCAwLCAwKTtcclxuICAgICAgICAgICAgdGhpcy5fZGlydHlFZmZlY3QgPSBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENsZWFycyBhbGwgZWZmZWN0cyBmcm9tIHRoZSBkcmF3aW5nIGFuZCByZXR1cm4gaXQgdG8gaXRzIG9yaWdpbmFsIHN0YXRlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNwcml0ZUltcGwucHJvdG90eXBlLmNsZWFyRWZmZWN0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5lZmZlY3RzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5RWZmZWN0cygpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVzZXRzIHRoZSBpbnRlcm5hbCBzdGF0ZSBvZiB0aGUgZHJhd2luZyAoaWYgYW55KVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNwcml0ZUltcGwucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBkbyBub3RoaW5nXHJcbiAgICAgICAgfTtcclxuICAgICAgICBTcHJpdGVJbXBsLnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY3R4LCB4LCB5KSB7XHJcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoeCwgeSk7XHJcbiAgICAgICAgICAgIGN0eC5yb3RhdGUodGhpcy5yb3RhdGlvbik7XHJcbiAgICAgICAgICAgIHZhciBzY2FsZWRTV2lkdGggPSB0aGlzLndpZHRoICogdGhpcy5zY2FsZS54O1xyXG4gICAgICAgICAgICB2YXIgc2NhbGVkU0hlaWdodCA9IHRoaXMuaGVpZ2h0ICogdGhpcy5zY2FsZS55O1xyXG4gICAgICAgICAgICB2YXIgeHBvaW50ID0gKHNjYWxlZFNXaWR0aCkgKiB0aGlzLmFuY2hvci54O1xyXG4gICAgICAgICAgICB2YXIgeXBvaW50ID0gKHNjYWxlZFNIZWlnaHQpICogdGhpcy5hbmNob3IueTtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gQ29sb3JfOS5Db2xvci5CbGFjay50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlUmVjdCgteHBvaW50LCAteXBvaW50LCBzY2FsZWRTV2lkdGgsIHNjYWxlZFNIZWlnaHQpO1xyXG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRHJhd3MgdGhlIHNwcml0ZSBhcHByb3ByaWF0ZWx5IHRvIHRoZSAyRCByZW5kZXJpbmcgY29udGV4dCwgYXQgYW4geCBhbmQgeSBjb29yZGluYXRlLlxyXG4gICAgICAgICAqIEBwYXJhbSBjdHggIFRoZSAyRCByZW5kZXJpbmcgY29udGV4dFxyXG4gICAgICAgICAqIEBwYXJhbSB4ICAgIFRoZSB4IGNvb3JkaW5hdGUgb2Ygd2hlcmUgdG8gZHJhd1xyXG4gICAgICAgICAqIEBwYXJhbSB5ICAgIFRoZSB5IGNvb3JkaW5hdGUgb2Ygd2hlcmUgdG8gZHJhd1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNwcml0ZUltcGwucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoY3R4LCB4LCB5KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9kaXJ0eUVmZmVjdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYXBwbHlFZmZlY3RzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gY2FsY3VsYXRpbmcgY3VycmVudCBkaW1lbnNpb25zXHJcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSB0aGlzLm5hdHVyYWxXaWR0aCAqIHRoaXMuc2NhbGUueDtcclxuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLm5hdHVyYWxIZWlnaHQgKiB0aGlzLnNjYWxlLnk7XHJcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgIHZhciB4cG9pbnQgPSB0aGlzLndpZHRoICogdGhpcy5hbmNob3IueDtcclxuICAgICAgICAgICAgdmFyIHlwb2ludCA9IHRoaXMuaGVpZ2h0ICogdGhpcy5hbmNob3IueTtcclxuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcclxuICAgICAgICAgICAgY3R4LnJvdGF0ZSh0aGlzLnJvdGF0aW9uKTtcclxuICAgICAgICAgICAgdmFyIHNjYWxlZFNXaWR0aCA9IHRoaXMuc3dpZHRoICogdGhpcy5zY2FsZS54O1xyXG4gICAgICAgICAgICB2YXIgc2NhbGVkU0hlaWdodCA9IHRoaXMuc2hlaWdodCAqIHRoaXMuc2NhbGUueTtcclxuICAgICAgICAgICAgLy8gdG9kbyBjYWNoZSBmbGlwcGVkIHNwcml0ZXNcclxuICAgICAgICAgICAgaWYgKHRoaXMuZmxpcEhvcml6b250YWwpIHtcclxuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoc2NhbGVkU1dpZHRoLCAwKTtcclxuICAgICAgICAgICAgICAgIGN0eC5zY2FsZSgtMSwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuZmxpcFZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKDAsIHNjYWxlZFNIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgY3R4LnNjYWxlKDEsIC0xKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMuX3Nwcml0ZUNhbnZhcywgMCwgMCwgdGhpcy5zd2lkdGgsIHRoaXMuc2hlaWdodCwgLXhwb2ludCwgLXlwb2ludCwgc2NhbGVkU1dpZHRoLCBzY2FsZWRTSGVpZ2h0KTtcclxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByb2R1Y2VzIGEgY29weSBvZiB0aGUgY3VycmVudCBzcHJpdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBTcHJpdGVJbXBsLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBTcHJpdGUodGhpcy5fdGV4dHVyZSwgdGhpcy5zeCwgdGhpcy5zeSwgdGhpcy5zd2lkdGgsIHRoaXMuc2hlaWdodCk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5zY2FsZSA9IHRoaXMuc2NhbGUuY2xvbmUoKTtcclxuICAgICAgICAgICAgcmVzdWx0LnJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbjtcclxuICAgICAgICAgICAgcmVzdWx0LmZsaXBIb3Jpem9udGFsID0gdGhpcy5mbGlwSG9yaXpvbnRhbDtcclxuICAgICAgICAgICAgcmVzdWx0LmZsaXBWZXJ0aWNhbCA9IHRoaXMuZmxpcFZlcnRpY2FsO1xyXG4gICAgICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IHRoaXMuZWZmZWN0cy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuYWRkRWZmZWN0KHRoaXMuZWZmZWN0c1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBTcHJpdGVJbXBsO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuU3ByaXRlSW1wbCA9IFNwcml0ZUltcGw7XHJcbiAgICAvKipcclxuICAgICAqIEEgW1tTcHJpdGVdXSBpcyBvbmUgb2YgdGhlIG1haW4gZHJhd2luZyBwcmltaXRpdmVzLiBJdCBpcyByZXNwb25zaWJsZSBmb3IgZHJhd2luZ1xyXG4gICAgICogaW1hZ2VzIG9yIHBhcnRzIG9mIGltYWdlcyBmcm9tIGEgW1tUZXh0dXJlXV0gcmVzb3VyY2UgdG8gdGhlIHNjcmVlbi5cclxuICAgICAqXHJcbiAgICAgKiBbW2luY2x1ZGU6U3ByaXRlcy5tZF1dXHJcbiAgICAgKi9cclxuICAgIHZhciBTcHJpdGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhTcHJpdGUsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gU3ByaXRlKGltYWdlT3JDb25maWcsIHN4LCBzeSwgc3dpZHRoLCBzaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBpbWFnZU9yQ29uZmlnLCBzeCwgc3ksIHN3aWR0aCwgc2hlaWdodCkgfHwgdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFNwcml0ZTtcclxuICAgIH0oQ29uZmlndXJhYmxlXzEuQ29uZmlndXJhYmxlKFNwcml0ZUltcGwpKSk7XHJcbiAgICBleHBvcnRzLlNwcml0ZSA9IFNwcml0ZTtcclxufSk7XHJcbmRlZmluZShcIkRyYXdpbmcvQW5pbWF0aW9uXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiRHJhd2luZy9TcHJpdGVFZmZlY3RzXCIsIFwiQWxnZWJyYVwiLCBcIkVuZ2luZVwiLCBcIlV0aWwvVXRpbFwiLCBcIkNvbmZpZ3VyYWJsZVwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIEVmZmVjdHMsIEFsZ2VicmFfMTIsIEVuZ2luZV8xLCBVdGlsLCBDb25maWd1cmFibGVfMikge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEBoaWRkZW5cclxuICAgICAqL1xyXG4gICAgdmFyIEFuaW1hdGlvbkltcGwgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFR5cGljYWxseSB5b3Ugd2lsbCB1c2UgYSBbW1Nwcml0ZVNoZWV0XV0gdG8gZ2VuZXJhdGUgYW4gW1tBbmltYXRpb25dXS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBlbmdpbmUgIFJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBnYW1lIGVuZ2luZVxyXG4gICAgICAgICAqIEBwYXJhbSBpbWFnZXMgIEFuIGFycmF5IG9mIHNwcml0ZXMgdG8gY3JlYXRlIHRoZSBmcmFtZXMgZm9yIHRoZSBhbmltYXRpb25cclxuICAgICAgICAgKiBAcGFyYW0gc3BlZWQgICBUaGUgbnVtYmVyIGluIG1pbGxpc2Vjb25kcyB0byBkaXNwbGF5IGVhY2ggZnJhbWUgaW4gdGhlIGFuaW1hdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSBsb29wICAgIEluZGljYXRlcyB3aGV0aGVyIHRoZSBhbmltYXRpb24gc2hvdWxkIGxvb3AgYWZ0ZXIgaXQgaXMgY29tcGxldGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uSW1wbChlbmdpbmVPckNvbmZpZywgc3ByaXRlcywgc3BlZWQsIGxvb3ApIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBzcHJpdGUgZnJhbWVzIHRvIHBsYXksIGluIG9yZGVyLiBTZWUgW1tTcHJpdGVTaGVldC5nZXRBbmltYXRpb25Gb3JBbGxdXSB0byBxdWlja2x5XHJcbiAgICAgICAgICAgICAqIGdlbmVyYXRlIGFuIFtbQW5pbWF0aW9uXV0uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZXMgPSBbXTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEN1cnJlbnQgZnJhbWUgaW5kZXggYmVpbmcgc2hvd25cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEZyYW1lID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fb2xkVGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIHRoaXMuYW5jaG9yID0gbmV3IEFsZ2VicmFfMTIuVmVjdG9yKDAuMCwgMC4wKTtcclxuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbiA9IDAuMDtcclxuICAgICAgICAgICAgdGhpcy5zY2FsZSA9IG5ldyBBbGdlYnJhXzEyLlZlY3RvcigxLCAxKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBhbmltYXRpb24gc2hvdWxkIGxvb3AgYWZ0ZXIgaXQgaXMgY29tcGxldGVkXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmxvb3AgPSB0cnVlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW5kaWNhdGVzIHRoZSBmcmFtZSBpbmRleCB0aGUgYW5pbWF0aW9uIHNob3VsZCBmcmVlemUgb24gZm9yIGEgbm9uLWxvb3BpbmdcclxuICAgICAgICAgICAgICogYW5pbWF0aW9uLiBCeSBkZWZhdWx0IGl0IGlzIHRoZSBsYXN0IGZyYW1lLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5mcmVlemVGcmFtZSA9IC0xO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRmxpcCBlYWNoIGZyYW1lIHZlcnRpY2FsbHkuIFNldHMgW1tTcHJpdGUuZmxpcFZlcnRpY2FsXV0uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmZsaXBWZXJ0aWNhbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRmxpcCBlYWNoIGZyYW1lIGhvcml6b250YWxseS4gU2V0cyBbW1Nwcml0ZS5mbGlwSG9yaXpvbnRhbF1dLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5mbGlwSG9yaXpvbnRhbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gMDtcclxuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLm5hdHVyYWxXaWR0aCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMubmF0dXJhbEhlaWdodCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBlbmdpbmUgPSBlbmdpbmVPckNvbmZpZztcclxuICAgICAgICAgICAgaWYgKGVuZ2luZU9yQ29uZmlnICYmICEoZW5naW5lT3JDb25maWcgaW5zdGFuY2VvZiBFbmdpbmVfMS5FbmdpbmUpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29uZmlnID0gZW5naW5lT3JDb25maWc7XHJcbiAgICAgICAgICAgICAgICBlbmdpbmUgPSBjb25maWcuZW5naW5lO1xyXG4gICAgICAgICAgICAgICAgc3ByaXRlcyA9IGNvbmZpZy5zcHJpdGVzO1xyXG4gICAgICAgICAgICAgICAgc3BlZWQgPSBjb25maWcuc3BlZWQ7XHJcbiAgICAgICAgICAgICAgICBsb29wID0gY29uZmlnLmxvb3A7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zcHJpdGVzID0gc3ByaXRlcztcclxuICAgICAgICAgICAgdGhpcy5zcGVlZCA9IHNwZWVkO1xyXG4gICAgICAgICAgICB0aGlzLl9lbmdpbmUgPSBlbmdpbmU7XHJcbiAgICAgICAgICAgIGlmIChsb29wICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9vcCA9IGxvb3A7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHNwcml0ZXMgJiYgc3ByaXRlc1swXSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBzcHJpdGVzWzBdID8gc3ByaXRlc1swXS5oZWlnaHQgOiAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IHNwcml0ZXNbMF0gPyBzcHJpdGVzWzBdLndpZHRoIDogMDtcclxuICAgICAgICAgICAgICAgIHRoaXMubmF0dXJhbFdpZHRoID0gc3ByaXRlc1swXSA/IHNwcml0ZXNbMF0ubmF0dXJhbFdpZHRoIDogMDtcclxuICAgICAgICAgICAgICAgIHRoaXMubmF0dXJhbEhlaWdodCA9IHNwcml0ZXNbMF0gPyBzcHJpdGVzWzBdLm5hdHVyYWxIZWlnaHQgOiAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcmVlemVGcmFtZSA9IHNwcml0ZXMubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcHBsaWVzIHRoZSBvcGFjaXR5IGVmZmVjdCB0byBhIHNwcml0ZSwgc2V0dGluZyB0aGUgYWxwaGEgb2YgYWxsIHBpeGVscyB0byBhIGdpdmVuIHZhbHVlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQW5pbWF0aW9uSW1wbC5wcm90b3R5cGUub3BhY2l0eSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZEVmZmVjdChuZXcgRWZmZWN0cy5PcGFjaXR5KHZhbHVlKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcHBsaWVzIHRoZSBncmF5c2NhbGUgZWZmZWN0IHRvIGEgc3ByaXRlLCByZW1vdmluZyBjb2xvciBpbmZvcm1hdGlvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBBbmltYXRpb25JbXBsLnByb3RvdHlwZS5ncmF5c2NhbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRWZmZWN0KG5ldyBFZmZlY3RzLkdyYXlzY2FsZSgpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFwcGxpZXMgdGhlIGludmVydCBlZmZlY3QgdG8gYSBzcHJpdGUsIGludmVydGluZyB0aGUgcGl4ZWwgY29sb3JzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFuaW1hdGlvbkltcGwucHJvdG90eXBlLmludmVydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRFZmZlY3QobmV3IEVmZmVjdHMuSW52ZXJ0KCkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXBwbGllcyB0aGUgZmlsbCBlZmZlY3QgdG8gYSBzcHJpdGUsIGNoYW5naW5nIHRoZSBjb2xvciBjaGFubmVscyBvZiBhbGwgbm9uLXRyYW5zcGFyZW50IHBpeGVscyB0byBtYXRjaCBhIGdpdmVuIGNvbG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQW5pbWF0aW9uSW1wbC5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIChjb2xvcikge1xyXG4gICAgICAgICAgICB0aGlzLmFkZEVmZmVjdChuZXcgRWZmZWN0cy5GaWxsKGNvbG9yKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcHBsaWVzIHRoZSBjb2xvcml6ZSBlZmZlY3QgdG8gYSBzcHJpdGUsIGNoYW5naW5nIHRoZSBjb2xvciBjaGFubmVscyBvZiBhbGwgcGl4ZWxzIHRvIGJlIHRoZSBhdmVyYWdlIG9mIHRoZSBvcmlnaW5hbCBjb2xvciBhbmQgdGhlXHJcbiAgICAgICAgICogcHJvdmlkZWQgY29sb3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQW5pbWF0aW9uSW1wbC5wcm90b3R5cGUuY29sb3JpemUgPSBmdW5jdGlvbiAoY29sb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRFZmZlY3QobmV3IEVmZmVjdHMuQ29sb3JpemUoY29sb3IpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFwcGxpZXMgdGhlIGxpZ2h0ZW4gZWZmZWN0IHRvIGEgc3ByaXRlLCBjaGFuZ2VzIHRoZSBsaWdodG5lc3Mgb2YgdGhlIGNvbG9yIGFjY29yZGluZyB0byBoc2xcclxuICAgICAgICAgKi9cclxuICAgICAgICBBbmltYXRpb25JbXBsLnByb3RvdHlwZS5saWdodGVuID0gZnVuY3Rpb24gKGZhY3Rvcikge1xyXG4gICAgICAgICAgICBpZiAoZmFjdG9yID09PSB2b2lkIDApIHsgZmFjdG9yID0gMC4xOyB9XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRWZmZWN0KG5ldyBFZmZlY3RzLkxpZ2h0ZW4oZmFjdG9yKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcHBsaWVzIHRoZSBkYXJrZW4gZWZmZWN0IHRvIGEgc3ByaXRlLCBjaGFuZ2VzIHRoZSBkYXJrbmVzcyBvZiB0aGUgY29sb3IgYWNjb3JkaW5nIHRvIGhzbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFuaW1hdGlvbkltcGwucHJvdG90eXBlLmRhcmtlbiA9IGZ1bmN0aW9uIChmYWN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKGZhY3RvciA9PT0gdm9pZCAwKSB7IGZhY3RvciA9IDAuMTsgfVxyXG4gICAgICAgICAgICB0aGlzLmFkZEVmZmVjdChuZXcgRWZmZWN0cy5EYXJrZW4oZmFjdG9yKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcHBsaWVzIHRoZSBzYXR1cmF0ZSBlZmZlY3QgdG8gYSBzcHJpdGUsIHNhdHVyYXRlcyB0aGUgY29sb3IgYWNjb3JkaW5nIHRvIGhzbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFuaW1hdGlvbkltcGwucHJvdG90eXBlLnNhdHVyYXRlID0gZnVuY3Rpb24gKGZhY3Rvcikge1xyXG4gICAgICAgICAgICBpZiAoZmFjdG9yID09PSB2b2lkIDApIHsgZmFjdG9yID0gMC4xOyB9XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRWZmZWN0KG5ldyBFZmZlY3RzLlNhdHVyYXRlKGZhY3RvcikpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXBwbGllcyB0aGUgZGVzYXR1cmF0ZSBlZmZlY3QgdG8gYSBzcHJpdGUsIGRlc2F0dXJhdGVzIHRoZSBjb2xvciBhY2NvcmRpbmcgdG8gaHNsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQW5pbWF0aW9uSW1wbC5wcm90b3R5cGUuZGVzYXR1cmF0ZSA9IGZ1bmN0aW9uIChmYWN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKGZhY3RvciA9PT0gdm9pZCAwKSB7IGZhY3RvciA9IDAuMTsgfVxyXG4gICAgICAgICAgICB0aGlzLmFkZEVmZmVjdChuZXcgRWZmZWN0cy5EZXNhdHVyYXRlKGZhY3RvcikpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkIGEgW1tJU3ByaXRlRWZmZWN0XV0gbWFudWFsbHlcclxuICAgICAgICAgKi9cclxuICAgICAgICBBbmltYXRpb25JbXBsLnByb3RvdHlwZS5hZGRFZmZlY3QgPSBmdW5jdGlvbiAoZWZmZWN0KSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5zcHJpdGVzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZXNbaV0uYWRkRWZmZWN0KGVmZmVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEFuaW1hdGlvbkltcGwucHJvdG90eXBlLnJlbW92ZUVmZmVjdCA9IGZ1bmN0aW9uIChwYXJhbSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuc3ByaXRlcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVzW2ldLnJlbW92ZUVmZmVjdChwYXJhbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENsZWFyIGFsbCBzcHJpdGUgZWZmZWN0c1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFuaW1hdGlvbkltcGwucHJvdG90eXBlLmNsZWFyRWZmZWN0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnNwcml0ZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlc1tpXS5jbGVhckVmZmVjdHMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgQW5pbWF0aW9uSW1wbC5wcm90b3R5cGUuX3NldEFuY2hvciA9IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gICAgICAgICAgICAvL2lmICghdGhpcy5hbmNob3IuZXF1YWxzKHBvaW50KSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuc3ByaXRlcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVzW2ldLmFuY2hvci5zZXRUbyhwb2ludC54LCBwb2ludC55KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL31cclxuICAgICAgICB9O1xyXG4gICAgICAgIEFuaW1hdGlvbkltcGwucHJvdG90eXBlLl9zZXRSb3RhdGlvbiA9IGZ1bmN0aW9uIChyYWRpYW5zKSB7XHJcbiAgICAgICAgICAgIC8vaWYgKHRoaXMucm90YXRpb24gIT09IHJhZGlhbnMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnNwcml0ZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlc1tpXS5yb3RhdGlvbiA9IHJhZGlhbnM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy99XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBbmltYXRpb25JbXBsLnByb3RvdHlwZS5fc2V0U2NhbGUgPSBmdW5jdGlvbiAoc2NhbGUpIHtcclxuICAgICAgICAgICAgLy9pZiAoIXRoaXMuc2NhbGUuZXF1YWxzKHNjYWxlKSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuc3ByaXRlcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVzW2ldLnNjYWxlID0gc2NhbGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy99XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXNldHMgdGhlIGFuaW1hdGlvbiB0byBmaXJzdCBmcmFtZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBBbmltYXRpb25JbXBsLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50RnJhbWUgPSAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGFuaW1hdGlvbiBpcyBjb21wbGV0ZSwgYW5pbWF0aW9ucyB0aGF0IGxvb3AgYXJlIG5ldmVyIGNvbXBsZXRlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFuaW1hdGlvbkltcGwucHJvdG90eXBlLmlzRG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICghdGhpcy5sb29wICYmIHRoaXMuY3VycmVudEZyYW1lID49IHRoaXMuc3ByaXRlcy5sZW5ndGgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTm90IG1lYW50IHRvIGJlIGNhbGxlZCBieSBnYW1lIGRldmVsb3BlcnMuIFRpY2tzIHRoZSBhbmltYXRpb24gZm9yd2FyZCBpbnRlcm5hbGx5IGFuZFxyXG4gICAgICAgICAqIGNhbGN1bGF0ZXMgd2hldGhlciB0byBjaGFuZ2UgdG8gdGhlIGZyYW1lLlxyXG4gICAgICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFuaW1hdGlvbkltcGwucHJvdG90eXBlLnRpY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB0aW1lID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgaWYgKCh0aW1lIC0gdGhpcy5fb2xkVGltZSkgPiB0aGlzLnNwZWVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZSA9ICh0aGlzLmxvb3AgPyAodGhpcy5jdXJyZW50RnJhbWUgKyAxKSAlIHRoaXMuc3ByaXRlcy5sZW5ndGggOiB0aGlzLmN1cnJlbnRGcmFtZSArIDEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fb2xkVGltZSA9IHRpbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEFuaW1hdGlvbkltcGwucHJvdG90eXBlLl91cGRhdGVWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldEFuY2hvcih0aGlzLmFuY2hvcik7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldFJvdGF0aW9uKHRoaXMucm90YXRpb24pO1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRTY2FsZSh0aGlzLnNjYWxlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNraXBzIGFoZWFkIGEgc3BlY2lmaWVkIG51bWJlciBvZiBmcmFtZXMgaW4gdGhlIGFuaW1hdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSBmcmFtZXMgIEZyYW1lcyB0byBza2lwIGFoZWFkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQW5pbWF0aW9uSW1wbC5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uIChmcmFtZXMpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50RnJhbWUgPSAodGhpcy5jdXJyZW50RnJhbWUgKyBmcmFtZXMpICUgdGhpcy5zcHJpdGVzLmxlbmd0aDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEFuaW1hdGlvbkltcGwucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoY3R4LCB4LCB5KSB7XHJcbiAgICAgICAgICAgIHRoaXMudGljaygpO1xyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVWYWx1ZXMoKTtcclxuICAgICAgICAgICAgdmFyIGN1cnJTcHJpdGU7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRGcmFtZSA8IHRoaXMuc3ByaXRlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJTcHJpdGUgPSB0aGlzLnNwcml0ZXNbdGhpcy5jdXJyZW50RnJhbWVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmxpcFZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VyclNwcml0ZS5mbGlwVmVydGljYWwgPSB0aGlzLmZsaXBWZXJ0aWNhbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZsaXBIb3Jpem9udGFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VyclNwcml0ZS5mbGlwSG9yaXpvbnRhbCA9IHRoaXMuZmxpcEhvcml6b250YWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjdXJyU3ByaXRlLmRyYXcoY3R4LCB4LCB5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5mcmVlemVGcmFtZSAhPT0gLTEgJiYgdGhpcy5jdXJyZW50RnJhbWUgPj0gdGhpcy5zcHJpdGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgY3VyclNwcml0ZSA9IHRoaXMuc3ByaXRlc1tVdGlsLmNsYW1wKHRoaXMuZnJlZXplRnJhbWUsIDAsIHRoaXMuc3ByaXRlcy5sZW5ndGggLSAxKV07XHJcbiAgICAgICAgICAgICAgICBjdXJyU3ByaXRlLmRyYXcoY3R4LCB4LCB5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBhZGQgdGhlIGNhbGN1bGF0ZWQgd2lkdGhcclxuICAgICAgICAgICAgaWYgKGN1cnJTcHJpdGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSBjdXJyU3ByaXRlLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBjdXJyU3ByaXRlLmhlaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGxheXMgYW4gYW5pbWF0aW9uIGF0IGFuIGFyYml0cmFyeSBsb2NhdGlvbiBpbiB0aGUgZ2FtZS5cclxuICAgICAgICAgKiBAcGFyYW0geCAgVGhlIHggcG9zaXRpb24gaW4gdGhlIGdhbWUgdG8gcGxheVxyXG4gICAgICAgICAqIEBwYXJhbSB5ICBUaGUgeSBwb3NpdGlvbiBpbiB0aGUgZ2FtZSB0byBwbGF5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQW5pbWF0aW9uSW1wbC5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uICh4LCB5KSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgICAgICAgICAgdGhpcy5fZW5naW5lLnBsYXlBbmltYXRpb24odGhpcywgeCwgeSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gQW5pbWF0aW9uSW1wbDtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkFuaW1hdGlvbkltcGwgPSBBbmltYXRpb25JbXBsO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbmltYXRpb25zIGFsbG93IHlvdSB0byBkaXNwbGF5IGEgc2VyaWVzIG9mIGltYWdlcyBvbmUgYWZ0ZXIgYW5vdGhlcixcclxuICAgICAqIGNyZWF0aW5nIHRoZSBpbGx1c2lvbiBvZiBjaGFuZ2UuIEdlbmVyYWxseSB0aGVzZSBpbWFnZXMgd2lsbCBjb21lIGZyb20gYSBbW1Nwcml0ZVNoZWV0XV0gc291cmNlLlxyXG4gICAgICpcclxuICAgICAqIFtbaW5jbHVkZTpBbmltYXRpb25zLm1kXV1cclxuICAgICAqL1xyXG4gICAgdmFyIEFuaW1hdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKEFuaW1hdGlvbiwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBBbmltYXRpb24oZW5naW5lT3JDb25maWcsIGltYWdlcywgc3BlZWQsIGxvb3ApIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGVuZ2luZU9yQ29uZmlnLCBpbWFnZXMsIHNwZWVkLCBsb29wKSB8fCB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gQW5pbWF0aW9uO1xyXG4gICAgfShDb25maWd1cmFibGVfMi5Db25maWd1cmFibGUoQW5pbWF0aW9uSW1wbCkpKTtcclxuICAgIGV4cG9ydHMuQW5pbWF0aW9uID0gQW5pbWF0aW9uO1xyXG59KTtcclxuZGVmaW5lKFwiRHJhd2luZy9TcHJpdGVTaGVldFwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkRyYXdpbmcvU3ByaXRlXCIsIFwiRHJhd2luZy9BbmltYXRpb25cIiwgXCJEcmF3aW5nL0NvbG9yXCIsIFwiRHJhd2luZy9TcHJpdGVFZmZlY3RzXCIsIFwiUmVzb3VyY2VzL1RleHR1cmVcIiwgXCJVdGlsL0xvZ1wiLCBcIkxhYmVsXCIsIFwiQ29uZmlndXJhYmxlXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgU3ByaXRlXzIsIEFuaW1hdGlvbl8xLCBDb2xvcl8xMCwgRWZmZWN0cywgVGV4dHVyZV8yLCBMb2dfNCwgTGFiZWxfMSwgQ29uZmlndXJhYmxlXzMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaGlkZGVuXHJcbiAgICAgKi9cclxuICAgIHZhciBTcHJpdGVTaGVldEltcGwgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBpbWFnZSAgICAgVGhlIGJhY2tpbmcgaW1hZ2UgdGV4dHVyZSB0byBidWlsZCB0aGUgU3ByaXRlU2hlZXRcclxuICAgICAgICAgKiBAcGFyYW0gY29sdW1ucyAgIFRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgaW1hZ2UgdGV4dHVyZVxyXG4gICAgICAgICAqIEBwYXJhbSByb3dzICAgICAgVGhlIG51bWJlciBvZiByb3dzIGluIHRoZSBpbWFnZSB0ZXh0dXJlXHJcbiAgICAgICAgICogQHBhcmFtIHNwV2lkdGggICBUaGUgd2lkdGggb2YgZWFjaCBpbmRpdmlkdWFsIHNwcml0ZSBpbiBwaXhlbHNcclxuICAgICAgICAgKiBAcGFyYW0gc3BIZWlnaHQgIFRoZSBoZWlnaHQgb2YgZWFjaCBpbmRpdmlkdWFsIHNwcml0ZSBpbiBwaXhlbHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBTcHJpdGVTaGVldEltcGwoaW1hZ2VPckNvbmZpZ09yU3ByaXRlcywgY29sdW1ucywgcm93cywgc3BXaWR0aCwgc3BIZWlnaHQpIHtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGVzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuaW1hZ2UgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmNvbHVtbnMgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLnJvd3MgPSAwO1xyXG4gICAgICAgICAgICB2YXIgbG9hZEZyb21JbWFnZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoaW1hZ2VPckNvbmZpZ09yU3ByaXRlcyBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZXMgPSBpbWFnZU9yQ29uZmlnT3JTcHJpdGVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGltYWdlT3JDb25maWdPclNwcml0ZXMgJiYgIShpbWFnZU9yQ29uZmlnT3JTcHJpdGVzIGluc3RhbmNlb2YgVGV4dHVyZV8yLlRleHR1cmUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2x1bW5zID0gaW1hZ2VPckNvbmZpZ09yU3ByaXRlcy5jb2x1bW5zO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm93cyA9IGltYWdlT3JDb25maWdPclNwcml0ZXMucm93cztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwV2lkdGggPSBpbWFnZU9yQ29uZmlnT3JTcHJpdGVzLnNwV2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcEhlaWdodCA9IGltYWdlT3JDb25maWdPclNwcml0ZXMuc3BIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbWFnZSA9IGltYWdlT3JDb25maWdPclNwcml0ZXMuaW1hZ2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmltYWdlID0gaW1hZ2VPckNvbmZpZ09yU3ByaXRlcztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbnMgPSBjb2x1bW5zO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm93cyA9IHJvd3M7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcFdpZHRoID0gc3BXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwSGVpZ2h0ID0gc3BIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZXMgPSBuZXcgQXJyYXkodGhpcy5jb2x1bW5zICogdGhpcy5yb3dzKTtcclxuICAgICAgICAgICAgICAgIGxvYWRGcm9tSW1hZ2UgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFRPRE86IEluc3BlY3QgYWN0dWFsIGltYWdlIGRpbWVuc2lvbnMgd2l0aCBwcmVsb2FkaW5nXHJcbiAgICAgICAgICAgIC8qaWYoc3BXaWR0aCAqIGNvbHVtbnMgPiB0aGlzLmludGVybmFsSW1hZ2UubmF0dXJhbFdpZHRoKXtcclxuICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3ByaXRlU2hlZXQgc3BlY2lmaWVkIGlzIHdpZGVyIHRoYW4gaW1hZ2Ugd2lkdGhcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgXHJcbiAgICAgICAgICAgIGlmKHNwSGVpZ2h0ICogcm93cyA+IHRoaXMuaW50ZXJuYWxJbWFnZS5uYXR1cmFsSGVpZ2h0KXtcclxuICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3ByaXRlU2hlZXQgc3BlY2lmaWVkIGlzIGhpZ2hlciB0aGFuIGltYWdlIGhlaWdodFwiKTtcclxuICAgICAgICAgICAgfSovXHJcbiAgICAgICAgICAgIGlmIChsb2FkRnJvbUltYWdlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICB2YXIgaiA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVzW2ogKyBpICogdGhpcy5jb2x1bW5zXSA9IG5ldyBTcHJpdGVfMi5TcHJpdGUodGhpcy5pbWFnZSwgaiAqIHRoaXMuc3BXaWR0aCwgaSAqIHRoaXMuc3BIZWlnaHQsIHRoaXMuc3BXaWR0aCwgdGhpcy5zcEhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZSBhbiBhbmltYXRpb24gZnJvbSB0aGUgdGhpcyBTcHJpdGVTaGVldCBieSBsaXN0aW5nIG91dCB0aGVcclxuICAgICAgICAgKiBzcHJpdGUgaW5kaWNlcy4gU3ByaXRlcyBhcmUgb3JnYW5pemVkIGluIHJvdyBtYWpvciBvcmRlciBpbiB0aGUgU3ByaXRlU2hlZXQuXHJcbiAgICAgICAgICogQHBhcmFtIGVuZ2luZSAgIFJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBnYW1lIFtbRW5naW5lXV1cclxuICAgICAgICAgKiBAcGFyYW0gaW5kaWNlcyAgQW4gYXJyYXkgb2Ygc3ByaXRlIGluZGljZXMgdG8gdXNlIGluIHRoZSBhbmltYXRpb25cclxuICAgICAgICAgKiBAcGFyYW0gc3BlZWQgICAgVGhlIG51bWJlciBpbiBtaWxsaXNlY29uZHMgdG8gZGlzcGxheSBlYWNoIGZyYW1lIGluIHRoZSBhbmltYXRpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBTcHJpdGVTaGVldEltcGwucHJvdG90eXBlLmdldEFuaW1hdGlvbkJ5SW5kaWNlcyA9IGZ1bmN0aW9uIChlbmdpbmUsIGluZGljZXMsIHNwZWVkKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBpbWFnZXMgPSBpbmRpY2VzLm1hcChmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zcHJpdGVzW2luZGV4XTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGltYWdlcyA9IGltYWdlcy5tYXAoZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpLmNsb25lKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFuaW1hdGlvbl8xLkFuaW1hdGlvbihlbmdpbmUsIGltYWdlcywgc3BlZWQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlIGFuIGFuaW1hdGlvbiBmcm9tIHRoZSB0aGlzIFNwcml0ZVNoZWV0IGJ5IHNwZWNpZmluZyB0aGUgcmFuZ2Ugb2ZcclxuICAgICAgICAgKiBpbWFnZXMgd2l0aCB0aGUgYmVnaW5uaW5nIChpbmNsdXNpdmUpIGFuZCBlbmRpbmcgKGV4Y2x1c2l2ZSkgaW5kZXhcclxuICAgICAgICAgKiBGb3IgZXhhbXBsZSBgZ2V0QW5pbWF0aW9uQmV0d2VlbihlbmdpbmUsIDAsIDUsIDIwMClgIHJldHVybnMgYW4gYW5pbWF0aW9uIHdpdGggNSBmcmFtZXMuXHJcbiAgICAgICAgICogQHBhcmFtIGVuZ2luZSAgICAgIFJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBnYW1lIEVuZ2luZVxyXG4gICAgICAgICAqIEBwYXJhbSBiZWdpbkluZGV4ICBUaGUgaW5kZXggdG8gc3RhcnQgdGFraW5nIGZyYW1lcyAoaW5jbHVzaXZlKVxyXG4gICAgICAgICAqIEBwYXJhbSBlbmRJbmRleCAgICBUaGUgaW5kZXggdG8gc3RvcCB0YWtpbmcgZnJhbWVzIChleGNsdXNpdmUpXHJcbiAgICAgICAgICogQHBhcmFtIHNwZWVkICAgICAgIFRoZSBudW1iZXIgaW4gbWlsbGlzZWNvbmRzIHRvIGRpc3BsYXkgZWFjaCBmcmFtZSBpbiB0aGUgYW5pbWF0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU3ByaXRlU2hlZXRJbXBsLnByb3RvdHlwZS5nZXRBbmltYXRpb25CZXR3ZWVuID0gZnVuY3Rpb24gKGVuZ2luZSwgYmVnaW5JbmRleCwgZW5kSW5kZXgsIHNwZWVkKSB7XHJcbiAgICAgICAgICAgIHZhciBpbWFnZXMgPSB0aGlzLnNwcml0ZXMuc2xpY2UoYmVnaW5JbmRleCwgZW5kSW5kZXgpO1xyXG4gICAgICAgICAgICBpbWFnZXMgPSBpbWFnZXMubWFwKGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaS5jbG9uZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb25fMS5BbmltYXRpb24oZW5naW5lLCBpbWFnZXMsIHNwZWVkKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRyZWF0IHRoZSBlbnRpcmUgU3ByaXRlU2hlZXQgYXMgb25lIGFuaW1hdGlvbiwgb3JnYW5pemluZyB0aGUgZnJhbWVzIGluXHJcbiAgICAgICAgICogcm93IG1ham9yIG9yZGVyLlxyXG4gICAgICAgICAqIEBwYXJhbSBlbmdpbmUgIFJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBnYW1lIFtbRW5naW5lXV1cclxuICAgICAgICAgKiBAcGFyYW0gc3BlZWQgICBUaGUgbnVtYmVyIGluIG1pbGxpc2Vjb25kcyB0byBkaXNwbGF5IGVhY2ggZnJhbWUgdGhlIGFuaW1hdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNwcml0ZVNoZWV0SW1wbC5wcm90b3R5cGUuZ2V0QW5pbWF0aW9uRm9yQWxsID0gZnVuY3Rpb24gKGVuZ2luZSwgc3BlZWQpIHtcclxuICAgICAgICAgICAgdmFyIHNwcml0ZXMgPSB0aGlzLnNwcml0ZXMubWFwKGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaS5jbG9uZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb25fMS5BbmltYXRpb24oZW5naW5lLCBzcHJpdGVzLCBzcGVlZCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXRyZWl2ZSBhIHNwZWNpZmljIHNwcml0ZSBmcm9tIHRoZSBTcHJpdGVTaGVldCBieSBpdHMgaW5kZXguIFNwcml0ZXMgYXJlIG9yZ2FuaXplZFxyXG4gICAgICAgICAqIGluIHJvdyBtYWpvciBvcmRlciBpbiB0aGUgU3ByaXRlU2hlZXQuXHJcbiAgICAgICAgICogQHBhcmFtIGluZGV4ICBUaGUgaW5kZXggb2YgdGhlIHNwcml0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNwcml0ZVNoZWV0SW1wbC5wcm90b3R5cGUuZ2V0U3ByaXRlID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5zcHJpdGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ByaXRlc1tpbmRleF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5kZXg6ICcgKyBpbmRleCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBTcHJpdGVTaGVldEltcGw7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5TcHJpdGVTaGVldEltcGwgPSBTcHJpdGVTaGVldEltcGw7XHJcbiAgICAvKipcclxuICAgICAqIFNwcml0ZSBzaGVldHMgYXJlIGEgdXNlZnVsIG1lY2hhbmlzbSBmb3Igc2xpY2luZyB1cCBpbWFnZSByZXNvdXJjZXMgaW50b1xyXG4gICAgICogc2VwYXJhdGUgc3ByaXRlcyBvciBmb3IgZ2VuZXJhdGluZyBpbiBnYW1lIGFuaW1hdGlvbnMuIFtbU3ByaXRlfFNwcml0ZXNdXSBhcmUgb3JnYW5pemVkXHJcbiAgICAgKiBpbiByb3cgbWFqb3Igb3JkZXIgaW4gdGhlIFtbU3ByaXRlU2hlZXRdXS5cclxuICAgICAqXHJcbiAgICAgKiBbW2luY2x1ZGU6U3ByaXRlU2hlZXRzLm1kXV1cclxuICAgICAqL1xyXG4gICAgdmFyIFNwcml0ZVNoZWV0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoU3ByaXRlU2hlZXQsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gU3ByaXRlU2hlZXQoaW1hZ2VPckNvbmZpZ09yU3ByaXRlcywgY29sdW1ucywgcm93cywgc3BXaWR0aCwgc3BIZWlnaHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGltYWdlT3JDb25maWdPclNwcml0ZXMsIGNvbHVtbnMsIHJvd3MsIHNwV2lkdGgsIHNwSGVpZ2h0KSB8fCB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gU3ByaXRlU2hlZXQ7XHJcbiAgICB9KENvbmZpZ3VyYWJsZV8zLkNvbmZpZ3VyYWJsZShTcHJpdGVTaGVldEltcGwpKSk7XHJcbiAgICBleHBvcnRzLlNwcml0ZVNoZWV0ID0gU3ByaXRlU2hlZXQ7XHJcbiAgICB2YXIgU3ByaXRlRm9udEltcGwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhTcHJpdGVGb250SW1wbCwgX3N1cGVyKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gaW1hZ2UgICAgICAgICAgIFRoZSBiYWNraW5nIGltYWdlIHRleHR1cmUgdG8gYnVpbGQgdGhlIFNwcml0ZUZvbnRcclxuICAgICAgICAgKiBAcGFyYW0gYWxwaGFiZXQgICAgICAgIEEgc3RyaW5nIHJlcHJlc2VudGluZyBhbGwgdGhlIGNoYXJhY3RlcnMgaW4gdGhlIGltYWdlLCBpbiByb3cgbWFqb3Igb3JkZXIuXHJcbiAgICAgICAgICogQHBhcmFtIGNhc2VJbnNlbnNpdGl2ZSAgSW5kaWNhdGUgd2hldGhlciB0aGlzIGZvbnQgdGFrZXMgY2FzZSBpbnRvIGFjY291bnRcclxuICAgICAgICAgKiBAcGFyYW0gY29sdW1ucyAgICAgICAgIFRoZSBudW1iZXIgb2YgY29sdW1ucyBvZiBjaGFyYWN0ZXJzIGluIHRoZSBpbWFnZVxyXG4gICAgICAgICAqIEBwYXJhbSByb3dzICAgICAgICAgICAgVGhlIG51bWJlciBvZiByb3dzIG9mIGNoYXJhY3RlcnMgaW4gdGhlIGltYWdlXHJcbiAgICAgICAgICogQHBhcmFtIHNwV2lkdGggICAgICAgICBUaGUgd2lkdGggb2YgZWFjaCBjaGFyYWN0ZXIgaW4gcGl4ZWxzXHJcbiAgICAgICAgICogQHBhcmFtIHNwSGVpZ2h0ICAgICAgICBUaGUgaGVpZ2h0IG9mIGVhY2ggY2hhcmFjdGVyIGluIHBpeGVsc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIFNwcml0ZUZvbnRJbXBsKGltYWdlT3JDb25maWcsIGFscGhhYmV0LCBjYXNlSW5zZW5zaXRpdmUsIGNvbHVtbnMsIHJvd3MsIHNwV2lkdGgsIHNwSGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGltYWdlT3JDb25maWcgaW5zdGFuY2VvZiBUZXh0dXJlXzIuVGV4dHVyZSA/IHsgaW1hZ2U6IGltYWdlT3JDb25maWcsIHNwV2lkdGg6IHNwV2lkdGgsXHJcbiAgICAgICAgICAgICAgICBzcEhlaWdodDogc3BIZWlnaHQsIHJvd3M6IHJvd3MsIGNvbHVtbnM6IGNvbHVtbnMgfSA6IGltYWdlT3JDb25maWcpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLl9jdXJyZW50Q29sb3IgPSBDb2xvcl8xMC5Db2xvci5CbGFjay5jbG9uZSgpO1xyXG4gICAgICAgICAgICBfdGhpcy5fY3VycmVudE9wYWNpdHkgPSAxLjA7XHJcbiAgICAgICAgICAgIF90aGlzLl9zcHJpdGVzID0ge307XHJcbiAgICAgICAgICAgIC8vIHRleHQgc2hhZG93XHJcbiAgICAgICAgICAgIF90aGlzLl90ZXh0U2hhZG93T24gPSBmYWxzZTtcclxuICAgICAgICAgICAgX3RoaXMuX3RleHRTaGFkb3dEaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIF90aGlzLl90ZXh0U2hhZG93Q29sb3IgPSBDb2xvcl8xMC5Db2xvci5CbGFjay5jbG9uZSgpO1xyXG4gICAgICAgICAgICBfdGhpcy5fdGV4dFNoYWRvd1Nwcml0ZXMgPSB7fTtcclxuICAgICAgICAgICAgX3RoaXMuX3NoYWRvd09mZnNldFggPSA1O1xyXG4gICAgICAgICAgICBfdGhpcy5fc2hhZG93T2Zmc2V0WSA9IDU7XHJcbiAgICAgICAgICAgIGlmIChpbWFnZU9yQ29uZmlnICYmICEoaW1hZ2VPckNvbmZpZyBpbnN0YW5jZW9mIFRleHR1cmVfMi5UZXh0dXJlKSkge1xyXG4gICAgICAgICAgICAgICAgYWxwaGFiZXQgPSBpbWFnZU9yQ29uZmlnLmFscGhhYmV0O1xyXG4gICAgICAgICAgICAgICAgY2FzZUluc2Vuc2l0aXZlID0gaW1hZ2VPckNvbmZpZy5jYXNlSW5zZW5zaXRpdmU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMuX2FscGhhYmV0ID0gYWxwaGFiZXQ7XHJcbiAgICAgICAgICAgIF90aGlzLl9jYXNlSW5zZW5zaXRpdmUgPSBjYXNlSW5zZW5zaXRpdmU7XHJcbiAgICAgICAgICAgIF90aGlzLl9zcHJpdGVzID0gX3RoaXMuZ2V0VGV4dFNwcml0ZXMoKTtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgZGljdGlvbmFyeSB0aGF0IG1hcHMgZWFjaCBjaGFyYWN0ZXIgaW4gdGhlIGFscGhhYmV0IHRvIHRoZSBhcHByb3ByaWF0ZSBbW1Nwcml0ZV1dLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNwcml0ZUZvbnRJbXBsLnByb3RvdHlwZS5nZXRUZXh0U3ByaXRlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGxvb2t1cCA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2FscGhhYmV0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2hhciA9IHRoaXMuX2FscGhhYmV0W2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Nhc2VJbnNlbnNpdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYXIgPSBjaGFyLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsb29rdXBbY2hhcl0gPSB0aGlzLnNwcml0ZXNbaV0uY2xvbmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbG9va3VwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgdGV4dCBzaGFkb3cgZm9yIHNwcml0ZSBmb250c1xyXG4gICAgICAgICAqIEBwYXJhbSBvZmZzZXRYICAgICAgVGhlIHggb2Zmc2V0IGluIHBpeGVscyB0byBwbGFjZSB0aGUgc2hhZG93XHJcbiAgICAgICAgICogQHBhcmFtIG9mZnNldFkgICAgICBUaGUgeSBvZmZzZXQgaW4gcGl4ZWxzIHRvIHBsYWNlIHRoZSBzaGFkb3dcclxuICAgICAgICAgKiBAcGFyYW0gc2hhZG93Q29sb3IgIFRoZSBjb2xvciBvZiB0aGUgdGV4dCBzaGFkb3dcclxuICAgICAgICAgKi9cclxuICAgICAgICBTcHJpdGVGb250SW1wbC5wcm90b3R5cGUuc2V0VGV4dFNoYWRvdyA9IGZ1bmN0aW9uIChvZmZzZXRYLCBvZmZzZXRZLCBzaGFkb3dDb2xvcikge1xyXG4gICAgICAgICAgICB0aGlzLl90ZXh0U2hhZG93T24gPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9zaGFkb3dPZmZzZXRYID0gb2Zmc2V0WDtcclxuICAgICAgICAgICAgdGhpcy5fc2hhZG93T2Zmc2V0WSA9IG9mZnNldFk7XHJcbiAgICAgICAgICAgIHRoaXMuX3RleHRTaGFkb3dDb2xvciA9IHNoYWRvd0NvbG9yLmNsb25lKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3RleHRTaGFkb3dEaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGNoYXJhY3RlciBpbiB0aGlzLl9zcHJpdGVzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0U2hhZG93U3ByaXRlc1tjaGFyYWN0ZXJdID0gdGhpcy5fc3ByaXRlc1tjaGFyYWN0ZXJdLmNsb25lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRvZ2dsZXMgdGV4dCBzaGFkb3dzIG9uIG9yIG9mZlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNwcml0ZUZvbnRJbXBsLnByb3RvdHlwZS51c2VUZXh0U2hhZG93ID0gZnVuY3Rpb24gKG9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RleHRTaGFkb3dPbiA9IG9uO1xyXG4gICAgICAgICAgICBpZiAob24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0VGV4dFNoYWRvdyg1LCA1LCB0aGlzLl90ZXh0U2hhZG93Q29sb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEcmF3cyB0aGUgY3VycmVudCBzcHJpdGUgZm9udFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNwcml0ZUZvbnRJbXBsLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGN0eCwgdGV4dCwgeCwgeSwgb3B0aW9ucykge1xyXG4gICAgICAgICAgICBvcHRpb25zID0gdGhpcy5fcGFyc2VPcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudENvbG9yLnRvU3RyaW5nKCkgIT09IG9wdGlvbnMuY29sb3IudG9TdHJpbmcoKSB8fCB0aGlzLl9jdXJyZW50T3BhY2l0eSAhPT0gb3B0aW9ucy5vcGFjaXR5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50T3BhY2l0eSA9IG9wdGlvbnMub3BhY2l0eTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRDb2xvciA9IG9wdGlvbnMuY29sb3I7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjaGFyIGluIHRoaXMuX3Nwcml0ZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zcHJpdGVzW2NoYXJdLmNsZWFyRWZmZWN0cygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Nwcml0ZXNbY2hhcl0uZmlsbChvcHRpb25zLmNvbG9yKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zcHJpdGVzW2NoYXJdLm9wYWNpdHkob3B0aW9ucy5vcGFjaXR5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5fdGV4dFNoYWRvd09uICYmIHRoaXMuX3RleHRTaGFkb3dEaXJ0eSAmJiB0aGlzLl90ZXh0U2hhZG93Q29sb3IpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGNoYXJhY3RlclNoYWRvdyBpbiB0aGlzLl90ZXh0U2hhZG93U3ByaXRlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RleHRTaGFkb3dTcHJpdGVzW2NoYXJhY3RlclNoYWRvd10uY2xlYXJFZmZlY3RzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGV4dFNoYWRvd1Nwcml0ZXNbY2hhcmFjdGVyU2hhZG93XS5hZGRFZmZlY3QobmV3IEVmZmVjdHMuRmlsbCh0aGlzLl90ZXh0U2hhZG93Q29sb3IuY2xvbmUoKSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dFNoYWRvd0RpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZmluZCB0aGUgY3VycmVudCBsZW5ndGggb2YgdGV4dCBpbiBwaXhlbHNcclxuICAgICAgICAgICAgdmFyIHNwcml0ZSA9IHRoaXMuc3ByaXRlc1swXTtcclxuICAgICAgICAgICAgLy8gZmluZCB0aGUgY3VycmVudCBoZWlnaHQgZm8gdGhlIHRleHQgaW4gcGl4ZWxzXHJcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBzcHJpdGUuc2hlaWdodDtcclxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIGFwcHJvcHJpYXRlIHNjYWxlIGZvciBmb250IHNpemVcclxuICAgICAgICAgICAgdmFyIHNjYWxlID0gb3B0aW9ucy5mb250U2l6ZSAvIGhlaWdodDtcclxuICAgICAgICAgICAgdmFyIGxlbmd0aCA9ICh0ZXh0Lmxlbmd0aCAqIHNwcml0ZS5zd2lkdGggKiBzY2FsZSkgKyAodGV4dC5sZW5ndGggKiBvcHRpb25zLmxldHRlclNwYWNpbmcpO1xyXG4gICAgICAgICAgICB2YXIgY3VyclggPSB4O1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy50ZXh0QWxpZ24gPT09IExhYmVsXzEuVGV4dEFsaWduLkxlZnQgfHwgb3B0aW9ucy50ZXh0QWxpZ24gPT09IExhYmVsXzEuVGV4dEFsaWduLlN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyWCA9IHg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy50ZXh0QWxpZ24gPT09IExhYmVsXzEuVGV4dEFsaWduLlJpZ2h0IHx8IG9wdGlvbnMudGV4dEFsaWduID09PSBMYWJlbF8xLlRleHRBbGlnbi5FbmQpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJYID0geCAtIGxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLnRleHRBbGlnbiA9PT0gTGFiZWxfMS5UZXh0QWxpZ24uQ2VudGVyKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyWCA9IHggLSBsZW5ndGggLyAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjdXJyWSA9IHkgLSBoZWlnaHQgKiBzY2FsZTtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYmFzZUFsaWduID09PSBMYWJlbF8xLkJhc2VBbGlnbi5Ub3AgfHwgb3B0aW9ucy5iYXNlQWxpZ24gPT09IExhYmVsXzEuQmFzZUFsaWduLkhhbmdpbmcpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJZID0geTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLmJhc2VBbGlnbiA9PT0gTGFiZWxfMS5CYXNlQWxpZ24uSWRlb2dyYXBoaWMgfHxcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuYmFzZUFsaWduID09PSBMYWJlbF8xLkJhc2VBbGlnbi5Cb3R0b20gfHxcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuYmFzZUFsaWduID09PSBMYWJlbF8xLkJhc2VBbGlnbi5BbHBoYWJldGljKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyWSA9IHkgLSBoZWlnaHQgKiBzY2FsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLmJhc2VBbGlnbiA9PT0gTGFiZWxfMS5CYXNlQWxpZ24uTWlkZGxlKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyWSA9IHkgLSAoaGVpZ2h0ICogc2NhbGUpIC8gMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBjaGFyYWN0ZXIgPSB0ZXh0W2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Nhc2VJbnNlbnNpdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJhY3RlciA9IGNoYXJhY3Rlci50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0ZXh0IHNoYWRvd1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl90ZXh0U2hhZG93T24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGV4dFNoYWRvd1Nwcml0ZXNbY2hhcmFjdGVyXS5zY2FsZS54ID0gc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RleHRTaGFkb3dTcHJpdGVzW2NoYXJhY3Rlcl0uc2NhbGUueSA9IHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0U2hhZG93U3ByaXRlc1tjaGFyYWN0ZXJdLmRyYXcoY3R4LCBjdXJyWCArIHRoaXMuX3NoYWRvd09mZnNldFgsIGN1cnJZICsgdGhpcy5fc2hhZG93T2Zmc2V0WSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFyU3ByaXRlID0gdGhpcy5fc3ByaXRlc1tjaGFyYWN0ZXJdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJTcHJpdGUuc2NhbGUueCA9IHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJTcHJpdGUuc2NhbGUueSA9IHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJTcHJpdGUuZHJhdyhjdHgsIGN1cnJYLCBjdXJyWSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VyclggKz0gKGNoYXJTcHJpdGUud2lkdGggKyBvcHRpb25zLmxldHRlclNwYWNpbmcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBMb2dfNC5Mb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcihcIlNwcml0ZUZvbnQgRXJyb3IgZHJhd2luZyBjaGFyIFwiICsgY2hhcmFjdGVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgU3ByaXRlRm9udEltcGwucHJvdG90eXBlLl9wYXJzZU9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IG9wdGlvbnMuZm9udFNpemUgfHwgMTAsXHJcbiAgICAgICAgICAgICAgICBsZXR0ZXJTcGFjaW5nOiBvcHRpb25zLmxldHRlclNwYWNpbmcgfHwgMCxcclxuICAgICAgICAgICAgICAgIGNvbG9yOiBvcHRpb25zLmNvbG9yIHx8IENvbG9yXzEwLkNvbG9yLkJsYWNrLmNsb25lKCksXHJcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IHR5cGVvZiBvcHRpb25zLnRleHRBbGlnbiA9PT0gdW5kZWZpbmVkID8gTGFiZWxfMS5UZXh0QWxpZ24uTGVmdCA6IG9wdGlvbnMudGV4dEFsaWduLFxyXG4gICAgICAgICAgICAgICAgYmFzZUFsaWduOiB0eXBlb2Ygb3B0aW9ucy5iYXNlQWxpZ24gPT09IHVuZGVmaW5lZCA/IExhYmVsXzEuQmFzZUFsaWduLkJvdHRvbSA6IG9wdGlvbnMuYmFzZUFsaWduLFxyXG4gICAgICAgICAgICAgICAgbWF4V2lkdGg6IG9wdGlvbnMubWF4V2lkdGggfHwgLTEsXHJcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiBvcHRpb25zLm9wYWNpdHkgfHwgMFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFNwcml0ZUZvbnRJbXBsO1xyXG4gICAgfShTcHJpdGVTaGVldCkpO1xyXG4gICAgZXhwb3J0cy5TcHJpdGVGb250SW1wbCA9IFNwcml0ZUZvbnRJbXBsO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTcHJpdGUgZm9udHMgYXJlIGEgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGEgW1tMYWJlbF1dIHRvIHNwZWNpZnlcclxuICAgICAqIGEgcGFydGljdWxhciBiaXRtYXAgYXMgYSBmb250LiBOb3RlIHRoYXQgc29tZSBmb250IGZlYXR1cmVzIGFyZSBub3RcclxuICAgICAqIHN1cHBvcnRlZCBieSBTcHJpdGUgZm9udHMuXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOlNwcml0ZUZvbnRzLm1kXV1cclxuICAgICAqL1xyXG4gICAgdmFyIFNwcml0ZUZvbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhTcHJpdGVGb250LCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFNwcml0ZUZvbnQoaW1hZ2VPckNvbmZpZywgYWxwaGFiZXQsIGNhc2VJbnNlbnNpdGl2ZSwgY29sdW1ucywgcm93cywgc3BXaWR0aCwgc3BIZWlnaHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGltYWdlT3JDb25maWcsIGFscGhhYmV0LCBjYXNlSW5zZW5zaXRpdmUsIGNvbHVtbnMsIHJvd3MsIHNwV2lkdGgsIHNwSGVpZ2h0KSB8fCB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gU3ByaXRlRm9udDtcclxuICAgIH0oQ29uZmlndXJhYmxlXzMuQ29uZmlndXJhYmxlKFNwcml0ZUZvbnRJbXBsKSkpO1xyXG4gICAgZXhwb3J0cy5TcHJpdGVGb250ID0gU3ByaXRlRm9udDtcclxufSk7XHJcbmRlZmluZShcIkxhYmVsXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiRHJhd2luZy9Db2xvclwiLCBcIkFjdG9yXCIsIFwiQ29uZmlndXJhYmxlXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgQ29sb3JfMTEsIEFjdG9yXzQsIENvbmZpZ3VyYWJsZV80KSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogRW51bSByZXByZXNlbnRpbmcgdGhlIGRpZmZlcmVudCBmb250IHNpemUgdW5pdHNcclxuICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9mb250LXNpemVcclxuICAgICAqL1xyXG4gICAgdmFyIEZvbnRVbml0O1xyXG4gICAgKGZ1bmN0aW9uIChGb250VW5pdCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVtIGlzIGEgc2NhbGFibGUgdW5pdCwgMSBlbSBpcyBlcXVhbCB0byB0aGUgY3VycmVudCBmb250IHNpemUgb2YgdGhlIGN1cnJlbnQgZWxlbWVudCwgcGFyZW50IGVsZW1lbnRzIGNhbiBlZmZlY3QgZW0gdmFsdWVzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRm9udFVuaXRbRm9udFVuaXRbXCJFbVwiXSA9IDBdID0gXCJFbVwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbSBpcyBzaW1pbGFyIHRvIHRoZSBFbSwgaXQgaXMgYSBzY2FsYWJsZSB1bml0LiAxIHJlbSBpcyBlcWF1bCB0byB0aGUgZm9udCBzaXplIG9mIHRoZSByb290IGVsZW1lbnRcclxuICAgICAgICAgKi9cclxuICAgICAgICBGb250VW5pdFtGb250VW5pdFtcIlJlbVwiXSA9IDFdID0gXCJSZW1cIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQaXhlbCBpcyBhIHVuaXQgb2YgbGVuZ3RoIGluIHNjcmVlbiBwaXhlbHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBGb250VW5pdFtGb250VW5pdFtcIlB4XCJdID0gMl0gPSBcIlB4XCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUG9pbnQgaXMgYSBwaHlzaWNhbCB1bml0IGxlbmd0aCAoMS83MiBvZiBhbiBpbmNoKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEZvbnRVbml0W0ZvbnRVbml0W1wiUHRcIl0gPSAzXSA9IFwiUHRcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQZXJjZW50IGlzIGEgc2NhbGFibGUgdW5pdCBzaW1pbGFyIHRvIEVtLCB0aGUgb25seSBkaWZmZXJlbmNlIGlzIHRoZSBFbSB1bml0cyBzY2FsZSBmYXN0ZXIgd2hlbiBUZXh0LVNpemUgc3R1ZmZcclxuICAgICAgICAgKi9cclxuICAgICAgICBGb250VW5pdFtGb250VW5pdFtcIlBlcmNlbnRcIl0gPSA0XSA9IFwiUGVyY2VudFwiO1xyXG4gICAgfSkoRm9udFVuaXQgPSBleHBvcnRzLkZvbnRVbml0IHx8IChleHBvcnRzLkZvbnRVbml0ID0ge30pKTtcclxuICAgIC8qKlxyXG4gICAgICogRW51bSByZXByZXNlbnRpbmcgdGhlIGRpZmZlcmVudCBob3Jpem9udGFsIHRleHQgYWxpZ25tZW50c1xyXG4gICAgICovXHJcbiAgICB2YXIgVGV4dEFsaWduO1xyXG4gICAgKGZ1bmN0aW9uIChUZXh0QWxpZ24pIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdGV4dCBpcyBsZWZ0LWFsaWduZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVGV4dEFsaWduW1RleHRBbGlnbltcIkxlZnRcIl0gPSAwXSA9IFwiTGVmdFwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0ZXh0IGlzIHJpZ2h0LWFsaWduZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVGV4dEFsaWduW1RleHRBbGlnbltcIlJpZ2h0XCJdID0gMV0gPSBcIlJpZ2h0XCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHRleHQgaXMgY2VudGVyZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVGV4dEFsaWduW1RleHRBbGlnbltcIkNlbnRlclwiXSA9IDJdID0gXCJDZW50ZXJcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdGV4dCBpcyBhbGlnbmVkIGF0IHRoZSBub3JtYWwgc3RhcnQgb2YgdGhlIGxpbmUgKGxlZnQtYWxpZ25lZCBmb3IgbGVmdC10by1yaWdodCBsb2NhbGVzLFxyXG4gICAgICAgICAqIHJpZ2h0LWFsaWduZWQgZm9yIHJpZ2h0LXRvLWxlZnQgbG9jYWxlcykuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVGV4dEFsaWduW1RleHRBbGlnbltcIlN0YXJ0XCJdID0gM10gPSBcIlN0YXJ0XCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHRleHQgaXMgYWxpZ25lZCBhdCB0aGUgbm9ybWFsIGVuZCBvZiB0aGUgbGluZSAocmlnaHQtYWxpZ25lZCBmb3IgbGVmdC10by1yaWdodCBsb2NhbGVzLFxyXG4gICAgICAgICAqIGxlZnQtYWxpZ25lZCBmb3IgcmlnaHQtdG8tbGVmdCBsb2NhbGVzKS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBUZXh0QWxpZ25bVGV4dEFsaWduW1wiRW5kXCJdID0gNF0gPSBcIkVuZFwiO1xyXG4gICAgfSkoVGV4dEFsaWduID0gZXhwb3J0cy5UZXh0QWxpZ24gfHwgKGV4cG9ydHMuVGV4dEFsaWduID0ge30pKTtcclxuICAgIC8qKlxyXG4gICAgICogRW51bSByZXByZXNlbnRpbmcgdGhlIGRpZmZlcmVudCBiYXNlbGluZSB0ZXh0IGFsaWdubWVudHNcclxuICAgICAqL1xyXG4gICAgdmFyIEJhc2VBbGlnbjtcclxuICAgIChmdW5jdGlvbiAoQmFzZUFsaWduKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHRleHQgYmFzZWxpbmUgaXMgdGhlIHRvcCBvZiB0aGUgZW0gc3F1YXJlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJhc2VBbGlnbltCYXNlQWxpZ25bXCJUb3BcIl0gPSAwXSA9IFwiVG9wXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHRleHQgYmFzZWxpbmUgaXMgdGhlIGhhbmdpbmcgYmFzZWxpbmUuICBDdXJyZW50bHkgdW5zdXBwb3J0ZWQ7IHRoaXMgd2lsbCBhY3QgbGlrZVxyXG4gICAgICAgICAqIGFscGhhYmV0aWMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQmFzZUFsaWduW0Jhc2VBbGlnbltcIkhhbmdpbmdcIl0gPSAxXSA9IFwiSGFuZ2luZ1wiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0ZXh0IGJhc2VsaW5lIGlzIHRoZSBtaWRkbGUgb2YgdGhlIGVtIHNxdWFyZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBCYXNlQWxpZ25bQmFzZUFsaWduW1wiTWlkZGxlXCJdID0gMl0gPSBcIk1pZGRsZVwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0ZXh0IGJhc2VsaW5lIGlzIHRoZSBub3JtYWwgYWxwaGFiZXRpYyBiYXNlbGluZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBCYXNlQWxpZ25bQmFzZUFsaWduW1wiQWxwaGFiZXRpY1wiXSA9IDNdID0gXCJBbHBoYWJldGljXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHRleHQgYmFzZWxpbmUgaXMgdGhlIGlkZW9ncmFwaGljIGJhc2VsaW5lOyB0aGlzIGlzIHRoZSBib3R0b20gb2ZcclxuICAgICAgICAgKiB0aGUgYm9keSBvZiB0aGUgY2hhcmFjdGVycywgaWYgdGhlIG1haW4gYm9keSBvZiBjaGFyYWN0ZXJzIHByb3RydWRlc1xyXG4gICAgICAgICAqIGJlbmVhdGggdGhlIGFscGhhYmV0aWMgYmFzZWxpbmUuICBDdXJyZW50bHkgdW5zdXBwb3J0ZWQ7IHRoaXMgd2lsbFxyXG4gICAgICAgICAqIGFjdCBsaWtlIGFscGhhYmV0aWMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQmFzZUFsaWduW0Jhc2VBbGlnbltcIklkZW9ncmFwaGljXCJdID0gNF0gPSBcIklkZW9ncmFwaGljXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHRleHQgYmFzZWxpbmUgaXMgdGhlIGJvdHRvbSBvZiB0aGUgYm91bmRpbmcgYm94LiAgVGhpcyBkaWZmZXJzXHJcbiAgICAgICAgICogZnJvbSB0aGUgaWRlb2dyYXBoaWMgYmFzZWxpbmUgaW4gdGhhdCB0aGUgaWRlb2dyYXBoaWMgYmFzZWxpbmVcclxuICAgICAgICAgKiBkb2Vzbid0IGNvbnNpZGVyIGRlc2NlbmRlcnMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQmFzZUFsaWduW0Jhc2VBbGlnbltcIkJvdHRvbVwiXSA9IDVdID0gXCJCb3R0b21cIjtcclxuICAgIH0pKEJhc2VBbGlnbiA9IGV4cG9ydHMuQmFzZUFsaWduIHx8IChleHBvcnRzLkJhc2VBbGlnbiA9IHt9KSk7XHJcbiAgICAvKipcclxuICAgICAqIEVudW0gcmVwcmVzZW50aW5nIHRoZSBkaWZmZXJlbnQgcG9zc2libGUgZm9udCBzdHlsZXNcclxuICAgICAqL1xyXG4gICAgdmFyIEZvbnRTdHlsZTtcclxuICAgIChmdW5jdGlvbiAoRm9udFN0eWxlKSB7XHJcbiAgICAgICAgRm9udFN0eWxlW0ZvbnRTdHlsZVtcIk5vcm1hbFwiXSA9IDBdID0gXCJOb3JtYWxcIjtcclxuICAgICAgICBGb250U3R5bGVbRm9udFN0eWxlW1wiSXRhbGljXCJdID0gMV0gPSBcIkl0YWxpY1wiO1xyXG4gICAgICAgIEZvbnRTdHlsZVtGb250U3R5bGVbXCJPYmxpcXVlXCJdID0gMl0gPSBcIk9ibGlxdWVcIjtcclxuICAgIH0pKEZvbnRTdHlsZSA9IGV4cG9ydHMuRm9udFN0eWxlIHx8IChleHBvcnRzLkZvbnRTdHlsZSA9IHt9KSk7XHJcbiAgICAvKipcclxuICAgICAqIEBoaWRkZW5cclxuICAgICAqL1xyXG4gICAgdmFyIExhYmVsSW1wbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKExhYmVsSW1wbCwgX3N1cGVyKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gdGV4dCAgICAgICAgVGhlIHRleHQgb2YgdGhlIGxhYmVsXHJcbiAgICAgICAgICogQHBhcmFtIHggICAgICAgICAgIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBsYWJlbFxyXG4gICAgICAgICAqIEBwYXJhbSB5ICAgICAgICAgICBUaGUgeSBwb3NpdGlvbiBvZiB0aGUgbGFiZWxcclxuICAgICAgICAgKiBAcGFyYW0gZm9udEZhbWlseSAgVXNlIGFueSB2YWxpZCBDU1MgZm9udCBzdHJpbmcgZm9yIHRoZSBsYWJlbCdzIGZvbnQuIFdlYiBmb250cyBhcmUgc3VwcG9ydGVkLiBEZWZhdWx0IGlzIGAxMHB4IHNhbnMtc2VyaWZgLlxyXG4gICAgICAgICAqIEBwYXJhbSBzcHJpdGVGb250ICBVc2UgYW4gRXhjYWxpYnVyIHNwcml0ZSBmb250IGZvciB0aGUgbGFiZWwncyBmb250LCBpZiBhIFNwcml0ZUZvbnQgaXMgcHJvdmlkZWQgaXQgd2lsbCB0YWtlIHByZWNlZGVuY2VcclxuICAgICAgICAgKiBvdmVyIGEgY3NzIGZvbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gTGFiZWxJbXBsKHRleHRPckNvbmZpZywgeCwgeSwgZm9udEZhbWlseSwgc3ByaXRlRm9udCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0ZXh0T3JDb25maWcgJiYgdHlwZW9mIHRleHRPckNvbmZpZyA9PT0gJ29iamVjdCcgPyB7XHJcbiAgICAgICAgICAgICAgICB4OiB0ZXh0T3JDb25maWcueCxcclxuICAgICAgICAgICAgICAgIHk6IHRleHRPckNvbmZpZy55XHJcbiAgICAgICAgICAgIH0gOiB7IHg6IHgsIHk6IHkgfSkgfHwgdGhpcztcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHMgb3IgZ2V0cyB0aGUgYm9sZCBwcm9wZXJ0eSBvZiB0aGUgbGFiZWwncyB0ZXh0LCBieSBkZWZhdWx0IGl0J3MgZmFsc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmJvbGQgPSBmYWxzZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBmb250IHNpemUgaW4gdGhlIHNlbGVjdGVkIHVuaXRzLCBkZWZhdWx0IGlzIDEwIChkZWZhdWx0IHVuaXRzIGlzIHBpeGVsKVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuZm9udFNpemUgPSAxMDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBmb250IHN0eWxlIGZvciB0aGlzIGxhYmVsLCB0aGUgZGVmYXVsdCBpcyBbW0ZvbnRTdHlsZS5Ob3JtYWxdXVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuZm9udFN0eWxlID0gRm9udFN0eWxlLk5vcm1hbDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBjc3MgdW5pdHMgZm9yIGEgZm9udCBzaXplIHN1Y2ggYXMgcHgsIHB0LCBlbSAoU3ByaXRlRm9udCBvbmx5IHN1cHBvcnQgcHgpLCBieSBkZWZhdWx0IGlzICdweCc7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5mb250VW5pdCA9IEZvbnRVbml0LlB4O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBob3Jpem9udGFsIHRleHQgYWxpZ25tZW50IHByb3BlcnR5IGZvciB0aGUgbGFiZWwuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy50ZXh0QWxpZ24gPSBUZXh0QWxpZ24uTGVmdDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgYmFzZWxpbmUgYWxpZ25tZW50IHByb3BlcnR5IGZvciB0aGUgbGFiZWwuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5iYXNlQWxpZ24gPSBCYXNlQWxpZ24uQm90dG9tO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBsZXR0ZXIgc3BhY2luZyBvbiBhIExhYmVsLiBPbmx5IHN1cHBvcnRlZCB3aXRoIFNwcml0ZSBGb250cy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmxldHRlclNwYWNpbmcgPSAwOyAvL3B4XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgW1tTcHJpdGVGb250XV0gd2lsbCBiZSBjYXNlLXNlbnNpdGl2ZSB3aGVuIG1hdGNoaW5nIGNoYXJhY3RlcnMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5jYXNlSW5zZW5zaXRpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB2YXIgdGV4dCA9ICcnO1xyXG4gICAgICAgICAgICBpZiAodGV4dE9yQ29uZmlnICYmIHR5cGVvZiB0ZXh0T3JDb25maWcgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICBmb250RmFtaWx5ID0gdGV4dE9yQ29uZmlnLmZvbnRGYW1pbHk7XHJcbiAgICAgICAgICAgICAgICBzcHJpdGVGb250ID0gdGV4dE9yQ29uZmlnLnNwcml0ZUZvbnQ7XHJcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dE9yQ29uZmlnLnRleHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dE9yQ29uZmlnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzLnRleHQgPSB0ZXh0IHx8ICcnO1xyXG4gICAgICAgICAgICBfdGhpcy5jb2xvciA9IENvbG9yXzExLkNvbG9yLkJsYWNrLmNsb25lKCk7XHJcbiAgICAgICAgICAgIF90aGlzLnNwcml0ZUZvbnQgPSBzcHJpdGVGb250O1xyXG4gICAgICAgICAgICBfdGhpcy5jb2xsaXNpb25UeXBlID0gQWN0b3JfNC5Db2xsaXNpb25UeXBlLlByZXZlbnRDb2xsaXNpb247XHJcbiAgICAgICAgICAgIF90aGlzLmZvbnRGYW1pbHkgPSBmb250RmFtaWx5IHx8ICdzYW5zLXNlcmlmJzsgLy8gY29hbGVzY2UgdG8gZGVmYXVsdCBjYW52YXMgZm9udFxyXG4gICAgICAgICAgICBfdGhpcy5fdGV4dFNoYWRvd09uID0gZmFsc2U7XHJcbiAgICAgICAgICAgIF90aGlzLl9zaGFkb3dPZmZzZXRYID0gMDtcclxuICAgICAgICAgICAgX3RoaXMuX3NoYWRvd09mZnNldFkgPSAwO1xyXG4gICAgICAgICAgICBpZiAoc3ByaXRlRm9udCkge1xyXG4gICAgICAgICAgICAgICAgLy90aGlzLl90ZXh0U3ByaXRlcyA9IHNwcml0ZUZvbnQuZ2V0VGV4dFNwcml0ZXMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSB0ZXh0IGluIHRoZSBsYWJlbCAoaW4gcGl4ZWxzKTtcclxuICAgICAgICAgKiBAcGFyYW0gY3R4ICBSZW5kZXJpbmcgY29udGV4dCB0byBtZWFzdXJlIHRoZSBzdHJpbmcgd2l0aFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExhYmVsSW1wbC5wcm90b3R5cGUuZ2V0VGV4dFdpZHRoID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gICAgICAgICAgICB2YXIgb2xkRm9udCA9IGN0eC5mb250O1xyXG4gICAgICAgICAgICBjdHguZm9udCA9IHRoaXMuX2ZvbnRTdHJpbmc7XHJcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGN0eC5tZWFzdXJlVGV4dCh0aGlzLnRleHQpLndpZHRoO1xyXG4gICAgICAgICAgICBjdHguZm9udCA9IG9sZEZvbnQ7XHJcbiAgICAgICAgICAgIHJldHVybiB3aWR0aDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIFR5cGVTY3JpcHQgZG9lc24ndCBzdXBwb3J0IHN0cmluZyBlbnVtcyA6KFxyXG4gICAgICAgIExhYmVsSW1wbC5wcm90b3R5cGUuX2xvb2t1cEZvbnRVbml0ID0gZnVuY3Rpb24gKGZvbnRVbml0KSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoZm9udFVuaXQpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgRm9udFVuaXQuRW06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdlbSc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEZvbnRVbml0LlJlbTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3JlbSc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEZvbnRVbml0LlB0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAncHQnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBGb250VW5pdC5QeDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3B4JztcclxuICAgICAgICAgICAgICAgIGNhc2UgRm9udFVuaXQuUGVyY2VudDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyUnO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3B4JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgTGFiZWxJbXBsLnByb3RvdHlwZS5fbG9va3VwVGV4dEFsaWduID0gZnVuY3Rpb24gKHRleHRBbGlnbikge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRleHRBbGlnbikge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBUZXh0QWxpZ24uTGVmdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2xlZnQnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBUZXh0QWxpZ24uUmlnaHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdyaWdodCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFRleHRBbGlnbi5DZW50ZXI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdjZW50ZXInO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBUZXh0QWxpZ24uRW5kOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnZW5kJztcclxuICAgICAgICAgICAgICAgIGNhc2UgVGV4dEFsaWduLlN0YXJ0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnc3RhcnQnO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3N0YXJ0JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgTGFiZWxJbXBsLnByb3RvdHlwZS5fbG9va3VwQmFzZUFsaWduID0gZnVuY3Rpb24gKGJhc2VBbGlnbikge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGJhc2VBbGlnbikge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBCYXNlQWxpZ24uQWxwaGFiZXRpYzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2FscGhhYmV0aWMnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBCYXNlQWxpZ24uQm90dG9tOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnYm90dG9tJztcclxuICAgICAgICAgICAgICAgIGNhc2UgQmFzZUFsaWduLkhhbmdpbmc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdoYW5naW4nO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBCYXNlQWxpZ24uSWRlb2dyYXBoaWM6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdpZGVvZ3JhcGhpYyc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEJhc2VBbGlnbi5NaWRkbGU6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdtaWRkbGUnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBCYXNlQWxpZ24uVG9wOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndG9wJztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdhbHBoYWJldGljJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgTGFiZWxJbXBsLnByb3RvdHlwZS5fbG9va3VwRm9udFN0eWxlID0gZnVuY3Rpb24gKGZvbnRTdHlsZSkge1xyXG4gICAgICAgICAgICB2YXIgYm9sZHN0cmluZyA9IHRoaXMuYm9sZCA/ICcgYm9sZCcgOiAnJztcclxuICAgICAgICAgICAgc3dpdGNoIChmb250U3R5bGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgRm9udFN0eWxlLkl0YWxpYzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2l0YWxpYycgKyBib2xkc3RyaW5nO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBGb250U3R5bGUuTm9ybWFsOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnbm9ybWFsJyArIGJvbGRzdHJpbmc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEZvbnRTdHlsZS5PYmxpcXVlOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnb2JsaXF1ZScgKyBib2xkc3RyaW5nO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ25vcm1hbCcgKyBib2xkc3RyaW5nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSB0ZXh0IHNoYWRvdyBmb3Igc3ByaXRlIGZvbnRzXHJcbiAgICAgICAgICogQHBhcmFtIG9mZnNldFggICAgICBUaGUgeCBvZmZzZXQgaW4gcGl4ZWxzIHRvIHBsYWNlIHRoZSBzaGFkb3dcclxuICAgICAgICAgKiBAcGFyYW0gb2Zmc2V0WSAgICAgIFRoZSB5IG9mZnNldCBpbiBwaXhlbHMgdG8gcGxhY2UgdGhlIHNoYWRvd1xyXG4gICAgICAgICAqIEBwYXJhbSBzaGFkb3dDb2xvciAgVGhlIGNvbG9yIG9mIHRoZSB0ZXh0IHNoYWRvd1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExhYmVsSW1wbC5wcm90b3R5cGUuc2V0VGV4dFNoYWRvdyA9IGZ1bmN0aW9uIChvZmZzZXRYLCBvZmZzZXRZLCBzaGFkb3dDb2xvcikge1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZUZvbnQuc2V0VGV4dFNoYWRvdyhvZmZzZXRYLCBvZmZzZXRZLCBzaGFkb3dDb2xvcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUb2dnbGVzIHRleHQgc2hhZG93cyBvbiBvciBvZmYsIG9ubHkgYXBwbGllcyB3aGVuIHVzaW5nIHNwcml0ZSBmb250c1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExhYmVsSW1wbC5wcm90b3R5cGUudXNlVGV4dFNoYWRvdyA9IGZ1bmN0aW9uIChvbikge1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZUZvbnQudXNlVGV4dFNoYWRvdyhvbik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDbGVhcnMgdGhlIGN1cnJlbnQgdGV4dCBzaGFkb3dcclxuICAgICAgICAgKi9cclxuICAgICAgICBMYWJlbEltcGwucHJvdG90eXBlLmNsZWFyVGV4dFNoYWRvdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fdGV4dFNoYWRvd09uID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3NoYWRvd09mZnNldFggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9zaGFkb3dPZmZzZXRZID0gMDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIExhYmVsSW1wbC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGVuZ2luZSwgZGVsdGEpIHtcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzLCBlbmdpbmUsIGRlbHRhKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIExhYmVsSW1wbC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjdHgsIGRlbHRhKSB7XHJcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUodGhpcy5wb3MueCwgdGhpcy5wb3MueSk7XHJcbiAgICAgICAgICAgIGN0eC5zY2FsZSh0aGlzLnNjYWxlLngsIHRoaXMuc2NhbGUueSk7XHJcbiAgICAgICAgICAgIGN0eC5yb3RhdGUodGhpcy5yb3RhdGlvbik7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl90ZXh0U2hhZG93T24pIHtcclxuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHRoaXMuX3NoYWRvd09mZnNldFgsIHRoaXMuX3NoYWRvd09mZnNldFkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZm9udERyYXcoY3R4KTtcclxuICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fZm9udERyYXcoY3R4KTtcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kcmF3LmNhbGwodGhpcywgY3R4LCBkZWx0YSk7XHJcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBMYWJlbEltcGwucHJvdG90eXBlLl9mb250RHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc3ByaXRlRm9udCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVGb250LmRyYXcoY3R4LCB0aGlzLnRleHQsIDAsIDAsIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogdGhpcy5jb2xvci5jbG9uZSgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGJhc2VBbGlnbjogdGhpcy5iYXNlQWxpZ24sXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dEFsaWduOiB0aGlzLnRleHRBbGlnbixcclxuICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogdGhpcy5mb250U2l6ZSxcclxuICAgICAgICAgICAgICAgICAgICBsZXR0ZXJTcGFjaW5nOiB0aGlzLmxldHRlclNwYWNpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogdGhpcy5vcGFjaXR5XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBvbGRBbGlnbiA9IGN0eC50ZXh0QWxpZ247XHJcbiAgICAgICAgICAgICAgICB2YXIgb2xkVGV4dEJhc2VsaW5lID0gY3R4LnRleHRCYXNlbGluZTtcclxuICAgICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSB0aGlzLl9sb29rdXBUZXh0QWxpZ24odGhpcy50ZXh0QWxpZ24pO1xyXG4gICAgICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IHRoaXMuX2xvb2t1cEJhc2VBbGlnbih0aGlzLmJhc2VBbGlnbik7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb2xvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sb3IuYSA9IHRoaXMub3BhY2l0eTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmNvbG9yLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBjdHguZm9udCA9IHRoaXMuX2ZvbnRTdHJpbmc7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXhXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dCh0aGlzLnRleHQsIDAsIDAsIHRoaXMubWF4V2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KHRoaXMudGV4dCwgMCwgMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjdHgudGV4dEFsaWduID0gb2xkQWxpZ247XHJcbiAgICAgICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gb2xkVGV4dEJhc2VsaW5lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGFiZWxJbXBsLnByb3RvdHlwZSwgXCJfZm9udFN0cmluZ1wiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvb2t1cEZvbnRTdHlsZSh0aGlzLmZvbnRTdHlsZSkgKyBcIiBcIiArIHRoaXMuZm9udFNpemUgKyB0aGlzLl9sb29rdXBGb250VW5pdCh0aGlzLmZvbnRVbml0KSArIFwiIFwiICsgdGhpcy5mb250RmFtaWx5O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBMYWJlbEltcGwucHJvdG90eXBlLmRlYnVnRHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kZWJ1Z0RyYXcuY2FsbCh0aGlzLCBjdHgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIExhYmVsSW1wbDtcclxuICAgIH0oQWN0b3JfNC5BY3RvcikpO1xyXG4gICAgZXhwb3J0cy5MYWJlbEltcGwgPSBMYWJlbEltcGw7XHJcbiAgICAvKipcclxuICAgICAqIExhYmVscyBhcmUgdGhlIHdheSB0byBkcmF3IHNtYWxsIGFtb3VudHMgb2YgdGV4dCB0byB0aGUgc2NyZWVuLiBUaGV5IGFyZVxyXG4gICAgICogYWN0b3JzIGFuZCBpbmhlcml0IGFsbCBvZiB0aGUgYmVuZWZpdHMgYW5kIGNhcGFiaWxpdGllcy5cclxuICAgICAqXHJcbiAgICAgKiBbW2luY2x1ZGU6TGFiZWxzLm1kXV1cclxuICAgICAqL1xyXG4gICAgdmFyIExhYmVsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoTGFiZWwsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gTGFiZWwodGV4dE9yQ29uZmlnLCB4LCB5LCBmb250RmFtaWx5LCBzcHJpdGVGb250KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB0ZXh0T3JDb25maWcsIHgsIHksIGZvbnRGYW1pbHksIHNwcml0ZUZvbnQpIHx8IHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBMYWJlbDtcclxuICAgIH0oQ29uZmlndXJhYmxlXzQuQ29uZmlndXJhYmxlKExhYmVsSW1wbCkpKTtcclxuICAgIGV4cG9ydHMuTGFiZWwgPSBMYWJlbDtcclxufSk7XHJcbmRlZmluZShcIkludGVyZmFjZXMvSUF1ZGlvXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbn0pO1xyXG5kZWZpbmUoXCJJbnRlcmZhY2VzL0lBdWRpb0ltcGxlbWVudGF0aW9uXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbn0pO1xyXG5kZWZpbmUoXCJSZXNvdXJjZXMvU291bmRcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJVdGlsL0xvZ1wiLCBcIlV0aWwvVXRpbFwiLCBcIlByb21pc2VzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgTG9nXzUsIFV0aWwsIFByb21pc2VzXzUpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLy8gc2V0IHVwIGF1ZGlvIGNvbnRleHQgcmVmZXJlbmNlXHJcbiAgICAvLyB3aGVuIHdlIGludHJvZHVjZSBtdWx0aS10cmFja2luZywgd2UgbWF5IG5lZWQgdG8gbW92ZSB0aGlzIHRvIGEgZmFjdG9yeSBtZXRob2RcclxuICAgIGlmICh3aW5kb3cuQXVkaW9Db250ZXh0KSB7XHJcbiAgICAgICAgdmFyIGF1ZGlvQ29udGV4dCA9IG5ldyB3aW5kb3cuQXVkaW9Db250ZXh0KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFuIGF1ZGlvIGltcGxlbWVudGF0aW9uIGZvciBIVE1MNSBhdWRpby5cclxuICAgICAqL1xyXG4gICAgdmFyIEF1ZGlvVGFnID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBBdWRpb1RhZygpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXNwb25zZVR5cGUgPSAnYmxvYic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRyYW5zZm9ybXMgcmF3IEJsb2IgZGF0YSBpbnRvIGEgb2JqZWN0IFVSTCBmb3IgdXNlIGluIGF1ZGlvIHRhZ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEF1ZGlvVGFnLnByb3RvdHlwZS5wcm9jZXNzRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGRhdGEpO1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZXNfNS5Qcm9taXNlLnJlc29sdmUodXJsKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYW4gYXVkaW8gdGFnIHJlZmVyZW5jaW5nIHRoZSBwcm92aWRlZCBhdWRpbyBVUkxcclxuICAgICAgICAgKi9cclxuICAgICAgICBBdWRpb1RhZy5wcm90b3R5cGUuY3JlYXRlSW5zdGFuY2UgPSBmdW5jdGlvbiAodXJsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXVkaW9UYWdJbnN0YW5jZSh1cmwpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEF1ZGlvVGFnO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuQXVkaW9UYWcgPSBBdWRpb1RhZztcclxuICAgIC8qKlxyXG4gICAgICogQW4gYXVkaW8gaW1wbGVtZW50YXRpb24gZm9yIFdlYiBBdWRpbyBBUEkuXHJcbiAgICAgKi9cclxuICAgIHZhciBXZWJBdWRpbyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gV2ViQXVkaW8oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlciA9IExvZ181LkxvZ2dlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgICAgICB0aGlzLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByb2Nlc3NlcyByYXcgYXJyYXlidWZmZXIgZGF0YSBhbmQgZGVjb2RlcyBpbnRvIFdlYkF1ZGlvIGJ1ZmZlciAoYXN5bmMpLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFdlYkF1ZGlvLnByb3RvdHlwZS5wcm9jZXNzRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBjb21wbGV0ZSA9IG5ldyBQcm9taXNlc181LlByb21pc2UoKTtcclxuICAgICAgICAgICAgYXVkaW9Db250ZXh0LmRlY29kZUF1ZGlvRGF0YShkYXRhLCBmdW5jdGlvbiAoYnVmZmVyKSB7XHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZS5yZXNvbHZlKGJ1ZmZlcik7XHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuZXJyb3IoJ1VuYWJsZSB0byBkZWNvZGUgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJyB0aGlzIGJyb3dzZXIgbWF5IG5vdCBmdWxseSBzdXBwb3J0IHRoaXMgZm9ybWF0LCBvciB0aGUgZmlsZSBtYXkgYmUgY29ycnVwdCwgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ2lmIHRoaXMgaXMgYW4gbXAzIHRyeSByZW1vdmluZyBpZDMgdGFncyBhbmQgYWxidW0gYXJ0IGZyb20gdGhlIGZpbGUuJyk7XHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZS5yZXNvbHZlKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gY29tcGxldGU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IFdlYkF1ZGlvIEF1ZGlvQnVmZmVyU291cmNlTm9kZSB0byBwbGF5IGEgc291bmQgaW5zdGFuY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBXZWJBdWRpby5wcm90b3R5cGUuY3JlYXRlSW5zdGFuY2UgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgV2ViQXVkaW9JbnN0YW5jZShidWZmZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGxheSBhbiBlbXB0eSBzb3VuZCB0byB1bmxvY2sgU2FmYXJpIFdlYkF1ZGlvIGNvbnRleHQuIENhbGwgdGhpcyBmdW5jdGlvblxyXG4gICAgICAgICAqIHJpZ2h0IGFmdGVyIGEgdXNlciBpbnRlcmFjdGlvbiBldmVudC4gVHlwaWNhbGx5IHVzZWQgYnkgW1tQYXVzZUFmdGVyTG9hZGVyXV1cclxuICAgICAgICAgKiBAc291cmNlIGh0dHBzOi8vcGF1bGJha2F1cy5jb20vdHV0b3JpYWxzL2h0bWw1L3dlYi1hdWRpby1vbi1pb3MvXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgV2ViQXVkaW8udW5sb2NrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoV2ViQXVkaW8uX3VubG9ja2VkIHx8ICFhdWRpb0NvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjcmVhdGUgZW1wdHkgYnVmZmVyIGFuZCBwbGF5IGl0XHJcbiAgICAgICAgICAgIHZhciBidWZmZXIgPSBhdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyKDEsIDEsIDIyMDUwKTtcclxuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcclxuICAgICAgICAgICAgdmFyIGVuZGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHNvdXJjZS5idWZmZXIgPSBidWZmZXI7XHJcbiAgICAgICAgICAgIHNvdXJjZS5jb25uZWN0KGF1ZGlvQ29udGV4dC5kZXN0aW5hdGlvbik7XHJcbiAgICAgICAgICAgIHNvdXJjZS5vbmVuZGVkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZW5kZWQgPSB0cnVlOyB9O1xyXG4gICAgICAgICAgICBpZiAoc291cmNlLm5vdGVPbikge1xyXG4gICAgICAgICAgICAgICAgLy8gZGVwcmVjYXRlZFxyXG4gICAgICAgICAgICAgICAgc291cmNlLm5vdGVPbigwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNvdXJjZS5zdGFydCgwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBieSBjaGVja2luZyB0aGUgcGxheSBzdGF0ZSBhZnRlciBzb21lIHRpbWUsIHdlIGtub3cgaWYgd2UncmUgcmVhbGx5IHVubG9ja2VkXHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5wbGF5YmFja1N0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlZ2FjeVNvdXJjZSA9IHNvdXJjZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGVnYWN5U291cmNlLnBsYXliYWNrU3RhdGUgPT09IGxlZ2FjeVNvdXJjZS5QTEFZSU5HX1NUQVRFIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZ2FjeVNvdXJjZS5wbGF5YmFja1N0YXRlID09PSBsZWdhY3lTb3VyY2UuRklOSVNIRURfU1RBVEUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgV2ViQXVkaW8uX3VubG9ja2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lID4gMCB8fCBlbmRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBXZWJBdWRpby5fdW5sb2NrZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBXZWJBdWRpby5pc1VubG9ja2VkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdW5sb2NrZWQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gV2ViQXVkaW87XHJcbiAgICB9KCkpO1xyXG4gICAgV2ViQXVkaW8uX3VubG9ja2VkID0gZmFsc2U7XHJcbiAgICBleHBvcnRzLldlYkF1ZGlvID0gV2ViQXVkaW87XHJcbiAgICAvKipcclxuICAgICAqIEZhY3RvcnkgbWV0aG9kIHRoYXQgZ2V0cyB0aGUgYXVkaW8gaW1wbGVtZW50YXRpb24gdG8gdXNlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldEF1ZGlvSW1wbGVtZW50YXRpb24oKSB7XHJcbiAgICAgICAgaWYgKHdpbmRvdy5BdWRpb0NvbnRleHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBXZWJBdWRpbygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBdWRpb1RhZygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGV4cG9ydHMuZ2V0QXVkaW9JbXBsZW1lbnRhdGlvbiA9IGdldEF1ZGlvSW1wbGVtZW50YXRpb247XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBbW1NvdW5kXV0gb2JqZWN0IGFsbG93cyBnYW1lcyBidWlsdCBpbiBFeGNhbGlidXIgdG8gbG9hZCBhdWRpb1xyXG4gICAgICogY29tcG9uZW50cywgZnJvbSBzb3VuZHRyYWNrcyB0byBzb3VuZCBlZmZlY3RzLiBbW1NvdW5kXV0gaXMgYW4gW1tJTG9hZGFibGVdXVxyXG4gICAgICogd2hpY2ggbWVhbnMgaXQgY2FuIGJlIHBhc3NlZCB0byBhIFtbTG9hZGVyXV0gdG8gcHJlLWxvYWQgYmVmb3JlIGEgZ2FtZSBvciBsZXZlbC5cclxuICAgICAqXHJcbiAgICAgKiBbW2luY2x1ZGU6U291bmRzLm1kXV1cclxuICAgICAqL1xyXG4gICAgdmFyIFNvdW5kID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gcGF0aHMgQSBsaXN0IG9mIGF1ZGlvIHNvdXJjZXMgKGNsaXAud2F2LCBjbGlwLm1wMywgY2xpcC5vZ2cpIGZvciB0aGlzIGF1ZGlvIGNsaXAuIFRoaXMgaXMgZG9uZSBmb3IgYnJvd3NlciBjb21wYXRpYmlsaXR5LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIFNvdW5kKCkge1xyXG4gICAgICAgICAgICB2YXIgcGF0aHMgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHBhdGhzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyID0gTG9nXzUuTG9nZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl90cmFja3MgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5faXNMb2FkZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl92b2x1bWUgPSAxLjA7XHJcbiAgICAgICAgICAgIHRoaXMub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuOyB9O1xyXG4gICAgICAgICAgICB0aGlzLm9uY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybjsgfTtcclxuICAgICAgICAgICAgdGhpcy5vbmVycm9yID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XHJcbiAgICAgICAgICAgIHRoaXMuX3dhc1BsYXlpbmdPbkhpZGRlbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKiBDaHJvbWUgOiBNUDMsIFdBViwgT2dnXHJcbiAgICAgICAgICAgICAgICogRmlyZWZveCA6IFdBViwgT2dnLFxyXG4gICAgICAgICAgICAgICAqIElFIDogTVAzLCBXQVYgY29taW5nIHNvb25cclxuICAgICAgICAgICAgICAgKiBTYWZhcmkgTVAzLCBXQVYsIE9nZ1xyXG4gICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnBhdGggPSAnJztcclxuICAgICAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBwYXRoc18xID0gcGF0aHM7IF9hIDwgcGF0aHNfMS5sZW5ndGg7IF9hKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXRoID0gcGF0aHNfMVtfYV07XHJcbiAgICAgICAgICAgICAgICBpZiAoU291bmQuY2FuUGxheUZpbGUocGF0aCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXRoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIud2FybignVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgYW55IG9mIHRoZSBhdWRpbyBmaWxlcyBzcGVjaWZpZWQ6JywgcGF0aHMuam9pbignLCAnKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIud2FybignQXR0ZW1wdGluZyB0byB1c2UnLCBwYXRoc1swXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGggPSBwYXRoc1swXTsgLy8gc2VsZWN0IHRoZSBmaXJzdCBzcGVjaWZpZWRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNvdW5kID0gZ2V0QXVkaW9JbXBsZW1lbnRhdGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgYnJvd3NlciBjYW4gcGxheSB0aGlzIGZpbGUgYXMgSFRNTDUgQXVkaW9cclxuICAgICAgICAgKi9cclxuICAgICAgICBTb3VuZC5jYW5QbGF5RmlsZSA9IGZ1bmN0aW9uIChmaWxlKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYSA9IG5ldyBBdWRpbygpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZpbGV0eXBlID0gLy4qXFwuKFtBLVphLXowLTldKykkLztcclxuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gZmlsZS5tYXRjaChmaWxldHlwZSlbMV07XHJcbiAgICAgICAgICAgICAgICBpZiAoYS5jYW5QbGF5VHlwZSgnYXVkaW8vJyArIHR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIExvZ181LkxvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4oJ0Nhbm5vdCBkZXRlcm1pbmUgYXVkaW8gc3VwcG9ydCwgYXNzdW1pbmcgbm8gc3VwcG9ydCBmb3IgdGhlIEF1ZGlvIFRhZycsIGUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTb3VuZC5wcm90b3R5cGUud2lyZUVuZ2luZSA9IGZ1bmN0aW9uIChlbmdpbmUpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKGVuZ2luZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZW5naW5lID0gZW5naW5lO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZW5naW5lLm9uKCdoaWRkZW4nLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZ2luZS5wYXVzZUF1ZGlvV2hlbkhpZGRlbiAmJiBfdGhpcy5pc1BsYXlpbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fd2FzUGxheWluZ09uSGlkZGVuID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucGF1c2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VuZ2luZS5vbigndmlzaWJsZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZW5naW5lLnBhdXNlQXVkaW9XaGVuSGlkZGVuICYmIF90aGlzLl93YXNQbGF5aW5nT25IaWRkZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucGxheSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fd2FzUGxheWluZ09uSGlkZGVuID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgaG93IG1hbnkgaW5zdGFuY2VzIG9mIHRoZSBzb3VuZCBhcmUgY3VycmVudGx5IHBsYXlpbmdcclxuICAgICAgICAgKi9cclxuICAgICAgICBTb3VuZC5wcm90b3R5cGUuaW5zdGFuY2VDb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYWNrcy5sZW5ndGg7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSB2b2x1bWUgb2YgdGhlIHNvdW5kIGNsaXBcclxuICAgICAgICAgKiBAcGFyYW0gdm9sdW1lICBBIHZvbHVtZSB2YWx1ZSBiZXR3ZWVuIDAtMS4wXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU291bmQucHJvdG90eXBlLnNldFZvbHVtZSA9IGZ1bmN0aW9uICh2b2x1bWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fdm9sdW1lID0gdm9sdW1lO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5fdHJhY2tzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRyYWNrID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgdHJhY2suc2V0Vm9sdW1lKHZvbHVtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCdTZXQgdm9sdW1lIGZvciBhbGwgaW5zdGFuY2VzIG9mIHNvdW5kJywgdGhpcy5wYXRoLCAndG8nLCB2b2x1bWUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGNsaXAgc2hvdWxkIGxvb3Agd2hlbiBjb21wbGV0ZVxyXG4gICAgICAgICAqIEBwYXJhbSBsb29wICBTZXQgdGhlIGxvb3BpbmcgZmxhZ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNvdW5kLnByb3RvdHlwZS5zZXRMb29wID0gZnVuY3Rpb24gKGxvb3ApIHtcclxuICAgICAgICAgICAgdGhpcy5fbG9vcCA9IGxvb3A7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl90cmFja3M7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHJhY2sgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICB0cmFjay5zZXRMb29wKGxvb3ApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZygnU2V0IGxvb3AgZm9yIGFsbCBpbnN0YW5jZXMgb2Ygc291bmQnLCB0aGlzLnBhdGgsICd0bycsIGxvb3ApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIHNvdW5kIGlzIHBsYXlpbmcgcmlnaHQgbm93XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU291bmQucHJvdG90eXBlLmlzUGxheWluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYWNrcy5zb21lKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0LmlzUGxheWluZygpOyB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBsYXkgdGhlIHNvdW5kLCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIHNvdW5kIGlzIGRvbmUgcGxheWluZ1xyXG4gICAgICAgICAqIEFuIG9wdGlvbmFsIHZvbHVtZSBhcmd1bWVudCBjYW4gYmUgcGFzc2VkIGluIHRvIHBsYXkgdGhlIHNvdW5kLiBNYXggdm9sdW1lIGlzIDEuMFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNvdW5kLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKHZvbHVtZSkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNMb2FkZWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXN1bWVkID0gW107XHJcbiAgICAgICAgICAgICAgICAvLyBlbnN1cmUgd2UgcmVzdW1lICpjdXJyZW50KiB0cmFja3MgKGlmIHBhdXNlZClcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl90cmFja3M7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYWNrID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VtZWQucHVzaCh0cmFjay5wbGF5KCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gd2hlbiBwYXVzZWQsIGRvbid0IHN0YXJ0IHBsYXlpbmcgbmV3IHRyYWNrXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNQYXVzZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZygnUmVzdW1pbmcgcGF1c2VkIGluc3RhbmNlcyBmb3Igc291bmQnLCB0aGlzLnBhdGgsIHRoaXMuX3RyYWNrcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzb2x2ZSB3aGVuIHJlc3VtZWQgdHJhY2tzIGFyZSBkb25lXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2VzXzUuUHJvbWlzZS5qb2luKHJlc3VtZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gcHVzaCBhIG5ldyB0cmFja1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld1RyYWNrID0gdGhpcy5zb3VuZC5jcmVhdGVJbnN0YW5jZSh0aGlzLl9kYXRhKTtcclxuICAgICAgICAgICAgICAgIG5ld1RyYWNrLnNldExvb3AodGhpcy5fbG9vcCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodm9sdW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3VHJhY2suc2V0Vm9sdW1lKFV0aWwuY2xhbXAodm9sdW1lLCAwLjAsIDEuMCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3VHJhY2suc2V0Vm9sdW1lKHRoaXMuX3ZvbHVtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFja3MucHVzaChuZXdUcmFjayk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoJ1BsYXlpbmcgbmV3IGluc3RhbmNlIGZvciBzb3VuZCcsIHRoaXMucGF0aCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3VHJhY2sucGxheSgpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gZG9uZSwgcmVtb3ZlIHRyYWNrXHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3RyYWNrcy5zcGxpY2UoX3RoaXMuX3RyYWNrcy5pbmRleE9mKG5ld1RyYWNrKSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlc181LlByb21pc2UucmVzb2x2ZSh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3RvcCB0aGUgc291bmQsIGFuZCBkbyBub3QgcmV3aW5kXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU291bmQucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5fdHJhY2tzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRyYWNrID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgdHJhY2sucGF1c2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZygnUGF1c2VkIGFsbCBpbnN0YW5jZXMgb2Ygc291bmQnLCB0aGlzLnBhdGgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3RvcCB0aGUgc291bmQgYW5kIHJld2luZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNvdW5kLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB2YXIgdHJhY2tzID0gdGhpcy5fdHJhY2tzLmNvbmNhdChbXSk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgdHJhY2tzXzEgPSB0cmFja3M7IF9pIDwgdHJhY2tzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHJhY2sgPSB0cmFja3NfMVtfaV07XHJcbiAgICAgICAgICAgICAgICB0cmFjay5zdG9wKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCdTdG9wcGVkIGFsbCBpbnN0YW5jZXMgb2Ygc291bmQnLCB0aGlzLnBhdGgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzb3VuZCBpcyBsb2FkZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBTb3VuZC5wcm90b3R5cGUuaXNMb2FkZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc0xvYWRlZDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJlZ2lucyBsb2FkaW5nIHRoZSBzb3VuZCBhbmQgcmV0dXJucyBhIHByb21pc2UgdG8gYmUgcmVzb2x2ZWQgb24gY29tcGxldGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNvdW5kLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgY29tcGxldGUgPSBuZXcgUHJvbWlzZXNfNS5Qcm9taXNlKCk7XHJcbiAgICAgICAgICAgIGlmICghIXRoaXMuZ2V0RGF0YSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoJ0FscmVhZHkgaGF2ZSBkYXRhIGZvciBhdWRpbyByZXNvdXJjZScsIHRoaXMucGF0aCk7XHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZS5yZXNvbHZlKHRoaXMuc291bmQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbmNvbXBsZXRlKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGxldGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCdTdGFydGVkIGxvYWRpbmcgc291bmQnLCB0aGlzLnBhdGgpO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZmV0Y2hSZXNvdXJjZShmdW5jdGlvbiAocmVxdWVzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyAhPT0gMjAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGF1ZGlvIHJlc291cmNlICcsIF90aGlzLnBhdGgsICcgc2VydmVyIHJlc3BvbmRlZCB3aXRoIGVycm9yIGNvZGUnLCByZXF1ZXN0LnN0YXR1cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9uZXJyb3IocmVxdWVzdC5yZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlLnJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9hZCBzb3VuZFxyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldERhdGEocmVxdWVzdC5yZXNwb25zZSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9uY29tcGxldGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci5kZWJ1ZygnQ29tcGxldGVkIGxvYWRpbmcgc291bmQnLCBfdGhpcy5wYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGUucmVzb2x2ZShfdGhpcy5zb3VuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGNvbXBsZXRlLnJlc29sdmUoZSk7IH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcignRXJyb3IgbG9hZGluZyBzb3VuZCEgSWYgdGhpcyBpcyBhIGNyb3NzIG9yaWdpbiBlcnJvciwgXFxcclxuICAgICAgICAgICAgeW91IG11c3QgaG9zdCB5b3VyIHNvdW5kIHdpdGggeW91ciBodG1sIGFuZCBqYXZhc2NyaXB0LicpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbmVycm9yKGUpO1xyXG4gICAgICAgICAgICAgICAgY29tcGxldGUucmVzb2x2ZShlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY29tcGxldGU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIFNvdW5kLnByb3RvdHlwZS5fZmV0Y2hSZXNvdXJjZSA9IGZ1bmN0aW9uIChvbmxvYWQpIHtcclxuICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICAgICAgcmVxdWVzdC5vcGVuKCdHRVQnLCB0aGlzLnBhdGgsIHRydWUpO1xyXG4gICAgICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IHRoaXMuc291bmQucmVzcG9uc2VUeXBlO1xyXG4gICAgICAgICAgICByZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSB0aGlzLm9ucHJvZ3Jlc3M7XHJcbiAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9IHRoaXMub25lcnJvcjtcclxuICAgICAgICAgICAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBvbmxvYWQocmVxdWVzdCk7IH07XHJcbiAgICAgICAgICAgIHJlcXVlc3Quc2VuZCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgcmF3IHNvdW5kIGRhdGEgKGUuZy4gYmxvYiBVUkwgb3IgQXVkaW9CdWZmZXIpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU291bmQucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyByYXcgc291bmQgZGF0YSBhbmQgcmV0dXJucyBhIFByb21pc2UgdGhhdCBpcyByZXNvbHZlZCB3aGVuIHNvdW5kIGRhdGEgaXMgcHJvY2Vzc2VkXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gZGF0YSBUaGUgWEhSIGRhdGEgZm9yIHRoZSBzb3VuZCBpbXBsZW1lbnRhdGlvbiB0byBwcm9jZXNzIChCbG9iIG9yIEFycmF5QnVmZmVyKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNvdW5kLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc291bmQucHJvY2Vzc0RhdGEoZGF0YSkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2lzTG9hZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9kYXRhID0gX3RoaXMucHJvY2Vzc0RhdGEoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXQgdGhlIHJhdyBzb3VuZCBkYXRhIChlLmcuIGJsb2IgVVJMIG9yIEF1ZGlvQnVmZmVyKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNvdW5kLnByb3RvdHlwZS5wcm9jZXNzRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFNvdW5kO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuU291bmQgPSBTb3VuZDtcclxuICAgIC8qKlxyXG4gICAgICogSW50ZXJuYWwgY2xhc3MgcmVwcmVzZW50aW5nIGEgSFRNTDUgYXVkaW8gaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIHZhciBBdWRpb1RhZ0luc3RhbmNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBBdWRpb1RhZ0luc3RhbmNlKHNyYykge1xyXG4gICAgICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9hdWRpb0VsZW1lbnQgPSBuZXcgQXVkaW8oc3JjKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgQXVkaW9UYWdJbnN0YW5jZS5wcm90b3R5cGUuaXNQbGF5aW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNQbGF5aW5nO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEF1ZGlvVGFnSW5zdGFuY2UucHJvdG90eXBlLCBcImxvb3BcIiwge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb29wO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBBdWRpb1RhZ0luc3RhbmNlLnByb3RvdHlwZS5zZXRMb29wID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvb3AgPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5fYXVkaW9FbGVtZW50Lmxvb3AgPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5fd2lyZVVwT25FbmRlZCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQXVkaW9UYWdJbnN0YW5jZS5wcm90b3R5cGUuc2V0Vm9sdW1lID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2F1ZGlvRWxlbWVudC52b2x1bWUgPSBVdGlsLmNsYW1wKHZhbHVlLCAwLCAxLjApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQXVkaW9UYWdJbnN0YW5jZS5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzUGF1c2VkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXN1bWUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5faXNQbGF5aW5nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wbGF5aW5nUHJvbWlzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEF1ZGlvVGFnSW5zdGFuY2UucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fYXVkaW9FbGVtZW50LmxvYWQoKTtcclxuICAgICAgICAgICAgdGhpcy5fYXVkaW9FbGVtZW50Lmxvb3AgPSB0aGlzLl9sb29wO1xyXG4gICAgICAgICAgICB0aGlzLl9hdWRpb0VsZW1lbnQucGxheSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9wbGF5aW5nUHJvbWlzZSA9IG5ldyBQcm9taXNlc181LlByb21pc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5fd2lyZVVwT25FbmRlZCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQXVkaW9UYWdJbnN0YW5jZS5wcm90b3R5cGUuX3Jlc3VtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1BhdXNlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2F1ZGlvRWxlbWVudC5wbGF5KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzUGxheWluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX3dpcmVVcE9uRW5kZWQoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEF1ZGlvVGFnSW5zdGFuY2UucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzUGxheWluZykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2F1ZGlvRWxlbWVudC5wYXVzZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQXVkaW9UYWdJbnN0YW5jZS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1BsYXlpbmcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9hdWRpb0VsZW1lbnQucGF1c2UoKTtcclxuICAgICAgICAgICAgdGhpcy5fYXVkaW9FbGVtZW50LmN1cnJlbnRUaW1lID0gMDtcclxuICAgICAgICAgICAgdGhpcy5faGFuZGxlT25FbmRlZCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQXVkaW9UYWdJbnN0YW5jZS5wcm90b3R5cGUuX3dpcmVVcE9uRW5kZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fbG9vcCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYXVkaW9FbGVtZW50Lm9uZW5kZWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5faGFuZGxlT25FbmRlZCgpOyB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBdWRpb1RhZ0luc3RhbmNlLnByb3RvdHlwZS5faGFuZGxlT25FbmRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3BsYXlpbmdQcm9taXNlLnJlc29sdmUodHJ1ZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gQXVkaW9UYWdJbnN0YW5jZTtcclxuICAgIH0oKSk7XHJcbiAgICAvKipcclxuICAgICAqIEludGVybmFsIGNsYXNzIHJlcHJlc2VudGluZyBhIFdlYiBBdWRpbyBBdWRpb0J1ZmZlclNvdXJjZU5vZGUgaW5zdGFuY2VcclxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYl9BdWRpb19BUElcclxuICAgICAqL1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIHZhciBXZWJBdWRpb0luc3RhbmNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBXZWJBdWRpb0luc3RhbmNlKF9idWZmZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fYnVmZmVyID0gX2J1ZmZlcjtcclxuICAgICAgICAgICAgdGhpcy5fdm9sdW1lTm9kZSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVHYWluKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDdXJyZW50IHBsYXliYWNrIG9mZnNldCAoaW4gc2Vjb25kcylcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRPZmZzZXQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBXZWJBdWRpb0luc3RhbmNlLnByb3RvdHlwZS5pc1BsYXlpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1BsYXlpbmc7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBXZWJBdWRpb0luc3RhbmNlLnByb3RvdHlwZS5zZXRWb2x1bWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3ZvbHVtZU5vZGUuZ2Fpbi5zZXRUYXJnZXRBdFRpbWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ZvbHVtZU5vZGUuZ2Fpbi5zZXRUYXJnZXRBdFRpbWUoVXRpbC5jbGFtcCh2YWx1ZSwgMCwgMS4wKSwgYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lLCAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ZvbHVtZU5vZGUuZ2Fpbi52YWx1ZSA9IFV0aWwuY2xhbXAodmFsdWUsIDAsIDEuMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFdlYkF1ZGlvSW5zdGFuY2UucHJvdG90eXBlLnNldExvb3AgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fbG9vcCA9IHZhbHVlO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fYnVmZmVyU291cmNlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9idWZmZXJTb3VyY2UubG9vcCA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fd2lyZVVwT25FbmRlZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBXZWJBdWRpb0luc3RhbmNlLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNQYXVzZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3VtZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLl9pc1BsYXlpbmcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BsYXlpbmdQcm9taXNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgV2ViQXVkaW9JbnN0YW5jZS5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl92b2x1bWVOb2RlLmNvbm5lY3QoYXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uKTtcclxuICAgICAgICAgICAgdGhpcy5fY3JlYXRlQnVmZmVyU291cmNlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlclNvdXJjZS5zdGFydCgwLCAwKTtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRPZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9wbGF5aW5nUHJvbWlzZSA9IG5ldyBQcm9taXNlc181LlByb21pc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5fd2lyZVVwT25FbmRlZCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgV2ViQXVkaW9JbnN0YW5jZS5wcm90b3R5cGUuX3Jlc3VtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1BhdXNlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGEgYnVmZmVyIHNvdXJjZSBjYW4gb25seSBiZSBzdGFydGVkIG9uY2VcclxuICAgICAgICAgICAgLy8gc28gd2UgbmVlZCB0byBkaXNwb3NlIG9mIHRoZSBwcmV2aW91cyBpbnN0YW5jZSBiZWZvcmVcclxuICAgICAgICAgICAgLy8gXCJyZXN1bWluZ1wiIHRoZSBuZXh0IG9uZVxyXG4gICAgICAgICAgICB0aGlzLl9idWZmZXJTb3VyY2Uub25lbmRlZCA9IG51bGw7IC8vIGRpc3Bvc2Ugb2YgYW55IHByZXZpb3VzIGV2ZW50IGhhbmRsZXJcclxuICAgICAgICAgICAgdGhpcy5fY3JlYXRlQnVmZmVyU291cmNlKCk7XHJcbiAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9ICgxIC8gdGhpcy5fYnVmZmVyU291cmNlLnBsYXliYWNrUmF0ZS52YWx1ZSkgKiB0aGlzLl9idWZmZXIuZHVyYXRpb247XHJcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlclNvdXJjZS5zdGFydCgwLCB0aGlzLl9jdXJyZW50T2Zmc2V0ICUgZHVyYXRpb24pO1xyXG4gICAgICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl93aXJlVXBPbkVuZGVkKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBXZWJBdWRpb0luc3RhbmNlLnByb3RvdHlwZS5fY3JlYXRlQnVmZmVyU291cmNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9idWZmZXJTb3VyY2UgPSBhdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlclNvdXJjZS5idWZmZXIgPSB0aGlzLl9idWZmZXI7XHJcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlclNvdXJjZS5sb29wID0gdGhpcy5fbG9vcDtcclxuICAgICAgICAgICAgdGhpcy5fYnVmZmVyU291cmNlLnBsYXliYWNrUmF0ZS52YWx1ZSA9IDEuMDtcclxuICAgICAgICAgICAgdGhpcy5fYnVmZmVyU291cmNlLmNvbm5lY3QodGhpcy5fdm9sdW1lTm9kZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBXZWJBdWRpb0luc3RhbmNlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1BsYXlpbmcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9idWZmZXJTb3VyY2Uuc3RvcCgwKTtcclxuICAgICAgICAgICAgLy8gUGxheWJhY2sgcmF0ZSB3aWxsIGJlIGEgc2NhbGUgZmFjdG9yIG9mIGhvdyBmYXN0L3Nsb3cgdGhlIGF1ZGlvIGlzIGJlaW5nIHBsYXllZFxyXG4gICAgICAgICAgICAvLyBkZWZhdWx0IGlzIDEuMFxyXG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGludmVydCBpdCB0byBnZXQgdGhlIHRpbWUgc2NhbGVcclxuICAgICAgICAgICAgdmFyIHBiUmF0ZSA9IDEgLyAodGhpcy5fYnVmZmVyU291cmNlLnBsYXliYWNrUmF0ZS52YWx1ZSB8fCAxLjApO1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50T2Zmc2V0ID0gKChuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRoaXMuX3N0YXJ0VGltZSkgKiBwYlJhdGUpIC8gMTAwMDsgLy8gaW4gc2Vjb25kc1xyXG4gICAgICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgV2ViQXVkaW9JbnN0YW5jZS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1BsYXlpbmcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9idWZmZXJTb3VyY2Uuc3RvcCgwKTtcclxuICAgICAgICAgICAgLy8gaGFuZGxlciB3aWxsIG5vdCBiZSB3aXJlZCB1cCBpZiB3ZSB3ZXJlIGxvb3BpbmdcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9idWZmZXJTb3VyY2Uub25lbmRlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlT25FbmRlZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRPZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFdlYkF1ZGlvSW5zdGFuY2UucHJvdG90eXBlLl93aXJlVXBPbkVuZGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2xvb3ApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2J1ZmZlclNvdXJjZS5vbmVuZGVkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2hhbmRsZU9uRW5kZWQoKTsgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgV2ViQXVkaW9JbnN0YW5jZS5wcm90b3R5cGUuX2hhbmRsZU9uRW5kZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIHBhdXNpbmcgY2FsbHMgc3RvcCgwKSB3aGljaCB0cmlnZ2VycyBvbmVuZGVkIGV2ZW50XHJcbiAgICAgICAgICAgIC8vIHNvIHdlIGRvbid0IFwicmVzb2x2ZVwiIHlldCAod2hlbiB3ZSByZXN1bWUgd2UnbGwgdHJ5IGFnYWluKVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzUGF1c2VkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BsYXlpbmdQcm9taXNlLnJlc29sdmUodHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBXZWJBdWRpb0luc3RhbmNlO1xyXG4gICAgfSgpKTtcclxufSk7XHJcbmRlZmluZShcIkludGVyZmFjZXMvSUxvYWRlclwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG59KTtcclxuZGVmaW5lKFwiTG9hZGVyXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiRHJhd2luZy9Db2xvclwiLCBcIlJlc291cmNlcy9Tb3VuZFwiLCBcIlV0aWwvTG9nXCIsIFwiUHJvbWlzZXNcIiwgXCJDbGFzc1wiLCBcIlV0aWwvRHJhd1V0aWxcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBDb2xvcl8xMiwgU291bmRfMSwgTG9nXzYsIFByb21pc2VzXzYsIENsYXNzXzMsIERyYXdVdGlsKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogUHJlLWxvYWRpbmcgYXNzZXRzXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGxvYWRlciBwcm92aWRlcyBhIG1lY2hhbmlzbSB0byBwcmVsb2FkIG11bHRpcGxlIHJlc291cmNlcyBhdFxyXG4gICAgICogb25lIHRpbWUuIFRoZSBsb2FkZXIgbXVzdCBiZSBwYXNzZWQgdG8gdGhlIGVuZ2luZSBpbiBvcmRlciB0b1xyXG4gICAgICogdHJpZ2dlciB0aGUgbG9hZGluZyBwcm9ncmVzcyBiYXIuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIFtbTG9hZGVyXV0gaXRzZWxmIGltcGxlbWVudHMgW1tJTG9hZGFibGVdXSBzbyB5b3UgY2FuIGxvYWQgbG9hZGVycy5cclxuICAgICAqXHJcbiAgICAgKiAjIyBFeGFtcGxlOiBQcmUtbG9hZGluZyByZXNvdXJjZXMgZm9yIGEgZ2FtZVxyXG4gICAgICpcclxuICAgICAqIGBgYGpzXHJcbiAgICAgKiAvLyBjcmVhdGUgYSBsb2FkZXJcclxuICAgICAqIHZhciBsb2FkZXIgPSBuZXcgZXguTG9hZGVyKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gY3JlYXRlIGEgcmVzb3VyY2UgZGljdGlvbmFyeSAoYmVzdCBwcmFjdGljZSBpcyB0byBrZWVwIGEgc2VwYXJhdGUgZmlsZSlcclxuICAgICAqIHZhciByZXNvdXJjZXMgPSB7XHJcbiAgICAgKiAgIFRleHR1cmVHcm91bmQ6IG5ldyBleC5UZXh0dXJlKFwiL2ltYWdlcy90ZXh0dXJlcy9ncm91bmQucG5nXCIpLFxyXG4gICAgICogICBTb3VuZERlYXRoOiBuZXcgZXguU291bmQoXCIvc291bmQvZGVhdGgud2F2XCIsIFwiL3NvdW5kL2RlYXRoLm1wM1wiKVxyXG4gICAgICogfTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBsb29wIHRocm91Z2ggZGljdGlvbmFyeSBhbmQgYWRkIHRvIGxvYWRlclxyXG4gICAgICogZm9yICh2YXIgbG9hZGFibGUgaW4gcmVzb3VyY2VzKSB7XHJcbiAgICAgKiAgIGlmIChyZXNvdXJjZXMuaGFzT3duUHJvcGVydHkobG9hZGFibGUpKSB7XHJcbiAgICAgKiAgICAgbG9hZGVyLmFkZFJlc291cmNlKHJlc291cmNlc1tsb2FkYWJsZV0pO1xyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKlxyXG4gICAgICogLy8gc3RhcnQgZ2FtZVxyXG4gICAgICogZ2FtZS5zdGFydChsb2FkZXIpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICogICBjb25zb2xlLmxvZyhcIkdhbWUgc3RhcnRlZCFcIik7XHJcbiAgICAgKiB9KTtcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICB2YXIgTG9hZGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoTG9hZGVyLCBfc3VwZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBsb2FkYWJsZXMgIE9wdGlvbmFsbHkgcHJvdmlkZSB0aGUgbGlzdCBvZiByZXNvdXJjZXMgeW91IHdhbnQgdG8gbG9hZCBhdCBjb25zdHJ1Y3RvciB0aW1lXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gTG9hZGVyKGxvYWRhYmxlcykge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5fcmVzb3VyY2VMaXN0ID0gW107XHJcbiAgICAgICAgICAgIF90aGlzLl9pbmRleCA9IDA7XHJcbiAgICAgICAgICAgIF90aGlzLl9yZXNvdXJjZUNvdW50ID0gMDtcclxuICAgICAgICAgICAgX3RoaXMuX251bUxvYWRlZCA9IDA7XHJcbiAgICAgICAgICAgIF90aGlzLl9wcm9ncmVzc0NvdW50cyA9IHt9O1xyXG4gICAgICAgICAgICBfdGhpcy5fdG90YWxDb3VudHMgPSB7fTtcclxuICAgICAgICAgICAgLy8gbG9nbyBkcmF3aW5nIHN0dWZmXHJcbiAgICAgICAgICAgIC8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xyXG4gICAgICAgICAgICAvLyBiYXNlNjQgc3RyaW5nIGVuY29kaW5nIG9mIHRoZSBleGNhbGlidXIgbG9nbyAobG9nby13aGl0ZS5wbmcpXHJcbiAgICAgICAgICAgIF90aGlzLmxvZ28gPSAnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFkUUFBQUIyQ0FZQUFBQnhoR0k5QUFBQUNYQklXWE1BQUFzU0FBQUxFZ0hTM1g3OEFBQUtuVWxFUVZSNDJ1M2RQMndqU3gwSDhOOGhKSW9uSVJtSmpzcTBTQlIrQlExZGNxS2hlMGxENzdTdlN3cEtrSktHUHVscGt0ZlJJTVVkRXFLSXFWNTdycEFva000ZGJTaXlxN09OUFRQN3gzOWlmejdTRmJuRW5wM3hlcjQ3Tzd1ekgxNWZYd01BNk9ZSG1nQUFCQ29BQ0ZRQUVLZ0FnRUFGQUlFS0FBSVZBQVFxQUNCUUFVQ2dBb0JBQlFDQkNnQUlWQUFRcUFBZ1VBRkFvQUlBQWhVQUJDb0FDRlFBRUtnQWdFQ0ZMYm1PaU5lRmYyUGJBeXo2OFByNnFoVWdiUndSOTJ2Ky96d2lKcllITUVLRk1tY04vLy9VdGdjUXFGQmsxUEQvOTdVOVF4OFZDRlNndTRFbUFJRUtBQUlWQUFRcUFDQlE0WjI1am9qUDhlWCswV3ROQWdJVmFPWStJbTVqK2VLaDI0aDQxalFnVUlFeVo3RjVOYVBVN3dDQkNpd1lkL3c5Y09CK3FBbGdKM0tMTG93MEVWMTk4ODAzUld2SmZ2ZmRkeCswbGhFcUhLdTVKZ0FqVkNCdmxobUZ6alFSWFVla0h6OStUUDc5eTh1TFJqTkNoWGZ2b2VQdkFZRUt4TnRqMWU0Mi9PNUpvSUpBQmNyZFJNUlZMTStYM2tURXBhYUI5ODhjS3V6V2c5RW9iVFdkTXgwT2x5OHVONGRxaEFvQVJxZ25hTjNhckhmcXU3T3lIOEl0S0xWQi9QK0NFZk1USHlHUFkzbnB4MW04eldHREVlb0JmVWsveGR0aTU3ZHIvcjFXdjIrNkVQb3czdFo1clJkUzcyczFuZXVGOTd4dldkK1hUSDAvVitVTXR0RFdxYkkvcjJucnhmcCtqdjJ1U2pTTzdTK09YeS9BLzNsTis5eFg1VDVIeEVVUFpaMHRmQjcxK3c1N2VKL0hGdSt6K2prdjF1OTJZWDlmYkkvSGhYM0pBOXJwNU1QcjY2dFdhRzlVZlVHYnJISXppN2NMVXlZRmYvdHBUYWR5MDNFRWVMOG1VSjZpN01LWU52V05xcjRQZTJqcmFkWE82MExydlBBejJQUTVSUFg2ODRhaDhkeEQrMnphbnRuQ2dWaXBTVlYrbS90Z0I5VzJERHEyU3gvdk05NXdjSGhaaFdWSm04eXJ2NThjU2dmVGRjNzArKysvWC9yNTIyKy90VUtTRWVwQnFvK29tNFpMUGVyTWpVd3VOblFDdHgxR1dKdGVlMUZ3ZEQ1dVdkODZ4THM4VWFWdDJhTkVPMS9zYVovWjVyWU1XNHpxNnYzNHJHVjlCZzNxMmVaOVNrZU5tOXF3eVVoMzBPUElIWUZLeDVGRzAzQzd6blNPcVlCcStxVy96cFEzYW5IMDM3VE5IbHVHNmYwV1BzUGhIdmFiNFFGdHk3b2dPZXV4RFljTnkyL3p1MjIxNFdOWVd4bUJ1ck5POGJHbjk3cE5CT084eHkvOXVDb3JaWjRJMnI0QzdhSmdPN1pWOWlFNDlEbTZOdk9XeCtwV0U5Q1VxM3piZFRwOWRvejM4VGJYdHpxSDlSVDVDeVdlNDIyT2Fab1pHZVpDYWJyaFBRWTlIandzanBUdkNnNFl0bEUyK1RhL2oyYnpuOGZxckRxZ20rNnlVSE9tQXZXVWpBdEdoYk5ZdnNCa25EbnFIMVFoYzdWbXhIZ2ViL05idWRBNWovVVhsWXdpZjJwNmx1aEFjOXRldTFucGlIS25EczhpZjZ0Q203SkxYM05LcGd0dFhlOXJ1YzltSE1kN2E4M2l3ZHhGNXZ0OHR1dEFSYUNla2xSbk5LOUM4V25ORjdnZUpRNFQ0WEczSmhTblZkaWxRckcreU9ucmxWSGZzRUdZemhOQm43THU2dFM3K0hKYWZKUTRFTWlObE5xV1haOVdQdlZnblZZSEc1TTFCeURYa1Q2bGVYMkVnVHFKdHl0NDV5djdTMnFPM3NFWmpaaERMWGVSK1lLZEowWmRrOFFvY3ZIOU43MzJLck50cStGWi96eklIQUJjSnJZcGQrWHYxNGxPZDVhcDc2U2dyZHVXL1ZUUTFxY1FwcW5iZ3U0aWZadlVNTnBkOVh1b1ptdkN0UGFRMlkvQkNIVkxnYnJKVGVSUERkVmY2cGZNS0RVMmZPa0htVkZGZlhyM01zb3VMc25OdlY1a1JvZTUrczQzMVBldW9LUHFXbmF1clkvWlBCRWVxd2NlTjRsOTZpd082SDdNanE0eTdWR1BWTmUxMFZhWk16VkNQVldwSS9aNkZaYmN2NWZNcUdDVStkTGZGR3pqNThqUDgrYkNkSkNvN3l6S1R3ZE9GMGJ1OVVnN1Y0Yyt5ejdGSmZZZUdveXNVc3MwSHNzSWRWWndZTER1ak1xbEVTb0NkVHRHc1p0YkhuSkJlTmREU0pTczBqVEtkTUpOMUhOWDU0V3Y3YnZzVTlOa1ZKVmExM2RYKy93dUFyVjBYL2w1Ukh5by9sbmZGNEc2cDZEclMwa0hkdFhoeTM1VEdFckRQWVpVbjJXZldxRE9vL2xWcWRNRDJPL2hLSmhEN1Mvb2R1a3ltcTlzMDJRTjRFRVBSL3piYU91bVpjK3IxNXpLMVpxem5sOWpzZmllbVRNMVFtVjNIVXVUa2VkbGc5SElRelJiVUQ5M2RmQysydHBqMmZJSEVIMitScUNDUUgxM2dacTdoV1hUTnBWdTE5T0IxZmM5blEwQUtPS1ViNWxVMFAxa0R5T25lb1drMGxPWjljSVAweDdxdTgrMkJoQ29SMndZdTErZTdEbWFYekJTc3U1dmFYMW5lMnpycG1VUFRteGY3UE0xRG00eS92QzdueTdOaWY3K3ovOVptdE0wWjNwYW5QTHRQbXJhOWYxNmJjSzBEcGJud2s0M1ZkL1JIdHU2emZOUVR5MVFCeTNhcUcyZzluVm14bWwrQk9vSnlUM05wV21uOXhoZkZudTRidkRhKzQ0QlhocXFmZGYzdVVGOSt5ejc3QVQzMVl1ZTJtamVjWVE2Mk5MZmdrQTlnaEhxTE5FaE5lbTRIMWM2dmR5RHhoZi9icHo1bTRjb1cvYzM5d2k2VkgyYlB0SGxjYVY5Y3ZYdHMrenhDZTZyVGVxYzJuZEw3dUdkOTNRd005YkZjQXpNb1paN1NnVEJiV3grYXN1aTYxaC9pcTErUm1qcWRiblFYUTNUMUROUTYzVi9VOXVjcW0vcE16UGIxcmVQc2svMWlUT2pndmF0UjRXM0xjOFVMQjc4cEVMeXJuQWZlVGNqMU5VNTA5Lzg2bWZKMzMvOCtNZjAwYTA1VXlQVUV3N1VWQ2VXRy9XTkVpRXh5SFJNdDVsdFczMGl6VVBrMTh5dHQ3bE5mYzhpLy9EdnR2WHRvK3lTQTVCamxqc0xVRjhsUGtxTVBFdFcxSm9tRHNpR0JaOUJ5YjROQXZVSVRTTjlHdXdzSWo2dDZVVE9xazdqSlJFa216cWxpOHhJczk2dWRTTzIwc1gwSDF2VzkySUw5ZTFhOXJncVZ5ZjkxZ2JQc1R5OVVEOW45bE9rVDhrK1Jma0ZSNVBNTnF4T2NkU2YzMlBCdmczdmlsTyt6ZHhFK29reDlXbTBwaDM2WFlzUlpDcE1GOTkzR09rNXF2cUIzRGN0Nmp2c3NiNjdLdnVVTkozZnJ3OTJiaHI4L1NUU0YwSmRSUE1McFVDZ25zZ285Uzc2UFoyNDZaRmsxd1d2SzVtM3ZWb1l2VzFTejduTjkxamZYYlExWlFjN1RXNkhlYW9PYWx5cEcvOC9wL3JQMWFOQWM2Wkh6U25mZHFQVVBoZHkyUFF3Nk56OWdTVmh1aGlxdWVVSFIzdXU3eTdLM3JkRFg0dTQ2WnJQYlVhMElGQlowc2VLUTNYUVRSdDJ2bTNXL2EyRGJOS3lzKytydm0zZXA2K3kxeDJVZFAzYldVOWx6cmE0N1UxR21sY3RYL3NRMjN0K2FPbEJ5TFRoLzROQVBhQ1J4dGNkTzVITFNKLzZ2TnRDd0d4NjdWUG1QYnZXZDFxOWZyS0h0cDRrQXFSSjJIUjlqNzYySmZYM2JaLy9lbFB0ajEzUFBEeDErRDV0cWsvWGk2Tk84U0h6N01tSDE5ZFhyZEJOZlZGUDZUMlBUMVVITml0ODcvdDRtNSthUkgrblFCZHZxeWhaREtKTGZaczhoN1hQc3FkVjJaT1YrdGFuS0I4YWxuMGR5eGRBWGJWNGo0Z3Z0NG9NT3JiUDZ2YlU3M05XN1RNbGJkVG5QcldwZnFYZmg5SEtaOXZrZTdLdVRlWlJOdFhSU2U2KzFGVi8vY2UvbG41ZVhmc1hnY3FYenI2KzkyNjFNM21vT29hN0U2bnZUWlRmeTdpTnNtZmI3a2pmZ1hHc3Z4ZTB2aWhzRXRzOUhUcXVQcHQxcTF2dGFodTJUcUFpVUFFRUtqMHpod29BUnFnQXUvT25YLzQ0MldIKzl4Yy9XdnI1OHJlL1RyN2Y0MS8rWnNScWhBb0FDRlFBRUtnQWNIak1vUUpza0pzei9lcXJyNVordnZyN3Y1Zm1RRmV2QWw1bHp0UUlGUUFRcUFBZ1VBSGdJSmxEQmRoZ2RRNDFOMmVLRVNvQUlGQUJRS0FDd0ZFd2h3b0FScWdBSUZBQlFLQUNBQUlWQUFRcUFBaFVBQkNvQUlCQUJRQ0JDZ0FDRlFBRUtnQWdVQUZBb0FLQVFBVUFnUW9BQ0ZRQUVLZ0FJRkFCUUtBQ0FBSVZBQVFxQUFoVUFCQ29BSUJBQlFDQkNnQUNGUUFRcUFBZ1VBRkFvQUtBUUFVQWx2d1BjRkRuczFEc0g0c0FBQUFBU1VWT1JLNUNZSUk9JztcclxuICAgICAgICAgICAgLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cclxuICAgICAgICAgICAgX3RoaXMubG9nb1dpZHRoID0gNDY4O1xyXG4gICAgICAgICAgICBfdGhpcy5sb2dvSGVpZ2h0ID0gMTE4O1xyXG4gICAgICAgICAgICBfdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSAnIzE3NkJBQSc7XHJcbiAgICAgICAgICAgIF90aGlzLmdldERhdGEgPSBmdW5jdGlvbiAoKSB7IHJldHVybjsgfTtcclxuICAgICAgICAgICAgX3RoaXMuc2V0RGF0YSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuOyB9O1xyXG4gICAgICAgICAgICBfdGhpcy5wcm9jZXNzRGF0YSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuOyB9O1xyXG4gICAgICAgICAgICBfdGhpcy5vbnByb2dyZXNzID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIExvZ182LkxvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdbZXguTG9hZGVyXSBMb2FkaW5nICcgKyAoMTAwICogZS5sb2FkZWQgLyBlLnRvdGFsKS50b0ZpeGVkKDApKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgX3RoaXMub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuOyB9O1xyXG4gICAgICAgICAgICBfdGhpcy5vbmVycm9yID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XHJcbiAgICAgICAgICAgIGlmIChsb2FkYWJsZXMpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmFkZFJlc291cmNlcyhsb2FkYWJsZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvYWRlci5wcm90b3R5cGUsIFwiX2ltYWdlXCIsIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2ltYWdlRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ltYWdlRWxlbWVudCA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ltYWdlRWxlbWVudC5zcmMgPSB0aGlzLmxvZ287XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faW1hZ2VFbGVtZW50O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICA7XHJcbiAgICAgICAgTG9hZGVyLnByb3RvdHlwZS53aXJlRW5naW5lID0gZnVuY3Rpb24gKGVuZ2luZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9lbmdpbmUgPSBlbmdpbmU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGQgYSByZXNvdXJjZSB0byB0aGUgbG9hZGVyIHRvIGxvYWRcclxuICAgICAgICAgKiBAcGFyYW0gbG9hZGFibGUgIFJlc291cmNlIHRvIGFkZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExvYWRlci5wcm90b3R5cGUuYWRkUmVzb3VyY2UgPSBmdW5jdGlvbiAobG9hZGFibGUpIHtcclxuICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuX2luZGV4Kys7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jlc291cmNlTGlzdC5wdXNoKGxvYWRhYmxlKTtcclxuICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3NDb3VudHNba2V5XSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3RvdGFsQ291bnRzW2tleV0gPSAxO1xyXG4gICAgICAgICAgICB0aGlzLl9yZXNvdXJjZUNvdW50Kys7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGQgYSBsaXN0IG9mIHJlc291cmNlcyB0byB0aGUgbG9hZGVyIHRvIGxvYWRcclxuICAgICAgICAgKiBAcGFyYW0gbG9hZGFibGVzICBUaGUgbGlzdCBvZiByZXNvdXJjZXMgdG8gbG9hZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExvYWRlci5wcm90b3R5cGUuYWRkUmVzb3VyY2VzID0gZnVuY3Rpb24gKGxvYWRhYmxlcykge1xyXG4gICAgICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IGxvYWRhYmxlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFJlc291cmNlKGxvYWRhYmxlc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgbG9hZGVyIGhhcyBjb21wbGV0ZWx5IGxvYWRlZCBhbGwgcmVzb3VyY2VzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTG9hZGVyLnByb3RvdHlwZS5pc0xvYWRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX251bUxvYWRlZCA9PT0gdGhpcy5fcmVzb3VyY2VDb3VudDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJlZ2luIGxvYWRpbmcgYWxsIG9mIHRoZSBzdXBwbGllZCByZXNvdXJjZXMsIHJldHVybmluZyBhIHByb21pc2VcclxuICAgICAgICAgKiB0aGF0IHJlc29sdmVzIHdoZW4gbG9hZGluZyBvZiBhbGwgaXMgY29tcGxldGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBMb2FkZXIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBjb21wbGV0ZSA9IG5ldyBQcm9taXNlc182LlByb21pc2UoKTtcclxuICAgICAgICAgICAgdmFyIG1lID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3Jlc291cmNlTGlzdC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIG1lLm9uY29tcGxldGUuY2FsbChtZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGxldGUucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBwcm9ncmVzc0FycmF5ID0gbmV3IEFycmF5KHRoaXMuX3Jlc291cmNlTGlzdC5sZW5ndGgpO1xyXG4gICAgICAgICAgICB2YXIgcHJvZ3Jlc3NDaHVua3MgPSB0aGlzLl9yZXNvdXJjZUxpc3QubGVuZ3RoO1xyXG4gICAgICAgICAgICB0aGlzLl9yZXNvdXJjZUxpc3QuZm9yRWFjaChmdW5jdGlvbiAociwgaSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl9lbmdpbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICByLndpcmVFbmdpbmUoX3RoaXMuX2VuZ2luZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0b3RhbCA9IGUudG90YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvYWRlZCA9IGUubG9hZGVkO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzQXJyYXlbaV0gPSB7IGxvYWRlZDogKChsb2FkZWQgLyB0b3RhbCkgKiAoMTAwIC8gcHJvZ3Jlc3NDaHVua3MpKSwgdG90YWw6IDEwMCB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9ncmVzc1Jlc3VsdCA9IHByb2dyZXNzQXJyYXkucmVkdWNlKGZ1bmN0aW9uIChhY2N1bSwgbmV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBsb2FkZWQ6IChhY2N1bS5sb2FkZWQgKyBuZXh0LmxvYWRlZCksIHRvdGFsOiAxMDAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9LCB7IGxvYWRlZDogMCwgdG90YWw6IDEwMCB9KTtcclxuICAgICAgICAgICAgICAgICAgICBtZS5vbnByb2dyZXNzLmNhbGwobWUsIHByb2dyZXNzUmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByLm9uY29tcGxldGUgPSByLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWUuX251bUxvYWRlZCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtZS5fbnVtTG9hZGVkID09PSBtZS5fcmVzb3VyY2VDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5vbmNvbXBsZXRlLmNhbGwobWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGxvYWROZXh0KGxpc3QsIGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWxpc3RbaW5kZXhdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGlzdFtpbmRleF0ubG9hZCgpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvYWROZXh0KGxpc3QsIGluZGV4ICsgMSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsb2FkTmV4dCh0aGlzLl9yZXNvdXJjZUxpc3QsIDApO1xyXG4gICAgICAgICAgICByZXR1cm4gY29tcGxldGU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMb2FkZXIgZHJhdyBmdW5jdGlvbi4gRHJhd3MgdGhlIGRlZmF1bHQgRXhjYWxpYnVyIGxvYWRpbmcgc2NyZWVuLlxyXG4gICAgICAgICAqIE92ZXJyaWRlIGBsb2dvYCwgYGxvZ29XaWR0aGAsIGBsb2dvSGVpZ2h0YCBhbmQgYGJhY2tncm91bmRDb2xvcmAgcHJvcGVydGllc1xyXG4gICAgICAgICAqIHRvIGN1c3RvbWl6ZSB0aGUgZHJhd2luZywgb3IganVzdCBvdmVycmlkZSBlbnRpcmUgbWV0aG9kLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExvYWRlci5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICAgICAgICAgICAgdmFyIGNhbnZhc0hlaWdodCA9IHRoaXMuX2VuZ2luZS5jYW52YXNIZWlnaHQgLyB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcclxuICAgICAgICAgICAgdmFyIGNhbnZhc1dpZHRoID0gdGhpcy5fZW5naW5lLmNhbnZhc1dpZHRoIC8gd2luZG93LmRldmljZVBpeGVsUmF0aW87XHJcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmJhY2tncm91bmRDb2xvcjtcclxuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xyXG4gICAgICAgICAgICB2YXIgeSA9IGNhbnZhc0hlaWdodCAvIDI7XHJcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IE1hdGgubWluKHRoaXMubG9nb1dpZHRoLCBjYW52YXNXaWR0aCAqIDAuNzUpO1xyXG4gICAgICAgICAgICB2YXIgeCA9IChjYW52YXNXaWR0aCAvIDIpIC0gKHdpZHRoIC8gMik7XHJcbiAgICAgICAgICAgIHZhciBpbWFnZUhlaWdodCA9IE1hdGguZmxvb3Iod2lkdGggKiAodGhpcy5sb2dvSGVpZ2h0IC8gdGhpcy5sb2dvV2lkdGgpKTsgLy8gT0cgaGVpZ2h0L3dpZHRoIGZhY3RvclxyXG4gICAgICAgICAgICB2YXIgb2xkQW50aWFsaWFzID0gdGhpcy5fZW5naW5lLmdldEFudGlhbGlhc2luZygpO1xyXG4gICAgICAgICAgICB0aGlzLl9lbmdpbmUuc2V0QW50aWFsaWFzaW5nKHRydWUpO1xyXG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMuX2ltYWdlLCAwLCAwLCB0aGlzLmxvZ29XaWR0aCwgdGhpcy5sb2dvSGVpZ2h0LCB4LCB5IC0gaW1hZ2VIZWlnaHQgLSAyMCwgd2lkdGgsIGltYWdlSGVpZ2h0KTtcclxuICAgICAgICAgICAgLy8gbG9hZGluZyBib3hcclxuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDI7XHJcbiAgICAgICAgICAgIERyYXdVdGlsLnJvdW5kUmVjdChjdHgsIHgsIHksIHdpZHRoLCAyMCwgMTApO1xyXG4gICAgICAgICAgICB2YXIgcHJvZ3Jlc3MgPSB3aWR0aCAqICh0aGlzLl9udW1Mb2FkZWQgLyB0aGlzLl9yZXNvdXJjZUNvdW50KTtcclxuICAgICAgICAgICAgdmFyIG1hcmdpbiA9IDU7XHJcbiAgICAgICAgICAgIHZhciBwcm9ncmVzc1dpZHRoID0gcHJvZ3Jlc3MgLSBtYXJnaW4gKiAyO1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gMjAgLSBtYXJnaW4gKiAyO1xyXG4gICAgICAgICAgICBEcmF3VXRpbC5yb3VuZFJlY3QoY3R4LCB4ICsgbWFyZ2luLCB5ICsgbWFyZ2luLCBwcm9ncmVzc1dpZHRoID4gMCA/IHByb2dyZXNzV2lkdGggOiAwLCBoZWlnaHQsIDUsIG51bGwsIENvbG9yXzEyLkNvbG9yLldoaXRlKTtcclxuICAgICAgICAgICAgdGhpcy5fZW5naW5lLnNldEFudGlhbGlhc2luZyhvbGRBbnRpYWxpYXMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGVyZm9ybSBhbnkgY2FsY3VsYXRpb25zIG9yIGxvZ2ljIGluIHRoZSBgdXBkYXRlYCBtZXRob2QuIFRoZSBkZWZhdWx0IGBMb2FkZXJgIGRvZXMgbm90XHJcbiAgICAgICAgICogZG8gYW55dGhpbmcgaW4gdGhpcyBtZXRob2Qgc28gaXQgaXMgc2FmZSB0byBvdmVycmlkZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBMb2FkZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChfZW5naW5lLCBfZGVsdGEpIHtcclxuICAgICAgICAgICAgLy8gb3ZlcnJpZGFibGUgdXBkYXRlXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gTG9hZGVyO1xyXG4gICAgfShDbGFzc18zLkNsYXNzKSk7XHJcbiAgICBleHBvcnRzLkxvYWRlciA9IExvYWRlcjtcclxuICAgIC8qKlxyXG4gICAgICogQSBbW0xvYWRlcl1dIHRoYXQgcGF1c2VzIGFmdGVyIGxvYWRpbmcgdG8gYWxsb3cgdXNlclxyXG4gICAgICogdG8gcHJvY2VlZCB0byBwbGF5IHRoZSBnYW1lLiBUeXBpY2FsbHkgeW91IHdpbGxcclxuICAgICAqIHdhbnQgdG8gdXNlIHRoaXMgbG9hZGVyIGZvciBpT1MgdG8gYWxsb3cgc291bmRzXHJcbiAgICAgKiB0byBwbGF5IGFmdGVyIGxvYWRpbmcgKEFwcGxlIFNhZmFyaSByZXF1aXJlcyB1c2VyXHJcbiAgICAgKiBpbnRlcmFjdGlvbiB0byBhbGxvdyBzb3VuZHMsIGV2ZW4gZm9yIGdhbWVzKVxyXG4gICAgICpcclxuICAgICAqICoqTm90ZToqKiBCZWNhdXNlIExvYWRlciBpcyBub3QgcGFydCBvZiBhIFNjZW5lLCB5b3UgbXVzdFxyXG4gICAgICogY2FsbCBgdXBkYXRlYCBhbmQgYGRyYXdgIG1hbnVhbGx5IG9uIFwiY2hpbGRcIiBvYmplY3RzLlxyXG4gICAgICpcclxuICAgICAqICMjIEltcGxlbWVudGluZyBhIFRyaWdnZXJcclxuICAgICAqXHJcbiAgICAgKiBUaGUgYFBhdXNlQWZ0ZXJMb2FkZXJgIHJlcXVpcmVzIGFuIGVsZW1lbnQgdG8gYWN0IGFzIHRoZSB0cmlnZ2VyIGJ1dHRvblxyXG4gICAgICogdG8gc3RhcnQgdGhlIGdhbWUuXHJcbiAgICAgKlxyXG4gICAgICogRm9yIGV4YW1wbGUsIGxldCdzIGNyZWF0ZSBhbiBgPGE+YCB0YWcgdG8gYmUgb3VyIHRyaWdnZXIgYW5kIGNhbGwgaXQgYHRhcC10by1wbGF5YC5cclxuICAgICAqXHJcbiAgICAgKiBgYGBodG1sXHJcbiAgICAgKiA8ZGl2IGlkPVwid3JhcHBlclwiPlxyXG4gICAgICogICAgPGNhbnZhcyBpZD1cImdhbWVcIj48L2NhbnZhcz5cclxuICAgICAqICAgIDxhIGlkPVwidGFwLXRvLXBsYXlcIiBocmVmPSdqYXZhc2NyaXB0OnZvaWQoMCk7Jz5UYXAgdG8gUGxheTwvYT5cclxuICAgICAqIDwvZGl2PlxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogV2UndmUgcHV0IGl0IGluc2lkZSBhIHdyYXBwZXIgdG8gcG9zaXRpb24gaXQgcHJvcGVybHkgb3ZlciB0aGUgZ2FtZSBjYW52YXMuXHJcbiAgICAgKlxyXG4gICAgICogTm93IGxldCdzIGFkZCBzb21lIENTUyB0byBzdHlsZSBpdCAoaW5zZXJ0IGludG8gYDxoZWFkPmApOlxyXG4gICAgICpcclxuICAgICAqIGBgYGh0bWxcclxuICAgICAqIDxzdHlsZT5cclxuICAgICAqICAgICAjd3JhcHBlciB7XHJcbiAgICAgKiAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuICAgICAqICAgICAgICAgd2lkdGg6IDUwMHB4O1xyXG4gICAgICogICAgICAgICBoZWlnaHQ6IDUwMHB4O1xyXG4gICAgICogICAgIH1cclxuICAgICAqICAgICAjdGFwLXRvLXBsYXkge1xyXG4gICAgICogICAgICAgICBkaXNwbGF5OiBub25lO1xyXG4gICAgICogICAgICAgICBmb250LXNpemU6IDI0cHg7XHJcbiAgICAgKiAgICAgICAgIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmO1xyXG4gICAgICogICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XHJcbiAgICAgKiAgICAgICAgIGJvcmRlcjogM3B4IHNvbGlkIHdoaXRlO1xyXG4gICAgICogICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICAgKiAgICAgICAgIGNvbG9yOiB3aGl0ZTtcclxuICAgICAqICAgICAgICAgd2lkdGg6IDIwMHB4O1xyXG4gICAgICogICAgICAgICBoZWlnaHQ6IDUwcHg7XHJcbiAgICAgKiAgICAgICAgIGxpbmUtaGVpZ2h0OiA1MHB4O1xyXG4gICAgICogICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XHJcbiAgICAgKiAgICAgICAgIGxlZnQ6IDE0N3B4O1xyXG4gICAgICogICAgICAgICB0b3A6IDgwJTtcclxuICAgICAqICAgICB9XHJcbiAgICAgKiA8L3N0eWxlPlxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogTm93IHdlIGNhbiBjcmVhdGUgYSBgUGF1c2VBZnRlckxvYWRlcmAgd2l0aCBhIHJlZmVyZW5jZSB0byBvdXIgdHJpZ2dlciBidXR0b246XHJcbiAgICAgKlxyXG4gICAgICogYGBgdHNcclxuICAgICAqIHZhciBsb2FkZXIgPSBuZXcgZXguUGF1c2VBZnRlckxvYWRlcigndGFwLXRvLXBsYXknLCBbLi4uXSk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiAjIyBVc2UgUGF1c2VBZnRlckxvYWRlciBmb3IgaU9TXHJcbiAgICAgKlxyXG4gICAgICogVGhlIHByaW1hcnkgdXNlIGNhc2UgZm9yIHBhdXNpbmcgYmVmb3JlIHN0YXJ0aW5nIHRoZSBnYW1lIGlzIHRvXHJcbiAgICAgKiBwYXNzIEFwcGxlJ3MgcmVxdWlyZW1lbnQgb2YgdXNlciBpbnRlcmFjdGlvbi4gVGhlIFdlYiBBdWRpbyBjb250ZXh0XHJcbiAgICAgKiBpbiBTYWZhcmkgaXMgZGlzYWJsZWQgYnkgZGVmYXVsdCB1bnRpbCB1c2VyIGludGVyYWN0aW9uLlxyXG4gICAgICpcclxuICAgICAqIFRoZXJlZm9yZSwgeW91IGNhbiB1c2UgdGhpcyBzbmlwcGV0IHRvIG9ubHkgdXNlIFBhdXNlQWZ0ZXJMb2FkZXIgd2hlblxyXG4gICAgICogaU9TIGlzIGRldGVjdGVkIChzZWUgW3RoaXMgdGhyZWFkXShodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzkwMzg2MjUvZGV0ZWN0LWlmLWRldmljZS1pcy1pb3MpXHJcbiAgICAgKiBmb3IgbW9yZSB0ZWNobmlxdWVzKS5cclxuICAgICAqXHJcbiAgICAgKiBgYGB0c1xyXG4gICAgICogdmFyIGlPUyA9IC9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICEoPGFueT53aW5kb3cpLk1TU3RyZWFtO1xyXG4gICAgICogdmFyIGxvYWRlcjogZXguTG9hZGVyID0gaU9TID8gbmV3IGV4LlBhdXNlQWZ0ZXJMb2FkZXIoJ3RhcC10by1wbGF5JykgOiBuZXcgZXguTG9hZGVyKCk7XHJcbiAgICAgKlxyXG4gICAgICogbG9hZGVyLmFkZFJlc291cmNlKC4uLik7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgdmFyIFBhdXNlQWZ0ZXJMb2FkZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhQYXVzZUFmdGVyTG9hZGVyLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFBhdXNlQWZ0ZXJMb2FkZXIodHJpZ2dlckVsZW1lbnRJZCwgbG9hZGFibGVzKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGxvYWRhYmxlcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuX2hhbmRsZU9uVHJpZ2dlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fd2FpdFByb21pc2Uuc3RhdGUoKSAhPT0gUHJvbWlzZXNfNi5Qcm9taXNlU3RhdGUuUGVuZGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHVubG9jayBTYWZhcmkgV2ViQXVkaW8gY29udGV4dFxyXG4gICAgICAgICAgICAgICAgU291bmRfMS5XZWJBdWRpby51bmxvY2soKTtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlIHRvIHBsYXkgZ2FtZVxyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3dhaXRQcm9taXNlLnJlc29sdmUoX3RoaXMuX2xvYWRlZFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIC8vIGhpZGUgRE9NIGVsZW1lbnRcclxuICAgICAgICAgICAgICAgIF90aGlzLl9wbGF5VHJpZ2dlci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBfdGhpcy5fcGxheVRyaWdnZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0cmlnZ2VyRWxlbWVudElkKTtcclxuICAgICAgICAgICAgX3RoaXMuX3BsYXlUcmlnZ2VyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgX3RoaXMuX2hhbmRsZU9uVHJpZ2dlcik7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgUGF1c2VBZnRlckxvYWRlci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdGhpcy5fd2FpdFByb21pc2UgPSBuZXcgUHJvbWlzZXNfNi5Qcm9taXNlKCk7XHJcbiAgICAgICAgICAgIC8vIHdhaXQgdW50aWwgdXNlciBpbmRpY2F0ZXMgdG8gcHJvY2VlZCBiZWZvcmUgZmluaXNoaW5nIGxvYWRcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5sb2FkLmNhbGwodGhpcykudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9sb2FkZWRWYWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgLy8gc2hvdyBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fcGxheVRyaWdnZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3dhaXRQcm9taXNlLnJlamVjdCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2FpdFByb21pc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gUGF1c2VBZnRlckxvYWRlcjtcclxuICAgIH0oTG9hZGVyKSk7XHJcbiAgICBleHBvcnRzLlBhdXNlQWZ0ZXJMb2FkZXIgPSBQYXVzZUFmdGVyTG9hZGVyO1xyXG59KTtcclxuZGVmaW5lKFwiSW50ZXJmYWNlcy9JQWN0b3JUcmFpdFwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG59KTtcclxuZGVmaW5lKFwiVHJhaXRzL0NhcHR1cmVQb2ludGVyXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIFByb3BvZ2F0ZXMgcG9pbnRlciBldmVudHMgdG8gdGhlIGFjdG9yXHJcbiAgICAgKi9cclxuICAgIHZhciBDYXB0dXJlUG9pbnRlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gQ2FwdHVyZVBvaW50ZXIoKSB7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIENhcHR1cmVQb2ludGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoYWN0b3IsIGVuZ2luZSkge1xyXG4gICAgICAgICAgICBpZiAoIWFjdG9yLmVuYWJsZUNhcHR1cmVQb2ludGVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGFjdG9yLmlzS2lsbGVkKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbmdpbmUuaW5wdXQucG9pbnRlcnMucHJvcG9nYXRlKGFjdG9yKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBDYXB0dXJlUG9pbnRlcjtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkNhcHR1cmVQb2ludGVyID0gQ2FwdHVyZVBvaW50ZXI7XHJcbn0pO1xyXG5kZWZpbmUoXCJUcmFpdHMvRXVsZXJNb3ZlbWVudFwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIlBoeXNpY3NcIiwgXCJBY3RvclwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIFBoeXNpY3NfNywgQWN0b3JfNSkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICB2YXIgRXVsZXJNb3ZlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gRXVsZXJNb3ZlbWVudCgpIHtcclxuICAgICAgICB9XHJcbiAgICAgICAgRXVsZXJNb3ZlbWVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGFjdG9yLCBfZW5naW5lLCBkZWx0YSkge1xyXG4gICAgICAgICAgICAvLyBVcGRhdGUgcGxhY2VtZW50cyBiYXNlZCBvbiBsaW5lYXIgYWxnZWJyYVxyXG4gICAgICAgICAgICB2YXIgc2Vjb25kcyA9IGRlbHRhIC8gMTAwMDtcclxuICAgICAgICAgICAgdmFyIHRvdGFsQWNjID0gYWN0b3IuYWNjLmNsb25lKCk7XHJcbiAgICAgICAgICAgIC8vIE9ubHkgYWN0aXZlIHZhbmlsbGEgYWN0b3JzIGFyZSBhZmZlY3RlZCBieSBnbG9iYWwgYWNjZWxlcmF0aW9uXHJcbiAgICAgICAgICAgIGlmIChhY3Rvci5jb2xsaXNpb25UeXBlID09PSBBY3Rvcl81LkNvbGxpc2lvblR5cGUuQWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICB0b3RhbEFjYy5hZGRFcXVhbChQaHlzaWNzXzcuUGh5c2ljcy5hY2MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFjdG9yLm9sZFZlbCA9IGFjdG9yLnZlbDtcclxuICAgICAgICAgICAgYWN0b3IudmVsLmFkZEVxdWFsKHRvdGFsQWNjLnNjYWxlKHNlY29uZHMpKTtcclxuICAgICAgICAgICAgYWN0b3IucG9zLmFkZEVxdWFsKGFjdG9yLnZlbC5zY2FsZShzZWNvbmRzKSkuYWRkRXF1YWwodG90YWxBY2Muc2NhbGUoMC41ICogc2Vjb25kcyAqIHNlY29uZHMpKTtcclxuICAgICAgICAgICAgYWN0b3IucnggKz0gYWN0b3IudG9ycXVlICogKDEuMCAvIGFjdG9yLm1vaSkgKiBzZWNvbmRzO1xyXG4gICAgICAgICAgICBhY3Rvci5yb3RhdGlvbiArPSBhY3Rvci5yeCAqIHNlY29uZHM7XHJcbiAgICAgICAgICAgIGFjdG9yLnNjYWxlLnggKz0gYWN0b3Iuc3ggKiBkZWx0YSAvIDEwMDA7XHJcbiAgICAgICAgICAgIGFjdG9yLnNjYWxlLnkgKz0gYWN0b3Iuc3kgKiBkZWx0YSAvIDEwMDA7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gRXVsZXJNb3ZlbWVudDtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkV1bGVyTW92ZW1lbnQgPSBFdWxlck1vdmVtZW50O1xyXG59KTtcclxuZGVmaW5lKFwiVXRpbC9DdWxsaW5nQm94XCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiQWxnZWJyYVwiLCBcIkRyYXdpbmcvQ29sb3JcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBBbGdlYnJhXzEzLCBDb2xvcl8xMykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICB2YXIgQ3VsbGluZ0JveCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gQ3VsbGluZ0JveCgpIHtcclxuICAgICAgICAgICAgdGhpcy5fdG9wTGVmdCA9IG5ldyBBbGdlYnJhXzEzLlZlY3RvcigwLCAwKTtcclxuICAgICAgICAgICAgdGhpcy5fdG9wUmlnaHQgPSBuZXcgQWxnZWJyYV8xMy5WZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2JvdHRvbUxlZnQgPSBuZXcgQWxnZWJyYV8xMy5WZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2JvdHRvbVJpZ2h0ID0gbmV3IEFsZ2VicmFfMTMuVmVjdG9yKDAsIDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBDdWxsaW5nQm94LnByb3RvdHlwZS5pc1Nwcml0ZU9mZlNjcmVlbiA9IGZ1bmN0aW9uIChhY3RvciwgZW5naW5lKSB7XHJcbiAgICAgICAgICAgIHZhciBkcmF3aW5nV2lkdGggPSBhY3Rvci5jdXJyZW50RHJhd2luZy53aWR0aDtcclxuICAgICAgICAgICAgdmFyIGRyYXdpbmdIZWlnaHQgPSBhY3Rvci5jdXJyZW50RHJhd2luZy5oZWlnaHQ7XHJcbiAgICAgICAgICAgIHZhciByb3RhdGlvbiA9IGFjdG9yLnJvdGF0aW9uO1xyXG4gICAgICAgICAgICB2YXIgYW5jaG9yID0gYWN0b3IuZ2V0Q2VudGVyKCk7XHJcbiAgICAgICAgICAgIHZhciB3b3JsZFBvcyA9IGFjdG9yLmdldFdvcmxkUG9zKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3RvcExlZnQueCA9IHdvcmxkUG9zLnggLSAoZHJhd2luZ1dpZHRoIC8gMik7XHJcbiAgICAgICAgICAgIHRoaXMuX3RvcExlZnQueSA9IHdvcmxkUG9zLnkgLSAoZHJhd2luZ0hlaWdodCAvIDIpO1xyXG4gICAgICAgICAgICB0aGlzLl90b3BMZWZ0ID0gdGhpcy5fdG9wTGVmdC5yb3RhdGUocm90YXRpb24sIGFuY2hvcik7XHJcbiAgICAgICAgICAgIHRoaXMuX3RvcFJpZ2h0LnggPSB3b3JsZFBvcy54ICsgKGRyYXdpbmdXaWR0aCAvIDIpO1xyXG4gICAgICAgICAgICB0aGlzLl90b3BSaWdodC55ID0gd29ybGRQb3MueSAtIChkcmF3aW5nSGVpZ2h0IC8gMik7XHJcbiAgICAgICAgICAgIHRoaXMuX3RvcFJpZ2h0ID0gdGhpcy5fdG9wUmlnaHQucm90YXRlKHJvdGF0aW9uLCBhbmNob3IpO1xyXG4gICAgICAgICAgICB0aGlzLl9ib3R0b21MZWZ0LnggPSB3b3JsZFBvcy54IC0gKGRyYXdpbmdXaWR0aCAvIDIpO1xyXG4gICAgICAgICAgICB0aGlzLl9ib3R0b21MZWZ0LnkgPSB3b3JsZFBvcy55ICsgKGRyYXdpbmdIZWlnaHQgLyAyKTtcclxuICAgICAgICAgICAgdGhpcy5fYm90dG9tTGVmdCA9IHRoaXMuX2JvdHRvbUxlZnQucm90YXRlKHJvdGF0aW9uLCBhbmNob3IpO1xyXG4gICAgICAgICAgICB0aGlzLl9ib3R0b21SaWdodC54ID0gd29ybGRQb3MueCArIChkcmF3aW5nV2lkdGggLyAyKTtcclxuICAgICAgICAgICAgdGhpcy5fYm90dG9tUmlnaHQueSA9IHdvcmxkUG9zLnkgKyAoZHJhd2luZ0hlaWdodCAvIDIpO1xyXG4gICAgICAgICAgICB0aGlzLl9ib3R0b21SaWdodCA9IHRoaXMuX2JvdHRvbVJpZ2h0LnJvdGF0ZShyb3RhdGlvbiwgYW5jaG9yKTtcclxuICAgICAgICAgICAgLy8vXHJcbiAgICAgICAgICAgIHZhciB0b3BMZWZ0U2NyZWVuID0gZW5naW5lLndvcmxkVG9TY3JlZW5Db29yZGluYXRlcyh0aGlzLl90b3BMZWZ0KTtcclxuICAgICAgICAgICAgdmFyIHRvcFJpZ2h0U2NyZWVuID0gZW5naW5lLndvcmxkVG9TY3JlZW5Db29yZGluYXRlcyh0aGlzLl90b3BSaWdodCk7XHJcbiAgICAgICAgICAgIHZhciBib3R0b21MZWZ0U2NyZWVuID0gZW5naW5lLndvcmxkVG9TY3JlZW5Db29yZGluYXRlcyh0aGlzLl9ib3R0b21MZWZ0KTtcclxuICAgICAgICAgICAgdmFyIGJvdHRvbVJpZ2h0U2NyZWVuID0gZW5naW5lLndvcmxkVG9TY3JlZW5Db29yZGluYXRlcyh0aGlzLl9ib3R0b21SaWdodCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3hDb29yZHMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5feUNvb3JkcyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLl94Q29vcmRzLnB1c2godG9wTGVmdFNjcmVlbi54LCB0b3BSaWdodFNjcmVlbi54LCBib3R0b21MZWZ0U2NyZWVuLngsIGJvdHRvbVJpZ2h0U2NyZWVuLngpO1xyXG4gICAgICAgICAgICB0aGlzLl95Q29vcmRzLnB1c2godG9wTGVmdFNjcmVlbi55LCB0b3BSaWdodFNjcmVlbi55LCBib3R0b21MZWZ0U2NyZWVuLnksIGJvdHRvbVJpZ2h0U2NyZWVuLnkpO1xyXG4gICAgICAgICAgICB0aGlzLl94TWluID0gTWF0aC5taW4uYXBwbHkobnVsbCwgdGhpcy5feENvb3Jkcyk7XHJcbiAgICAgICAgICAgIHRoaXMuX3lNaW4gPSBNYXRoLm1pbi5hcHBseShudWxsLCB0aGlzLl95Q29vcmRzKTtcclxuICAgICAgICAgICAgdGhpcy5feE1heCA9IE1hdGgubWF4LmFwcGx5KG51bGwsIHRoaXMuX3hDb29yZHMpO1xyXG4gICAgICAgICAgICB0aGlzLl95TWF4ID0gTWF0aC5tYXguYXBwbHkobnVsbCwgdGhpcy5feUNvb3Jkcyk7XHJcbiAgICAgICAgICAgIHZhciBtaW5Xb3JsZCA9IGVuZ2luZS5zY3JlZW5Ub1dvcmxkQ29vcmRpbmF0ZXMobmV3IEFsZ2VicmFfMTMuVmVjdG9yKHRoaXMuX3hNaW4sIHRoaXMuX3lNaW4pKTtcclxuICAgICAgICAgICAgdmFyIG1heFdvcmxkID0gZW5naW5lLnNjcmVlblRvV29ybGRDb29yZGluYXRlcyhuZXcgQWxnZWJyYV8xMy5WZWN0b3IodGhpcy5feE1heCwgdGhpcy5feU1heCkpO1xyXG4gICAgICAgICAgICB0aGlzLl94TWluV29ybGQgPSBtaW5Xb3JsZC54O1xyXG4gICAgICAgICAgICB0aGlzLl95TWluV29ybGQgPSBtaW5Xb3JsZC55O1xyXG4gICAgICAgICAgICB0aGlzLl94TWF4V29ybGQgPSBtYXhXb3JsZC54O1xyXG4gICAgICAgICAgICB0aGlzLl95TWF4V29ybGQgPSBtYXhXb3JsZC55O1xyXG4gICAgICAgICAgICB2YXIgYm91bmRpbmdQb2ludHMgPSBbXHJcbiAgICAgICAgICAgICAgICBuZXcgQWxnZWJyYV8xMy5WZWN0b3IodGhpcy5feE1pbiwgdGhpcy5feU1pbiksXHJcbiAgICAgICAgICAgICAgICBuZXcgQWxnZWJyYV8xMy5WZWN0b3IodGhpcy5feE1heCwgdGhpcy5feU1pbiksXHJcbiAgICAgICAgICAgICAgICBuZXcgQWxnZWJyYV8xMy5WZWN0b3IodGhpcy5feE1pbiwgdGhpcy5feU1heCksXHJcbiAgICAgICAgICAgICAgICBuZXcgQWxnZWJyYV8xMy5WZWN0b3IodGhpcy5feE1heCwgdGhpcy5feU1heClcclxuICAgICAgICAgICAgXTsgLy8gYm90dG9tcmlnaHRcclxuICAgICAgICAgICAgLy8gc3ByaXRlIGNhbiBiZSB3aWRlciB0aGFuIGNhbnZhcyBzY3JlZW4gKGFuZCBzdGlsbCB2aXNpYmxlIHdpdGhpbiBjYW52YXMpXHJcbiAgICAgICAgICAgIC8vIHRvcCBvciBib3R0b20gb2Ygc3ByaXRlIG11c3QgYmUgd2l0aGluIGNhbnZhc1xyXG4gICAgICAgICAgICBpZiAoYm91bmRpbmdQb2ludHNbMF0ueCA8IDAgJiYgYm91bmRpbmdQb2ludHNbMV0ueCA+IGVuZ2luZS5jYW52YXMuY2xpZW50V2lkdGggJiZcclxuICAgICAgICAgICAgICAgIChib3VuZGluZ1BvaW50c1swXS55ID4gMCB8fCBib3VuZGluZ1BvaW50c1syXS55IDwgZW5naW5lLmNhbnZhcy5jbGllbnRIZWlnaHQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gc3ByaXRlIGNhbiBiZSB0YWxsZXIgdGhhbiBjYW52YXMgc2NyZWVuIChhbmQgc3RpbGwgdmlzaWJsZSB3aXRoaW4gY2FudmFzKVxyXG4gICAgICAgICAgICAvLyBsZWZ0IG9yIHJpZ2h0IG9mIHNwcml0ZSBtdXN0IGJlIHdpdGhpbiBjYW52YXNcclxuICAgICAgICAgICAgaWYgKGJvdW5kaW5nUG9pbnRzWzBdLnkgPCAwICYmIGJvdW5kaW5nUG9pbnRzWzJdLnkgPiBlbmdpbmUuY2FudmFzLmNsaWVudEhlaWdodCAmJlxyXG4gICAgICAgICAgICAgICAgKGJvdW5kaW5nUG9pbnRzWzFdLnggPiAwIHx8IGJvdW5kaW5nUG9pbnRzWzBdLnggPCBlbmdpbmUuY2FudmFzLmNsaWVudFdpZHRoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBpZiBhbnkgY29ybmVyIGlzIHZpc2libGUsIHdlJ3JlIG5vdCBvZmZzY3JlZW5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZGluZ1BvaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGJvdW5kaW5nUG9pbnRzW2ldLnggPiAwICYmXHJcbiAgICAgICAgICAgICAgICAgICAgYm91bmRpbmdQb2ludHNbaV0ueSA+IDAgJiZcclxuICAgICAgICAgICAgICAgICAgICBib3VuZGluZ1BvaW50c1tpXS54IDwgZW5naW5lLmNhbnZhcy5jbGllbnRXaWR0aCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kaW5nUG9pbnRzW2ldLnkgPCBlbmdpbmUuY2FudmFzLmNsaWVudEhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEN1bGxpbmdCb3gucHJvdG90eXBlLmRlYnVnRHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICAgICAgICAgICAgLy8gYm91bmRpbmcgcmVjdGFuZ2xlXHJcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gQ29sb3JfMTMuQ29sb3IuV2hpdGUudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgY3R4LnJlY3QodGhpcy5feE1pbldvcmxkLCB0aGlzLl95TWluV29ybGQsIHRoaXMuX3hNYXhXb3JsZCAtIHRoaXMuX3hNaW5Xb3JsZCwgdGhpcy5feU1heFdvcmxkIC0gdGhpcy5feU1pbldvcmxkKTtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gQ29sb3JfMTMuQ29sb3IuUmVkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgY3R4LmFyYyh0aGlzLl90b3BMZWZ0LngsIHRoaXMuX3RvcExlZnQueSwgNSwgMCwgTWF0aC5QSSAqIDIpO1xyXG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XHJcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBDb2xvcl8xMy5Db2xvci5HcmVlbi50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5hcmModGhpcy5fdG9wUmlnaHQueCwgdGhpcy5fdG9wUmlnaHQueSwgNSwgMCwgTWF0aC5QSSAqIDIpO1xyXG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XHJcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBDb2xvcl8xMy5Db2xvci5CbHVlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgY3R4LmFyYyh0aGlzLl9ib3R0b21MZWZ0LngsIHRoaXMuX2JvdHRvbUxlZnQueSwgNSwgMCwgTWF0aC5QSSAqIDIpO1xyXG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XHJcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBDb2xvcl8xMy5Db2xvci5NYWdlbnRhLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgY3R4LmFyYyh0aGlzLl9ib3R0b21SaWdodC54LCB0aGlzLl9ib3R0b21SaWdodC55LCA1LCAwLCBNYXRoLlBJICogMik7XHJcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgY3R4LmZpbGwoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBDdWxsaW5nQm94O1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuQ3VsbGluZ0JveCA9IEN1bGxpbmdCb3g7XHJcbn0pO1xyXG5kZWZpbmUoXCJUcmFpdHMvT2Zmc2NyZWVuQ3VsbGluZ1wiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIlV0aWwvQ3VsbGluZ0JveFwiLCBcIkFsZ2VicmFcIiwgXCJFdmVudHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBDdWxsaW5nQm94XzEsIEFsZ2VicmFfMTQsIEV2ZW50c18zKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIHZhciBPZmZzY3JlZW5DdWxsaW5nID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBPZmZzY3JlZW5DdWxsaW5nKCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1bGxpbmdCb3ggPSBuZXcgQ3VsbGluZ0JveF8xLkN1bGxpbmdCb3goKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgT2Zmc2NyZWVuQ3VsbGluZy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGFjdG9yLCBlbmdpbmUpIHtcclxuICAgICAgICAgICAgdmFyIGV2ZW50RGlzcGF0Y2hlciA9IGFjdG9yLmV2ZW50RGlzcGF0Y2hlcjtcclxuICAgICAgICAgICAgdmFyIGFuY2hvciA9IGFjdG9yLmFuY2hvcjtcclxuICAgICAgICAgICAgdmFyIGdsb2JhbFNjYWxlID0gYWN0b3IuZ2V0R2xvYmFsU2NhbGUoKTtcclxuICAgICAgICAgICAgdmFyIHdpZHRoID0gZ2xvYmFsU2NhbGUueCAqIGFjdG9yLmdldFdpZHRoKCkgLyBhY3Rvci5zY2FsZS54O1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gZ2xvYmFsU2NhbGUueSAqIGFjdG9yLmdldEhlaWdodCgpIC8gYWN0b3Iuc2NhbGUueTtcclxuICAgICAgICAgICAgdmFyIHdvcmxkUG9zID0gYWN0b3IuZ2V0V29ybGRQb3MoKTtcclxuICAgICAgICAgICAgdmFyIGFjdG9yU2NyZWVuQ29vcmRzID0gZW5naW5lLndvcmxkVG9TY3JlZW5Db29yZGluYXRlcyhuZXcgQWxnZWJyYV8xNC5WZWN0b3Iod29ybGRQb3MueCAtIGFuY2hvci54ICogd2lkdGgsIHdvcmxkUG9zLnkgLSBhbmNob3IueSAqIGhlaWdodCkpO1xyXG4gICAgICAgICAgICB2YXIgem9vbSA9IDEuMDtcclxuICAgICAgICAgICAgaWYgKGFjdG9yLnNjZW5lICYmIGFjdG9yLnNjZW5lLmNhbWVyYSkge1xyXG4gICAgICAgICAgICAgICAgem9vbSA9IE1hdGguYWJzKGFjdG9yLnNjZW5lLmNhbWVyYS5nZXRab29tKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpc1Nwcml0ZU9mZlNjcmVlbiA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmIChhY3Rvci5jdXJyZW50RHJhd2luZyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpc1Nwcml0ZU9mZlNjcmVlbiA9IHRoaXMuY3VsbGluZ0JveC5pc1Nwcml0ZU9mZlNjcmVlbihhY3RvciwgZW5naW5lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWFjdG9yLmlzT2ZmU2NyZWVuKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGFjdG9yU2NyZWVuQ29vcmRzLnggKyB3aWR0aCAqIHpvb20gPCAwIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0b3JTY3JlZW5Db29yZHMueSArIGhlaWdodCAqIHpvb20gPCAwIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0b3JTY3JlZW5Db29yZHMueCA+IGVuZ2luZS5jYW52YXNXaWR0aCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGFjdG9yU2NyZWVuQ29vcmRzLnkgPiBlbmdpbmUuY2FudmFzSGVpZ2h0KSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGlzU3ByaXRlT2ZmU2NyZWVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnREaXNwYXRjaGVyLmVtaXQoJ2V4aXR2aWV3cG9ydCcsIG5ldyBFdmVudHNfMy5FeGl0Vmlld1BvcnRFdmVudChhY3RvcikpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdG9yLmlzT2ZmU2NyZWVuID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICgoYWN0b3JTY3JlZW5Db29yZHMueCArIHdpZHRoICogem9vbSA+IDAgJiZcclxuICAgICAgICAgICAgICAgICAgICBhY3RvclNjcmVlbkNvb3Jkcy55ICsgaGVpZ2h0ICogem9vbSA+IDAgJiZcclxuICAgICAgICAgICAgICAgICAgICBhY3RvclNjcmVlbkNvb3Jkcy54IDwgZW5naW5lLmNhbnZhc1dpZHRoICYmXHJcbiAgICAgICAgICAgICAgICAgICAgYWN0b3JTY3JlZW5Db29yZHMueSA8IGVuZ2luZS5jYW52YXNIZWlnaHQpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgIWlzU3ByaXRlT2ZmU2NyZWVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnREaXNwYXRjaGVyLmVtaXQoJ2VudGVydmlld3BvcnQnLCBuZXcgRXZlbnRzXzMuRW50ZXJWaWV3UG9ydEV2ZW50KGFjdG9yKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0b3IuaXNPZmZTY3JlZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIE9mZnNjcmVlbkN1bGxpbmc7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5PZmZzY3JlZW5DdWxsaW5nID0gT2Zmc2NyZWVuQ3VsbGluZztcclxufSk7XHJcbmRlZmluZShcIlRyYWl0cy9UaWxlTWFwQ29sbGlzaW9uRGV0ZWN0aW9uXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiQWN0b3JcIiwgXCJDb2xsaXNpb24vU2lkZVwiLCBcIkV2ZW50c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIEFjdG9yXzYsIFNpZGVfMiwgRXZlbnRzXzQpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgdmFyIFRpbGVNYXBDb2xsaXNpb25EZXRlY3Rpb24gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIFRpbGVNYXBDb2xsaXNpb25EZXRlY3Rpb24oKSB7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFRpbGVNYXBDb2xsaXNpb25EZXRlY3Rpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChhY3RvciwgZW5naW5lKSB7XHJcbiAgICAgICAgICAgIHZhciBldmVudERpc3BhdGNoZXIgPSBhY3Rvci5ldmVudERpc3BhdGNoZXI7XHJcbiAgICAgICAgICAgIGlmIChhY3Rvci5jb2xsaXNpb25UeXBlICE9PSBBY3Rvcl82LkNvbGxpc2lvblR5cGUuUHJldmVudENvbGxpc2lvbiAmJiBlbmdpbmUuY3VycmVudFNjZW5lICYmIGVuZ2luZS5jdXJyZW50U2NlbmUudGlsZU1hcHMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZW5naW5lLmN1cnJlbnRTY2VuZS50aWxlTWFwcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXAgPSBlbmdpbmUuY3VycmVudFNjZW5lLnRpbGVNYXBzW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnRlcnNlY3RNYXA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpZGUgPSBTaWRlXzIuU2lkZS5Ob25lO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXggPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpbnRlcnNlY3RNYXAgPSBtYXAuY29sbGlkZXMoYWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXgtLSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZGUgPSBhY3Rvci5nZXRTaWRlRnJvbUludGVyc2VjdChpbnRlcnNlY3RNYXApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudERpc3BhdGNoZXIuZW1pdCgncHJlY29sbGlzaW9uJywgbmV3IEV2ZW50c180LlByZUNvbGxpc2lvbkV2ZW50KGFjdG9yLCBudWxsLCBzaWRlLCBpbnRlcnNlY3RNYXApKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFjdG9yLmNvbGxpc2lvblR5cGUgPT09IEFjdG9yXzYuQ29sbGlzaW9uVHlwZS5BY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdG9yLnBvcy55ICs9IGludGVyc2VjdE1hcC55O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0b3IucG9zLnggKz0gaW50ZXJzZWN0TWFwLng7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudERpc3BhdGNoZXIuZW1pdCgncG9zdGNvbGxpc2lvbicsIG5ldyBFdmVudHNfNC5Qb3N0Q29sbGlzaW9uRXZlbnQoYWN0b3IsIG51bGwsIHNpZGUsIGludGVyc2VjdE1hcCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gVGlsZU1hcENvbGxpc2lvbkRldGVjdGlvbjtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLlRpbGVNYXBDb2xsaXNpb25EZXRlY3Rpb24gPSBUaWxlTWFwQ29sbGlzaW9uRGV0ZWN0aW9uO1xyXG59KTtcclxuZGVmaW5lKFwiVHJhaXRzL0luZGV4XCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiVHJhaXRzL0NhcHR1cmVQb2ludGVyXCIsIFwiVHJhaXRzL0V1bGVyTW92ZW1lbnRcIiwgXCJUcmFpdHMvT2Zmc2NyZWVuQ3VsbGluZ1wiLCBcIlRyYWl0cy9UaWxlTWFwQ29sbGlzaW9uRGV0ZWN0aW9uXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgQ2FwdHVyZVBvaW50ZXJfMSwgRXVsZXJNb3ZlbWVudF8xLCBPZmZzY3JlZW5DdWxsaW5nXzEsIFRpbGVNYXBDb2xsaXNpb25EZXRlY3Rpb25fMSkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBmdW5jdGlvbiBfX2V4cG9ydChtKSB7XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgX19leHBvcnQoQ2FwdHVyZVBvaW50ZXJfMSk7XHJcbiAgICBfX2V4cG9ydChFdWxlck1vdmVtZW50XzEpO1xyXG4gICAgX19leHBvcnQoT2Zmc2NyZWVuQ3VsbGluZ18xKTtcclxuICAgIF9fZXhwb3J0KFRpbGVNYXBDb2xsaXNpb25EZXRlY3Rpb25fMSk7XHJcbn0pO1xyXG5kZWZpbmUoXCJQYXJ0aWNsZXNcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJBY3RvclwiLCBcIkRyYXdpbmcvQ29sb3JcIiwgXCJBbGdlYnJhXCIsIFwiVXRpbC9VdGlsXCIsIFwiVXRpbC9EcmF3VXRpbFwiLCBcIlRyYWl0cy9JbmRleFwiLCBcIkNvbmZpZ3VyYWJsZVwiLCBcIk1hdGgvUmFuZG9tXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgQWN0b3JfNywgQ29sb3JfMTQsIEFsZ2VicmFfMTUsIFV0aWwsIERyYXdVdGlsLCBUcmFpdHMsIENvbmZpZ3VyYWJsZV81LCBSYW5kb21fMikge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEFuIGVudW0gdGhhdCByZXByZXNlbnRzIHRoZSB0eXBlcyBvZiBlbWl0dGVyIG5venpsZXNcclxuICAgICAqL1xyXG4gICAgdmFyIEVtaXR0ZXJUeXBlO1xyXG4gICAgKGZ1bmN0aW9uIChFbWl0dGVyVHlwZSkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0YW50IGZvciB0aGUgY2lyY3VsYXIgZW1pdHRlciB0eXBlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRW1pdHRlclR5cGVbRW1pdHRlclR5cGVbXCJDaXJjbGVcIl0gPSAwXSA9IFwiQ2lyY2xlXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uc3RhbnQgZm9yIHRoZSByZWN0YW5ndWxhciBlbWl0dGVyIHR5cGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBFbWl0dGVyVHlwZVtFbWl0dGVyVHlwZVtcIlJlY3RhbmdsZVwiXSA9IDFdID0gXCJSZWN0YW5nbGVcIjtcclxuICAgIH0pKEVtaXR0ZXJUeXBlID0gZXhwb3J0cy5FbWl0dGVyVHlwZSB8fCAoZXhwb3J0cy5FbWl0dGVyVHlwZSA9IHt9KSk7XHJcbiAgICAvKipcclxuICAgICAqIEBoaWRkZW5cclxuICAgICAqL1xyXG4gICAgdmFyIFBhcnRpY2xlSW1wbCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gUGFydGljbGVJbXBsKGVtaXR0ZXJPckNvbmZpZywgbGlmZSwgb3BhY2l0eSwgYmVnaW5Db2xvciwgZW5kQ29sb3IsIHBvc2l0aW9uLCB2ZWxvY2l0eSwgYWNjZWxlcmF0aW9uLCBzdGFydFNpemUsIGVuZFNpemUpIHtcclxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IG5ldyBBbGdlYnJhXzE1LlZlY3RvcigwLCAwKTtcclxuICAgICAgICAgICAgdGhpcy52ZWxvY2l0eSA9IG5ldyBBbGdlYnJhXzE1LlZlY3RvcigwLCAwKTtcclxuICAgICAgICAgICAgdGhpcy5hY2NlbGVyYXRpb24gPSBuZXcgQWxnZWJyYV8xNS5WZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMucGFydGljbGVSb3RhdGlvbmFsVmVsb2NpdHkgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRSb3RhdGlvbiA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuZm9jdXMgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmZvY3VzQWNjZWwgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLm9wYWNpdHkgPSAxO1xyXG4gICAgICAgICAgICB0aGlzLmJlZ2luQ29sb3IgPSBDb2xvcl8xNC5Db2xvci5XaGl0ZS5jbG9uZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmVuZENvbG9yID0gQ29sb3JfMTQuQ29sb3IuV2hpdGUuY2xvbmUoKTtcclxuICAgICAgICAgICAgLy8gTGlmZSBpcyBjb3VudGVkIGluIG1zXHJcbiAgICAgICAgICAgIHRoaXMubGlmZSA9IDMwMDtcclxuICAgICAgICAgICAgdGhpcy5mYWRlRmxhZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvLyBDb2xvciB0cmFuc2l0aW9uc1xyXG4gICAgICAgICAgICB0aGlzLl9yUmF0ZSA9IDE7XHJcbiAgICAgICAgICAgIHRoaXMuX2dSYXRlID0gMTtcclxuICAgICAgICAgICAgdGhpcy5fYlJhdGUgPSAxO1xyXG4gICAgICAgICAgICB0aGlzLl9hUmF0ZSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRDb2xvciA9IENvbG9yXzE0LkNvbG9yLldoaXRlLmNsb25lKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlciA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMucGFydGljbGVTaXplID0gNTtcclxuICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZVNwcml0ZSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuc2l6ZVJhdGUgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmVsYXBzZWRNdWx0aXBsaWVyID0gMDtcclxuICAgICAgICAgICAgdmFyIGVtaXR0ZXIgPSBlbWl0dGVyT3JDb25maWc7XHJcbiAgICAgICAgICAgIGlmIChlbWl0dGVyICYmICEoZW1pdHRlck9yQ29uZmlnIGluc3RhbmNlb2YgUGFydGljbGVFbWl0dGVyKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbmZpZyA9IGVtaXR0ZXJPckNvbmZpZztcclxuICAgICAgICAgICAgICAgIGVtaXR0ZXIgPSBjb25maWcuZW1pdHRlcjtcclxuICAgICAgICAgICAgICAgIGxpZmUgPSBjb25maWcubGlmZTtcclxuICAgICAgICAgICAgICAgIG9wYWNpdHkgPSBjb25maWcub3BhY2l0eTtcclxuICAgICAgICAgICAgICAgIGVuZENvbG9yID0gY29uZmlnLmVuZENvbG9yO1xyXG4gICAgICAgICAgICAgICAgYmVnaW5Db2xvciA9IGNvbmZpZy5iZWdpbkNvbG9yO1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSBjb25maWcucG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICB2ZWxvY2l0eSA9IGNvbmZpZy52ZWxvY2l0eTtcclxuICAgICAgICAgICAgICAgIGFjY2VsZXJhdGlvbiA9IGNvbmZpZy5hY2NlbGVyYXRpb247XHJcbiAgICAgICAgICAgICAgICBzdGFydFNpemUgPSBjb25maWcuc3RhcnRTaXplO1xyXG4gICAgICAgICAgICAgICAgZW5kU2l6ZSA9IGNvbmZpZy5lbmRTaXplO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlciA9IGVtaXR0ZXI7XHJcbiAgICAgICAgICAgIHRoaXMubGlmZSA9IGxpZmUgfHwgdGhpcy5saWZlO1xyXG4gICAgICAgICAgICB0aGlzLm9wYWNpdHkgPSBvcGFjaXR5IHx8IHRoaXMub3BhY2l0eTtcclxuICAgICAgICAgICAgdGhpcy5lbmRDb2xvciA9IGVuZENvbG9yIHx8IHRoaXMuZW5kQ29sb3IuY2xvbmUoKTtcclxuICAgICAgICAgICAgdGhpcy5iZWdpbkNvbG9yID0gYmVnaW5Db2xvciB8fCB0aGlzLmJlZ2luQ29sb3IuY2xvbmUoKTtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudENvbG9yID0gdGhpcy5iZWdpbkNvbG9yLmNsb25lKCk7XHJcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbiB8fCB0aGlzLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICB0aGlzLnZlbG9jaXR5ID0gdmVsb2NpdHkgfHwgdGhpcy52ZWxvY2l0eTtcclxuICAgICAgICAgICAgdGhpcy5hY2NlbGVyYXRpb24gPSBhY2NlbGVyYXRpb24gfHwgdGhpcy5hY2NlbGVyYXRpb247XHJcbiAgICAgICAgICAgIHRoaXMuX3JSYXRlID0gKHRoaXMuZW5kQ29sb3IuciAtIHRoaXMuYmVnaW5Db2xvci5yKSAvIHRoaXMubGlmZTtcclxuICAgICAgICAgICAgdGhpcy5fZ1JhdGUgPSAodGhpcy5lbmRDb2xvci5nIC0gdGhpcy5iZWdpbkNvbG9yLmcpIC8gdGhpcy5saWZlO1xyXG4gICAgICAgICAgICB0aGlzLl9iUmF0ZSA9ICh0aGlzLmVuZENvbG9yLmIgLSB0aGlzLmJlZ2luQ29sb3IuYikgLyB0aGlzLmxpZmU7XHJcbiAgICAgICAgICAgIHRoaXMuX2FSYXRlID0gdGhpcy5vcGFjaXR5IC8gdGhpcy5saWZlO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0U2l6ZSA9IHN0YXJ0U2l6ZSB8fCAwO1xyXG4gICAgICAgICAgICB0aGlzLmVuZFNpemUgPSBlbmRTaXplIHx8IDA7XHJcbiAgICAgICAgICAgIGlmICgodGhpcy5lbmRTaXplID4gMCkgJiYgKHRoaXMuc3RhcnRTaXplID4gMCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2l6ZVJhdGUgPSAodGhpcy5lbmRTaXplIC0gdGhpcy5zdGFydFNpemUpIC8gdGhpcy5saWZlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZVNpemUgPSB0aGlzLnN0YXJ0U2l6ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBQYXJ0aWNsZUltcGwucHJvdG90eXBlLmtpbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci5yZW1vdmVQYXJ0aWNsZSh0aGlzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFBhcnRpY2xlSW1wbC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGlmZSA9IHRoaXMubGlmZSAtIGRlbHRhO1xyXG4gICAgICAgICAgICB0aGlzLmVsYXBzZWRNdWx0aXBsaWVyID0gdGhpcy5lbGFwc2VkTXVsdGlwbGllciArIGRlbHRhO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5saWZlIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5raWxsKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuZmFkZUZsYWcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3BhY2l0eSA9IFV0aWwuY2xhbXAodGhpcy5fYVJhdGUgKiB0aGlzLmxpZmUsIDAuMDAwMSwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCh0aGlzLnN0YXJ0U2l6ZSA+IDApICYmICh0aGlzLmVuZFNpemUgPiAwKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZVNpemUgPSBVdGlsLmNsYW1wKHRoaXMuc2l6ZVJhdGUgKiBkZWx0YSArIHRoaXMucGFydGljbGVTaXplLCBNYXRoLm1pbih0aGlzLnN0YXJ0U2l6ZSwgdGhpcy5lbmRTaXplKSwgTWF0aC5tYXgodGhpcy5zdGFydFNpemUsIHRoaXMuZW5kU2l6ZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRDb2xvci5yID0gVXRpbC5jbGFtcCh0aGlzLl9jdXJyZW50Q29sb3IuciArIHRoaXMuX3JSYXRlICogZGVsdGEsIDAsIDI1NSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRDb2xvci5nID0gVXRpbC5jbGFtcCh0aGlzLl9jdXJyZW50Q29sb3IuZyArIHRoaXMuX2dSYXRlICogZGVsdGEsIDAsIDI1NSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRDb2xvci5iID0gVXRpbC5jbGFtcCh0aGlzLl9jdXJyZW50Q29sb3IuYiArIHRoaXMuX2JSYXRlICogZGVsdGEsIDAsIDI1NSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRDb2xvci5hID0gVXRpbC5jbGFtcCh0aGlzLm9wYWNpdHksIDAuMDAwMSwgMSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZvY3VzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWNjZWwgPSB0aGlzLmZvY3VzLnN1Yih0aGlzLnBvc2l0aW9uKS5ub3JtYWxpemUoKS5zY2FsZSh0aGlzLmZvY3VzQWNjZWwpLnNjYWxlKGRlbHRhIC8gMTAwMCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZlbG9jaXR5ID0gdGhpcy52ZWxvY2l0eS5hZGQoYWNjZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52ZWxvY2l0eSA9IHRoaXMudmVsb2NpdHkuYWRkKHRoaXMuYWNjZWxlcmF0aW9uLnNjYWxlKGRlbHRhIC8gMTAwMCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uLmFkZCh0aGlzLnZlbG9jaXR5LnNjYWxlKGRlbHRhIC8gMTAwMCkpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wYXJ0aWNsZVJvdGF0aW9uYWxWZWxvY2l0eSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Um90YXRpb24gPSAodGhpcy5jdXJyZW50Um90YXRpb24gKyB0aGlzLnBhcnRpY2xlUm90YXRpb25hbFZlbG9jaXR5ICogZGVsdGEgLyAxMDAwKSAlICgyICogTWF0aC5QSSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFBhcnRpY2xlSW1wbC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGFydGljbGVTcHJpdGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFydGljbGVTcHJpdGUucm90YXRpb24gPSB0aGlzLmN1cnJlbnRSb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFydGljbGVTcHJpdGUuc2NhbGUuc2V0VG8odGhpcy5wYXJ0aWNsZVNpemUsIHRoaXMucGFydGljbGVTaXplKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFydGljbGVTcHJpdGUuZHJhdyhjdHgsIHRoaXMucG9zaXRpb24ueCwgdGhpcy5wb3NpdGlvbi55KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50Q29sb3IuYSA9IFV0aWwuY2xhbXAodGhpcy5vcGFjaXR5LCAwLjAwMDEsIDEpO1xyXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5fY3VycmVudENvbG9yLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgY3R4LmFyYyh0aGlzLnBvc2l0aW9uLngsIHRoaXMucG9zaXRpb24ueSwgdGhpcy5wYXJ0aWNsZVNpemUsIDAsIE1hdGguUEkgKiAyKTtcclxuICAgICAgICAgICAgY3R4LmZpbGwoKTtcclxuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFBhcnRpY2xlSW1wbDtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLlBhcnRpY2xlSW1wbCA9IFBhcnRpY2xlSW1wbDtcclxuICAgIC8qKlxyXG4gICAgICogUGFydGljbGUgaXMgdXNlZCBpbiBhIFtbUGFydGljbGVFbWl0dGVyXV1cclxuICAgICAqL1xyXG4gICAgdmFyIFBhcnRpY2xlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoUGFydGljbGUsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gUGFydGljbGUoZW1pdHRlck9yQ29uZmlnLCBsaWZlLCBvcGFjaXR5LCBiZWdpbkNvbG9yLCBlbmRDb2xvciwgcG9zaXRpb24sIHZlbG9jaXR5LCBhY2NlbGVyYXRpb24sIHN0YXJ0U2l6ZSwgZW5kU2l6ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgZW1pdHRlck9yQ29uZmlnLCBsaWZlLCBvcGFjaXR5LCBiZWdpbkNvbG9yLCBlbmRDb2xvciwgcG9zaXRpb24sIHZlbG9jaXR5LCBhY2NlbGVyYXRpb24sIHN0YXJ0U2l6ZSwgZW5kU2l6ZSkgfHwgdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFBhcnRpY2xlO1xyXG4gICAgfShDb25maWd1cmFibGVfNS5Db25maWd1cmFibGUoUGFydGljbGVJbXBsKSkpO1xyXG4gICAgZXhwb3J0cy5QYXJ0aWNsZSA9IFBhcnRpY2xlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaGlkZGVuXHJcbiAgICAgKi9cclxuICAgIHZhciBQYXJ0aWNsZUVtaXR0ZXJJbXBsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoUGFydGljbGVFbWl0dGVySW1wbCwgX3N1cGVyKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0geCAgICAgICBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgZW1pdHRlclxyXG4gICAgICAgICAqIEBwYXJhbSB5ICAgICAgIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBlbWl0dGVyXHJcbiAgICAgICAgICogQHBhcmFtIHdpZHRoICAgVGhlIHdpZHRoIG9mIHRoZSBlbWl0dGVyXHJcbiAgICAgICAgICogQHBhcmFtIGhlaWdodCAgVGhlIGhlaWdodCBvZiB0aGUgZW1pdHRlclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIFBhcnRpY2xlRW1pdHRlckltcGwoeE9yQ29uZmlnLCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGVvZiB4T3JDb25maWcgPT09ICdudW1iZXInID8geyB4OiB4T3JDb25maWcsIHk6IHksIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSA6IHhPckNvbmZpZykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMubnVtUGFydGljbGVzID0gMDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgaXNFbWl0dGluZyBmbGFnXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5pc0VtaXR0aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgYmFja2luZyBwYXJ0aWNsZSBjb2xsZWN0aW9uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5wYXJ0aWNsZXMgPSBudWxsO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBiYWNraW5nIGRlYWRQYXJ0aWNsZSBjb2xsZWN0aW9uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5kZWFkUGFydGljbGVzID0gbnVsbDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbWluaW11bSBwYXJ0aWNsZSB2ZWxvY2l0eVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMubWluVmVsID0gMDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbWF4aW11bSBwYXJ0aWNsZSB2ZWxvY2l0eVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMubWF4VmVsID0gMDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgYWNjZWxlcmF0aW9uIHZlY3RvciBmb3IgYWxsIHBhcnRpY2xlc1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuYWNjZWxlcmF0aW9uID0gbmV3IEFsZ2VicmFfMTUuVmVjdG9yKDAsIDApO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBtaW5pbXVtIGFuZ2xlIGluIHJhZGlhbnNcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLm1pbkFuZ2xlID0gMDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbWF4aW11bSBhbmdsZSBpbiByYWRpYW5zXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5tYXhBbmdsZSA9IDA7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGVtaXNzaW9uIHJhdGUgZm9yIHBhcnRpY2xlcyAocGFydGljbGVzL3NlYylcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmVtaXRSYXRlID0gMTsgLy9wYXJ0aWNsZXMvc2VjXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGxpZmUgb2YgZWFjaCBwYXJ0aWNsZSBpbiBtaWxsaXNlY29uZHNcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLnBhcnRpY2xlTGlmZSA9IDIwMDA7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG9wYWNpdHkgb2YgZWFjaCBwYXJ0aWNsZSBmcm9tIDAgdG8gMS4wXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5vcGFjaXR5ID0gMTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgZmFkZSBmbGFnIHdoaWNoIGNhdXNlcyBwYXJ0aWNsZXMgdG8gZ3JhZHVhbGx5IGZhZGUgb3V0IG92ZXIgdGhlIGNvdXJzZSBvZiB0aGVpciBsaWZlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuZmFkZUZsYWcgPSBmYWxzZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgb3B0aW9uYWwgZm9jdXMgd2hlcmUgYWxsIHBhcnRpY2xlcyBzaG91bGQgYWNjZWxlcmF0ZSB0b3dhcmRzXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5mb2N1cyA9IG51bGw7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGFjY2VsZXJhdGlvbiBmb3IgZm9jdXNpbmcgcGFydGljbGVzIGlmIGEgZm9jdXMgaGFzIGJlZW4gc3BlY2lmaWVkXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5mb2N1c0FjY2VsID0gMTtcclxuICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBvcHRpb25hbCBzdGFydGluZyBzaXplIGZvciB0aGUgcGFydGljbGVzXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5zdGFydFNpemUgPSBudWxsO1xyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG9wdGlvbmFsIGVuZGluZyBzaXplIGZvciB0aGUgcGFydGljbGVzXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5lbmRTaXplID0gbnVsbDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbWluaW11bSBzaXplIG9mIGFsbCBwYXJ0aWNsZXNcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLm1pblNpemUgPSA1O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBtYXhpbXVtIHNpemUgb2YgYWxsIHBhcnRpY2xlc1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMubWF4U2l6ZSA9IDU7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGJlZ2lubmluZyBjb2xvciBvZiBhbGwgcGFydGljbGVzXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5iZWdpbkNvbG9yID0gQ29sb3JfMTQuQ29sb3IuV2hpdGUuY2xvbmUoKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgZW5kaW5nIGNvbG9yIG9mIGFsbCBwYXJ0aWNsZXNcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmVuZENvbG9yID0gQ29sb3JfMTQuQ29sb3IuV2hpdGUuY2xvbmUoKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgc3ByaXRlIHRoYXQgYSBwYXJ0aWNsZSBzaG91bGQgdXNlXHJcbiAgICAgICAgICAgICAqIEB3YXJuaW5nIFBlcmZvcm1hbmNlIGludGVuc2l2ZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMucGFydGljbGVTcHJpdGUgPSBudWxsO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBlbWl0dGVyIHR5cGUgZm9yIHRoZSBwYXJ0aWNsZSBlbWl0dGVyXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5lbWl0dGVyVHlwZSA9IEVtaXR0ZXJUeXBlLlJlY3RhbmdsZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgZW1pdHRlciByYWRpdXMsIG9ubHkgdGFrZXMgZWZmZWN0IHdoZW4gdGhlIFtbZW1pdHRlclR5cGVdXSBpcyBbW0VtaXR0ZXJUeXBlLkNpcmNsZV1dXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5yYWRpdXMgPSAwO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBwYXJ0aWNsZSByb3RhdGlvbmFsIHNwZWVkIHZlbG9jaXR5XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5wYXJ0aWNsZVJvdGF0aW9uYWxWZWxvY2l0eSA9IDA7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBwYXJ0aWNsZXMgc2hvdWxkIHN0YXJ0IHdpdGggYSByYW5kb20gcm90YXRpb25cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLnJhbmRvbVJvdGF0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgICAgIF90aGlzLl9wYXJ0aWNsZXNUb0VtaXQgPSAwO1xyXG4gICAgICAgICAgICBfdGhpcy5jb2xsaXNpb25UeXBlID0gQWN0b3JfNy5Db2xsaXNpb25UeXBlLlByZXZlbnRDb2xsaXNpb247XHJcbiAgICAgICAgICAgIF90aGlzLnBhcnRpY2xlcyA9IG5ldyBVdGlsLkNvbGxlY3Rpb24oKTtcclxuICAgICAgICAgICAgX3RoaXMuZGVhZFBhcnRpY2xlcyA9IG5ldyBVdGlsLkNvbGxlY3Rpb24oKTtcclxuICAgICAgICAgICAgX3RoaXMucmFuZG9tID0gbmV3IFJhbmRvbV8yLlJhbmRvbSgpO1xyXG4gICAgICAgICAgICAvLyBSZW1vdmUgb2Zmc2NyZWVuIGN1bGxpbmcgZnJvbSBwYXJ0aWNsZSBlbWl0dGVyc1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzLnRyYWl0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnRyYWl0c1tpXSBpbnN0YW5jZW9mIFRyYWl0cy5PZmZzY3JlZW5DdWxsaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudHJhaXRzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFBhcnRpY2xlRW1pdHRlckltcGwucHJvdG90eXBlLnJlbW92ZVBhcnRpY2xlID0gZnVuY3Rpb24gKHBhcnRpY2xlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVhZFBhcnRpY2xlcy5wdXNoKHBhcnRpY2xlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhdXNlcyB0aGUgZW1pdHRlciB0byBlbWl0IHBhcnRpY2xlc1xyXG4gICAgICAgICAqIEBwYXJhbSBwYXJ0aWNsZUNvdW50ICBOdW1iZXIgb2YgcGFydGljbGVzIHRvIGVtaXQgcmlnaHQgbm93XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUGFydGljbGVFbWl0dGVySW1wbC5wcm90b3R5cGUuZW1pdFBhcnRpY2xlcyA9IGZ1bmN0aW9uIChwYXJ0aWNsZUNvdW50KSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydGljbGVDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnRpY2xlcy5wdXNoKHRoaXMuX2NyZWF0ZVBhcnRpY2xlKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQYXJ0aWNsZUVtaXR0ZXJJbXBsLnByb3RvdHlwZS5jbGVhclBhcnRpY2xlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZXMuY2xlYXIoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIENyZWF0ZXMgYSBuZXcgcGFydGljbGUgZ2l2ZW4gdGhlIGNvbnN0cmFpbnRzIG9mIHRoZSBlbWl0dGVyXHJcbiAgICAgICAgUGFydGljbGVFbWl0dGVySW1wbC5wcm90b3R5cGUuX2NyZWF0ZVBhcnRpY2xlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyB0b2RvIGltcGxlbWVudCBlbWl0dGVyIGNvbnN0cmFpbnRzO1xyXG4gICAgICAgICAgICB2YXIgcmFuWCA9IDA7XHJcbiAgICAgICAgICAgIHZhciByYW5ZID0gMDtcclxuICAgICAgICAgICAgdmFyIGFuZ2xlID0gVXRpbC5yYW5kb21JblJhbmdlKHRoaXMubWluQW5nbGUsIHRoaXMubWF4QW5nbGUsIHRoaXMucmFuZG9tKTtcclxuICAgICAgICAgICAgdmFyIHZlbCA9IFV0aWwucmFuZG9tSW5SYW5nZSh0aGlzLm1pblZlbCwgdGhpcy5tYXhWZWwsIHRoaXMucmFuZG9tKTtcclxuICAgICAgICAgICAgdmFyIHNpemUgPSB0aGlzLnN0YXJ0U2l6ZSB8fCBVdGlsLnJhbmRvbUluUmFuZ2UodGhpcy5taW5TaXplLCB0aGlzLm1heFNpemUsIHRoaXMucmFuZG9tKTtcclxuICAgICAgICAgICAgdmFyIGR4ID0gdmVsICogTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgICAgICAgICB2YXIgZHkgPSB2ZWwgKiBNYXRoLnNpbihhbmdsZSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVtaXR0ZXJUeXBlID09PSBFbWl0dGVyVHlwZS5SZWN0YW5nbGUpIHtcclxuICAgICAgICAgICAgICAgIHJhblggPSBVdGlsLnJhbmRvbUluUmFuZ2UodGhpcy5wb3MueCwgdGhpcy5wb3MueCArIHRoaXMuZ2V0V2lkdGgoKSwgdGhpcy5yYW5kb20pO1xyXG4gICAgICAgICAgICAgICAgcmFuWSA9IFV0aWwucmFuZG9tSW5SYW5nZSh0aGlzLnBvcy55LCB0aGlzLnBvcy55ICsgdGhpcy5nZXRIZWlnaHQoKSwgdGhpcy5yYW5kb20pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuZW1pdHRlclR5cGUgPT09IEVtaXR0ZXJUeXBlLkNpcmNsZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJhZGl1cyA9IFV0aWwucmFuZG9tSW5SYW5nZSgwLCB0aGlzLnJhZGl1cywgdGhpcy5yYW5kb20pO1xyXG4gICAgICAgICAgICAgICAgcmFuWCA9IHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlKSArIHRoaXMucG9zLng7XHJcbiAgICAgICAgICAgICAgICByYW5ZID0gcmFkaXVzICogTWF0aC5zaW4oYW5nbGUpICsgdGhpcy5wb3MueTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcCA9IG5ldyBQYXJ0aWNsZSh0aGlzLCB0aGlzLnBhcnRpY2xlTGlmZSwgdGhpcy5vcGFjaXR5LCB0aGlzLmJlZ2luQ29sb3IsIHRoaXMuZW5kQ29sb3IsIG5ldyBBbGdlYnJhXzE1LlZlY3RvcihyYW5YLCByYW5ZKSwgbmV3IEFsZ2VicmFfMTUuVmVjdG9yKGR4LCBkeSksIHRoaXMuYWNjZWxlcmF0aW9uLCB0aGlzLnN0YXJ0U2l6ZSwgdGhpcy5lbmRTaXplKTtcclxuICAgICAgICAgICAgcC5mYWRlRmxhZyA9IHRoaXMuZmFkZUZsYWc7XHJcbiAgICAgICAgICAgIHAucGFydGljbGVTaXplID0gc2l6ZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGFydGljbGVTcHJpdGUpIHtcclxuICAgICAgICAgICAgICAgIHAucGFydGljbGVTcHJpdGUgPSB0aGlzLnBhcnRpY2xlU3ByaXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHAucGFydGljbGVSb3RhdGlvbmFsVmVsb2NpdHkgPSB0aGlzLnBhcnRpY2xlUm90YXRpb25hbFZlbG9jaXR5O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5yYW5kb21Sb3RhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcC5jdXJyZW50Um90YXRpb24gPSBVdGlsLnJhbmRvbUluUmFuZ2UoMCwgTWF0aC5QSSAqIDIsIHRoaXMucmFuZG9tKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5mb2N1cykge1xyXG4gICAgICAgICAgICAgICAgcC5mb2N1cyA9IHRoaXMuZm9jdXMuYWRkKG5ldyBBbGdlYnJhXzE1LlZlY3Rvcih0aGlzLnBvcy54LCB0aGlzLnBvcy55KSk7XHJcbiAgICAgICAgICAgICAgICBwLmZvY3VzQWNjZWwgPSB0aGlzLmZvY3VzQWNjZWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQYXJ0aWNsZUVtaXR0ZXJJbXBsLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZW5naW5lLCBkZWx0YSkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMsIGVuZ2luZSwgZGVsdGEpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0VtaXR0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJ0aWNsZXNUb0VtaXQgKz0gdGhpcy5lbWl0UmF0ZSAqIChkZWx0YSAvIDEwMDApO1xyXG4gICAgICAgICAgICAgICAgLy92YXIgbnVtUGFydGljbGVzID0gTWF0aC5jZWlsKHRoaXMuZW1pdFJhdGUgKiBkZWx0YSAvIDEwMDApO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3BhcnRpY2xlc1RvRW1pdCA+IDEuMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdFBhcnRpY2xlcyhNYXRoLmZsb29yKHRoaXMuX3BhcnRpY2xlc1RvRW1pdCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnRpY2xlc1RvRW1pdCA9IHRoaXMuX3BhcnRpY2xlc1RvRW1pdCAtIE1hdGguZmxvb3IodGhpcy5fcGFydGljbGVzVG9FbWl0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnBhcnRpY2xlcy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLnVwZGF0ZShkZWx0YSk7IH0pO1xyXG4gICAgICAgICAgICB0aGlzLmRlYWRQYXJ0aWNsZXMuZm9yRWFjaChmdW5jdGlvbiAocCkgeyByZXR1cm4gX3RoaXMucGFydGljbGVzLnJlbW92ZUVsZW1lbnQocCk7IH0pO1xyXG4gICAgICAgICAgICB0aGlzLmRlYWRQYXJ0aWNsZXMuY2xlYXIoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFBhcnRpY2xlRW1pdHRlckltcGwucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgICAgICAgICAgIC8vIHRvZG8gaXMgdGhlcmUgYSBtb3JlIGVmZmljaWVudCB0byBkcmF3IFxyXG4gICAgICAgICAgICAvLyBwb3NzaWJseSB1c2UgYSB3ZWJnbCBvZmZzY3JlZW4gY2FudmFzIGFuZCBzaGFkZXJzIHRvIGRvIHBhcnRpY2xlcz9cclxuICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZXMuZm9yRWFjaChmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5kcmF3KGN0eCk7IH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUGFydGljbGVFbWl0dGVySW1wbC5wcm90b3R5cGUuZGVidWdEcmF3ID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRlYnVnRHJhdy5jYWxsKHRoaXMsIGN0eCk7XHJcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBDb2xvcl8xNC5Db2xvci5CbGFjay50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBjdHguZmlsbFRleHQoJ1BhcnRpY2xlczogJyArIHRoaXMucGFydGljbGVzLmNvdW50KCksIHRoaXMucG9zLngsIHRoaXMucG9zLnkgKyAyMCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZvY3VzKSB7XHJcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QodGhpcy5mb2N1cy54ICsgdGhpcy5wb3MueCwgdGhpcy5mb2N1cy55ICsgdGhpcy5wb3MueSwgMywgMyk7XHJcbiAgICAgICAgICAgICAgICBEcmF3VXRpbC5saW5lKGN0eCwgQ29sb3JfMTQuQ29sb3IuWWVsbG93LCB0aGlzLmZvY3VzLnggKyB0aGlzLnBvcy54LCB0aGlzLmZvY3VzLnkgKyB0aGlzLnBvcy55LCBfc3VwZXIucHJvdG90eXBlLmdldENlbnRlci5jYWxsKHRoaXMpLngsIF9zdXBlci5wcm90b3R5cGUuZ2V0Q2VudGVyLmNhbGwodGhpcykueSk7XHJcbiAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQoJ0ZvY3VzJywgdGhpcy5mb2N1cy54ICsgdGhpcy5wb3MueCwgdGhpcy5mb2N1cy55ICsgdGhpcy5wb3MueSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBQYXJ0aWNsZUVtaXR0ZXJJbXBsO1xyXG4gICAgfShBY3Rvcl83LkFjdG9yKSk7XHJcbiAgICBleHBvcnRzLlBhcnRpY2xlRW1pdHRlckltcGwgPSBQYXJ0aWNsZUVtaXR0ZXJJbXBsO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVc2luZyBhIHBhcnRpY2xlIGVtaXR0ZXIgaXMgYSBncmVhdCB3YXkgdG8gY3JlYXRlIGludGVyZXN0aW5nIGVmZmVjdHNcclxuICAgICAqIGluIHlvdXIgZ2FtZSwgbGlrZSBzbW9rZSwgZmlyZSwgd2F0ZXIsIGV4cGxvc2lvbnMsIGV0Yy4gYFBhcnRpY2xlRW1pdHRlcmBcclxuICAgICAqIGV4dGVuZCBbW0FjdG9yXV0gYWxsb3dpbmcgeW91IHRvIHVzZSBhbGwgb2YgdGhlIGZlYXR1cmVzIHRoYXQgY29tZSB3aXRoLlxyXG4gICAgICpcclxuICAgICAqIFtbaW5jbHVkZTpQYXJ0aWNsZXMubWRdXVxyXG4gICAgICovXHJcbiAgICB2YXIgUGFydGljbGVFbWl0dGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoUGFydGljbGVFbWl0dGVyLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFBhcnRpY2xlRW1pdHRlcih4T3JDb25maWcsIHksIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHhPckNvbmZpZywgeSwgd2lkdGgsIGhlaWdodCkgfHwgdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFBhcnRpY2xlRW1pdHRlcjtcclxuICAgIH0oQ29uZmlndXJhYmxlXzUuQ29uZmlndXJhYmxlKFBhcnRpY2xlRW1pdHRlckltcGwpKSk7XHJcbiAgICBleHBvcnRzLlBhcnRpY2xlRW1pdHRlciA9IFBhcnRpY2xlRW1pdHRlcjtcclxufSk7XHJcbmRlZmluZShcIlRpbGVNYXBcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJDb2xsaXNpb24vQm91bmRpbmdCb3hcIiwgXCJEcmF3aW5nL0NvbG9yXCIsIFwiQ2xhc3NcIiwgXCJBbGdlYnJhXCIsIFwiVXRpbC9Mb2dcIiwgXCJFdmVudHNcIiwgXCJDb25maWd1cmFibGVcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBCb3VuZGluZ0JveF80LCBDb2xvcl8xNSwgQ2xhc3NfNCwgQWxnZWJyYV8xNiwgTG9nXzcsIEV2ZW50cywgQ29uZmlndXJhYmxlXzYpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaGlkZGVuXHJcbiAgICAgKi9cclxuICAgIHZhciBUaWxlTWFwSW1wbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFRpbGVNYXBJbXBsLCBfc3VwZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB4ICAgICAgICAgICAgIFRoZSB4IGNvb3JkaW5hdGUgdG8gYW5jaG9yIHRoZSBUaWxlTWFwJ3MgdXBwZXIgbGVmdCBjb3JuZXIgKHNob3VsZCBub3QgYmUgY2hhbmdlZCBvbmNlIHNldClcclxuICAgICAgICAgKiBAcGFyYW0geSAgICAgICAgICAgICBUaGUgeSBjb29yZGluYXRlIHRvIGFuY2hvciB0aGUgVGlsZU1hcCdzIHVwcGVyIGxlZnQgY29ybmVyIChzaG91bGQgbm90IGJlIGNoYW5nZWQgb25jZSBzZXQpXHJcbiAgICAgICAgICogQHBhcmFtIGNlbGxXaWR0aCAgICAgVGhlIGluZGl2aWR1YWwgd2lkdGggb2YgZWFjaCBjZWxsIChpbiBwaXhlbHMpIChzaG91bGQgbm90IGJlIGNoYW5nZWQgb25jZSBzZXQpXHJcbiAgICAgICAgICogQHBhcmFtIGNlbGxIZWlnaHQgICAgVGhlIGluZGl2aWR1YWwgaGVpZ2h0IG9mIGVhY2ggY2VsbCAoaW4gcGl4ZWxzKSAoc2hvdWxkIG5vdCBiZSBjaGFuZ2VkIG9uY2Ugc2V0KVxyXG4gICAgICAgICAqIEBwYXJhbSByb3dzICAgICAgICAgIFRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGUgVGlsZU1hcCAoc2hvdWxkIG5vdCBiZSBjaGFuZ2VkIG9uY2Ugc2V0KVxyXG4gICAgICAgICAqIEBwYXJhbSBjb2xzICAgICAgICAgIFRoZSBudW1iZXIgb2YgY29scyBpbiB0aGUgVGlsZU1hcCAoc2hvdWxkIG5vdCBiZSBjaGFuZ2VkIG9uY2Ugc2V0KVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIFRpbGVNYXBJbXBsKHhPckNvbmZpZywgeSwgY2VsbFdpZHRoLCBjZWxsSGVpZ2h0LCByb3dzLCBjb2xzKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLl9jb2xsaWRpbmdYID0gLTE7XHJcbiAgICAgICAgICAgIF90aGlzLl9jb2xsaWRpbmdZID0gLTE7XHJcbiAgICAgICAgICAgIF90aGlzLl9vblNjcmVlblhTdGFydCA9IDA7XHJcbiAgICAgICAgICAgIF90aGlzLl9vblNjcmVlblhFbmQgPSA5OTk5O1xyXG4gICAgICAgICAgICBfdGhpcy5fb25TY3JlZW5ZU3RhcnQgPSAwO1xyXG4gICAgICAgICAgICBfdGhpcy5fb25TY3JlZW5ZRW5kID0gOTk5OTtcclxuICAgICAgICAgICAgX3RoaXMuX3Nwcml0ZVNoZWV0cyA9IHt9O1xyXG4gICAgICAgICAgICBfdGhpcy5sb2dnZXIgPSBMb2dfNy5Mb2dnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgX3RoaXMuZGF0YSA9IFtdO1xyXG4gICAgICAgICAgICBpZiAoeE9yQ29uZmlnICYmIHR5cGVvZiB4T3JDb25maWcgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29uZmlnID0geE9yQ29uZmlnO1xyXG4gICAgICAgICAgICAgICAgeE9yQ29uZmlnID0gY29uZmlnLng7XHJcbiAgICAgICAgICAgICAgICB5ID0gY29uZmlnLnk7XHJcbiAgICAgICAgICAgICAgICBjZWxsV2lkdGggPSBjb25maWcuY2VsbFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgY2VsbEhlaWdodCA9IGNvbmZpZy5jZWxsSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgcm93cyA9IGNvbmZpZy5yb3dzO1xyXG4gICAgICAgICAgICAgICAgY29scyA9IGNvbmZpZy5jb2xzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzLmRhdGEgPSBuZXcgQXJyYXkocm93cyAqIGNvbHMpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbHM7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByb3dzOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2QgPSBuZXcgQ2VsbChpICogY2VsbFdpZHRoICsgeE9yQ29uZmlnLCBqICogY2VsbEhlaWdodCArIHksIGNlbGxXaWR0aCwgY2VsbEhlaWdodCwgaSArIGogKiBjb2xzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGF0YVtpICsgaiAqIGNvbHNdID0gY2Q7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFRpbGVNYXBJbXBsLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBUaWxlTWFwSW1wbC5wcm90b3R5cGUucmVnaXN0ZXJTcHJpdGVTaGVldCA9IGZ1bmN0aW9uIChrZXksIHNwcml0ZVNoZWV0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Nwcml0ZVNoZWV0c1trZXldID0gc3ByaXRlU2hlZXQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBpbnRlcnNlY3Rpb24gdmVjdG9yIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVzb2x2ZSBjb2xsaXNpb25zIHdpdGggYWN0b3JzLiBJZiB0aGVyZVxyXG4gICAgICAgICAqIGlzIG5vIGNvbGxpc2lvbiBudWxsIGlzIHJldHVybmVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRpbGVNYXBJbXBsLnByb3RvdHlwZS5jb2xsaWRlcyA9IGZ1bmN0aW9uIChhY3Rvcikge1xyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSBhY3Rvci5wb3MueCArIGFjdG9yLmdldFdpZHRoKCk7XHJcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBhY3Rvci5wb3MueSArIGFjdG9yLmdldEhlaWdodCgpO1xyXG4gICAgICAgICAgICB2YXIgYWN0b3JCb3VuZHMgPSBhY3Rvci5nZXRCb3VuZHMoKTtcclxuICAgICAgICAgICAgdmFyIG92ZXJsYXBzID0gW107XHJcbiAgICAgICAgICAgIC8vIHRyYWNlIHBvaW50cyBmb3Igb3ZlcmxhcFxyXG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gYWN0b3JCb3VuZHMubGVmdDsgeCA8PSB3aWR0aDsgeCArPSBNYXRoLm1pbihhY3Rvci5nZXRXaWR0aCgpIC8gMiwgdGhpcy5jZWxsV2lkdGggLyAyKSkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IGFjdG9yQm91bmRzLnRvcDsgeSA8PSBoZWlnaHQ7IHkgKz0gTWF0aC5taW4oYWN0b3IuZ2V0SGVpZ2h0KCkgLyAyLCB0aGlzLmNlbGxIZWlnaHQgLyAyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjZWxsID0gdGhpcy5nZXRDZWxsQnlQb2ludCh4LCB5KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbCAmJiBjZWxsLnNvbGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdmVybGFwID0gYWN0b3JCb3VuZHMuY29sbGlkZXMoY2VsbC5nZXRCb3VuZHMoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaXIgPSBhY3Rvci5nZXRDZW50ZXIoKS5zdWIoY2VsbC5nZXRDZW50ZXIoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdmVybGFwICYmIG92ZXJsYXAuZG90KGRpcikgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVybGFwcy5wdXNoKG92ZXJsYXApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvdmVybGFwcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgc21hbGxlc3QgY2hhbmdlIG90aGVyIHRoYW4gemVyb1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gb3ZlcmxhcHMucmVkdWNlKGZ1bmN0aW9uIChhY2N1bSwgbmV4dCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHggPSBhY2N1bS54O1xyXG4gICAgICAgICAgICAgICAgdmFyIHkgPSBhY2N1bS55O1xyXG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGFjY3VtLngpIDwgTWF0aC5hYnMobmV4dC54KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSBuZXh0Lng7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoYWNjdW0ueSkgPCBNYXRoLmFicyhuZXh0LnkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeSA9IG5leHQueTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWxnZWJyYV8xNi5WZWN0b3IoeCwgeSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgW1tDZWxsXV0gYnkgaW5kZXggKHJvdyBtYWpvciBvcmRlcilcclxuICAgICAgICAgKi9cclxuICAgICAgICBUaWxlTWFwSW1wbC5wcm90b3R5cGUuZ2V0Q2VsbEJ5SW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVtpbmRleF07XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBbW0NlbGxdXSBieSBpdHMgeCBhbmQgeSBjb29yZGluYXRlc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRpbGVNYXBJbXBsLnByb3RvdHlwZS5nZXRDZWxsID0gZnVuY3Rpb24gKHgsIHkpIHtcclxuICAgICAgICAgICAgaWYgKHggPCAwIHx8IHkgPCAwIHx8IHggPj0gdGhpcy5jb2xzIHx8IHkgPj0gdGhpcy5yb3dzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhW3ggKyB5ICogdGhpcy5jb2xzXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIFtbQ2VsbF1dIGJ5IHRlc3RpbmcgYSBwb2ludCBpbiBnbG9iYWwgY29vcmRpbmF0ZXMsXHJcbiAgICAgICAgICogcmV0dXJucyBgbnVsbGAgaWYgbm8gY2VsbCB3YXMgZm91bmQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVGlsZU1hcEltcGwucHJvdG90eXBlLmdldENlbGxCeVBvaW50ID0gZnVuY3Rpb24gKHgsIHkpIHtcclxuICAgICAgICAgICAgeCA9IE1hdGguZmxvb3IoKHggLSB0aGlzLngpIC8gdGhpcy5jZWxsV2lkdGgpO1xyXG4gICAgICAgICAgICB5ID0gTWF0aC5mbG9vcigoeSAtIHRoaXMueSkgLyB0aGlzLmNlbGxIZWlnaHQpO1xyXG4gICAgICAgICAgICB2YXIgY2VsbCA9IHRoaXMuZ2V0Q2VsbCh4LCB5KTtcclxuICAgICAgICAgICAgaWYgKHggPj0gMCAmJiB5ID49IDAgJiYgeCA8IHRoaXMuY29scyAmJiB5IDwgdGhpcy5yb3dzICYmIGNlbGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjZWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVGlsZU1hcEltcGwucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChlbmdpbmUsIGRlbHRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncHJldXBkYXRlJywgbmV3IEV2ZW50cy5QcmVVcGRhdGVFdmVudChlbmdpbmUsIGRlbHRhLCB0aGlzKSk7XHJcbiAgICAgICAgICAgIHZhciB3b3JsZENvb3Jkc1VwcGVyTGVmdCA9IGVuZ2luZS5zY3JlZW5Ub1dvcmxkQ29vcmRpbmF0ZXMobmV3IEFsZ2VicmFfMTYuVmVjdG9yKDAsIDApKTtcclxuICAgICAgICAgICAgdmFyIHdvcmxkQ29vcmRzTG93ZXJSaWdodCA9IGVuZ2luZS5zY3JlZW5Ub1dvcmxkQ29vcmRpbmF0ZXMobmV3IEFsZ2VicmFfMTYuVmVjdG9yKGVuZ2luZS5jYW52YXMuY2xpZW50V2lkdGgsIGVuZ2luZS5jYW52YXMuY2xpZW50SGVpZ2h0KSk7XHJcbiAgICAgICAgICAgIHRoaXMuX29uU2NyZWVuWFN0YXJ0ID0gTWF0aC5tYXgoTWF0aC5mbG9vcih3b3JsZENvb3Jkc1VwcGVyTGVmdC54IC8gdGhpcy5jZWxsV2lkdGgpIC0gMiwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMuX29uU2NyZWVuWVN0YXJ0ID0gTWF0aC5tYXgoTWF0aC5mbG9vcigod29ybGRDb29yZHNVcHBlckxlZnQueSAtIHRoaXMueSkgLyB0aGlzLmNlbGxIZWlnaHQpIC0gMiwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMuX29uU2NyZWVuWEVuZCA9IE1hdGgubWF4KE1hdGguZmxvb3Iod29ybGRDb29yZHNMb3dlclJpZ2h0LnggLyB0aGlzLmNlbGxXaWR0aCkgKyAyLCAwKTtcclxuICAgICAgICAgICAgdGhpcy5fb25TY3JlZW5ZRW5kID0gTWF0aC5tYXgoTWF0aC5mbG9vcigod29ybGRDb29yZHNMb3dlclJpZ2h0LnkgLSB0aGlzLnkpIC8gdGhpcy5jZWxsSGVpZ2h0KSArIDIsIDApO1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3Bvc3R1cGRhdGUnLCBuZXcgRXZlbnRzLlBvc3RVcGRhdGVFdmVudChlbmdpbmUsIGRlbHRhLCB0aGlzKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEcmF3cyB0aGUgdGlsZSBtYXAgdG8gdGhlIHNjcmVlbi4gQ2FsbGVkIGJ5IHRoZSBbW1NjZW5lXV0uXHJcbiAgICAgICAgICogQHBhcmFtIGN0eCAgICBUaGUgY3VycmVudCByZW5kZXJpbmcgY29udGV4dFxyXG4gICAgICAgICAqIEBwYXJhbSBkZWx0YSAgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGxhc3QgZHJhd1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRpbGVNYXBJbXBsLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGN0eCwgZGVsdGEpIHtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdwcmVkcmF3JywgbmV3IEV2ZW50cy5QcmVEcmF3RXZlbnQoY3R4LCBkZWx0YSwgdGhpcykpO1xyXG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKHRoaXMueCwgdGhpcy55KTtcclxuICAgICAgICAgICAgdmFyIHggPSB0aGlzLl9vblNjcmVlblhTdGFydCwgeEVuZCA9IE1hdGgubWluKHRoaXMuX29uU2NyZWVuWEVuZCwgdGhpcy5jb2xzKTtcclxuICAgICAgICAgICAgdmFyIHkgPSB0aGlzLl9vblNjcmVlbllTdGFydCwgeUVuZCA9IE1hdGgubWluKHRoaXMuX29uU2NyZWVuWUVuZCwgdGhpcy5yb3dzKTtcclxuICAgICAgICAgICAgdmFyIGNzLCBjc2ksIGNzbGVuO1xyXG4gICAgICAgICAgICBmb3IgKHg7IHggPCB4RW5kOyB4KyspIHtcclxuICAgICAgICAgICAgICAgIGZvciAoeTsgeSA8IHlFbmQ7IHkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGdldCBub24tbmVnYXRpdmUgdGlsZSBzcHJpdGVzXHJcbiAgICAgICAgICAgICAgICAgICAgY3MgPSB0aGlzLmdldENlbGwoeCwgeSkuc3ByaXRlcy5maWx0ZXIoZnVuY3Rpb24gKHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMuc3ByaXRlSWQgPiAtMTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNzaSA9IDAsIGNzbGVuID0gY3MubGVuZ3RoOyBjc2kgPCBjc2xlbjsgY3NpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNzID0gdGhpcy5fc3ByaXRlU2hlZXRzW2NzW2NzaV0uc3ByaXRlU2hlZXRLZXldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkcmF3IHNwcml0ZSwgd2FybmluZyBpZiBzcHJpdGUgZG9lc24ndCBleGlzdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcHJpdGUgPSBzcy5nZXRTcHJpdGUoY3NbY3NpXS5zcHJpdGVJZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3ByaXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLmRyYXcoY3R4LCB4ICogdGhpcy5jZWxsV2lkdGgsIHkgKiB0aGlzLmNlbGxIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybignU3ByaXRlIGRvZXMgbm90IGV4aXN0IGZvciBpZCcsIGNzW2NzaV0uc3ByaXRlSWQsICdpbiBzcHJpdGUgc2hlZXQnLCBjc1tjc2ldLnNwcml0ZVNoZWV0S2V5LCBzcHJpdGUsIHNzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ1Nwcml0ZSBzaGVldCcsIGNzW2NzaV0uc3ByaXRlU2hlZXRLZXksICdkb2VzIG5vdCBleGlzdCcsIHNzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHkgPSB0aGlzLl9vblNjcmVlbllTdGFydDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3Bvc3RkcmF3JywgbmV3IEV2ZW50cy5Qb3N0RHJhd0V2ZW50KGN0eCwgZGVsdGEsIHRoaXMpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERyYXdzIGFsbCB0aGUgdGlsZSBtYXAncyBkZWJ1ZyBpbmZvLiBDYWxsZWQgYnkgdGhlIFtbU2NlbmVdXS5cclxuICAgICAgICAgKiBAcGFyYW0gY3R4ICBUaGUgY3VycmVudCByZW5kZXJpbmcgY29udGV4dFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRpbGVNYXBJbXBsLnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuY29scyAqIHRoaXMuY2VsbFdpZHRoO1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5yb3dzICogdGhpcy5jZWxsSGVpZ2h0O1xyXG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBDb2xvcl8xNS5Db2xvci5SZWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB0aGlzLmNvbHMgKyAxOyB4KyspIHtcclxuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8odGhpcy54ICsgeCAqIHRoaXMuY2VsbFdpZHRoLCB0aGlzLnkpO1xyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh0aGlzLnggKyB4ICogdGhpcy5jZWxsV2lkdGgsIHRoaXMueSArIGhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCB0aGlzLnJvd3MgKyAxOyB5KyspIHtcclxuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8odGhpcy54LCB0aGlzLnkgKyB5ICogdGhpcy5jZWxsSGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8odGhpcy54ICsgd2lkdGgsIHRoaXMueSArIHkgKiB0aGlzLmNlbGxIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBzb2xpZCA9IENvbG9yXzE1LkNvbG9yLlJlZC5jbG9uZSgpO1xyXG4gICAgICAgICAgICBzb2xpZC5hID0gLjM7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YS5maWx0ZXIoZnVuY3Rpb24gKGNlbGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjZWxsLnNvbGlkO1xyXG4gICAgICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChjZWxsKSB7XHJcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gc29saWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChjZWxsLngsIGNlbGwueSwgY2VsbC53aWR0aCwgY2VsbC5oZWlnaHQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2NvbGxpZGluZ1kgPiAtMSAmJiB0aGlzLl9jb2xsaWRpbmdYID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBDb2xvcl8xNS5Db2xvci5DeWFuLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QodGhpcy54ICsgdGhpcy5fY29sbGlkaW5nWCAqIHRoaXMuY2VsbFdpZHRoLCB0aGlzLnkgKyB0aGlzLl9jb2xsaWRpbmdZICogdGhpcy5jZWxsSGVpZ2h0LCB0aGlzLmNlbGxXaWR0aCwgdGhpcy5jZWxsSGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFRpbGVNYXBJbXBsO1xyXG4gICAgfShDbGFzc180LkNsYXNzKSk7XHJcbiAgICBleHBvcnRzLlRpbGVNYXBJbXBsID0gVGlsZU1hcEltcGw7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBbW1RpbGVNYXBdXSBjbGFzcyBwcm92aWRlcyBhIGxpZ2h0d2VpZ2h0IHdheSB0byBkbyBsYXJnZSBjb21wbGV4IHNjZW5lcyB3aXRoIGNvbGxpc2lvblxyXG4gICAgICogd2l0aG91dCB0aGUgb3ZlcmhlYWQgb2YgYWN0b3JzLlxyXG4gICAgICpcclxuICAgICAqIFtbaW5jbHVkZTpUaWxlTWFwcy5tZF1dXHJcbiAgICAgKi9cclxuICAgIHZhciBUaWxlTWFwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoVGlsZU1hcCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBUaWxlTWFwKHhPckNvbmZpZywgeSwgY2VsbFdpZHRoLCBjZWxsSGVpZ2h0LCByb3dzLCBjb2xzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB4T3JDb25maWcsIHksIGNlbGxXaWR0aCwgY2VsbEhlaWdodCwgcm93cywgY29scykgfHwgdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFRpbGVNYXA7XHJcbiAgICB9KENvbmZpZ3VyYWJsZV82LkNvbmZpZ3VyYWJsZShUaWxlTWFwSW1wbCkpKTtcclxuICAgIGV4cG9ydHMuVGlsZU1hcCA9IFRpbGVNYXA7XHJcbiAgICAvKipcclxuICAgICAqIFRpbGUgc3ByaXRlcyBhcmUgdXNlZCB0byByZW5kZXIgYSBzcGVjaWZpYyBzcHJpdGUgZnJvbSBhIFtbVGlsZU1hcF1dJ3Mgc3ByaXRlc2hlZXQocylcclxuICAgICAqL1xyXG4gICAgdmFyIFRpbGVTcHJpdGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBzcHJpdGVTaGVldEtleSAgVGhlIGtleSBvZiB0aGUgc3ByaXRlc2hlZXQgdG8gdXNlXHJcbiAgICAgICAgICogQHBhcmFtIHNwcml0ZUlkICAgICAgICBUaGUgaW5kZXggb2YgdGhlIHNwcml0ZSBpbiB0aGUgW1tTcHJpdGVTaGVldF1dXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gVGlsZVNwcml0ZShzcHJpdGVTaGVldEtleSwgc3ByaXRlSWQpIHtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGVTaGVldEtleSA9IHNwcml0ZVNoZWV0S2V5O1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZUlkID0gc3ByaXRlSWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBUaWxlU3ByaXRlO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuVGlsZVNwcml0ZSA9IFRpbGVTcHJpdGU7XHJcbiAgICAvKipcclxuICAgICAqIEBoaWRkZW5cclxuICAgICAqL1xyXG4gICAgdmFyIENlbGxJbXBsID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0geCAgICAgICBHZXRzIG9yIHNldHMgeCBjb29yZGluYXRlIG9mIHRoZSBjZWxsIGluIHdvcmxkIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICogQHBhcmFtIHkgICAgICAgR2V0cyBvciBzZXRzIHkgY29vcmRpbmF0ZSBvZiB0aGUgY2VsbCBpbiB3b3JsZCBjb29yZGluYXRlc1xyXG4gICAgICAgICAqIEBwYXJhbSB3aWR0aCAgIEdldHMgb3Igc2V0cyB0aGUgd2lkdGggb2YgdGhlIGNlbGxcclxuICAgICAgICAgKiBAcGFyYW0gaGVpZ2h0ICBHZXRzIG9yIHNldHMgdGhlIGhlaWdodCBvZiB0aGUgY2VsbFxyXG4gICAgICAgICAqIEBwYXJhbSBpbmRleCAgIFRoZSBpbmRleCBvZiB0aGUgY2VsbCBpbiByb3cgbWFqb3Igb3JkZXJcclxuICAgICAgICAgKiBAcGFyYW0gc29saWQgICBHZXRzIG9yIHNldHMgd2hldGhlciB0aGlzIGNlbGwgaXMgc29saWRcclxuICAgICAgICAgKiBAcGFyYW0gc3ByaXRlcyBUaGUgbGlzdCBvZiB0aWxlIHNwcml0ZXMgdG8gdXNlIHRvIGRyYXcgaW4gdGhpcyBjZWxsIChpbiBvcmRlcilcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBDZWxsSW1wbCh4T3JDb25maWcsIHksIHdpZHRoLCBoZWlnaHQsIGluZGV4LCBzb2xpZCwgc3ByaXRlcykge1xyXG4gICAgICAgICAgICBpZiAoc29saWQgPT09IHZvaWQgMCkgeyBzb2xpZCA9IGZhbHNlOyB9XHJcbiAgICAgICAgICAgIGlmIChzcHJpdGVzID09PSB2b2lkIDApIHsgc3ByaXRlcyA9IFtdOyB9XHJcbiAgICAgICAgICAgIHRoaXMuc29saWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGVzID0gW107XHJcbiAgICAgICAgICAgIGlmICh4T3JDb25maWcgJiYgdHlwZW9mIHhPckNvbmZpZyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb25maWcgPSB4T3JDb25maWc7XHJcbiAgICAgICAgICAgICAgICB4T3JDb25maWcgPSBjb25maWcueDtcclxuICAgICAgICAgICAgICAgIHkgPSBjb25maWcueTtcclxuICAgICAgICAgICAgICAgIHdpZHRoID0gY29uZmlnLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gY29uZmlnLmhlaWdodDtcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gY29uZmlnLmluZGV4O1xyXG4gICAgICAgICAgICAgICAgc29saWQgPSBjb25maWcuc29saWQ7XHJcbiAgICAgICAgICAgICAgICBzcHJpdGVzID0gY29uZmlnLnNwcml0ZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy54ID0geE9yQ29uZmlnO1xyXG4gICAgICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgICAgIHRoaXMuc29saWQgPSBzb2xpZDtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGVzID0gc3ByaXRlcztcclxuICAgICAgICAgICAgdGhpcy5fYm91bmRzID0gbmV3IEJvdW5kaW5nQm94XzQuQm91bmRpbmdCb3godGhpcy54LCB0aGlzLnksIHRoaXMueCArIHRoaXMud2lkdGgsIHRoaXMueSArIHRoaXMuaGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgYm91bmRpbmcgYm94IGZvciB0aGlzIGNlbGxcclxuICAgICAgICAgKi9cclxuICAgICAgICBDZWxsSW1wbC5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYm91bmRzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgY2VudGVyIGNvb3JkaW5hdGUgb2YgdGhpcyBjZWxsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2VsbEltcGwucHJvdG90eXBlLmdldENlbnRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbGdlYnJhXzE2LlZlY3Rvcih0aGlzLnggKyB0aGlzLndpZHRoIC8gMiwgdGhpcy55ICsgdGhpcy5oZWlnaHQgLyAyKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZCBhbm90aGVyIFtbVGlsZVNwcml0ZV1dIHRvIHRoaXMgY2VsbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENlbGxJbXBsLnByb3RvdHlwZS5wdXNoU3ByaXRlID0gZnVuY3Rpb24gKHRpbGVTcHJpdGUpIHtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGVzLnB1c2godGlsZVNwcml0ZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmUgYW4gaW5zdGFuY2Ugb2YgW1tUaWxlU3ByaXRlXV0gZnJvbSB0aGlzIGNlbGxcclxuICAgICAgICAgKi9cclxuICAgICAgICBDZWxsSW1wbC5wcm90b3R5cGUucmVtb3ZlU3ByaXRlID0gZnVuY3Rpb24gKHRpbGVTcHJpdGUpIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgIGlmICgoaW5kZXggPSB0aGlzLnNwcml0ZXMuaW5kZXhPZih0aWxlU3ByaXRlKSkgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENsZWFyIGFsbCBzcHJpdGVzIGZyb20gdGhpcyBjZWxsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2VsbEltcGwucHJvdG90eXBlLmNsZWFyU3ByaXRlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGVzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gQ2VsbEltcGw7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5DZWxsSW1wbCA9IENlbGxJbXBsO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaWxlTWFwIENlbGxcclxuICAgICAqXHJcbiAgICAgKiBBIGxpZ2h0LXdlaWdodCBvYmplY3QgdGhhdCBvY2N1cGllcyBhIHNwYWNlIGluIGEgY29sbGlzaW9uIG1hcC4gR2VuZXJhbGx5XHJcbiAgICAgKiBjcmVhdGVkIGJ5IGEgW1tUaWxlTWFwXV0uXHJcbiAgICAgKlxyXG4gICAgICogQ2VsbHMgY2FuIGRyYXcgbXVsdGlwbGUgc3ByaXRlcy4gTm90ZSB0aGF0IHRoZSBvcmRlciBvZiBkcmF3aW5nIGlzIHRoZSBvcmRlclxyXG4gICAgICogb2YgdGhlIHNwcml0ZXMgaW4gdGhlIGFycmF5IHNvIHRoZSBsYXN0IG9uZSB3aWxsIGJlIGRyYXduIG9uIHRvcC4gWW91IGNhblxyXG4gICAgICogdXNlIHRyYW5zcGFyZW5jeSB0byBjcmVhdGUgbGF5ZXJzIHRoaXMgd2F5LlxyXG4gICAgICovXHJcbiAgICB2YXIgQ2VsbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKENlbGwsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gQ2VsbCh4T3JDb25maWcsIHksIHdpZHRoLCBoZWlnaHQsIGluZGV4LCBzb2xpZCwgc3ByaXRlcykge1xyXG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgeE9yQ29uZmlnLCB5LCB3aWR0aCwgaGVpZ2h0LCBpbmRleCwgc29saWQsIHNwcml0ZXMpIHx8IHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBDZWxsO1xyXG4gICAgfShDb25maWd1cmFibGVfNi5Db25maWd1cmFibGUoQ2VsbEltcGwpKSk7XHJcbiAgICBleHBvcnRzLkNlbGwgPSBDZWxsO1xyXG59KTtcclxuZGVmaW5lKFwiVGltZXJcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIEV4Y2FsaWJ1ciB0aW1lciBob29rcyBpbnRvIHRoZSBpbnRlcm5hbCB0aW1lciBhbmQgZmlyZXMgY2FsbGJhY2tzLFxyXG4gICAgICogYWZ0ZXIgYSBjZXJ0YWluIGludGVydmFsLCBvcHRpb25hbGx5IHJlcGVhdGluZy5cclxuICAgICAqL1xyXG4gICAgdmFyIFRpbWVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gZmNuICAgICAgICBUaGUgY2FsbGJhY2sgdG8gYmUgZmlyZWQgYWZ0ZXIgdGhlIGludGVydmFsIGlzIGNvbXBsZXRlLlxyXG4gICAgICAgICAqIEBwYXJhbSBpbnRlcnZhbCAgIEludGVydmFsIGxlbmd0aFxyXG4gICAgICAgICAqIEBwYXJhbSByZXBlYXRzICAgIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgY2FsbCBiYWNrIHNob3VsZCBiZSBmaXJlZCBvbmx5IG9uY2UsIG9yIHJlcGVhdCBhZnRlciBldmVyeSBpbnRlcnZhbCBhcyBjb21wbGV0ZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gVGltZXIoZmNuLCBpbnRlcnZhbCwgcmVwZWF0cykge1xyXG4gICAgICAgICAgICB0aGlzLmlkID0gMDtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbCA9IDEwO1xyXG4gICAgICAgICAgICB0aGlzLmZjbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuOyB9O1xyXG4gICAgICAgICAgICB0aGlzLnJlcGVhdHMgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fZWxhcHNlZFRpbWUgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl90b3RhbFRpbWVBbGl2ZSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuc2NlbmUgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmlkID0gVGltZXIuaWQrKztcclxuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbCA9IGludGVydmFsIHx8IHRoaXMuaW50ZXJ2YWw7XHJcbiAgICAgICAgICAgIHRoaXMuZmNuID0gZmNuIHx8IHRoaXMuZmNuO1xyXG4gICAgICAgICAgICB0aGlzLnJlcGVhdHMgPSByZXBlYXRzIHx8IHRoaXMucmVwZWF0cztcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXBkYXRlcyB0aGUgdGltZXIgYWZ0ZXIgYSBjZXJ0YWluIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkLiBUaGlzIGlzIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgZW5naW5lLlxyXG4gICAgICAgICAqIEBwYXJhbSBkZWx0YSAgTnVtYmVyIG9mIGVsYXBzZWQgbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBsYXN0IHVwZGF0ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBUaW1lci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fcGF1c2VkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90b3RhbFRpbWVBbGl2ZSArPSBkZWx0YTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VsYXBzZWRUaW1lICs9IGRlbHRhO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbXBsZXRlICYmIHRoaXMuX2VsYXBzZWRUaW1lID49IHRoaXMuaW50ZXJ2YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZjbi5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlcGVhdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZWxhcHNlZFRpbWUgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXNldHMgdGhlIHRpbWVyIHNvIHRoYXQgaXQgY2FuIGJlIHJldXNlZCwgYW5kIG9wdGlvbmFsbHkgcmVjb25maWd1cmUgdGhlIHRpbWVycyBpbnRlcnZhbC5cclxuICAgICAgICAgKiBAcGFyYW0gbmV3SW50ZXJ2YWwgSWYgc3BlY2lmaWVkLCBzZXRzIGEgbmV3IG5vbi1uZWdhdGl2ZSBpbnRlcnZhbCBpbiBtaWxsaXNlY29uZHMgdG8gcmVmaXJlIHRoZSBjYWxsYmFja1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRpbWVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIChuZXdJbnRlcnZhbCkge1xyXG4gICAgICAgICAgICBpZiAoISFuZXdJbnRlcnZhbCAmJiBuZXdJbnRlcnZhbCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmludGVydmFsID0gbmV3SW50ZXJ2YWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jb21wbGV0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9lbGFwc2VkVGltZSA9IDA7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBUaW1lci5wcm90b3R5cGUuZ2V0VGltZVJ1bm5pbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90b3RhbFRpbWVBbGl2ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBhdXNlcyB0aGUgdGltZXIgc28gdGhhdCBubyBtb3JlIHRpbWUgd2lsbCBiZSBpbmNyZW1lbnRlZCB0b3dhcmRzIHRoZSBuZXh0IGNhbGxcclxuICAgICAgICAgKi9cclxuICAgICAgICBUaW1lci5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVbnBhdXNlcyB0aGUgdGltZXIuIFRpbWUgd2lsbCBub3cgaW5jcmVtZW50IHRvd2FyZHMgdGhlIG5leHQgY2FsbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRpbWVyLnByb3RvdHlwZS51bnBhdXNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbmNlbHMgdGhlIHRpbWVyLCBwcmV2ZW50aW5nIGFueSBmdXJ0aGVyIGV4ZWN1dGlvbnMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVGltZXIucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2NlbmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUuY2FuY2VsVGltZXIodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBUaW1lcjtcclxuICAgIH0oKSk7XHJcbiAgICBUaW1lci5pZCA9IDA7XHJcbiAgICBleHBvcnRzLlRpbWVyID0gVGltZXI7XHJcbn0pO1xyXG5kZWZpbmUoXCJUcmlnZ2VyXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiRHJhd2luZy9Db2xvclwiLCBcIkFjdGlvbnMvQWN0aW9uXCIsIFwiRXZlbnREaXNwYXRjaGVyXCIsIFwiQWN0b3JcIiwgXCJBbGdlYnJhXCIsIFwiRXZlbnRzXCIsIFwiVXRpbC9VdGlsXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgQ29sb3JfMTYsIEFjdGlvbl8xLCBFdmVudERpc3BhdGNoZXJfMSwgQWN0b3JfOCwgQWxnZWJyYV8xNywgRXZlbnRzXzUsIFV0aWwpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgdmFyIHRyaWdnZXJEZWZhdWx0cyA9IHtcclxuICAgICAgICBwb3M6IEFsZ2VicmFfMTcuVmVjdG9yLlplcm8uY2xvbmUoKSxcclxuICAgICAgICB3aWR0aDogMTAsXHJcbiAgICAgICAgaGVpZ2h0OiAxMCxcclxuICAgICAgICB2aXNpYmxlOiBmYWxzZSxcclxuICAgICAgICBhY3Rpb246IGZ1bmN0aW9uICgpIHsgcmV0dXJuOyB9LFxyXG4gICAgICAgIGZpbHRlcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSxcclxuICAgICAgICByZXBlYXQ6IC0xXHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUcmlnZ2VycyBhcmUgYSBtZXRob2Qgb2YgZmlyaW5nIGFyYml0cmFyeSBjb2RlIG9uIGNvbGxpc2lvbi4gVGhlc2UgYXJlIHVzZWZ1bFxyXG4gICAgICogYXMgJ2J1dHRvbnMnLCAnc3dpdGNoZXMnLCBvciB0byB0cmlnZ2VyIGVmZmVjdHMgaW4gYSBnYW1lLiBCeSBkZWZhdWx0IHRyaWdnZXJzXHJcbiAgICAgKiBhcmUgaW52aXNpYmxlLCBhbmQgY2FuIG9ubHkgYmUgc2VlbiB3aGVuIFtbVHJpZ2dlci52aXNpYmxlXV0gaXMgc2V0IHRvIGB0cnVlYC5cclxuICAgICAqXHJcbiAgICAgKiBbW2luY2x1ZGU6VHJpZ2dlcnMubWRdXVxyXG4gICAgICovXHJcbiAgICB2YXIgVHJpZ2dlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFRyaWdnZXIsIF9zdXBlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gb3B0cyBUcmlnZ2VyIG9wdGlvbnNcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBUcmlnZ2VyKG9wdHMpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0cy5wb3MueCwgb3B0cy5wb3MueSwgb3B0cy53aWR0aCwgb3B0cy5oZWlnaHQpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBY3Rpb24gdG8gZmlyZSB3aGVuIHRyaWdnZXJlZCBieSBjb2xsaXNpb25cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmFjdGlvbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuOyB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRmlsdGVyIHRvIGFkZCBhZGRpdGlvbmFsIGdyYW51bGFyaXR5IHRvIGFjdGlvbiBkaXNwYXRjaCwgaWYgYSBmaWx0ZXIgaXMgc3BlY2lmaWVkIHRoZSBhY3Rpb24gd2lsbCBvbmx5IGZpcmUgd2hlblxyXG4gICAgICAgICAgICAgKiBmaWx0ZXIgcmV0dXJuIHRydWUgZm9yIHRoZSBjb2xsaWRlZCBhY3Rvci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmZpbHRlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBOdW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IGJlZm9yZSBraWxsaW5nIHRoZSB0cmlnZ2VyLFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMucmVwZWF0ID0gLTE7XHJcbiAgICAgICAgICAgIG9wdHMgPSBVdGlsLmV4dGVuZCh7fSwgdHJpZ2dlckRlZmF1bHRzLCBvcHRzKTtcclxuICAgICAgICAgICAgX3RoaXMuZmlsdGVyID0gb3B0cy5maWx0ZXIgfHwgX3RoaXMuZmlsdGVyO1xyXG4gICAgICAgICAgICBfdGhpcy5yZXBlYXQgPSBvcHRzLnJlcGVhdCB8fCBfdGhpcy5yZXBlYXQ7XHJcbiAgICAgICAgICAgIF90aGlzLmFjdGlvbiA9IG9wdHMuYWN0aW9uIHx8IF90aGlzLmFjdGlvbjtcclxuICAgICAgICAgICAgaWYgKG9wdHMudGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy50YXJnZXQgPSBvcHRzLnRhcmdldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy52aXNpYmxlID0gb3B0cy52aXNpYmxlO1xyXG4gICAgICAgICAgICBfdGhpcy5jb2xsaXNpb25UeXBlID0gQWN0b3JfOC5Db2xsaXNpb25UeXBlLlBhc3NpdmU7XHJcbiAgICAgICAgICAgIF90aGlzLmV2ZW50RGlzcGF0Y2hlciA9IG5ldyBFdmVudERpc3BhdGNoZXJfMS5FdmVudERpc3BhdGNoZXIoX3RoaXMpO1xyXG4gICAgICAgICAgICBfdGhpcy5hY3Rpb25RdWV1ZSA9IG5ldyBBY3Rpb25fMS5BY3Rpb25RdWV1ZShfdGhpcyk7XHJcbiAgICAgICAgICAgIF90aGlzLm9uKCdjb2xsaXNpb25zdGFydCcsIGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5maWx0ZXIoZXZ0Lm90aGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ2VudGVyJywgbmV3IEV2ZW50c181LkVudGVyVHJpZ2dlckV2ZW50KF90aGlzLCBldnQub3RoZXIpKTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZGlzcGF0Y2hBY3Rpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdHJpZ2dlciBpZiBpdHMgZG9uZSwgLTEgcmVwZWF0IGZvcmV2ZXJcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMucmVwZWF0ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmtpbGwoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBfdGhpcy5vbignY29sbGlzaW9uZW5kJywgZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmZpbHRlcihldnQub3RoZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgnZXhpdCcsIG5ldyBFdmVudHNfNS5FeGl0VHJpZ2dlckV2ZW50KF90aGlzLCBldnQub3RoZXIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyaWdnZXIucHJvdG90eXBlLCBcInRhcmdldFwiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RhcmdldDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpbHRlciA9IGZ1bmN0aW9uIChhY3RvcikgeyByZXR1cm4gYWN0b3IgPT09IHRhcmdldDsgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgVHJpZ2dlci5wcm90b3R5cGUuX2luaXRpYWxpemUgPSBmdW5jdGlvbiAoZW5naW5lKSB7XHJcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuX2luaXRpYWxpemUuY2FsbCh0aGlzLCBlbmdpbmUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVHJpZ2dlci5wcm90b3R5cGUuX2Rpc3BhdGNoQWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmFjdGlvbi5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLnJlcGVhdC0tO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBUcmlnZ2VyLnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGVidWdEcmF3LmNhbGwodGhpcywgY3R4KTtcclxuICAgICAgICAgICAgLy8gTWVhbnQgdG8gZHJhdyBkZWJ1ZyBpbmZvcm1hdGlvbiBhYm91dCBhY3RvcnNcclxuICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLnBvcy54LCB0aGlzLnBvcy55KTtcclxuICAgICAgICAgICAgdmFyIGJiID0gdGhpcy5nZXRCb3VuZHMoKTtcclxuICAgICAgICAgICAgdmFyIHdwID0gdGhpcy5nZXRXb3JsZFBvcygpO1xyXG4gICAgICAgICAgICBiYi5sZWZ0ID0gYmIubGVmdCAtIHdwLng7XHJcbiAgICAgICAgICAgIGJiLnJpZ2h0ID0gYmIucmlnaHQgLSB3cC54O1xyXG4gICAgICAgICAgICBiYi50b3AgPSBiYi50b3AgLSB3cC55O1xyXG4gICAgICAgICAgICBiYi5ib3R0b20gPSBiYi5ib3R0b20gLSB3cC55O1xyXG4gICAgICAgICAgICAvLyBDdXJyZW50bHkgY29sbGlzaW9uIHByaW1pdGl2ZXMgY2Fubm90IHJvdGF0ZSBcclxuICAgICAgICAgICAgLy8gY3R4LnJvdGF0ZSh0aGlzLnJvdGF0aW9uKTtcclxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IENvbG9yXzE2LkNvbG9yLlZpb2xldC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBDb2xvcl8xNi5Db2xvci5WaW9sZXQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KCdUcmlnZ2VyJywgMTAsIDEwKTtcclxuICAgICAgICAgICAgYmIuZGVidWdEcmF3KGN0eCk7XHJcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gVHJpZ2dlcjtcclxuICAgIH0oQWN0b3JfOC5BY3RvcikpO1xyXG4gICAgZXhwb3J0cy5UcmlnZ2VyID0gVHJpZ2dlcjtcclxufSk7XHJcbmRlZmluZShcIkFjdGlvbnMvSW5kZXhcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJBY3Rpb25zL0FjdGlvbkNvbnRleHRcIiwgXCJBY3Rpb25zL1JvdGF0aW9uVHlwZVwiLCBcIkFjdGlvbnMvQWN0aW9uXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgQWN0aW9uQ29udGV4dF8yLCBSb3RhdGlvblR5cGVfMSwgYWN0aW9ucykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBmdW5jdGlvbiBfX2V4cG9ydChtKSB7XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgX19leHBvcnQoQWN0aW9uQ29udGV4dF8yKTtcclxuICAgIF9fZXhwb3J0KFJvdGF0aW9uVHlwZV8xKTtcclxuICAgIGV4cG9ydHMuQWN0aW9ucyA9IGFjdGlvbnM7XHJcbiAgICAvLyBsZWdhY3kgSW50ZXJuYWwuQWN0aW9ucyBuYW1lc3BhY2Ugc3VwcG9ydFxyXG4gICAgZXhwb3J0cy5JbnRlcm5hbCA9IHsgQWN0aW9uczogYWN0aW9ucyB9O1xyXG59KTtcclxuZGVmaW5lKFwiQ29sbGlzaW9uL0R5bmFtaWNUcmVlXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiUGh5c2ljc1wiLCBcIkNvbGxpc2lvbi9Cb3VuZGluZ0JveFwiLCBcIlV0aWwvTG9nXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgUGh5c2ljc184LCBCb3VuZGluZ0JveF81LCBMb2dfOCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIER5bmFtaWMgVHJlZSBOb2RlIHVzZWQgZm9yIHRyYWNraW5nIGJvdW5kcyB3aXRoaW4gdGhlIHRyZWVcclxuICAgICAqL1xyXG4gICAgdmFyIFRyZWVOb2RlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBUcmVlTm9kZShwYXJlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50IHx8IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuYm9keSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuYm91bmRzID0gbmV3IEJvdW5kaW5nQm94XzUuQm91bmRpbmdCb3goKTtcclxuICAgICAgICAgICAgdGhpcy5sZWZ0ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5yaWdodCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgVHJlZU5vZGUucHJvdG90eXBlLmlzTGVhZiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICghdGhpcy5sZWZ0ICYmICF0aGlzLnJpZ2h0KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBUcmVlTm9kZTtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLlRyZWVOb2RlID0gVHJlZU5vZGU7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBEeW5hbWljVHJlZXMgcHJvdmlkZXMgYSBzcGF0aWFsIHBhcnRpaW9uaW5nIGRhdGEgc3RydWN0dXJlIGZvciBxdWlja2x5IHF1ZXJ5aW5nIGZvciBvdmVybGFwcGluZyBib3VuZGluZyBib3hlcyBmb3JcclxuICAgICAqIGFsbCB0cmFja2VkIGJvZGllcy4gVGhlIHdvcnN0IGNhc2UgcGVyZm9ybWFuY2Ugb2YgdGhpcyBpcyBPKG4qbG9nKG4pKSB3aGVyZSBuIGlzIHRoZSBudW1iZXIgb2YgYm9kaWVzIGluIHRoZSB0cmVlLlxyXG4gICAgICpcclxuICAgICAqIEludGVybmFsbHkgdGhlIGJvdW5kaW5nIGJveGVzIGFyZSBvcmdhbml6ZWQgYXMgYSBiYWxhbmNlZCBiaW5hcnkgdHJlZSBvZiBib3VuZGluZyBib3hlcywgd2hlcmUgdGhlIGxlYWYgbm9kZXMgYXJlIHRyYWNrZWQgYm9kaWVzLlxyXG4gICAgICogRXZlcnkgbm9uLWxlYWYgbm9kZSBpcyBhIGJvdW5kaW5nIGJveCB0aGF0IGNvbnRhaW5zIGNoaWxkIGJvdW5kaW5nIGJveGVzLlxyXG4gICAgICovXHJcbiAgICB2YXIgRHluYW1pY1RyZWUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIER5bmFtaWNUcmVlKHdvcmxkQm91bmRzKSB7XHJcbiAgICAgICAgICAgIGlmICh3b3JsZEJvdW5kcyA9PT0gdm9pZCAwKSB7IHdvcmxkQm91bmRzID0gbmV3IEJvdW5kaW5nQm94XzUuQm91bmRpbmdCb3goLU51bWJlci5NQVhfVkFMVUUsIC1OdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFKTsgfVxyXG4gICAgICAgICAgICB0aGlzLndvcmxkQm91bmRzID0gd29ybGRCb3VuZHM7XHJcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMubm9kZXMgPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5zZXJ0cyBhIG5vZGUgaW50byB0aGUgZHluYW1pYyB0cmVlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLl9pbnNlcnQgPSBmdW5jdGlvbiAobGVhZikge1xyXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gbm9kZXMgaW4gdGhlIHRyZWUsIG1ha2UgdGhpcyB0aGUgcm9vdCBsZWFmXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJvb3QgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucm9vdCA9IGxlYWY7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3QucGFyZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBTZWFyY2ggdGhlIHRyZWUgZm9yIGEgbm9kZSB0aGF0IGlzIG5vdCBhIGxlYWYgYW5kIGZpbmQgdGhlIGJlc3QgcGxhY2UgdG8gaW5zZXJ0XHJcbiAgICAgICAgICAgIHZhciBsZWFmQUFCQiA9IGxlYWYuYm91bmRzO1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudFJvb3QgPSB0aGlzLnJvb3Q7XHJcbiAgICAgICAgICAgIHdoaWxlICghY3VycmVudFJvb3QuaXNMZWFmKCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsZWZ0ID0gY3VycmVudFJvb3QubGVmdDtcclxuICAgICAgICAgICAgICAgIHZhciByaWdodCA9IGN1cnJlbnRSb290LnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyZWEgPSBjdXJyZW50Um9vdC5ib3VuZHMuZ2V0UGVyaW1ldGVyKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29tYmluZWRBQUJCID0gY3VycmVudFJvb3QuYm91bmRzLmNvbWJpbmUobGVhZkFBQkIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbWJpbmVkQXJlYSA9IGNvbWJpbmVkQUFCQi5nZXRQZXJpbWV0ZXIoKTtcclxuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBjb3N0IGhldXJpc3RpYyBmb3IgY3JlYXRpbmcgYSBuZXcgcGFyZW50IGFuZCBsZWFmXHJcbiAgICAgICAgICAgICAgICB2YXIgY29zdCA9IDIgKiBjb21iaW5lZEFyZWE7XHJcbiAgICAgICAgICAgICAgICAvLyBNaW5pbXVtIGNvc3Qgb2YgcHVzaGluZyB0aGUgbGVhZiBkb3duIHRoZSB0cmVlXHJcbiAgICAgICAgICAgICAgICB2YXIgaW5oZXJpdGFuY2VDb3N0ID0gMiAqIChjb21iaW5lZEFyZWEgLSBhcmVhKTtcclxuICAgICAgICAgICAgICAgIC8vIENvc3Qgb2YgZGVzY2VuZGluZ1xyXG4gICAgICAgICAgICAgICAgdmFyIGxlZnRDb3N0ID0gMDtcclxuICAgICAgICAgICAgICAgIHZhciBsZWZ0Q29tYmluZWQgPSBsZWFmQUFCQi5jb21iaW5lKGxlZnQuYm91bmRzKTtcclxuICAgICAgICAgICAgICAgIHZhciBuZXdBcmVhO1xyXG4gICAgICAgICAgICAgICAgdmFyIG9sZEFyZWE7XHJcbiAgICAgICAgICAgICAgICBpZiAobGVmdC5pc0xlYWYoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnRDb3N0ID0gbGVmdENvbWJpbmVkLmdldFBlcmltZXRlcigpICsgaW5oZXJpdGFuY2VDb3N0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2xkQXJlYSA9IGxlZnQuYm91bmRzLmdldFBlcmltZXRlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0FyZWEgPSBsZWZ0Q29tYmluZWQuZ2V0UGVyaW1ldGVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdENvc3QgPSAobmV3QXJlYSAtIG9sZEFyZWEpICsgaW5oZXJpdGFuY2VDb3N0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHJpZ2h0Q29zdCA9IDA7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmlnaHRDb21iaW5lZCA9IGxlYWZBQUJCLmNvbWJpbmUocmlnaHQuYm91bmRzKTtcclxuICAgICAgICAgICAgICAgIGlmIChyaWdodC5pc0xlYWYoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0Q29zdCA9IHJpZ2h0Q29tYmluZWQuZ2V0UGVyaW1ldGVyKCkgKyBpbmhlcml0YW5jZUNvc3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvbGRBcmVhID0gcmlnaHQuYm91bmRzLmdldFBlcmltZXRlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0FyZWEgPSByaWdodENvbWJpbmVkLmdldFBlcmltZXRlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0Q29zdCA9IChuZXdBcmVhIC0gb2xkQXJlYSkgKyBpbmhlcml0YW5jZUNvc3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBjb3N0IGlzIGFjY2VwdGFibGVcclxuICAgICAgICAgICAgICAgIGlmIChjb3N0IDwgbGVmdENvc3QgJiYgY29zdCA8IHJpZ2h0Q29zdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gRGVzY2VuZCB0byB0aGUgZGVwdGhzXHJcbiAgICAgICAgICAgICAgICBpZiAobGVmdENvc3QgPCByaWdodENvc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Um9vdCA9IGxlZnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Um9vdCA9IHJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgbmV3IHBhcmVudCBub2RlIGFuZCBpbnNlcnQgaW50byB0aGUgdHJlZVxyXG4gICAgICAgICAgICB2YXIgb2xkUGFyZW50ID0gY3VycmVudFJvb3QucGFyZW50O1xyXG4gICAgICAgICAgICB2YXIgbmV3UGFyZW50ID0gbmV3IFRyZWVOb2RlKG9sZFBhcmVudCk7XHJcbiAgICAgICAgICAgIG5ld1BhcmVudC5ib3VuZHMgPSBsZWFmQUFCQi5jb21iaW5lKGN1cnJlbnRSb290LmJvdW5kcyk7XHJcbiAgICAgICAgICAgIG5ld1BhcmVudC5oZWlnaHQgPSBjdXJyZW50Um9vdC5oZWlnaHQgKyAxO1xyXG4gICAgICAgICAgICBpZiAob2xkUGFyZW50ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgc2libGluZyBub2RlIHdhcyBub3QgdGhlIHJvb3RcclxuICAgICAgICAgICAgICAgIGlmIChvbGRQYXJlbnQubGVmdCA9PT0gY3VycmVudFJvb3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBvbGRQYXJlbnQubGVmdCA9IG5ld1BhcmVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG9sZFBhcmVudC5yaWdodCA9IG5ld1BhcmVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG5ld1BhcmVudC5sZWZ0ID0gY3VycmVudFJvb3Q7XHJcbiAgICAgICAgICAgICAgICBuZXdQYXJlbnQucmlnaHQgPSBsZWFmO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFJvb3QucGFyZW50ID0gbmV3UGFyZW50O1xyXG4gICAgICAgICAgICAgICAgbGVhZi5wYXJlbnQgPSBuZXdQYXJlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgc2libGluZyBub2RlIHdhcyB0aGUgcm9vdFxyXG4gICAgICAgICAgICAgICAgbmV3UGFyZW50LmxlZnQgPSBjdXJyZW50Um9vdDtcclxuICAgICAgICAgICAgICAgIG5ld1BhcmVudC5yaWdodCA9IGxlYWY7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Um9vdC5wYXJlbnQgPSBuZXdQYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICBsZWFmLnBhcmVudCA9IG5ld1BhcmVudDtcclxuICAgICAgICAgICAgICAgIHRoaXMucm9vdCA9IG5ld1BhcmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBXYWxrIHVwIHRoZSB0cmVlIGZpeGluZyBoZWlnaHRzIGFuZCBBQUJCc1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudE5vZGUgPSBsZWFmLnBhcmVudDtcclxuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZSA9IHRoaXMuX2JhbGFuY2UoY3VycmVudE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50Tm9kZS5sZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJlbnQgb2YgY3VycmVudCBsZWFmIGNhbm5vdCBoYXZlIGEgbnVsbCBsZWZ0IGNoaWxkJyArIGN1cnJlbnROb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghY3VycmVudE5vZGUucmlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmVudCBvZiBjdXJyZW50IGxlYWYgY2Fubm90IGhhdmUgYSBudWxsIHJpZ2h0IGNoaWxkJyArIGN1cnJlbnROb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLmhlaWdodCA9IDEgKyBNYXRoLm1heChjdXJyZW50Tm9kZS5sZWZ0LmhlaWdodCwgY3VycmVudE5vZGUucmlnaHQuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLmJvdW5kcyA9IGN1cnJlbnROb2RlLmxlZnQuYm91bmRzLmNvbWJpbmUoY3VycmVudE5vZGUucmlnaHQuYm91bmRzKTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGEgbm9kZSBmcm9tIHRoZSBkeW5hbWljIHRyZWVcclxuICAgICAgICAgKi9cclxuICAgICAgICBEeW5hbWljVHJlZS5wcm90b3R5cGUuX3JlbW92ZSA9IGZ1bmN0aW9uIChsZWFmKSB7XHJcbiAgICAgICAgICAgIGlmIChsZWFmID09PSB0aGlzLnJvb3QpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucm9vdCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHBhcmVudCA9IGxlYWYucGFyZW50O1xyXG4gICAgICAgICAgICB2YXIgZ3JhbmRQYXJlbnQgPSBwYXJlbnQucGFyZW50O1xyXG4gICAgICAgICAgICB2YXIgc2libGluZztcclxuICAgICAgICAgICAgaWYgKHBhcmVudC5sZWZ0ID09PSBsZWFmKSB7XHJcbiAgICAgICAgICAgICAgICBzaWJsaW5nID0gcGFyZW50LnJpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2libGluZyA9IHBhcmVudC5sZWZ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChncmFuZFBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGdyYW5kUGFyZW50LmxlZnQgPT09IHBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGdyYW5kUGFyZW50LmxlZnQgPSBzaWJsaW5nO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JhbmRQYXJlbnQucmlnaHQgPSBzaWJsaW5nO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2libGluZy5wYXJlbnQgPSBncmFuZFBhcmVudDtcclxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50Tm9kZSA9IGdyYW5kUGFyZW50O1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSB0aGlzLl9iYWxhbmNlKGN1cnJlbnROb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5ib3VuZHMgPSBjdXJyZW50Tm9kZS5sZWZ0LmJvdW5kcy5jb21iaW5lKGN1cnJlbnROb2RlLnJpZ2h0LmJvdW5kcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUuaGVpZ2h0ID0gMSArIE1hdGgubWF4KGN1cnJlbnROb2RlLmxlZnQuaGVpZ2h0LCBjdXJyZW50Tm9kZS5yaWdodC5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yb290ID0gc2libGluZztcclxuICAgICAgICAgICAgICAgIHNpYmxpbmcucGFyZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVHJhY2tzIGEgYm9keSBpbiB0aGUgZHluYW1pYyB0cmVlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLnRyYWNrQm9keSA9IGZ1bmN0aW9uIChib2R5KSB7XHJcbiAgICAgICAgICAgIHZhciBub2RlID0gbmV3IFRyZWVOb2RlKCk7XHJcbiAgICAgICAgICAgIG5vZGUuYm9keSA9IGJvZHk7XHJcbiAgICAgICAgICAgIG5vZGUuYm91bmRzID0gYm9keS5nZXRCb3VuZHMoKTtcclxuICAgICAgICAgICAgbm9kZS5ib3VuZHMubGVmdCAtPSAyO1xyXG4gICAgICAgICAgICBub2RlLmJvdW5kcy50b3AgLT0gMjtcclxuICAgICAgICAgICAgbm9kZS5ib3VuZHMucmlnaHQgKz0gMjtcclxuICAgICAgICAgICAgbm9kZS5ib3VuZHMuYm90dG9tICs9IDI7XHJcbiAgICAgICAgICAgIHRoaXMubm9kZXNbYm9keS5hY3Rvci5pZF0gPSBub2RlO1xyXG4gICAgICAgICAgICB0aGlzLl9pbnNlcnQobm9kZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGVzIHRoZSBkeW5hbWljIHRyZWUgZ2l2ZW4gdGhlIGN1cnJlbnQgYm91bmRzIG9mIGVhY2ggYm9keSBiZWluZyB0cmFja2VkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLnVwZGF0ZUJvZHkgPSBmdW5jdGlvbiAoYm9keSkge1xyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZXNbYm9keS5hY3Rvci5pZF07XHJcbiAgICAgICAgICAgIGlmICghbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBiID0gYm9keS5nZXRCb3VuZHMoKTtcclxuICAgICAgICAgICAgLy8gaWYgdGhlIGJvZHkgaXMgb3V0c2lkZSB0aGUgd29ybGQgbm8gbG9uZ2VyIHVwZGF0ZSBpdFxyXG4gICAgICAgICAgICBpZiAoIXRoaXMud29ybGRCb3VuZHMuY29udGFpbnMoYikpIHtcclxuICAgICAgICAgICAgICAgIExvZ184LkxvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4oJ0FjdG9yIHdpdGggaWQgJyArIGJvZHkuYWN0b3IuaWQgK1xyXG4gICAgICAgICAgICAgICAgICAgICcgaXMgb3V0c2lkZSB0aGUgd29ybGQgYm91bmRzIGFuZCB3aWxsIG5vIGxvbmdlciBiZSB0cmFja2VkIGZvciBwaHlzaWNzJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVudHJhY2tCb2R5KGJvZHkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChub2RlLmJvdW5kcy5jb250YWlucyhiKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZShub2RlKTtcclxuICAgICAgICAgICAgYi5sZWZ0IC09IFBoeXNpY3NfOC5QaHlzaWNzLmJvdW5kc1BhZGRpbmc7XHJcbiAgICAgICAgICAgIGIudG9wIC09IFBoeXNpY3NfOC5QaHlzaWNzLmJvdW5kc1BhZGRpbmc7XHJcbiAgICAgICAgICAgIGIucmlnaHQgKz0gUGh5c2ljc184LlBoeXNpY3MuYm91bmRzUGFkZGluZztcclxuICAgICAgICAgICAgYi5ib3R0b20gKz0gUGh5c2ljc184LlBoeXNpY3MuYm91bmRzUGFkZGluZztcclxuICAgICAgICAgICAgdmFyIG11bHRkeCA9IGJvZHkudmVsLnggKiBQaHlzaWNzXzguUGh5c2ljcy5keW5hbWljVHJlZVZlbG9jaXR5TXVsdGlwbHllcjtcclxuICAgICAgICAgICAgdmFyIG11bHRkeSA9IGJvZHkudmVsLnkgKiBQaHlzaWNzXzguUGh5c2ljcy5keW5hbWljVHJlZVZlbG9jaXR5TXVsdGlwbHllcjtcclxuICAgICAgICAgICAgaWYgKG11bHRkeCA8IDApIHtcclxuICAgICAgICAgICAgICAgIGIubGVmdCArPSBtdWx0ZHg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBiLnJpZ2h0ICs9IG11bHRkeDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobXVsdGR5IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgYi50b3AgKz0gbXVsdGR5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYi5ib3R0b20gKz0gbXVsdGR5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5vZGUuYm91bmRzID0gYjtcclxuICAgICAgICAgICAgdGhpcy5faW5zZXJ0KG5vZGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVudHJhY2tzIGEgYm9keSBmcm9tIHRoZSBkeW5hbWljIHRyZWVcclxuICAgICAgICAgKi9cclxuICAgICAgICBEeW5hbWljVHJlZS5wcm90b3R5cGUudW50cmFja0JvZHkgPSBmdW5jdGlvbiAoYm9keSkge1xyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZXNbYm9keS5hY3Rvci5pZF07XHJcbiAgICAgICAgICAgIGlmICghbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZShub2RlKTtcclxuICAgICAgICAgICAgdGhpcy5ub2Rlc1tib2R5LmFjdG9yLmlkXSA9IG51bGw7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm5vZGVzW2JvZHkuYWN0b3IuaWRdO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQmFsYW5jZXMgdGhlIHRyZWUgYWJvdXQgYSBub2RlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLl9iYWxhbmNlID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGJhbGFuY2UgYXQgbnVsbCBub2RlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5vZGUuaXNMZWFmKCkgfHwgbm9kZS5oZWlnaHQgPCAyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbGVmdCA9IG5vZGUubGVmdDtcclxuICAgICAgICAgICAgdmFyIHJpZ2h0ID0gbm9kZS5yaWdodDtcclxuICAgICAgICAgICAgdmFyIGEgPSBub2RlO1xyXG4gICAgICAgICAgICB2YXIgYiA9IGxlZnQ7XHJcbiAgICAgICAgICAgIHZhciBjID0gcmlnaHQ7XHJcbiAgICAgICAgICAgIHZhciBkID0gbGVmdC5sZWZ0O1xyXG4gICAgICAgICAgICB2YXIgZSA9IGxlZnQucmlnaHQ7XHJcbiAgICAgICAgICAgIHZhciBmID0gcmlnaHQubGVmdDtcclxuICAgICAgICAgICAgdmFyIGcgPSByaWdodC5yaWdodDtcclxuICAgICAgICAgICAgdmFyIGJhbGFuY2UgPSBjLmhlaWdodCAtIGIuaGVpZ2h0O1xyXG4gICAgICAgICAgICAvLyBSb3RhdGUgYyBub2RlIHVwXHJcbiAgICAgICAgICAgIGlmIChiYWxhbmNlID4gMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gU3dhcCB0aGUgcmlnaHQgbm9kZSB3aXRoIGl0J3MgcGFyZW50XHJcbiAgICAgICAgICAgICAgICBjLmxlZnQgPSBhO1xyXG4gICAgICAgICAgICAgICAgYy5wYXJlbnQgPSBhLnBhcmVudDtcclxuICAgICAgICAgICAgICAgIGEucGFyZW50ID0gYztcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBvcmlnaW5hbCBub2RlJ3Mgb2xkIHBhcmVudCBzaG91bGQgcG9pbnQgdG8gdGhlIHJpZ2h0IG5vZGVcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgbWVnYSBjb25mdXNpbmdcclxuICAgICAgICAgICAgICAgIGlmIChjLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjLnBhcmVudC5sZWZ0ID09PSBhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMucGFyZW50LmxlZnQgPSBjO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYy5wYXJlbnQucmlnaHQgPSBjO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm9vdCA9IGM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBSb3RhdGVcclxuICAgICAgICAgICAgICAgIGlmIChmLmhlaWdodCA+IGcuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYy5yaWdodCA9IGY7XHJcbiAgICAgICAgICAgICAgICAgICAgYS5yaWdodCA9IGc7XHJcbiAgICAgICAgICAgICAgICAgICAgZy5wYXJlbnQgPSBhO1xyXG4gICAgICAgICAgICAgICAgICAgIGEuYm91bmRzID0gYi5ib3VuZHMuY29tYmluZShnLmJvdW5kcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYy5ib3VuZHMgPSBhLmJvdW5kcy5jb21iaW5lKGYuYm91bmRzKTtcclxuICAgICAgICAgICAgICAgICAgICBhLmhlaWdodCA9IDEgKyBNYXRoLm1heChiLmhlaWdodCwgZy5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGMuaGVpZ2h0ID0gMSArIE1hdGgubWF4KGEuaGVpZ2h0LCBmLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjLnJpZ2h0ID0gZztcclxuICAgICAgICAgICAgICAgICAgICBhLnJpZ2h0ID0gZjtcclxuICAgICAgICAgICAgICAgICAgICBmLnBhcmVudCA9IGE7XHJcbiAgICAgICAgICAgICAgICAgICAgYS5ib3VuZHMgPSBiLmJvdW5kcy5jb21iaW5lKGYuYm91bmRzKTtcclxuICAgICAgICAgICAgICAgICAgICBjLmJvdW5kcyA9IGEuYm91bmRzLmNvbWJpbmUoZy5ib3VuZHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGEuaGVpZ2h0ID0gMSArIE1hdGgubWF4KGIuaGVpZ2h0LCBmLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYy5oZWlnaHQgPSAxICsgTWF0aC5tYXgoYS5oZWlnaHQsIGcuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBjO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFJvdGF0ZSBsZWZ0IG5vZGUgdXBcclxuICAgICAgICAgICAgaWYgKGJhbGFuY2UgPCAtMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gc3dhcFxyXG4gICAgICAgICAgICAgICAgYi5sZWZ0ID0gYTtcclxuICAgICAgICAgICAgICAgIGIucGFyZW50ID0gYS5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICBhLnBhcmVudCA9IGI7XHJcbiAgICAgICAgICAgICAgICAvLyBub2RlJ3Mgb2xkIHBhcmVudCBzaG91bGQgcG9pbnQgdG8gYlxyXG4gICAgICAgICAgICAgICAgaWYgKGIucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGIucGFyZW50LmxlZnQgPT09IGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYi5wYXJlbnQubGVmdCA9IGI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYi5wYXJlbnQucmlnaHQgIT09IGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICdFcnJvciByb3RhdGluZyBEeW5hbWljIFRyZWUnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIucGFyZW50LnJpZ2h0ID0gYjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvb3QgPSBiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gcm90YXRlXHJcbiAgICAgICAgICAgICAgICBpZiAoZC5oZWlnaHQgPiBlLmhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGIucmlnaHQgPSBkO1xyXG4gICAgICAgICAgICAgICAgICAgIGEubGVmdCA9IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5wYXJlbnQgPSBhO1xyXG4gICAgICAgICAgICAgICAgICAgIGEuYm91bmRzID0gYy5ib3VuZHMuY29tYmluZShlLmJvdW5kcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYi5ib3VuZHMgPSBhLmJvdW5kcy5jb21iaW5lKGQuYm91bmRzKTtcclxuICAgICAgICAgICAgICAgICAgICBhLmhlaWdodCA9IDEgKyBNYXRoLm1heChjLmhlaWdodCwgZS5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGIuaGVpZ2h0ID0gMSArIE1hdGgubWF4KGEuaGVpZ2h0LCBkLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBiLnJpZ2h0ID0gZTtcclxuICAgICAgICAgICAgICAgICAgICBhLmxlZnQgPSBkO1xyXG4gICAgICAgICAgICAgICAgICAgIGQucGFyZW50ID0gYTtcclxuICAgICAgICAgICAgICAgICAgICBhLmJvdW5kcyA9IGMuYm91bmRzLmNvbWJpbmUoZC5ib3VuZHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGIuYm91bmRzID0gYS5ib3VuZHMuY29tYmluZShlLmJvdW5kcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYS5oZWlnaHQgPSAxICsgTWF0aC5tYXgoYy5oZWlnaHQsIGQuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICBiLmhlaWdodCA9IDEgKyBNYXRoLm1heChhLmhlaWdodCwgZS5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBpbnRlcm5hbCBoZWlnaHQgb2YgdGhlIHRyZWUsIHNob3J0ZXIgdHJlZXMgYXJlIGJldHRlci4gUGVyZm9ybWFuY2UgZHJvcHMgYXMgdGhlIHRyZWUgZ3Jvd3NcclxuICAgICAgICAgKi9cclxuICAgICAgICBEeW5hbWljVHJlZS5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5yb290ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb290LmhlaWdodDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFF1ZXJpZXMgdGhlIER5bmFtaWMgQXhpcyBBbGlnbmVkIFRyZWUgZm9yIGJvZGllcyB0aGF0IGNvdWxkIGJlIGNvbGxpZGluZyB3aXRoIHRoZSBwcm92aWRlZCBib2R5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogSW4gdGhlIHF1ZXJ5IGNhbGxiYWNrLCBpdCB3aWxsIGJlIHBhc3NlZCBhIHBvdGVudGlhbCBjb2xsaWRlci4gUmV0dXJuaW5nIHRydWUgZnJvbSB0aGlzIGNhbGxiYWNrIGluZGljYXRlc1xyXG4gICAgICAgICAqIHRoYXQgeW91IGFyZSBjb21wbGV0ZSB3aXRoIHlvdXIgcXVlcnkgYW5kIHlvdSBkbyBub3Qgd2FudCB0byBjb250aW51ZS4gUmV0dXJuaW5nIGZhbHNlIHdpbGwgY29udGludWUgc2VhcmNoaW5nXHJcbiAgICAgICAgICogdGhlIHRyZWUgdW50aWwgYWxsIHBvc3NpYmxlIGNvbGxpZGVycyBoYXZlIGJlZW4gcmV0dXJuZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gKGJvZHksIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHZhciBib3VuZHMgPSBib2R5LmdldEJvdW5kcygpO1xyXG4gICAgICAgICAgICB2YXIgaGVscGVyID0gZnVuY3Rpb24gKGN1cnJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUgJiYgY3VycmVudE5vZGUuYm91bmRzLmNvbGxpZGVzKGJvdW5kcykpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUuaXNMZWFmKCkgJiYgY3VycmVudE5vZGUuYm9keSAhPT0gYm9keSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2suY2FsbChib2R5LCBjdXJyZW50Tm9kZS5ib2R5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXIoY3VycmVudE5vZGUubGVmdCkgfHwgaGVscGVyKGN1cnJlbnROb2RlLnJpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGhlbHBlcih0aGlzLnJvb3QpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUXVlcmllcyB0aGUgRHluYW1pYyBBeGlzIEFsaWduZWQgVHJlZSBmb3IgYm9kaWVzIHRoYXQgY291bGQgYmUgaW50ZXJzZWN0aW5nLiBCeSBkZWZhdWx0IHRoZSByYXljYXN0IHF1ZXJ5IHVzZXMgYW4gaW5maW5pdGVseVxyXG4gICAgICAgICAqIGxvbmcgcmF5IHRvIHRlc3QgdGhlIHRyZWUgc3BlY2lmaWVkIGJ5IGBtYXhgLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogSW4gdGhlIHF1ZXJ5IGNhbGxiYWNrLCBpdCB3aWxsIGJlIHBhc3NlZCBhIHBvdGVudGlhbCBib2R5IHRoYXQgaW50ZXJzZWN0cyB3aXRoIHRoZSByYWNhc3QuIFJldHVybmluZyB0cnVlIGZyb20gdGhpc1xyXG4gICAgICAgICAqIGNhbGxiYWNrIGluZGljYXRlcyB0aGF0IHlvdXIgYXJlIGNvbXBsZXRlIHdpdGggeW91ciBxdWVyeSBhbmQgZG8gbm90IHdhbnQgdG8gY29udGludWUuIFJldHVybiBmYWxzZSB3aWxsIGNvbnRpbnVlIHNlYXJjaGluZ1xyXG4gICAgICAgICAqIHRoZSB0cmVlIHVudGlsIGFsbCBwb3NzaWJsZSBib2RpZXMgdGhhdCB3b3VsZCBpbnRlcnNlY3Qgd2l0aCB0aGUgcmF5IGhhdmUgYmVlbiByZXR1cm5lZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBEeW5hbWljVHJlZS5wcm90b3R5cGUucmF5Q2FzdFF1ZXJ5ID0gZnVuY3Rpb24gKHJheSwgbWF4LCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBpZiAobWF4ID09PSB2b2lkIDApIHsgbWF4ID0gSW5maW5pdHk7IH1cclxuICAgICAgICAgICAgdmFyIGhlbHBlciA9IGZ1bmN0aW9uIChjdXJyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlICYmIGN1cnJlbnROb2RlLmJvdW5kcy5yYXlDYXN0KHJheSwgbWF4KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZS5pc0xlYWYoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2suY2FsbChyYXksIGN1cnJlbnROb2RlLmJvZHkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByYXkgaGl0IGEgbGVhZiEgcmV0dXJuIHRoZSBib2R5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmF5IGhpdCBidXQgbm90IGF0IGEgbGVhZiwgcmVjdXJzZSBkZWVwZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcihjdXJyZW50Tm9kZS5sZWZ0KSB8fCBoZWxwZXIoY3VycmVudE5vZGUucmlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gcmF5IG1pc3NlZCAgICAgICAgIFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBoZWxwZXIodGhpcy5yb290KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIER5bmFtaWNUcmVlLnByb3RvdHlwZS5nZXROb2RlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGhlbHBlciA9IGZ1bmN0aW9uIChjdXJyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtjdXJyZW50Tm9kZV0uY29uY2F0KGhlbHBlcihjdXJyZW50Tm9kZS5sZWZ0KSwgaGVscGVyKGN1cnJlbnROb2RlLnJpZ2h0KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBoZWxwZXIodGhpcy5yb290KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIER5bmFtaWNUcmVlLnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgICAgICAgICAgIC8vIGRyYXcgYWxsIHRoZSBub2RlcyBpbiB0aGUgRHluYW1pYyBUcmVlXHJcbiAgICAgICAgICAgIHZhciBoZWxwZXIgPSBmdW5jdGlvbiAoY3VycmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZS5pc0xlYWYoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ2dyZWVuJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnd2hpdGUnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5ib3VuZHMuZGVidWdEcmF3KGN0eCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLmxlZnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVscGVyKGN1cnJlbnROb2RlLmxlZnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUucmlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVscGVyKGN1cnJlbnROb2RlLnJpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGhlbHBlcih0aGlzLnJvb3QpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIER5bmFtaWNUcmVlO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuRHluYW1pY1RyZWUgPSBEeW5hbWljVHJlZTtcclxufSk7XHJcbmRlZmluZShcIkNvbGxpc2lvbi9JQ29sbGlzaW9uUmVzb2x2ZXJcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxufSk7XHJcbmRlZmluZShcIkNvbGxpc2lvbi9EeW5hbWljVHJlZUNvbGxpc2lvbkJyb2FkcGhhc2VcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJQaHlzaWNzXCIsIFwiQ29sbGlzaW9uL0R5bmFtaWNUcmVlXCIsIFwiQ29sbGlzaW9uL1BhaXJcIiwgXCJBbGdlYnJhXCIsIFwiQWN0b3JcIiwgXCJVdGlsL0xvZ1wiLCBcIkV2ZW50c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIFBoeXNpY3NfOSwgRHluYW1pY1RyZWVfMSwgUGFpcl8yLCBBbGdlYnJhXzE4LCBBY3Rvcl85LCBMb2dfOSwgRXZlbnRzXzYpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgdmFyIER5bmFtaWNUcmVlQ29sbGlzaW9uQnJvYWRwaGFzZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gRHluYW1pY1RyZWVDb2xsaXNpb25Ccm9hZHBoYXNlKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9keW5hbWljQ29sbGlzaW9uVHJlZSA9IG5ldyBEeW5hbWljVHJlZV8xLkR5bmFtaWNUcmVlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbGxpc2lvbkhhc2ggPSB7fTtcclxuICAgICAgICAgICAgdGhpcy5fY29sbGlzaW9uUGFpckNhY2hlID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3RGcmFtZVBhaXJzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3RGcmFtZVBhaXJzSGFzaCA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUcmFja3MgYSBwaHlzaWNzIGJvZHkgZm9yIGNvbGxpc2lvbnNcclxuICAgICAgICAgKi9cclxuICAgICAgICBEeW5hbWljVHJlZUNvbGxpc2lvbkJyb2FkcGhhc2UucHJvdG90eXBlLnRyYWNrID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgICAgICBpZiAoIXRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgTG9nXzkuTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybignQ2Fubm90IHRyYWNrIG51bGwgcGh5c2ljcyBib2R5Jyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fZHluYW1pY0NvbGxpc2lvblRyZWUudHJhY2tCb2R5KHRhcmdldCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVbnRyYWNrcyBhIHBoeXNpY3MgYm9keVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIER5bmFtaWNUcmVlQ29sbGlzaW9uQnJvYWRwaGFzZS5wcm90b3R5cGUudW50cmFjayA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIExvZ185LkxvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4oJ0Nhbm5vdCB1bnRyYWNrIGEgbnVsbCBwaHlzaWNzIGJvZHknKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9keW5hbWljQ29sbGlzaW9uVHJlZS51bnRyYWNrQm9keSh0YXJnZXQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRHluYW1pY1RyZWVDb2xsaXNpb25Ccm9hZHBoYXNlLnByb3RvdHlwZS5fY2FuQ29sbGlkZSA9IGZ1bmN0aW9uIChhY3RvckEsIGFjdG9yQikge1xyXG4gICAgICAgICAgICAvLyBpZiB0aGUgY29sbGlzaW9uIHBhaXIgaGFzIGJlZW4gY2FsY3VsYXRlZCBhbHJlYWR5IHNob3J0IGNpcmN1aXRcclxuICAgICAgICAgICAgdmFyIGhhc2ggPSBQYWlyXzIuUGFpci5jYWxjdWxhdGVQYWlySGFzaChhY3RvckEuYm9keSwgYWN0b3JCLmJvZHkpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fY29sbGlzaW9uSGFzaFtoYXNoXSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBwYWlyIGV4aXN0cyBlYXN5IGV4aXQgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaWYgYm90aCBhcmUgZml4ZWQgc2hvcnQgY2lyY3VpdFxyXG4gICAgICAgICAgICBpZiAoYWN0b3JBLmNvbGxpc2lvblR5cGUgPT09IEFjdG9yXzkuQ29sbGlzaW9uVHlwZS5GaXhlZCAmJiBhY3RvckIuY29sbGlzaW9uVHlwZSA9PT0gQWN0b3JfOS5Db2xsaXNpb25UeXBlLkZpeGVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaWYgdGhlIG90aGVyIGlzIHByZXZlbnQgY29sbGlzaW9uIG9yIGlzIGRlYWQgc2hvcnQgY2lyY3VpdFxyXG4gICAgICAgICAgICBpZiAoYWN0b3JCLmNvbGxpc2lvblR5cGUgPT09IEFjdG9yXzkuQ29sbGlzaW9uVHlwZS5QcmV2ZW50Q29sbGlzaW9uIHx8IGFjdG9yQi5pc0tpbGxlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdGhleSBjYW4gY29sbGlkZVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERldGVjdHMgcG90ZW50aWFsIGNvbGxpc2lvbiBwYWlycyBpbiBhIGJyb2FkcGhhc2UgYXBwcm9hY2ggd2l0aCB0aGUgZHluYW1pYyBhYWJiIHRyZWUgc3RyYXRlZ3lcclxuICAgICAgICAgKi9cclxuICAgICAgICBEeW5hbWljVHJlZUNvbGxpc2lvbkJyb2FkcGhhc2UucHJvdG90eXBlLmJyb2FkcGhhc2UgPSBmdW5jdGlvbiAodGFyZ2V0cywgZGVsdGEsIHN0YXRzKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBzZWNvbmRzID0gZGVsdGEgLyAxMDAwO1xyXG4gICAgICAgICAgICAvLyBUT0RPIG9wdGltaXphdGlvbiB1c2Ugb25seSB0aGUgYWN0b3JzIHRoYXQgYXJlIG1vdmluZyB0byBzdGFydCBcclxuICAgICAgICAgICAgLy8gUmV0cmlldmUgdGhlIGxpc3Qgb2YgcG90ZW50aWFsIGNvbGxpZGVycywgZXhjbHVkZSBraWxsZWQsIHByZXZlbnRlZCwgYW5kIHNlbGZcclxuICAgICAgICAgICAgdmFyIHBvdGVudGlhbENvbGxpZGVycyA9IHRhcmdldHMuZmlsdGVyKGZ1bmN0aW9uIChvdGhlcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICFvdGhlci5pc0tpbGxlZCgpICYmIG90aGVyLmNvbGxpc2lvblR5cGUgIT09IEFjdG9yXzkuQ29sbGlzaW9uVHlwZS5QcmV2ZW50Q29sbGlzaW9uO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gY2xlYXIgb2xkIGxpc3Qgb2YgY29sbGlzaW9uIHBhaXJzXHJcbiAgICAgICAgICAgIHRoaXMuX2NvbGxpc2lvblBhaXJDYWNoZSA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLl9jb2xsaXNpb25IYXNoID0ge307XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBub3JtYWwgY29sbGlzaW9uIHBhaXJzXHJcbiAgICAgICAgICAgIHZhciBhY3RvcjtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGwgPSBwb3RlbnRpYWxDb2xsaWRlcnMubGVuZ3RoOyBqIDwgbDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBhY3RvciA9IHBvdGVudGlhbENvbGxpZGVyc1tqXTtcclxuICAgICAgICAgICAgICAgIC8vIFF1ZXJ5IHRoZSBjb2xsaXNpb24gdHJlZSBmb3IgcG90ZW50aWFsIGNvbGxpZGVyc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZHluYW1pY0NvbGxpc2lvblRyZWUucXVlcnkoYWN0b3IuYm9keSwgZnVuY3Rpb24gKG90aGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9jYW5Db2xsaWRlKGFjdG9yLCBvdGhlci5hY3RvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhaXIgPSBuZXcgUGFpcl8yLlBhaXIoYWN0b3IuYm9keSwgb3RoZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fY29sbGlzaW9uSGFzaFtwYWlyLmlkXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9jb2xsaXNpb25QYWlyQ2FjaGUucHVzaChwYWlyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQWx3YXlzIHJldHVybiBmYWxzZSwgdG8gcXVlcnkgd2hvbGUgdHJlZS4gUmV0dXJuaW5nIHRydWUgaW4gdGhlIHF1ZXJ5IG1ldGhvZCBzdG9wcyBzZWFyY2hpbmdcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc3RhdHMpIHtcclxuICAgICAgICAgICAgICAgIHN0YXRzLnBoeXNpY3MucGFpcnMgPSB0aGlzLl9jb2xsaXNpb25QYWlyQ2FjaGUubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIENoZWNrIGR5bmFtaWMgdHJlZSBmb3IgZmFzdCBtb3Zpbmcgb2JqZWN0c1xyXG4gICAgICAgICAgICAvLyBGYXN0IG1vdmluZyBvYmplY3RzIGFyZSB0aG9zZSBtb3ZpbmcgYXQgbGVhc3QgdGhlcmUgc21hbGxlc3QgYm91bmQgcGVyIGZyYW1lXHJcbiAgICAgICAgICAgIGlmIChQaHlzaWNzXzkuUGh5c2ljcy5jaGVja0ZvckZhc3RCb2RpZXMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgcG90ZW50aWFsQ29sbGlkZXJzXzEgPSBwb3RlbnRpYWxDb2xsaWRlcnM7IF9pIDwgcG90ZW50aWFsQ29sbGlkZXJzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjdG9yID0gcG90ZW50aWFsQ29sbGlkZXJzXzFbX2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNraXAgbm9uLWFjdGl2ZSBvYmplY3RzLiBEb2VzIG5vdCBtYWtlIHNlbnNlIG9uIG90aGVyIGNvbGxpc29uIHR5cGVzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdG9yLmNvbGxpc2lvblR5cGUgIT09IEFjdG9yXzkuQ29sbGlzaW9uVHlwZS5BY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIDtcclxuICAgICAgICAgICAgICAgICAgICAvLyBNYXhpbXVtIHRyYXZlbCBkaXN0YW5jZSBuZXh0IGZyYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVwZGF0ZURpc3RhbmNlID0gKGFjdG9yLnZlbC5tYWduaXR1ZGUoKSAqIHNlY29uZHMpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGFjdG9yLmFjYy5tYWduaXR1ZGUoKSAqIC41ICogc2Vjb25kcyAqIHNlY29uZHMpOyAvLyBhY2MgdGVybVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIG1pbmltdW0gZGltZW5zaW9uXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pbkRpbWVuc2lvbiA9IE1hdGgubWluKGFjdG9yLmJvZHkuZ2V0Qm91bmRzKCkuZ2V0SGVpZ2h0KCksIGFjdG9yLmJvZHkuZ2V0Qm91bmRzKCkuZ2V0V2lkdGgoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFBoeXNpY3NfOS5QaHlzaWNzLmRpc2FibGVNaW5pbXVtU3BlZWRGb3JGYXN0Qm9keSB8fCB1cGRhdGVEaXN0YW5jZSA+IChtaW5EaW1lbnNpb24gLyAyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRzLnBoeXNpY3MuZmFzdEJvZGllcysrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YXJ0IHdpdGggdGhlIG9sZFBvcyBiZWNhdXNlIHRoZSBpbnRlZ3JhdGlvbiBmb3IgYWN0b3JzIGhhcyBhbHJlYWR5IGhhcHBlbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9iamVjdHMgcmVzdGluZyBvbiBhIHN1cmZhY2UgbWF5IGJlIHNsaWdodGx5IHBlbmF0cmF0aW5nIGluIHRoZSBjdXJyZW50IHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1cGRhdGVWZWMgPSBhY3Rvci5wb3Muc3ViKGFjdG9yLm9sZFBvcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjZW50ZXJQb2ludCA9IGFjdG9yLmJvZHkuY29sbGlzaW9uQXJlYS5nZXRDZW50ZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZ1cnRoZXN0UG9pbnQgPSBhY3Rvci5ib2R5LmNvbGxpc2lvbkFyZWEuZ2V0RnVydGhlc3RQb2ludChhY3Rvci52ZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luID0gZnVydGhlc3RQb2ludC5zdWIodXBkYXRlVmVjKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJheSA9IG5ldyBBbGdlYnJhXzE4LlJheShvcmlnaW4sIGFjdG9yLnZlbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJhY2sgdGhlIHJheSB1cCBieSAtMnggc3VyZmFjZUVwc2lsb24gdG8gYWNjb3VudCBmb3IgZmFzdCBtb3Zpbmcgb2JqZWN0cyBzdGFydGluZyBvbiB0aGUgc3VyZmFjZSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmF5LnBvcyA9IHJheS5wb3MuYWRkKHJheS5kaXIuc2NhbGUoLTIgKiBQaHlzaWNzXzkuUGh5c2ljcy5zdXJmYWNlRXBzaWxvbikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWluQm9keTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1pblRyYW5zbGF0ZSA9IG5ldyBBbGdlYnJhXzE4LlZlY3RvcihJbmZpbml0eSwgSW5maW5pdHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9keW5hbWljQ29sbGlzaW9uVHJlZS5yYXlDYXN0UXVlcnkocmF5LCB1cGRhdGVEaXN0YW5jZSArIFBoeXNpY3NfOS5QaHlzaWNzLnN1cmZhY2VFcHNpbG9uICogMiwgZnVuY3Rpb24gKG90aGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWN0b3IuYm9keSAhPT0gb3RoZXIgJiYgb3RoZXIuY29sbGlzaW9uQXJlYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoaXRQb2ludCA9IG90aGVyLmNvbGxpc2lvbkFyZWEucmF5Q2FzdChyYXksIHVwZGF0ZURpc3RhbmNlICsgUGh5c2ljc185LlBoeXNpY3Muc3VyZmFjZUVwc2lsb24gKiAxMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhpdFBvaW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2xhdGUgPSBoaXRQb2ludC5zdWIob3JpZ2luKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zbGF0ZS5tYWduaXR1ZGUoKSA8IG1pblRyYW5zbGF0ZS5tYWduaXR1ZGUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluVHJhbnNsYXRlID0gdHJhbnNsYXRlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluQm9keSA9IG90aGVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1pbkJvZHkgJiYgQWxnZWJyYV8xOC5WZWN0b3IuaXNWYWxpZChtaW5UcmFuc2xhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFpciA9IG5ldyBQYWlyXzIuUGFpcihhY3Rvci5ib2R5LCBtaW5Cb2R5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fY29sbGlzaW9uSGFzaFtwYWlyLmlkXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxpc2lvbkhhc2hbcGFpci5pZF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxpc2lvblBhaXJDYWNoZS5wdXNoKHBhaXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSB0aGUgZmFzdCBtb3Zpbmcgb2JqZWN0IHRvIHRoZSBvdGhlciBib2R5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIHB1c2ggaW50byB0aGUgc3VyZmFjZSBieSBleC5QaHlzaWNzLnN1cmZhY2VFcHNpbG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2hpZnQgPSBjZW50ZXJQb2ludC5zdWIoZnVydGhlc3RQb2ludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rvci5wb3MgPSBvcmlnaW4uYWRkKHNoaWZ0KS5hZGQobWluVHJhbnNsYXRlKS5hZGQocmF5LmRpci5zY2FsZSgyICogUGh5c2ljc185LlBoeXNpY3Muc3VyZmFjZUVwc2lsb24pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdG9yLmJvZHkuY29sbGlzaW9uQXJlYS5yZWNhbGMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRzLnBoeXNpY3MuZmFzdEJvZHlDb2xsaXNpb25zKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcmV0dXJuIGNhY2hlXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2xsaXNpb25QYWlyQ2FjaGU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcHBsaWVzIG5hcnJvdyBwaGFzZSBvbiBjb2xsaXNpb24gcGFpcnMgdG8gZmluZCBhY3R1YWwgYXJlYSBpbnRlcnNlY3Rpb25zXHJcbiAgICAgICAgICogQWRkcyBhY3R1YWwgY29sbGlkaW5nIHBhaXJzIHRvIHN0YXRzJyBGcmFtZSBkYXRhXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHluYW1pY1RyZWVDb2xsaXNpb25Ccm9hZHBoYXNlLnByb3RvdHlwZS5uYXJyb3dwaGFzZSA9IGZ1bmN0aW9uIChwYWlycywgc3RhdHMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcGFpcnNbaV0uY29sbGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRzICYmIHBhaXJzW2ldLmNvbGxpc2lvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRzLnBoeXNpY3MuY29sbGlzaW9ucysrO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRzLnBoeXNpY3MuY29sbGlkZXJzSGFzaFtwYWlyc1tpXS5pZF0gPSBwYWlyc1tpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcGFpcnMuZmlsdGVyKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLmNvbGxpc2lvbjsgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQZXJmb3JtIGNvbGxpc2lvbiByZXNvbHV0aW9uIGdpdmVuIGEgc3RyYXRlZ3kgKHJpZ2lkIGJvZHkgb3IgYm94KSBhbmQgbW92ZSBvYmplY3RzIG91dCBvZiBpbnRlcnNlY3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHluYW1pY1RyZWVDb2xsaXNpb25Ccm9hZHBoYXNlLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gKHBhaXJzLCBkZWx0YSwgc3RyYXRlZ3kpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBwYWlyc18xID0gcGFpcnM7IF9pIDwgcGFpcnNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYWlyID0gcGFpcnNfMVtfaV07XHJcbiAgICAgICAgICAgICAgICBwYWlyLnJlc29sdmUoc3RyYXRlZ3kpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhaXIuY29sbGlzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFpci5ib2R5QS5hcHBseU10digpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhaXIuYm9keUIuYXBwbHlNdHYoKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyB0b2RvIHN0aWxsIGRvbid0IGxpa2UgdGhpcywgdGhpcyBpcyBhIHNtYWxsIGludGVncmF0aW9uIHN0ZXAgdG8gcmVzb2x2ZSBuYXJyb3dwaGFzZSBjb2xsaXNpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgcGFpci5ib2R5QS5hY3Rvci5pbnRlZ3JhdGUoZGVsdGEgKiBQaHlzaWNzXzkuUGh5c2ljcy5jb2xsaXNpb25TaGlmdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFpci5ib2R5Qi5hY3Rvci5pbnRlZ3JhdGUoZGVsdGEgKiBQaHlzaWNzXzkuUGh5c2ljcy5jb2xsaXNpb25TaGlmdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHBhaXJzLmZpbHRlcihmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5jYW5Db2xsaWRlOyB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIER5bmFtaWNUcmVlQ29sbGlzaW9uQnJvYWRwaGFzZS5wcm90b3R5cGUucnVuQ29sbGlzaW9uU3RhcnRFbmQgPSBmdW5jdGlvbiAocGFpcnMpIHtcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRGcmFtZUhhc2ggPSB7fTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBwYWlyc18yID0gcGFpcnM7IF9pIDwgcGFpcnNfMi5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBwID0gcGFpcnNfMltfaV07XHJcbiAgICAgICAgICAgICAgICAvLyBsb2FkIGN1cnJlbnRGcmFtZUhhc2hcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRGcmFtZUhhc2hbcC5pZF0gPSBwO1xyXG4gICAgICAgICAgICAgICAgLy8gZmluZCBhbGwgbmV3IGNvbGxpc2lvbnNcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fbGFzdEZyYW1lUGFpcnNIYXNoW3AuaWRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjdG9yMSA9IHAuYm9keUEuYWN0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjdG9yMiA9IHAuYm9keUIuYWN0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0b3IxLmVtaXQoJ2NvbGxpc2lvbnN0YXJ0JywgbmV3IEV2ZW50c182LkNvbGxpc2lvblN0YXJ0RXZlbnQoYWN0b3IxLCBhY3RvcjIsIHApKTtcclxuICAgICAgICAgICAgICAgICAgICBhY3RvcjIuZW1pdCgnY29sbGlzaW9uc3RhcnQnLCBuZXcgRXZlbnRzXzYuQ29sbGlzaW9uU3RhcnRFdmVudChhY3RvcjIsIGFjdG9yMSwgcCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGZpbmQgYWxsIG9sZCBjb2xsaXNpb25zXHJcbiAgICAgICAgICAgIGZvciAodmFyIF9hID0gMCwgX2IgPSB0aGlzLl9sYXN0RnJhbWVQYWlyczsgX2EgPCBfYi5sZW5ndGg7IF9hKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBwID0gX2JbX2FdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50RnJhbWVIYXNoW3AuaWRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjdG9yMSA9IHAuYm9keUEuYWN0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjdG9yMiA9IHAuYm9keUIuYWN0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0b3IxLmVtaXQoJ2NvbGxpc2lvbmVuZCcsIG5ldyBFdmVudHNfNi5Db2xsaXNpb25FbmRFdmVudChhY3RvcjEsIGFjdG9yMikpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdG9yMi5lbWl0KCdjb2xsaXNpb25lbmQnLCBuZXcgRXZlbnRzXzYuQ29sbGlzaW9uRW5kRXZlbnQoYWN0b3IyLCBhY3RvcjEpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyByZXNldCB0aGUgbGFzdCBmcmFtZSBjYWNoZVxyXG4gICAgICAgICAgICB0aGlzLl9sYXN0RnJhbWVQYWlycyA9IHBhaXJzO1xyXG4gICAgICAgICAgICB0aGlzLl9sYXN0RnJhbWVQYWlyc0hhc2ggPSBjdXJyZW50RnJhbWVIYXNoO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXBkYXRlIHRoZSBkeW5hbWljIHRyZWUgcG9zaXRpb25zXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHluYW1pY1RyZWVDb2xsaXNpb25Ccm9hZHBoYXNlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAodGFyZ2V0cykge1xyXG4gICAgICAgICAgICB2YXIgdXBkYXRlZCA9IDAsIGkgPSAwLCBsZW4gPSB0YXJnZXRzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9keW5hbWljQ29sbGlzaW9uVHJlZS51cGRhdGVCb2R5KHRhcmdldHNbaV0uYm9keSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZWQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIER5bmFtaWNUcmVlQ29sbGlzaW9uQnJvYWRwaGFzZS5wcm90b3R5cGUuZGVidWdEcmF3ID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gICAgICAgICAgICBpZiAoUGh5c2ljc185LlBoeXNpY3MuYnJvYWRwaGFzZURlYnVnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9keW5hbWljQ29sbGlzaW9uVHJlZS5kZWJ1Z0RyYXcoY3R4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoUGh5c2ljc185LlBoeXNpY3Muc2hvd0NvbnRhY3RzIHx8IFBoeXNpY3NfOS5QaHlzaWNzLnNob3dDb2xsaXNpb25Ob3JtYWxzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5fY29sbGlzaW9uUGFpckNhY2hlOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYWlyID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhaXIuZGVidWdEcmF3KGN0eCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBEeW5hbWljVHJlZUNvbGxpc2lvbkJyb2FkcGhhc2U7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5EeW5hbWljVHJlZUNvbGxpc2lvbkJyb2FkcGhhc2UgPSBEeW5hbWljVHJlZUNvbGxpc2lvbkJyb2FkcGhhc2U7XHJcbn0pO1xyXG5kZWZpbmUoXCJDb2xsaXNpb24vSVBoeXNpY3NcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxufSk7XHJcbmRlZmluZShcIkNvbGxpc2lvbi9OYWl2ZUNvbGxpc2lvbkJyb2FkcGhhc2VcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJQaHlzaWNzXCIsIFwiQ29sbGlzaW9uL0NvbGxpc2lvbkNvbnRhY3RcIiwgXCJDb2xsaXNpb24vUGFpclwiLCBcIkFjdG9yXCIsIFwiRXZlbnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgUGh5c2ljc18xMCwgQ29sbGlzaW9uQ29udGFjdF8yLCBQYWlyXzMsIEFjdG9yXzEwLCBFdmVudHNfNykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICB2YXIgTmFpdmVDb2xsaXNpb25Ccm9hZHBoYXNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBOYWl2ZUNvbGxpc2lvbkJyb2FkcGhhc2UoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3RGcmFtZVBhaXJzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3RGcmFtZVBhaXJzSGFzaCA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBOYWl2ZUNvbGxpc2lvbkJyb2FkcGhhc2UucHJvdG90eXBlLnRyYWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBwYXNzXHJcbiAgICAgICAgfTtcclxuICAgICAgICBOYWl2ZUNvbGxpc2lvbkJyb2FkcGhhc2UucHJvdG90eXBlLnVudHJhY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIHBhc3NcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERldGVjdHMgcG90ZW50aWFsIGNvbGxpc2lvbiBwYWlycyBpbiBhIGJyb2FkcGhhc2UgYXBwcm9hY2ggd2l0aCB0aGUgZHluYW1pYyBhYWJiIHRyZWUgc3RyYXRlZ3lcclxuICAgICAgICAgKi9cclxuICAgICAgICBOYWl2ZUNvbGxpc2lvbkJyb2FkcGhhc2UucHJvdG90eXBlLmJyb2FkcGhhc2UgPSBmdW5jdGlvbiAodGFyZ2V0cykge1xyXG4gICAgICAgICAgICAvLyBSZXRyaWV2ZSB0aGUgbGlzdCBvZiBwb3RlbnRpYWwgY29sbGlkZXJzLCBleGNsdWRlIGtpbGxlZCwgcHJldmVudGVkLCBhbmQgc2VsZlxyXG4gICAgICAgICAgICB2YXIgcG90ZW50aWFsQ29sbGlkZXJzID0gdGFyZ2V0cy5maWx0ZXIoZnVuY3Rpb24gKG90aGVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gIW90aGVyLmlzS2lsbGVkKCkgJiYgb3RoZXIuY29sbGlzaW9uVHlwZSAhPT0gQWN0b3JfMTAuQ29sbGlzaW9uVHlwZS5QcmV2ZW50Q29sbGlzaW9uO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmFyIGFjdG9yMTtcclxuICAgICAgICAgICAgdmFyIGFjdG9yMjtcclxuICAgICAgICAgICAgdmFyIGNvbGxpc2lvblBhaXJzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBsID0gcG90ZW50aWFsQ29sbGlkZXJzLmxlbmd0aDsgaiA8IGw7IGorKykge1xyXG4gICAgICAgICAgICAgICAgYWN0b3IxID0gcG90ZW50aWFsQ29sbGlkZXJzW2pdO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGogKyAxOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0b3IyID0gcG90ZW50aWFsQ29sbGlkZXJzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtaW5pbXVtVHJhbnNsYXRpb25WZWN0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pbmltdW1UcmFuc2xhdGlvblZlY3RvciA9IGFjdG9yMS5jb2xsaWRlcyhhY3RvcjIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYWlyID0gbmV3IFBhaXJfMy5QYWlyKGFjdG9yMS5ib2R5LCBhY3RvcjIuYm9keSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhaXIuY29sbGlzaW9uID0gbmV3IENvbGxpc2lvbkNvbnRhY3RfMi5Db2xsaXNpb25Db250YWN0KGFjdG9yMS5jb2xsaXNpb25BcmVhLCBhY3RvcjIuY29sbGlzaW9uQXJlYSwgbWluaW11bVRyYW5zbGF0aW9uVmVjdG9yLCBhY3RvcjEucG9zLCBtaW5pbXVtVHJhbnNsYXRpb25WZWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbGxpc2lvblBhaXJzLnNvbWUoZnVuY3Rpb24gKGNwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3AuaWQgPT09IHBhaXIuaWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsaXNpb25QYWlycy5wdXNoKHBhaXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjb2xsaXNpb25QYWlycztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElkZW50aWZ5IGFjdHVhbCBjb2xsaXNpb25zIGZyb20gdGhvc2UgcGFpcnMsIGFuZCBjYWxjdWxhdGUgY29sbGlzaW9uIGltcHVsc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBOYWl2ZUNvbGxpc2lvbkJyb2FkcGhhc2UucHJvdG90eXBlLm5hcnJvd3BoYXNlID0gZnVuY3Rpb24gKHBhaXJzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYWlycztcclxuICAgICAgICB9O1xyXG4gICAgICAgIE5haXZlQ29sbGlzaW9uQnJvYWRwaGFzZS5wcm90b3R5cGUucnVuQ29sbGlzaW9uU3RhcnRFbmQgPSBmdW5jdGlvbiAocGFpcnMpIHtcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRGcmFtZUhhc2ggPSB7fTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBwYWlyc18zID0gcGFpcnM7IF9pIDwgcGFpcnNfMy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBwID0gcGFpcnNfM1tfaV07XHJcbiAgICAgICAgICAgICAgICAvLyBsb2FkIGN1cnJlbnRGcmFtZUhhc2hcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRGcmFtZUhhc2hbcC5pZF0gPSBwO1xyXG4gICAgICAgICAgICAgICAgLy8gZmluZCBhbGwgbmV3IGNvbGxpc2lvbnNcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fbGFzdEZyYW1lUGFpcnNIYXNoW3AuaWRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjdG9yMSA9IHAuYm9keUEuYWN0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjdG9yMiA9IHAuYm9keUIuYWN0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0b3IxLmVtaXQoJ2NvbGxpc2lvbnN0YXJ0JywgbmV3IEV2ZW50c183LkNvbGxpc2lvblN0YXJ0RXZlbnQoYWN0b3IxLCBhY3RvcjIsIHApKTtcclxuICAgICAgICAgICAgICAgICAgICBhY3RvcjIuZW1pdCgnY29sbGlzaW9uc3RhcnQnLCBuZXcgRXZlbnRzXzcuQ29sbGlzaW9uU3RhcnRFdmVudChhY3RvcjIsIGFjdG9yMSwgcCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGZpbmQgYWxsIG9sZCBjb2xsaXNpb25zXHJcbiAgICAgICAgICAgIGZvciAodmFyIF9hID0gMCwgX2IgPSB0aGlzLl9sYXN0RnJhbWVQYWlyczsgX2EgPCBfYi5sZW5ndGg7IF9hKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBwID0gX2JbX2FdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50RnJhbWVIYXNoW3AuaWRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjdG9yMSA9IHAuYm9keUEuYWN0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjdG9yMiA9IHAuYm9keUIuYWN0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0b3IxLmVtaXQoJ2NvbGxpc2lvbmVuZCcsIG5ldyBFdmVudHNfNy5Db2xsaXNpb25FbmRFdmVudChhY3RvcjEsIGFjdG9yMikpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdG9yMi5lbWl0KCdjb2xsaXNpb25lbmQnLCBuZXcgRXZlbnRzXzcuQ29sbGlzaW9uRW5kRXZlbnQoYWN0b3IyLCBhY3RvcjEpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyByZXNldCB0aGUgbGFzdCBmcmFtZSBjYWNoZVxyXG4gICAgICAgICAgICB0aGlzLl9sYXN0RnJhbWVQYWlycyA9IHBhaXJzO1xyXG4gICAgICAgICAgICB0aGlzLl9sYXN0RnJhbWVQYWlyc0hhc2ggPSBjdXJyZW50RnJhbWVIYXNoO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVzb2x2ZSB0aGUgcG9zaXRpb24gYW5kIHZlbG9jaXR5IG9mIHRoZSBwaHlzaWNzIGJvZGllc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE5haXZlQ29sbGlzaW9uQnJvYWRwaGFzZS5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIChwYWlycykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHBhaXJzXzQgPSBwYWlyczsgX2kgPCBwYWlyc180Lmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhaXIgPSBwYWlyc180W19pXTtcclxuICAgICAgICAgICAgICAgIHBhaXIucmVzb2x2ZShQaHlzaWNzXzEwLlBoeXNpY3MuY29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcGFpcnMuZmlsdGVyKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLmNhbkNvbGxpZGU7IH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgTmFpdmVDb2xsaXNpb25Ccm9hZHBoYXNlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgTmFpdmVDb2xsaXNpb25Ccm9hZHBoYXNlLnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBOYWl2ZUNvbGxpc2lvbkJyb2FkcGhhc2U7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5OYWl2ZUNvbGxpc2lvbkJyb2FkcGhhc2UgPSBOYWl2ZUNvbGxpc2lvbkJyb2FkcGhhc2U7XHJcbn0pO1xyXG5kZWZpbmUoXCJDb2xsaXNpb24vSW5kZXhcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJDb2xsaXNpb24vQm9keVwiLCBcIkNvbGxpc2lvbi9Cb3VuZGluZ0JveFwiLCBcIkNvbGxpc2lvbi9DaXJjbGVBcmVhXCIsIFwiQ29sbGlzaW9uL0NvbGxpc2lvbkNvbnRhY3RcIiwgXCJDb2xsaXNpb24vQ29sbGlzaW9uSnVtcFRhYmxlXCIsIFwiQ29sbGlzaW9uL0R5bmFtaWNUcmVlXCIsIFwiQ29sbGlzaW9uL0R5bmFtaWNUcmVlQ29sbGlzaW9uQnJvYWRwaGFzZVwiLCBcIkNvbGxpc2lvbi9FZGdlQXJlYVwiLCBcIkNvbGxpc2lvbi9OYWl2ZUNvbGxpc2lvbkJyb2FkcGhhc2VcIiwgXCJDb2xsaXNpb24vUGFpclwiLCBcIkNvbGxpc2lvbi9Qb2x5Z29uQXJlYVwiLCBcIkNvbGxpc2lvbi9TaWRlXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgQm9keV8xLCBCb3VuZGluZ0JveF82LCBDaXJjbGVBcmVhXzQsIENvbGxpc2lvbkNvbnRhY3RfMywgQ29sbGlzaW9uSnVtcFRhYmxlXzQsIER5bmFtaWNUcmVlXzIsIER5bmFtaWNUcmVlQ29sbGlzaW9uQnJvYWRwaGFzZV8xLCBFZGdlQXJlYV80LCBOYWl2ZUNvbGxpc2lvbkJyb2FkcGhhc2VfMSwgUGFpcl80LCBQb2x5Z29uQXJlYV82LCBTaWRlXzMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIF9fZXhwb3J0KEJvZHlfMSk7XHJcbiAgICBfX2V4cG9ydChCb3VuZGluZ0JveF82KTtcclxuICAgIF9fZXhwb3J0KENpcmNsZUFyZWFfNCk7XHJcbiAgICBfX2V4cG9ydChDb2xsaXNpb25Db250YWN0XzMpO1xyXG4gICAgX19leHBvcnQoQ29sbGlzaW9uSnVtcFRhYmxlXzQpO1xyXG4gICAgX19leHBvcnQoRHluYW1pY1RyZWVfMik7XHJcbiAgICBfX2V4cG9ydChEeW5hbWljVHJlZUNvbGxpc2lvbkJyb2FkcGhhc2VfMSk7XHJcbiAgICBfX2V4cG9ydChFZGdlQXJlYV80KTtcclxuICAgIF9fZXhwb3J0KE5haXZlQ29sbGlzaW9uQnJvYWRwaGFzZV8xKTtcclxuICAgIF9fZXhwb3J0KFBhaXJfNCk7XHJcbiAgICBfX2V4cG9ydChQb2x5Z29uQXJlYV82KTtcclxuICAgIF9fZXhwb3J0KFNpZGVfMyk7XHJcbn0pO1xyXG5kZWZpbmUoXCJEcmF3aW5nL1BvbHlnb25cIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJBbGdlYnJhXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgQWxnZWJyYV8xOSkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBjbG9zZWQgcG9seWdvbiBkcmF3aW5nIGdpdmVuIGEgbGlzdCBvZiBbW1ZlY3Rvcl1dcy5cclxuICAgICAqXHJcbiAgICAgKiBAd2FybmluZyBVc2Ugc3BhcmluZ2x5IGFzIFBvbHlnb25zIGFyZSBwZXJmb3JtYW5jZSBpbnRlbnNpdmVcclxuICAgICAqL1xyXG4gICAgdmFyIFBvbHlnb24gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBwb2ludHMgIFRoZSB2ZWN0b3JzIHRvIHVzZSB0byBidWlsZCB0aGUgcG9seWdvbiBpbiBvcmRlclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIFBvbHlnb24ocG9pbnRzKSB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgd2lkdGggb2YgdGhlIGxpbmVzIG9mIHRoZSBwb2x5Z29uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmxpbmVXaWR0aCA9IDU7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgcG9seWdvbiBpcyBmaWxsZWQgb3Igbm90LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5maWxsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fcG9pbnRzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuYW5jaG9yID0gbmV3IEFsZ2VicmFfMTkuVmVjdG9yKDAsIDApO1xyXG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uID0gMDtcclxuICAgICAgICAgICAgdGhpcy5zY2FsZSA9IG5ldyBBbGdlYnJhXzE5LlZlY3RvcigxLCAxKTtcclxuICAgICAgICAgICAgdGhpcy5fcG9pbnRzID0gcG9pbnRzO1xyXG4gICAgICAgICAgICB2YXIgbWluWCA9IHRoaXMuX3BvaW50cy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cnIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbihwcmV2LCBjdXJyLngpO1xyXG4gICAgICAgICAgICB9LCAwKTtcclxuICAgICAgICAgICAgdmFyIG1heFggPSB0aGlzLl9wb2ludHMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgocHJldiwgY3Vyci54KTtcclxuICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSBtYXhYIC0gbWluWDtcclxuICAgICAgICAgICAgdmFyIG1pblkgPSB0aGlzLl9wb2ludHMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5taW4ocHJldiwgY3Vyci55KTtcclxuICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgICAgIHZhciBtYXhZID0gdGhpcy5fcG9pbnRzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3Vycikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHByZXYsIGN1cnIueSk7XHJcbiAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IG1heFkgLSBtaW5ZO1xyXG4gICAgICAgICAgICB0aGlzLm5hdHVyYWxIZWlnaHQgPSB0aGlzLmhlaWdodDtcclxuICAgICAgICAgICAgdGhpcy5uYXR1cmFsV2lkdGggPSB0aGlzLndpZHRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbm90aW1wbGVtZW50ZWQgRWZmZWN0cyBhcmUgbm90IHN1cHBvcnRlZCBvbiBgUG9seWdvbmBcclxuICAgICAgICAgKi9cclxuICAgICAgICBQb2x5Z29uLnByb3RvdHlwZS5hZGRFZmZlY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgb24gcG9seWdvbnNcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBub3RpbXBsZW1lbnRlZCBFZmZlY3RzIGFyZSBub3Qgc3VwcG9ydGVkIG9uIGBQb2x5Z29uYFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBvbHlnb24ucHJvdG90eXBlLnJlbW92ZUVmZmVjdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBvbiBwb2x5Z29uc1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG5vdGltcGxlbWVudGVkIEVmZmVjdHMgYXJlIG5vdCBzdXBwb3J0ZWQgb24gYFBvbHlnb25gXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUG9seWdvbi5wcm90b3R5cGUuY2xlYXJFZmZlY3RzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIG9uIHBvbHlnb25zXHJcbiAgICAgICAgfTtcclxuICAgICAgICBQb2x5Z29uLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy9wYXNzXHJcbiAgICAgICAgfTtcclxuICAgICAgICBQb2x5Z29uLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGN0eCwgeCwgeSkge1xyXG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKHggKyB0aGlzLmFuY2hvci54LCB5ICsgdGhpcy5hbmNob3IueSk7XHJcbiAgICAgICAgICAgIGN0eC5zY2FsZSh0aGlzLnNjYWxlLngsIHRoaXMuc2NhbGUueSk7XHJcbiAgICAgICAgICAgIGN0eC5yb3RhdGUodGhpcy5yb3RhdGlvbik7XHJcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMubGluZVdpZHRoO1xyXG4gICAgICAgICAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIHN1cHBsaWVkIHBvaW50cyBhbmQgY29uc3RydWN0IGEgJ3BvbHlnb24nXHJcbiAgICAgICAgICAgIHZhciBmaXJzdFBvaW50ID0gdGhpcy5fcG9pbnRzWzBdO1xyXG4gICAgICAgICAgICBjdHgubW92ZVRvKGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55KTtcclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9wb2ludHMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh0aGlzLl9wb2ludHNbaV0ueCwgdGhpcy5fcG9pbnRzW2ldLnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN0eC5saW5lVG8oZmlyc3RQb2ludC54LCBmaXJzdFBvaW50LnkpO1xyXG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbGxlZCkge1xyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuZmlsbENvbG9yLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMubGluZUNvbG9yLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZsaXBIb3Jpem9udGFsKSB7XHJcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHRoaXMud2lkdGgsIDApO1xyXG4gICAgICAgICAgICAgICAgY3R4LnNjYWxlKC0xLCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5mbGlwVmVydGljYWwpIHtcclxuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoMCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgY3R4LnNjYWxlKDEsIC0xKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gUG9seWdvbjtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLlBvbHlnb24gPSBQb2x5Z29uO1xyXG59KTtcclxuZGVmaW5lKFwiRHJhd2luZy9JbmRleFwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkRyYXdpbmcvQW5pbWF0aW9uXCIsIFwiRHJhd2luZy9Db2xvclwiLCBcIkRyYXdpbmcvUG9seWdvblwiLCBcIkRyYXdpbmcvU3ByaXRlXCIsIFwiRHJhd2luZy9TcHJpdGVTaGVldFwiLCBcIkRyYXdpbmcvU3ByaXRlRWZmZWN0c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIEFuaW1hdGlvbl8yLCBDb2xvcl8xNywgUG9seWdvbl8xLCBTcHJpdGVfMywgU3ByaXRlU2hlZXRfMSwgZWZmZWN0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBmdW5jdGlvbiBfX2V4cG9ydChtKSB7XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgZXhwb3J0cy5BbmltYXRpb24gPSBBbmltYXRpb25fMi5BbmltYXRpb247XHJcbiAgICBfX2V4cG9ydChDb2xvcl8xNyk7XHJcbiAgICBfX2V4cG9ydChQb2x5Z29uXzEpO1xyXG4gICAgZXhwb3J0cy5TcHJpdGUgPSBTcHJpdGVfMy5TcHJpdGU7XHJcbiAgICBleHBvcnRzLlNwcml0ZVNoZWV0ID0gU3ByaXRlU2hlZXRfMS5TcHJpdGVTaGVldDtcclxuICAgIGV4cG9ydHMuU3ByaXRlRm9udCA9IFNwcml0ZVNoZWV0XzEuU3ByaXRlRm9udDtcclxuICAgIGV4cG9ydHMuRWZmZWN0cyA9IGVmZmVjdHM7XHJcbn0pO1xyXG5kZWZpbmUoXCJJbnRlcmZhY2VzL0luZGV4XCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbn0pO1xyXG5kZWZpbmUoXCJNYXRoL1Blcmxpbk5vaXNlXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiTWF0aC9SYW5kb21cIiwgXCJEcmF3aW5nL0NvbG9yXCIsIFwiVXRpbC9VdGlsXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgUmFuZG9tXzMsIENvbG9yXzE4LCBVdGlsKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIGZ1bmN0aW9uIF9sZXJwKHRpbWUsIGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gYSArIHRpbWUgKiAoYiAtIGEpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gX2ZhZGUodCkge1xyXG4gICAgICAgIHJldHVybiB0ICogdCAqIHQgKiAodCAqICh0ICogNiAtIDE1KSArIDEwKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGVzIHBlcmxpbiBub2lzZSBiYXNlZCBvbiB0aGUgMjAwMiBTaWdncmFwaCBwYXBlciBodHRwOi8vbXJsLm55dS5lZHUvfnBlcmxpbi9ub2lzZS9cclxuICAgICAqIEFsc28gaHR0cHM6Ly9mbGFmbGEyLmdpdGh1Yi5pby8yMDE0LzA4LzA5L3Blcmxpbm5vaXNlLmh0bWxcclxuICAgICAqL1xyXG4gICAgdmFyIFBlcmxpbkdlbmVyYXRvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gUGVybGluR2VuZXJhdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdGhpcy5fcGVybSA9IFsxNTEsIDE2MCwgMTM3LCA5MSwgOTAsIDE1LCAxMzEsIDEzLCAyMDEsIDk1LCA5NiwgNTMsIDE5NCwgMjMzLCA3LCAyMjUsXHJcbiAgICAgICAgICAgICAgICAxNDAsIDM2LCAxMDMsIDMwLCA2OSwgMTQyLCA4LCA5OSwgMzcsIDI0MCwgMjEsIDEwLCAyMywgMTkwLCA2LCAxNDgsIDI0NywgMTIwLCAyMzQsIDc1LCAwLCAyNixcclxuICAgICAgICAgICAgICAgIDE5NywgNjIsIDk0LCAyNTIsIDIxOSwgMjAzLCAxMTcsIDM1LCAxMSwgMzIsIDU3LCAxNzcsIDMzLCA4OCwgMjM3LCAxNDksIDU2LCA4NywgMTc0LCAyMCwgMTI1LCAxMzYsXHJcbiAgICAgICAgICAgICAgICAxNzEsIDE2OCwgNjgsIDE3NSwgNzQsIDE2NSwgNzEsIDEzNCwgMTM5LCA0OCwgMjcsIDE2NiwgNzcsIDE0NiwgMTU4LCAyMzEsIDgzLCAxMTEsIDIyOSwgMTIyLCA2MCxcclxuICAgICAgICAgICAgICAgIDIxMSwgMTMzLCAyMzAsIDIyMCwgMTA1LCA5MiwgNDEsIDU1LCA0NiwgMjQ1LCA0MCwgMjQ0LCAxMDIsIDE0MywgNTQsIDY1LCAyNSwgNjMsIDE2MSwgMSwgMjE2LCA4MCxcclxuICAgICAgICAgICAgICAgIDczLCAyMDksIDc2LCAxMzIsIDE4NywgMjA4LCA4OSwgMTgsIDE2OSwgMjAwLCAxOTYsIDEzNSwgMTMwLCAxMTYsIDE4OCwgMTU5LCA4NiwgMTY0LCAxMDAsIDEwOSwgMTk4LFxyXG4gICAgICAgICAgICAgICAgMTczLCAxODYsIDMsIDY0LCA1MiwgMjE3LCAyMjYsIDI1MCwgMTI0LCAxMjMsIDUsIDIwMiwgMzgsIDE0NywgMTE4LCAxMjYsIDI1NSwgODIsIDg1LCAyMTIsIDIwNywgMjA2LFxyXG4gICAgICAgICAgICAgICAgNTksIDIyNywgNDcsIDE2LCA1OCwgMTcsIDE4MiwgMTg5LCAyOCwgNDIsIDIyMywgMTgzLCAxNzAsIDIxMywgMTE5LCAyNDgsIDE1MiwgMiwgNDQsIDE1NCwgMTYzLCA3MCxcclxuICAgICAgICAgICAgICAgIDIyMSwgMTUzLCAxMDEsIDE1NSwgMTY3LCA0MywgMTcyLCA5LCAxMjksIDIyLCAzOSwgMjUzLCAxOSwgOTgsIDEwOCwgMTEwLCA3OSwgMTEzLCAyMjQsIDIzMiwgMTc4LFxyXG4gICAgICAgICAgICAgICAgMTg1LCAxMTIsIDEwNCwgMjE4LCAyNDYsIDk3LCAyMjgsIDI1MSwgMzQsIDI0MiwgMTkzLCAyMzgsIDIxMCwgMTQ0LCAxMiwgMTkxLCAxNzksIDE2MiwgMjQxLCA4MSxcclxuICAgICAgICAgICAgICAgIDUxLCAxNDUsIDIzNSwgMjQ5LCAxNCwgMjM5LCAxMDcsIDQ5LCAxOTIsIDIxNCwgMzEsIDE4MSwgMTk5LCAxMDYsIDE1NywgMTg0LCA4NCwgMjA0LCAxNzYsIDExNSxcclxuICAgICAgICAgICAgICAgIDEyMSwgNTAsIDQ1LCAxMjcsIDQsIDE1MCwgMjU0LCAxMzgsIDIzNiwgMjA1LCA5MywgMjIyLCAxMTQsIDY3LCAyOSwgMjQsIDcyLCAyNDMsIDE0MSwgMTI4LCAxOTUsXHJcbiAgICAgICAgICAgICAgICA3OCwgNjYsIDIxNSwgNjEsIDE1NiwgMTgwXTtcclxuICAgICAgICAgICAgdGhpcy5fcCA9IG5ldyBVaW50OEFycmF5KDUxMik7XHJcbiAgICAgICAgICAgIHRoaXMuX2RlZmF1bHRQZXJsaW5PcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgb2N0YXZlczogMSxcclxuICAgICAgICAgICAgICAgIGZyZXF1ZW5jeTogMSxcclxuICAgICAgICAgICAgICAgIGFtcGxpdHVkZTogMSxcclxuICAgICAgICAgICAgICAgIHBlcnNpc3RhbmNlOiAuNVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBvcHRpb25zID0gVXRpbC5leHRlbmQoe30sIHRoaXMuX2RlZmF1bHRQZXJsaW5PcHRpb25zLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgdGhpcy5wZXJzaXN0YW5jZSA9IG9wdGlvbnMucGVyc2lzdGFuY2U7XHJcbiAgICAgICAgICAgIHRoaXMuYW1wbGl0dWRlID0gb3B0aW9ucy5hbXBsaXR1ZGU7XHJcbiAgICAgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gb3B0aW9ucy5mcmVxdWVuY3k7XHJcbiAgICAgICAgICAgIHRoaXMub2N0YXZlcyA9IG9wdGlvbnMub2N0YXZlcztcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2VlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmFuZG9tID0gbmV3IFJhbmRvbV8zLlJhbmRvbShvcHRpb25zLnNlZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmFuZG9tID0gbmV3IFJhbmRvbV8zLlJhbmRvbSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3Blcm0gPSB0aGlzLl9yYW5kb20uc2h1ZmZsZSh0aGlzLl9wZXJtKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA1MTI7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcFtpXSA9IHRoaXMuX3Blcm1baSAlIDI1Nl0gJiAweEZGO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFBlcmxpbkdlbmVyYXRvci5wcm90b3R5cGUubm9pc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhbXAgPSB0aGlzLmFtcGxpdHVkZTtcclxuICAgICAgICAgICAgdmFyIGZyZXEgPSB0aGlzLmZyZXF1ZW5jeTtcclxuICAgICAgICAgICAgdmFyIHRvdGFsID0gMDtcclxuICAgICAgICAgICAgdmFyIG1heFZhbHVlID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9jdGF2ZXM7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbCArPSB0aGlzLl9ub2lzZTFkKGFyZ3VtZW50c1swXSAqIGZyZXEpICogYW1wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsICs9IHRoaXMuX25vaXNlMmQoYXJndW1lbnRzWzBdICogZnJlcSwgYXJndW1lbnRzWzFdICogZnJlcSkgKiBhbXA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWwgKz0gdGhpcy5fbm9pc2UzZChhcmd1bWVudHNbMF0gKiBmcmVxLCBhcmd1bWVudHNbMV0gKiBmcmVxLCBhcmd1bWVudHNbMl0gKiBmcmVxKSAqIGFtcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzIGZvciBwZXJsaW4gbm9pc2UnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG1heFZhbHVlICs9IGFtcDtcclxuICAgICAgICAgICAgICAgIGFtcCAqPSB0aGlzLnBlcnNpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgZnJlcSAqPSAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0b3RhbCAvIG1heFZhbHVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2VuZXJhdGVzIGEgbGlzdCBzdGFydGluZyBhdCAwIGFuZCBlbmRpbmcgYXQgMSBvZiBjb250aW91cyBwZXJsaW4gbm9pc2UsIGJ5IGRlZmF1bHQgdGhlIHN0ZXAgaXMgMS9sZW5ndGg7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBQZXJsaW5HZW5lcmF0b3IucHJvdG90eXBlLnNlcXVlbmNlID0gZnVuY3Rpb24gKGxlbmd0aCwgc3RlcCkge1xyXG4gICAgICAgICAgICBpZiAoIXN0ZXApIHtcclxuICAgICAgICAgICAgICAgIHN0ZXAgPSAxIC8gbGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBhcnJheSA9IG5ldyBBcnJheShsZW5ndGgpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IHRoaXMubm9pc2UoaSAqIHN0ZXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBhcnJheTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdlbmVyYXRlcyBhIDJEIGdyaWQgb2YgcGVybGluIG5vaXNlIGdpdmVuIGEgc3RlcCB2YWx1ZSBwYWNrZWQgaW50byBhIDFEIGFycmF5IGkgPSAoeCArIHkqd2lkdGgpLFxyXG4gICAgICAgICAqIGJ5IGRlZmF1bHQgdGhlIHN0ZXAgd2lsbCAxLyhtaW4oZGltZW5zaW9uKSlcclxuICAgICAgICAgKi9cclxuICAgICAgICBQZXJsaW5HZW5lcmF0b3IucHJvdG90eXBlLmdyaWQgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCwgc3RlcCkge1xyXG4gICAgICAgICAgICBpZiAoIXN0ZXApIHtcclxuICAgICAgICAgICAgICAgIHN0ZXAgPSAxIC8gKE1hdGgubWluKHdpZHRoLCBoZWlnaHQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYXJyYXkgPSBuZXcgQXJyYXkod2lkdGggKiBoZWlnaHQpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICBhcnJheVt4ICsgeSAqIHdpZHRoXSA9IHRoaXMubm9pc2UoeCAqIHN0ZXAsIHkgKiBzdGVwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYXJyYXk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQZXJsaW5HZW5lcmF0b3IucHJvdG90eXBlLl9ncmFkaWVudDNkID0gZnVuY3Rpb24gKGhhc2gsIHgsIHksIHopIHtcclxuICAgICAgICAgICAgdmFyIGggPSBoYXNoICYgMHhGO1xyXG4gICAgICAgICAgICB2YXIgdSA9IGggPCA4ID8geCA6IHk7XHJcbiAgICAgICAgICAgIHZhciB2ID0gaCA8IDQgPyB5IDogKChoID09PSAxMiB8fCBoID09PSAxNCkgPyB4IDogeik7XHJcbiAgICAgICAgICAgIHJldHVybiAoKGggJiAxKSA9PT0gMCA/IHUgOiAtdSkgKyAoKGggJiAyKSA9PT0gMCA/IHYgOiAtdik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQZXJsaW5HZW5lcmF0b3IucHJvdG90eXBlLl9ncmFkaWVudDJkID0gZnVuY3Rpb24gKGhhc2gsIHgsIHkpIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gKGhhc2ggJiAxKSA9PT0gMCA/IHggOiB5O1xyXG4gICAgICAgICAgICByZXR1cm4gKGhhc2ggJiAyKSA9PT0gMCA/IC12YWx1ZSA6IHZhbHVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUGVybGluR2VuZXJhdG9yLnByb3RvdHlwZS5fZ3JhZGllbnQxZCA9IGZ1bmN0aW9uIChoYXNoLCB4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoaGFzaCAmIDEpID09PSAwID8gLXggOiB4O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUGVybGluR2VuZXJhdG9yLnByb3RvdHlwZS5fbm9pc2UxZCA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgIHZhciBpbnRYID0gTWF0aC5mbG9vcih4KSAmIDB4RkY7IC8vIGZvcmNlIDAtMjU1IGludGVnZXJzIHRvIGxvb2t1cCBpbiBwZXJtdXRhdGlvblxyXG4gICAgICAgICAgICB4IC09IE1hdGguZmxvb3IoeCk7XHJcbiAgICAgICAgICAgIHZhciBmYWRlWCA9IF9mYWRlKHgpO1xyXG4gICAgICAgICAgICByZXR1cm4gKF9sZXJwKGZhZGVYLCB0aGlzLl9ncmFkaWVudDFkKHRoaXMuX3BbaW50WF0sIHgpLCB0aGlzLl9ncmFkaWVudDFkKHRoaXMuX3BbaW50WCArIDFdLCB4IC0gMSkpICsgMSkgLyAyO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUGVybGluR2VuZXJhdG9yLnByb3RvdHlwZS5fbm9pc2UyZCA9IGZ1bmN0aW9uICh4LCB5KSB7XHJcbiAgICAgICAgICAgIHZhciBpbnRYID0gTWF0aC5mbG9vcih4KSAmIDB4RkY7XHJcbiAgICAgICAgICAgIHZhciBpbnRZID0gTWF0aC5mbG9vcih5KSAmIDB4RkY7XHJcbiAgICAgICAgICAgIHggLT0gTWF0aC5mbG9vcih4KTtcclxuICAgICAgICAgICAgeSAtPSBNYXRoLmZsb29yKHkpO1xyXG4gICAgICAgICAgICB2YXIgZmFkZVggPSBfZmFkZSh4KTtcclxuICAgICAgICAgICAgdmFyIGZhZGVZID0gX2ZhZGUoeSk7XHJcbiAgICAgICAgICAgIHZhciBhID0gdGhpcy5fcFtpbnRYXSArIGludFk7XHJcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy5fcFtpbnRYICsgMV0gKyBpbnRZO1xyXG4gICAgICAgICAgICByZXR1cm4gKF9sZXJwKGZhZGVZLCBfbGVycChmYWRlWCwgdGhpcy5fZ3JhZGllbnQyZCh0aGlzLl9wW2FdLCB4LCB5KSwgdGhpcy5fZ3JhZGllbnQyZCh0aGlzLl9wW2JdLCB4IC0gMSwgeSkpLCBfbGVycChmYWRlWCwgdGhpcy5fZ3JhZGllbnQyZCh0aGlzLl9wW2EgKyAxXSwgeCwgeSAtIDEpLCB0aGlzLl9ncmFkaWVudDJkKHRoaXMuX3BbYiArIDFdLCB4IC0gMSwgeSAtIDEpKSkgKyAxKSAvIDI7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQZXJsaW5HZW5lcmF0b3IucHJvdG90eXBlLl9ub2lzZTNkID0gZnVuY3Rpb24gKHgsIHksIHopIHtcclxuICAgICAgICAgICAgdmFyIGludFggPSBNYXRoLmZsb29yKHgpICYgMHhGRjtcclxuICAgICAgICAgICAgdmFyIGludFkgPSBNYXRoLmZsb29yKHkpICYgMHhGRjtcclxuICAgICAgICAgICAgdmFyIGludFogPSBNYXRoLmZsb29yKHopICYgMHhGRjtcclxuICAgICAgICAgICAgeCAtPSBNYXRoLmZsb29yKHgpO1xyXG4gICAgICAgICAgICB5IC09IE1hdGguZmxvb3IoeSk7XHJcbiAgICAgICAgICAgIHogLT0gTWF0aC5mbG9vcih6KTtcclxuICAgICAgICAgICAgdmFyIGZhZGVYID0gX2ZhZGUoeCk7XHJcbiAgICAgICAgICAgIHZhciBmYWRlWSA9IF9mYWRlKHkpO1xyXG4gICAgICAgICAgICB2YXIgZmFkZVogPSBfZmFkZSh6KTtcclxuICAgICAgICAgICAgdmFyIGEgPSB0aGlzLl9wW2ludFhdICsgaW50WTtcclxuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLl9wW2ludFggKyAxXSArIGludFk7XHJcbiAgICAgICAgICAgIHZhciBhYSA9IHRoaXMuX3BbYV0gKyBpbnRaO1xyXG4gICAgICAgICAgICB2YXIgYmEgPSB0aGlzLl9wW2JdICsgaW50WjtcclxuICAgICAgICAgICAgdmFyIGFiID0gdGhpcy5fcFthICsgMV0gKyBpbnRaO1xyXG4gICAgICAgICAgICB2YXIgYmIgPSB0aGlzLl9wW2IgKyAxXSArIGludFo7XHJcbiAgICAgICAgICAgIHJldHVybiAoX2xlcnAoZmFkZVosIF9sZXJwKGZhZGVZLCBfbGVycChmYWRlWCwgdGhpcy5fZ3JhZGllbnQzZCh0aGlzLl9wW2FhXSwgeCwgeSwgeiksIHRoaXMuX2dyYWRpZW50M2QodGhpcy5fcFtiYV0sIHggLSAxLCB5LCB6KSksIF9sZXJwKGZhZGVYLCB0aGlzLl9ncmFkaWVudDNkKHRoaXMuX3BbYWJdLCB4LCB5IC0gMSwgeiksIHRoaXMuX2dyYWRpZW50M2QodGhpcy5fcFtiYl0sIHggLSAxLCB5IC0gMSwgeikpKSwgX2xlcnAoZmFkZVksIF9sZXJwKGZhZGVYLCB0aGlzLl9ncmFkaWVudDNkKHRoaXMuX3BbYWEgKyAxXSwgeCwgeSwgeiAtIDEpLCB0aGlzLl9ncmFkaWVudDNkKHRoaXMuX3BbYmEgKyAxXSwgeCAtIDEsIHksIHogLSAxKSksIF9sZXJwKGZhZGVYLCB0aGlzLl9ncmFkaWVudDNkKHRoaXMuX3BbYWIgKyAxXSwgeCwgeSAtIDEsIHogLSAxKSwgdGhpcy5fZ3JhZGllbnQzZCh0aGlzLl9wW2JiICsgMV0sIHggLSAxLCB5IC0gMSwgeiAtIDEpKSkpICsgMSkgLyAyO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFBlcmxpbkdlbmVyYXRvcjtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLlBlcmxpbkdlbmVyYXRvciA9IFBlcmxpbkdlbmVyYXRvcjtcclxuICAgIC8qKlxyXG4gICAgICogQSBoZWxwZXIgdG8gZHJhdyAyRCBwZXJsaW4gbWFwcyBnaXZlbiBhIHBlcmxpbiBnZW5lcmF0b3IgYW5kIGEgZnVuY3Rpb25cclxuICAgICAqL1xyXG4gICAgdmFyIFBlcmxpbkRyYXdlcjJEID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gZ2VuZXJhdG9yIC0gQW4gZXhpc3RpbmcgcGVybGluIGdlbmVyYXRvclxyXG4gICAgICAgICAqIEBwYXJhbSBjb2xvckZjbiAtIEEgY29sb3IgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHZhbHVlIGJldHdlZW4gWzAsIDI1NV0gZGVyaXZlZCBmcm9tIHRoZSBwZXJsaW4gZ2VuZXJhdG9yLCBhbmQgcmV0dXJucyBhIGNvbG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gUGVybGluRHJhd2VyMkQoZ2VuZXJhdG9yLCBjb2xvckZjbikge1xyXG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRvciA9IGdlbmVyYXRvcjtcclxuICAgICAgICAgICAgdGhpcy5jb2xvckZjbiA9IGNvbG9yRmNuO1xyXG4gICAgICAgICAgICBpZiAoIWNvbG9yRmNuKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbG9yRmNuID0gZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsIDwgMTI1ID8gQ29sb3JfMTguQ29sb3IuQmxhY2sgOiBDb2xvcl8xOC5Db2xvci5XaGl0ZTsgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGFuIGltYWdlIG9mIDJEIHBlcmxpbiBub2lzZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBlcmxpbkRyYXdlcjJELnByb3RvdHlwZS5pbWFnZSA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHZhciBpbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xyXG4gICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhdyhjdHgsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICBpbWFnZS5zcmMgPSBjYW52YXMudG9EYXRhVVJMKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBpbWFnZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgZHJhd3MgYSAyRCBwZXJsaW4gZ3JpZCBvbiBhIGNhbnZhcyBjb250ZXh0LCBub3QgcmVjb21tZW5kZWQgdG8gYmUgY2FsbGVkIGV2ZXJ5IGZyYW1lIGR1ZSB0byBwZXJmb3JtYW5jZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBlcmxpbkRyYXdlcjJELnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgICAgICB2YXIgZ3JpZCA9IHRoaXMuZ2VuZXJhdG9yLmdyaWQod2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgICAgIHZhciBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKHgsIHksIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGhlaWdodDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdpZHRoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gZ3JpZFtpICsgd2lkdGggKiBqXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IE1hdGguZmxvb3IodmFsICogMjU1KSAmIDB4ZmY7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBpeGVsID0gKGkgKyBqICogaW1hZ2VEYXRhLndpZHRoKSAqIDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gdGhpcy5jb2xvckZjbihjKTtcclxuICAgICAgICAgICAgICAgICAgICBpbWFnZURhdGEuZGF0YVtwaXhlbF0gPSBjb2xvci5yO1xyXG4gICAgICAgICAgICAgICAgICAgIGltYWdlRGF0YS5kYXRhW3BpeGVsICsgMV0gPSBjb2xvci5nO1xyXG4gICAgICAgICAgICAgICAgICAgIGltYWdlRGF0YS5kYXRhW3BpeGVsICsgMl0gPSBjb2xvci5iO1xyXG4gICAgICAgICAgICAgICAgICAgIGltYWdlRGF0YS5kYXRhW3BpeGVsICsgM10gPSBNYXRoLmZsb29yKGNvbG9yLmEgKiAyNTUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN0eC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCB4LCB5KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBQZXJsaW5EcmF3ZXIyRDtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLlBlcmxpbkRyYXdlcjJEID0gUGVybGluRHJhd2VyMkQ7XHJcbn0pO1xyXG5kZWZpbmUoXCJNYXRoL0luZGV4XCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiTWF0aC9QZXJsaW5Ob2lzZVwiLCBcIk1hdGgvUmFuZG9tXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgUGVybGluTm9pc2VfMSwgUmFuZG9tXzQpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIF9fZXhwb3J0KFBlcmxpbk5vaXNlXzEpO1xyXG4gICAgX19leHBvcnQoUmFuZG9tXzQpO1xyXG59KTtcclxuZGVmaW5lKFwiUG9zdFByb2Nlc3NpbmcvSVBvc3RQcm9jZXNzb3JcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxufSk7XHJcbmRlZmluZShcIlBvc3RQcm9jZXNzaW5nL0NvbG9yQmxpbmRDb3JyZWN0b3JcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJVdGlsL0xvZ1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIExvZ18xMCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICB2YXIgQ29sb3JCbGluZG5lc3M7XHJcbiAgICAoZnVuY3Rpb24gKENvbG9yQmxpbmRuZXNzKSB7XHJcbiAgICAgICAgQ29sb3JCbGluZG5lc3NbQ29sb3JCbGluZG5lc3NbXCJQcm90YW5vcGVcIl0gPSAwXSA9IFwiUHJvdGFub3BlXCI7XHJcbiAgICAgICAgQ29sb3JCbGluZG5lc3NbQ29sb3JCbGluZG5lc3NbXCJEZXV0ZXJhbm9wZVwiXSA9IDFdID0gXCJEZXV0ZXJhbm9wZVwiO1xyXG4gICAgICAgIENvbG9yQmxpbmRuZXNzW0NvbG9yQmxpbmRuZXNzW1wiVHJpdGFub3BlXCJdID0gMl0gPSBcIlRyaXRhbm9wZVwiO1xyXG4gICAgfSkoQ29sb3JCbGluZG5lc3MgPSBleHBvcnRzLkNvbG9yQmxpbmRuZXNzIHx8IChleHBvcnRzLkNvbG9yQmxpbmRuZXNzID0ge30pKTtcclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBwb3N0IHByb2Nlc3NvciBjYW4gY29ycmVjdCBjb2xvcnMgYW5kIHNpbXVsYXRlIGNvbG9yIGJsaW5kbmVzcy5cclxuICAgICAqIEl0IGlzIHBvc3NpYmxlIHRvIHVzZSB0aGlzIG9uIGV2ZXJ5IGdhbWUsIGJ1dCB0aGUgZ2FtZSdzIHBlcmZvcm1hbmNlXHJcbiAgICAgKiB3aWxsIHN1ZmZlciBtZWFzdXJhYmx5LiBJdCdzIGJldHRlciB0byB1c2UgaXQgYXMgYSBoZWxwZnVsIHRvb2wgd2hpbGUgZGV2ZWxvcGluZyB5b3VyIGdhbWUuXHJcbiAgICAgKiBSZW1lbWJlciwgdGhlIGJlc3QgcHJhY3RpY2UgaXMgdG8gZGVzaWduIHdpdGggY29sb3IgYmxpbmRuZXNzIGluIG1pbmQuXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOkNvbG9yQmxpbmQubWRdXVxyXG4gICAgICovXHJcbiAgICB2YXIgQ29sb3JCbGluZENvcnJlY3RvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gQ29sb3JCbGluZENvcnJlY3RvcihlbmdpbmUsIHNpbXVsYXRlLCBjb2xvck1vZGUpIHtcclxuICAgICAgICAgICAgaWYgKHNpbXVsYXRlID09PSB2b2lkIDApIHsgc2ltdWxhdGUgPSBmYWxzZTsgfVxyXG4gICAgICAgICAgICBpZiAoY29sb3JNb2RlID09PSB2b2lkIDApIHsgY29sb3JNb2RlID0gQ29sb3JCbGluZG5lc3MuUHJvdGFub3BlOyB9XHJcbiAgICAgICAgICAgIHRoaXMuZW5naW5lID0gZW5naW5lO1xyXG4gICAgICAgICAgICB0aGlzLnNpbXVsYXRlID0gc2ltdWxhdGU7XHJcbiAgICAgICAgICAgIHRoaXMuY29sb3JNb2RlID0gY29sb3JNb2RlO1xyXG4gICAgICAgICAgICB0aGlzLl92ZXJ0ZXhTaGFkZXIgPSAnYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbjsnICtcclxuICAgICAgICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhX3RleENvb3JkOycgK1xyXG4gICAgICAgICAgICAgICAgJ3VuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247JyArXHJcbiAgICAgICAgICAgICAgICAndmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7JyArXHJcbiAgICAgICAgICAgICAgICAndm9pZCBtYWluKCkgeycgK1xyXG4gICAgICAgICAgICAgICAgLy8gY29udmVydCB0aGUgcmVjdGFuZ2xlIGZyb20gcGl4ZWxzIHRvIDAuMCB0byAxLjBcclxuICAgICAgICAgICAgICAgICd2ZWMyIHplcm9Ub09uZSA9IGFfcG9zaXRpb24gLyB1X3Jlc29sdXRpb247JyArXHJcbiAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IGZyb20gMC0+MSB0byAwLT4yXHJcbiAgICAgICAgICAgICAgICAndmVjMiB6ZXJvVG9Ud28gPSB6ZXJvVG9PbmUgKiAyLjA7JyArXHJcbiAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IGZyb20gMC0+MiB0byAtMS0+KzEgKGNsaXBzcGFjZSlcclxuICAgICAgICAgICAgICAgICd2ZWMyIGNsaXBTcGFjZSA9IHplcm9Ub1R3byAtIDEuMDsnICtcclxuICAgICAgICAgICAgICAgICdnbF9Qb3NpdGlvbiA9IHZlYzQoY2xpcFNwYWNlICogdmVjMigxLCAtMSksIDAsIDEpOycgK1xyXG4gICAgICAgICAgICAgICAgLy8gcGFzcyB0aGUgdGV4Q29vcmQgdG8gdGhlIGZyYWdtZW50IHNoYWRlclxyXG4gICAgICAgICAgICAgICAgLy8gVGhlIEdQVSB3aWxsIGludGVycG9sYXRlIHRoaXMgdmFsdWUgYmV0d2VlbiBwb2ludHMuXHJcbiAgICAgICAgICAgICAgICAndl90ZXhDb29yZCA9IGFfdGV4Q29vcmQ7JyArXHJcbiAgICAgICAgICAgICAgICAnfSc7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZyYWdtZW50U2hhZGVyID0gJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycgK1xyXG4gICAgICAgICAgICAgICAgLy8gb3VyIHRleHR1cmVcclxuICAgICAgICAgICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlOycgK1xyXG4gICAgICAgICAgICAgICAgLy8gdGhlIHRleENvb3JkcyBwYXNzZWQgaW4gZnJvbSB0aGUgdmVydGV4IHNoYWRlci5cclxuICAgICAgICAgICAgICAgICd2YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDsnICtcclxuICAgICAgICAgICAgICAgIC8vIENvbG9yIGJsaW5kIGNvbnZlcnNpb25zXHJcbiAgICAgICAgICAgICAgICAvKidtYXQzIG1bOV0gPScgK1xyXG4gICAgICAgICAgICAgICAgJ3snICtcclxuICAgICAgICAgICAgICAgICAgICdtYXQzKDEuMCwgMC4wLCAwLjAsICAwLjAsIDEuMCwgMC4wLCAgMC4wLCAwLjAsIDEuMCAgKSwnICsgLy8gbm9ybWFsXHJcbiAgICAgICAgICAgICAgICAgICAnbWF0MygwLjU2NywgMC40MzMsIDAuMCwgIDAuNTU4LCAwLjQ0MiwgMC4wLCAgMC4wLCAwLjI0MiwgMC43NTgpLCcgKyAvLyBwcm90YW5vcGlhXHJcbiAgICAgICAgICAgICAgICAgICAnbWF0MygwLjgxNywgMC4xODMsIDAuMCwgIDAuMzMzLCAwLjY2NywgMC4wLCAgMC4wLCAwLjEyNSwwLjg3NSksJyArIC8vIHByb3Rhbm9tYWx5XHJcbiAgICAgICAgICAgICAgICAgICAnbWF0MygwLjYyNSwgMC4zNzUsIDAuMCwgIDAuNywgMC4zLCAwLjAsICAwLjAsIDAuMywwLjcgICksJyArIC8vIGRldXRlcmFub3BpYVxyXG4gICAgICAgICAgICAgICAgICAgJ21hdDMoMC44LCAwLjIsIDAuMCwgIDAuMjU4LCAwLjc0MiwgMC4wLCAgMC4wLCAwLjE0MiwwLjg1OCksJyArIC8vIGRldXRlcmFub21hbHlcclxuICAgICAgICAgICAgICAgICAgICdtYXQzKDAuOTUsIDAuMDUsIDAuMCwgIDAuMCwgMC40MzMsIDAuNTY3LCAgMC4wLCAwLjQ3NSwwLjUyNSksJyArIC8vIHRyaXRhbm9waWFcclxuICAgICAgICAgICAgICAgICAgICdtYXQzKDAuOTY3LCAwLjAzMywgMC4wLCAgMC4wLCAwLjczMywgMC4yNjcsICAwLjAsIDAuMTgzLDAuODE3KSwnICsgLy8gdHJpdGFub21hbHlcclxuICAgICAgICAgICAgICAgICAgICdtYXQzKDAuMjk5LCAwLjU4NywgMC4xMTQsICAwLjI5OSwgMC41ODcsIDAuMTE0LCAgMC4yOTksIDAuNTg3LDAuMTE0KSwnICsgLy8gYWNocm9tYXRvcHNpYVxyXG4gICAgICAgICAgICAgICAgICAgJ21hdDMoMC42MTgsIDAuMzIwLCAwLjA2MiwgIDAuMTYzLCAwLjc3NSwgMC4wNjIsICAwLjE2MywgMC4zMjAsMC41MTYpJyArICAvLyBhY2hyb21hdG9tYWx5XHJcbiAgICAgICAgICAgICAgICAnfTsnICsqL1xyXG4gICAgICAgICAgICAgICAgJ3ZvaWQgbWFpbigpIHsnICtcclxuICAgICAgICAgICAgICAgICd2ZWM0IG8gPSAgdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4Q29vcmQpOycgK1xyXG4gICAgICAgICAgICAgICAgLy8gUkdCIHRvIExNUyBtYXRyaXggY29udmVyc2lvblxyXG4gICAgICAgICAgICAgICAgJ2Zsb2F0IEwgPSAoMTcuODgyNCAqIG8ucikgKyAoNDMuNTE2MSAqIG8uZykgKyAoNC4xMTkzNSAqIG8uYik7JyArXHJcbiAgICAgICAgICAgICAgICAnZmxvYXQgTSA9ICgzLjQ1NTY1ICogby5yKSArICgyNy4xNTU0ICogby5nKSArICgzLjg2NzE0ICogby5iKTsnICtcclxuICAgICAgICAgICAgICAgICdmbG9hdCBTID0gKDAuMDI5OTU2NiAqIG8ucikgKyAoMC4xODQzMDkgKiBvLmcpICsgKDEuNDY3MDkgKiBvLmIpOycgK1xyXG4gICAgICAgICAgICAgICAgLy8gU2ltdWxhdGUgY29sb3IgYmxpbmRuZXNzXHJcbiAgICAgICAgICAgICAgICAnLy9NT0RFIENPREUvLycgK1xyXG4gICAgICAgICAgICAgICAgLyogRGV1dGVyYW5vcGUgZm9yIHRlc3RpbmdcclxuICAgICAgICAgICAgICAgICdmbG9hdCBsID0gMS4wICogTCArIDAuMCAqIE0gKyAwLjAgKiBTOycgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgJ2Zsb2F0IG0gPSAwLjQ5NDIwNyAqIEwgKyAwLjAgKiBNICsgMS4yNDgyNyAqIFM7JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAnZmxvYXQgcyA9IDAuMCAqIEwgKyAwLjAgKiBNICsgMS4wICogUzsnICsqL1xyXG4gICAgICAgICAgICAgICAgLy8gTE1TIHRvIFJHQiBtYXRyaXggY29udmVyc2lvblxyXG4gICAgICAgICAgICAgICAgJ3ZlYzQgZXJyb3I7JyArXHJcbiAgICAgICAgICAgICAgICAnZXJyb3IuciA9ICgwLjA4MDk0NDQ0NzkgKiBsKSArICgtMC4xMzA1MDQ0MDkgKiBtKSArICgwLjExNjcyMTA2NiAqIHMpOycgK1xyXG4gICAgICAgICAgICAgICAgJ2Vycm9yLmcgPSAoLTAuMDEwMjQ4NTMzNSAqIGwpICsgKDAuMDU0MDE5MzI2NiAqIG0pICsgKC0wLjExMzYxNDcwOCAqIHMpOycgK1xyXG4gICAgICAgICAgICAgICAgJ2Vycm9yLmIgPSAoLTAuMDAwMzY1Mjk2OTM4ICogbCkgKyAoLTAuMDA0MTIxNjE0NjkgKiBtKSArICgwLjY5MzUxMTQwNSAqIHMpOycgK1xyXG4gICAgICAgICAgICAgICAgJ2Vycm9yLmEgPSAxLjA7JyArXHJcbiAgICAgICAgICAgICAgICAndmVjNCBkaWZmID0gbyAtIGVycm9yOycgK1xyXG4gICAgICAgICAgICAgICAgJ3ZlYzQgY29ycmVjdGlvbjsnICtcclxuICAgICAgICAgICAgICAgICdjb3JyZWN0aW9uLnIgPSAwLjA7JyArXHJcbiAgICAgICAgICAgICAgICAnY29ycmVjdGlvbi5nID0gIChkaWZmLnIgKiAwLjcpICsgKGRpZmYuZyAqIDEuMCk7JyArXHJcbiAgICAgICAgICAgICAgICAnY29ycmVjdGlvbi5iID0gIChkaWZmLnIgKiAwLjcpICsgKGRpZmYuYiAqIDEuMCk7JyArXHJcbiAgICAgICAgICAgICAgICAnY29ycmVjdGlvbiA9IG8gKyBjb3JyZWN0aW9uOycgK1xyXG4gICAgICAgICAgICAgICAgJ2NvcnJlY3Rpb24uYSA9IG8uYTsnICtcclxuICAgICAgICAgICAgICAgICcvL1NJTVVMQVRFLy8nICtcclxuICAgICAgICAgICAgICAgICd9JztcclxuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxDYW52YXMud2lkdGggPSBlbmdpbmUuZHJhd1dpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbENhbnZhcy5oZWlnaHQgPSBlbmdpbmUuZHJhd0hlaWdodDtcclxuICAgICAgICAgICAgdGhpcy5fZ2wgPSB0aGlzLl9pbnRlcm5hbENhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIHsgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl9wcm9ncmFtID0gdGhpcy5fZ2wuY3JlYXRlUHJvZ3JhbSgpO1xyXG4gICAgICAgICAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSB0aGlzLl9nZXRTaGFkZXIoJ0ZyYWdtZW50JywgdGhpcy5fZ2V0RnJhZ21lbnRTaGFkZXJCeU1vZGUoY29sb3JNb2RlKSk7XHJcbiAgICAgICAgICAgIHZhciB2ZXJ0ZXh0U2hhZGVyID0gdGhpcy5fZ2V0U2hhZGVyKCdWZXJ0ZXgnLCB0aGlzLl92ZXJ0ZXhTaGFkZXIpO1xyXG4gICAgICAgICAgICB0aGlzLl9nbC5hdHRhY2hTaGFkZXIodGhpcy5fcHJvZ3JhbSwgdmVydGV4dFNoYWRlcik7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLmF0dGFjaFNoYWRlcih0aGlzLl9wcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLmxpbmtQcm9ncmFtKHRoaXMuX3Byb2dyYW0pO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2dsLmdldFByb2dyYW1QYXJhbWV0ZXIodGhpcy5fcHJvZ3JhbSwgdGhpcy5fZ2wuTElOS19TVEFUVVMpKSB7XHJcbiAgICAgICAgICAgICAgICBMb2dfMTAuTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoJ1VuYWJsZSB0byBsaW5rIHNoYWRlciBwcm9ncmFtIScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLnVzZVByb2dyYW0odGhpcy5fcHJvZ3JhbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIENvbG9yQmxpbmRDb3JyZWN0b3IucHJvdG90eXBlLl9nZXRGcmFnbWVudFNoYWRlckJ5TW9kZSA9IGZ1bmN0aW9uIChjb2xvck1vZGUpIHtcclxuICAgICAgICAgICAgdmFyIGNvZGUgPSAnJztcclxuICAgICAgICAgICAgaWYgKGNvbG9yTW9kZSA9PT0gQ29sb3JCbGluZG5lc3MuUHJvdGFub3BlKSB7XHJcbiAgICAgICAgICAgICAgICBjb2RlID1cclxuICAgICAgICAgICAgICAgICAgICAnZmxvYXQgbCA9IDAuMCAqIEwgKyAyLjAyMzQ0ICogTSArIC0yLjUyNTgxICogUzsnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Zsb2F0IG0gPSAwLjAgKiBMICsgMS4wICogTSArIDAuMCAqIFM7JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdmbG9hdCBzID0gMC4wICogTCArIDAuMCAqIE0gKyAxLjAgKiBTOyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY29sb3JNb2RlID09PSBDb2xvckJsaW5kbmVzcy5EZXV0ZXJhbm9wZSkge1xyXG4gICAgICAgICAgICAgICAgY29kZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgJ2Zsb2F0IGwgPSAxLjAgKiBMICsgMC4wICogTSArIDAuMCAqIFM7JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdmbG9hdCBtID0gMC40OTQyMDcgKiBMICsgMC4wICogTSArIDEuMjQ4MjcgKiBTOycgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmxvYXQgcyA9IDAuMCAqIEwgKyAwLjAgKiBNICsgMS4wICogUzsnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbG9yTW9kZSA9PT0gQ29sb3JCbGluZG5lc3MuVHJpdGFub3BlKSB7XHJcbiAgICAgICAgICAgICAgICBjb2RlID1cclxuICAgICAgICAgICAgICAgICAgICAnZmxvYXQgbCA9IDEuMCAqIEwgKyAwLjAgKiBNICsgMC4wICogUzsnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Zsb2F0IG0gPSAwLjAgKiBMICsgMS4wICogTSArIDAuMCAqIFM7JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdmbG9hdCBzID0gLTAuMzk1OTEzICogTCArIDAuODAxMTA5ICogTSArIDAuMCAqIFM7JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5zaW11bGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZnJhZ21lbnRTaGFkZXIgPSB0aGlzLl9mcmFnbWVudFNoYWRlci5yZXBsYWNlKCcvL1NJTVVMQVRFLy8nLCAnZ2xfRnJhZ0NvbG9yID0gZXJyb3IucmdiYTsnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZyYWdtZW50U2hhZGVyID0gdGhpcy5fZnJhZ21lbnRTaGFkZXIucmVwbGFjZSgnLy9TSU1VTEFURS8vJywgJ2dsX0ZyYWdDb2xvciA9IGNvcnJlY3Rpb24ucmdiYTsnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZnJhZ21lbnRTaGFkZXIucmVwbGFjZSgnLy9NT0RFIENPREUvLycsIGNvZGUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQ29sb3JCbGluZENvcnJlY3Rvci5wcm90b3R5cGUuX3NldFJlY3RhbmdsZSA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHZhciB4MSA9IHg7XHJcbiAgICAgICAgICAgIHZhciB4MiA9IHggKyB3aWR0aDtcclxuICAgICAgICAgICAgdmFyIHkxID0geTtcclxuICAgICAgICAgICAgdmFyIHkyID0geSArIGhlaWdodDtcclxuICAgICAgICAgICAgdGhpcy5fZ2wuYnVmZmVyRGF0YSh0aGlzLl9nbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkoW1xyXG4gICAgICAgICAgICAgICAgeDEsIHkxLFxyXG4gICAgICAgICAgICAgICAgeDIsIHkxLFxyXG4gICAgICAgICAgICAgICAgeDEsIHkyLFxyXG4gICAgICAgICAgICAgICAgeDEsIHkyLFxyXG4gICAgICAgICAgICAgICAgeDIsIHkxLFxyXG4gICAgICAgICAgICAgICAgeDIsIHkyXHJcbiAgICAgICAgICAgIF0pLCB0aGlzLl9nbC5TVEFUSUNfRFJBVyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDb2xvckJsaW5kQ29ycmVjdG9yLnByb3RvdHlwZS5fZ2V0U2hhZGVyID0gZnVuY3Rpb24gKHR5cGUsIHByb2dyYW0pIHtcclxuICAgICAgICAgICAgdmFyIHNoYWRlcjtcclxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdGcmFnbWVudCcpIHtcclxuICAgICAgICAgICAgICAgIHNoYWRlciA9IHRoaXMuX2dsLmNyZWF0ZVNoYWRlcih0aGlzLl9nbC5GUkFHTUVOVF9TSEFERVIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdWZXJ0ZXgnKSB7XHJcbiAgICAgICAgICAgICAgICBzaGFkZXIgPSB0aGlzLl9nbC5jcmVhdGVTaGFkZXIodGhpcy5fZ2wuVkVSVEVYX1NIQURFUik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBMb2dfMTAuTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoJ0Vycm9yIHVua25vd24gc2hhZGVyIHR5cGUnLCB0eXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9nbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBwcm9ncmFtKTtcclxuICAgICAgICAgICAgdGhpcy5fZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2dsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIHRoaXMuX2dsLkNPTVBJTEVfU1RBVFVTKSkge1xyXG4gICAgICAgICAgICAgICAgTG9nXzEwLkxvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKCdVbmFibGUgdG8gY29tcGlsZSBzaGFkZXIhJywgdGhpcy5fZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzaGFkZXI7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDb2xvckJsaW5kQ29ycmVjdG9yLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKGltYWdlLCBvdXQpIHtcclxuICAgICAgICAgICAgLy8gbG9vayB1cCB3aGVyZSB0aGUgdmVydGV4IGRhdGEgbmVlZHMgdG8gZ28uXHJcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbkxvY2F0aW9uID0gdGhpcy5fZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fcHJvZ3JhbSwgJ2FfcG9zaXRpb24nKTtcclxuICAgICAgICAgICAgdmFyIHRleENvb3JkTG9jYXRpb24gPSB0aGlzLl9nbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl9wcm9ncmFtLCAnYV90ZXhDb29yZCcpO1xyXG4gICAgICAgICAgICB2YXIgdGV4Q29vcmRCdWZmZXIgPSB0aGlzLl9nbC5jcmVhdGVCdWZmZXIoKTtcclxuICAgICAgICAgICAgdGhpcy5fZ2wuYmluZEJ1ZmZlcih0aGlzLl9nbC5BUlJBWV9CVUZGRVIsIHRleENvb3JkQnVmZmVyKTtcclxuICAgICAgICAgICAgdGhpcy5fZ2wuYnVmZmVyRGF0YSh0aGlzLl9nbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkoW1xyXG4gICAgICAgICAgICAgICAgMC4wLCAwLjAsXHJcbiAgICAgICAgICAgICAgICAxLjAsIDAuMCxcclxuICAgICAgICAgICAgICAgIDAuMCwgMS4wLFxyXG4gICAgICAgICAgICAgICAgMC4wLCAxLjAsXHJcbiAgICAgICAgICAgICAgICAxLjAsIDAuMCxcclxuICAgICAgICAgICAgICAgIDEuMCwgMS4wXHJcbiAgICAgICAgICAgIF0pLCB0aGlzLl9nbC5TVEFUSUNfRFJBVyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRleENvb3JkTG9jYXRpb24pO1xyXG4gICAgICAgICAgICB0aGlzLl9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRleENvb3JkTG9jYXRpb24sIDIsIHRoaXMuX2dsLkZMT0FULCBmYWxzZSwgMCwgMCk7XHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIHRleHR1cmUuXHJcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy5fZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9nbC5iaW5kVGV4dHVyZSh0aGlzLl9nbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcclxuICAgICAgICAgICAgLy8gU2V0IHRoZSBwYXJhbWV0ZXJzIHNvIHdlIGNhbiByZW5kZXIgYW55IHNpemUgaW1hZ2UuXHJcbiAgICAgICAgICAgIHRoaXMuX2dsLnRleFBhcmFtZXRlcmkodGhpcy5fZ2wuVEVYVFVSRV8yRCwgdGhpcy5fZ2wuVEVYVFVSRV9XUkFQX1MsIHRoaXMuX2dsLkNMQU1QX1RPX0VER0UpO1xyXG4gICAgICAgICAgICB0aGlzLl9nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuX2dsLlRFWFRVUkVfMkQsIHRoaXMuX2dsLlRFWFRVUkVfV1JBUF9ULCB0aGlzLl9nbC5DTEFNUF9UT19FREdFKTtcclxuICAgICAgICAgICAgdGhpcy5fZ2wudGV4UGFyYW1ldGVyaSh0aGlzLl9nbC5URVhUVVJFXzJELCB0aGlzLl9nbC5URVhUVVJFX01JTl9GSUxURVIsIHRoaXMuX2dsLk5FQVJFU1QpO1xyXG4gICAgICAgICAgICB0aGlzLl9nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuX2dsLlRFWFRVUkVfMkQsIHRoaXMuX2dsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgdGhpcy5fZ2wuTkVBUkVTVCk7XHJcbiAgICAgICAgICAgIC8vIEZsaXAgdGhlIHRleHR1cmUgd2hlbiB1bnBhY2tpbmcgaW50byB0aGUgZ2wgY29udGV4dCwgZ2wgcmVhZHMgdGV4dHVyZXMgaW4gdGhlIG9wcG9zaXRlIG9yZGVyIGFzIGV2ZXJ5dGhpbmcgZWxzZSA6L1xyXG4gICAgICAgICAgICB0aGlzLl9nbC5waXhlbFN0b3JlaSh0aGlzLl9nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCAxKTtcclxuICAgICAgICAgICAgLy8gVXBsb2FkIHRoZSBpbWFnZSBpbnRvIHRoZSB0ZXh0dXJlLlxyXG4gICAgICAgICAgICB0aGlzLl9nbC50ZXhJbWFnZTJEKHRoaXMuX2dsLlRFWFRVUkVfMkQsIDAsIHRoaXMuX2dsLlJHQkEsIHRoaXMuX2dsLlJHQkEsIHRoaXMuX2dsLlVOU0lHTkVEX0JZVEUsIGltYWdlKTtcclxuICAgICAgICAgICAgLy8gbG9va3VwIHVuaWZvcm1zXHJcbiAgICAgICAgICAgIHZhciByZXNvbHV0aW9uTG9jYXRpb24gPSB0aGlzLl9nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fcHJvZ3JhbSwgJ3VfcmVzb2x1dGlvbicpO1xyXG4gICAgICAgICAgICAvLyBzZXQgdGhlIHJlc29sdXRpb25cclxuICAgICAgICAgICAgdGhpcy5fZ2wudW5pZm9ybTJmKHJlc29sdXRpb25Mb2NhdGlvbiwgdGhpcy5faW50ZXJuYWxDYW52YXMud2lkdGgsIHRoaXMuX2ludGVybmFsQ2FudmFzLmhlaWdodCk7XHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIGJ1ZmZlciBmb3IgdGhlIHBvc2l0aW9uIG9mIHRoZSByZWN0YW5nbGUgY29ybmVycy5cclxuICAgICAgICAgICAgdmFyIHBvc2l0aW9uQnVmZmVyID0gdGhpcy5fZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLmJpbmRCdWZmZXIodGhpcy5fZ2wuQVJSQVlfQlVGRkVSLCBwb3NpdGlvbkJ1ZmZlcik7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc2l0aW9uTG9jYXRpb24pO1xyXG4gICAgICAgICAgICB0aGlzLl9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBvc2l0aW9uTG9jYXRpb24sIDIsIHRoaXMuX2dsLkZMT0FULCBmYWxzZSwgMCwgMCk7XHJcbiAgICAgICAgICAgIC8vIFNldCBhIHJlY3RhbmdsZSB0aGUgc2FtZSBzaXplIGFzIHRoZSBpbWFnZS5cclxuICAgICAgICAgICAgdGhpcy5fc2V0UmVjdGFuZ2xlKDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpO1xyXG4gICAgICAgICAgICAvLyBEcmF3IHRoZSByZWN0YW5nbGUuXHJcbiAgICAgICAgICAgIHRoaXMuX2dsLmRyYXdBcnJheXModGhpcy5fZ2wuVFJJQU5HTEVTLCAwLCA2KTtcclxuICAgICAgICAgICAgLy8gR3JhYiB0cmFuZm9ybWVkIGltYWdlIGZyb20gaW50ZXJuYWwgY2FudmFzXHJcbiAgICAgICAgICAgIHZhciBwaXhlbERhdGEgPSBuZXcgVWludDhBcnJheShpbWFnZS53aWR0aCAqIGltYWdlLmhlaWdodCAqIDQpO1xyXG4gICAgICAgICAgICB0aGlzLl9nbC5yZWFkUGl4ZWxzKDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIHRoaXMuX2dsLlJHQkEsIHRoaXMuX2dsLlVOU0lHTkVEX0JZVEUsIHBpeGVsRGF0YSk7XHJcbiAgICAgICAgICAgIGltYWdlLmRhdGEuc2V0KHBpeGVsRGF0YSk7XHJcbiAgICAgICAgICAgIG91dC5wdXRJbWFnZURhdGEoaW1hZ2UsIDAsIDApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIENvbG9yQmxpbmRDb3JyZWN0b3I7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5Db2xvckJsaW5kQ29ycmVjdG9yID0gQ29sb3JCbGluZENvcnJlY3RvcjtcclxufSk7XHJcbmRlZmluZShcIlBvc3RQcm9jZXNzaW5nL0luZGV4XCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiUG9zdFByb2Nlc3NpbmcvQ29sb3JCbGluZENvcnJlY3RvclwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIENvbG9yQmxpbmRDb3JyZWN0b3JfMSkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBmdW5jdGlvbiBfX2V4cG9ydChtKSB7XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgX19leHBvcnQoQ29sb3JCbGluZENvcnJlY3Rvcl8xKTtcclxufSk7XHJcbmRlZmluZShcIlJlc291cmNlcy9JbmRleFwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIlJlc291cmNlcy9SZXNvdXJjZVwiLCBcIlJlc291cmNlcy9Tb3VuZFwiLCBcIlJlc291cmNlcy9UZXh0dXJlXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgUmVzb3VyY2VfMiwgU291bmRfMiwgVGV4dHVyZV8zKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIGZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcclxuICAgICAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICBfX2V4cG9ydChSZXNvdXJjZV8yKTtcclxuICAgIF9fZXhwb3J0KFNvdW5kXzIpO1xyXG4gICAgX19leHBvcnQoVGV4dHVyZV8zKTtcclxufSk7XHJcbmRlZmluZShcIklucHV0L0dhbWVwYWRcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJDbGFzc1wiLCBcIkV2ZW50c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIENsYXNzXzUsIEV2ZW50c184KSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogRXhjYWxpYnVyIGxldmVyYWdlcyB0aGUgSFRNTDUgR2FtZXBhZCBBUEkgW3doZXJlIGl0IGlzIHN1cHBvcnRlZF0oaHR0cDovL2Nhbml1c2UuY29tLyNmZWF0PWdhbWVwYWQpXHJcbiAgICAgKiB0byBwcm92aWRlIGNvbnRyb2xsZXIgc3VwcG9ydCBmb3IgeW91ciBnYW1lcy5cclxuICAgICAqXHJcbiAgICAgKiBbW2luY2x1ZGU6R2FtZXBhZHMubWRdXVxyXG4gICAgICovXHJcbiAgICB2YXIgR2FtZXBhZHMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhHYW1lcGFkcywgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBHYW1lcGFkcygpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRvIHBvbGwgZm9yIEdhbWVwYWQgaW5wdXQgKGRlZmF1bHQ6IGBmYWxzZWApXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5lbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCBHYW1lcGFkIEFQSSBpcyBzdXBwb3J0ZWRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLnN1cHBvcnRlZCA9ICEhbmF2aWdhdG9yLmdldEdhbWVwYWRzO1xyXG4gICAgICAgICAgICBfdGhpcy5fZ2FtZVBhZFRpbWVTdGFtcHMgPSBbMCwgMCwgMCwgMF07XHJcbiAgICAgICAgICAgIF90aGlzLl9vbGRQYWRzID0gW107XHJcbiAgICAgICAgICAgIF90aGlzLl9wYWRzID0gW107XHJcbiAgICAgICAgICAgIF90aGlzLl9pbml0U3VjY2VzcyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBfdGhpcy5fbmF2aWdhdG9yID0gbmF2aWdhdG9yO1xyXG4gICAgICAgICAgICBfdGhpcy5fbWluaW11bUNvbmZpZ3VyYXRpb24gPSBudWxsO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEdhbWVwYWRzLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuc3VwcG9ydGVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2luaXRTdWNjZXNzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gSW4gQ2hyb21lLCB0aGlzIHdpbGwgcmV0dXJuIDQgdW5kZWZpbmVkIGl0ZW1zIHVudGlsIGEgYnV0dG9uIGlzIHByZXNzZWRcclxuICAgICAgICAgICAgLy8gSW4gRkYsIHRoaXMgd2lsbCBub3QgcmV0dXJuIGFueSBpdGVtcyB1bnRpbCBhIGJ1dHRvbiBpcyBwcmVzc2VkXHJcbiAgICAgICAgICAgIHRoaXMuX29sZFBhZHMgPSB0aGlzLl9jbG9uZVBhZHModGhpcy5fbmF2aWdhdG9yLmdldEdhbWVwYWRzKCkpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fb2xkUGFkcy5sZW5ndGggJiYgdGhpcy5fb2xkUGFkc1swXSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdFN1Y2Nlc3MgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBtaW5pbXVtIGdhbWVwYWQgY29uZmlndXJhdGlvbiwgZm9yIGV4YW1wbGUge2F4aXM6IDQsIGJ1dHRvbnM6IDR9IG1lYW5zXHJcbiAgICAgICAgICogdGhpcyBnYW1lIHJlcXVpcmVzIGF0IG1pbmltdW0gNCBheGlzIGlucHV0cyBhbmQgNCBidXR0b25zLCB0aGlzIGlzIG5vdCByZXN0cmljdGl2ZVxyXG4gICAgICAgICAqIGFsbCBvdGhlciBjb250cm9sbGVycyB3aXRoIG1vcmUgYXhpcyBvciBidXR0b25zIGFyZSB2YWxpZCBhcyB3ZWxsLiBJZiBubyBtaW5pbXVtXHJcbiAgICAgICAgICogY29uZmlndXJhdGlvbiBpcyBzZXQgYWxsIHBhZHMgYXJlIHZhbGlkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEdhbWVwYWRzLnByb3RvdHlwZS5zZXRNaW5pbXVtR2FtZXBhZENvbmZpZ3VyYXRpb24gPSBmdW5jdGlvbiAoY29uZmlnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuYWJsZUFuZFVwZGF0ZSgpOyAvLyBpZiBjb25maWcgaXMgdXNlZCwgaW1wbGljaXRseSBlbmFibGVcclxuICAgICAgICAgICAgdGhpcy5fbWluaW11bUNvbmZpZ3VyYXRpb24gPSBjb25maWc7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGVuIGltcGxpY2l0bHkgZW5hYmxlZCwgc2V0IHRoZSBlbmFibGVkIGZsYWcgYW5kIHJ1biBhbiB1cGRhdGUgc28gaW5mb3JtYXRpb24gaXMgdXBkYXRlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEdhbWVwYWRzLnByb3RvdHlwZS5fZW5hYmxlQW5kVXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrcyBhIG5hdmlnYXRvciBnYW1lcGFkIGFnYWluc3QgdGhlIG1pbmltdW0gY29uZmlndXJhdGlvbiBpZiBwcmVzZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEdhbWVwYWRzLnByb3RvdHlwZS5faXNHYW1lcGFkVmFsaWQgPSBmdW5jdGlvbiAocGFkKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fbWluaW11bUNvbmZpZ3VyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDtcclxuICAgICAgICAgICAgaWYgKCFwYWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA7XHJcbiAgICAgICAgICAgIHZhciBheGVzTGVuZ3RoID0gcGFkLmF4ZXMuZmlsdGVyKGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgIT09IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgIH0pLmxlbmd0aDtcclxuICAgICAgICAgICAgdmFyIGJ1dHRvbkxlbmd0aCA9IHBhZC5idXR0b25zLmZpbHRlcihmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAodHlwZW9mIHZhbHVlICE9PSB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICB9KS5sZW5ndGg7XHJcbiAgICAgICAgICAgIHJldHVybiBheGVzTGVuZ3RoID49IHRoaXMuX21pbmltdW1Db25maWd1cmF0aW9uLmF4aXMgJiZcclxuICAgICAgICAgICAgICAgIGJ1dHRvbkxlbmd0aCA+PSB0aGlzLl9taW5pbXVtQ29uZmlndXJhdGlvbi5idXR0b25zICYmXHJcbiAgICAgICAgICAgICAgICBwYWQuY29ubmVjdGVkO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgR2FtZXBhZHMucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgICAgICB0aGlzLl9lbmFibGVBbmRVcGRhdGUoKTsgLy8gaW1wbGljaXRseSBlbmFibGVcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBHYW1lcGFkcy5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgICAgICB0aGlzLl9lbmFibGVBbmRVcGRhdGUoKTsgLy8gaW1wbGljaXRseSBlbmFibGVcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5vZmYuY2FsbCh0aGlzLCBldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXBkYXRlcyBHYW1lcGFkIHN0YXRlIGFuZCBwdWJsaXNoZXMgR2FtZXBhZCBldmVudHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBHYW1lcGFkcy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZCB8fCAhdGhpcy5zdXBwb3J0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmluaXQoKTtcclxuICAgICAgICAgICAgdmFyIGdhbWVwYWRzID0gdGhpcy5fbmF2aWdhdG9yLmdldEdhbWVwYWRzKCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2FtZXBhZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmICghZ2FtZXBhZHNbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtZXBhZCA9IHRoaXMuYXQoaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2FzIGNvbm5lY3RlZCwgYnV0IG5vdyBpc24ndCBlbWl0IHRoZSBkaXNjb25uZWN0IGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdhbWVwYWQuY29ubmVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ2Rpc2Nvbm5lY3QnLCBuZXcgRXZlbnRzXzguR2FtZXBhZERpc2Nvbm5lY3RFdmVudChpLCBnYW1lcGFkKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IGNvbm5lY3Rpb24gc3RhdHVzXHJcbiAgICAgICAgICAgICAgICAgICAgZ2FtZXBhZC5jb25uZWN0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5hdChpKS5jb25uZWN0ZWQgJiYgdGhpcy5faXNHYW1lcGFkVmFsaWQoZ2FtZXBhZHNbaV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ2Nvbm5lY3QnLCBuZXcgRXZlbnRzXzguR2FtZXBhZENvbm5lY3RFdmVudChpLCB0aGlzLmF0KGkpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBjb25uZWN0aW9uIHN0YXR1c1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXQoaSkuY29ubmVjdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIDtcclxuICAgICAgICAgICAgICAgIC8vIE9ubHkgc3VwcG9ydGVkIGluIENocm9tZVxyXG4gICAgICAgICAgICAgICAgaWYgKGdhbWVwYWRzW2ldLnRpbWVzdGFtcCAmJiBnYW1lcGFkc1tpXS50aW1lc3RhbXAgPT09IHRoaXMuX2dhbWVQYWRUaW1lU3RhbXBzW2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9nYW1lUGFkVGltZVN0YW1wc1tpXSA9IGdhbWVwYWRzW2ldLnRpbWVzdGFtcDtcclxuICAgICAgICAgICAgICAgIC8vIEFkZCByZWZlcmVuY2UgdG8gbmF2aWdhdG9yIGdhbWVwYWRcclxuICAgICAgICAgICAgICAgIHRoaXMuYXQoaSkubmF2aWdhdG9yR2FtZXBhZCA9IGdhbWVwYWRzW2ldO1xyXG4gICAgICAgICAgICAgICAgLy8gQnV0dG9uc1xyXG4gICAgICAgICAgICAgICAgdmFyIGIsIGJpLCBhLCBhaSwgdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGIgaW4gQnV0dG9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIGJpID0gQnV0dG9uc1tiXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGJpID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2FtZXBhZHNbaV0uYnV0dG9uc1tiaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZ2FtZXBhZHNbaV0uYnV0dG9uc1tiaV0udmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX29sZFBhZHNbaV0uZ2V0QnV0dG9uKGJpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnYW1lcGFkc1tpXS5idXR0b25zW2JpXS5wcmVzc2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXQoaSkudXBkYXRlQnV0dG9uKGJpLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXQoaSkuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ2J1dHRvbicsIG5ldyBFdmVudHNfOC5HYW1lcGFkQnV0dG9uRXZlbnQoYmksIHZhbHVlLCB0aGlzLmF0KGkpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0KGkpLnVwZGF0ZUJ1dHRvbihiaSwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gQXhlc1xyXG4gICAgICAgICAgICAgICAgZm9yIChhIGluIEF4ZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBhaSA9IEF4ZXNbYV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhaSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBnYW1lcGFkc1tpXS5heGVzW2FpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl9vbGRQYWRzW2ldLmdldEF4ZXMoYWkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0KGkpLnVwZGF0ZUF4ZXMoYWksIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXQoaSkuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ2F4aXMnLCBuZXcgRXZlbnRzXzguR2FtZXBhZEF4aXNFdmVudChhaSwgdmFsdWUsIHRoaXMuYXQoaSkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX29sZFBhZHNbaV0gPSB0aGlzLl9jbG9uZVBhZChnYW1lcGFkc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNhZmVseSByZXRyaWV2ZXMgYSBHYW1lcGFkIGF0IGEgc3BlY2lmaWMgaW5kZXggYW5kIGNyZWF0ZXMgb25lIGlmIGl0IGRvZXNuJ3QgeWV0IGV4aXN0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgR2FtZXBhZHMucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuYWJsZUFuZFVwZGF0ZSgpOyAvLyBpbXBsaWNpdGx5IGVuYWJsZSBnYW1lcGFkcyB3aGVuIGF0KCkgaXMgY2FsbGVkICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSB0aGlzLl9wYWRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIHRoZXJlIGlzIGEgcGFkIHRvIHJldHJpZXZlXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5fcGFkcy5sZW5ndGggLSAxLCBtYXggPSBpbmRleDsgaSA8IG1heDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFkcy5wdXNoKG5ldyBHYW1lcGFkKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29sZFBhZHMucHVzaChuZXcgR2FtZXBhZCgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFkc1tpbmRleF07XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwgdmFsaWQgZ2FtZXBhZHMgdGhhdCBtZWV0IHRoZSBtaW5pbXVtIGNvbmZpZ3VyYXRpb24gcmVxdWlyZW1lbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgR2FtZXBhZHMucHJvdG90eXBlLmdldFZhbGlkR2FtZXBhZHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuYWJsZUFuZFVwZGF0ZSgpO1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcGFkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzR2FtZXBhZFZhbGlkKHRoaXMuYXQoaSkubmF2aWdhdG9yR2FtZXBhZCkgJiYgdGhpcy5hdChpKS5jb25uZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmF0KGkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgbnVtYmVyIG9mIGNvbm5lY3RlZCBnYW1lcGFkc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEdhbWVwYWRzLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhZHMuZmlsdGVyKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLmNvbm5lY3RlZDsgfSkubGVuZ3RoO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgR2FtZXBhZHMucHJvdG90eXBlLl9jbG9uZVBhZHMgPSBmdW5jdGlvbiAocGFkcykge1xyXG4gICAgICAgICAgICB2YXIgYXJyID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhcnIucHVzaCh0aGlzLl9jbG9uZVBhZChwYWRzW2ldKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGFycjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZhc3Rlc3Qgd2F5IHRvIGNsb25lIGEga25vd24gb2JqZWN0IGlzIHRvIGRvIGl0IHlvdXJzZWxmXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgR2FtZXBhZHMucHJvdG90eXBlLl9jbG9uZVBhZCA9IGZ1bmN0aW9uIChwYWQpIHtcclxuICAgICAgICAgICAgdmFyIGksIGxlbjtcclxuICAgICAgICAgICAgdmFyIGNsb25lZFBhZCA9IG5ldyBHYW1lcGFkKCk7XHJcbiAgICAgICAgICAgIGlmICghcGFkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmVkUGFkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHBhZC5idXR0b25zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFkLmJ1dHRvbnNbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBjbG9uZWRQYWQudXBkYXRlQnV0dG9uKGksIHBhZC5idXR0b25zW2ldLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBwYWQuYXhlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY2xvbmVkUGFkLnVwZGF0ZUF4ZXMoaSwgcGFkLmF4ZXNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjbG9uZWRQYWQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gR2FtZXBhZHM7XHJcbiAgICB9KENsYXNzXzUuQ2xhc3MpKTtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1pbmltdW0gdmFsdWUgYW4gYXhpcyBoYXMgdG8gbW92ZSBiZWZvcmUgY29uc2lkZXJpbmcgaXQgYSBjaGFuZ2VcclxuICAgICAqL1xyXG4gICAgR2FtZXBhZHMuTWluQXhpc01vdmVUaHJlc2hvbGQgPSAwLjA1O1xyXG4gICAgZXhwb3J0cy5HYW1lcGFkcyA9IEdhbWVwYWRzO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHYW1lcGFkIGhvbGRzIHN0YXRlIGluZm9ybWF0aW9uIGZvciBhIGNvbm5lY3RlZCBjb250cm9sbGVyLiBTZWUgW1tHYW1lcGFkc11dXHJcbiAgICAgKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBoYW5kbGluZyBjb250cm9sbGVyIGlucHV0LlxyXG4gICAgICovXHJcbiAgICB2YXIgR2FtZXBhZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKEdhbWVwYWQsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gR2FtZXBhZCgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuY29ubmVjdGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIF90aGlzLl9idXR0b25zID0gbmV3IEFycmF5KDE2KTtcclxuICAgICAgICAgICAgX3RoaXMuX2F4ZXMgPSBuZXcgQXJyYXkoNCk7XHJcbiAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgX3RoaXMuX2J1dHRvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9idXR0b25zW2ldID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgX3RoaXMuX2F4ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9heGVzW2ldID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiBidXR0b24gaXMgcHJlc3NlZFxyXG4gICAgICAgICAqIEBwYXJhbSBidXR0b24gICAgIFRoZSBidXR0b24gdG8gcXVlcnlcclxuICAgICAgICAgKiBAcGFyYW0gdGhyZXNob2xkICBUaGUgdGhyZXNob2xkIG92ZXIgd2hpY2ggdGhlIGJ1dHRvbiBpcyBjb25zaWRlcmVkIHRvIGJlIHByZXNzZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBHYW1lcGFkLnByb3RvdHlwZS5pc0J1dHRvblByZXNzZWQgPSBmdW5jdGlvbiAoYnV0dG9uLCB0aHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgaWYgKHRocmVzaG9sZCA9PT0gdm9pZCAwKSB7IHRocmVzaG9sZCA9IDE7IH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J1dHRvbnNbYnV0dG9uXSA+PSB0aHJlc2hvbGQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBnaXZlbiBidXR0b24gdmFsdWUgYmV0d2VlbiAwIGFuZCAxXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgR2FtZXBhZC5wcm90b3R5cGUuZ2V0QnV0dG9uID0gZnVuY3Rpb24gKGJ1dHRvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYnV0dG9uc1tidXR0b25dO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgZ2l2ZW4gYXhpcyB2YWx1ZSBiZXR3ZWVuIC0xIGFuZCAxLiBWYWx1ZXMgYmVsb3dcclxuICAgICAgICAgKiBbW01pbkF4aXNNb3ZlVGhyZXNob2xkXV0gYXJlIGNvbnNpZGVyZWQgMC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBHYW1lcGFkLnByb3RvdHlwZS5nZXRBeGVzID0gZnVuY3Rpb24gKGF4ZXMpIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fYXhlc1theGVzXTtcclxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHZhbHVlKSA8IEdhbWVwYWRzLk1pbkF4aXNNb3ZlVGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgR2FtZXBhZC5wcm90b3R5cGUudXBkYXRlQnV0dG9uID0gZnVuY3Rpb24gKGJ1dHRvbkluZGV4LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9idXR0b25zW2J1dHRvbkluZGV4XSA9IHZhbHVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgR2FtZXBhZC5wcm90b3R5cGUudXBkYXRlQXhlcyA9IGZ1bmN0aW9uIChheGVzSW5kZXgsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2F4ZXNbYXhlc0luZGV4XSA9IHZhbHVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEdhbWVwYWQ7XHJcbiAgICB9KENsYXNzXzUuQ2xhc3MpKTtcclxuICAgIGV4cG9ydHMuR2FtZXBhZCA9IEdhbWVwYWQ7XHJcbiAgICAvKipcclxuICAgICAqIEdhbWVwYWQgQnV0dG9ucyBlbnVtZXJhdGlvblxyXG4gICAgICovXHJcbiAgICB2YXIgQnV0dG9ucztcclxuICAgIChmdW5jdGlvbiAoQnV0dG9ucykge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZhY2UgMSBidXR0b24gKGUuZy4gQSlcclxuICAgICAgICAgKi9cclxuICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJGYWNlMVwiXSA9IDBdID0gXCJGYWNlMVwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZhY2UgMiBidXR0b24gKGUuZy4gQilcclxuICAgICAgICAgKi9cclxuICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJGYWNlMlwiXSA9IDFdID0gXCJGYWNlMlwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZhY2UgMyBidXR0b24gKGUuZy4gWClcclxuICAgICAgICAgKi9cclxuICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJGYWNlM1wiXSA9IDJdID0gXCJGYWNlM1wiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZhY2UgNCBidXR0b24gKGUuZy4gWSlcclxuICAgICAgICAgKi9cclxuICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJGYWNlNFwiXSA9IDNdID0gXCJGYWNlNFwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExlZnQgYnVtcGVyIGJ1dHRvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ1dHRvbnNbQnV0dG9uc1tcIkxlZnRCdW1wZXJcIl0gPSA0XSA9IFwiTGVmdEJ1bXBlclwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJpZ2h0IGJ1bXBlciBidXR0b25cclxuICAgICAgICAgKi9cclxuICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJSaWdodEJ1bXBlclwiXSA9IDVdID0gXCJSaWdodEJ1bXBlclwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExlZnQgdHJpZ2dlciBidXR0b25cclxuICAgICAgICAgKi9cclxuICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJMZWZ0VHJpZ2dlclwiXSA9IDZdID0gXCJMZWZ0VHJpZ2dlclwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJpZ2h0IHRyaWdnZXIgYnV0dG9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnV0dG9uc1tCdXR0b25zW1wiUmlnaHRUcmlnZ2VyXCJdID0gN10gPSBcIlJpZ2h0VHJpZ2dlclwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNlbGVjdCBidXR0b25cclxuICAgICAgICAgKi9cclxuICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJTZWxlY3RcIl0gPSA4XSA9IFwiU2VsZWN0XCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3RhcnQgYnV0dG9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnV0dG9uc1tCdXR0b25zW1wiU3RhcnRcIl0gPSA5XSA9IFwiU3RhcnRcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMZWZ0IGFuYWxvZyBzdGljayBwcmVzcyAoZS5nLiBMMylcclxuICAgICAgICAgKi9cclxuICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJMZWZ0U3RpY2tcIl0gPSAxMF0gPSBcIkxlZnRTdGlja1wiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJpZ2h0IGFuYWxvZyBzdGljayBwcmVzcyAoZS5nLiBSMylcclxuICAgICAgICAgKi9cclxuICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJSaWdodFN0aWNrXCJdID0gMTFdID0gXCJSaWdodFN0aWNrXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRC1wYWQgdXBcclxuICAgICAgICAgKi9cclxuICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJEcGFkVXBcIl0gPSAxMl0gPSBcIkRwYWRVcFwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEQtcGFkIGRvd25cclxuICAgICAgICAgKi9cclxuICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJEcGFkRG93blwiXSA9IDEzXSA9IFwiRHBhZERvd25cIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBELXBhZCBsZWZ0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnV0dG9uc1tCdXR0b25zW1wiRHBhZExlZnRcIl0gPSAxNF0gPSBcIkRwYWRMZWZ0XCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRC1wYWQgcmlnaHRcclxuICAgICAgICAgKi9cclxuICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJEcGFkUmlnaHRcIl0gPSAxNV0gPSBcIkRwYWRSaWdodFwiO1xyXG4gICAgfSkoQnV0dG9ucyA9IGV4cG9ydHMuQnV0dG9ucyB8fCAoZXhwb3J0cy5CdXR0b25zID0ge30pKTtcclxuICAgIC8qKlxyXG4gICAgICogR2FtZXBhZCBBeGVzIGVudW1lcmF0aW9uXHJcbiAgICAgKi9cclxuICAgIHZhciBBeGVzO1xyXG4gICAgKGZ1bmN0aW9uIChBeGVzKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTGVmdCBhbmFsb2d1ZSBzdGljayBYIGRpcmVjdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEF4ZXNbQXhlc1tcIkxlZnRTdGlja1hcIl0gPSAwXSA9IFwiTGVmdFN0aWNrWFwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExlZnQgYW5hbG9ndWUgc3RpY2sgWSBkaXJlY3Rpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBBeGVzW0F4ZXNbXCJMZWZ0U3RpY2tZXCJdID0gMV0gPSBcIkxlZnRTdGlja1lcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSaWdodCBhbmFsb2d1ZSBzdGljayBYIGRpcmVjdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEF4ZXNbQXhlc1tcIlJpZ2h0U3RpY2tYXCJdID0gMl0gPSBcIlJpZ2h0U3RpY2tYXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmlnaHQgYW5hbG9ndWUgc3RpY2sgWSBkaXJlY3Rpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBBeGVzW0F4ZXNbXCJSaWdodFN0aWNrWVwiXSA9IDNdID0gXCJSaWdodFN0aWNrWVwiO1xyXG4gICAgfSkoQXhlcyA9IGV4cG9ydHMuQXhlcyB8fCAoZXhwb3J0cy5BeGVzID0ge30pKTtcclxufSk7XHJcbmRlZmluZShcIklucHV0L1BvaW50ZXJcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJFbmdpbmVcIiwgXCJFdmVudHNcIiwgXCJVSUFjdG9yXCIsIFwiQWxnZWJyYVwiLCBcIkNsYXNzXCIsIFwiVXRpbC9VdGlsXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgRW5naW5lXzIsIEV2ZW50c185LCBVSUFjdG9yXzEsIEFsZ2VicmFfMjAsIENsYXNzXzYsIFV0aWwpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdHlwZSBvZiBwb2ludGVyIGZvciBhIFtbUG9pbnRlckV2ZW50XV0uXHJcbiAgICAgKi9cclxuICAgIHZhciBQb2ludGVyVHlwZTtcclxuICAgIChmdW5jdGlvbiAoUG9pbnRlclR5cGUpIHtcclxuICAgICAgICBQb2ludGVyVHlwZVtQb2ludGVyVHlwZVtcIlRvdWNoXCJdID0gMF0gPSBcIlRvdWNoXCI7XHJcbiAgICAgICAgUG9pbnRlclR5cGVbUG9pbnRlclR5cGVbXCJNb3VzZVwiXSA9IDFdID0gXCJNb3VzZVwiO1xyXG4gICAgICAgIFBvaW50ZXJUeXBlW1BvaW50ZXJUeXBlW1wiUGVuXCJdID0gMl0gPSBcIlBlblwiO1xyXG4gICAgICAgIFBvaW50ZXJUeXBlW1BvaW50ZXJUeXBlW1wiVW5rbm93blwiXSA9IDNdID0gXCJVbmtub3duXCI7XHJcbiAgICB9KShQb2ludGVyVHlwZSA9IGV4cG9ydHMuUG9pbnRlclR5cGUgfHwgKGV4cG9ydHMuUG9pbnRlclR5cGUgPSB7fSkpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbW91c2UgYnV0dG9uIGJlaW5nIHByZXNzZWQuXHJcbiAgICAgKi9cclxuICAgIHZhciBQb2ludGVyQnV0dG9uO1xyXG4gICAgKGZ1bmN0aW9uIChQb2ludGVyQnV0dG9uKSB7XHJcbiAgICAgICAgUG9pbnRlckJ1dHRvbltQb2ludGVyQnV0dG9uW1wiTGVmdFwiXSA9IDBdID0gXCJMZWZ0XCI7XHJcbiAgICAgICAgUG9pbnRlckJ1dHRvbltQb2ludGVyQnV0dG9uW1wiTWlkZGxlXCJdID0gMV0gPSBcIk1pZGRsZVwiO1xyXG4gICAgICAgIFBvaW50ZXJCdXR0b25bUG9pbnRlckJ1dHRvbltcIlJpZ2h0XCJdID0gMl0gPSBcIlJpZ2h0XCI7XHJcbiAgICAgICAgUG9pbnRlckJ1dHRvbltQb2ludGVyQnV0dG9uW1wiVW5rbm93blwiXSA9IDNdID0gXCJVbmtub3duXCI7XHJcbiAgICB9KShQb2ludGVyQnV0dG9uID0gZXhwb3J0cy5Qb2ludGVyQnV0dG9uIHx8IChleHBvcnRzLlBvaW50ZXJCdXR0b24gPSB7fSkpO1xyXG4gICAgdmFyIFdoZWVsRGVsdGFNb2RlO1xyXG4gICAgKGZ1bmN0aW9uIChXaGVlbERlbHRhTW9kZSkge1xyXG4gICAgICAgIFdoZWVsRGVsdGFNb2RlW1doZWVsRGVsdGFNb2RlW1wiUGl4ZWxcIl0gPSAwXSA9IFwiUGl4ZWxcIjtcclxuICAgICAgICBXaGVlbERlbHRhTW9kZVtXaGVlbERlbHRhTW9kZVtcIkxpbmVcIl0gPSAxXSA9IFwiTGluZVwiO1xyXG4gICAgICAgIFdoZWVsRGVsdGFNb2RlW1doZWVsRGVsdGFNb2RlW1wiUGFnZVwiXSA9IDJdID0gXCJQYWdlXCI7XHJcbiAgICB9KShXaGVlbERlbHRhTW9kZSA9IGV4cG9ydHMuV2hlZWxEZWx0YU1vZGUgfHwgKGV4cG9ydHMuV2hlZWxEZWx0YU1vZGUgPSB7fSkpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlcm1pbmVzIHRoZSBzY29wZSBvZiBoYW5kbGluZyBtb3VzZS90b3VjaCBldmVudHMuIFNlZSBbW1BvaW50ZXJzXV0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXHJcbiAgICAgKi9cclxuICAgIHZhciBQb2ludGVyU2NvcGU7XHJcbiAgICAoZnVuY3Rpb24gKFBvaW50ZXJTY29wZSkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEhhbmRsZSBldmVudHMgb24gdGhlIGBjYW52YXNgIGVsZW1lbnQgb25seS4gRXZlbnRzIG9yaWdpbmF0aW5nIG91dHNpZGUgdGhlXHJcbiAgICAgICAgICogYGNhbnZhc2Agd2lsbCBub3QgYmUgaGFuZGxlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQb2ludGVyU2NvcGVbUG9pbnRlclNjb3BlW1wiQ2FudmFzXCJdID0gMF0gPSBcIkNhbnZhc1wiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEhhbmRsZXMgZXZlbnRzIG9uIHRoZSBlbnRpcmUgZG9jdW1lbnQuIEFsbCBldmVudHMgd2lsbCBiZSBoYW5kbGVkIGJ5IEV4Y2FsaWJ1ci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQb2ludGVyU2NvcGVbUG9pbnRlclNjb3BlW1wiRG9jdW1lbnRcIl0gPSAxXSA9IFwiRG9jdW1lbnRcIjtcclxuICAgIH0pKFBvaW50ZXJTY29wZSA9IGV4cG9ydHMuUG9pbnRlclNjb3BlIHx8IChleHBvcnRzLlBvaW50ZXJTY29wZSA9IHt9KSk7XHJcbiAgICAvKipcclxuICAgICAqIEEgY29uc3RhbnQgdXNlZCB0byBub3JtYWxpemUgd2hlZWwgZXZlbnRzIGFjcm9zcyBkaWZmZXJlbnQgYnJvd3NlcnNcclxuICAgICAqXHJcbiAgICAgKiBUaGlzIG5vcm1hbGl6YXRpb24gZmFjdG9yIGlzIHB1bGxlZCBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0V2ZW50cy93aGVlbCNMaXN0ZW5pbmdfdG9fdGhpc19ldmVudF9hY3Jvc3NfYnJvd3NlclxyXG4gICAgICovXHJcbiAgICB2YXIgU2Nyb2xsV2hlZWxOb3JtYWxpemF0aW9uRmFjdG9yID0gLTEgLyA0MDtcclxuICAgIC8qKlxyXG4gICAgICogUG9pbnRlciBldmVudHNcclxuICAgICAqXHJcbiAgICAgKiBSZXByZXNlbnRzIGEgbW91c2UsIHRvdWNoLCBvciBzdHlsdXMgZXZlbnQuIFNlZSBbW1BvaW50ZXJzXV0gZm9yIG1vcmUgaW5mb3JtYXRpb24gb25cclxuICAgICAqIGhhbmRsaW5nIHBvaW50ZXIgaW5wdXQuXHJcbiAgICAgKlxyXG4gICAgICogRm9yIG1vdXNlLWJhc2VkIGV2ZW50cywgeW91IGNhbiBpbnNwZWN0IFtbUG9pbnRlckV2ZW50LmJ1dHRvbl1dIHRvIHNlZSB3aGF0IGJ1dHRvbiB3YXMgcHJlc3NlZC5cclxuICAgICAqL1xyXG4gICAgdmFyIFBvaW50ZXJFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFBvaW50ZXJFdmVudCwgX3N1cGVyKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gcGFnZVggICAgICAgIFRoZSBgeGAgY29vcmRpbmF0ZSBvZiB0aGUgZXZlbnQgKGluIGRvY3VtZW50IGNvb3JkaW5hdGVzKVxyXG4gICAgICAgICAqIEBwYXJhbSBwYWdlWSAgICAgICAgVGhlIGB5YCBjb29yZGluYXRlIG9mIHRoZSBldmVudCAoaW4gZG9jdW1lbnQgY29vcmRpbmF0ZXMpXHJcbiAgICAgICAgICogQHBhcmFtIHNjcmVlblggICAgICBUaGUgYHhgIGNvb3JkaW5hdGUgb2YgdGhlIGV2ZW50IChpbiBzY3JlZW4gY29vcmRpbmF0ZXMpXHJcbiAgICAgICAgICogQHBhcmFtIHNjcmVlblkgICAgICBUaGUgYHlgIGNvb3JkaW5hdGUgb2YgdGhlIGV2ZW50IChpbiBzY3JlZW4gY29vcmRpbmF0ZXMpXHJcbiAgICAgICAgICogQHBhcmFtIGluZGV4ICAgICAgICBUaGUgaW5kZXggb2YgdGhlIHBvaW50ZXIgKHplcm8tYmFzZWQpXHJcbiAgICAgICAgICogQHBhcmFtIHBvaW50ZXJUeXBlICBUaGUgdHlwZSBvZiBwb2ludGVyXHJcbiAgICAgICAgICogQHBhcmFtIGJ1dHRvbiAgICAgICBUaGUgYnV0dG9uIHByZXNzZWQgKGlmIFtbUG9pbnRlclR5cGUuTW91c2VdXSlcclxuICAgICAgICAgKiBAcGFyYW0gZXYgICAgICAgICAgIFRoZSByYXcgRE9NIGV2ZW50IGJlaW5nIGhhbmRsZWRcclxuICAgICAgICAgKiBAcGFyYW0gcG9zICAgICAgICAgIChXaWxsIGJlIGFkZGVkIHRvIHNpZ25hdHVyZSBpbiAwLjE0LjAgcmVsZWFzZSkgVGhlIHBvc2l0aW9uIG9mIHRoZSBldmVudCAoaW4gd29ybGQgY29vcmRpbmF0ZXMpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gUG9pbnRlckV2ZW50KHgsIHksIHBhZ2VYLCBwYWdlWSwgc2NyZWVuWCwgc2NyZWVuWSwgaW5kZXgsIHBvaW50ZXJUeXBlLCBidXR0b24sIGV2KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLnggPSB4O1xyXG4gICAgICAgICAgICBfdGhpcy55ID0geTtcclxuICAgICAgICAgICAgX3RoaXMucGFnZVggPSBwYWdlWDtcclxuICAgICAgICAgICAgX3RoaXMucGFnZVkgPSBwYWdlWTtcclxuICAgICAgICAgICAgX3RoaXMuc2NyZWVuWCA9IHNjcmVlblg7XHJcbiAgICAgICAgICAgIF90aGlzLnNjcmVlblkgPSBzY3JlZW5ZO1xyXG4gICAgICAgICAgICBfdGhpcy5pbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICBfdGhpcy5wb2ludGVyVHlwZSA9IHBvaW50ZXJUeXBlO1xyXG4gICAgICAgICAgICBfdGhpcy5idXR0b24gPSBidXR0b247XHJcbiAgICAgICAgICAgIF90aGlzLmV2ID0gZXY7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBvaW50ZXJFdmVudC5wcm90b3R5cGUsIFwicG9zXCIsIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFsZ2VicmFfMjAuVmVjdG9yKHRoaXMueCwgdGhpcy55KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIFBvaW50ZXJFdmVudDtcclxuICAgIH0oRXZlbnRzXzkuR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLlBvaW50ZXJFdmVudCA9IFBvaW50ZXJFdmVudDtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogV2hlZWwgRXZlbnRzXHJcbiAgICAgKlxyXG4gICAgICogUmVwcmVzZW50cyBhIG1vdXNlIHdoZWVsIGV2ZW50LiBTZWUgW1tQb2ludGVyc11dIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uXHJcbiAgICAgKiBoYW5kbGluZyBwb2ludCBpbnB1dC5cclxuICAgICAqL1xyXG4gICAgdmFyIFdoZWVsRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhXaGVlbEV2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB4ICAgICAgICAgICAgVGhlIGB4YCBjb29yZGluYXRlIG9mIHRoZSBldmVudCAoaW4gd29ybGQgY29vcmRpbmF0ZXMpXHJcbiAgICAgICAgICogQHBhcmFtIHkgICAgICAgICAgICBUaGUgYHlgIGNvb3JkaW5hdGUgb2YgdGhlIGV2ZW50IChpbiB3b3JsZCBjb29yZGluYXRlcylcclxuICAgICAgICAgKiBAcGFyYW0gcGFnZVggICAgICAgIFRoZSBgeGAgY29vcmRpbmF0ZSBvZiB0aGUgZXZlbnQgKGluIGRvY3VtZW50IGNvb3JkaW5hdGVzKVxyXG4gICAgICAgICAqIEBwYXJhbSBwYWdlWSAgICAgICAgVGhlIGB5YCBjb29yZGluYXRlIG9mIHRoZSBldmVudCAoaW4gZG9jdW1lbnQgY29vcmRpbmF0ZXMpXHJcbiAgICAgICAgICogQHBhcmFtIHNjcmVlblggICAgICBUaGUgYHhgIGNvb3JkaW5hdGUgb2YgdGhlIGV2ZW50IChpbiBzY3JlZW4gY29vcmRpbmF0ZXMpXHJcbiAgICAgICAgICogQHBhcmFtIHNjcmVlblkgICAgICBUaGUgYHlgIGNvb3JkaW5hdGUgb2YgdGhlIGV2ZW50IChpbiBzY3JlZW4gY29vcmRpbmF0ZXMpXHJcbiAgICAgICAgICogQHBhcmFtIGluZGV4ICAgICAgICBUaGUgaW5kZXggb2YgdGhlIHBvaW50ZXIgKHplcm8tYmFzZWQpXHJcbiAgICAgICAgICogQHBhcmFtIGRlbHRhWCAgICAgICBUaGUgdHlwZSBvZiBwb2ludGVyXHJcbiAgICAgICAgICogQHBhcmFtIGRlbHRhWSAgICAgICBUaGUgdHlwZSBvZiBwb2ludGVyXHJcbiAgICAgICAgICogQHBhcmFtIGRlbHRhWiAgICAgICBUaGUgdHlwZSBvZiBwb2ludGVyXHJcbiAgICAgICAgICogQHBhcmFtIGRlbHRhTW9kZSAgICBUaGUgdHlwZSBvZiBtb3ZlbWVudCBbW1doZWVsRGVsdGFNb2RlXV1cclxuICAgICAgICAgKiBAcGFyYW0gZXYgICAgICAgICAgIFRoZSByYXcgRE9NIGV2ZW50IGJlaW5nIGhhbmRsZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBXaGVlbEV2ZW50KHgsIHksIHBhZ2VYLCBwYWdlWSwgc2NyZWVuWCwgc2NyZWVuWSwgaW5kZXgsIGRlbHRhWCwgZGVsdGFZLCBkZWx0YVosIGRlbHRhTW9kZSwgZXYpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMueCA9IHg7XHJcbiAgICAgICAgICAgIF90aGlzLnkgPSB5O1xyXG4gICAgICAgICAgICBfdGhpcy5wYWdlWCA9IHBhZ2VYO1xyXG4gICAgICAgICAgICBfdGhpcy5wYWdlWSA9IHBhZ2VZO1xyXG4gICAgICAgICAgICBfdGhpcy5zY3JlZW5YID0gc2NyZWVuWDtcclxuICAgICAgICAgICAgX3RoaXMuc2NyZWVuWSA9IHNjcmVlblk7XHJcbiAgICAgICAgICAgIF90aGlzLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgICAgIF90aGlzLmRlbHRhWCA9IGRlbHRhWDtcclxuICAgICAgICAgICAgX3RoaXMuZGVsdGFZID0gZGVsdGFZO1xyXG4gICAgICAgICAgICBfdGhpcy5kZWx0YVogPSBkZWx0YVo7XHJcbiAgICAgICAgICAgIF90aGlzLmRlbHRhTW9kZSA9IGRlbHRhTW9kZTtcclxuICAgICAgICAgICAgX3RoaXMuZXYgPSBldjtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gV2hlZWxFdmVudDtcclxuICAgIH0oRXZlbnRzXzkuR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLldoZWVsRXZlbnQgPSBXaGVlbEV2ZW50O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVzIHBvaW50ZXIgZXZlbnRzIChtb3VzZSwgdG91Y2gsIHN0eWx1cywgZXRjLikgYW5kIG5vcm1hbGl6ZXMgdG9cclxuICAgICAqIFtXM0MgUG9pbnRlciBFdmVudHNdKGh0dHA6Ly93d3cudzMub3JnL1RSL3BvaW50ZXJldmVudHMvKS5cclxuICAgICAqXHJcbiAgICAgKiBbW2luY2x1ZGU6UG9pbnRlcnMubWRdXVxyXG4gICAgICovXHJcbiAgICB2YXIgUG9pbnRlcnMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhQb2ludGVycywgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBQb2ludGVycyhlbmdpbmUpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuX3BvaW50ZXJEb3duID0gW107XHJcbiAgICAgICAgICAgIF90aGlzLl9wb2ludGVyVXAgPSBbXTtcclxuICAgICAgICAgICAgX3RoaXMuX3BvaW50ZXJNb3ZlID0gW107XHJcbiAgICAgICAgICAgIF90aGlzLl9wb2ludGVyQ2FuY2VsID0gW107XHJcbiAgICAgICAgICAgIF90aGlzLl93aGVlbCA9IFtdO1xyXG4gICAgICAgICAgICBfdGhpcy5fcG9pbnRlcnMgPSBbXTtcclxuICAgICAgICAgICAgX3RoaXMuX2FjdGl2ZVBvaW50ZXJzID0gW107XHJcbiAgICAgICAgICAgIF90aGlzLl9lbmdpbmUgPSBlbmdpbmU7XHJcbiAgICAgICAgICAgIF90aGlzLl9wb2ludGVycy5wdXNoKG5ldyBQb2ludGVyKCkpO1xyXG4gICAgICAgICAgICBfdGhpcy5fYWN0aXZlUG9pbnRlcnMgPSBbLTFdO1xyXG4gICAgICAgICAgICBfdGhpcy5wcmltYXJ5ID0gX3RoaXMuX3BvaW50ZXJzWzBdO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFBvaW50ZXJzLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbml0aWFsaXplcyBwb2ludGVyIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBvaW50ZXJzLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQgfHwgdGhpcy5fZW5naW5lLmNhbnZhcztcclxuICAgICAgICAgICAgLy8gVG91Y2ggRXZlbnRzXHJcbiAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5faGFuZGxlVG91Y2hFdmVudCgnZG93bicsIHRoaXMuX3BvaW50ZXJEb3duKSk7XHJcbiAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX2hhbmRsZVRvdWNoRXZlbnQoJ3VwJywgdGhpcy5fcG9pbnRlclVwKSk7XHJcbiAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9oYW5kbGVUb3VjaEV2ZW50KCdtb3ZlJywgdGhpcy5fcG9pbnRlck1vdmUpKTtcclxuICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcy5faGFuZGxlVG91Y2hFdmVudCgnY2FuY2VsJywgdGhpcy5fcG9pbnRlckNhbmNlbCkpO1xyXG4gICAgICAgICAgICAvLyBXM0MgUG9pbnRlciBFdmVudHNcclxuICAgICAgICAgICAgLy8gQ3VycmVudDogSUUxMSwgSUUxMFxyXG4gICAgICAgICAgICBpZiAod2luZG93LlBvaW50ZXJFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgLy8gSUUxMVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fZW5naW5lLmNhbnZhcy5zdHlsZS50b3VjaEFjdGlvbiA9ICdub25lJztcclxuICAgICAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIHRoaXMuX2hhbmRsZVBvaW50ZXJFdmVudCgnZG93bicsIHRoaXMuX3BvaW50ZXJEb3duKSk7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgdGhpcy5faGFuZGxlUG9pbnRlckV2ZW50KCd1cCcsIHRoaXMuX3BvaW50ZXJVcCkpO1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgdGhpcy5faGFuZGxlUG9pbnRlckV2ZW50KCdtb3ZlJywgdGhpcy5fcG9pbnRlck1vdmUpKTtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyY2FuY2VsJywgdGhpcy5faGFuZGxlUG9pbnRlckV2ZW50KCdjYW5jZWwnLCB0aGlzLl9wb2ludGVyTW92ZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHdpbmRvdy5NU1BvaW50ZXJFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgLy8gSUUxMFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fZW5naW5lLmNhbnZhcy5zdHlsZS5tc1RvdWNoQWN0aW9uID0gJ25vbmUnO1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ01TUG9pbnRlckRvd24nLCB0aGlzLl9oYW5kbGVQb2ludGVyRXZlbnQoJ2Rvd24nLCB0aGlzLl9wb2ludGVyRG93bikpO1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ01TUG9pbnRlclVwJywgdGhpcy5faGFuZGxlUG9pbnRlckV2ZW50KCd1cCcsIHRoaXMuX3BvaW50ZXJVcCkpO1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ01TUG9pbnRlck1vdmUnLCB0aGlzLl9oYW5kbGVQb2ludGVyRXZlbnQoJ21vdmUnLCB0aGlzLl9wb2ludGVyTW92ZSkpO1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ01TUG9pbnRlckNhbmNlbCcsIHRoaXMuX2hhbmRsZVBvaW50ZXJFdmVudCgnY2FuY2VsJywgdGhpcy5fcG9pbnRlck1vdmUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIE1vdXNlIEV2ZW50c1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX2hhbmRsZU1vdXNlRXZlbnQoJ2Rvd24nLCB0aGlzLl9wb2ludGVyRG93bikpO1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9oYW5kbGVNb3VzZUV2ZW50KCd1cCcsIHRoaXMuX3BvaW50ZXJVcCkpO1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX2hhbmRsZU1vdXNlRXZlbnQoJ21vdmUnLCB0aGlzLl9wb2ludGVyTW92ZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE1ETiBNb3VzZVdoZWVsRXZlbnRcclxuICAgICAgICAgICAgaWYgKCdvbndoZWVsJyBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gTW9kZXJuIEJyb3dzZXJzXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLl9oYW5kbGVXaGVlbEV2ZW50KCd3aGVlbCcsIHRoaXMuX3doZWVsKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZG9jdW1lbnQub25tb3VzZXdoZWVsICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlYmtpdCBhbmQgSUVcclxuICAgICAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgdGhpcy5faGFuZGxlV2hlZWxFdmVudCgnd2hlZWwnLCB0aGlzLl93aGVlbCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gUmVtYWluaW5nIGJyb3dzZXIgYW5kIG9sZGVyIEZpcmVmb3hcclxuICAgICAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdNb3pNb3VzZVBpeGVsU2Nyb2xsJywgdGhpcy5faGFuZGxlV2hlZWxFdmVudCgnd2hlZWwnLCB0aGlzLl93aGVlbCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQb2ludGVycy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9wb2ludGVyVXAubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fcG9pbnRlckRvd24ubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fcG9pbnRlck1vdmUubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fcG9pbnRlckNhbmNlbC5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl93aGVlbC5sZW5ndGggPSAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2FmZWx5IGdldHMgYSBQb2ludGVyIGF0IGEgc3BlY2lmaWMgaW5kZXggYW5kIGluaXRpYWxpemVzIG9uZSBpZiBpdCBkb2Vzbid0IHlldCBleGlzdFxyXG4gICAgICAgICAqIEBwYXJhbSBpbmRleCAgVGhlIHBvaW50ZXIgaW5kZXggdG8gcmV0cmlldmVcclxuICAgICAgICAgKi9cclxuICAgICAgICBQb2ludGVycy5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID49IHRoaXMuX3BvaW50ZXJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIHRoZXJlIGlzIGEgcG9pbnRlciB0byByZXRyaWV2ZVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX3BvaW50ZXJzLmxlbmd0aCAtIDEsIG1heCA9IGluZGV4OyBpIDwgbWF4OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb2ludGVycy5wdXNoKG5ldyBQb2ludGVyKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVBvaW50ZXJzLnB1c2goLTEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wb2ludGVyc1tpbmRleF07XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgbnVtYmVyIG9mIHBvaW50ZXJzIGJlaW5nIHdhdGNoZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBQb2ludGVycy5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wb2ludGVycy5sZW5ndGg7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcm9wb2dhdGVzIGV2ZW50cyB0byBhY3RvciBpZiBuZWNlc3NhcnlcclxuICAgICAgICAgKi9cclxuICAgICAgICBQb2ludGVycy5wcm90b3R5cGUucHJvcG9nYXRlID0gZnVuY3Rpb24gKGFjdG9yKSB7XHJcbiAgICAgICAgICAgIHZhciBpc1VJQWN0b3IgPSBhY3RvciBpbnN0YW5jZW9mIFVJQWN0b3JfMS5VSUFjdG9yO1xyXG4gICAgICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3BvaW50ZXJVcC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWN0b3IuY29udGFpbnModGhpcy5fcG9pbnRlclVwW2ldLngsIHRoaXMuX3BvaW50ZXJVcFtpXS55LCAhaXNVSUFjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdG9yLmV2ZW50RGlzcGF0Y2hlci5lbWl0KCdwb2ludGVydXAnLCB0aGlzLl9wb2ludGVyVXBbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgICAgICBsZW4gPSB0aGlzLl9wb2ludGVyRG93bi5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWN0b3IuY29udGFpbnModGhpcy5fcG9pbnRlckRvd25baV0ueCwgdGhpcy5fcG9pbnRlckRvd25baV0ueSwgIWlzVUlBY3RvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBhY3Rvci5ldmVudERpc3BhdGNoZXIuZW1pdCgncG9pbnRlcmRvd24nLCB0aGlzLl9wb2ludGVyRG93bltpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGFjdG9yLmNhcHR1cmVQb2ludGVyLmNhcHR1cmVNb3ZlRXZlbnRzKSB7XHJcbiAgICAgICAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgICAgICAgIGxlbiA9IHRoaXMuX3BvaW50ZXJNb3ZlLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdG9yLmNvbnRhaW5zKHRoaXMuX3BvaW50ZXJNb3ZlW2ldLngsIHRoaXMuX3BvaW50ZXJNb3ZlW2ldLnksICFpc1VJQWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdG9yLmV2ZW50RGlzcGF0Y2hlci5lbWl0KCdwb2ludGVybW92ZScsIHRoaXMuX3BvaW50ZXJNb3ZlW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgICAgIGxlbiA9IHRoaXMuX3BvaW50ZXJDYW5jZWwubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFjdG9yLmNvbnRhaW5zKHRoaXMuX3BvaW50ZXJDYW5jZWxbaV0ueCwgdGhpcy5fcG9pbnRlckNhbmNlbFtpXS55LCAhaXNVSUFjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdG9yLmV2ZW50RGlzcGF0Y2hlci5lbWl0KCdwb2ludGVyY2FuY2VsJywgdGhpcy5fcG9pbnRlckNhbmNlbFtpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgICAgIGxlbiA9IHRoaXMuX3doZWVsLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChhY3Rvci5jb250YWlucyh0aGlzLl93aGVlbFtpXS54LCB0aGlzLl93aGVlbFtpXS55LCAhaXNVSUFjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdG9yLmV2ZW50RGlzcGF0Y2hlci5lbWl0KCdwb2ludGVyd2hlZWwnLCB0aGlzLl93aGVlbFtpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFBvaW50ZXJzLnByb3RvdHlwZS5faGFuZGxlTW91c2VFdmVudCA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50QXJyKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHggPSBlLnBhZ2VYIC0gVXRpbC5nZXRQb3NpdGlvbihfdGhpcy5fZW5naW5lLmNhbnZhcykueDtcclxuICAgICAgICAgICAgICAgIHZhciB5ID0gZS5wYWdlWSAtIFV0aWwuZ2V0UG9zaXRpb24oX3RoaXMuX2VuZ2luZS5jYW52YXMpLnk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWRQb2ludCA9IF90aGlzLl9lbmdpbmUuc2NyZWVuVG9Xb3JsZENvb3JkaW5hdGVzKG5ldyBBbGdlYnJhXzIwLlZlY3Rvcih4LCB5KSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGUgPSBuZXcgUG9pbnRlckV2ZW50KHRyYW5zZm9ybWVkUG9pbnQueCwgdHJhbnNmb3JtZWRQb2ludC55LCBlLnBhZ2VYLCBlLnBhZ2VZLCB4LCB5LCAwLCBQb2ludGVyVHlwZS5Nb3VzZSwgZS5idXR0b24sIGUpO1xyXG4gICAgICAgICAgICAgICAgZXZlbnRBcnIucHVzaChwZSk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5hdCgwKS5ldmVudERpc3BhdGNoZXIuZW1pdChldmVudE5hbWUsIHBlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFBvaW50ZXJzLnByb3RvdHlwZS5faGFuZGxlVG91Y2hFdmVudCA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50QXJyKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGUuY2hhbmdlZFRvdWNoZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBfdGhpcy5fcG9pbnRlcnMubGVuZ3RoID4gMSA/IF90aGlzLl9nZXRQb2ludGVySW5kZXgoZS5jaGFuZ2VkVG91Y2hlc1tpXS5pZGVudGlmaWVyKSA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBlLmNoYW5nZWRUb3VjaGVzW2ldLnBhZ2VYIC0gVXRpbC5nZXRQb3NpdGlvbihfdGhpcy5fZW5naW5lLmNhbnZhcykueDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IGUuY2hhbmdlZFRvdWNoZXNbaV0ucGFnZVkgLSBVdGlsLmdldFBvc2l0aW9uKF90aGlzLl9lbmdpbmUuY2FudmFzKS55O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZFBvaW50ID0gX3RoaXMuX2VuZ2luZS5zY3JlZW5Ub1dvcmxkQ29vcmRpbmF0ZXMobmV3IEFsZ2VicmFfMjAuVmVjdG9yKHgsIHkpKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGUgPSBuZXcgUG9pbnRlckV2ZW50KHRyYW5zZm9ybWVkUG9pbnQueCwgdHJhbnNmb3JtZWRQb2ludC55LCBlLmNoYW5nZWRUb3VjaGVzW2ldLnBhZ2VYLCBlLmNoYW5nZWRUb3VjaGVzW2ldLnBhZ2VZLCB4LCB5LCBpbmRleCwgUG9pbnRlclR5cGUuVG91Y2gsIFBvaW50ZXJCdXR0b24uVW5rbm93biwgZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRBcnIucHVzaChwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXQoaW5kZXgpLmV2ZW50RGlzcGF0Y2hlci5lbWl0KGV2ZW50TmFtZSwgcGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgd2l0aCBtdWx0aS1wb2ludGVyXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9wb2ludGVycy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09ICd1cCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBwb2ludGVyIElEIGZyb20gcG9vbCB3aGVuIHBvaW50ZXIgaXMgbGlmdGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYWN0aXZlUG9pbnRlcnNbaW5kZXhdID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnROYW1lID09PSAnZG93bicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldCBwb2ludGVyIElEIHRvIGdpdmVuIGluZGV4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYWN0aXZlUG9pbnRlcnNbaW5kZXhdID0gZS5jaGFuZ2VkVG91Y2hlc1tpXS5pZGVudGlmaWVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUG9pbnRlcnMucHJvdG90eXBlLl9oYW5kbGVQb2ludGVyRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudEFycikge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgaW5kZXggZm9yIHRoaXMgcG9pbnRlciBJRCBpZiBtdWx0aS1wb2ludGVyIGlzIGFza2VkIGZvclxyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gX3RoaXMuX3BvaW50ZXJzLmxlbmd0aCA+IDEgPyBfdGhpcy5fZ2V0UG9pbnRlckluZGV4KGUucG9pbnRlcklkKSA6IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHggPSBlLnBhZ2VYIC0gVXRpbC5nZXRQb3NpdGlvbihfdGhpcy5fZW5naW5lLmNhbnZhcykueDtcclxuICAgICAgICAgICAgICAgIHZhciB5ID0gZS5wYWdlWSAtIFV0aWwuZ2V0UG9zaXRpb24oX3RoaXMuX2VuZ2luZS5jYW52YXMpLnk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWRQb2ludCA9IF90aGlzLl9lbmdpbmUuc2NyZWVuVG9Xb3JsZENvb3JkaW5hdGVzKG5ldyBBbGdlYnJhXzIwLlZlY3Rvcih4LCB5KSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGUgPSBuZXcgUG9pbnRlckV2ZW50KHRyYW5zZm9ybWVkUG9pbnQueCwgdHJhbnNmb3JtZWRQb2ludC55LCBlLnBhZ2VYLCBlLnBhZ2VZLCB4LCB5LCBpbmRleCwgX3RoaXMuX3N0cmluZ1RvUG9pbnRlclR5cGUoZS5wb2ludGVyVHlwZSksIGUuYnV0dG9uLCBlKTtcclxuICAgICAgICAgICAgICAgIGV2ZW50QXJyLnB1c2gocGUpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuYXQoaW5kZXgpLmV2ZW50RGlzcGF0Y2hlci5lbWl0KGV2ZW50TmFtZSwgcGUpO1xyXG4gICAgICAgICAgICAgICAgLy8gb25seSB3aXRoIG11bHRpLXBvaW50ZXJcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fcG9pbnRlcnMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09ICd1cCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHBvaW50ZXIgSUQgZnJvbSBwb29sIHdoZW4gcG9pbnRlciBpcyBsaWZ0ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FjdGl2ZVBvaW50ZXJzW2luZGV4XSA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChldmVudE5hbWUgPT09ICdkb3duJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgcG9pbnRlciBJRCB0byBnaXZlbiBpbmRleFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYWN0aXZlUG9pbnRlcnNbaW5kZXhdID0gZS5wb2ludGVySWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUG9pbnRlcnMucHJvdG90eXBlLl9oYW5kbGVXaGVlbEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgZXZlbnRBcnIpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTaG91bGQgd2UgcHJldmVudCBwYWdlIHNjcm9sbCBiZWNhdXNlIG9mIHRoaXMgZXZlbnRcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fZW5naW5lLnBhZ2VTY3JvbGxQcmV2ZW50aW9uTW9kZSA9PT0gRW5naW5lXzIuU2Nyb2xsUHJldmVudGlvbk1vZGUuQWxsIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKF90aGlzLl9lbmdpbmUucGFnZVNjcm9sbFByZXZlbnRpb25Nb2RlID09PSBFbmdpbmVfMi5TY3JvbGxQcmV2ZW50aW9uTW9kZS5DYW52YXMgJiYgZS50YXJnZXQgPT09IF90aGlzLl9lbmdpbmUuY2FudmFzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB4ID0gZS5wYWdlWCAtIFV0aWwuZ2V0UG9zaXRpb24oX3RoaXMuX2VuZ2luZS5jYW52YXMpLng7XHJcbiAgICAgICAgICAgICAgICB2YXIgeSA9IGUucGFnZVkgLSBVdGlsLmdldFBvc2l0aW9uKF90aGlzLl9lbmdpbmUuY2FudmFzKS55O1xyXG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkUG9pbnQgPSBfdGhpcy5fZW5naW5lLnNjcmVlblRvV29ybGRDb29yZGluYXRlcyhuZXcgQWxnZWJyYV8yMC5WZWN0b3IoeCwgeSkpO1xyXG4gICAgICAgICAgICAgICAgLy8gZGVsdGFYLCBkZWx0YVksIGFuZCBkZWx0YVogYXJlIHRoZSBzdGFuZGFyZCBtb2Rlcm4gcHJvcGVydGllc1xyXG4gICAgICAgICAgICAgICAgLy8gd2hlZWxEZWx0YVgsIHdoZWVsRGVsdGFZLCBhcmUgbGVnYWN5IHByb3BlcnRpZXMgaW4gd2Via2l0IGJyb3dzZXJzIGFuZCBvbGRlciBJRVxyXG4gICAgICAgICAgICAgICAgLy8gZS5kZXRhaWwgaXMgb25seSB1c2VkIGluIG9wZXJhXHJcbiAgICAgICAgICAgICAgICB2YXIgZGVsdGFYID0gZS5kZWx0YVggfHxcclxuICAgICAgICAgICAgICAgICAgICAoZS53aGVlbERlbHRhWCAqIFNjcm9sbFdoZWVsTm9ybWFsaXphdGlvbkZhY3RvcikgfHxcclxuICAgICAgICAgICAgICAgICAgICAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRlbHRhWSA9IGUuZGVsdGFZIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKGUud2hlZWxEZWx0YVkgKiBTY3JvbGxXaGVlbE5vcm1hbGl6YXRpb25GYWN0b3IpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKGUud2hlZWxEZWx0YSAqIFNjcm9sbFdoZWVsTm9ybWFsaXphdGlvbkZhY3RvcikgfHxcclxuICAgICAgICAgICAgICAgICAgICBlLmRldGFpbCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIDA7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVsdGFaID0gZS5kZWx0YVogfHwgMDtcclxuICAgICAgICAgICAgICAgIHZhciBkZWx0YU1vZGUgPSBXaGVlbERlbHRhTW9kZS5QaXhlbDtcclxuICAgICAgICAgICAgICAgIGlmIChlLmRlbHRhTW9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmRlbHRhTW9kZSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWx0YU1vZGUgPSBXaGVlbERlbHRhTW9kZS5MaW5lO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlLmRlbHRhTW9kZSA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWx0YU1vZGUgPSBXaGVlbERlbHRhTW9kZS5QYWdlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB3ZSA9IG5ldyBXaGVlbEV2ZW50KHRyYW5zZm9ybWVkUG9pbnQueCwgdHJhbnNmb3JtZWRQb2ludC55LCBlLnBhZ2VYLCBlLnBhZ2VZLCB4LCB5LCAwLCBkZWx0YVgsIGRlbHRhWSwgZGVsdGFaLCBkZWx0YU1vZGUsIGUpO1xyXG4gICAgICAgICAgICAgICAgZXZlbnRBcnIucHVzaCh3ZSk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5hdCgwKS5ldmVudERpc3BhdGNoZXIuZW1pdChldmVudE5hbWUsIHdlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGluZGV4IG9mIHRoZSBwb2ludGVyIHNwZWNpZmllZCBmb3IgdGhlIGdpdmVuIHBvaW50ZXIgSUQgb3IgZmluZHMgdGhlIG5leHQgZW1wdHkgcG9pbnRlciBzbG90IGF2YWlsYWJsZS5cclxuICAgICAgICAgKiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2UgSUUxMC8xMSB1c2VzIGluY3JlbWVudGluZyBwb2ludGVyIElEcyBzbyB3ZSBuZWVkIHRvIHN0b3JlIGEgbWFwcGluZyBvZiBJRCA9PiBpZHhcclxuICAgICAgICAgKi9cclxuICAgICAgICBQb2ludGVycy5wcm90b3R5cGUuX2dldFBvaW50ZXJJbmRleCA9IGZ1bmN0aW9uIChwb2ludGVySWQpIHtcclxuICAgICAgICAgICAgdmFyIGlkeDtcclxuICAgICAgICAgICAgaWYgKChpZHggPSB0aGlzLl9hY3RpdmVQb2ludGVycy5pbmRleE9mKHBvaW50ZXJJZCkpID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpZHg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9hY3RpdmVQb2ludGVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZVBvaW50ZXJzW2ldID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGlnbm9yZSBwb2ludGVyIGJlY2F1c2UgZ2FtZSBpc24ndCB3YXRjaGluZ1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQb2ludGVycy5wcm90b3R5cGUuX3N0cmluZ1RvUG9pbnRlclR5cGUgPSBmdW5jdGlvbiAocykge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHMpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3RvdWNoJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUG9pbnRlclR5cGUuVG91Y2g7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdtb3VzZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBvaW50ZXJUeXBlLk1vdXNlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAncGVuJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUG9pbnRlclR5cGUuUGVuO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUG9pbnRlclR5cGUuVW5rbm93bjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFBvaW50ZXJzO1xyXG4gICAgfShDbGFzc182LkNsYXNzKSk7XHJcbiAgICBleHBvcnRzLlBvaW50ZXJzID0gUG9pbnRlcnM7XHJcbiAgICAvKipcclxuICAgICAqIENhcHR1cmVzIGFuZCBkaXNwYXRjaGVzIFBvaW50ZXJFdmVudHNcclxuICAgICAqL1xyXG4gICAgdmFyIFBvaW50ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhQb2ludGVyLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFBvaW50ZXIoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgbGFzdCBwb3NpdGlvbiBvbiB0aGUgZG9jdW1lbnQgdGhpcyBwb2ludGVyIHdhcyBhdC4gQ2FuIGJlIGBudWxsYCBpZiBwb2ludGVyIHdhcyBuZXZlciBhY3RpdmUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5sYXN0UGFnZVBvcyA9IG51bGw7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgbGFzdCBwb3NpdGlvbiBvbiB0aGUgc2NyZWVuIHRoaXMgcG9pbnRlciB3YXMgYXQuIENhbiBiZSBgbnVsbGAgaWYgcG9pbnRlciB3YXMgbmV2ZXIgYWN0aXZlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMubGFzdFNjcmVlblBvcyA9IG51bGw7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgbGFzdCBwb3NpdGlvbiBpbiB0aGUgZ2FtZSB3b3JsZCBjb29yZGluYXRlcyB0aGlzIHBvaW50ZXIgd2FzIGF0LiBDYW4gYmUgYG51bGxgIGlmIHBvaW50ZXIgd2FzIG5ldmVyIGFjdGl2ZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmxhc3RXb3JsZFBvcyA9IG51bGw7XHJcbiAgICAgICAgICAgIF90aGlzLm9uKCdtb3ZlJywgX3RoaXMuX29uUG9pbnRlck1vdmUpO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFBvaW50ZXIucHJvdG90eXBlLl9vblBvaW50ZXJNb3ZlID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdFdvcmxkUG9zID0gbmV3IEFsZ2VicmFfMjAuVmVjdG9yKGV2LngsIGV2LnkpO1xyXG4gICAgICAgICAgICB0aGlzLmxhc3RQYWdlUG9zID0gbmV3IEFsZ2VicmFfMjAuVmVjdG9yKGV2LnBhZ2VYLCBldi5wYWdlWSk7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdFNjcmVlblBvcyA9IG5ldyBBbGdlYnJhXzIwLlZlY3Rvcihldi5zY3JlZW5YLCBldi5zY3JlZW5ZKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBQb2ludGVyO1xyXG4gICAgfShDbGFzc182LkNsYXNzKSk7XHJcbiAgICBleHBvcnRzLlBvaW50ZXIgPSBQb2ludGVyO1xyXG59KTtcclxuZGVmaW5lKFwiSW5wdXQvS2V5Ym9hcmRcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJDbGFzc1wiLCBcIkV2ZW50c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIENsYXNzXzcsIEV2ZW50c18xMCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEVudW0gcmVwcmVzZW50aW5nIGlucHV0IGtleSBjb2Rlc1xyXG4gICAgICovXHJcbiAgICB2YXIgS2V5cztcclxuICAgIChmdW5jdGlvbiAoS2V5cykge1xyXG4gICAgICAgIEtleXNbS2V5c1tcIk51bTFcIl0gPSA5N10gPSBcIk51bTFcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJOdW0yXCJdID0gOThdID0gXCJOdW0yXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiTnVtM1wiXSA9IDk5XSA9IFwiTnVtM1wiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIk51bTRcIl0gPSAxMDBdID0gXCJOdW00XCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiTnVtNVwiXSA9IDEwMV0gPSBcIk51bTVcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJOdW02XCJdID0gMTAyXSA9IFwiTnVtNlwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIk51bTdcIl0gPSAxMDNdID0gXCJOdW03XCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiTnVtOFwiXSA9IDEwNF0gPSBcIk51bThcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJOdW05XCJdID0gMTA1XSA9IFwiTnVtOVwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIk51bTBcIl0gPSA5Nl0gPSBcIk51bTBcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJOdW1sb2NrXCJdID0gMTQ0XSA9IFwiTnVtbG9ja1wiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIlNlbWljb2xvblwiXSA9IDE4Nl0gPSBcIlNlbWljb2xvblwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIkFcIl0gPSA2NV0gPSBcIkFcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJCXCJdID0gNjZdID0gXCJCXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiQ1wiXSA9IDY3XSA9IFwiQ1wiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIkRcIl0gPSA2OF0gPSBcIkRcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJFXCJdID0gNjldID0gXCJFXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiRlwiXSA9IDcwXSA9IFwiRlwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIkdcIl0gPSA3MV0gPSBcIkdcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJIXCJdID0gNzJdID0gXCJIXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiSVwiXSA9IDczXSA9IFwiSVwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIkpcIl0gPSA3NF0gPSBcIkpcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJLXCJdID0gNzVdID0gXCJLXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiTFwiXSA9IDc2XSA9IFwiTFwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIk1cIl0gPSA3N10gPSBcIk1cIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJOXCJdID0gNzhdID0gXCJOXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiT1wiXSA9IDc5XSA9IFwiT1wiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIlBcIl0gPSA4MF0gPSBcIlBcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJRXCJdID0gODFdID0gXCJRXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiUlwiXSA9IDgyXSA9IFwiUlwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIlNcIl0gPSA4M10gPSBcIlNcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJUXCJdID0gODRdID0gXCJUXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiVVwiXSA9IDg1XSA9IFwiVVwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIlZcIl0gPSA4Nl0gPSBcIlZcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJXXCJdID0gODddID0gXCJXXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiWFwiXSA9IDg4XSA9IFwiWFwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIllcIl0gPSA4OV0gPSBcIllcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJaXCJdID0gOTBdID0gXCJaXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiU2hpZnRcIl0gPSAxNl0gPSBcIlNoaWZ0XCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiQWx0XCJdID0gMThdID0gXCJBbHRcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJVcFwiXSA9IDM4XSA9IFwiVXBcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJEb3duXCJdID0gNDBdID0gXCJEb3duXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiTGVmdFwiXSA9IDM3XSA9IFwiTGVmdFwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIlJpZ2h0XCJdID0gMzldID0gXCJSaWdodFwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIlNwYWNlXCJdID0gMzJdID0gXCJTcGFjZVwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIkVzY1wiXSA9IDI3XSA9IFwiRXNjXCI7XHJcbiAgICB9KShLZXlzID0gZXhwb3J0cy5LZXlzIHx8IChleHBvcnRzLktleXMgPSB7fSkpO1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFdmVudCB0aHJvd24gb24gYSBnYW1lIG9iamVjdCBmb3IgYSBrZXkgZXZlbnRcclxuICAgICAqL1xyXG4gICAgdmFyIEtleUV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoS2V5RXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIGtleSAgVGhlIGtleSByZXNwb25zaWJsZSBmb3IgdGhyb3dpbmcgdGhlIGV2ZW50XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gS2V5RXZlbnQoa2V5KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLmtleSA9IGtleTtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gS2V5RXZlbnQ7XHJcbiAgICB9KEV2ZW50c18xMC5HYW1lRXZlbnQpKTtcclxuICAgIGV4cG9ydHMuS2V5RXZlbnQgPSBLZXlFdmVudDtcclxuICAgIC8qKlxyXG4gICAgICogUHJvdmlkZXMga2V5Ym9hcmQgc3VwcG9ydCBmb3IgRXhjYWxpYnVyLlxyXG4gICAgICpcclxuICAgICAqIFtbaW5jbHVkZTpLZXlib2FyZC5tZF1dXHJcbiAgICAgKi9cclxuICAgIHZhciBLZXlib2FyZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKEtleWJvYXJkLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIEtleWJvYXJkKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5fa2V5cyA9IFtdO1xyXG4gICAgICAgICAgICBfdGhpcy5fa2V5c1VwID0gW107XHJcbiAgICAgICAgICAgIF90aGlzLl9rZXlzRG93biA9IFtdO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEtleWJvYXJkLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbml0aWFsaXplIEtleWJvYXJkIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEtleWJvYXJkLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGdsb2JhbCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICBnbG9iYWwgPSBnbG9iYWwgfHwgd2luZG93O1xyXG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9rZXlzLmxlbmd0aCA9IDA7IC8vIGVtcHRpZXMgYXJyYXkgZWZmaWNpZW50bHlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIGtleSB1cCBpcyBvbiB3aW5kb3cgYmVjYXVzZSBjYW52YXMgY2Fubm90IGhhdmUgZm9jdXNcclxuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29kZSA9IF90aGlzLl9ub3JtYWxpemVLZXlDb2RlKGV2LmtleUNvZGUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IF90aGlzLl9rZXlzLmluZGV4T2YoY29kZSk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fa2V5cy5zcGxpY2Uoa2V5LCAxKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9rZXlzVXAucHVzaChjb2RlKTtcclxuICAgICAgICAgICAgICAgIHZhciBrZXlFdmVudCA9IG5ldyBLZXlFdmVudChjb2RlKTtcclxuICAgICAgICAgICAgICAgIC8vIGFsaWFzIHRoZSBvbGQgYXBpLCB3ZSBtYXkgd2FudCB0byBkZXByZWNhdGUgdGhpcyBpbiB0aGUgZnV0dXJlXHJcbiAgICAgICAgICAgICAgICBfdGhpcy5ldmVudERpc3BhdGNoZXIuZW1pdCgndXAnLCBrZXlFdmVudCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5ldmVudERpc3BhdGNoZXIuZW1pdCgncmVsZWFzZScsIGtleUV2ZW50KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIGtleSBkb3duIGlzIG9uIHdpbmRvdyBiZWNhdXNlIGNhbnZhcyBjYW5ub3QgaGF2ZSBmb2N1c1xyXG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvZGUgPSBfdGhpcy5fbm9ybWFsaXplS2V5Q29kZShldi5rZXlDb2RlKTtcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fa2V5cy5pbmRleE9mKGNvZGUpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9rZXlzLnB1c2goY29kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2tleXNEb3duLnB1c2goY29kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleUV2ZW50ID0gbmV3IEtleUV2ZW50KGNvZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50RGlzcGF0Y2hlci5lbWl0KCdkb3duJywga2V5RXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50RGlzcGF0Y2hlci5lbWl0KCdwcmVzcycsIGtleUV2ZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBLZXlib2FyZC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBSZXNldCBrZXlzRG93biBhbmQga2V5c1VwIGFmdGVyIHVwZGF0ZSBpcyBjb21wbGV0ZVxyXG4gICAgICAgICAgICB0aGlzLl9rZXlzRG93bi5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9rZXlzVXAubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgLy8gRW1pdCBzeW50aGV0aWMgXCJob2xkXCIgZXZlbnRcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9rZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5lbWl0KCdob2xkJywgbmV3IEtleUV2ZW50KHRoaXMuX2tleXNbaV0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBsaXN0IG9mIGtleXMgYmVpbmcgcHJlc3NlZCBkb3duXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgS2V5Ym9hcmQucHJvdG90eXBlLmdldEtleXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9rZXlzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVzdHMgaWYgYSBjZXJ0YWluIGtleSB3YXMganVzdCBwcmVzc2VkIHRoaXMgZnJhbWUuIFRoaXMgaXMgY2xlYXJlZCBhdCB0aGUgZW5kIG9mIHRoZSB1cGRhdGUgZnJhbWUuXHJcbiAgICAgICAgICogQHBhcmFtIGtleSBUZXN0IHdoZXRoZXIgYSBrZXkgd2FzIGp1c3QgcHJlc3NlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEtleWJvYXJkLnByb3RvdHlwZS53YXNQcmVzc2VkID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fa2V5c0Rvd24uaW5kZXhPZihrZXkpID4gLTE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZXN0cyBpZiBhIGNlcnRhaW4ga2V5IGlzIGhlbGQgZG93bi4gVGhpcyBpcyBwZXJzaXN0ZWQgYmV0d2VlbiBmcmFtZXMuXHJcbiAgICAgICAgICogQHBhcmFtIGtleSAgVGVzdCB3aGV0aGVyIGEga2V5IGlzIGhlbGQgZG93blxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEtleWJvYXJkLnByb3RvdHlwZS5pc0hlbGQgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9rZXlzLmluZGV4T2Yoa2V5KSA+IC0xO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVzdHMgaWYgYSBjZXJ0YWluIGtleSB3YXMganVzdCByZWxlYXNlZCB0aGlzIGZyYW1lLiBUaGlzIGlzIGNsZWFyZWQgYXQgdGhlIGVuZCBvZiB0aGUgdXBkYXRlIGZyYW1lLlxyXG4gICAgICAgICAqIEBwYXJhbSBrZXkgIFRlc3Qgd2hldGhlciBhIGtleSB3YXMganVzdCByZWxlYXNlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEtleWJvYXJkLnByb3RvdHlwZS53YXNSZWxlYXNlZCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2tleXNVcC5pbmRleE9mKGtleSkgPiAtMTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE5vcm1hbGl6ZXMgc29tZSBicm93c2VyIGV2ZW50IGtleSBjb2RlcyB0byBtYXAgdG8gc3RhbmRhcmQgRXhjYWxpYnVyIGtleSBjb2Rlc1xyXG4gICAgICAgICAqIEBwYXJhbSBjb2RlIEV2ZW50IGtleUNvZGVcclxuICAgICAgICAgKiBAc2VlIGh0dHA6Ly91bml4cGFwYS5jb20vanMva2V5Lmh0bWxcclxuICAgICAgICAgKi9cclxuICAgICAgICBLZXlib2FyZC5wcm90b3R5cGUuX25vcm1hbGl6ZUtleUNvZGUgPSBmdW5jdGlvbiAoY29kZSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTk6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEtleXMuU2VtaWNvbG9uO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEtleWJvYXJkO1xyXG4gICAgfShDbGFzc183LkNsYXNzKSk7XHJcbiAgICBleHBvcnRzLktleWJvYXJkID0gS2V5Ym9hcmQ7XHJcbn0pO1xyXG5kZWZpbmUoXCJJbnB1dC9JRW5naW5lSW5wdXRcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxufSk7XHJcbi8qKlxyXG4gKiBQcm92aWRlcyBzdXBwb3J0IGZvciBtaWNlLCBrZXlib2FyZHMsIGFuZCBjb250cm9sbGVycy5cclxuICpcclxuICogW1tpbmNsdWRlOklucHV0Lm1kXV1cclxuICovXHJcbmRlZmluZShcIklucHV0L0luZGV4XCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiSW5wdXQvR2FtZXBhZFwiLCBcIklucHV0L1BvaW50ZXJcIiwgXCJJbnB1dC9LZXlib2FyZFwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIEdhbWVwYWRfMSwgUG9pbnRlcl8xLCBLZXlib2FyZF8xKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIGZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcclxuICAgICAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlZG9jXHJcbiAgICAgKi9cclxuICAgIF9fZXhwb3J0KEdhbWVwYWRfMSk7XHJcbiAgICBfX2V4cG9ydChQb2ludGVyXzEpO1xyXG4gICAgX19leHBvcnQoS2V5Ym9hcmRfMSk7XHJcbn0pO1xyXG5kZWZpbmUoXCJVdGlsL0luZGV4XCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiVXRpbC9VdGlsXCIsIFwiVXRpbC9EcmF3VXRpbFwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIFV0aWxfMywgZHJhd1V0aWwpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIF9fZXhwb3J0KFV0aWxfMyk7XHJcbiAgICBleHBvcnRzLkRyYXdVdGlsID0gZHJhd1V0aWw7XHJcbn0pO1xyXG5kZWZpbmUoXCJVdGlsL0RlY29yYXRvcnNcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJVdGlsL0xvZ1wiLCBcIlV0aWwvVXRpbFwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIExvZ18xMSwgVXRpbCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIE9ic29sZXRlIGRlY29yYXRvciBmb3IgbWFya2luZyBFeGNhbGlidXIgbWV0aG9kcyBvYnNvbGV0ZSwgeW91IGNhbiBvcHRpb25hbGx5IHNwZWNpZnkgYSBjdXN0b20gbWVzc2FnZSBhbmQvb3IgYWx0ZXJuYXRlIHJlcGxhY2VtZW50XHJcbiAgICAgKiBtZXRob2QgZG8gdGhlIGRlcHJlY2F0ZWQgb25lLiBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vamF5cGhlbHBzL2NvcmUtZGVjb3JhdG9ycy5qc1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBvYnNvbGV0ZShvcHRpb25zKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHt9LCB7IG1lc3NhZ2U6ICdUaGlzIG1ldGhvZCB3aWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIHZlcnNpb25zIG9mIEV4Y2FsaWJ1ci4nLCBhbHRlcm5hdGVNZXRob2Q6IG51bGwgfSwgb3B0aW9ucyk7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIHByb3BlcnR5LCBkZXNjcmlwdG9yKSB7XHJcbiAgICAgICAgICAgIGlmICghKHR5cGVvZiBkZXNjcmlwdG9yLnZhbHVlID09PSAnZnVuY3Rpb24nIHx8XHJcbiAgICAgICAgICAgICAgICB0eXBlb2YgZGVzY3JpcHRvci5nZXQgPT09ICdmdW5jdGlvbicgfHxcclxuICAgICAgICAgICAgICAgIHR5cGVvZiBkZXNjcmlwdG9yLnNldCA9PT0gJ2Z1bmN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignT25seSBmdW5jdGlvbnMvZ2V0dGVycy9zZXR0ZXJzIGNhbiBiZSBtYXJrZWQgYXMgb2Jzb2xldGUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbWV0aG9kU2lnbmF0dXJlID0gXCJcIiArICh0YXJnZXQubmFtZSB8fCAnJykgKyAodGFyZ2V0Lm5hbWUgPyAnLicgOiAnJykgKyBwcm9wZXJ0eTtcclxuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBtZXRob2RTaWduYXR1cmUgKyBcIiBpcyBtYXJrZWQgb2Jzb2xldGU6IFwiICsgb3B0aW9ucy5tZXNzYWdlICtcclxuICAgICAgICAgICAgICAgIChvcHRpb25zLmFsdGVybmF0ZU1ldGhvZCA/IFwiIFVzZSBcIiArIG9wdGlvbnMuYWx0ZXJuYXRlTWV0aG9kICsgXCIgaW5zdGVhZFwiIDogJycpO1xyXG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gVXRpbC5leHRlbmQoe30sIGRlc2NyaXB0b3IpO1xyXG4gICAgICAgICAgICBpZiAoZGVzY3JpcHRvci52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kLnZhbHVlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIExvZ18xMS5Mb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdG9yLnZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ldGhvZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGVzY3JpcHRvci5nZXQpIHtcclxuICAgICAgICAgICAgICAgIG1ldGhvZC5nZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgTG9nXzExLkxvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4obWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3IuZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yLnNldCkge1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kLnNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBMb2dfMTEuTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybihtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvci5zZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZDtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5vYnNvbGV0ZSA9IG9ic29sZXRlO1xyXG59KTtcclxuZGVmaW5lKFwiVXRpbC9EZXRlY3RvclwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIlV0aWwvTG9nXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgTG9nXzEyKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBpcyB0aGUgbGlzdCBvZiBmZWF0dXJlcyB0aGF0IHdpbGwgYmUgdXNlZCB0byBsb2cgdGhlIHN1cHBvcnRlZFxyXG4gICAgICogZmVhdHVyZXMgdG8gdGhlIGNvbnNvbGUgd2hlbiBEZXRlY3Rvci5sb2dCcm93c2VyRmVhdHVyZXMoKSBpcyBjYWxsZWQuXHJcbiAgICAgKi9cclxuICAgIHZhciBSRVBPUlRFRF9GRUFUVVJFUyA9IHtcclxuICAgICAgICB3ZWJnbDogJ1dlYkdMJyxcclxuICAgICAgICB3ZWJhdWRpbzogJ1dlYkF1ZGlvJyxcclxuICAgICAgICBnYW1lcGFkYXBpOiAnR2FtZXBhZCBBUEknXHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBFeGNhbGlidXIgaW50ZXJuYWwgZmVhdHVyZSBkZXRlY3Rpb24gaGVscGVyIGNsYXNzXHJcbiAgICAgKi9cclxuICAgIHZhciBEZXRlY3RvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gRGV0ZWN0b3IoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZlYXR1cmVzID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5mYWlsZWRUZXN0cyA9IFtdO1xyXG4gICAgICAgICAgICAvLyBjcml0aWNhbCBicm93c2VyIGZlYXR1cmVzIHJlcXVpcmVkIGZvciBleCB0byBydW5cclxuICAgICAgICAgICAgdGhpcy5fY3JpdGljYWxUZXN0cyA9IHtcclxuICAgICAgICAgICAgICAgIC8vIFRlc3QgY2FudmFzLzJkIGNvbnRleHQgc3VwcG9ydFxyXG4gICAgICAgICAgICAgICAgY2FudmFzU3VwcG9ydDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhKGVsZW0uZ2V0Q29udGV4dCAmJiBlbGVtLmdldENvbnRleHQoJzJkJykpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC8vIFRlc3QgYXJyYXkgYnVmZmVyIHN1cHBvcnQgZXggdXNlcyBmb3IgZG93bmxvYWRpbmcgYmluYXJ5IGRhdGFcclxuICAgICAgICAgICAgICAgIGFycmF5QnVmZmVyU3VwcG9ydDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICAgICAgICAgICAgICB4aHIub3BlbignR0VUJywgJy8nKTtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geGhyLnJlc3BvbnNlVHlwZSA9PT0gJ2FycmF5YnVmZmVyJztcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAvLyBUZXN0IGRhdGEgdXJscyBleCB1c2VzIGZvciBzcHJpdGVzXHJcbiAgICAgICAgICAgICAgICBkYXRhVXJsU3VwcG9ydDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJykuaW5kZXhPZignZGF0YTppbWFnZS9wbmcnKSA9PT0gMDtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAvLyBUZXN0IG9iamVjdCB1cmwgc3VwcG9ydCBmb3IgbG9hZGluZ1xyXG4gICAgICAgICAgICAgICAgb2JqZWN0VXJsU3VwcG9ydDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoJ1VSTCcgaW4gd2luZG93KSAmJiAoJ3Jldm9rZU9iamVjdFVSTCcgaW4gVVJMKSAmJiAoJ2NyZWF0ZU9iamVjdFVSTCcgaW4gVVJMKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAvLyBSR0JBIHN1cHBvcnQgZm9yIGNvbG9yc1xyXG4gICAgICAgICAgICAgICAgcmdiYVN1cHBvcnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJykuc3R5bGU7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuY3NzVGV4dCA9ICdiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMTUwLDI1NSwxNTAsLjUpJztcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCcnICsgc3R5bGUuYmFja2dyb3VuZENvbG9yKS5pbmRleE9mKCdyZ2JhJykgPiAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLy8gd2FybmluZ3MgZXhjYWxpYnVyIHBlcmZvcm1hbmNlIHdpbGwgYmUgZGVncmFkZWRcclxuICAgICAgICAgICAgdGhpcy5fd2FybmluZ1Rlc3QgPSB7XHJcbiAgICAgICAgICAgICAgICB3ZWJBdWRpb1N1cHBvcnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gISEod2luZG93LkF1ZGlvQ29udGV4dCB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5tb3pBdWRpb0NvbnRleHQgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93Lm1zQXVkaW9Db250ZXh0IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5vQXVkaW9Db250ZXh0KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB3ZWJnbFN1cHBvcnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhIShlbGVtLmdldENvbnRleHQgJiYgZWxlbS5nZXRDb250ZXh0KCd3ZWJnbCcpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5fZmVhdHVyZXMgPSB0aGlzLl9sb2FkQnJvd3NlckZlYXR1cmVzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBtYXAgb2YgY3VycmVudGx5IHN1cHBvcnRlZCBicm93c2VyIGZlYXR1cmVzLiBUaGlzIG1ldGhvZFxyXG4gICAgICAgICAqIHRyZWF0cyB0aGUgZmVhdHVyZXMgYXMgYSBzaW5nbGV0b24gYW5kIHdpbGwgb25seSBjYWxjdWxhdGUgZmVhdHVyZVxyXG4gICAgICAgICAqIHN1cHBvcnQgaWYgaXQgaGFzIG5vdCBwcmV2aW91c2x5IGJlZW4gZG9uZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBEZXRlY3Rvci5wcm90b3R5cGUuZ2V0QnJvd3NlckZlYXR1cmVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fZmVhdHVyZXMgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZlYXR1cmVzID0gdGhpcy5fbG9hZEJyb3dzZXJGZWF0dXJlcygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mZWF0dXJlcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlcG9ydCBvbiBub24tY3JpdGljYWwgYnJvd3NlciBzdXBwb3J0IGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuXHJcbiAgICAgICAgICogVXNlIG5hdGl2ZSBicm93c2VyIGNvbnNvbGUgY29sb3JzIGZvciB2aXNpYmlsaXR5LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERldGVjdG9yLnByb3RvdHlwZS5sb2dCcm93c2VyRmVhdHVyZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBtc2cgPSAnJWNTVVBQT1JURUQgQlJPV1NFUiBGRUFUVVJFU1xcbj09PT09PT09PT09PT09PT09PT09PT09PT09JWNcXG4nO1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IFtcclxuICAgICAgICAgICAgICAgICdmb250LXdlaWdodDogYm9sZDsgY29sb3I6IG5hdnknLFxyXG4gICAgICAgICAgICAgICAgJ2ZvbnQtd2VpZ2h0OiBub3JtYWw7IGNvbG9yOiBpbmhlcml0J1xyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICB2YXIgc3VwcG9ydGVkID0gdGhpcy5nZXRCcm93c2VyRmVhdHVyZXMoKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5rZXlzKFJFUE9SVEVEX0ZFQVRVUkVTKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBmZWF0dXJlID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN1cHBvcnRlZFtmZWF0dXJlXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1zZyArPSAnKCVjXFx1MjcxMyVjKSc7IC8vICjinJMpXHJcbiAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKCdmb250LXdlaWdodDogYm9sZDsgY29sb3I6IGdyZWVuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKCdmb250LXdlaWdodDogbm9ybWFsOyBjb2xvcjogaW5oZXJpdCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbXNnICs9ICcoJWNcXHUyNzE3JWMpJzsgLy8gKOKclylcclxuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goJ2ZvbnQtd2VpZ2h0OiBib2xkOyBjb2xvcjogcmVkJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKCdmb250LXdlaWdodDogbm9ybWFsOyBjb2xvcjogaW5oZXJpdCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgO1xyXG4gICAgICAgICAgICAgICAgbXNnICs9ICcgJyArIFJFUE9SVEVEX0ZFQVRVUkVTW2ZlYXR1cmVdICsgJ1xcbic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXJncy51bnNoaWZ0KG1zZyk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRXhlY3V0ZXMgc2V2ZXJhbCBJSUZFJ3MgdG8gZ2V0IGEgY29uc3RhbnQgcmVmZXJlbmNlIHRvIHN1cHBvcnRlZFxyXG4gICAgICAgICAqIGZlYXR1cmVzIHdpdGhpbiB0aGUgY3VycmVudCBleGVjdXRpb24gY29udGV4dC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBEZXRlY3Rvci5wcm90b3R5cGUuX2xvYWRCcm93c2VyRmVhdHVyZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAvLyBJSUZFIHRvIGNoZWNrIGNhbnZhcyBzdXBwb3J0XHJcbiAgICAgICAgICAgICAgICBjYW52YXM6IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9jcml0aWNhbFRlc3RzLmNhbnZhc1N1cHBvcnQoKTtcclxuICAgICAgICAgICAgICAgIH0pKCksXHJcbiAgICAgICAgICAgICAgICAvLyBJSUZFIHRvIGNoZWNrIGFycmF5YnVmZmVyIHN1cHBvcnRcclxuICAgICAgICAgICAgICAgIGFycmF5YnVmZmVyOiAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fY3JpdGljYWxUZXN0cy5hcnJheUJ1ZmZlclN1cHBvcnQoKTtcclxuICAgICAgICAgICAgICAgIH0pKCksXHJcbiAgICAgICAgICAgICAgICAvLyBJSUZFIHRvIGNoZWNrIGRhdGF1cmwgc3VwcG9ydFxyXG4gICAgICAgICAgICAgICAgZGF0YXVybDogKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2NyaXRpY2FsVGVzdHMuZGF0YVVybFN1cHBvcnQoKTtcclxuICAgICAgICAgICAgICAgIH0pKCksXHJcbiAgICAgICAgICAgICAgICAvLyBJSUZFIHRvIGNoZWNrIG9iamVjdHVybCBzdXBwb3J0XHJcbiAgICAgICAgICAgICAgICBvYmplY3R1cmw6IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9jcml0aWNhbFRlc3RzLm9iamVjdFVybFN1cHBvcnQoKTtcclxuICAgICAgICAgICAgICAgIH0pKCksXHJcbiAgICAgICAgICAgICAgICAvLyBJSUZFIHRvIGNoZWNrIHJnYmEgc3VwcG9ydFxyXG4gICAgICAgICAgICAgICAgcmdiYTogKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2NyaXRpY2FsVGVzdHMucmdiYVN1cHBvcnQoKTtcclxuICAgICAgICAgICAgICAgIH0pKCksXHJcbiAgICAgICAgICAgICAgICAvLyBJSUZFIHRvIGNoZWNrIHdlYmF1ZGlvIHN1cHBvcnRcclxuICAgICAgICAgICAgICAgIHdlYmF1ZGlvOiAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fd2FybmluZ1Rlc3Qud2ViQXVkaW9TdXBwb3J0KCk7XHJcbiAgICAgICAgICAgICAgICB9KSgpLFxyXG4gICAgICAgICAgICAgICAgLy8gSUlGRSB0byBjaGVjayB3ZWJnbCBzdXBwb3J0XHJcbiAgICAgICAgICAgICAgICB3ZWJnbDogKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX3dhcm5pbmdUZXN0LndlYmdsU3VwcG9ydCgpO1xyXG4gICAgICAgICAgICAgICAgfSkoKSxcclxuICAgICAgICAgICAgICAgIC8vIElJRkUgdG8gY2hlY2sgZ2FtZXBhZGFwaSBzdXBwb3J0XHJcbiAgICAgICAgICAgICAgICBnYW1lcGFkYXBpOiAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhIW5hdmlnYXRvci5nZXRHYW1lcGFkcztcclxuICAgICAgICAgICAgICAgIH0pKClcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIERldGVjdG9yLnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBDcml0aWNhbCB0ZXN0IHdpbGwgZm9yIGV4IG5vdCB0byBydW5cclxuICAgICAgICAgICAgdmFyIGZhaWxlZENyaXRpY2FsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHRlc3QgaW4gdGhpcy5fY3JpdGljYWxUZXN0cykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9jcml0aWNhbFRlc3RzW3Rlc3RdLmNhbGwodGhpcykpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZhaWxlZFRlc3RzLnB1c2godGVzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgTG9nXzEyLkxvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKCdDcml0aWNhbCBicm93c2VyIGZlYXR1cmUgbWlzc2luZywgRXhjYWxpYnVyIHJlcXVpcmVzOicsIHRlc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZhaWxlZENyaXRpY2FsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZmFpbGVkQ3JpdGljYWwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBXYXJuaW5nIHRlc3RzIGRvIG5vdCBmb3IgZXggdG8gcmV0dXJuIGZhbHNlIHRvIGNvbXBhdGliaWxpdHlcclxuICAgICAgICAgICAgZm9yICh2YXIgd2FybmluZyBpbiB0aGlzLl93YXJuaW5nVGVzdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl93YXJuaW5nVGVzdFt3YXJuaW5nXSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgTG9nXzEyLkxvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4oJ1dhcm5pbmcgYnJvd3NlciBmZWF0dXJlIG1pc3NpbmcsIEV4Y2FsaWJ1ciB3aWxsIGhhdmUgcmVkdWNlZCBwZXJmb3JtYW5jZTonLCB3YXJuaW5nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBEZXRlY3RvcjtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkRldGVjdG9yID0gRGV0ZWN0b3I7XHJcbn0pO1xyXG5kZWZpbmUoXCJVdGlsL1NvcnRlZExpc3RcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogQSBzb3J0ZWQgbGlzdCBpbXBsZW1lbnRhdGlvbi4gTk9URTogdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3Qgc2VsZi1iYWxhbmNpbmdcclxuICAgICAqL1xyXG4gICAgdmFyIFNvcnRlZExpc3QgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIFNvcnRlZExpc3QoZ2V0Q29tcGFyYWJsZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9nZXRDb21wYXJhYmxlID0gZ2V0Q29tcGFyYWJsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgU29ydGVkTGlzdC5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9maW5kKHRoaXMuX3Jvb3QsIGVsZW1lbnQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgU29ydGVkTGlzdC5wcm90b3R5cGUuX2ZpbmQgPSBmdW5jdGlvbiAobm9kZSwgZWxlbWVudCkge1xyXG4gICAgICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fZ2V0Q29tcGFyYWJsZS5jYWxsKGVsZW1lbnQpID09PSBub2RlLmdldEtleSgpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5nZXREYXRhKCkuaW5kZXhPZihlbGVtZW50KSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fZ2V0Q29tcGFyYWJsZS5jYWxsKGVsZW1lbnQpIDwgbm9kZS5nZXRLZXkoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmQobm9kZS5nZXRMZWZ0KCksIGVsZW1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmQobm9kZS5nZXRSaWdodCgpLCBlbGVtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gcmV0dXJucyB0aGUgYXJyYXkgb2YgZWxlbWVudHMgYXQgYSBzcGVjaWZpYyBrZXkgdmFsdWVcclxuICAgICAgICBTb3J0ZWRMaXN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXQodGhpcy5fcm9vdCwga2V5KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNvcnRlZExpc3QucHJvdG90eXBlLl9nZXQgPSBmdW5jdGlvbiAobm9kZSwga2V5KSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09IG5vZGUuZ2V0S2V5KCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmdldERhdGEoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPCBub2RlLmdldEtleSgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0KG5vZGUuZ2V0TGVmdCgpLCBrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldChub2RlLmdldFJpZ2h0KCksIGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFNvcnRlZExpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb290ID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Jvb3QgPSBuZXcgQmluYXJ5VHJlZU5vZGUodGhpcy5fZ2V0Q29tcGFyYWJsZS5jYWxsKGVsZW1lbnQpLCBbZWxlbWVudF0sIG51bGwsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0KHRoaXMuX3Jvb3QsIGVsZW1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTb3J0ZWRMaXN0LnByb3RvdHlwZS5faW5zZXJ0ID0gZnVuY3Rpb24gKG5vZGUsIGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2dldENvbXBhcmFibGUuY2FsbChlbGVtZW50KSA9PT0gbm9kZS5nZXRLZXkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmdldERhdGEoKS5pbmRleE9mKGVsZW1lbnQpID4gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyB0aGUgZWxlbWVudCB3ZSdyZSB0cnlpbmcgdG8gaW5zZXJ0IGFscmVhZHkgZXhpc3RzXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmdldERhdGEoKS5wdXNoKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9nZXRDb21wYXJhYmxlLmNhbGwoZWxlbWVudCkgPCBub2RlLmdldEtleSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuZ2V0TGVmdCgpID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRMZWZ0KG5ldyBCaW5hcnlUcmVlTm9kZSh0aGlzLl9nZXRDb21wYXJhYmxlLmNhbGwoZWxlbWVudCksIFtlbGVtZW50XSwgbnVsbCwgbnVsbCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnNlcnQobm9kZS5nZXRMZWZ0KCksIGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmdldFJpZ2h0KCkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnNldFJpZ2h0KG5ldyBCaW5hcnlUcmVlTm9kZSh0aGlzLl9nZXRDb21wYXJhYmxlLmNhbGwoZWxlbWVudCksIFtlbGVtZW50XSwgbnVsbCwgbnVsbCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnNlcnQobm9kZS5nZXRSaWdodCgpLCBlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgU29ydGVkTGlzdC5wcm90b3R5cGUucmVtb3ZlQnlDb21wYXJhYmxlID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5fcm9vdCA9IHRoaXMuX3JlbW92ZSh0aGlzLl9yb290LCBlbGVtZW50KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNvcnRlZExpc3QucHJvdG90eXBlLl9yZW1vdmUgPSBmdW5jdGlvbiAobm9kZSwgZWxlbWVudCkge1xyXG4gICAgICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9nZXRDb21wYXJhYmxlLmNhbGwoZWxlbWVudCkgPT09IG5vZGUuZ2V0S2V5KCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50SW5kZXggPSBub2RlLmdldERhdGEoKS5pbmRleE9mKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIG5vZGUgY29udGFpbnMgdGhlIGVsZW1lbnQsIHJlbW92ZSB0aGUgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRJbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5nZXREYXRhKCkuc3BsaWNlKGVsZW1lbnRJbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSByZW1vdmVkIHRoZSBsYXN0IGVsZW1lbnQgYXQgdGhpcyBub2RlLCByZW1vdmUgdGhlIG5vZGVcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5nZXREYXRhKCkubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBub2RlIGlzIGEgbGVhZlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5nZXRMZWZ0KCkgPT0gbnVsbCAmJiBub2RlLmdldFJpZ2h0KCkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5nZXRMZWZ0KCkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuZ2V0UmlnaHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlLmdldFJpZ2h0KCkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuZ2V0TGVmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIG5vZGUgaGFzIDIgY2hpbGRyZW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXAgPSB0aGlzLl9maW5kTWluTm9kZShub2RlLmdldFJpZ2h0KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnNldEtleSh0ZW1wLmdldEtleSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXREYXRhKHRlbXAuZ2V0RGF0YSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRSaWdodCh0aGlzLl9jbGVhbnVwKG5vZGUuZ2V0UmlnaHQoKSwgdGVtcCkpOyAvL1wiY2xlYW51cCBub2Rlc1wiIChtb3ZlIHRoZW0gdXAgcmVjdXJzaXZlbHkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBwcmV2ZW50cyB0aGUgbm9kZSBmcm9tIGJlaW5nIHJlbW92ZWQgc2luY2UgaXQgc3RpbGwgY29udGFpbnMgZWxlbWVudHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2dldENvbXBhcmFibGUuY2FsbChlbGVtZW50KSA8IG5vZGUuZ2V0S2V5KCkpIHtcclxuICAgICAgICAgICAgICAgIG5vZGUuc2V0TGVmdCh0aGlzLl9yZW1vdmUobm9kZS5nZXRMZWZ0KCksIGVsZW1lbnQpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5zZXRSaWdodCh0aGlzLl9yZW1vdmUobm9kZS5nZXRSaWdodCgpLCBlbGVtZW50KSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIGNhbGxlZCBvbmNlIHdlIGhhdmUgc3VjY2Vzc2Z1bGx5IHJlbW92ZWQgdGhlIGVsZW1lbnQgd2Ugd2FudGVkLCByZWN1cnNpdmVseSBjb3JyZWN0cyB0aGUgcGFydCBvZiB0aGUgdHJlZSBiZWxvdyB0aGUgcmVtb3ZlZCBub2RlXHJcbiAgICAgICAgU29ydGVkTGlzdC5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbiAobm9kZSwgZWxlbWVudCkge1xyXG4gICAgICAgICAgICB2YXIgY29tcGFyYWJsZSA9IGVsZW1lbnQuZ2V0S2V5KCk7XHJcbiAgICAgICAgICAgIGlmIChub2RlID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbXBhcmFibGUgPT09IG5vZGUuZ2V0S2V5KCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBub2RlIGlzIGEgbGVhZlxyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuZ2V0TGVmdCgpID09IG51bGwgJiYgbm9kZS5nZXRSaWdodCgpID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUuZ2V0TGVmdCgpID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5nZXRSaWdodCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5nZXRSaWdodCgpID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5nZXRMZWZ0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBpZiBub2RlIGhhcyAyIGNoaWxkcmVuXHJcbiAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IHRoaXMuX2ZpbmRNaW5Ob2RlKG5vZGUuZ2V0UmlnaHQoKSk7XHJcbiAgICAgICAgICAgICAgICBub2RlLnNldEtleSh0ZW1wLmdldEtleSgpKTtcclxuICAgICAgICAgICAgICAgIG5vZGUuc2V0RGF0YSh0ZW1wLmdldERhdGEoKSk7XHJcbiAgICAgICAgICAgICAgICBub2RlLnNldFJpZ2h0KHRoaXMuX2NsZWFudXAobm9kZS5nZXRSaWdodCgpLCB0ZW1wKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9nZXRDb21wYXJhYmxlLmNhbGwoZWxlbWVudCkgPCBub2RlLmdldEtleSgpKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLnNldExlZnQodGhpcy5fY2xlYW51cChub2RlLmdldExlZnQoKSwgZWxlbWVudCkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLnNldFJpZ2h0KHRoaXMuX2NsZWFudXAobm9kZS5nZXRSaWdodCgpLCBlbGVtZW50KSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgU29ydGVkTGlzdC5wcm90b3R5cGUuX2ZpbmRNaW5Ob2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBub2RlO1xyXG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudC5nZXRMZWZ0KCkgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuZ2V0TGVmdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgU29ydGVkTGlzdC5wcm90b3R5cGUubGlzdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgdGhpcy5fbGlzdCh0aGlzLl9yb290LCByZXN1bHRzKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTb3J0ZWRMaXN0LnByb3RvdHlwZS5fbGlzdCA9IGZ1bmN0aW9uICh0cmVlTm9kZSwgcmVzdWx0cykge1xyXG4gICAgICAgICAgICBpZiAodHJlZU5vZGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdCh0cmVlTm9kZS5nZXRMZWZ0KCksIHJlc3VsdHMpO1xyXG4gICAgICAgICAgICAgICAgdHJlZU5vZGUuZ2V0RGF0YSgpLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xpc3QodHJlZU5vZGUuZ2V0UmlnaHQoKSwgcmVzdWx0cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBTb3J0ZWRMaXN0O1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuU29ydGVkTGlzdCA9IFNvcnRlZExpc3Q7XHJcbiAgICAvKipcclxuICAgICAqIEEgdHJlZSBub2RlIHBhcnQgb2YgW1tTb3J0ZWRMaXN0XV1cclxuICAgICAqL1xyXG4gICAgdmFyIEJpbmFyeVRyZWVOb2RlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBCaW5hcnlUcmVlTm9kZShrZXksIGRhdGEsIGxlZnQsIHJpZ2h0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2tleSA9IGtleTtcclxuICAgICAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgICAgIHRoaXMuX2xlZnQgPSBsZWZ0O1xyXG4gICAgICAgICAgICB0aGlzLl9yaWdodCA9IHJpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBCaW5hcnlUcmVlTm9kZS5wcm90b3R5cGUuZ2V0S2V5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fa2V5O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQmluYXJ5VHJlZU5vZGUucHJvdG90eXBlLnNldEtleSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgdGhpcy5fa2V5ID0ga2V5O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQmluYXJ5VHJlZU5vZGUucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQmluYXJ5VHJlZU5vZGUucHJvdG90eXBlLnNldERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICB0aGlzLl9kYXRhID0gZGF0YTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEJpbmFyeVRyZWVOb2RlLnByb3RvdHlwZS5nZXRMZWZ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGVmdDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEJpbmFyeVRyZWVOb2RlLnByb3RvdHlwZS5zZXRMZWZ0ID0gZnVuY3Rpb24gKGxlZnQpIHtcclxuICAgICAgICAgICAgdGhpcy5fbGVmdCA9IGxlZnQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBCaW5hcnlUcmVlTm9kZS5wcm90b3R5cGUuZ2V0UmlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yaWdodDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEJpbmFyeVRyZWVOb2RlLnByb3RvdHlwZS5zZXRSaWdodCA9IGZ1bmN0aW9uIChyaWdodCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yaWdodCA9IHJpZ2h0O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEJpbmFyeVRyZWVOb2RlO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuQmluYXJ5VHJlZU5vZGUgPSBCaW5hcnlUcmVlTm9kZTtcclxuICAgIC8qKlxyXG4gICAgICogTW9jayBlbGVtZW50IGZvciB0ZXN0aW5nXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHZhciBNb2NrZWRFbGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBNb2NrZWRFbGVtZW50KGtleSkge1xyXG4gICAgICAgICAgICB0aGlzLl9rZXkgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9rZXkgPSBrZXk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE1vY2tlZEVsZW1lbnQucHJvdG90eXBlLmdldFRoZUtleSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2tleTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIE1vY2tlZEVsZW1lbnQucHJvdG90eXBlLnNldEtleSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgdGhpcy5fa2V5ID0ga2V5O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIE1vY2tlZEVsZW1lbnQ7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5Nb2NrZWRFbGVtZW50ID0gTW9ja2VkRWxlbWVudDtcclxufSk7XHJcbmRlZmluZShcIkluZGV4XCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiQWN0b3JcIiwgXCJBbGdlYnJhXCIsIFwiQ2FtZXJhXCIsIFwiQ2xhc3NcIiwgXCJDb25maWd1cmFibGVcIiwgXCJEZWJ1Z1wiLCBcIkVuZ2luZVwiLCBcIkV2ZW50RGlzcGF0Y2hlclwiLCBcIkV2ZW50c1wiLCBcIkdyb3VwXCIsIFwiTGFiZWxcIiwgXCJMb2FkZXJcIiwgXCJQYXJ0aWNsZXNcIiwgXCJQaHlzaWNzXCIsIFwiUHJvbWlzZXNcIiwgXCJTY2VuZVwiLCBcIlRpbGVNYXBcIiwgXCJUaW1lclwiLCBcIlRyaWdnZXJcIiwgXCJVSUFjdG9yXCIsIFwiQWN0aW9ucy9JbmRleFwiLCBcIkNvbGxpc2lvbi9JbmRleFwiLCBcIkRyYXdpbmcvSW5kZXhcIiwgXCJNYXRoL0luZGV4XCIsIFwiUG9zdFByb2Nlc3NpbmcvSW5kZXhcIiwgXCJSZXNvdXJjZXMvSW5kZXhcIiwgXCJFdmVudHNcIiwgXCJJbnB1dC9JbmRleFwiLCBcIlRyYWl0cy9JbmRleFwiLCBcIlV0aWwvSW5kZXhcIiwgXCJVdGlsL0RlY29yYXRvcnNcIiwgXCJVdGlsL0RldGVjdG9yXCIsIFwiVXRpbC9DdWxsaW5nQm94XCIsIFwiVXRpbC9FYXNpbmdGdW5jdGlvbnNcIiwgXCJVdGlsL0xvZ1wiLCBcIlV0aWwvU29ydGVkTGlzdFwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIEFjdG9yXzExLCBBbGdlYnJhXzIxLCBDYW1lcmFfMSwgQ2xhc3NfOCwgQ29uZmlndXJhYmxlXzcsIERlYnVnXzEsIEVuZ2luZV8zLCBFdmVudERpc3BhdGNoZXJfMiwgRXZlbnRzXzExLCBHcm91cF8xLCBMYWJlbF8yLCBMb2FkZXJfMSwgUGFydGljbGVzXzEsIFBoeXNpY3NfMTEsIFByb21pc2VzXzcsIFNjZW5lXzEsIFRpbGVNYXBfMSwgVGltZXJfMSwgVHJpZ2dlcl8xLCBVSUFjdG9yXzIsIEluZGV4XzEsIEluZGV4XzIsIEluZGV4XzMsIEluZGV4XzQsIEluZGV4XzUsIEluZGV4XzYsIGV2ZW50cywgaW5wdXQsIHRyYWl0cywgdXRpbCwgRGVjb3JhdG9yc18xLCBEZXRlY3Rvcl8xLCBDdWxsaW5nQm94XzIsIEVhc2luZ0Z1bmN0aW9uc18zLCBMb2dfMTMsIFNvcnRlZExpc3RfMSkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBmdW5jdGlvbiBfX2V4cG9ydChtKSB7XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY3VycmVudCBFeGNhbGlidXIgdmVyc2lvbiBzdHJpbmdcclxuICAgICAqL1xyXG4gICAgZXhwb3J0cy5FWF9WRVJTSU9OID0gJzAuMTUuMCc7XHJcbiAgICBleHBvcnRzLkFjdG9yID0gQWN0b3JfMTEuQWN0b3I7XHJcbiAgICBleHBvcnRzLkNvbGxpc2lvblR5cGUgPSBBY3Rvcl8xMS5Db2xsaXNpb25UeXBlO1xyXG4gICAgX19leHBvcnQoQWxnZWJyYV8yMSk7XHJcbiAgICBfX2V4cG9ydChDYW1lcmFfMSk7XHJcbiAgICBfX2V4cG9ydChDbGFzc184KTtcclxuICAgIF9fZXhwb3J0KENvbmZpZ3VyYWJsZV83KTtcclxuICAgIF9fZXhwb3J0KERlYnVnXzEpO1xyXG4gICAgX19leHBvcnQoRW5naW5lXzMpO1xyXG4gICAgX19leHBvcnQoRXZlbnREaXNwYXRjaGVyXzIpO1xyXG4gICAgX19leHBvcnQoRXZlbnRzXzExKTtcclxuICAgIF9fZXhwb3J0KEdyb3VwXzEpO1xyXG4gICAgZXhwb3J0cy5MYWJlbCA9IExhYmVsXzIuTGFiZWw7XHJcbiAgICBleHBvcnRzLkZvbnRTdHlsZSA9IExhYmVsXzIuRm9udFN0eWxlO1xyXG4gICAgZXhwb3J0cy5Gb250VW5pdCA9IExhYmVsXzIuRm9udFVuaXQ7XHJcbiAgICBleHBvcnRzLlRleHRBbGlnbiA9IExhYmVsXzIuVGV4dEFsaWduO1xyXG4gICAgZXhwb3J0cy5CYXNlQWxpZ24gPSBMYWJlbF8yLkJhc2VBbGlnbjtcclxuICAgIF9fZXhwb3J0KExvYWRlcl8xKTtcclxuICAgIGV4cG9ydHMuUGFydGljbGUgPSBQYXJ0aWNsZXNfMS5QYXJ0aWNsZTtcclxuICAgIGV4cG9ydHMuUGFydGljbGVFbWl0dGVyID0gUGFydGljbGVzXzEuUGFydGljbGVFbWl0dGVyO1xyXG4gICAgZXhwb3J0cy5FbWl0dGVyVHlwZSA9IFBhcnRpY2xlc18xLkVtaXR0ZXJUeXBlO1xyXG4gICAgX19leHBvcnQoUGh5c2ljc18xMSk7XHJcbiAgICBfX2V4cG9ydChQcm9taXNlc183KTtcclxuICAgIF9fZXhwb3J0KFNjZW5lXzEpO1xyXG4gICAgZXhwb3J0cy5UaWxlTWFwID0gVGlsZU1hcF8xLlRpbGVNYXA7XHJcbiAgICBleHBvcnRzLkNlbGwgPSBUaWxlTWFwXzEuQ2VsbDtcclxuICAgIGV4cG9ydHMuVGlsZVNwcml0ZSA9IFRpbGVNYXBfMS5UaWxlU3ByaXRlO1xyXG4gICAgX19leHBvcnQoVGltZXJfMSk7XHJcbiAgICBfX2V4cG9ydChUcmlnZ2VyXzEpO1xyXG4gICAgX19leHBvcnQoVUlBY3Rvcl8yKTtcclxuICAgIF9fZXhwb3J0KEluZGV4XzEpO1xyXG4gICAgX19leHBvcnQoSW5kZXhfMik7XHJcbiAgICBfX2V4cG9ydChJbmRleF8zKTtcclxuICAgIF9fZXhwb3J0KEluZGV4XzQpO1xyXG4gICAgX19leHBvcnQoSW5kZXhfNSk7XHJcbiAgICBfX2V4cG9ydChJbmRleF82KTtcclxuICAgIGV4cG9ydHMuRXZlbnRzID0gZXZlbnRzO1xyXG4gICAgZXhwb3J0cy5JbnB1dCA9IGlucHV0O1xyXG4gICAgZXhwb3J0cy5UcmFpdHMgPSB0cmFpdHM7XHJcbiAgICBleHBvcnRzLlV0aWwgPSB1dGlsO1xyXG4gICAgX19leHBvcnQoRGVjb3JhdG9yc18xKTtcclxuICAgIF9fZXhwb3J0KERldGVjdG9yXzEpO1xyXG4gICAgX19leHBvcnQoQ3VsbGluZ0JveF8yKTtcclxuICAgIF9fZXhwb3J0KEVhc2luZ0Z1bmN0aW9uc18zKTtcclxuICAgIF9fZXhwb3J0KExvZ18xMyk7XHJcbiAgICBfX2V4cG9ydChTb3J0ZWRMaXN0XzEpO1xyXG59KTtcclxuZGVmaW5lKFwiRW5naW5lXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiSW5kZXhcIiwgXCJQcm9taXNlc1wiLCBcIkFsZ2VicmFcIiwgXCJVSUFjdG9yXCIsIFwiQWN0b3JcIiwgXCJUaW1lclwiLCBcIlRpbGVNYXBcIiwgXCJMb2FkZXJcIiwgXCJVdGlsL0RldGVjdG9yXCIsIFwiRXZlbnRzXCIsIFwiVXRpbC9Mb2dcIiwgXCJEcmF3aW5nL0NvbG9yXCIsIFwiU2NlbmVcIiwgXCJEZWJ1Z1wiLCBcIkNsYXNzXCIsIFwiSW5wdXQvSW5kZXhcIiwgXCJVdGlsL1V0aWxcIiwgXCJDb2xsaXNpb24vQm91bmRpbmdCb3hcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBJbmRleF83LCBQcm9taXNlc184LCBBbGdlYnJhXzIyLCBVSUFjdG9yXzMsIEFjdG9yXzEyLCBUaW1lcl8yLCBUaWxlTWFwXzIsIExvYWRlcl8yLCBEZXRlY3Rvcl8yLCBFdmVudHNfMTIsIExvZ18xNCwgQ29sb3JfMTksIFNjZW5lXzIsIERlYnVnXzIsIENsYXNzXzksIElucHV0LCBVdGlsLCBCb3VuZGluZ0JveF83KSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogRW51bSByZXByZXNlbnRpbmcgdGhlIGRpZmZlcmVudCBkaXNwbGF5IG1vZGVzIGF2YWlsYWJsZSB0byBFeGNhbGlidXJcclxuICAgICAqL1xyXG4gICAgdmFyIERpc3BsYXlNb2RlO1xyXG4gICAgKGZ1bmN0aW9uIChEaXNwbGF5TW9kZSkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNob3cgdGhlIGdhbWUgYXMgZnVsbCBzY3JlZW5cclxuICAgICAgICAgKi9cclxuICAgICAgICBEaXNwbGF5TW9kZVtEaXNwbGF5TW9kZVtcIkZ1bGxTY3JlZW5cIl0gPSAwXSA9IFwiRnVsbFNjcmVlblwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNjYWxlIHRoZSBnYW1lIHRvIHRoZSBwYXJlbnQgRE9NIGNvbnRhaW5lclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERpc3BsYXlNb2RlW0Rpc3BsYXlNb2RlW1wiQ29udGFpbmVyXCJdID0gMV0gPSBcIkNvbnRhaW5lclwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNob3cgdGhlIGdhbWUgYXMgYSBmaXhlZCBzaXplXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRGlzcGxheU1vZGVbRGlzcGxheU1vZGVbXCJGaXhlZFwiXSA9IDJdID0gXCJGaXhlZFwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFsbG93IHRoZSBnYW1lIHRvIGJlIHBvc2l0aW9uZWQgd2l0aCB0aGUgW1tJRW5naW5lT3B0aW9ucy5wb3NpdGlvbl1dIG9wdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERpc3BsYXlNb2RlW0Rpc3BsYXlNb2RlW1wiUG9zaXRpb25cIl0gPSAzXSA9IFwiUG9zaXRpb25cIjtcclxuICAgIH0pKERpc3BsYXlNb2RlID0gZXhwb3J0cy5EaXNwbGF5TW9kZSB8fCAoZXhwb3J0cy5EaXNwbGF5TW9kZSA9IHt9KSk7XHJcbiAgICAvKipcclxuICAgICAqIEVudW0gcmVwcmVzZW50aW5nIHRoZSBkaWZmZXJlbnQgbW91c2V3aGVlbCBldmVudCBidWJibGUgcHJldmVudGlvblxyXG4gICAgICovXHJcbiAgICB2YXIgU2Nyb2xsUHJldmVudGlvbk1vZGU7XHJcbiAgICAoZnVuY3Rpb24gKFNjcm9sbFByZXZlbnRpb25Nb2RlKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRG8gbm90IHByZXZlbnQgYW55IHBhZ2Ugc2Nyb2xsaW5nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2Nyb2xsUHJldmVudGlvbk1vZGVbU2Nyb2xsUHJldmVudGlvbk1vZGVbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcmV2ZW50IHBhZ2Ugc2Nyb2xsIGlmIG1vdXNlIGlzIG92ZXIgdGhlIGdhbWUgY2FudmFzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2Nyb2xsUHJldmVudGlvbk1vZGVbU2Nyb2xsUHJldmVudGlvbk1vZGVbXCJDYW52YXNcIl0gPSAxXSA9IFwiQ2FudmFzXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJldmVudCBhbGwgcGFnZSBzY3JvbGxpbmcgdmlhIG1vdXNlIHdoZWVsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2Nyb2xsUHJldmVudGlvbk1vZGVbU2Nyb2xsUHJldmVudGlvbk1vZGVbXCJBbGxcIl0gPSAyXSA9IFwiQWxsXCI7XHJcbiAgICB9KShTY3JvbGxQcmV2ZW50aW9uTW9kZSA9IGV4cG9ydHMuU2Nyb2xsUHJldmVudGlvbk1vZGUgfHwgKGV4cG9ydHMuU2Nyb2xsUHJldmVudGlvbk1vZGUgPSB7fSkpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgRXhjYWxpYnVyIEVuZ2luZVxyXG4gICAgICpcclxuICAgICAqIFRoZSBbW0VuZ2luZV1dIGlzIHRoZSBtYWluIGRyaXZlciBmb3IgYSBnYW1lLiBJdCBpcyByZXNwb25zaWJsZSBmb3JcclxuICAgICAqIHN0YXJ0aW5nL3N0b3BwaW5nIHRoZSBnYW1lLCBtYWludGFpbmluZyBzdGF0ZSwgdHJhbnNtaXR0aW5nIGV2ZW50cyxcclxuICAgICAqIGxvYWRpbmcgcmVzb3VyY2VzLCBhbmQgbWFuYWdpbmcgdGhlIHNjZW5lLlxyXG4gICAgICpcclxuICAgICAqIFtbaW5jbHVkZTpFbmdpbmUubWRdXVxyXG4gICAgICovXHJcbiAgICB2YXIgRW5naW5lID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoRW5naW5lLCBfc3VwZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgZ2FtZSB1c2luZyB0aGUgZ2l2ZW4gW1tJRW5naW5lT3B0aW9uc11dLiBCeSBkZWZhdWx0LCBpZiBubyBvcHRpb25zIGFyZSBwcm92aWRlZCxcclxuICAgICAgICAgKiB0aGUgZ2FtZSB3aWxsIGJlIHJlbmRlcmVkIGZ1bGwgc2NyZWVuICh0YWtpbmcgdXAgYWxsIGF2YWlsYWJsZSBicm93c2VyIHdpbmRvdyBzcGFjZSkuXHJcbiAgICAgICAgICogWW91IGNhbiBjdXN0b21pemUgdGhlIGdhbWUgcmVuZGVyaW5nIHRocm91Z2ggW1tJRW5naW5lT3B0aW9uc11dLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogRXhhbXBsZTpcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIGBgYGpzXHJcbiAgICAgICAgICogdmFyIGdhbWUgPSBuZXcgZXguRW5naW5lKHtcclxuICAgICAgICAgKiAgIHdpZHRoOiAwLCAvLyB0aGUgd2lkdGggb2YgdGhlIGNhbnZhc1xyXG4gICAgICAgICAqICAgaGVpZ2h0OiAwLCAvLyB0aGUgaGVpZ2h0IG9mIHRoZSBjYW52YXNcclxuICAgICAgICAgKiAgIGNhbnZhc0VsZW1lbnRJZDogJycsIC8vIHRoZSBET00gY2FudmFzIGVsZW1lbnQgSUQsIGlmIHlvdSBhcmUgcHJvdmlkaW5nIHlvdXIgb3duXHJcbiAgICAgICAgICogICBkaXNwbGF5TW9kZTogZXguRGlzcGxheU1vZGUuRnVsbFNjcmVlbiwgLy8gdGhlIGRpc3BsYXkgbW9kZVxyXG4gICAgICAgICAqICAgcG9pbnRlclNjb3BlOiBleC5JbnB1dC5Qb2ludGVyU2NvcGUuRG9jdW1lbnQsIC8vIHRoZSBzY29wZSBvZiBjYXB0dXJpbmcgcG9pbnRlciAobW91c2UvdG91Y2gpIGV2ZW50c1xyXG4gICAgICAgICAqICAgYmFja2dyb3VuZENvbG9yOiBleC5Db2xvci5mcm9tSGV4KCcjMjE4NWQwJykgLy8gYmFja2dyb3VuZCBjb2xvciBvZiB0aGUgZW5naW5lXHJcbiAgICAgICAgICogfSk7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAvLyBjYWxsIGdhbWUuc3RhcnQsIHdoaWNoIGlzIGEgUHJvbWlzZVxyXG4gICAgICAgICAqIGdhbWUuc3RhcnQoKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgKiAgIC8vIHJlYWR5LCBzZXQsIGdvIVxyXG4gICAgICAgICAqIH0pO1xyXG4gICAgICAgICAqIGBgYFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIEVuZ2luZShvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLl9oYXNTdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBY2Nlc3MgRXhjYWxpYnVyIGRlYnVnZ2luZyBmdW5jdGlvbmFsaXR5LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuZGVidWcgPSBuZXcgRGVidWdfMi5EZWJ1ZygpO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBsaXN0IG9mIHBvc3QgcHJvY2Vzc29ycyB0byBhcHBseSBhdCB0aGUgZW5kIG9mIGRyYXdpbmcgYSBmcmFtZSAoc3VjaCBhcyBbW0NvbG9yQmxpbmRDb3JyZWN0b3JdXSlcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLnBvc3RQcm9jZXNzb3JzID0gW107XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDb250YWlucyBhbGwgdGhlIHNjZW5lcyBjdXJyZW50bHkgcmVnaXN0ZXJlZCB3aXRoIEV4Y2FsaWJ1clxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuc2NlbmVzID0ge307XHJcbiAgICAgICAgICAgIF90aGlzLl9hbmltYXRpb25zID0gW107XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZW5naW5lIGlzIHNldCB0byBmdWxsc2NyZWVuIG9yIG5vdFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuaXNGdWxsc2NyZWVuID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbmRpY2F0ZXMgdGhlIGN1cnJlbnQgW1tEaXNwbGF5TW9kZV1dIG9mIHRoZSBlbmdpbmUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5kaXNwbGF5TW9kZSA9IERpc3BsYXlNb2RlLkZ1bGxTY3JlZW47XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBhdWRpbyBzaG91bGQgYmUgcGF1c2VkIHdoZW4gdGhlIGdhbWUgaXMgbm8gbG9uZ2VyIHZpc2libGUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5wYXVzZUF1ZGlvV2hlbkhpZGRlbiA9IHRydWU7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZW5naW5lIHNob3VsZCBkcmF3IHdpdGggZGVidWcgaW5mb3JtYXRpb25cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmlzRGVidWcgPSBmYWxzZTtcclxuICAgICAgICAgICAgX3RoaXMuZGVidWdDb2xvciA9IG5ldyBDb2xvcl8xOS5Db2xvcigyNTUsIDI1NSwgMjU1KTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBhY3Rpb24gdG8gdGFrZSB3aGVuIGEgZmF0YWwgZXhjZXB0aW9uIGlzIHRocm93blxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMub25GYXRhbEV4Y2VwdGlvbiA9IGZ1bmN0aW9uIChlKSB7IExvZ18xNC5Mb2dnZXIuZ2V0SW5zdGFuY2UoKS5mYXRhbChlKTsgfTtcclxuICAgICAgICAgICAgX3RoaXMuX2lzU21vb3RoaW5nRW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIF90aGlzLl90aW1lc2NhbGUgPSAxLjA7XHJcbiAgICAgICAgICAgIF90aGlzLl9pc0xvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgb3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHt9LCBFbmdpbmUuX0RlZmF1bHRFbmdpbmVPcHRpb25zLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgLy8gQ2hlY2sgY29tcGF0aWJpbGl0eSBcclxuICAgICAgICAgICAgdmFyIGRldGVjdG9yID0gbmV3IERldGVjdG9yXzIuRGV0ZWN0b3IoKTtcclxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnN1cHByZXNzTWluaW11bUJyb3dzZXJGZWF0dXJlRGV0ZWN0aW9uICYmICEoX3RoaXMuX2NvbXBhdGlibGUgPSBkZXRlY3Rvci50ZXN0KCkpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5pbm5lclRleHQgPSAnU29ycnksIHlvdXIgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IGFsbCB0aGUgZmVhdHVyZXMgbmVlZGVkIGZvciBFeGNhbGlidXInO1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIGRldGVjdG9yLmZhaWxlZFRlc3RzLmZvckVhY2goZnVuY3Rpb24gKHRlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGVzdE1lc3NhZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAgICAgICAgICB0ZXN0TWVzc2FnZS5pbm5lclRleHQgPSAnQnJvd3NlciBmZWF0dXJlIG1pc3NpbmcgJyArIHRlc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0ZXN0TWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmNhbnZhc0VsZW1lbnRJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChvcHRpb25zLmNhbnZhc0VsZW1lbnRJZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbnZhcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXMucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChjYW52YXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9jb21wYXRpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBVc2UgbmF0aXZlIGNvbnNvbGUgQVBJIGZvciBjb2xvciBmdW5cclxuICAgICAgICAgICAgaWYgKGNvbnNvbGUubG9nICYmICFvcHRpb25zLnN1cHByZXNzQ29uc29sZUJvb3RNZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIiVjUG93ZXJlZCBieSBFeGNhbGlidXIuanMgKHZcIiArIEluZGV4XzcuRVhfVkVSU0lPTiArIFwiKVwiLCAnYmFja2dyb3VuZDogIzE3NkJBQTsgY29sb3I6IHdoaXRlOyBib3JkZXItcmFkaXVzOiA1cHg7IHBhZGRpbmc6IDE1cHg7IGZvbnQtc2l6ZTogMS41ZW07IGxpbmUtaGVpZ2h0OiA4MHB4OycpO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1xcblxcXHJcbiAgICAgIC98IF9fX19fX19fX19fX19fX19cXG5cXFxyXG5PfD09PXwqID5fX19fX19fX19fX19fX19fPlxcblxcXHJcbiAgICAgIFxcXFx8Jyk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVmlzaXQnLCAnaHR0cDovL2V4Y2FsaWJ1cmpzLmNvbScsICdmb3IgbW9yZSBpbmZvcm1hdGlvbicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzLl9sb2dnZXIgPSBMb2dfMTQuTG9nZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgICAgIC8vIElmIGRlYnVnIGlzIGVuYWJsZWQsIGxldCdzIGxvZyBicm93c2VyIGZlYXR1cmVzIHRvIHRoZSBjb25zb2xlLlxyXG4gICAgICAgICAgICBpZiAoX3RoaXMuX2xvZ2dlci5kZWZhdWx0TGV2ZWwgPT09IExvZ18xNC5Mb2dMZXZlbC5EZWJ1Zykge1xyXG4gICAgICAgICAgICAgICAgZGV0ZWN0b3IubG9nQnJvd3NlckZlYXR1cmVzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci5kZWJ1ZygnQnVpbGRpbmcgZW5naW5lLi4uJyk7XHJcbiAgICAgICAgICAgIF90aGlzLmNhbnZhc0VsZW1lbnRJZCA9IG9wdGlvbnMuY2FudmFzRWxlbWVudElkO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jYW52YXNFbGVtZW50SWQpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuZGVidWcoJ1VzaW5nIENhbnZhcyBlbGVtZW50IHNwZWNpZmllZDogJyArIG9wdGlvbnMuY2FudmFzRWxlbWVudElkKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9wdGlvbnMuY2FudmFzRWxlbWVudElkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuZGVidWcoJ1VzaW5nIGdlbmVyYXRlZCBjYW52YXMgZWxlbWVudCcpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMud2lkdGggJiYgb3B0aW9ucy5oZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRpc3BsYXlNb2RlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kaXNwbGF5TW9kZSA9IERpc3BsYXlNb2RlLkZpeGVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci5kZWJ1ZygnRW5naW5lIHZpZXdwb3J0IGlzIHNpemUgJyArIG9wdGlvbnMud2lkdGggKyAnIHggJyArIG9wdGlvbnMuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmNhbnZhcy53aWR0aCA9IG9wdGlvbnMud2lkdGg7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5jYW52YXMuaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIW9wdGlvbnMuZGlzcGxheU1vZGUpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuZGVidWcoJ0VuZ2luZSB2aWV3cG9ydCBpcyBmdWxsc2NyZWVuJyk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5kaXNwbGF5TW9kZSA9IERpc3BsYXlNb2RlLkZ1bGxTY3JlZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvci5jbG9uZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzLl9sb2FkZXIgPSBuZXcgTG9hZGVyXzIuTG9hZGVyKCk7XHJcbiAgICAgICAgICAgIF90aGlzLl9pbml0aWFsaXplKG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBfdGhpcy5yb290U2NlbmUgPSBfdGhpcy5jdXJyZW50U2NlbmUgPSBuZXcgU2NlbmVfMi5TY2VuZShfdGhpcyk7XHJcbiAgICAgICAgICAgIF90aGlzLmFkZFNjZW5lKCdyb290JywgX3RoaXMucm9vdFNjZW5lKTtcclxuICAgICAgICAgICAgX3RoaXMuZ29Ub1NjZW5lKCdyb290Jyk7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVuZ2luZS5wcm90b3R5cGUsIFwiY2FudmFzV2lkdGhcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIHdpZHRoIG9mIHRoZSBnYW1lIGNhbnZhcyBpbiBwaXhlbHMgKHBoeXNpY2FsIHdpZHRoIGNvbXBvbmVudCBvZiB0aGVcclxuICAgICAgICAgICAgICogcmVzb2x1dGlvbiBvZiB0aGUgY2FudmFzIGVsZW1lbnQpXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy53aWR0aDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVuZ2luZS5wcm90b3R5cGUsIFwiaGFsZkNhbnZhc1dpZHRoXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJldHVybnMgaGFsZiB3aWR0aCBvZiB0aGUgZ2FtZSBjYW52YXMgaW4gcGl4ZWxzIChoYWxmIHBoeXNpY2FsIHdpZHRoIGNvbXBvbmVudClcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLndpZHRoIC8gMjtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVuZ2luZS5wcm90b3R5cGUsIFwiY2FudmFzSGVpZ2h0XCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIGdhbWUgY2FudmFzIGluIHBpeGVscywgKHBoeXNpY2FsIGhlaWdodCBjb21wb25lbnQgb2ZcclxuICAgICAgICAgICAgICogdGhlIHJlc29sdXRpb24gb2YgdGhlIGNhbnZhcyBlbGVtZW50KVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYW52YXMuaGVpZ2h0O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW5naW5lLnByb3RvdHlwZSwgXCJoYWxmQ2FudmFzSGVpZ2h0XCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJldHVybnMgaGFsZiBoZWlnaHQgb2YgdGhlIGdhbWUgY2FudmFzIGluIHBpeGVscyAoaGFsZiBwaHlzaWNhbCBoZWlnaHQgY29tcG9uZW50KVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYW52YXMuaGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVuZ2luZS5wcm90b3R5cGUsIFwiZHJhd1dpZHRoXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSBlbmdpbmUncyB2aXNpYmxlIGRyYXdpbmcgc3VyZmFjZSBpbiBwaXhlbHMgaW5jbHVkaW5nIHpvb20gYW5kIGRldmljZSBwaXhlbCByYXRpby5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFNjZW5lICYmIHRoaXMuY3VycmVudFNjZW5lLmNhbWVyYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5jYW52YXNXaWR0aCAvIHRoaXMuY3VycmVudFNjZW5lLmNhbWVyYS5nZXRab29tKCkpIC8gdGhpcy5waXhlbFJhdGlvO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzV2lkdGggLyB0aGlzLnBpeGVsUmF0aW87XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbmdpbmUucHJvdG90eXBlLCBcImhhbGZEcmF3V2lkdGhcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmV0dXJucyBoYWxmIHRoZSB3aWR0aCBvZiB0aGUgZW5naW5lJ3MgdmlzaWJsZSBkcmF3aW5nIHN1cmZhY2UgaW4gcGl4ZWxzIGluY2x1ZGluZyB6b29tIGFuZCBkZXZpY2UgcGl4ZWwgcmF0aW8uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRyYXdXaWR0aCAvIDI7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbmdpbmUucHJvdG90eXBlLCBcImRyYXdIZWlnaHRcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmV0dXJucyB0aGUgaGVpZ2h0IG9mIHRoZSBlbmdpbmUncyB2aXNpYmxlIGRyYXdpbmcgc3VyZmFjZSBpbiBwaXhlbHMgaW5jbHVkaW5nIHpvb20gYW5kIGRldmljZSBwaXhlbCByYXRpby5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFNjZW5lICYmIHRoaXMuY3VycmVudFNjZW5lLmNhbWVyYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5jYW52YXNIZWlnaHQgLyB0aGlzLmN1cnJlbnRTY2VuZS5jYW1lcmEuZ2V0Wm9vbSgpKSAvIHRoaXMucGl4ZWxSYXRpbztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbnZhc0hlaWdodCAvIHRoaXMucGl4ZWxSYXRpbztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVuZ2luZS5wcm90b3R5cGUsIFwiaGFsZkRyYXdIZWlnaHRcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmV0dXJucyBoYWxmIHRoZSBoZWlnaHQgb2YgdGhlIGVuZ2luZSdzIHZpc2libGUgZHJhd2luZyBzdXJmYWNlIGluIHBpeGVscyBpbmNsdWRpbmcgem9vbSBhbmQgZGV2aWNlIHBpeGVsIHJhdGlvLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kcmF3SGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVuZ2luZS5wcm90b3R5cGUsIFwiaXNIaURwaVwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXR1cm5zIHdoZXRoZXIgZXhjYWxpYnVyIGRldGVjdHMgdGhlIGN1cnJlbnQgc2NyZWVuIHRvIGJlIEhpRFBJXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBpeGVsUmF0aW8gIT09IDE7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbmdpbmUucHJvdG90eXBlLCBcInN0YXRzXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFjY2VzcyBbW3N0YXRzXV0gdGhhdCBob2xkcyBmcmFtZSBzdGF0aXN0aWNzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWJ1Zy5zdGF0cztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVuZ2luZS5wcm90b3R5cGUsIFwicGl4ZWxSYXRpb1wiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBjYWxjdWxhdGVkIHBpeGVsIHJhdGlvbiBmb3IgdXNlIGluIHJlbmRlcmluZ1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGV2aWNlUGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGl4ZWxSYXRpbyA9IGRldmljZVBpeGVsUmF0aW87XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGl4ZWxSYXRpbztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgQm91bmRpbmdCb3ggb2YgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgc2NyZWVuXHJcbiAgICAgICAgICogYW5kIHRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSBzY3JlZW4uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5nZXRXb3JsZEJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGxlZnQgPSB0aGlzLnNjcmVlblRvV29ybGRDb29yZGluYXRlcyhBbGdlYnJhXzIyLlZlY3Rvci5aZXJvKS54O1xyXG4gICAgICAgICAgICB2YXIgdG9wID0gdGhpcy5zY3JlZW5Ub1dvcmxkQ29vcmRpbmF0ZXMoQWxnZWJyYV8yMi5WZWN0b3IuWmVybykueTtcclxuICAgICAgICAgICAgdmFyIHJpZ2h0ID0gbGVmdCArIHRoaXMuZHJhd1dpZHRoO1xyXG4gICAgICAgICAgICB2YXIgYm90dG9tID0gdG9wICsgdGhpcy5kcmF3SGVpZ2h0O1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJvdW5kaW5nQm94XzcuQm91bmRpbmdCb3gobGVmdCwgdG9wLCByaWdodCwgYm90dG9tKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbmdpbmUucHJvdG90eXBlLCBcInRpbWVzY2FsZVwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBjdXJyZW50IGVuZ2luZSB0aW1lc2NhbGUgZmFjdG9yIChkZWZhdWx0IGlzIDEuMCB3aGljaCBpcyAxOjEgdGltZSlcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVzY2FsZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHMgdGhlIGN1cnJlbnQgZW5naW5lIHRpbWVzY2FsZSBmYWN0b3IuIFVzZWZ1bCBmb3IgY3JlYXRpbmcgc2xvdy1tb3Rpb24gZWZmZWN0cyBvciBmYXN0LWZvcndhcmQgZWZmZWN0c1xyXG4gICAgICAgICAgICAgKiB3aGVuIHVzaW5nIHRpbWUtYmFzZWQgbW92ZW1lbnQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIDw9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBMb2dfMTQuTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoJ0Nhbm5vdCBzZXQgZW5naW5lLnRpbWVzY2FsZSB0byBhIHZhbHVlIG9mIDAgb3IgbGVzcyB0aGFuIDAuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGltZXNjYWxlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBsYXlzIGEgc3ByaXRlIGFuaW1hdGlvbiBvbiB0aGUgc2NyZWVuIGF0IHRoZSBzcGVjaWZpZWQgYHhgIGFuZCBgeWBcclxuICAgICAgICAgKiAoaW4gZ2FtZSBjb29yZGluYXRlcywgbm90IHNjcmVlbiBwaXhlbHMpLiBUaGVzZSBhbmltYXRpb25zIHBsYXlcclxuICAgICAgICAgKiBpbmRlcGVuZGVudCBvZiBhY3RvcnMsIGFuZCB3aWxsIGJlIGNsZWFuZWQgdXAgaW50ZXJuYWxseSBhcyBzb29uXHJcbiAgICAgICAgICogYXMgdGhleSBhcmUgY29tcGxldGUuIE5vdGUgYW5pbWF0aW9ucyB0aGF0IGxvb3Agd2lsbCBuZXZlciBiZVxyXG4gICAgICAgICAqIGNsZWFuZWQgdXAuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gYW5pbWF0aW9uICBBbmltYXRpb24gdG8gcGxheVxyXG4gICAgICAgICAqIEBwYXJhbSB4ICAgICAgICAgIHggZ2FtZSBjb29yZGluYXRlIHRvIHBsYXkgdGhlIGFuaW1hdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSB5ICAgICAgICAgIHkgZ2FtZSBjb29yZGluYXRlIHRvIHBsYXkgdGhlIGFuaW1hdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUucGxheUFuaW1hdGlvbiA9IGZ1bmN0aW9uIChhbmltYXRpb24sIHgsIHkpIHtcclxuICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9ucy5wdXNoKG5ldyBBbmltYXRpb25Ob2RlKGFuaW1hdGlvbiwgeCwgeSkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhIFtbVGlsZU1hcF1dIHRvIHRoZSBbW2N1cnJlbnRTY2VuZV1dLCBvbmNlIHRoaXMgaXMgZG9uZSB0aGUgVGlsZU1hcFxyXG4gICAgICAgICAqIHdpbGwgYmUgZHJhd24gYW5kIHVwZGF0ZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5hZGRUaWxlTWFwID0gZnVuY3Rpb24gKHRpbGVNYXApIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUuYWRkVGlsZU1hcCh0aWxlTWFwKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgYSBbW1RpbGVNYXBdXSBmcm9tIHRoZSBbW2N1cnJlbnRTY2VuZV1dLCBpdCB3aWxsIG5vIGxvbmdlciBiZSBkcmF3biBvciB1cGRhdGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUucmVtb3ZlVGlsZU1hcCA9IGZ1bmN0aW9uICh0aWxlTWFwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLnJlbW92ZVRpbGVNYXAodGlsZU1hcCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgW1tUaW1lcl1dIHRvIHRoZSBbW2N1cnJlbnRTY2VuZV1dLlxyXG4gICAgICAgICAqIEBwYXJhbSB0aW1lciAgVGhlIHRpbWVyIHRvIGFkZCB0byB0aGUgW1tjdXJyZW50U2NlbmVdXS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBFbmdpbmUucHJvdG90eXBlLmFkZFRpbWVyID0gZnVuY3Rpb24gKHRpbWVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRTY2VuZS5hZGRUaW1lcih0aW1lcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGEgW1tUaW1lcl1dIGZyb20gdGhlIFtbY3VycmVudFNjZW5lXV0uXHJcbiAgICAgICAgICogQHBhcmFtIHRpbWVyICBUaGUgdGltZXIgdG8gcmVtb3ZlIHRvIHRoZSBbW2N1cnJlbnRTY2VuZV1dLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUucmVtb3ZlVGltZXIgPSBmdW5jdGlvbiAodGltZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFNjZW5lLnJlbW92ZVRpbWVyKHRpbWVyKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYSBbW1NjZW5lXV0gdG8gdGhlIGVuZ2luZSwgdGhpbmsgb2Ygc2NlbmVzIGluIEV4Y2FsaWJ1ciBhcyB5b3VcclxuICAgICAgICAgKiB3b3VsZCBsZXZlbHMgb3IgbWVudXMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ga2V5ICBUaGUgbmFtZSBvZiB0aGUgc2NlbmUsIG11c3QgYmUgdW5pcXVlXHJcbiAgICAgICAgICogQHBhcmFtIHNjZW5lIFRoZSBzY2VuZSB0byBhZGQgdG8gdGhlIGVuZ2luZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuYWRkU2NlbmUgPSBmdW5jdGlvbiAoa2V5LCBzY2VuZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zY2VuZXNba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oJ1NjZW5lJywga2V5LCAnYWxyZWFkeSBleGlzdHMgb3ZlcndyaXRpbmcnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNjZW5lc1trZXldID0gc2NlbmU7XHJcbiAgICAgICAgICAgIHNjZW5lLmVuZ2luZSA9IHRoaXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAaW50ZXJuYWxcclxuICAgICAgICAgKi9cclxuICAgICAgICBFbmdpbmUucHJvdG90eXBlLnJlbW92ZVNjZW5lID0gZnVuY3Rpb24gKGVudGl0eSkge1xyXG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgU2NlbmVfMi5TY2VuZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHNjZW5lXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5zY2VuZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zY2VuZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zY2VuZXNba2V5XSA9PT0gZW50aXR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zY2VuZXNba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGVudGl0eSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBzY2VuZVxyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2NlbmVzW2VudGl0eV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGVudGl0eSkge1xyXG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgVUlBY3Rvcl8zLlVJQWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLmFkZFVJQWN0b3IoZW50aXR5KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgQWN0b3JfMTIuQWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FkZENoaWxkKGVudGl0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIFRpbWVyXzIuVGltZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkVGltZXIoZW50aXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgVGlsZU1hcF8yLlRpbGVNYXApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkVGlsZU1hcChlbnRpdHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFNjZW5lKGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoZW50aXR5KSB7XHJcbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBVSUFjdG9yXzMuVUlBY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUucmVtb3ZlVUlBY3RvcihlbnRpdHkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBBY3Rvcl8xMi5BY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQ2hpbGQoZW50aXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgVGltZXJfMi5UaW1lcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVUaW1lcihlbnRpdHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBUaWxlTWFwXzIuVGlsZU1hcCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVUaWxlTWFwKGVudGl0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIFNjZW5lXzIuU2NlbmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlU2NlbmUoZW50aXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGVudGl0eSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlU2NlbmUoZW50aXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhbiBhY3RvciB0byB0aGUgW1tjdXJyZW50U2NlbmVdXSBvZiB0aGUgZ2FtZS4gVGhpcyBpcyBzeW5vbnltb3VzXHJcbiAgICAgICAgICogdG8gY2FsbGluZyBgZW5naW5lLmN1cnJlbnRTY2VuZS5hZGQoYWN0b3IpYC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEFjdG9ycyBjYW4gb25seSBiZSBkcmF3biBpZiB0aGV5IGFyZSBhIG1lbWJlciBvZiBhIHNjZW5lLCBhbmQgb25seVxyXG4gICAgICAgICAqIHRoZSBbW2N1cnJlbnRTY2VuZV1dIG1heSBiZSBkcmF3biBvciB1cGRhdGVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGFjdG9yICBUaGUgYWN0b3IgdG8gYWRkIHRvIHRoZSBbW2N1cnJlbnRTY2VuZV1dXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5fYWRkQ2hpbGQgPSBmdW5jdGlvbiAoYWN0b3IpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUuYWRkKGFjdG9yKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgYW4gYWN0b3IgZnJvbSB0aGUgW1tjdXJyZW50U2NlbmVdXSBvZiB0aGUgZ2FtZS4gVGhpcyBpcyBzeW5vbnltb3VzXHJcbiAgICAgICAgICogdG8gY2FsbGluZyBgZW5naW5lLmN1cnJlbnRTY2VuZS5yZW1vdmUoYWN0b3IpYC5cclxuICAgICAgICAgKiBBY3RvcnMgdGhhdCBhcmUgcmVtb3ZlZCBmcm9tIGEgc2NlbmUgd2lsbCBubyBsb25nZXIgYmUgZHJhd24gb3IgdXBkYXRlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBhY3RvciAgVGhlIGFjdG9yIHRvIHJlbW92ZSBmcm9tIHRoZSBbW2N1cnJlbnRTY2VuZV1dLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuX3JlbW92ZUNoaWxkID0gZnVuY3Rpb24gKGFjdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLnJlbW92ZShhY3Rvcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGFuZ2VzIHRoZSBjdXJyZW50bHkgdXBkYXRpbmcgYW5kIGRyYXdpbmcgc2NlbmUgdG8gYSBkaWZmZXJlbnQsXHJcbiAgICAgICAgICogbmFtZWQgc2NlbmUuIENhbGxzIHRoZSBbW1NjZW5lXV0gbGlmZWN5Y2xlIGV2ZW50cy5cclxuICAgICAgICAgKiBAcGFyYW0ga2V5ICBUaGUga2V5IG9mIHRoZSBzY2VuZSB0byB0cmFuc2l0aW9uIHRvLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuZ29Ub1NjZW5lID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zY2VuZXNba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9sZFNjZW5lID0gdGhpcy5jdXJyZW50U2NlbmU7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3U2NlbmUgPSB0aGlzLnNjZW5lc1trZXldO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCdHb2luZyB0byBzY2VuZTonLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgLy8gb25seSBkZWFjdGl2YXRlIHdoZW4gaW5pdGlhbGl6ZWRcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRTY2VuZS5pc0luaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUub25EZWFjdGl2YXRlLmNhbGwodGhpcy5jdXJyZW50U2NlbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLmV2ZW50RGlzcGF0Y2hlci5lbWl0KCdkZWFjdGl2YXRlJywgbmV3IEV2ZW50c18xMi5EZWFjdGl2YXRlRXZlbnQobmV3U2NlbmUsIHRoaXMuY3VycmVudFNjZW5lKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBzZXQgY3VycmVudCBzY2VuZSB0byBuZXcgb25lXHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZSA9IG5ld1NjZW5lO1xyXG4gICAgICAgICAgICAgICAgLy8gaW5pdGlhbGl6ZSB0aGUgY3VycmVudCBzY2VuZSBpZiBoYXMgbm90IGJlZW4gYWxyZWFkeVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUuX2luaXRpYWxpemUodGhpcyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5vbkFjdGl2YXRlLmNhbGwodGhpcy5jdXJyZW50U2NlbmUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ2FjdGl2YXRlJywgbmV3IEV2ZW50c18xMi5BY3RpdmF0ZUV2ZW50KG9sZFNjZW5lLCB0aGlzLmN1cnJlbnRTY2VuZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKCdTY2VuZScsIGtleSwgJ2RvZXMgbm90IGV4aXN0IScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUcmFuc2Zvcm1zIHRoZSBjdXJyZW50IHgsIHkgZnJvbSBzY3JlZW4gY29vcmRpbmF0ZXMgdG8gd29ybGQgY29vcmRpbmF0ZXNcclxuICAgICAgICAgKiBAcGFyYW0gcG9pbnQgIFNjcmVlbiBjb29yZGluYXRlIHRvIGNvbnZlcnRcclxuICAgICAgICAgKi9cclxuICAgICAgICBFbmdpbmUucHJvdG90eXBlLnNjcmVlblRvV29ybGRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gICAgICAgICAgICB2YXIgbmV3WCA9IHBvaW50Lng7XHJcbiAgICAgICAgICAgIHZhciBuZXdZID0gcG9pbnQueTtcclxuICAgICAgICAgICAgLy8gdHJhbnNmb3JtIGJhY2sgdG8gd29ybGQgc3BhY2VcclxuICAgICAgICAgICAgbmV3WCA9IChuZXdYIC8gdGhpcy5jYW52YXMuY2xpZW50V2lkdGgpICogdGhpcy5kcmF3V2lkdGg7XHJcbiAgICAgICAgICAgIG5ld1kgPSAobmV3WSAvIHRoaXMuY2FudmFzLmNsaWVudEhlaWdodCkgKiB0aGlzLmRyYXdIZWlnaHQ7XHJcbiAgICAgICAgICAgIC8vIHRyYW5zZm9ybSBiYXNlZCBvbiB6b29tXHJcbiAgICAgICAgICAgIG5ld1ggPSBuZXdYIC0gdGhpcy5oYWxmRHJhd1dpZHRoO1xyXG4gICAgICAgICAgICBuZXdZID0gbmV3WSAtIHRoaXMuaGFsZkRyYXdIZWlnaHQ7XHJcbiAgICAgICAgICAgIC8vIHNoaWZ0IGJ5IGZvY3VzXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRTY2VuZSAmJiB0aGlzLmN1cnJlbnRTY2VuZS5jYW1lcmEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmb2N1cyA9IHRoaXMuY3VycmVudFNjZW5lLmNhbWVyYS5nZXRGb2N1cygpO1xyXG4gICAgICAgICAgICAgICAgbmV3WCArPSBmb2N1cy54O1xyXG4gICAgICAgICAgICAgICAgbmV3WSArPSBmb2N1cy55O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWxnZWJyYV8yMi5WZWN0b3IoTWF0aC5mbG9vcihuZXdYKSwgTWF0aC5mbG9vcihuZXdZKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUcmFuc2Zvcm1zIGEgd29ybGQgY29vcmRpbmF0ZSwgdG8gYSBzY3JlZW4gY29vcmRpbmF0ZVxyXG4gICAgICAgICAqIEBwYXJhbSBwb2ludCAgV29ybGQgY29vcmRpbmF0ZSB0byBjb252ZXJ0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS53b3JsZFRvU2NyZWVuQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbiAocG9pbnQpIHtcclxuICAgICAgICAgICAgdmFyIHNjcmVlblggPSBwb2ludC54O1xyXG4gICAgICAgICAgICB2YXIgc2NyZWVuWSA9IHBvaW50Lnk7XHJcbiAgICAgICAgICAgIC8vIHNoaWZ0IGJ5IGZvY3VzXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRTY2VuZSAmJiB0aGlzLmN1cnJlbnRTY2VuZS5jYW1lcmEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmb2N1cyA9IHRoaXMuY3VycmVudFNjZW5lLmNhbWVyYS5nZXRGb2N1cygpO1xyXG4gICAgICAgICAgICAgICAgc2NyZWVuWCAtPSBmb2N1cy54O1xyXG4gICAgICAgICAgICAgICAgc2NyZWVuWSAtPSBmb2N1cy55O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHRyYW5zZm9ybSBiYWNrIG9uIHpvb21cclxuICAgICAgICAgICAgc2NyZWVuWCA9IHNjcmVlblggKyB0aGlzLmhhbGZEcmF3V2lkdGg7XHJcbiAgICAgICAgICAgIHNjcmVlblkgPSBzY3JlZW5ZICsgdGhpcy5oYWxmRHJhd0hlaWdodDtcclxuICAgICAgICAgICAgLy8gdHJhbnNmb3JtIGJhY2sgdG8gc2NyZWVuIHNwYWNlXHJcbiAgICAgICAgICAgIHNjcmVlblggPSAoc2NyZWVuWCAqIHRoaXMuY2FudmFzLmNsaWVudFdpZHRoKSAvIHRoaXMuZHJhd1dpZHRoO1xyXG4gICAgICAgICAgICBzY3JlZW5ZID0gKHNjcmVlblkgKiB0aGlzLmNhbnZhcy5jbGllbnRIZWlnaHQpIC8gdGhpcy5kcmF3SGVpZ2h0O1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFsZ2VicmFfMjIuVmVjdG9yKE1hdGguZmxvb3Ioc2NyZWVuWCksIE1hdGguZmxvb3Ioc2NyZWVuWSkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgaW50ZXJuYWwgY2FudmFzIGhlaWdodCBiYXNlZCBvbiB0aGUgc2VsZWN0ZWQgZGlzcGxheSBtb2RlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuX3NldEhlaWdodEJ5RGlzcGxheU1vZGUgPSBmdW5jdGlvbiAocGFyZW50KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRpc3BsYXlNb2RlID09PSBEaXNwbGF5TW9kZS5Db250YWluZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gcGFyZW50LmNsaWVudFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gcGFyZW50LmNsaWVudEhlaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5kaXNwbGF5TW9kZSA9PT0gRGlzcGxheU1vZGUuRnVsbFNjcmVlbikge1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5tYXJnaW4gPSAnMHB4JztcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gcGFyZW50LmlubmVyV2lkdGg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSBwYXJlbnQuaW5uZXJIZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluaXRpYWxpemVzIHRoZSBpbnRlcm5hbCBjYW52YXMsIHJlbmRlcmluZyBjb250ZXh0LCBkaXNwbGF5bW9kZSwgYW5kIG5hdGl2ZSBldmVudCBsaXN0ZW5lcnNcclxuICAgICAgICAgKi9cclxuICAgICAgICBFbmdpbmUucHJvdG90eXBlLl9pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGlzcGxheU1vZGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheU1vZGUgPSBvcHRpb25zLmRpc3BsYXlNb2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRpc3BsYXlNb2RlID09PSBEaXNwbGF5TW9kZS5GdWxsU2NyZWVuIHx8IHRoaXMuZGlzcGxheU1vZGUgPT09IERpc3BsYXlNb2RlLkNvbnRhaW5lcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9ICh0aGlzLmRpc3BsYXlNb2RlID09PSBEaXNwbGF5TW9kZS5Db250YWluZXIgP1xyXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLmNhbnZhcy5wYXJlbnRFbGVtZW50IHx8IGRvY3VtZW50LmJvZHkpIDogd2luZG93KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NldEhlaWdodEJ5RGlzcGxheU1vZGUocGFyZW50KTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci5kZWJ1ZygnVmlldyBwb3J0IHJlc2l6ZWQnKTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2V0SGVpZ2h0QnlEaXNwbGF5TW9kZShwYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuaW5mbygncGFyZW50LmNsaWVudEhlaWdodCAnICsgcGFyZW50LmNsaWVudEhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0QW50aWFsaWFzaW5nKF90aGlzLl9pc1Ntb290aGluZ0VuYWJsZWQpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5kaXNwbGF5TW9kZSA9PT0gRGlzcGxheU1vZGUuUG9zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ludGlhbGl6ZURpc3BsYXlNb2RlUG9zaXRpb24ob3B0aW9ucyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaW5pdGlhbGl6ZSBpbnB1dHNcclxuICAgICAgICAgICAgdGhpcy5pbnB1dCA9IHtcclxuICAgICAgICAgICAgICAgIGtleWJvYXJkOiBuZXcgSW5wdXQuS2V5Ym9hcmQoKSxcclxuICAgICAgICAgICAgICAgIHBvaW50ZXJzOiBuZXcgSW5wdXQuUG9pbnRlcnModGhpcyksXHJcbiAgICAgICAgICAgICAgICBnYW1lcGFkczogbmV3IElucHV0LkdhbWVwYWRzKClcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5pbnB1dC5rZXlib2FyZC5pbml0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXQucG9pbnRlcnMuaW5pdChvcHRpb25zICYmIG9wdGlvbnMucG9pbnRlclNjb3BlID09PSBJbnB1dC5Qb2ludGVyU2NvcGUuRG9jdW1lbnQgPyBkb2N1bWVudCA6IHRoaXMuY2FudmFzKTtcclxuICAgICAgICAgICAgdGhpcy5pbnB1dC5nYW1lcGFkcy5pbml0KCk7XHJcbiAgICAgICAgICAgIHRoaXMucGFnZVNjcm9sbFByZXZlbnRpb25Nb2RlID0gb3B0aW9ucy5zY3JvbGxQcmV2ZW50aW9uTW9kZTtcclxuICAgICAgICAgICAgLy8gSXNzdWUgIzM4NSBtYWtlIHVzZSBvZiB0aGUgdmlzaWJpbGl0eSBhcGlcclxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvR3VpZGUvVXNlcl9leHBlcmllbmNlL1VzaW5nX3RoZV9QYWdlX1Zpc2liaWxpdHlfQVBJXHJcbiAgICAgICAgICAgIHZhciBoaWRkZW4sIHZpc2liaWxpdHlDaGFuZ2U7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQuaGlkZGVuICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgaGlkZGVuID0gJ2hpZGRlbic7XHJcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5Q2hhbmdlID0gJ3Zpc2liaWxpdHljaGFuZ2UnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCdtc0hpZGRlbicgaW4gZG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIGhpZGRlbiA9ICdtc0hpZGRlbic7XHJcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5Q2hhbmdlID0gJ21zdmlzaWJpbGl0eWNoYW5nZSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoJ3dlYmtpdEhpZGRlbicgaW4gZG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIGhpZGRlbiA9ICd3ZWJraXRIaWRkZW4nO1xyXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eUNoYW5nZSA9ICd3ZWJraXR2aXNpYmlsaXR5Y2hhbmdlJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKHZpc2liaWxpdHlDaGFuZ2UsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudFtoaWRkZW5dKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ2hpZGRlbicsIG5ldyBFdmVudHNfMTIuSGlkZGVuRXZlbnQoX3RoaXMpKTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmRlYnVnKCdXaW5kb3cgaGlkZGVuJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ldmVudERpc3BhdGNoZXIuZW1pdCgndmlzaWJsZScsIG5ldyBFdmVudHNfMTIuVmlzaWJsZUV2ZW50KF90aGlzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci5kZWJ1ZygnV2luZG93IHZpc2libGUnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnN1cHByZXNzSGlEUElTY2FsaW5nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplSGlEcGkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuY2FudmFzRWxlbWVudElkKSB7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuY2FudmFzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5faW50aWFsaXplRGlzcGxheU1vZGVQb3NpdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5wb3NpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaXNwbGF5TW9kZSBvZiBQb3NpdGlvbiB3YXMgc2VsZWN0ZWQgYnV0IG5vIHBvc2l0aW9uIG9wdGlvbiB3YXMgZ2l2ZW4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnBvc2l0aW9uID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzcGVjaWZpZWRQb3NpdGlvbiA9IG9wdGlvbnMucG9zaXRpb24uc3BsaXQoJyAnKTtcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHNwZWNpZmllZFBvc2l0aW9uWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RvcCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS50b3AgPSAnMHB4JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdib3R0b20nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUuYm90dG9tID0gJzBweCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWlkZGxlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLnRvcCA9ICc1MCUnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldFkgPSAtdGhpcy5oYWxmRHJhd0hlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLm1hcmdpblRvcCA9IG9mZnNldFkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFBvc2l0aW9uIEdpdmVuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGVjaWZpZWRQb3NpdGlvblsxXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHNwZWNpZmllZFBvc2l0aW9uWzFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdsZWZ0JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5sZWZ0ID0gJzBweCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdyaWdodCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUucmlnaHQgPSAnMHB4JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUubGVmdCA9ICc1MCUnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXRYID0gLXRoaXMuaGFsZkRyYXdXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5tYXJnaW5MZWZ0ID0gb2Zmc2V0WC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUG9zaXRpb24gR2l2ZW4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnBvc2l0aW9uLnRvcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygb3B0aW9ucy5wb3NpdGlvbi50b3AgPT09ICdudW1iZXInID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLnRvcCA9IG9wdGlvbnMucG9zaXRpb24udG9wLnRvU3RyaW5nKCkgKyAncHgnIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLnRvcCA9IG9wdGlvbnMucG9zaXRpb24udG9wO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5wb3NpdGlvbi5yaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygb3B0aW9ucy5wb3NpdGlvbi5yaWdodCA9PT0gJ251bWJlcicgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUucmlnaHQgPSBvcHRpb25zLnBvc2l0aW9uLnJpZ2h0LnRvU3RyaW5nKCkgKyAncHgnIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLnJpZ2h0ID0gb3B0aW9ucy5wb3NpdGlvbi5yaWdodDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucG9zaXRpb24uYm90dG9tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBvcHRpb25zLnBvc2l0aW9uLmJvdHRvbSA9PT0gJ251bWJlcicgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUuYm90dG9tID0gb3B0aW9ucy5wb3NpdGlvbi5ib3R0b20udG9TdHJpbmcoKSArICdweCcgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUuYm90dG9tID0gb3B0aW9ucy5wb3NpdGlvbi5ib3R0b207XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnBvc2l0aW9uLmxlZnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIG9wdGlvbnMucG9zaXRpb24ubGVmdCA9PT0gJ251bWJlcicgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUubGVmdCA9IG9wdGlvbnMucG9zaXRpb24ubGVmdC50b1N0cmluZygpICsgJ3B4JyA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5sZWZ0ID0gb3B0aW9ucy5wb3NpdGlvbi5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5faW5pdGlhbGl6ZUhpRHBpID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBTY2FsZSB0aGUgY2FudmFzIGlmIG5lZWRlZFxyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0hpRHBpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2xkV2lkdGggPSB0aGlzLmNhbnZhcy53aWR0aDtcclxuICAgICAgICAgICAgICAgIHZhciBvbGRIZWlnaHQgPSB0aGlzLmNhbnZhcy5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IG9sZFdpZHRoICogdGhpcy5waXhlbFJhdGlvO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gb2xkSGVpZ2h0ICogdGhpcy5waXhlbFJhdGlvO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUud2lkdGggPSBvbGRXaWR0aCArICdweCc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5oZWlnaHQgPSBvbGRIZWlnaHQgKyAncHgnO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oXCJIaSBEUEkgc2NyZWVuIGRldGVjdGVkLCByZXNldHRpbmcgY2FudmFzIHJlc29sdXRpb24gZnJvbSBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBcIiArIG9sZFdpZHRoICsgXCJ4XCIgKyBvbGRIZWlnaHQgKyBcIiB0byBcIiArIHRoaXMuY2FudmFzLndpZHRoICsgXCJ4XCIgKyB0aGlzLmNhbnZhcy5oZWlnaHQgKyBcIiBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjc3Mgc2l6ZSB3aWxsIHJlbWFpbiBcIiArIG9sZFdpZHRoICsgXCJ4XCIgKyBvbGRIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdHguc2NhbGUodGhpcy5waXhlbFJhdGlvLCB0aGlzLnBpeGVsUmF0aW8pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oXCJDYW52YXMgZHJhd2luZyBjb250ZXh0IHdhcyBzY2FsZWQgYnkgXCIgKyB0aGlzLnBpeGVsUmF0aW8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXIsIHRoaXMgd2lsbCBzZXQgdGhlIGFudGlhbGlhc2luZyBmbGFnIG9uIHRoZVxyXG4gICAgICAgICAqIGNhbnZhcy4gU2V0IHRoaXMgdG8gYGZhbHNlYCBpZiB5b3Ugd2FudCBhICdqYWdnZWQnIHBpeGVsIGFydCBsb29rIHRvIHlvdXJcclxuICAgICAgICAgKiBpbWFnZSByZXNvdXJjZXMuXHJcbiAgICAgICAgICogQHBhcmFtIGlzU21vb3RoICBTZXQgc21vb3RoaW5nIHRvIHRydWUgb3IgZmFsc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBFbmdpbmUucHJvdG90eXBlLnNldEFudGlhbGlhc2luZyA9IGZ1bmN0aW9uIChpc1Ntb290aCkge1xyXG4gICAgICAgICAgICB0aGlzLl9pc1Ntb290aGluZ0VuYWJsZWQgPSBpc1Ntb290aDtcclxuICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuY3R4O1xyXG4gICAgICAgICAgICBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gaXNTbW9vdGg7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBbJ3dlYmtpdEltYWdlU21vb3RoaW5nRW5hYmxlZCcsICdtb3pJbWFnZVNtb290aGluZ0VuYWJsZWQnLCAnbXNJbWFnZVNtb290aGluZ0VuYWJsZWQnXTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBzbW9vdGhpbmcgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoc21vb3RoaW5nIGluIGN0eCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eFtzbW9vdGhpbmddID0gaXNTbW9vdGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJuIHRoZSBjdXJyZW50IHNtb290aGluZyBzdGF0dXMgb2YgdGhlIGNhbnZhc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuZ2V0QW50aWFsaWFzaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkIHx8XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN0eC53ZWJraXRJbWFnZVNtb290aGluZ0VuYWJsZWQgfHxcclxuICAgICAgICAgICAgICAgIHRoaXMuY3R4Lm1vekltYWdlU21vb3RoaW5nRW5hYmxlZCB8fFxyXG4gICAgICAgICAgICAgICAgdGhpcy5jdHgubXNJbWFnZVNtb290aGluZ0VuYWJsZWQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGVzIHRoZSBlbnRpcmUgc3RhdGUgb2YgdGhlIGdhbWVcclxuICAgICAgICAgKiBAcGFyYW0gZGVsdGEgIE51bWJlciBvZiBtaWxsaXNlY29uZHMgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB1cGRhdGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0xvYWRpbmcpIHtcclxuICAgICAgICAgICAgICAgIC8vIHN1c3BlbmQgdXBkYXRlcyB1bnRpbGwgbG9hZGluZyBpcyBmaW5pc2hlZFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZGVyLnVwZGF0ZSh0aGlzLCBkZWx0YSk7XHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgaW5wdXQgbGlzdGVuZXJzXHJcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0LmtleWJvYXJkLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dC5wb2ludGVycy51cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQuZ2FtZXBhZHMudXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdwcmV1cGRhdGUnLCBuZXcgRXZlbnRzXzEyLlByZVVwZGF0ZUV2ZW50KHRoaXMsIGRlbHRhLCB0aGlzKSk7XHJcbiAgICAgICAgICAgIC8vIHByb2Nlc3MgZW5naW5lIGxldmVsIGV2ZW50c1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS51cGRhdGUodGhpcywgZGVsdGEpO1xyXG4gICAgICAgICAgICAvLyB1cGRhdGUgYW5pbWF0aW9uc1xyXG4gICAgICAgICAgICB0aGlzLl9hbmltYXRpb25zID0gdGhpcy5fYW5pbWF0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhYS5hbmltYXRpb24uaXNEb25lKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyBVcGRhdGUgaW5wdXQgbGlzdGVuZXJzXHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXQua2V5Ym9hcmQudXBkYXRlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXQucG9pbnRlcnMudXBkYXRlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXQuZ2FtZXBhZHMudXBkYXRlKCk7XHJcbiAgICAgICAgICAgIC8vIFB1Ymxpc2ggdXBkYXRlIGV2ZW50XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncG9zdHVwZGF0ZScsIG5ldyBFdmVudHNfMTIuUG9zdFVwZGF0ZUV2ZW50KHRoaXMsIGRlbHRhLCB0aGlzKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEcmF3cyB0aGUgZW50aXJlIGdhbWVcclxuICAgICAgICAgKiBAcGFyYW0gZGVsdGEgIE51bWJlciBvZiBtaWxsaXNlY29uZHMgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCBkcmF3LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuX2RyYXcgPSBmdW5jdGlvbiAoZGVsdGEpIHtcclxuICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuY3R4O1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3ByZWRyYXcnLCBuZXcgRXZlbnRzXzEyLlByZURyYXdFdmVudChjdHgsIGRlbHRhLCB0aGlzKSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0xvYWRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRlci5kcmF3KGN0eCwgZGVsdGEpO1xyXG4gICAgICAgICAgICAgICAgLy8gRHJhd2luZyBub3RoaW5nIGVsc2Ugd2hpbGUgbG9hZGluZ1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jYW52YXNXaWR0aCwgdGhpcy5jYW52YXNIZWlnaHQpO1xyXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5iYWNrZ3JvdW5kQ29sb3IudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMuY2FudmFzV2lkdGgsIHRoaXMuY2FudmFzSGVpZ2h0KTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUuZHJhdyh0aGlzLmN0eCwgZGVsdGEpO1xyXG4gICAgICAgICAgICAvLyB0b2RvIG5lZWRzIHRvIGJlIGEgYmV0dGVyIHdheSBvZiBkb2luZyB0aGlzXHJcbiAgICAgICAgICAgIHZhciBhID0gMCwgbGVuID0gdGhpcy5fYW5pbWF0aW9ucy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoYTsgYSA8IGxlbjsgYSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hbmltYXRpb25zW2FdLmFuaW1hdGlvbi5kcmF3KGN0eCwgdGhpcy5fYW5pbWF0aW9uc1thXS54LCB0aGlzLl9hbmltYXRpb25zW2FdLnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIERyYXcgZGVidWcgaW5mb3JtYXRpb25cclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNEZWJ1Zykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdHguZm9udCA9ICdDb25zb2xhcyc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSB0aGlzLmRlYnVnQ29sb3IudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIHZhciBrZXlzID0gdGhpcy5pbnB1dC5rZXlib2FyZC5nZXRLZXlzKCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN0eC5maWxsVGV4dChrZXlzW2pdLnRvU3RyaW5nKCkgKyAnIDogJyArIChJbnB1dC5LZXlzW2tleXNbal1dID8gSW5wdXQuS2V5c1trZXlzW2pdXSA6ICdOb3QgTWFwcGVkJyksIDEwMCwgMTAgKiBqICsgMTApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jdHguZmlsbFRleHQoJ0ZQUzonICsgdGhpcy5zdGF0cy5jdXJyRnJhbWUuZnBzLnRvRml4ZWQoMikudG9TdHJpbmcoKSwgMTAsIDEwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBQb3N0IHByb2Nlc3NpbmdcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBvc3RQcm9jZXNzb3JzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvc3RQcm9jZXNzb3JzW2ldLnByb2Nlc3ModGhpcy5jdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHRoaXMuY2FudmFzV2lkdGgsIHRoaXMuY2FudmFzSGVpZ2h0KSwgdGhpcy5jdHgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncG9zdGRyYXcnLCBuZXcgRXZlbnRzXzEyLlBvc3REcmF3RXZlbnQoY3R4LCBkZWx0YSwgdGhpcykpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3RhcnRzIHRoZSBpbnRlcm5hbCBnYW1lIGxvb3AgZm9yIEV4Y2FsaWJ1ciBhZnRlciBsb2FkaW5nXHJcbiAgICAgICAgICogYW55IHByb3ZpZGVkIGFzc2V0cy5cclxuICAgICAgICAgKiBAcGFyYW0gbG9hZGVyICBPcHRpb25hbCBbW0lMb2FkZXJdXSB0byB1c2UgdG8gbG9hZCByZXNvdXJjZXMuIFRoZSBkZWZhdWx0IGxvYWRlciBpcyBbW0xvYWRlcl1dLCBvdmVycmlkZSB0byBwcm92aWRlIHlvdXIgb3duXHJcbiAgICAgICAgICogY3VzdG9tIGxvYWRlci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBFbmdpbmUucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKGxvYWRlcikge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2NvbXBhdGlibGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2VzXzguUHJvbWlzZSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2UucmVqZWN0KCdFeGNhbGlidXIgaXMgaW5jb21wYXRpYmxlIHdpdGggeW91ciBicm93c2VyJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGxvYWRpbmdDb21wbGV0ZTtcclxuICAgICAgICAgICAgaWYgKGxvYWRlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZGVyID0gbG9hZGVyO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZGVyLndpcmVFbmdpbmUodGhpcyk7XHJcbiAgICAgICAgICAgICAgICBsb2FkaW5nQ29tcGxldGUgPSB0aGlzLmxvYWQodGhpcy5fbG9hZGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxvYWRpbmdDb21wbGV0ZSA9IFByb21pc2VzXzguUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbG9hZGluZ0NvbXBsZXRlLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgnc3RhcnQnLCBuZXcgRXZlbnRzXzEyLkdhbWVTdGFydEV2ZW50KF90aGlzKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2hhc1N0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2hhc1N0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCdTdGFydGluZyBnYW1lLi4uJyk7XHJcbiAgICAgICAgICAgICAgICBFbmdpbmUuY3JlYXRlTWFpbkxvb3AodGhpcywgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSwgRGF0ZS5ub3cpKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoJ0dhbWUgc3RhcnRlZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gR2FtZSBhbHJlYWR5IHN0YXJ0ZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGxvYWRpbmdDb21wbGV0ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEVuZ2luZS5jcmVhdGVNYWluTG9vcCA9IGZ1bmN0aW9uIChnYW1lLCByYWYsIG5vd0ZuKSB7XHJcbiAgICAgICAgICAgIHZhciBsYXN0VGltZSA9IG5vd0ZuKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBtYWlubG9vcCgpIHtcclxuICAgICAgICAgICAgICAgIGlmICghZ2FtZS5faGFzU3RhcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2FtZS5fcmVxdWVzdElkID0gcmFmKG1haW5sb29wKTtcclxuICAgICAgICAgICAgICAgICAgICBnYW1lLmVtaXQoJ3ByZWZyYW1lJywgbmV3IEV2ZW50c18xMi5QcmVGcmFtZUV2ZW50KGdhbWUsIGdhbWUuc3RhdHMucHJldkZyYW1lKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSB0aW1lIHRvIGNhbGN1bGF0ZSB0aW1lLWVsYXBzZWRcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbm93ID0gbm93Rm4oKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxhcHNlZCA9IE1hdGguZmxvb3Iobm93IC0gbGFzdFRpbWUpIHx8IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzb2x2ZXMgaXNzdWUgIzEzOCBpZiB0aGUgZ2FtZSBoYXMgYmVlbiBwYXVzZWQsIG9yIGJsdXJyZWQgZm9yIFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vcmUgdGhhbiBhIDIwMCBtaWxsaXNlY29uZHMsIHJlc2V0IGVsYXBzZWQgdGltZSB0byAxLiBUaGlzIGltcHJvdmVzIHJlbGlhYmlsaXR5IFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBwcm92aWRlcyBtb3JlIGV4cGVjdGVkIGJlaGF2aW9yIHdoZW4gdGhlIGVuZ2luZSBjb21lcyBiYWNrXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW50byBmb2N1c1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGFwc2VkID4gMjAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsYXBzZWQgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGEgPSBlbGFwc2VkICogZ2FtZS50aW1lc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzZXQgZnJhbWUgc3RhdHMgKHJldXNlIGV4aXN0aW5nIGluc3RhbmNlcylcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWVJZCA9IGdhbWUuc3RhdHMucHJldkZyYW1lLmlkICsgMTtcclxuICAgICAgICAgICAgICAgICAgICBnYW1lLnN0YXRzLnByZXZGcmFtZS5yZXNldChnYW1lLnN0YXRzLmN1cnJGcmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2FtZS5zdGF0cy5jdXJyRnJhbWUucmVzZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICBnYW1lLnN0YXRzLmN1cnJGcmFtZS5pZCA9IGZyYW1lSWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2FtZS5zdGF0cy5jdXJyRnJhbWUuZGVsdGEgPSBkZWx0YTtcclxuICAgICAgICAgICAgICAgICAgICBnYW1lLnN0YXRzLmN1cnJGcmFtZS5mcHMgPSAxLjAgLyAoZGVsdGEgLyAxMDAwKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYmVmb3JlVXBkYXRlID0gbm93Rm4oKTtcclxuICAgICAgICAgICAgICAgICAgICBnYW1lLl91cGRhdGUoZGVsdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhZnRlclVwZGF0ZSA9IG5vd0ZuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2FtZS5fZHJhdyhkZWx0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFmdGVyRHJhdyA9IG5vd0ZuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2FtZS5zdGF0cy5jdXJyRnJhbWUuZHVyYXRpb24udXBkYXRlID0gYWZ0ZXJVcGRhdGUgLSBiZWZvcmVVcGRhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2FtZS5zdGF0cy5jdXJyRnJhbWUuZHVyYXRpb24uZHJhdyA9IGFmdGVyRHJhdyAtIGFmdGVyVXBkYXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RUaW1lID0gbm93O1xyXG4gICAgICAgICAgICAgICAgICAgIGdhbWUuZW1pdCgncG9zdGZyYW1lJywgbmV3IEV2ZW50c18xMi5Qb3N0RnJhbWVFdmVudChnYW1lLCBnYW1lLnN0YXRzLmN1cnJGcmFtZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoZ2FtZS5fcmVxdWVzdElkKTtcclxuICAgICAgICAgICAgICAgICAgICBnYW1lLnN0b3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBnYW1lLm9uRmF0YWxFeGNlcHRpb24oZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTdG9wcyBFeGNhbGlidXIncyBtYWluIGxvb3AsIHVzZWZ1bCBmb3IgcGF1c2luZyB0aGUgZ2FtZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBFbmdpbmUucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9oYXNTdGFydGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3N0b3AnLCBuZXcgRXZlbnRzXzEyLkdhbWVTdG9wRXZlbnQodGhpcykpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faGFzU3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCdHYW1lIHN0b3BwZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgRW5naW5lJ3MgUnVubmluZyBzdGF0dXMsIFVzZWZ1bCBmb3IgY2hlY2tpbmcgd2hldGhlciBlbmdpbmUgaXMgcnVubmluZyBvciBwYXVzZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICEodGhpcy5faGFzU3RhcnRlZCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUYWtlcyBhIHNjcmVlbiBzaG90IG9mIHRoZSBjdXJyZW50IHZpZXdwb3J0IGFuZCByZXR1cm5zIGl0IGFzIGFuXHJcbiAgICAgICAgICogSFRNTCBJbWFnZSBFbGVtZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuc2NyZWVuc2hvdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgICAgICB2YXIgcmF3ID0gdGhpcy5jYW52YXMudG9EYXRhVVJMKCdpbWFnZS9wbmcnKTtcclxuICAgICAgICAgICAgcmVzdWx0LnNyYyA9IHJhdztcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFub3RoZXIgb3B0aW9uIGF2YWlsYWJsZSB0byB5b3UgdG8gbG9hZCByZXNvdXJjZXMgaW50byB0aGUgZ2FtZS5cclxuICAgICAgICAgKiBJbW1lZGlhdGVseSBhZnRlciBjYWxsaW5nIHRoaXMgdGhlIGdhbWUgd2lsbCBwYXVzZSBhbmQgdGhlIGxvYWRpbmcgc2NyZWVuXHJcbiAgICAgICAgICogd2lsbCBhcHBlYXIuXHJcbiAgICAgICAgICogQHBhcmFtIGxvYWRlciAgU29tZSBbW0lMb2FkYWJsZV1dIHN1Y2ggYXMgYSBbW0xvYWRlcl1dIGNvbGxlY3Rpb24sIFtbU291bmRdXSwgb3IgW1tUZXh0dXJlXV0uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKGxvYWRlcikge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgY29tcGxldGUgPSBuZXcgUHJvbWlzZXNfOC5Qcm9taXNlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzTG9hZGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIGxvYWRlci5sb2FkKCkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5faXNMb2FkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGUucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfSwgNTAwKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBFbmdpbmU7XHJcbiAgICB9KENsYXNzXzkuQ2xhc3MpKTtcclxuICAgIC8qKlxyXG4gICAgICogRGVmYXVsdCBbW0lFbmdpbmVPcHRpb25zXV1cclxuICAgICAqL1xyXG4gICAgRW5naW5lLl9EZWZhdWx0RW5naW5lT3B0aW9ucyA9IHtcclxuICAgICAgICB3aWR0aDogMCxcclxuICAgICAgICBoZWlnaHQ6IDAsXHJcbiAgICAgICAgY2FudmFzRWxlbWVudElkOiAnJyxcclxuICAgICAgICBwb2ludGVyU2NvcGU6IElucHV0LlBvaW50ZXJTY29wZS5Eb2N1bWVudCxcclxuICAgICAgICBzdXBwcmVzc0NvbnNvbGVCb290TWVzc2FnZTogbnVsbCxcclxuICAgICAgICBzdXBwcmVzc01pbmltdW1Ccm93c2VyRmVhdHVyZURldGVjdGlvbjogbnVsbCxcclxuICAgICAgICBzdXBwcmVzc0hpRFBJU2NhbGluZzogbnVsbCxcclxuICAgICAgICBzY3JvbGxQcmV2ZW50aW9uTW9kZTogU2Nyb2xsUHJldmVudGlvbk1vZGUuQ2FudmFzLFxyXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogQ29sb3JfMTkuQ29sb3IuZnJvbUhleCgnIzIxODVkMCcpIC8vIEV4Y2FsaWJ1ciBibHVlXHJcbiAgICB9O1xyXG4gICAgZXhwb3J0cy5FbmdpbmUgPSBFbmdpbmU7XHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICB2YXIgQW5pbWF0aW9uTm9kZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uTm9kZShhbmltYXRpb24sIHgsIHkpIHtcclxuICAgICAgICAgICAgdGhpcy5hbmltYXRpb24gPSBhbmltYXRpb247XHJcbiAgICAgICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBBbmltYXRpb25Ob2RlO1xyXG4gICAgfSgpKTtcclxufSk7XHJcbmRlZmluZShcIlVJQWN0b3JcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJBbGdlYnJhXCIsIFwiQWN0b3JcIiwgXCJUcmFpdHMvSW5kZXhcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBBbGdlYnJhXzIzLCBBY3Rvcl8xMywgVHJhaXRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogSGVscGVyIFtbQWN0b3JdXSBwcmltaXRpdmUgZm9yIGRyYXdpbmcgVUkncywgb3B0aW1pemVkIGZvciBVSSBkcmF3aW5nLiBEb2VzXHJcbiAgICAgKiBub3QgcGFydGljaXBhdGUgaW4gY29sbGlzaW9ucy4gRHJhd24gb24gdG9wIG9mIGFsbCBvdGhlciBhY3RvcnMuXHJcbiAgICAgKi9cclxuICAgIHZhciBVSUFjdG9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoVUlBY3RvciwgX3N1cGVyKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0geCAgICAgICBUaGUgc3RhcnRpbmcgeCBjb29yZGluYXRlIG9mIHRoZSBhY3RvclxyXG4gICAgICAgICAqIEBwYXJhbSB5ICAgICAgIFRoZSBzdGFydGluZyB5IGNvb3JkaW5hdGUgb2YgdGhlIGFjdG9yXHJcbiAgICAgICAgICogQHBhcmFtIHdpZHRoICAgVGhlIHN0YXJ0aW5nIHdpZHRoIG9mIHRoZSBhY3RvclxyXG4gICAgICAgICAqIEBwYXJhbSBoZWlnaHQgIFRoZSBzdGFydGluZyBoZWlnaHQgb2YgdGhlIGFjdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gVUlBY3Rvcih4T3JDb25maWcsIHksIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiAoeE9yQ29uZmlnICE9PSAnb2JqZWN0JykpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgeE9yQ29uZmlnLCB5LCB3aWR0aCwgaGVpZ2h0KSB8fCB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB4T3JDb25maWcpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMudHJhaXRzID0gW107XHJcbiAgICAgICAgICAgIF90aGlzLnRyYWl0cy5wdXNoKG5ldyBUcmFpdHMuQ2FwdHVyZVBvaW50ZXIoKSk7XHJcbiAgICAgICAgICAgIF90aGlzLmFuY2hvci5zZXRUbygwLCAwKTtcclxuICAgICAgICAgICAgX3RoaXMuY29sbGlzaW9uVHlwZSA9IEFjdG9yXzEzLkNvbGxpc2lvblR5cGUuUHJldmVudENvbGxpc2lvbjtcclxuICAgICAgICAgICAgX3RoaXMuZW5hYmxlQ2FwdHVyZVBvaW50ZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFVJQWN0b3IucHJvdG90eXBlLm9uSW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChlbmdpbmUpIHtcclxuICAgICAgICAgICAgdGhpcy5fZW5naW5lID0gZW5naW5lO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVUlBY3Rvci5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAoeCwgeSwgdXNlV29ybGQpIHtcclxuICAgICAgICAgICAgaWYgKHVzZVdvcmxkID09PSB2b2lkIDApIHsgdXNlV29ybGQgPSB0cnVlOyB9XHJcbiAgICAgICAgICAgIGlmICh1c2VXb3JsZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuY29udGFpbnMuY2FsbCh0aGlzLCB4LCB5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY29vcmRzID0gdGhpcy5fZW5naW5lLndvcmxkVG9TY3JlZW5Db29yZGluYXRlcyhuZXcgQWxnZWJyYV8yMy5WZWN0b3IoeCwgeSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5jb250YWlucy5jYWxsKHRoaXMsIGNvb3Jkcy54LCBjb29yZHMueSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gVUlBY3RvcjtcclxuICAgIH0oQWN0b3JfMTMuQWN0b3IpKTtcclxuICAgIGV4cG9ydHMuVUlBY3RvciA9IFVJQWN0b3I7XHJcbn0pO1xyXG5kZWZpbmUoXCJVdGlsL0FjdG9yc1wiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIlVJQWN0b3JcIiwgXCJMYWJlbFwiLCBcIlRyaWdnZXJcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBVSUFjdG9yXzQsIExhYmVsXzMsIFRyaWdnZXJfMikge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICBmdW5jdGlvbiBpc1ZhbmlsbGFBY3RvcihhY3Rvcikge1xyXG4gICAgICAgIHJldHVybiAhKGFjdG9yIGluc3RhbmNlb2YgVUlBY3Rvcl80LlVJQWN0b3IpICYmXHJcbiAgICAgICAgICAgICEoYWN0b3IgaW5zdGFuY2VvZiBUcmlnZ2VyXzIuVHJpZ2dlcikgJiZcclxuICAgICAgICAgICAgIShhY3RvciBpbnN0YW5jZW9mIExhYmVsXzMuTGFiZWwpO1xyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5pc1ZhbmlsbGFBY3RvciA9IGlzVmFuaWxsYUFjdG9yO1xyXG4gICAgZnVuY3Rpb24gaXNVSUFjdG9yKGFjdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIGFjdG9yIGluc3RhbmNlb2YgVUlBY3Rvcl80LlVJQWN0b3I7XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLmlzVUlBY3RvciA9IGlzVUlBY3RvcjtcclxufSk7XHJcbmRlZmluZShcIlNjZW5lXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiVUlBY3RvclwiLCBcIlBoeXNpY3NcIiwgXCJFdmVudHNcIiwgXCJVdGlsL0xvZ1wiLCBcIlRpbWVyXCIsIFwiQ29sbGlzaW9uL0R5bmFtaWNUcmVlQ29sbGlzaW9uQnJvYWRwaGFzZVwiLCBcIlV0aWwvU29ydGVkTGlzdFwiLCBcIkdyb3VwXCIsIFwiVGlsZU1hcFwiLCBcIkNhbWVyYVwiLCBcIkFjdG9yXCIsIFwiQ2xhc3NcIiwgXCJVdGlsL1V0aWxcIiwgXCJVdGlsL0FjdG9yc1wiLCBcIlRyaWdnZXJcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBVSUFjdG9yXzUsIFBoeXNpY3NfMTIsIEV2ZW50c18xMywgTG9nXzE1LCBUaW1lcl8zLCBEeW5hbWljVHJlZUNvbGxpc2lvbkJyb2FkcGhhc2VfMiwgU29ydGVkTGlzdF8yLCBHcm91cF8yLCBUaWxlTWFwXzMsIENhbWVyYV8yLCBBY3Rvcl8xNCwgQ2xhc3NfMTAsIFV0aWwsIEFjdG9yVXRpbHMsIFRyaWdnZXJfMykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIFtbQWN0b3J8QWN0b3JzXV0gYXJlIGNvbXBvc2VkIHRvZ2V0aGVyIGludG8gZ3JvdXBpbmdzIGNhbGxlZCBTY2VuZXMgaW5cclxuICAgICAqIEV4Y2FsaWJ1ci4gVGhlIG1ldGFwaG9yIG1vZGVscyB0aGUgc2FtZSBpZGVhIGJlaGluZCByZWFsIHdvcmxkXHJcbiAgICAgKiBhY3RvcnMgaW4gYSBzY2VuZS4gT25seSBhY3RvcnMgaW4gc2NlbmVzIHdpbGwgYmUgdXBkYXRlZCBhbmQgZHJhd24uXHJcbiAgICAgKlxyXG4gICAgICogVHlwaWNhbCB1c2FnZXMgb2YgYSBzY2VuZSBpbmNsdWRlOiBsZXZlbHMsIG1lbnVzLCBsb2FkaW5nIHNjcmVlbnMsIGV0Yy5cclxuICAgICAqXHJcbiAgICAgKiBbW2luY2x1ZGU6U2NlbmVzLm1kXV1cclxuICAgICAqL1xyXG4gICAgdmFyIFNjZW5lID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoU2NlbmUsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gU2NlbmUoZW5naW5lKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgYWN0b3JzIGluIHRoZSBjdXJyZW50IHNjZW5lXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5hY3RvcnMgPSBbXTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSB0cmlnZ2VycyBpbiB0aGUgY3VycmVudCBzY2VuZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMudHJpZ2dlcnMgPSBbXTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBbW1RpbGVNYXBdXXMgaW4gdGhlIHNjZW5lLCBpZiBhbnlcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLnRpbGVNYXBzID0gW107XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgW1tHcm91cF1dcyBpbiB0aGUgc2NlbmUsIGlmIGFueVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuZ3JvdXBzID0ge307XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgW1tVSUFjdG9yXV1zIGluIGEgc2NlbmUsIGlmIGFueTsgdGhlc2UgYXJlIGRyYXduIGxhc3RcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLnVpQWN0b3JzID0gW107XHJcbiAgICAgICAgICAgIF90aGlzLl9pc0luaXRpYWxpemVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIF90aGlzLl9zb3J0ZWREcmF3aW5nVHJlZSA9IG5ldyBTb3J0ZWRMaXN0XzIuU29ydGVkTGlzdChBY3Rvcl8xNC5BY3Rvci5wcm90b3R5cGUuZ2V0WkluZGV4KTtcclxuICAgICAgICAgICAgX3RoaXMuX2Jyb2FkcGhhc2UgPSBuZXcgRHluYW1pY1RyZWVDb2xsaXNpb25Ccm9hZHBoYXNlXzIuRHluYW1pY1RyZWVDb2xsaXNpb25Ccm9hZHBoYXNlKCk7XHJcbiAgICAgICAgICAgIF90aGlzLl9raWxsUXVldWUgPSBbXTtcclxuICAgICAgICAgICAgX3RoaXMuX3RyaWdnZXJLaWxsUXVldWUgPSBbXTtcclxuICAgICAgICAgICAgX3RoaXMuX3RpbWVycyA9IFtdO1xyXG4gICAgICAgICAgICBfdGhpcy5fY2FuY2VsUXVldWUgPSBbXTtcclxuICAgICAgICAgICAgX3RoaXMuX2xvZ2dlciA9IExvZ18xNS5Mb2dnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgX3RoaXMuY2FtZXJhID0gbmV3IENhbWVyYV8yLkJhc2VDYW1lcmEoKTtcclxuICAgICAgICAgICAgaWYgKGVuZ2luZSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY2FtZXJhLnggPSBlbmdpbmUuaGFsZkRyYXdXaWR0aDtcclxuICAgICAgICAgICAgICAgIF90aGlzLmNhbWVyYS55ID0gZW5naW5lLmhhbGZEcmF3SGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgU2NlbmUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgaXMgY2FsbGVkIGJlZm9yZSB0aGUgZmlyc3QgdXBkYXRlIG9mIHRoZSBbW1NjZW5lXV0uIEluaXRpYWxpemVzIHNjZW5lIG1lbWJlcnMgbGlrZSB0aGUgY2FtZXJhLiBUaGlzIG1ldGhvZCBpcyBtZWFudCB0byBiZVxyXG4gICAgICAgICAqIG92ZXJyaWRkZW4uIFRoaXMgaXMgd2hlcmUgaW5pdGlhbGl6YXRpb24gb2YgY2hpbGQgYWN0b3JzIHNob3VsZCB0YWtlIHBsYWNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5vbkluaXRpYWxpemUgPSBmdW5jdGlvbiAoZW5naW5lKSB7XHJcbiAgICAgICAgICAgIC8vIHdpbGwgYmUgb3ZlcnJpZGRlblxyXG4gICAgICAgICAgICBpZiAodGhpcy5jYW1lcmEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FtZXJhLnggPSBlbmdpbmUuaGFsZkRyYXdXaWR0aDtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FtZXJhLnkgPSBlbmdpbmUuaGFsZkRyYXdIZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCdTY2VuZS5vbkluaXRpYWxpemUnLCB0aGlzLCBlbmdpbmUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGUgc2NlbmUgaXMgbWFkZSBhY3RpdmUgYW5kIHN0YXJ0ZWQuIEl0IGlzIG1lYW50IHRvIGJlIG92ZXJyaWRlbixcclxuICAgICAgICAgKiB0aGlzIGlzIHdoZXJlIHlvdSBzaG91bGQgc2V0dXAgYW55IERPTSBVSSBvciBldmVudCBoYW5kbGVycyBuZWVkZWQgZm9yIHRoZSBzY2VuZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBTY2VuZS5wcm90b3R5cGUub25BY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gd2lsbCBiZSBvdmVycmlkZGVuXHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZygnU2NlbmUub25BY3RpdmF0ZScsIHRoaXMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGUgc2NlbmUgaXMgbWFkZSB0cmFuc2l0aW9uZWQgYXdheSBmcm9tIGFuZCBzdG9wcGVkLiBJdCBpcyBtZWFudCB0byBiZSBvdmVycmlkZW4sXHJcbiAgICAgICAgICogdGhpcyBpcyB3aGVyZSB5b3Ugc2hvdWxkIGNsZWFudXAgYW55IERPTSBVSSBvciBldmVudCBoYW5kbGVycyBuZWVkZWQgZm9yIHRoZSBzY2VuZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBTY2VuZS5wcm90b3R5cGUub25EZWFjdGl2YXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyB3aWxsIGJlIG92ZXJyaWRkZW5cclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCdTY2VuZS5vbkRlYWN0aXZhdGUnLCB0aGlzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluaXRpYWxpemVzIGFjdG9ycyBpbiB0aGUgc2NlbmVcclxuICAgICAgICAgKi9cclxuICAgICAgICBTY2VuZS5wcm90b3R5cGUuX2luaXRpYWxpemVDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuYWN0b3JzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgY2hpbGQuX2luaXRpYWxpemUodGhpcy5lbmdpbmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2NlbmUucHJvdG90eXBlLCBcImlzSW5pdGlhbGl6ZWRcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB3aGV0aGVyIG9yIG5vdCB0aGUgW1tTY2VuZV1dIGhhcyBiZWVuIGluaXRpYWxpemVkXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc0luaXRpYWxpemVkO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbml0aWFsaXplcyB0aGUgc2NlbmUgYmVmb3JlIHRoZSBmaXJzdCB1cGRhdGUsIG1lYW50IHRvIGJlIGNhbGxlZCBieSBlbmdpbmUgbm90IGJ5IHVzZXJzIG9mXHJcbiAgICAgICAgICogRXhjYWxpYnVyXHJcbiAgICAgICAgICogQGludGVybmFsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2NlbmUucHJvdG90eXBlLl9pbml0aWFsaXplID0gZnVuY3Rpb24gKGVuZ2luZSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkluaXRpYWxpemUuY2FsbCh0aGlzLCBlbmdpbmUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIuZW1pdCgnaW5pdGlhbGl6ZScsIG5ldyBFdmVudHNfMTMuSW5pdGlhbGl6ZUV2ZW50KGVuZ2luZSwgdGhpcykpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZUNoaWxkcmVuKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXBkYXRlcyBhbGwgdGhlIGFjdG9ycyBhbmQgdGltZXJzIGluIHRoZSBzY2VuZS4gQ2FsbGVkIGJ5IHRoZSBbW0VuZ2luZV1dLlxyXG4gICAgICAgICAqIEBwYXJhbSBlbmdpbmUgIFJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBFbmdpbmVcclxuICAgICAgICAgKiBAcGFyYW0gZGVsdGEgICBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgbGFzdCB1cGRhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBTY2VuZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGVuZ2luZSwgZGVsdGEpIHtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdwcmV1cGRhdGUnLCBuZXcgRXZlbnRzXzEzLlByZVVwZGF0ZUV2ZW50KGVuZ2luZSwgZGVsdGEsIHRoaXMpKTtcclxuICAgICAgICAgICAgdmFyIGksIGxlbjtcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRpbWVycyBpbiB0aGUgY2FuY2VsIHF1ZXVlIGJlZm9yZSB1cGRhdGluZyB0aGVtXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuX2NhbmNlbFF1ZXVlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVRpbWVyKHRoaXMuX2NhbmNlbFF1ZXVlW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9jYW5jZWxRdWV1ZS5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAvLyBDeWNsZSB0aHJvdWdoIHRpbWVycyB1cGRhdGluZyB0aW1lcnNcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuX3RpbWVyczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciB0aW1lciA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgIHRpbWVyLnVwZGF0ZShkZWx0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgO1xyXG4gICAgICAgICAgICAvLyBDeWNsZSB0aHJvdWdoIGFjdG9ycyB1cGRhdGluZyBVSSBhY3RvcnNcclxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy51aUFjdG9ycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51aUFjdG9yc1tpXS51cGRhdGUoZW5naW5lLCBkZWx0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQ3ljbGUgdGhyb3VnaCBhY3RvcnMgdXBkYXRpbmcgdGlsZSBtYXBzXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHRoaXMudGlsZU1hcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGlsZU1hcHNbaV0udXBkYXRlKGVuZ2luZSwgZGVsdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEN5Y2xlIHRocm91Z2ggYWN0b3JzIHVwZGF0aW5nIGFjdG9yc1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLmFjdG9ycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hY3RvcnNbaV0udXBkYXRlKGVuZ2luZSwgZGVsdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEN5Y2xlIHRocm91Z2ggdHJpZ2dlcnMgdXBkYXRpbmdcclxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy50cmlnZ2Vycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2Vyc1tpXS51cGRhdGUoZW5naW5lLCBkZWx0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fY29sbGVjdEFjdG9yU3RhdHMoZW5naW5lKTtcclxuICAgICAgICAgICAgLy8gUnVuIHRoZSBicm9hZHBoYXNlIGFuZCBuYXJyb3dwaGFzZVxyXG4gICAgICAgICAgICBpZiAodGhpcy5fYnJvYWRwaGFzZSAmJiBQaHlzaWNzXzEyLlBoeXNpY3MuZW5hYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGJlZm9yZUJyb2FkcGhhc2UgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYnJvYWRwaGFzZS51cGRhdGUodGhpcy5hY3RvcnMsIGRlbHRhKTtcclxuICAgICAgICAgICAgICAgIHZhciBwYWlycyA9IHRoaXMuX2Jyb2FkcGhhc2UuYnJvYWRwaGFzZSh0aGlzLmFjdG9ycywgZGVsdGEsIGVuZ2luZS5zdGF0cy5jdXJyRnJhbWUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGFmdGVyQnJvYWRwaGFzZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYmVmb3JlTmFycm93cGhhc2UgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGl0ZXIgPSBQaHlzaWNzXzEyLlBoeXNpY3MuY29sbGlzaW9uUGFzc2VzO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbGxpc2lvbkRlbHRhID0gZGVsdGEgLyBpdGVyO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGl0ZXIgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUnVuIHRoZSBuYXJyb3dwaGFzZVxyXG4gICAgICAgICAgICAgICAgICAgIHBhaXJzID0gdGhpcy5fYnJvYWRwaGFzZS5uYXJyb3dwaGFzZShwYWlycywgZW5naW5lLnN0YXRzLmN1cnJGcmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUnVuIGNvbGxpc2lvbiByZXNvbHV0aW9uIHN0cmF0ZWd5XHJcbiAgICAgICAgICAgICAgICAgICAgcGFpcnMgPSB0aGlzLl9icm9hZHBoYXNlLnJlc29sdmUocGFpcnMsIGNvbGxpc2lvbkRlbHRhLCBQaHlzaWNzXzEyLlBoeXNpY3MuY29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9icm9hZHBoYXNlLnJ1bkNvbGxpc2lvblN0YXJ0RW5kKHBhaXJzKTtcclxuICAgICAgICAgICAgICAgICAgICBpdGVyLS07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgYWZ0ZXJOYXJyb3dwaGFzZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICBlbmdpbmUuc3RhdHMuY3VyckZyYW1lLnBoeXNpY3MuYnJvYWRwaGFzZSA9IGFmdGVyQnJvYWRwaGFzZSAtIGJlZm9yZUJyb2FkcGhhc2U7XHJcbiAgICAgICAgICAgICAgICBlbmdpbmUuc3RhdHMuY3VyckZyYW1lLnBoeXNpY3MubmFycm93cGhhc2UgPSBhZnRlck5hcnJvd3BoYXNlIC0gYmVmb3JlTmFycm93cGhhc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZW5naW5lLnN0YXRzLmN1cnJGcmFtZS5hY3RvcnMua2lsbGVkID0gdGhpcy5fa2lsbFF1ZXVlLmxlbmd0aCArIHRoaXMuX3RyaWdnZXJLaWxsUXVldWUubGVuZ3RoO1xyXG4gICAgICAgICAgICB0aGlzLl9wcm9jZXNzS2lsbFF1ZXVlKHRoaXMuX2tpbGxRdWV1ZSwgdGhpcy5hY3RvcnMpO1xyXG4gICAgICAgICAgICB0aGlzLl9wcm9jZXNzS2lsbFF1ZXVlKHRoaXMuX3RyaWdnZXJLaWxsUXVldWUsIHRoaXMudHJpZ2dlcnMpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jYW1lcmEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FtZXJhLnVwZGF0ZShlbmdpbmUsIGRlbHRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3Bvc3R1cGRhdGUnLCBuZXcgRXZlbnRzXzEzLlBvc3RVcGRhdGVFdmVudChlbmdpbmUsIGRlbHRhLCB0aGlzKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTY2VuZS5wcm90b3R5cGUuX3Byb2Nlc3NLaWxsUXVldWUgPSBmdW5jdGlvbiAoa2lsbFF1ZXVlLCBjb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSBhY3RvcnMgZnJvbSBzY2VuZSBncmFwaCBhZnRlciBiZWluZyBraWxsZWRcclxuICAgICAgICAgICAgdmFyIGFjdG9ySW5kZXg7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwga2lsbFF1ZXVlXzEgPSBraWxsUXVldWU7IF9pIDwga2lsbFF1ZXVlXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIga2lsbGVkID0ga2lsbFF1ZXVlXzFbX2ldO1xyXG4gICAgICAgICAgICAgICAgYWN0b3JJbmRleCA9IGNvbGxlY3Rpb24uaW5kZXhPZihraWxsZWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFjdG9ySW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NvcnRlZERyYXdpbmdUcmVlLnJlbW92ZUJ5Q29tcGFyYWJsZShraWxsZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24uc3BsaWNlKGFjdG9ySW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGtpbGxRdWV1ZS5sZW5ndGggPSAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRHJhd3MgYWxsIHRoZSBhY3RvcnMgaW4gdGhlIFNjZW5lLiBDYWxsZWQgYnkgdGhlIFtbRW5naW5lXV0uXHJcbiAgICAgICAgICogQHBhcmFtIGN0eCAgICBUaGUgY3VycmVudCByZW5kZXJpbmcgY29udGV4dFxyXG4gICAgICAgICAqIEBwYXJhbSBkZWx0YSAgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGxhc3QgZHJhd1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGN0eCwgZGVsdGEpIHtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdwcmVkcmF3JywgbmV3IEV2ZW50c18xMy5QcmVEcmF3RXZlbnQoY3R4LCBkZWx0YSwgdGhpcykpO1xyXG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jYW1lcmEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FtZXJhLmRyYXcoY3R4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaSwgbGVuO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLnRpbGVNYXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRpbGVNYXBzW2ldLmRyYXcoY3R4LCBkZWx0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHNvcnRlZENoaWxkcmVuID0gdGhpcy5fc29ydGVkRHJhd2luZ1RyZWUubGlzdCgpO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBzb3J0ZWRDaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gb25seSBkcmF3IGFjdG9ycyB0aGF0IGFyZSB2aXNpYmxlIGFuZCBvbiBzY3JlZW5cclxuICAgICAgICAgICAgICAgIGlmIChzb3J0ZWRDaGlsZHJlbltpXS52aXNpYmxlICYmICFzb3J0ZWRDaGlsZHJlbltpXS5pc09mZlNjcmVlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHNvcnRlZENoaWxkcmVuW2ldLmRyYXcoY3R4LCBkZWx0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuZW5naW5lICYmIHRoaXMuZW5naW5lLmlzRGVidWcpIHtcclxuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICd5ZWxsb3cnO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1Z0RyYXcoY3R4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLnVpQWN0b3JzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGRyYXcgdWkgYWN0b3JzIHRoYXQgYXJlIHZpc2libGUgYW5kIG9uIHNjcmVlblxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudWlBY3RvcnNbaV0udmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudWlBY3RvcnNbaV0uZHJhdyhjdHgsIGRlbHRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5lbmdpbmUgJiYgdGhpcy5lbmdpbmUuaXNEZWJ1Zykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy51aUFjdG9ycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudWlBY3RvcnNbaV0uZGVidWdEcmF3KGN0eCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdwb3N0ZHJhdycsIG5ldyBFdmVudHNfMTMuUG9zdERyYXdFdmVudChjdHgsIGRlbHRhLCB0aGlzKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEcmF3cyBhbGwgdGhlIGFjdG9ycycgZGVidWcgaW5mb3JtYXRpb24gaW4gdGhlIFNjZW5lLiBDYWxsZWQgYnkgdGhlIFtbRW5naW5lXV0uXHJcbiAgICAgICAgICogQHBhcmFtIGN0eCAgVGhlIGN1cnJlbnQgcmVuZGVyaW5nIGNvbnRleHRcclxuICAgICAgICAgKi9cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncHJlZGVidWdkcmF3JywgbmV3IEV2ZW50c18xMy5QcmVEZWJ1Z0RyYXdFdmVudChjdHgsIHRoaXMpKTtcclxuICAgICAgICAgICAgdmFyIGksIGxlbjtcclxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy50aWxlTWFwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50aWxlTWFwc1tpXS5kZWJ1Z0RyYXcoY3R4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLmFjdG9ycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hY3RvcnNbaV0uZGVidWdEcmF3KGN0eCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy50cmlnZ2Vycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2Vyc1tpXS5kZWJ1Z0RyYXcoY3R4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9icm9hZHBoYXNlLmRlYnVnRHJhdyhjdHgsIDIwKTtcclxuICAgICAgICAgICAgdGhpcy5jYW1lcmEuZGVidWdEcmF3KGN0eCk7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncG9zdGRlYnVnZHJhdycsIG5ldyBFdmVudHNfMTMuUG9zdERlYnVnRHJhd0V2ZW50KGN0eCwgdGhpcykpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hlY2tzIHdoZXRoZXIgYW4gYWN0b3IgaXMgY29udGFpbmVkIGluIHRoaXMgc2NlbmUgb3Igbm90XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2NlbmUucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKGFjdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdG9ycy5pbmRleE9mKGFjdG9yKSA+IC0xO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgU2NlbmUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChlbnRpdHkpIHtcclxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIEFjdG9yXzE0LkFjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkudW5raWxsKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIFVJQWN0b3JfNS5VSUFjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIVV0aWwuY29udGFpbnModGhpcy51aUFjdG9ycywgZW50aXR5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkVUlBY3RvcihlbnRpdHkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBBY3Rvcl8xNC5BY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFVdGlsLmNvbnRhaW5zKHRoaXMuYWN0b3JzLCBlbnRpdHkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkQ2hpbGQoZW50aXR5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgVGltZXJfMy5UaW1lcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFVdGlsLmNvbnRhaW5zKHRoaXMuX3RpbWVycywgZW50aXR5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkVGltZXIoZW50aXR5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgVGlsZU1hcF8zLlRpbGVNYXApIHtcclxuICAgICAgICAgICAgICAgIGlmICghVXRpbC5jb250YWlucyh0aGlzLnRpbGVNYXBzLCBlbnRpdHkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRUaWxlTWFwKGVudGl0eSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoZW50aXR5KSB7XHJcbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBVSUFjdG9yXzUuVUlBY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVVSUFjdG9yKGVudGl0eSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIEFjdG9yXzE0LkFjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9icm9hZHBoYXNlLnVudHJhY2soZW50aXR5LmJvZHkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQ2hpbGQoZW50aXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgVGltZXJfMy5UaW1lcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVUaW1lcihlbnRpdHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBUaWxlTWFwXzMuVGlsZU1hcCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVUaWxlTWFwKGVudGl0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgKGFueSkgYWN0b3IgdG8gYWN0IGFzIGEgcGllY2Ugb2YgVUksIG1lYW5pbmcgaXQgaXMgYWx3YXlzIHBvc2l0aW9uZWRcclxuICAgICAgICAgKiBpbiBzY3JlZW4gY29vcmRpbmF0ZXMuIFVJIGFjdG9ycyBkbyBub3QgcGFydGljaXBhdGUgaW4gY29sbGlzaW9ucy5cclxuICAgICAgICAgKiBAdG9kbyBTaG91bGQgdGhpcyBiZSBgVUlBY3RvcmAgb25seT9cclxuICAgICAgICAgKi9cclxuICAgICAgICBTY2VuZS5wcm90b3R5cGUuYWRkVUlBY3RvciA9IGZ1bmN0aW9uIChhY3Rvcikge1xyXG4gICAgICAgICAgICB0aGlzLnVpQWN0b3JzLnB1c2goYWN0b3IpO1xyXG4gICAgICAgICAgICBhY3Rvci5zY2VuZSA9IHRoaXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGFuIGFjdG9yIGFzIGEgcGllY2Ugb2YgVUlcclxuICAgICAgICAgKi9cclxuICAgICAgICBTY2VuZS5wcm90b3R5cGUucmVtb3ZlVUlBY3RvciA9IGZ1bmN0aW9uIChhY3Rvcikge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLnVpQWN0b3JzLmluZGV4T2YoYWN0b3IpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51aUFjdG9ycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGFuIGFjdG9yIHRvIHRoZSBzY2VuZSwgb25jZSB0aGlzIGlzIGRvbmUgdGhlIGFjdG9yIHdpbGwgYmUgZHJhd24gYW5kIHVwZGF0ZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2NlbmUucHJvdG90eXBlLl9hZGRDaGlsZCA9IGZ1bmN0aW9uIChhY3Rvcikge1xyXG4gICAgICAgICAgICB0aGlzLl9icm9hZHBoYXNlLnRyYWNrKGFjdG9yLmJvZHkpO1xyXG4gICAgICAgICAgICBhY3Rvci5zY2VuZSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmIChhY3RvciBpbnN0YW5jZW9mIFRyaWdnZXJfMy5UcmlnZ2VyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJzLnB1c2goYWN0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hY3RvcnMucHVzaChhY3Rvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fc29ydGVkRHJhd2luZ1RyZWUuYWRkKGFjdG9yKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYSBbW1RpbGVNYXBdXSB0byB0aGUgc2NlbmUsIG9uY2UgdGhpcyBpcyBkb25lIHRoZSBUaWxlTWFwIHdpbGwgYmUgZHJhd24gYW5kIHVwZGF0ZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2NlbmUucHJvdG90eXBlLmFkZFRpbGVNYXAgPSBmdW5jdGlvbiAodGlsZU1hcCkge1xyXG4gICAgICAgICAgICB0aGlzLnRpbGVNYXBzLnB1c2godGlsZU1hcCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGEgW1tUaWxlTWFwXV0gZnJvbSB0aGUgc2NlbmUsIGl0IHdpbGwgbm8gbG9uZ2VyIGJlIGRyYXduIG9yIHVwZGF0ZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2NlbmUucHJvdG90eXBlLnJlbW92ZVRpbGVNYXAgPSBmdW5jdGlvbiAodGlsZU1hcCkge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLnRpbGVNYXBzLmluZGV4T2YodGlsZU1hcCk7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRpbGVNYXBzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgYW4gYWN0b3IgZnJvbSB0aGUgc2NlbmUsIGl0IHdpbGwgbm8gbG9uZ2VyIGJlIGRyYXduIG9yIHVwZGF0ZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2NlbmUucHJvdG90eXBlLl9yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIChhY3Rvcikge1xyXG4gICAgICAgICAgICB0aGlzLl9icm9hZHBoYXNlLnVudHJhY2soYWN0b3IuYm9keSk7XHJcbiAgICAgICAgICAgIGlmIChhY3RvciBpbnN0YW5jZW9mIFRyaWdnZXJfMy5UcmlnZ2VyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90cmlnZ2VyS2lsbFF1ZXVlLnB1c2goYWN0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fa2lsbFF1ZXVlLnB1c2goYWN0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFjdG9yLnBhcmVudCA9IG51bGw7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgW1tUaW1lcl1dIHRvIHRoZSBzY2VuZVxyXG4gICAgICAgICAqIEBwYXJhbSB0aW1lciAgVGhlIHRpbWVyIHRvIGFkZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5hZGRUaW1lciA9IGZ1bmN0aW9uICh0aW1lcikge1xyXG4gICAgICAgICAgICB0aGlzLl90aW1lcnMucHVzaCh0aW1lcik7XHJcbiAgICAgICAgICAgIHRpbWVyLnNjZW5lID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIHRpbWVyO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlcyBhIFtbVGltZXJdXSBmcm9tIHRoZSBzY2VuZS5cclxuICAgICAgICAgKiBAd2FybmluZyBDYW4gYmUgZGFuZ2Vyb3VzLCB1c2UgW1tjYW5jZWxUaW1lcl1dIGluc3RlYWRcclxuICAgICAgICAgKiBAcGFyYW0gdGltZXIgIFRoZSB0aW1lciB0byByZW1vdmVcclxuICAgICAgICAgKi9cclxuICAgICAgICBTY2VuZS5wcm90b3R5cGUucmVtb3ZlVGltZXIgPSBmdW5jdGlvbiAodGltZXIpIHtcclxuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLl90aW1lcnMuaW5kZXhPZih0aW1lcik7XHJcbiAgICAgICAgICAgIGlmIChpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGltZXJzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGltZXI7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYW5jZWxzIGEgW1tUaW1lcl1dLCByZW1vdmluZyBpdCBmcm9tIHRoZSBzY2VuZSBuaWNlbHlcclxuICAgICAgICAgKiBAcGFyYW0gdGltZXIgIFRoZSB0aW1lciB0byBjYW5jZWxcclxuICAgICAgICAgKi9cclxuICAgICAgICBTY2VuZS5wcm90b3R5cGUuY2FuY2VsVGltZXIgPSBmdW5jdGlvbiAodGltZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2FuY2VsUXVldWUucHVzaCh0aW1lcik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aW1lcjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRlc3RzIHdoZXRoZXIgYSBbW1RpbWVyXV0gaXMgYWN0aXZlIGluIHRoZSBzY2VuZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5pc1RpbWVyQWN0aXZlID0gZnVuY3Rpb24gKHRpbWVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5fdGltZXJzLmluZGV4T2YodGltZXIpID4gLTEgJiYgIXRpbWVyLmNvbXBsZXRlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYW5kIGFkZHMgYSBbW0dyb3VwXV0gdG8gdGhlIHNjZW5lIHdpdGggYSBuYW1lXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2NlbmUucHJvdG90eXBlLmNyZWF0ZUdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBHcm91cF8yLkdyb3VwKG5hbWUsIHRoaXMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIFtbR3JvdXBdXSBieSBuYW1lXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2NlbmUucHJvdG90eXBlLmdldEdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXBzW25hbWVdO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgU2NlbmUucHJvdG90eXBlLnJlbW92ZUdyb3VwID0gZnVuY3Rpb24gKGdyb3VwKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZ3JvdXAgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5ncm91cHNbZ3JvdXBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGdyb3VwIGluc3RhbmNlb2YgR3JvdXBfMi5Hcm91cCkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZ3JvdXBzW2dyb3VwLm5hbWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cyB0byByZW1vdmVHcm91cCcsIGdyb3VwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gYWN0b3IgZnJvbSB0aGUgc29ydGVkIGRyYXdpbmcgdHJlZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5jbGVhbnVwRHJhd1RyZWUgPSBmdW5jdGlvbiAoYWN0b3IpIHtcclxuICAgICAgICAgICAgdGhpcy5fc29ydGVkRHJhd2luZ1RyZWUucmVtb3ZlQnlDb21wYXJhYmxlKGFjdG9yKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwZGF0ZXMgdGhlIGdpdmVuIGFjdG9yJ3MgcG9zaXRpb24gaW4gdGhlIHNvcnRlZCBkcmF3aW5nIHRyZWVcclxuICAgICAgICAgKi9cclxuICAgICAgICBTY2VuZS5wcm90b3R5cGUudXBkYXRlRHJhd1RyZWUgPSBmdW5jdGlvbiAoYWN0b3IpIHtcclxuICAgICAgICAgICAgdGhpcy5fc29ydGVkRHJhd2luZ1RyZWUuYWRkKGFjdG9yKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5fY29sbGVjdEFjdG9yU3RhdHMgPSBmdW5jdGlvbiAoZW5naW5lKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnVpQWN0b3JzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIF91aSA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgIGVuZ2luZS5zdGF0cy5jdXJyRnJhbWUuYWN0b3JzLnVpKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IHRoaXMuYWN0b3JzOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFjdG9yID0gX2NbX2JdO1xyXG4gICAgICAgICAgICAgICAgZW5naW5lLnN0YXRzLmN1cnJGcmFtZS5hY3RvcnMuYWxpdmUrKztcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9kID0gMCwgX2UgPSBhY3Rvci5jaGlsZHJlbjsgX2QgPCBfZS5sZW5ndGg7IF9kKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBfZVtfZF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFjdG9yVXRpbHMuaXNVSUFjdG9yKGNoaWxkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmdpbmUuc3RhdHMuY3VyckZyYW1lLmFjdG9ycy51aSsrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5naW5lLnN0YXRzLmN1cnJGcmFtZS5hY3RvcnMuYWxpdmUrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBTY2VuZTtcclxuICAgIH0oQ2xhc3NfMTAuQ2xhc3MpKTtcclxuICAgIGV4cG9ydHMuU2NlbmUgPSBTY2VuZTtcclxufSk7XHJcbmRlZmluZShcIkV2ZW50c1wiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBCYXNlIGV2ZW50IHR5cGUgaW4gRXhjYWxpYnVyIHRoYXQgYWxsIG90aGVyIGV2ZW50IHR5cGVzIGRlcml2ZSBmcm9tLiBOb3QgYWxsIGV2ZW50IHR5cGVzIGFyZSB0aHJvd24gb24gYWxsIEV4Y2FsaWJ1ciBnYW1lIG9iamVjdHMsXHJcbiAgICAgKiBzb21lIGV2ZW50cyBhcmUgdW5pcXVlIHRvIGEgdHlwZSwgb3RoZXJzIGFyZSBub3QuXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICB2YXIgR2FtZUV2ZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBHYW1lRXZlbnQoKSB7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBHYW1lRXZlbnQ7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5HYW1lRXZlbnQgPSBHYW1lRXZlbnQ7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSAna2lsbCcgZXZlbnQgaXMgZW1pdHRlZCBvbiBhY3RvcnMgd2hlbiBpdCBpcyBraWxsZWQuIFRoZSB0YXJnZXQgaXMgdGhlIGFjdG9yIHRoYXQgd2FzIGtpbGxlZC5cclxuICAgICAqL1xyXG4gICAgdmFyIEtpbGxFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKEtpbGxFdmVudCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBLaWxsRXZlbnQodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gS2lsbEV2ZW50O1xyXG4gICAgfShHYW1lRXZlbnQpKTtcclxuICAgIGV4cG9ydHMuS2lsbEV2ZW50ID0gS2lsbEV2ZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgJ3N0YXJ0JyBldmVudCBpcyBlbWl0dGVkIG9uIGVuZ2luZSB3aGVuIGhhcyBzdGFydGVkIGFuZCBpcyByZWFkeSBmb3IgaW50ZXJhY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIHZhciBHYW1lU3RhcnRFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKEdhbWVTdGFydEV2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIEdhbWVTdGFydEV2ZW50KHRhcmdldCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEdhbWVTdGFydEV2ZW50O1xyXG4gICAgfShHYW1lRXZlbnQpKTtcclxuICAgIGV4cG9ydHMuR2FtZVN0YXJ0RXZlbnQgPSBHYW1lU3RhcnRFdmVudDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlICdzdG9wJyBldmVudCBpcyBlbWl0dGVkIG9uIGVuZ2luZSB3aGVuIGhhcyBiZWVuIHN0b3BwZWQgYW5kIHdpbGwgbm8gbG9uZ2VyIHRha2UgaW5wdXQsIHVwZGF0ZSBvciBkcmF3LlxyXG4gICAgICovXHJcbiAgICB2YXIgR2FtZVN0b3BFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKEdhbWVTdG9wRXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gR2FtZVN0b3BFdmVudCh0YXJnZXQpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBHYW1lU3RvcEV2ZW50O1xyXG4gICAgfShHYW1lRXZlbnQpKTtcclxuICAgIGV4cG9ydHMuR2FtZVN0b3BFdmVudCA9IEdhbWVTdG9wRXZlbnQ7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSAncHJlZHJhdycgZXZlbnQgaXMgZW1pdHRlZCBvbiBhY3RvcnMsIHNjZW5lcywgYW5kIGVuZ2luZSBiZWZvcmUgZHJhd2luZyBzdGFydHMuIEFjdG9ycycgcHJlZHJhdyBoYXBwZW5zIGluc2lkZSB0aGVpciBncmFwaGljc1xyXG4gICAgICogdHJhbnNmb3JtIHNvIHRoYXQgYWxsIGRyYXdpbmcgdGFrZXMgcGxhY2Ugd2l0aCB0aGUgYWN0b3IgYXMgdGhlIG9yaWdpbi5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIHZhciBQcmVEcmF3RXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhQcmVEcmF3RXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gUHJlRHJhd0V2ZW50KGN0eCwgZGVsdGEsIHRhcmdldCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5jdHggPSBjdHg7XHJcbiAgICAgICAgICAgIF90aGlzLmRlbHRhID0gZGVsdGE7XHJcbiAgICAgICAgICAgIF90aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUHJlRHJhd0V2ZW50O1xyXG4gICAgfShHYW1lRXZlbnQpKTtcclxuICAgIGV4cG9ydHMuUHJlRHJhd0V2ZW50ID0gUHJlRHJhd0V2ZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgJ3Bvc3RkcmF3JyBldmVudCBpcyBlbWl0dGVkIG9uIGFjdG9ycywgc2NlbmVzLCBhbmQgZW5naW5lIGFmdGVyIGRyYXdpbmcgZmluaXNoZXMuIEFjdG9ycycgcG9zdGRyYXcgaGFwcGVucyBpbnNpZGUgdGhlaXIgZ3JhcGhpY3NcclxuICAgICAqIHRyYW5zZm9ybSBzbyB0aGF0IGFsbCBkcmF3aW5nIHRha2VzIHBsYWNlIHdpdGggdGhlIGFjdG9yIGFzIHRoZSBvcmlnaW4uXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICB2YXIgUG9zdERyYXdFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFBvc3REcmF3RXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gUG9zdERyYXdFdmVudChjdHgsIGRlbHRhLCB0YXJnZXQpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuY3R4ID0gY3R4O1xyXG4gICAgICAgICAgICBfdGhpcy5kZWx0YSA9IGRlbHRhO1xyXG4gICAgICAgICAgICBfdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFBvc3REcmF3RXZlbnQ7XHJcbiAgICB9KEdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5Qb3N0RHJhd0V2ZW50ID0gUG9zdERyYXdFdmVudDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlICdwcmVkZWJ1Z2RyYXcnIGV2ZW50IGlzIGVtaXR0ZWQgb24gYWN0b3JzLCBzY2VuZXMsIGFuZCBlbmdpbmUgYmVmb3JlIGRlYnVnIGRyYXdpbmcgc3RhcnRzLlxyXG4gICAgICovXHJcbiAgICB2YXIgUHJlRGVidWdEcmF3RXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhQcmVEZWJ1Z0RyYXdFdmVudCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBQcmVEZWJ1Z0RyYXdFdmVudChjdHgsIHRhcmdldCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5jdHggPSBjdHg7XHJcbiAgICAgICAgICAgIF90aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUHJlRGVidWdEcmF3RXZlbnQ7XHJcbiAgICB9KEdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5QcmVEZWJ1Z0RyYXdFdmVudCA9IFByZURlYnVnRHJhd0V2ZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgJ3Bvc3RkZWJ1Z2RyYXcnIGV2ZW50IGlzIGVtaXR0ZWQgb24gYWN0b3JzLCBzY2VuZXMsIGFuZCBlbmdpbmUgYWZ0ZXIgZGVidWcgZHJhd2luZyBzdGFydHMuXHJcbiAgICAgKi9cclxuICAgIHZhciBQb3N0RGVidWdEcmF3RXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhQb3N0RGVidWdEcmF3RXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gUG9zdERlYnVnRHJhd0V2ZW50KGN0eCwgdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLmN0eCA9IGN0eDtcclxuICAgICAgICAgICAgX3RoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQb3N0RGVidWdEcmF3RXZlbnQ7XHJcbiAgICB9KEdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5Qb3N0RGVidWdEcmF3RXZlbnQgPSBQb3N0RGVidWdEcmF3RXZlbnQ7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSAncHJldXBkYXRlJyBldmVudCBpcyBlbWl0dGVkIG9uIGFjdG9ycywgc2NlbmVzLCBhbmQgZW5naW5lIGJlZm9yZSB0aGUgdXBkYXRlIHN0YXJ0cy5cclxuICAgICAqL1xyXG4gICAgdmFyIFByZVVwZGF0ZUV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoUHJlVXBkYXRlRXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gUHJlVXBkYXRlRXZlbnQoZW5naW5lLCBkZWx0YSwgdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLmVuZ2luZSA9IGVuZ2luZTtcclxuICAgICAgICAgICAgX3RoaXMuZGVsdGEgPSBkZWx0YTtcclxuICAgICAgICAgICAgX3RoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQcmVVcGRhdGVFdmVudDtcclxuICAgIH0oR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLlByZVVwZGF0ZUV2ZW50ID0gUHJlVXBkYXRlRXZlbnQ7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSAncG9zdHVwZGF0ZScgZXZlbnQgaXMgZW1pdHRlZCBvbiBhY3RvcnMsIHNjZW5lcywgYW5kIGVuZ2luZSBhZnRlciB0aGUgdXBkYXRlIGVuZHMuXHJcbiAgICAgKi9cclxuICAgIHZhciBQb3N0VXBkYXRlRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhQb3N0VXBkYXRlRXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gUG9zdFVwZGF0ZUV2ZW50KGVuZ2luZSwgZGVsdGEsIHRhcmdldCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5lbmdpbmUgPSBlbmdpbmU7XHJcbiAgICAgICAgICAgIF90aGlzLmRlbHRhID0gZGVsdGE7XHJcbiAgICAgICAgICAgIF90aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUG9zdFVwZGF0ZUV2ZW50O1xyXG4gICAgfShHYW1lRXZlbnQpKTtcclxuICAgIGV4cG9ydHMuUG9zdFVwZGF0ZUV2ZW50ID0gUG9zdFVwZGF0ZUV2ZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgJ3ByZWZyYW1lJyBldmVudCBpcyBlbWl0dGVkIG9uIHRoZSBlbmdpbmUsIGJlZm9yZSB0aGUgZnJhbWUgYmVnaW5zLlxyXG4gICAgICovXHJcbiAgICB2YXIgUHJlRnJhbWVFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFByZUZyYW1lRXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gUHJlRnJhbWVFdmVudChlbmdpbmUsIHByZXZTdGF0cykge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5lbmdpbmUgPSBlbmdpbmU7XHJcbiAgICAgICAgICAgIF90aGlzLnByZXZTdGF0cyA9IHByZXZTdGF0cztcclxuICAgICAgICAgICAgX3RoaXMudGFyZ2V0ID0gZW5naW5lO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQcmVGcmFtZUV2ZW50O1xyXG4gICAgfShHYW1lRXZlbnQpKTtcclxuICAgIGV4cG9ydHMuUHJlRnJhbWVFdmVudCA9IFByZUZyYW1lRXZlbnQ7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSAncG9zdGZyYW1lJyBldmVudCBpcyBlbWl0dGVkIG9uIHRoZSBlbmdpbmUsIGFmdGVyIGEgZnJhbWUgZW5kcy5cclxuICAgICAqL1xyXG4gICAgdmFyIFBvc3RGcmFtZUV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoUG9zdEZyYW1lRXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gUG9zdEZyYW1lRXZlbnQoZW5naW5lLCBzdGF0cykge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5lbmdpbmUgPSBlbmdpbmU7XHJcbiAgICAgICAgICAgIF90aGlzLnN0YXRzID0gc3RhdHM7XHJcbiAgICAgICAgICAgIF90aGlzLnRhcmdldCA9IGVuZ2luZTtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUG9zdEZyYW1lRXZlbnQ7XHJcbiAgICB9KEdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5Qb3N0RnJhbWVFdmVudCA9IFBvc3RGcmFtZUV2ZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBFdmVudCByZWNlaXZlZCB3aGVuIGEgZ2FtZXBhZCBpcyBjb25uZWN0ZWQgdG8gRXhjYWxpYnVyLiBbW0dhbWVwYWRzXV0gcmVjZWl2ZXMgdGhpcyBldmVudC5cclxuICAgICAqL1xyXG4gICAgdmFyIEdhbWVwYWRDb25uZWN0RXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhHYW1lcGFkQ29ubmVjdEV2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIEdhbWVwYWRDb25uZWN0RXZlbnQoaW5kZXgsIGdhbWVwYWQpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuaW5kZXggPSBpbmRleDtcclxuICAgICAgICAgICAgX3RoaXMuZ2FtZXBhZCA9IGdhbWVwYWQ7XHJcbiAgICAgICAgICAgIF90aGlzLnRhcmdldCA9IGdhbWVwYWQ7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEdhbWVwYWRDb25uZWN0RXZlbnQ7XHJcbiAgICB9KEdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5HYW1lcGFkQ29ubmVjdEV2ZW50ID0gR2FtZXBhZENvbm5lY3RFdmVudDtcclxuICAgIC8qKlxyXG4gICAgICogRXZlbnQgcmVjZWl2ZWQgd2hlbiBhIGdhbWVwYWQgaXMgZGlzY29ubmVjdGVkIGZyb20gRXhjYWxpYnVyLiBbW0dhbWVwYWRzXV0gcmVjZWl2ZXMgdGhpcyBldmVudC5cclxuICAgICAqL1xyXG4gICAgdmFyIEdhbWVwYWREaXNjb25uZWN0RXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhHYW1lcGFkRGlzY29ubmVjdEV2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIEdhbWVwYWREaXNjb25uZWN0RXZlbnQoaW5kZXgsIGdhbWVwYWQpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuaW5kZXggPSBpbmRleDtcclxuICAgICAgICAgICAgX3RoaXMuZ2FtZXBhZCA9IGdhbWVwYWQ7XHJcbiAgICAgICAgICAgIF90aGlzLnRhcmdldCA9IGdhbWVwYWQ7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEdhbWVwYWREaXNjb25uZWN0RXZlbnQ7XHJcbiAgICB9KEdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5HYW1lcGFkRGlzY29ubmVjdEV2ZW50ID0gR2FtZXBhZERpc2Nvbm5lY3RFdmVudDtcclxuICAgIC8qKlxyXG4gICAgICogR2FtZXBhZCBidXR0b24gZXZlbnQuIFNlZSBbW0dhbWVwYWRzXV0gZm9yIGluZm9ybWF0aW9uIG9uIHJlc3BvbmRpbmcgdG8gY29udHJvbGxlciBpbnB1dC4gW1tHYW1lcGFkXV0gaW5zdGFuY2VzIHJlY2VpdmUgdGhpcyBldmVudDtcclxuICAgICAqL1xyXG4gICAgdmFyIEdhbWVwYWRCdXR0b25FdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKEdhbWVwYWRCdXR0b25FdmVudCwgX3N1cGVyKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gYnV0dG9uICBUaGUgR2FtZXBhZCBidXR0b25cclxuICAgICAgICAgKiBAcGFyYW0gdmFsdWUgICBBIG51bWVyaWMgdmFsdWUgYmV0d2VlbiAwIGFuZCAxXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gR2FtZXBhZEJ1dHRvbkV2ZW50KGJ1dHRvbiwgdmFsdWUsIHRhcmdldCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5idXR0b24gPSBidXR0b247XHJcbiAgICAgICAgICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIF90aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gR2FtZXBhZEJ1dHRvbkV2ZW50O1xyXG4gICAgfShHYW1lRXZlbnQpKTtcclxuICAgIGV4cG9ydHMuR2FtZXBhZEJ1dHRvbkV2ZW50ID0gR2FtZXBhZEJ1dHRvbkV2ZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHYW1lcGFkIGF4aXMgZXZlbnQuIFNlZSBbW0dhbWVwYWRzXV0gZm9yIGluZm9ybWF0aW9uIG9uIHJlc3BvbmRpbmcgdG8gY29udHJvbGxlciBpbnB1dC4gW1tHYW1lcGFkXV0gaW5zdGFuY2VzIHJlY2VpdmUgdGhpcyBldmVudDtcclxuICAgICAqL1xyXG4gICAgdmFyIEdhbWVwYWRBeGlzRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhHYW1lcGFkQXhpc0V2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBheGlzICBUaGUgR2FtZXBhZCBheGlzXHJcbiAgICAgICAgICogQHBhcmFtIHZhbHVlIEEgbnVtZXJpYyB2YWx1ZSBiZXR3ZWVuIC0xIGFuZCAxXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gR2FtZXBhZEF4aXNFdmVudChheGlzLCB2YWx1ZSwgdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLmF4aXMgPSBheGlzO1xyXG4gICAgICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICBfdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEdhbWVwYWRBeGlzRXZlbnQ7XHJcbiAgICB9KEdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5HYW1lcGFkQXhpc0V2ZW50ID0gR2FtZXBhZEF4aXNFdmVudDtcclxuICAgIC8qKlxyXG4gICAgICogU3Vic2NyaWJlIGV2ZW50IHRocm93biB3aGVuIGhhbmRsZXJzIGZvciBldmVudHMgb3RoZXIgdGhhbiBzdWJzY3JpYmUgYXJlIGFkZGVkLiBNZXRhIGV2ZW50IHRoYXQgaXMgcmVjZWl2ZWQgYnlcclxuICAgICAqIFtbRXZlbnREaXNwYXRjaGVyfGV2ZW50IGRpc3BhdGNoZXJzXV0uXHJcbiAgICAgKi9cclxuICAgIHZhciBTdWJzY3JpYmVFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFN1YnNjcmliZUV2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFN1YnNjcmliZUV2ZW50KHRvcGljLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLnRvcGljID0gdG9waWM7XHJcbiAgICAgICAgICAgIF90aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBTdWJzY3JpYmVFdmVudDtcclxuICAgIH0oR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLlN1YnNjcmliZUV2ZW50ID0gU3Vic2NyaWJlRXZlbnQ7XHJcbiAgICAvKipcclxuICAgICAqIFVuc3Vic2NyaWJlIGV2ZW50IHRocm93biB3aGVuIGhhbmRsZXJzIGZvciBldmVudHMgb3RoZXIgdGhhbiB1bnN1YnNjcmliZSBhcmUgcmVtb3ZlZC4gTWV0YSBldmVudCB0aGF0IGlzIHJlY2VpdmVkIGJ5XHJcbiAgICAgKiBbW0V2ZW50RGlzcGF0Y2hlcnxldmVudCBkaXNwYXRjaGVyc11dLlxyXG4gICAgICovXHJcbiAgICB2YXIgVW5zdWJzY3JpYmVFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFVuc3Vic2NyaWJlRXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gVW5zdWJzY3JpYmVFdmVudCh0b3BpYywgaGFuZGxlcikge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy50b3BpYyA9IHRvcGljO1xyXG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gVW5zdWJzY3JpYmVFdmVudDtcclxuICAgIH0oR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLlVuc3Vic2NyaWJlRXZlbnQgPSBVbnN1YnNjcmliZUV2ZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBFdmVudCByZWNlaXZlZCBieSB0aGUgW1tFbmdpbmVdXSB3aGVuIHRoZSBicm93c2VyIHdpbmRvdyBpcyB2aXNpYmxlIG9uIGEgc2NyZWVuLlxyXG4gICAgICovXHJcbiAgICB2YXIgVmlzaWJsZUV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoVmlzaWJsZUV2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFZpc2libGVFdmVudCh0YXJnZXQpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBWaXNpYmxlRXZlbnQ7XHJcbiAgICB9KEdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5WaXNpYmxlRXZlbnQgPSBWaXNpYmxlRXZlbnQ7XHJcbiAgICAvKipcclxuICAgICAqIEV2ZW50IHJlY2VpdmVkIGJ5IHRoZSBbW0VuZ2luZV1dIHdoZW4gdGhlIGJyb3dzZXIgd2luZG93IGlzIGhpZGRlbiBmcm9tIGFsbCBzY3JlZW5zLlxyXG4gICAgICovXHJcbiAgICB2YXIgSGlkZGVuRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhIaWRkZW5FdmVudCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBIaWRkZW5FdmVudCh0YXJnZXQpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBIaWRkZW5FdmVudDtcclxuICAgIH0oR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLkhpZGRlbkV2ZW50ID0gSGlkZGVuRXZlbnQ7XHJcbiAgICAvKipcclxuICAgICAqIEV2ZW50IHRocm93biBvbiBhbiBbW0FjdG9yfGFjdG9yXV0gd2hlbiBhIGNvbGxpc2lvbiB3aWxsIG9jY3VyIHRoaXMgZnJhbWUgaWYgaXQgcmVzb2x2ZXNcclxuICAgICAqL1xyXG4gICAgdmFyIFByZUNvbGxpc2lvbkV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoUHJlQ29sbGlzaW9uRXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIGFjdG9yICAgICAgICAgVGhlIGFjdG9yIHRoZSBldmVudCB3YXMgdGhyb3duIG9uXHJcbiAgICAgICAgICogQHBhcmFtIG90aGVyICAgICAgICAgVGhlIGFjdG9yIHRoYXQgd2lsbCBjb2xsaWRlZCB3aXRoIHRoZSBjdXJyZW50IGFjdG9yXHJcbiAgICAgICAgICogQHBhcmFtIHNpZGUgICAgICAgICAgVGhlIHNpZGUgdGhhdCB3aWxsIGJlIGNvbGxpZGVkIHdpdGggdGhlIGN1cnJlbnQgYWN0b3JcclxuICAgICAgICAgKiBAcGFyYW0gaW50ZXJzZWN0aW9uICBJbnRlcnNlY3Rpb24gdmVjdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gUHJlQ29sbGlzaW9uRXZlbnQoYWN0b3IsIG90aGVyLCBzaWRlLCBpbnRlcnNlY3Rpb24pIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuYWN0b3IgPSBhY3RvcjtcclxuICAgICAgICAgICAgX3RoaXMub3RoZXIgPSBvdGhlcjtcclxuICAgICAgICAgICAgX3RoaXMuc2lkZSA9IHNpZGU7XHJcbiAgICAgICAgICAgIF90aGlzLmludGVyc2VjdGlvbiA9IGludGVyc2VjdGlvbjtcclxuICAgICAgICAgICAgX3RoaXMudGFyZ2V0ID0gYWN0b3I7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFByZUNvbGxpc2lvbkV2ZW50O1xyXG4gICAgfShHYW1lRXZlbnQpKTtcclxuICAgIGV4cG9ydHMuUHJlQ29sbGlzaW9uRXZlbnQgPSBQcmVDb2xsaXNpb25FdmVudDtcclxuICAgIC8qKlxyXG4gICAgICogRXZlbnQgdGhyb3duIG9uIGFuIFtbQWN0b3J8YWN0b3JdXSB3aGVuIGEgY29sbGlzaW9uIGhhcyBiZWVuIHJlc29sdmVkIChib2R5IHJlYWN0ZWQpIHRoaXMgZnJhbWVcclxuICAgICAqL1xyXG4gICAgdmFyIFBvc3RDb2xsaXNpb25FdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFBvc3RDb2xsaXNpb25FdmVudCwgX3N1cGVyKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gYWN0b3IgICAgICAgICBUaGUgYWN0b3IgdGhlIGV2ZW50IHdhcyB0aHJvd24gb25cclxuICAgICAgICAgKiBAcGFyYW0gb3RoZXIgICAgICAgICBUaGUgYWN0b3IgdGhhdCBkaWQgY29sbGlkZSB3aXRoIHRoZSBjdXJyZW50IGFjdG9yXHJcbiAgICAgICAgICogQHBhcmFtIHNpZGUgICAgICAgICAgVGhlIHNpZGUgdGhhdCBkaWQgY29sbGlkZSB3aXRoIHRoZSBjdXJyZW50IGFjdG9yXHJcbiAgICAgICAgICogQHBhcmFtIGludGVyc2VjdGlvbiAgSW50ZXJzZWN0aW9uIHZlY3RvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIFBvc3RDb2xsaXNpb25FdmVudChhY3Rvciwgb3RoZXIsIHNpZGUsIGludGVyc2VjdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5hY3RvciA9IGFjdG9yO1xyXG4gICAgICAgICAgICBfdGhpcy5vdGhlciA9IG90aGVyO1xyXG4gICAgICAgICAgICBfdGhpcy5zaWRlID0gc2lkZTtcclxuICAgICAgICAgICAgX3RoaXMuaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uO1xyXG4gICAgICAgICAgICBfdGhpcy50YXJnZXQgPSBhY3RvcjtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUG9zdENvbGxpc2lvbkV2ZW50O1xyXG4gICAgfShHYW1lRXZlbnQpKTtcclxuICAgIGV4cG9ydHMuUG9zdENvbGxpc2lvbkV2ZW50ID0gUG9zdENvbGxpc2lvbkV2ZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBFdmVudCB0aHJvd24gdGhlIGZpcnN0IHRpbWUgYW4gW1tBY3RvcnxhY3Rvcl1dIGNvbGxpZGVzIHdpdGggYW5vdGhlciwgYWZ0ZXIgYW4gYWN0b3IgaXMgaW4gY29udGFjdCBub3JtYWwgY29sbGlzaW9uIGV2ZW50cyBhcmUgZmlyZWQuXHJcbiAgICAgKi9cclxuICAgIHZhciBDb2xsaXNpb25TdGFydEV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoQ29sbGlzaW9uU3RhcnRFdmVudCwgX3N1cGVyKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIENvbGxpc2lvblN0YXJ0RXZlbnQoYWN0b3IsIG90aGVyLCBwYWlyKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLmFjdG9yID0gYWN0b3I7XHJcbiAgICAgICAgICAgIF90aGlzLm90aGVyID0gb3RoZXI7XHJcbiAgICAgICAgICAgIF90aGlzLnBhaXIgPSBwYWlyO1xyXG4gICAgICAgICAgICBfdGhpcy50YXJnZXQgPSBhY3RvcjtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gQ29sbGlzaW9uU3RhcnRFdmVudDtcclxuICAgIH0oR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLkNvbGxpc2lvblN0YXJ0RXZlbnQgPSBDb2xsaXNpb25TdGFydEV2ZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBFdmVudCB0aHJvd24gd2hlbiB0aGUgW1tBY3RvcnxhY3Rvcl1dIGlzIG5vIGxvbmdlciBjb2xsaWRpbmcgd2l0aCBhbm90aGVyXHJcbiAgICAgKi9cclxuICAgIHZhciBDb2xsaXNpb25FbmRFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKENvbGxpc2lvbkVuZEV2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gQ29sbGlzaW9uRW5kRXZlbnQoYWN0b3IsIG90aGVyKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLmFjdG9yID0gYWN0b3I7XHJcbiAgICAgICAgICAgIF90aGlzLm90aGVyID0gb3RoZXI7XHJcbiAgICAgICAgICAgIF90aGlzLnRhcmdldCA9IGFjdG9yO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBDb2xsaXNpb25FbmRFdmVudDtcclxuICAgIH0oR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLkNvbGxpc2lvbkVuZEV2ZW50ID0gQ29sbGlzaW9uRW5kRXZlbnQ7XHJcbiAgICAvKipcclxuICAgICAqIEV2ZW50IHRocm93biBvbiBhbiBbW0FjdG9yXV0gYW5kIGEgW1tTY2VuZV1dIG9ubHkgb25jZSBiZWZvcmUgdGhlIGZpcnN0IHVwZGF0ZSBjYWxsXHJcbiAgICAgKi9cclxuICAgIHZhciBJbml0aWFsaXplRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhJbml0aWFsaXplRXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIGVuZ2luZSAgVGhlIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBlbmdpbmVcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBJbml0aWFsaXplRXZlbnQoZW5naW5lLCB0YXJnZXQpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuZW5naW5lID0gZW5naW5lO1xyXG4gICAgICAgICAgICBfdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEluaXRpYWxpemVFdmVudDtcclxuICAgIH0oR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLkluaXRpYWxpemVFdmVudCA9IEluaXRpYWxpemVFdmVudDtcclxuICAgIC8qKlxyXG4gICAgICogRXZlbnQgdGhyb3duIG9uIGEgW1tTY2VuZV1dIG9uIGFjdGl2YXRpb25cclxuICAgICAqL1xyXG4gICAgdmFyIEFjdGl2YXRlRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhBY3RpdmF0ZUV2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBvbGRTY2VuZSAgVGhlIHJlZmVyZW5jZSB0byB0aGUgb2xkIHNjZW5lXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gQWN0aXZhdGVFdmVudChvbGRTY2VuZSwgdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLm9sZFNjZW5lID0gb2xkU2NlbmU7XHJcbiAgICAgICAgICAgIF90aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gQWN0aXZhdGVFdmVudDtcclxuICAgIH0oR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLkFjdGl2YXRlRXZlbnQgPSBBY3RpdmF0ZUV2ZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBFdmVudCB0aHJvd24gb24gYSBbW1NjZW5lXV0gb24gZGVhY3RpdmF0aW9uXHJcbiAgICAgKi9cclxuICAgIHZhciBEZWFjdGl2YXRlRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhEZWFjdGl2YXRlRXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIG5ld1NjZW5lICBUaGUgcmVmZXJlbmNlIHRvIHRoZSBuZXcgc2NlbmVcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBEZWFjdGl2YXRlRXZlbnQobmV3U2NlbmUsIHRhcmdldCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5uZXdTY2VuZSA9IG5ld1NjZW5lO1xyXG4gICAgICAgICAgICBfdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIERlYWN0aXZhdGVFdmVudDtcclxuICAgIH0oR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLkRlYWN0aXZhdGVFdmVudCA9IERlYWN0aXZhdGVFdmVudDtcclxuICAgIC8qKlxyXG4gICAgICogRXZlbnQgdGhyb3duIG9uIGFuIFtbQWN0b3JdXSB3aGVuIGl0IGNvbXBsZXRlbHkgbGVhdmVzIHRoZSBzY3JlZW4uXHJcbiAgICAgKi9cclxuICAgIHZhciBFeGl0Vmlld1BvcnRFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKEV4aXRWaWV3UG9ydEV2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIEV4aXRWaWV3UG9ydEV2ZW50KHRhcmdldCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEV4aXRWaWV3UG9ydEV2ZW50O1xyXG4gICAgfShHYW1lRXZlbnQpKTtcclxuICAgIGV4cG9ydHMuRXhpdFZpZXdQb3J0RXZlbnQgPSBFeGl0Vmlld1BvcnRFdmVudDtcclxuICAgIC8qKlxyXG4gICAgICogRXZlbnQgdGhyb3duIG9uIGFuIFtbQWN0b3JdXSB3aGVuIGl0IGNvbXBsZXRlbHkgbGVhdmVzIHRoZSBzY3JlZW4uXHJcbiAgICAgKi9cclxuICAgIHZhciBFbnRlclZpZXdQb3J0RXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhFbnRlclZpZXdQb3J0RXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gRW50ZXJWaWV3UG9ydEV2ZW50KHRhcmdldCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEVudGVyVmlld1BvcnRFdmVudDtcclxuICAgIH0oR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLkVudGVyVmlld1BvcnRFdmVudCA9IEVudGVyVmlld1BvcnRFdmVudDtcclxuICAgIHZhciBFbnRlclRyaWdnZXJFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKEVudGVyVHJpZ2dlckV2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIEVudGVyVHJpZ2dlckV2ZW50KHRhcmdldCwgYWN0b3IpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICBfdGhpcy5hY3RvciA9IGFjdG9yO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBFbnRlclRyaWdnZXJFdmVudDtcclxuICAgIH0oR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLkVudGVyVHJpZ2dlckV2ZW50ID0gRW50ZXJUcmlnZ2VyRXZlbnQ7XHJcbiAgICB2YXIgRXhpdFRyaWdnZXJFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKEV4aXRUcmlnZ2VyRXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gRXhpdFRyaWdnZXJFdmVudCh0YXJnZXQsIGFjdG9yKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgX3RoaXMuYWN0b3IgPSBhY3RvcjtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gRXhpdFRyaWdnZXJFdmVudDtcclxuICAgIH0oR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLkV4aXRUcmlnZ2VyRXZlbnQgPSBFeGl0VHJpZ2dlckV2ZW50O1xyXG59KTtcclxuZGVmaW5lKFwiQ2xhc3NcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJFdmVudERpc3BhdGNoZXJcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBFdmVudERpc3BhdGNoZXJfMykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEV4Y2FsaWJ1ciBiYXNlIGNsYXNzIHRoYXQgcHJvdmlkZXMgYmFzaWMgZnVuY3Rpb25hbGl0eSBzdWNoIGFzIFtbRXZlbnREaXNwYXRjaGVyXV1cclxuICAgICAqIGFuZCBleHRlbmRpbmcgYWJpbGl0aWVzIGZvciB2YW5pbGxhIEphdmFzY3JpcHQgcHJvamVjdHNcclxuICAgICAqL1xyXG4gICAgdmFyIENsYXNzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBDbGFzcygpIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIgPSBuZXcgRXZlbnREaXNwYXRjaGVyXzMuRXZlbnREaXNwYXRjaGVyKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbGlhcyBmb3IgYGFkZEV2ZW50TGlzdGVuZXJgLiBZb3UgY2FuIGxpc3RlbiBmb3IgYSB2YXJpZXR5IG9mXHJcbiAgICAgICAgICogZXZlbnRzIG9mZiBvZiB0aGUgZW5naW5lOyBzZWUgdGhlIGV2ZW50cyBzZWN0aW9uIGJlbG93IGZvciBhIGNvbXBsZXRlIGxpc3QuXHJcbiAgICAgICAgICogQHBhcmFtIGV2ZW50TmFtZSAgTmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIGZvclxyXG4gICAgICAgICAqIEBwYXJhbSBoYW5kbGVyICAgIEV2ZW50IGhhbmRsZXIgZm9yIHRoZSB0aHJvd24gZXZlbnRcclxuICAgICAgICAgKi9cclxuICAgICAgICBDbGFzcy5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLm9uKGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbGlhcyBmb3IgYHJlbW92ZUV2ZW50TGlzdGVuZXJgLiBJZiBvbmx5IHRoZSBldmVudE5hbWUgaXMgc3BlY2lmaWVkXHJcbiAgICAgICAgICogaXQgd2lsbCByZW1vdmUgYWxsIGhhbmRsZXJzIHJlZ2lzdGVyZWQgZm9yIHRoYXQgc3BlY2lmaWMgZXZlbnQuIElmIHRoZSBldmVudE5hbWVcclxuICAgICAgICAgKiBhbmQgdGhlIGhhbmRsZXIgaW5zdGFuY2UgYXJlIHNwZWNpZmllZCBvbmx5IHRoYXQgaGFuZGxlciB3aWxsIGJlIHJlbW92ZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gZXZlbnROYW1lICBOYW1lIG9mIHRoZSBldmVudCB0byBsaXN0ZW4gZm9yXHJcbiAgICAgICAgICogQHBhcmFtIGhhbmRsZXIgICAgRXZlbnQgaGFuZGxlciBmb3IgdGhlIHRocm93biBldmVudFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENsYXNzLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLm9mZihldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW1pdHMgYSBuZXcgZXZlbnRcclxuICAgICAgICAgKiBAcGFyYW0gZXZlbnROYW1lICAgTmFtZSBvZiB0aGUgZXZlbnQgdG8gZW1pdFxyXG4gICAgICAgICAqIEBwYXJhbSBldmVudE9iamVjdCBEYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGV2ZW50XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2xhc3MucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudE9iamVjdCkge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5lbWl0KGV2ZW50TmFtZSwgZXZlbnRPYmplY3QpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogT25jZSBsaXN0ZW5zIHRvIGFuIGV2ZW50IG9uZSB0aW1lLCB0aGVuIHVuc3Vic2NyaWJlcyBmcm9tIHRoYXQgZXZlbnRcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBldmVudE5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHN1YnNjcmliZSB0byBvbmNlXHJcbiAgICAgICAgICogQHBhcmFtIGhhbmRsZXIgICBUaGUgaGFuZGxlciBvZiB0aGUgZXZlbnQgdGhhdCB3aWxsIGJlIGF1dG8gdW5zdWJzY3JpYmVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2xhc3MucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLm9uY2UoZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFlvdSBtYXkgd2lzaCB0byBleHRlbmQgbmF0aXZlIEV4Y2FsaWJ1ciBmdW5jdGlvbmFsaXR5IGluIHZhbmlsbGEgSmF2YXNjcmlwdC5cclxuICAgICAgICAgKiBBbnkgbWV0aG9kIG9uIGEgY2xhc3MgaW5oZXJpdGluZyBbW0NsYXNzXV0gbWF5IGJlIGV4dGVuZGVkIHRvIHN1cHBvcnRcclxuICAgICAgICAgKiBhZGRpdGlvbmFsIGZ1bmN0aW9uYWxpdHkuIEluIHRoZSBleGFtcGxlIGJlbG93IHdlIGNyZWF0ZSBhIG5ldyB0eXBlIGNhbGxlZCBgTXlBY3RvcmAuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIGBgYGpzXHJcbiAgICAgICAgICogdmFyIE15QWN0b3IgPSBBY3Rvci5leHRlbmQoe1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAqICAgICAgIHRoaXMubmV3cHJvcCA9ICdzb21ldGhpbmcnO1xyXG4gICAgICAgICAqICAgICAgIEFjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICogICAgfSxcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgIHVwZGF0ZTogZnVuY3Rpb24oZW5naW5lLCBkZWx0YSkge1xyXG4gICAgICAgICAqICAgICAgIC8vIEltcGxlbWVudCBjdXN0b20gdXBkYXRlXHJcbiAgICAgICAgICogICAgICAgLy8gQ2FsbCBzdXBlciBjb25zdHJ1Y3RvciB1cGRhdGVcclxuICAgICAgICAgKiAgICAgICBBY3Rvci5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcywgZW5naW5lLCBkZWx0YSk7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgICBjb25zb2xlLmxvZyhcIlNvbWV0aGluZyBjb29sIVwiKTtcclxuICAgICAgICAgKiAgICB9XHJcbiAgICAgICAgICogfSk7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiB2YXIgbXlBY3RvciA9IG5ldyBNeUFjdG9yKDEwMCwgMTAwLCAxMDAsIDEwMCwgQ29sb3IuQXp1cmUpO1xyXG4gICAgICAgICAqIGBgYFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogSW4gVHlwZVNjcmlwdCwgeW91IG9ubHkgbmVlZCB0byB1c2UgdGhlIGBleHRlbmRzYCBzeW50YXgsIHlvdSBkbyBub3QgbmVlZFxyXG4gICAgICAgICAqIHRvIHVzZSB0aGlzIG1ldGhvZCBvZiBleHRlbnNpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gbWV0aG9kcyBBIEpTT04gb2JqZWN0IGNvbnRhaW4gYW55IG1ldGhvZHMvcHJvcGVydGllcyB5b3Ugd2FudCB0byBleHRlbmRcclxuICAgICAgICAgKi9cclxuICAgICAgICBDbGFzcy5leHRlbmQgPSBmdW5jdGlvbiAobWV0aG9kcykge1xyXG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGNoaWxkO1xyXG4gICAgICAgICAgICBpZiAobWV0aG9kcyAmJiBtZXRob2RzLmhhc093blByb3BlcnR5KCdjb25zdHJ1Y3RvcicpKSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZCA9IG1ldGhvZHMuY29uc3RydWN0b3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBhcmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFVzaW5nIGNvbnN0cnVjdG9yIGFsbG93cyBKUyB0byBsYXppbHkgaW5zdGFudGlhdGUgc3VwZXIgY2xhc3Nlc1xyXG4gICAgICAgICAgICB2YXIgU3VwZXIgPSBmdW5jdGlvbiAoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfTtcclxuICAgICAgICAgICAgU3VwZXIucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTtcclxuICAgICAgICAgICAgY2hpbGQucHJvdG90eXBlID0gbmV3IFN1cGVyO1xyXG4gICAgICAgICAgICBpZiAobWV0aG9kcykge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBtZXRob2RzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZHMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQucHJvdG90eXBlW3Byb3BdID0gbWV0aG9kc1twcm9wXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gTWFrZSBzdWJjbGFzc2VzIGV4dGVuZGFibGVcclxuICAgICAgICAgICAgY2hpbGQuZXh0ZW5kID0gQ2xhc3MuZXh0ZW5kO1xyXG4gICAgICAgICAgICByZXR1cm4gY2hpbGQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gQ2xhc3M7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5DbGFzcyA9IENsYXNzO1xyXG59KTtcclxuZGVmaW5lKFwiQWN0b3JcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJQaHlzaWNzXCIsIFwiQ2xhc3NcIiwgXCJDb2xsaXNpb24vQm91bmRpbmdCb3hcIiwgXCJSZXNvdXJjZXMvVGV4dHVyZVwiLCBcIkV2ZW50c1wiLCBcIkRyYXdpbmcvQ29sb3JcIiwgXCJEcmF3aW5nL1Nwcml0ZVwiLCBcIlV0aWwvTG9nXCIsIFwiQWN0aW9ucy9BY3Rpb25Db250ZXh0XCIsIFwiQWN0aW9ucy9BY3Rpb25cIiwgXCJBbGdlYnJhXCIsIFwiQ29sbGlzaW9uL0JvZHlcIiwgXCJDb2xsaXNpb24vU2lkZVwiLCBcIkNvbmZpZ3VyYWJsZVwiLCBcIlRyYWl0cy9JbmRleFwiLCBcIkRyYXdpbmcvU3ByaXRlRWZmZWN0c1wiLCBcIlV0aWwvVXRpbFwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIFBoeXNpY3NfMTMsIENsYXNzXzExLCBCb3VuZGluZ0JveF84LCBUZXh0dXJlXzQsIEV2ZW50c18xNCwgQ29sb3JfMjAsIFNwcml0ZV80LCBMb2dfMTYsIEFjdGlvbkNvbnRleHRfMywgQWN0aW9uXzIsIEFsZ2VicmFfMjQsIEJvZHlfMiwgU2lkZV80LCBDb25maWd1cmFibGVfOCwgVHJhaXRzLCBFZmZlY3RzLCBVdGlsKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogQGhpZGRlblxyXG4gICAgICovXHJcbiAgICB2YXIgQWN0b3JJbXBsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoQWN0b3JJbXBsLCBfc3VwZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB4ICAgICAgIFRoZSBzdGFydGluZyB4IGNvb3JkaW5hdGUgb2YgdGhlIGFjdG9yXHJcbiAgICAgICAgICogQHBhcmFtIHkgICAgICAgVGhlIHN0YXJ0aW5nIHkgY29vcmRpbmF0ZSBvZiB0aGUgYWN0b3JcclxuICAgICAgICAgKiBAcGFyYW0gd2lkdGggICBUaGUgc3RhcnRpbmcgd2lkdGggb2YgdGhlIGFjdG9yXHJcbiAgICAgICAgICogQHBhcmFtIGhlaWdodCAgVGhlIHN0YXJ0aW5nIGhlaWdodCBvZiB0aGUgYWN0b3JcclxuICAgICAgICAgKiBAcGFyYW0gY29sb3IgICBUaGUgc3RhcnRpbmcgY29sb3Igb2YgdGhlIGFjdG9yLiBMZWF2ZSBudWxsIHRvIGRyYXcgYSB0cmFuc3BhcmVudCBhY3Rvci4gVGhlIG9wYWNpdHkgb2YgdGhlIGNvbG9yIHdpbGwgYmUgdXNlZCBhcyB0aGVcclxuICAgICAgICAgKiBpbml0aWFsIFtbb3BhY2l0eV1dLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIEFjdG9ySW1wbCh4T3JDb25maWcsIHksIHdpZHRoLCBoZWlnaHQsIGNvbG9yKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBhY3RvclxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuaWQgPSBBY3RvckltcGwubWF4SWQrKztcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBwaHlzaWNzIGJvZHkgdGhlIGlzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGFjdG9yLiBUaGUgYm9keSBpcyB0aGUgY29udGFpbmVyIGZvciBhbGwgcGh5c2ljYWwgcHJvcGVydGllcywgbGlrZSBwb3NpdGlvbiwgdmVsb2NpdHksXHJcbiAgICAgICAgICAgICAqIGFjY2VsZXJhdGlvbiwgbWFzcywgaW5lcnRpYSwgZXRjLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuYm9keSA9IG5ldyBCb2R5XzIuQm9keShfdGhpcyk7XHJcbiAgICAgICAgICAgIF90aGlzLl9oZWlnaHQgPSAwO1xyXG4gICAgICAgICAgICBfdGhpcy5fd2lkdGggPSAwO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIHNjYWxlIHZlY3RvciBvZiB0aGUgYWN0b3JcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLnNjYWxlID0gbmV3IEFsZ2VicmFfMjQuVmVjdG9yKDEsIDEpO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIHggc2NhbGFyIHZlbG9jaXR5IG9mIHRoZSBhY3RvciBpbiBzY2FsZS9zZWNvbmRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLnN4ID0gMDsgLy9zY2FsZS9zZWNcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSB5IHNjYWxhciB2ZWxvY2l0eSBvZiB0aGUgYWN0b3IgaW4gc2NhbGUvc2Vjb25kXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5zeSA9IDA7IC8vc2NhbGUvc2VjXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgYWN0b3IgaXMgcGh5c2ljYWxseSBpbiB0aGUgdmlld3BvcnRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmlzT2ZmU2NyZWVuID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgdmlzaWJpbGl0eSBvZiBhbiBhY3RvclxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgb3BhY2l0eSBvZiBhbiBhY3Rvci4gUGFzc2luZyBpbiBhIGNvbG9yIGluIHRoZSBbW2NvbnN0cnVjdG9yXV0gd2lsbCB1c2UgdGhlXHJcbiAgICAgICAgICAgICAqIGNvbG9yJ3Mgb3BhY2l0eS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLm9wYWNpdHkgPSAxO1xyXG4gICAgICAgICAgICBfdGhpcy5wcmV2aW91c09wYWNpdHkgPSAxO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ29udmVuaWVuY2UgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgbG9nZ2VyXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5sb2dnZXIgPSBMb2dfMTYuTG9nZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgc2NlbmUgdGhhdCB0aGUgYWN0b3IgaXMgaW5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLnNjZW5lID0gbnVsbDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBwYXJlbnQgb2YgdGhpcyBhY3RvclxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMucGFyZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgLy8gVE9ETzogUmVwbGFjZSB0aGlzIHdpdGggdGhlIG5ldyBhY3RvciBjb2xsZWN0aW9uIG9uY2Ugei1pbmRleGluZyBpcyBidWlsdFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGNoaWxkcmVuIG9mIHRoaXMgYWN0b3JcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmNoaWxkcmVuID0gW107XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGN1cnJlbnQgY29sbGlzaW9uIHR5cGUgb2YgdGhpcyBhY3Rvci4gQnlcclxuICAgICAgICAgICAgICogZGVmYXVsdCBpdCBpcyAoW1tDb2xsaXNpb25UeXBlLlByZXZlbnRDb2xsaXNpb25dXSkuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5jb2xsaXNpb25UeXBlID0gQ29sbGlzaW9uVHlwZS5QcmV2ZW50Q29sbGlzaW9uO1xyXG4gICAgICAgICAgICBfdGhpcy5jb2xsaXNpb25Hcm91cHMgPSBbXTtcclxuICAgICAgICAgICAgX3RoaXMuX2NvbGxpc2lvbkhhbmRsZXJzID0ge307XHJcbiAgICAgICAgICAgIF90aGlzLl9pc0luaXRpYWxpemVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIF90aGlzLmZyYW1lcyA9IHt9O1xyXG4gICAgICAgICAgICBfdGhpcy5fZWZmZWN0c0RpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBY2Nlc3MgdG8gdGhlIGN1cnJlbnQgZHJhd2luZyBmb3IgdGhlIGFjdG9yLCB0aGlzIGNhbiBiZVxyXG4gICAgICAgICAgICAgKiBhbiBbW0FuaW1hdGlvbl1dLCBbW1Nwcml0ZV1dLCBvciBbW1BvbHlnb25dXS5cclxuICAgICAgICAgICAgICogU2V0IGRyYXdpbmdzIHdpdGggW1tzZXREcmF3aW5nXV0uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5jdXJyZW50RHJhd2luZyA9IG51bGw7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBNb2RpZnkgdGhlIGN1cnJlbnQgYWN0b3IgdXBkYXRlIHBpcGVsaW5lLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMudHJhaXRzID0gW107XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0byBlbmFibGUgdGhlIFtbQ2FwdHVyZVBvaW50ZXJdXSB0cmFpdCB0aGF0IHByb3BhZ2F0ZXNcclxuICAgICAgICAgICAgICogcG9pbnRlciBldmVudHMgdG8gdGhpcyBhY3RvclxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuZW5hYmxlQ2FwdHVyZVBvaW50ZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENvbmZpZ3VyYXRpb24gZm9yIFtbQ2FwdHVyZVBvaW50ZXJdXSB0cmFpdFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuY2FwdHVyZVBvaW50ZXIgPSB7XHJcbiAgICAgICAgICAgICAgICBjYXB0dXJlTW92ZUV2ZW50czogZmFsc2VcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgX3RoaXMuX3pJbmRleCA9IDA7XHJcbiAgICAgICAgICAgIF90aGlzLl9pc0tpbGxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBfdGhpcy5fb3BhY2l0eUZ4ID0gbmV3IEVmZmVjdHMuT3BhY2l0eShfdGhpcy5vcGFjaXR5KTtcclxuICAgICAgICAgICAgaWYgKHhPckNvbmZpZyAmJiB0eXBlb2YgeE9yQ29uZmlnID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbmZpZyA9IHhPckNvbmZpZztcclxuICAgICAgICAgICAgICAgIHhPckNvbmZpZyA9IGNvbmZpZy5wb3MgPyBjb25maWcucG9zLnggOiBjb25maWcueDtcclxuICAgICAgICAgICAgICAgIHkgPSBjb25maWcucG9zID8gY29uZmlnLnBvcy55IDogY29uZmlnLnk7XHJcbiAgICAgICAgICAgICAgICB3aWR0aCA9IGNvbmZpZy53aWR0aDtcclxuICAgICAgICAgICAgICAgIGhlaWdodCA9IGNvbmZpZy5oZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMucG9zLnggPSB4T3JDb25maWcgfHwgMDtcclxuICAgICAgICAgICAgX3RoaXMucG9zLnkgPSB5IHx8IDA7XHJcbiAgICAgICAgICAgIF90aGlzLl93aWR0aCA9IHdpZHRoIHx8IDA7XHJcbiAgICAgICAgICAgIF90aGlzLl9oZWlnaHQgPSBoZWlnaHQgfHwgMDtcclxuICAgICAgICAgICAgaWYgKGNvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5jb2xvciA9IGNvbG9yO1xyXG4gICAgICAgICAgICAgICAgLy8gc2V0IGRlZmF1bHQgb3BhY2l0eSBvZiBhbiBhY3RvciB0byB0aGUgY29sb3JcclxuICAgICAgICAgICAgICAgIF90aGlzLm9wYWNpdHkgPSBjb2xvci5hO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEJ1aWxkIGRlZmF1bHQgcGlwZWxpbmVcclxuICAgICAgICAgICAgLy90aGlzLnRyYWl0cy5wdXNoKG5ldyBleC5UcmFpdHMuRXVsZXJNb3ZlbWVudCgpKTtcclxuICAgICAgICAgICAgLy8gVE9ETzogVGlsZU1hcHMgc2hvdWxkIGJlIGNvbnZlcnRlZCB0byBhIGNvbGxpc2lvbiBhcmVhXHJcbiAgICAgICAgICAgIF90aGlzLnRyYWl0cy5wdXNoKG5ldyBUcmFpdHMuVGlsZU1hcENvbGxpc2lvbkRldGVjdGlvbigpKTtcclxuICAgICAgICAgICAgX3RoaXMudHJhaXRzLnB1c2gobmV3IFRyYWl0cy5PZmZzY3JlZW5DdWxsaW5nKCkpO1xyXG4gICAgICAgICAgICBfdGhpcy50cmFpdHMucHVzaChuZXcgVHJhaXRzLkNhcHR1cmVQb2ludGVyKCkpO1xyXG4gICAgICAgICAgICAvLyBCdWlsZCB0aGUgYWN0aW9uIHF1ZXVlXHJcbiAgICAgICAgICAgIF90aGlzLmFjdGlvblF1ZXVlID0gbmV3IEFjdGlvbl8yLkFjdGlvblF1ZXVlKF90aGlzKTtcclxuICAgICAgICAgICAgX3RoaXMuYWN0aW9ucyA9IG5ldyBBY3Rpb25Db250ZXh0XzMuQWN0aW9uQ29udGV4dChfdGhpcyk7XHJcbiAgICAgICAgICAgIC8vIGRlZmF1bHQgYW5jaG9yIGlzIGluIHRoZSBtaWRkbGVcclxuICAgICAgICAgICAgX3RoaXMuYW5jaG9yID0gbmV3IEFsZ2VicmFfMjQuVmVjdG9yKC41LCAuNSk7XHJcbiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgZGVmYXVsdCBjb2xsaXNpb24gYXJlYSB0byBiZSBib3hcclxuICAgICAgICAgICAgX3RoaXMuYm9keS51c2VCb3hDb2xsaXNpb24oKTtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0b3JJbXBsLnByb3RvdHlwZSwgXCJjb2xsaXNpb25BcmVhXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIGNvbGxpc2lvbiBhcmVhIHNoYXBlIHRvIHVzZSBmb3IgY29sbGlzaW9uIHBvc3NpYmxlIG9wdGlvbnMgYXJlIFtDaXJjbGVBcmVhfGNpcmNsZXNdLCBbUG9seWdvbkFyZWF8cG9seWdvbnNdLCBhbmRcclxuICAgICAgICAgICAgICogW0VkZ2VBcmVhfGVkZ2VzXS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5jb2xsaXNpb25BcmVhO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgY29sbGlzaW9uIGFyZWEgc2hhcGUgdG8gdXNlIGZvciBjb2xsaXNpb24gcG9zc2libGUgb3B0aW9ucyBhcmUgW0NpcmNsZUFyZWF8Y2lyY2xlc10sIFtQb2x5Z29uQXJlYXxwb2x5Z29uc10sIGFuZFxyXG4gICAgICAgICAgICAgKiBbRWRnZUFyZWF8ZWRnZXNdLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoYXJlYSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5LmNvbGxpc2lvbkFyZWEgPSBhcmVhO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0b3JJbXBsLnByb3RvdHlwZSwgXCJ4XCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIHggcG9zaXRpb24gb2YgdGhlIGFjdG9yIHJlbGF0aXZlIHRvIGl0J3MgcGFyZW50IChpZiBhbnkpXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJvZHkucG9zLng7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXRzIHRoZSB4IHBvc2l0aW9uIG9mIHRoZSBhY3RvciByZWxhdGl2ZSB0byBpdCdzIHBhcmVudCAoaWYgYW55KVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodGhlWCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5LnBvcy54ID0gdGhlWDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdG9ySW1wbC5wcm90b3R5cGUsIFwieVwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSB5IHBvc2l0aW9uIG9mIHRoZSBhY3RvciByZWxhdGl2ZSB0byBpdCdzIHBhcmVudCAoaWYgYW55KVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5LnBvcy55O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0cyB0aGUgeSBwb3NpdGlvbiBvZiB0aGUgYWN0b3IgcmVsYXRpdmUgdG8gaXQncyBwYXJlbnQgKGlmIGFueSlcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHRoZVkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYm9keS5wb3MueSA9IHRoZVk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3RvckltcGwucHJvdG90eXBlLCBcInBvc1wiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBwb3NpdGlvbiB2ZWN0b3Igb2YgdGhlIGFjdG9yIGluIHBpeGVsc1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5LnBvcztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHMgdGhlIHBvc2l0aW9uIHZlY3RvciBvZiB0aGUgYWN0b3IgaW4gcGl4ZWxzXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0aGVQb3MpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYm9keS5wb3Muc2V0VG8odGhlUG9zLngsIHRoZVBvcy55KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdG9ySW1wbC5wcm90b3R5cGUsIFwib2xkUG9zXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIHBvc2l0aW9uIHZlY3RvciBvZiB0aGUgYWN0b3IgZnJvbSB0aGUgbGFzdCBmcmFtZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5Lm9sZFBvcztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHMgdGhlIHBvc2l0aW9uIHZlY3RvciBvZiB0aGUgYWN0b3IgaW4gdGhlIGxhc3QgZnJhbWVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHRoZVBvcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5Lm9sZFBvcy5zZXRUbyh0aGVQb3MueCwgdGhlUG9zLnkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0b3JJbXBsLnByb3RvdHlwZSwgXCJ2ZWxcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgdmVsb2NpdHkgdmVjdG9yIG9mIHRoZSBhY3RvciBpbiBwaXhlbHMvc2VjXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJvZHkudmVsO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0cyB0aGUgdmVsb2NpdHkgdmVjdG9yIG9mIHRoZSBhY3RvciBpbiBwaXhlbHMvc2VjXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0aGVWZWwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYm9keS52ZWwuc2V0VG8odGhlVmVsLngsIHRoZVZlbC55KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdG9ySW1wbC5wcm90b3R5cGUsIFwib2xkVmVsXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIHZlbG9jaXR5IHZlY3RvciBvZiB0aGUgYWN0b3IgZnJvbSB0aGUgbGFzdCBmcmFtZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5Lm9sZFZlbDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHMgdGhlIHZlbG9jaXR5IHZlY3RvciBvZiB0aGUgYWN0b3IgZnJvbSB0aGUgbGFzdCBmcmFtZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodGhlVmVsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvZHkub2xkVmVsLnNldFRvKHRoZVZlbC54LCB0aGVWZWwueSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3RvckltcGwucHJvdG90eXBlLCBcImFjY1wiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBhY2NlbGVyYXRpb24gdmVjdG9yIG9mIHRoZSBhY3RvciBpbiBwaXhlbHMvc2Vjb25kL3NlY29uZC4gQW4gYWNjZWxlcmF0aW9uIHBvaW50aW5nIGRvd24gc3VjaCBhcyAoMCwgMTAwKSBtYXkgYmVcclxuICAgICAgICAgICAgICogdXNlZnVsIHRvIHNpbXVsYXRlIGEgZ3Jhdml0YXRpb25hbCBlZmZlY3QuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJvZHkuYWNjO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0cyB0aGUgYWNjZWxlcmF0aW9uIHZlY3RvciBvZiB0ZWggYWN0b3IgaW4gcGl4ZWxzL3NlY29uZC9zZWNvbmRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHRoZUFjYykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5LmFjYy5zZXRUbyh0aGVBY2MueCwgdGhlQWNjLnkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0b3JJbXBsLnByb3RvdHlwZSwgXCJyb3RhdGlvblwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSByb3RhdGlvbiBvZiB0aGUgYWN0b3IgaW4gcmFkaWFucy4gMSByYWRpYW4gPSAxODAvUEkgRGVncmVlcy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5yb3RhdGlvbjtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHMgdGhlIHJvdGF0aW9uIG9mIHRoZSBhY3RvciBpbiByYWRpYW5zLiAxIHJhZGlhbiA9IDE4MC9QSSBEZWdyZWVzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodGhlQW5nbGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYm9keS5yb3RhdGlvbiA9IHRoZUFuZ2xlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0b3JJbXBsLnByb3RvdHlwZSwgXCJyeFwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSByb3RhdGlvbmFsIHZlbG9jaXR5IG9mIHRoZSBhY3RvciBpbiByYWRpYW5zL3NlY29uZFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5LnJ4O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0cyB0aGUgcm90YXRpb25hbCB2ZWxvY2l0eSBvZiB0aGUgYWN0b3IgaW4gcmFkaWFucy9zZWNcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGFuZ3VsYXJWZWxvY2l0eSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5LnJ4ID0gYW5ndWxhclZlbG9jaXR5O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0b3JJbXBsLnByb3RvdHlwZSwgXCJ0b3JxdWVcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgY3VycmVudCB0b3JxdWUgYXBwbGllZCB0byB0aGUgYWN0b3IuIFRvcnF1ZSBjYW4gYmUgdGhvdWdodCBvZiBhcyByb3RhdGlvbmFsIGZvcmNlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJvZHkudG9ycXVlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0cyB0aGUgY3VycmVudCB0b3JxdWUgYXBwbGllZCB0byB0aGUgYWN0b3IuIFRvcnF1ZSBjYW4gYmUgdGhvdWdodCBvZiBhcyByb3RhdGlvbmFsIGZvcmNlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0aGVUb3JxdWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYm9keS50b3JxdWUgPSB0aGVUb3JxdWU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3RvckltcGwucHJvdG90eXBlLCBcIm1hc3NcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0IHRoZSBjdXJyZW50IG1hc3Mgb2YgdGhlIGFjdG9yLCBtYXNzIGNhbiBiZSB0aG91Z2h0IG9mIGFzIHRoZSByZXNpc3RhbmNlIHRvIGFjY2VsZXJhdGlvbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5tYXNzO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0cyB0aGUgbWFzcyBvZiB0aGUgYWN0b3IsIG1hc3MgY2FuIGJlIHRob3VnaHQgb2YgYXMgdGhlIHJlc2lzdGFuY2UgdG8gYWNjZWxlcmF0aW9uLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodGhlTWFzcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5Lm1hc3MgPSB0aGVNYXNzO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0b3JJbXBsLnByb3RvdHlwZSwgXCJtb2lcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgY3VycmVudCBtb21lbnQgb2YgaW5lcnRpYSwgbW9pIGNhbiBiZSB0aG91Z2h0IG9mIGFzIHRoZSByZXNpc3RhbmNlIHRvIHJvdGF0aW9uLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5Lm1vaTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHMgdGhlIGN1cnJlbnQgbW9tZW50IG9mIGluZXJ0aWEsIG1vaSBjYW4gYmUgdGhvdWdodCBvZiBhcyB0aGUgcmVzaXN0YW5jZSB0byByb3RhdGlvbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHRoZU1vaSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5Lm1vaSA9IHRoZU1vaTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdG9ySW1wbC5wcm90b3R5cGUsIFwiZnJpY3Rpb25cIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgY29lZmZpY2llbnQgb2YgZnJpY3Rpb24gb24gdGhpcyBhY3RvciwgdGhpcyBjYW4gYmUgdGhvdWdodCBvZiBhcyBob3cgc3RpY2t5IG9yIHNsaXBwZXJ5IGFuIG9iamVjdCBpcy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5mcmljdGlvbjtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHMgdGhlIGNvZWZmaWNpZW50IG9mIGZyaWN0aW9uIG9mIHRoaXMgYWN0b3IsIHRoaXMgY2FuIHZlIHRob3VnaHQgb2YgYXMgaG93IHN0aWNrIG9yIHNsaXBwZXJ5IGFuIG9iamVjdCBpcy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHRoZUZyaWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvZHkuZnJpY3Rpb24gPSB0aGVGcmljdGlvbjtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdG9ySW1wbC5wcm90b3R5cGUsIFwicmVzdGl0dXRpb25cIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgY29lZmZpY2llbnQgb2YgcmVzdGl0dXRpb24gb2YgdGhpcyBhY3RvciwgcmVwcmVzZW50cyB0aGUgYW1vdW50IG9mIGVuZXJneSBwcmVzZXJ2ZWQgYWZ0ZXIgY29sbGlzaW9uLiBUaGluayBvZiB0aGlzXHJcbiAgICAgICAgICAgICAqIGFzIGJvdW5jaW5lc3MuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJvZHkucmVzdGl0dXRpb247XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXRzIHRoZSBjb2VmZmljaWVudCBvZiByZXN0aXR1dGlvbiBvZiB0aGlzIGFjdG9yLCByZXByZXNlbnRzIHRoZSBhbW91bnQgb2YgZW5lcmd5IHByZXNlcnZlZCBhZnRlciBjb2xsaXNpb24uIFRoaW5rIG9mIHRoaXNcclxuICAgICAgICAgICAgICogYXMgYm91bmNpbmVzcy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHRoZVJlc3RpdHV0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvZHkucmVzdGl0dXRpb24gPSB0aGVSZXN0aXR1dGlvbjtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdG9ySW1wbC5wcm90b3R5cGUsIFwiY29sb3JcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0cyB0aGUgY29sb3Igb2YgdGhlIGFjdG9yLiBBIHJlY3RhbmdsZSBvZiB0aGlzIGNvbG9yIHdpbGwgYmVcclxuICAgICAgICAgICAgICogZHJhd24gaWYgbm8gW1tJRHJhd2FibGVdXSBpcyBzcGVjaWZpZWQgYXMgdGhlIGFjdG9ycyBkcmF3aW5nLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBUaGUgZGVmYXVsdCBpcyBgbnVsbGAgd2hpY2ggcHJldmVudHMgYSByZWN0YW5nbGUgZnJvbSBiZWluZyBkcmF3bi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG9yO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xvciA9IHYuY2xvbmUoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBpcyBjYWxsZWQgYmVmb3JlIHRoZSBmaXJzdCB1cGRhdGUgb2YgdGhlIGFjdG9yLiBUaGlzIG1ldGhvZCBpcyBtZWFudCB0byBiZVxyXG4gICAgICAgICAqIG92ZXJyaWRkZW4uIFRoaXMgaXMgd2hlcmUgaW5pdGlhbGl6YXRpb24gb2YgY2hpbGQgYWN0b3JzIHNob3VsZCB0YWtlIHBsYWNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUub25Jbml0aWFsaXplID0gZnVuY3Rpb24gKF9lbmdpbmUpIHtcclxuICAgICAgICAgICAgLy8gT3ZlcnJpZGUgbWVcclxuICAgICAgICB9O1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3RvckltcGwucHJvdG90eXBlLCBcImlzSW5pdGlhbGl6ZWRcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB3ZXRoZXIgdGhlIGFjdG9yIGlzIEluaXRpYWxpemVkXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc0luaXRpYWxpemVkO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbml0aWFsaXplcyB0aGlzIGFjdG9yIGFuZCBhbGwgaXQncyBjaGlsZCBhY3RvcnMsIG1lYW50IHRvIGJlIGNhbGxlZCBieSB0aGUgU2NlbmUgYmVmb3JlIGZpcnN0IHVwZGF0ZSBub3QgYnkgdXNlcnMgb2YgRXhjYWxpYnVyLlxyXG4gICAgICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUuX2luaXRpYWxpemUgPSBmdW5jdGlvbiAoZW5naW5lKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0luaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uSW5pdGlhbGl6ZShlbmdpbmUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIuZW1pdCgnaW5pdGlhbGl6ZScsIG5ldyBFdmVudHNfMTQuSW5pdGlhbGl6ZUV2ZW50KGVuZ2luZSwgdGhpcykpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faXNJbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuY2hpbGRyZW47IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICBjaGlsZC5faW5pdGlhbGl6ZShlbmdpbmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLl9jaGVja0ZvclBvaW50ZXJPcHRJbiA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWQgPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgIGlmIChub3JtYWxpemVkID09PSAncG9pbnRlcnVwJyB8fCBub3JtYWxpemVkID09PSAncG9pbnRlcmRvd24nIHx8IG5vcm1hbGl6ZWQgPT09ICdwb2ludGVybW92ZScpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZUNhcHR1cmVQb2ludGVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZCA9PT0gJ3BvaW50ZXJtb3ZlJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhcHR1cmVQb2ludGVyLmNhcHR1cmVNb3ZlRXZlbnRzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrRm9yUG9pbnRlck9wdEluKGV2ZW50TmFtZSk7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLm9uKGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrRm9yUG9pbnRlck9wdEluKGV2ZW50TmFtZSk7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLm9uY2UoZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIHRoZSBjdXJyZW50IGFjdG9yIGlzIGEgbWVtYmVyIG9mIHRoZSBzY2VuZSwgdGhpcyB3aWxsIHJlbW92ZVxyXG4gICAgICAgICAqIGl0IGZyb20gdGhlIHNjZW5lIGdyYXBoLiBJdCB3aWxsIG5vIGxvbmdlciBiZSBkcmF3biBvciB1cGRhdGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUua2lsbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2NlbmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgna2lsbCcsIG5ldyBFdmVudHNfMTQuS2lsbEV2ZW50KHRoaXMpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUucmVtb3ZlKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faXNLaWxsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybignQ2Fubm90IGtpbGwgYWN0b3IsIGl0IHdhcyBuZXZlciBhZGRlZCB0byB0aGUgU2NlbmUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgdGhlIGN1cnJlbnQgYWN0b3IgaXMga2lsbGVkLCBpdCB3aWxsIG5vdyBub3QgYmUga2lsbGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUudW5raWxsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9pc0tpbGxlZCA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5kaWNhdGVzIHdldGhlciB0aGUgYWN0b3IgaGFzIGJlZW4ga2lsbGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUuaXNLaWxsZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc0tpbGxlZDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYSBjaGlsZCBhY3RvciB0byB0aGlzIGFjdG9yLiBBbGwgbW92ZW1lbnQgb2YgdGhlIGNoaWxkIGFjdG9yIHdpbGwgYmVcclxuICAgICAgICAgKiByZWxhdGl2ZSB0byB0aGUgcGFyZW50IGFjdG9yLiBNZWFuaW5nIGlmIHRoZSBwYXJlbnQgbW92ZXMgdGhlIGNoaWxkIHdpbGxcclxuICAgICAgICAgKiBtb3ZlIHdpdGggaXQuXHJcbiAgICAgICAgICogQHBhcmFtIGFjdG9yIFRoZSBjaGlsZCBhY3RvciB0byBhZGRcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChhY3Rvcikge1xyXG4gICAgICAgICAgICBhY3Rvci5jb2xsaXNpb25UeXBlID0gQ29sbGlzaW9uVHlwZS5QcmV2ZW50Q29sbGlzaW9uO1xyXG4gICAgICAgICAgICBpZiAoVXRpbC5hZGRJdGVtVG9BcnJheShhY3RvciwgdGhpcy5jaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgICAgIGFjdG9yLnBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgYSBjaGlsZCBhY3RvciBmcm9tIHRoaXMgYWN0b3IuXHJcbiAgICAgICAgICogQHBhcmFtIGFjdG9yIFRoZSBjaGlsZCBhY3RvciB0byByZW1vdmVcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChhY3Rvcikge1xyXG4gICAgICAgICAgICBpZiAoVXRpbC5yZW1vdmVJdGVtRnJvbUFycmF5KGFjdG9yLCB0aGlzLmNoaWxkcmVuKSkge1xyXG4gICAgICAgICAgICAgICAgYWN0b3IucGFyZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS5zZXREcmF3aW5nID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICBrZXkgPSBrZXkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudERyYXdpbmcgIT09IHRoaXMuZnJhbWVzW2tleV0pIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZyYW1lc1trZXldICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyYW1lc1trZXldLnJlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50RHJhd2luZyA9IHRoaXMuZnJhbWVzW2tleV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBMb2dfMTYuTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoJ3RoZSBzcGVjaWZpZWQgZHJhd2luZyBrZXkgXFwnJyArIGtleSArICdcXCcgZG9lcyBub3QgZXhpc3QnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS5hZGREcmF3aW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZXNbYXJndW1lbnRzWzBdXSA9IGFyZ3VtZW50c1sxXTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jdXJyZW50RHJhd2luZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudERyYXdpbmcgPSBhcmd1bWVudHNbMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lZmZlY3RzRGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIFNwcml0ZV80LlNwcml0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRHJhd2luZygnZGVmYXVsdCcsIGFyZ3VtZW50c1swXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgVGV4dHVyZV80LlRleHR1cmUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZERyYXdpbmcoJ2RlZmF1bHQnLCBhcmd1bWVudHNbMF0uYXNTcHJpdGUoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3RvckltcGwucHJvdG90eXBlLCBcInpcIiwge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFpJbmRleCgpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdaKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFpJbmRleChuZXdaKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgei1pbmRleCBvZiBhbiBhY3Rvci4gVGhlIHotaW5kZXggZGV0ZXJtaW5lcyB0aGUgcmVsYXRpdmUgb3JkZXIgYW4gYWN0b3IgaXMgZHJhd24gaW4uXHJcbiAgICAgICAgICogQWN0b3JzIHdpdGggYSBoaWdoZXIgei1pbmRleCBhcmUgZHJhd24gb24gdG9wIG9mIGFjdG9ycyB3aXRoIGEgbG93ZXIgei1pbmRleFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUuZ2V0WkluZGV4ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fekluZGV4O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgei1pbmRleCBvZiBhbiBhY3RvciBhbmQgdXBkYXRlcyBpdCBpbiB0aGUgZHJhd2luZyBsaXN0IGZvciB0aGUgc2NlbmUuXHJcbiAgICAgICAgICogVGhlIHotaW5kZXggZGV0ZXJtaW5lcyB0aGUgcmVsYXRpdmUgb3JkZXIgYW4gYWN0b3IgaXMgZHJhd24gaW4uXHJcbiAgICAgICAgICogQWN0b3JzIHdpdGggYSBoaWdoZXIgei1pbmRleCBhcmUgZHJhd24gb24gdG9wIG9mIGFjdG9ycyB3aXRoIGEgbG93ZXIgei1pbmRleFxyXG4gICAgICAgICAqIEBwYXJhbSBuZXdJbmRleCBuZXcgei1pbmRleCB0byBhc3NpZ25cclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLnNldFpJbmRleCA9IGZ1bmN0aW9uIChuZXdJbmRleCkge1xyXG4gICAgICAgICAgICB0aGlzLnNjZW5lLmNsZWFudXBEcmF3VHJlZSh0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5fekluZGV4ID0gbmV3SW5kZXg7XHJcbiAgICAgICAgICAgIHRoaXMuc2NlbmUudXBkYXRlRHJhd1RyZWUodGhpcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGFuIGFjdG9yIHRvIGEgY29sbGlzaW9uIGdyb3VwLiBBY3RvcnMgd2l0aCBubyBuYW1lZCBjb2xsaXNpb24gZ3JvdXBzIGFyZVxyXG4gICAgICAgICAqIGNvbnNpZGVyZWQgdG8gYmUgaW4gZXZlcnkgY29sbGlzaW9uIGdyb3VwLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogT25jZSBpbiBhIGNvbGxpc2lvbiBncm91cChzKSBhY3RvcnMgd2lsbCBvbmx5IGNvbGxpZGUgd2l0aCBvdGhlciBhY3RvcnMgaW5cclxuICAgICAgICAgKiB0aGF0IGdyb3VwLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGNvbGxpc2lvbiBncm91cFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUuYWRkQ29sbGlzaW9uR3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbGxpc2lvbkdyb3Vwcy5wdXNoKG5hbWUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlcyBhbiBhY3RvciBmcm9tIGEgY29sbGlzaW9uIGdyb3VwLlxyXG4gICAgICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBjb2xsaXNpb24gZ3JvdXBcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLnJlbW92ZUNvbGxpc2lvbkdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5jb2xsaXNpb25Hcm91cHMuaW5kZXhPZihuYW1lKTtcclxuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25Hcm91cHMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IHRoZSBjZW50ZXIgcG9pbnQgb2YgYW4gYWN0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLmdldENlbnRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbGdlYnJhXzI0LlZlY3Rvcih0aGlzLnBvcy54ICsgdGhpcy5nZXRXaWR0aCgpIC8gMiAtIHRoaXMuYW5jaG9yLnggKiB0aGlzLmdldFdpZHRoKCksIHRoaXMucG9zLnkgKyB0aGlzLmdldEhlaWdodCgpIC8gMiAtIHRoaXMuYW5jaG9yLnkgKiB0aGlzLmdldEhlaWdodCgpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGNhbGN1bGF0ZWQgd2lkdGggb2YgYW4gYWN0b3IsIGZhY3RvcmluZyBpbiBzY2FsZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUuZ2V0V2lkdGggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93aWR0aCAqIHRoaXMuZ2V0R2xvYmFsU2NhbGUoKS54O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgd2lkdGggb2YgYW4gYWN0b3IsIGZhY3RvcmluZyBpbiB0aGUgY3VycmVudCBzY2FsZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUuc2V0V2lkdGggPSBmdW5jdGlvbiAod2lkdGgpIHtcclxuICAgICAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aCAvIHRoaXMuc2NhbGUueDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGNhbGN1bGF0ZWQgaGVpZ2h0IG9mIGFuIGFjdG9yLCBmYWN0b3JpbmcgaW4gc2NhbGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodCAqIHRoaXMuZ2V0R2xvYmFsU2NhbGUoKS55O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgaGVpZ2h0IG9mIGFuIGFjdG9yLCBmYWN0b3JpbmcgaW4gdGhlIGN1cnJlbnQgc2NhbGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLnNldEhlaWdodCA9IGZ1bmN0aW9uIChoZWlnaHQpIHtcclxuICAgICAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0IC8gdGhpcy5zY2FsZS55O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgbGVmdCBlZGdlIG9mIHRoZSBhY3RvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUuZ2V0TGVmdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Qm91bmRzKCkubGVmdDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIHJpZ2h0IGVkZ2Ugb2YgdGhlIGFjdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS5nZXRSaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Qm91bmRzKCkucmlnaHQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSB0b3AgZWRnZSBvZiB0aGUgYWN0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLmdldFRvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Qm91bmRzKCkudG9wO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgYm90dG9tIGVkZ2Ugb2YgdGhlIGFjdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS5nZXRCb3R0b20gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEJvdW5kcygpLmJvdHRvbTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhpcyBhY3RvcidzIHJvdGF0aW9uIHRha2luZyBpbnRvIGFjY291bnQgYW55IHBhcmVudCByZWxhdGlvbnNoaXBzXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyBSb3RhdGlvbiBhbmdsZSBpbiByYWRpYW5zXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS5nZXRXb3JsZFJvdGF0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yb3RhdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3RhdGlvbiArIHRoaXMucGFyZW50LmdldFdvcmxkUm90YXRpb24oKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgYW4gYWN0b3IncyB3b3JsZCBwb3NpdGlvbiB0YWtpbmcgaW50byBhY2NvdW50IHBhcmVudCByZWxhdGlvbnNoaXBzLCBzY2FsaW5nLCByb3RhdGlvbiwgYW5kIHRyYW5zbGF0aW9uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyBQb3NpdGlvbiBpbiB3b3JsZCBjb29yZGluYXRlc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUuZ2V0V29ybGRQb3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBvcy5jbG9uZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNvbGxlY3QgcGFyZW50cyAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgcGFyZW50cyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgcm9vdCA9IHRoaXM7XHJcbiAgICAgICAgICAgIHBhcmVudHMucHVzaCh0aGlzKTtcclxuICAgICAgICAgICAgLy8gZmluZCBwYXJlbnRzXHJcbiAgICAgICAgICAgIHdoaWxlIChyb290LnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgcm9vdCA9IHJvb3QucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgcGFyZW50cy5wdXNoKHJvb3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBwb3NpdGlvbiAgICAgICBcclxuICAgICAgICAgICAgdmFyIHggPSBwYXJlbnRzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uIChweCwgcCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHAucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHB4ICsgKHAucG9zLnggKiBwLmdldEdsb2JhbFNjYWxlKCkueCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHggKyBwLnBvcy54O1xyXG4gICAgICAgICAgICB9LCAwKTtcclxuICAgICAgICAgICAgdmFyIHkgPSBwYXJlbnRzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uIChweSwgcCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHAucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHB5ICsgKHAucG9zLnkgKiBwLmdldEdsb2JhbFNjYWxlKCkueSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHkgKyBwLnBvcy55O1xyXG4gICAgICAgICAgICB9LCAwKTtcclxuICAgICAgICAgICAgLy8gcm90YXRlIGFyb3VuZCByb290IGFuY2hvclxyXG4gICAgICAgICAgICB2YXIgcmEgPSByb290LmdldFdvcmxkUG9zKCk7IC8vIDEwLCAxMFxyXG4gICAgICAgICAgICB2YXIgciA9IHRoaXMuZ2V0V29ybGRSb3RhdGlvbigpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFsZ2VicmFfMjQuVmVjdG9yKHgsIHkpLnJvdGF0ZShyLCByYSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBnbG9iYWwgc2NhbGUgb2YgdGhlIEFjdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS5nZXRHbG9iYWxTY2FsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBbGdlYnJhXzI0LlZlY3Rvcih0aGlzLnNjYWxlLngsIHRoaXMuc2NhbGUueSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHBhcmVudFNjYWxlID0gdGhpcy5wYXJlbnQuZ2V0R2xvYmFsU2NhbGUoKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbGdlYnJhXzI0LlZlY3Rvcih0aGlzLnNjYWxlLnggKiBwYXJlbnRTY2FsZS54LCB0aGlzLnNjYWxlLnkgKiBwYXJlbnRTY2FsZS55KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIGFjdG9yJ3MgW1tCb3VuZGluZ0JveF1dIGNhbGN1bGF0ZWQgZm9yIHRoaXMgaW5zdGFudCBpbiB3b3JsZCBzcGFjZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gdG9kbyBjYWNoZSBib3VuZGluZyBib3hcclxuICAgICAgICAgICAgdmFyIGFuY2hvciA9IHRoaXMuX2dldENhbGN1bGF0ZWRBbmNob3IoKTtcclxuICAgICAgICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0V29ybGRQb3MoKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveF84LkJvdW5kaW5nQm94KHBvcy54IC0gYW5jaG9yLngsIHBvcy55IC0gYW5jaG9yLnksIHBvcy54ICsgdGhpcy5nZXRXaWR0aCgpIC0gYW5jaG9yLngsIHBvcy55ICsgdGhpcy5nZXRIZWlnaHQoKSAtIGFuY2hvci55KS5yb3RhdGUodGhpcy5yb3RhdGlvbiwgcG9zKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIGFjdG9yJ3MgW1tCb3VuZGluZ0JveF1dIHJlbGF0aXZlIHRvIHRoZSBhY3RvcnMgcG9zaXRpb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS5nZXRSZWxhdGl2ZUJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gdG9kbyBjYWNoZSBib3VuZGluZyBib3hcclxuICAgICAgICAgICAgdmFyIGFuY2hvciA9IHRoaXMuX2dldENhbGN1bGF0ZWRBbmNob3IoKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveF84LkJvdW5kaW5nQm94KC1hbmNob3IueCwgLWFuY2hvci55LCB0aGlzLmdldFdpZHRoKCkgLSBhbmNob3IueCwgdGhpcy5nZXRIZWlnaHQoKSAtIGFuY2hvci55KS5yb3RhdGUodGhpcy5yb3RhdGlvbik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZXN0cyB3aGV0aGVyIHRoZSB4L3kgc3BlY2lmaWVkIGFyZSBjb250YWluZWQgaW4gdGhlIGFjdG9yXHJcbiAgICAgICAgICogQHBhcmFtIHggIFggY29vcmRpbmF0ZSB0byB0ZXN0IChpbiB3b3JsZCBjb29yZGluYXRlcylcclxuICAgICAgICAgKiBAcGFyYW0geSAgWSBjb29yZGluYXRlIHRvIHRlc3QgKGluIHdvcmxkIGNvb3JkaW5hdGVzKVxyXG4gICAgICAgICAqIEBwYXJhbSByZWN1cnNlIGNoZWNrcyB3aGV0aGVyIHRoZSB4L3kgYXJlIGNvbnRhaW5lZCBpbiBhbnkgY2hpbGQgYWN0b3JzIChpZiB0aGV5IGV4aXN0KS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKHgsIHksIHJlY3Vyc2UpIHtcclxuICAgICAgICAgICAgaWYgKHJlY3Vyc2UgPT09IHZvaWQgMCkgeyByZWN1cnNlID0gZmFsc2U7IH1cclxuICAgICAgICAgICAgdmFyIGNvbnRhaW5tZW50ID0gdGhpcy5nZXRCb3VuZHMoKS5jb250YWlucyhuZXcgQWxnZWJyYV8yNC5WZWN0b3IoeCwgeSkpO1xyXG4gICAgICAgICAgICBpZiAocmVjdXJzZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5tZW50IHx8IHRoaXMuY2hpbGRyZW4uc29tZShmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQuY29udGFpbnMoeCwgeSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY29udGFpbm1lbnQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBzaWRlIG9mIHRoZSBjb2xsaXNpb24gYmFzZWQgb24gdGhlIGludGVyc2VjdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSBpbnRlcnNlY3QgVGhlIGRpc3BsYWNlbWVudCB2ZWN0b3IgcmV0dXJuZWQgYnkgYSBjb2xsaXNpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLmdldFNpZGVGcm9tSW50ZXJzZWN0ID0gZnVuY3Rpb24gKGludGVyc2VjdCkge1xyXG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoaW50ZXJzZWN0LngpID4gTWF0aC5hYnMoaW50ZXJzZWN0LnkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludGVyc2VjdC54IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gU2lkZV80LlNpZGUuUmlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTaWRlXzQuU2lkZS5MZWZ0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludGVyc2VjdC55IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gU2lkZV80LlNpZGUuQm90dG9tO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU2lkZV80LlNpZGUuVG9wO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBTaWRlXzQuU2lkZS5Ob25lO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVzdCB3aGV0aGVyIHRoZSBhY3RvciBoYXMgY29sbGlkZWQgd2l0aCBhbm90aGVyIGFjdG9yLCByZXR1cm5zIHRoZSBzaWRlIG9mIHRoZSBjdXJyZW50IGFjdG9yIHRoYXQgY29sbGlkZWQuXHJcbiAgICAgICAgICogQHBhcmFtIGFjdG9yIFRoZSBvdGhlciBhY3RvciB0byB0ZXN0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS5jb2xsaWRlc1dpdGhTaWRlID0gZnVuY3Rpb24gKGFjdG9yKSB7XHJcbiAgICAgICAgICAgIHZhciBzZXBhcmF0aW9uVmVjdG9yID0gdGhpcy5jb2xsaWRlcyhhY3Rvcik7XHJcbiAgICAgICAgICAgIGlmICghc2VwYXJhdGlvblZlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNpZGVfNC5TaWRlLk5vbmU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHNlcGFyYXRpb25WZWN0b3IueCkgPiBNYXRoLmFicyhzZXBhcmF0aW9uVmVjdG9yLnkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wb3MueCA8IGFjdG9yLnBvcy54KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNpZGVfNC5TaWRlLlJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNpZGVfNC5TaWRlLkxlZnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wb3MueSA8IGFjdG9yLnBvcy55KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNpZGVfNC5TaWRlLkJvdHRvbTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTaWRlXzQuU2lkZS5Ub3A7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRlc3Qgd2hldGhlciB0aGUgYWN0b3IgaGFzIGNvbGxpZGVkIHdpdGggYW5vdGhlciBhY3RvciwgcmV0dXJucyB0aGUgaW50ZXJzZWN0aW9uIHZlY3RvciBvbiBjb2xsaXNpb24uIFJldHVybnNcclxuICAgICAgICAgKiBgbnVsbGAgd2hlbiB0aGVyZSBpcyBubyBjb2xsaXNpb247XHJcbiAgICAgICAgICogQHBhcmFtIGFjdG9yIFRoZSBvdGhlciBhY3RvciB0byB0ZXN0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS5jb2xsaWRlcyA9IGZ1bmN0aW9uIChhY3Rvcikge1xyXG4gICAgICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoKTtcclxuICAgICAgICAgICAgdmFyIG90aGVyQm91bmRzID0gYWN0b3IuZ2V0Qm91bmRzKCk7XHJcbiAgICAgICAgICAgIHZhciBpbnRlcnNlY3QgPSBib3VuZHMuY29sbGlkZXMob3RoZXJCb3VuZHMpO1xyXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJzZWN0O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVnaXN0ZXIgYSBoYW5kbGVyIHRvIGZpcmUgd2hlbiB0aGlzIGFjdG9yIGNvbGxpZGVzIHdpdGggYW5vdGhlciBpbiBhIHNwZWNpZmllZCBncm91cFxyXG4gICAgICAgICAqIEBwYXJhbSBncm91cCBUaGUgZ3JvdXAgbmFtZSB0byBsaXN0ZW4gZm9yXHJcbiAgICAgICAgICogQHBhcmFtIGZ1bmMgVGhlIGNhbGxiYWNrIHRvIGZpcmUgb24gY29sbGlzaW9uIHdpdGggYW5vdGhlciBhY3RvciBmcm9tIHRoZSBncm91cC4gVGhlIGNhbGxiYWNrIGlzIHBhc3NlZCB0aGUgb3RoZXIgYWN0b3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS5vbkNvbGxpZGVzV2l0aCA9IGZ1bmN0aW9uIChncm91cCwgZnVuYykge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2NvbGxpc2lvbkhhbmRsZXJzW2dyb3VwXSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY29sbGlzaW9uSGFuZGxlcnNbZ3JvdXBdID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fY29sbGlzaW9uSGFuZGxlcnNbZ3JvdXBdLnB1c2goZnVuYyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLmdldENvbGxpc2lvbkhhbmRsZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sbGlzaW9uSGFuZGxlcnM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGFsbCBjb2xsaXNpb24gaGFuZGxlcnMgZm9yIHRoaXMgZ3JvdXAgb24gdGhpcyBhY3RvclxyXG4gICAgICAgICAqIEBwYXJhbSBncm91cCBHcm91cCB0byByZW1vdmUgYWxsIGhhbmRsZXJzIGZvciBvbiB0aGlzIGFjdG9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUucmVtb3ZlQ29sbGlkZXNXaXRoID0gZnVuY3Rpb24gKGdyb3VwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbGxpc2lvbkhhbmRsZXJzW2dyb3VwXSA9IFtdO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0d28gYWN0b3JzIGFyZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGRpc3RhbmNlIHNwZWNpZmllZCBmcm9tIGVhY2ggb3RoZXJcclxuICAgICAgICAgKiBAcGFyYW0gYWN0b3IgICAgIEFjdG9yIHRvIHRlc3RcclxuICAgICAgICAgKiBAcGFyYW0gZGlzdGFuY2UgIERpc3RhbmNlIGluIHBpeGVscyB0byB0ZXN0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS53aXRoaW4gPSBmdW5jdGlvbiAoYWN0b3IsIGRpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy5wb3MueCAtIGFjdG9yLnBvcy54LCAyKSArIE1hdGgucG93KHRoaXMucG9zLnkgLSBhY3Rvci5wb3MueSwgMikpIDw9IGRpc3RhbmNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS5fZ2V0Q2FsY3VsYXRlZEFuY2hvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbGdlYnJhXzI0LlZlY3Rvcih0aGlzLmdldFdpZHRoKCkgKiB0aGlzLmFuY2hvci54LCB0aGlzLmdldEhlaWdodCgpICogdGhpcy5hbmNob3IueSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLl9yZWFwcGx5RWZmZWN0cyA9IGZ1bmN0aW9uIChkcmF3aW5nKSB7XHJcbiAgICAgICAgICAgIGRyYXdpbmcucmVtb3ZlRWZmZWN0KHRoaXMuX29wYWNpdHlGeCk7XHJcbiAgICAgICAgICAgIGRyYXdpbmcuYWRkRWZmZWN0KHRoaXMuX29wYWNpdHlGeCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQZXJmb3JtIGV1bGVyIGludGVncmF0aW9uIGF0IHRoZSBzcGVjaWZpZWQgdGltZSBzdGVwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS5pbnRlZ3JhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcclxuICAgICAgICAgICAgLy8gVXBkYXRlIHBsYWNlbWVudHMgYmFzZWQgb24gbGluZWFyIGFsZ2VicmFcclxuICAgICAgICAgICAgdmFyIHNlY29uZHMgPSBkZWx0YSAvIDEwMDA7XHJcbiAgICAgICAgICAgIHZhciB0b3RhbEFjYyA9IHRoaXMuYWNjLmNsb25lKCk7XHJcbiAgICAgICAgICAgIC8vIE9ubHkgYWN0aXZlIHZhbmlsbGEgYWN0b3JzIGFyZSBhZmZlY3RlZCBieSBnbG9iYWwgYWNjZWxlcmF0aW9uXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbGxpc2lvblR5cGUgPT09IENvbGxpc2lvblR5cGUuQWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICB0b3RhbEFjYy5hZGRFcXVhbChQaHlzaWNzXzEzLlBoeXNpY3MuYWNjKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnZlbC5hZGRFcXVhbCh0b3RhbEFjYy5zY2FsZShzZWNvbmRzKSk7XHJcbiAgICAgICAgICAgIHRoaXMucG9zLmFkZEVxdWFsKHRoaXMudmVsLnNjYWxlKHNlY29uZHMpKS5hZGRFcXVhbCh0b3RhbEFjYy5zY2FsZSgwLjUgKiBzZWNvbmRzICogc2Vjb25kcykpO1xyXG4gICAgICAgICAgICB0aGlzLnJ4ICs9IHRoaXMudG9ycXVlICogKDEuMCAvIHRoaXMubW9pKSAqIHNlY29uZHM7XHJcbiAgICAgICAgICAgIHRoaXMucm90YXRpb24gKz0gdGhpcy5yeCAqIHNlY29uZHM7XHJcbiAgICAgICAgICAgIHRoaXMuc2NhbGUueCArPSB0aGlzLnN4ICogZGVsdGEgLyAxMDAwO1xyXG4gICAgICAgICAgICB0aGlzLnNjYWxlLnkgKz0gdGhpcy5zeSAqIGRlbHRhIC8gMTAwMDtcclxuICAgICAgICAgICAgLy8gVXBkYXRlIHBoeXNpY3MgYm9keVxyXG4gICAgICAgICAgICB0aGlzLmJvZHkudXBkYXRlKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxsZWQgYnkgdGhlIEVuZ2luZSwgdXBkYXRlcyB0aGUgc3RhdGUgb2YgdGhlIGFjdG9yXHJcbiAgICAgICAgICogQHBhcmFtIGVuZ2luZSBUaGUgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGdhbWUgZW5naW5lXHJcbiAgICAgICAgICogQHBhcmFtIGRlbHRhICBUaGUgdGltZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHVwZGF0ZSBpbiBtaWxsaXNlY29uZHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChlbmdpbmUsIGRlbHRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemUoZW5naW5lKTtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdwcmV1cGRhdGUnLCBuZXcgRXZlbnRzXzE0LlByZVVwZGF0ZUV2ZW50KGVuZ2luZSwgZGVsdGEsIHRoaXMpKTtcclxuICAgICAgICAgICAgLy8gVXBkYXRlIGFjdGlvbiBxdWV1ZVxyXG4gICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlLnVwZGF0ZShkZWx0YSk7XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBjb2xvciBvbmx5IG9wYWNpdHlcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29sb3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29sb3IuYSA9IHRoaXMub3BhY2l0eTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgY2hhbmdpbmcgb3BhY2l0eVxyXG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2aW91c09wYWNpdHkgIT09IHRoaXMub3BhY2l0eSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91c09wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vcGFjaXR5Rngub3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VmZmVjdHNEaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQ2FwdHVyZSBvbGQgdmFsdWVzIGJlZm9yZSBpbnRlZ3JhdGlvbiBzdGVwIHVwZGF0ZXMgdGhlbVxyXG4gICAgICAgICAgICB0aGlzLm9sZFZlbC5zZXRUbyh0aGlzLnZlbC54LCB0aGlzLnZlbC55KTtcclxuICAgICAgICAgICAgdGhpcy5vbGRQb3Muc2V0VG8odGhpcy5wb3MueCwgdGhpcy5wb3MueSk7XHJcbiAgICAgICAgICAgIC8vIFJ1biBFdWxlciBpbnRlZ3JhdGlvblxyXG4gICAgICAgICAgICB0aGlzLmludGVncmF0ZShkZWx0YSk7XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBhY3RvciBwaXBlbGluZSAobW92ZW1lbnQsIGNvbGxpc2lvbiBkZXRlY3Rpb24sIGV2ZW50IHByb3BhZ2F0aW9uLCBvZmZzY3JlZW4gY3VsbGluZylcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMudHJhaXRzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRyYWl0ID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgdHJhaXQudXBkYXRlKHRoaXMsIGVuZ2luZSwgZGVsdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBjaGlsZCBhY3RvcnNcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLnVwZGF0ZShlbmdpbmUsIGRlbHRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3Bvc3R1cGRhdGUnLCBuZXcgRXZlbnRzXzE0LlBvc3RVcGRhdGVFdmVudChlbmdpbmUsIGRlbHRhLCB0aGlzKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxsZWQgYnkgdGhlIEVuZ2luZSwgZHJhd3MgdGhlIGFjdG9yIHRvIHRoZSBzY3JlZW5cclxuICAgICAgICAgKiBAcGFyYW0gY3R4ICAgVGhlIHJlbmRlcmluZyBjb250ZXh0XHJcbiAgICAgICAgICogQHBhcmFtIGRlbHRhIFRoZSB0aW1lIHNpbmNlIHRoZSBsYXN0IGRyYXcgaW4gbWlsbGlzZWNvbmRzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGN0eCwgZGVsdGEpIHtcclxuICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLnBvcy54LCB0aGlzLnBvcy55KTtcclxuICAgICAgICAgICAgY3R4LnJvdGF0ZSh0aGlzLnJvdGF0aW9uKTtcclxuICAgICAgICAgICAgY3R4LnNjYWxlKHRoaXMuc2NhbGUueCwgdGhpcy5zY2FsZS55KTtcclxuICAgICAgICAgICAgLy8gdHJhbnNsYXRlIGNhbnZhcyBieSBhbmNob3Igb2Zmc2V0XHJcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLSh0aGlzLl93aWR0aCAqIHRoaXMuYW5jaG9yLngpLCAtKHRoaXMuX2hlaWdodCAqIHRoaXMuYW5jaG9yLnkpKTtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdwcmVkcmF3JywgbmV3IEV2ZW50c18xNC5QcmVEcmF3RXZlbnQoY3R4LCBkZWx0YSwgdGhpcykpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50RHJhd2luZykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRyYXdpbmcgPSB0aGlzLmN1cnJlbnREcmF3aW5nO1xyXG4gICAgICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9leGNhbGlidXJqcy9FeGNhbGlidXIvcHVsbC82MTkgZm9yIGRpc2N1c3Npb24gb24gdGhpcyBmb3JtdWxhICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldFggPSAodGhpcy5fd2lkdGggLSBkcmF3aW5nLm5hdHVyYWxXaWR0aCAqIGRyYXdpbmcuc2NhbGUueCkgKiB0aGlzLmFuY2hvci54O1xyXG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldFkgPSAodGhpcy5faGVpZ2h0IC0gZHJhd2luZy5uYXR1cmFsSGVpZ2h0ICogZHJhd2luZy5zY2FsZS55KSAqIHRoaXMuYW5jaG9yLnk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZWZmZWN0c0RpcnR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVhcHBseUVmZmVjdHModGhpcy5jdXJyZW50RHJhd2luZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZWZmZWN0c0RpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnREcmF3aW5nLmRyYXcoY3R4LCBvZmZzZXRYLCBvZmZzZXRZKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuY29sb3IudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgLy8gRHJhdyBjaGlsZCBhY3RvcnNcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltpXS52aXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS5kcmF3KGN0eCwgZGVsdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncG9zdGRyYXcnLCBuZXcgRXZlbnRzXzE0LlBvc3REcmF3RXZlbnQoY3R4LCBkZWx0YSwgdGhpcykpO1xyXG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FsbGVkIGJ5IHRoZSBFbmdpbmUsIGRyYXdzIHRoZSBhY3RvcnMgZGVidWdnaW5nIHRvIHRoZSBzY3JlZW5cclxuICAgICAgICAgKiBAcGFyYW0gY3R4IFRoZSByZW5kZXJpbmcgY29udGV4dFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncHJlZGVidWdkcmF3JywgbmV3IEV2ZW50c18xNC5QcmVEZWJ1Z0RyYXdFdmVudChjdHgsIHRoaXMpKTtcclxuICAgICAgICAgICAgdGhpcy5ib2R5LmRlYnVnRHJhdyhjdHgpO1xyXG4gICAgICAgICAgICAvLyBEcmF3IGFjdG9yIGJvdW5kaW5nIGJveFxyXG4gICAgICAgICAgICB2YXIgYmIgPSB0aGlzLmdldEJvdW5kcygpO1xyXG4gICAgICAgICAgICBiYi5kZWJ1Z0RyYXcoY3R4KTtcclxuICAgICAgICAgICAgLy8gRHJhdyBhY3RvciBJZFxyXG4gICAgICAgICAgICBjdHguZmlsbFRleHQoJ2lkOiAnICsgdGhpcy5pZCwgYmIubGVmdCArIDMsIGJiLnRvcCArIDEwKTtcclxuICAgICAgICAgICAgLy8gRHJhdyBhY3RvciBhbmNob3IgVmVjdG9yXHJcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBDb2xvcl8yMC5Db2xvci5ZZWxsb3cudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHguYXJjKHRoaXMuZ2V0V29ybGRQb3MoKS54LCB0aGlzLmdldFdvcmxkUG9zKCkueSwgMywgMCwgTWF0aC5QSSAqIDIpO1xyXG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XHJcbiAgICAgICAgICAgIC8vIEN1bGxpbmcgQm94IGRlYnVnIGRyYXdcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnRyYWl0cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhaXRzW2pdIGluc3RhbmNlb2YgVHJhaXRzLk9mZnNjcmVlbkN1bGxpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWl0c1tqXS5jdWxsaW5nQm94LmRlYnVnRHJhdyhjdHgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFVuaXQgQ2lyY2xlIGRlYnVnIGRyYXdcclxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gQ29sb3JfMjAuQ29sb3IuWWVsbG93LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgdmFyIHJhZGl1cyA9IE1hdGgubWluKHRoaXMuZ2V0V2lkdGgoKSwgdGhpcy5nZXRIZWlnaHQoKSk7XHJcbiAgICAgICAgICAgIGN0eC5hcmModGhpcy5nZXRXb3JsZFBvcygpLngsIHRoaXMuZ2V0V29ybGRQb3MoKS55LCByYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcclxuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgICAgIHZhciB0aWNrcyA9IHtcclxuICAgICAgICAgICAgICAgICcwIFBpJzogMCxcclxuICAgICAgICAgICAgICAgICdQaS8yJzogTWF0aC5QSSAvIDIsXHJcbiAgICAgICAgICAgICAgICAnUGknOiBNYXRoLlBJLFxyXG4gICAgICAgICAgICAgICAgJzMvMiBQaSc6IDMgKiBNYXRoLlBJIC8gMlxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgb2xkRm9udCA9IGN0eC5mb250O1xyXG4gICAgICAgICAgICBmb3IgKHZhciB0aWNrIGluIHRpY2tzKSB7XHJcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gQ29sb3JfMjAuQ29sb3IuWWVsbG93LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBjdHguZm9udCA9ICcxNHB4JztcclxuICAgICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcclxuICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dCh0aWNrLCB0aGlzLmdldFdvcmxkUG9zKCkueCArIE1hdGguY29zKHRpY2tzW3RpY2tdKSAqIChyYWRpdXMgKyAxMCksIHRoaXMuZ2V0V29ybGRQb3MoKS55ICsgTWF0aC5zaW4odGlja3NbdGlja10pICogKHJhZGl1cyArIDEwKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3R4LmZvbnQgPSBvbGRGb250O1xyXG4gICAgICAgICAgICAvLyBEcmF3IGNoaWxkIGFjdG9yc1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0uZGVidWdEcmF3KGN0eCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdwb3N0ZGVidWdkcmF3JywgbmV3IEV2ZW50c18xNC5Qb3N0RGVidWdEcmF3RXZlbnQoY3R4LCB0aGlzKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gQWN0b3JJbXBsO1xyXG4gICAgfShDbGFzc18xMS5DbGFzcykpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbmRpY2F0ZXMgdGhlIG5leHQgaWQgdG8gYmUgc2V0XHJcbiAgICAgKi9cclxuICAgIEFjdG9ySW1wbC5tYXhJZCA9IDA7XHJcbiAgICBleHBvcnRzLkFjdG9ySW1wbCA9IEFjdG9ySW1wbDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1vc3QgaW1wb3J0YW50IHByaW1pdGl2ZSBpbiBFeGNhbGlidXIgaXMgYW4gYEFjdG9yYC4gQW55dGhpbmcgdGhhdFxyXG4gICAgICogY2FuIG1vdmUgb24gdGhlIHNjcmVlbiwgY29sbGlkZSB3aXRoIGFub3RoZXIgYEFjdG9yYCwgcmVzcG9uZCB0byBldmVudHMsXHJcbiAgICAgKiBvciBpbnRlcmFjdCB3aXRoIHRoZSBjdXJyZW50IHNjZW5lLCBtdXN0IGJlIGFuIGFjdG9yLiBBbiBgQWN0b3JgICoqbXVzdCoqXHJcbiAgICAgKiBiZSBwYXJ0IG9mIGEgW1tTY2VuZV1dIGZvciBpdCB0byBiZSBkcmF3biB0byB0aGUgc2NyZWVuLlxyXG4gICAgICpcclxuICAgICAqIFtbaW5jbHVkZTpBY3RvcnMubWRdXVxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBbW2luY2x1ZGU6Q29uc3RydWN0b3JzLm1kXV1cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIHZhciBBY3RvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKEFjdG9yLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIEFjdG9yKHhPckNvbmZpZywgeSwgd2lkdGgsIGhlaWdodCwgY29sb3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHhPckNvbmZpZywgeSwgd2lkdGgsIGhlaWdodCwgY29sb3IpIHx8IHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBBY3RvcjtcclxuICAgIH0oQ29uZmlndXJhYmxlXzguQ29uZmlndXJhYmxlKEFjdG9ySW1wbCkpKTtcclxuICAgIGV4cG9ydHMuQWN0b3IgPSBBY3RvcjtcclxuICAgIC8qKlxyXG4gICAgICogQW4gZW51bSB0aGF0IGRlc2NyaWJlcyB0aGUgdHlwZXMgb2YgY29sbGlzaW9ucyBhY3RvcnMgY2FuIHBhcnRpY2lwYXRlIGluXHJcbiAgICAgKi9cclxuICAgIHZhciBDb2xsaXNpb25UeXBlO1xyXG4gICAgKGZ1bmN0aW9uIChDb2xsaXNpb25UeXBlKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWN0b3JzIHdpdGggdGhlIGBQcmV2ZW50Q29sbGlzaW9uYCBzZXR0aW5nIGRvIG5vdCBwYXJ0aWNpcGF0ZSBpbiBhbnlcclxuICAgICAgICAgKiBjb2xsaXNpb25zIGFuZCBkbyBub3QgcmFpc2UgY29sbGlzaW9uIGV2ZW50cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xsaXNpb25UeXBlW0NvbGxpc2lvblR5cGVbXCJQcmV2ZW50Q29sbGlzaW9uXCJdID0gMF0gPSBcIlByZXZlbnRDb2xsaXNpb25cIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBY3RvcnMgd2l0aCB0aGUgYFBhc3NpdmVgIHNldHRpbmcgb25seSByYWlzZSBjb2xsaXNpb24gZXZlbnRzLCBidXQgYXJlIG5vdFxyXG4gICAgICAgICAqIGluZmx1ZW5jZWQgb3IgbW92ZWQgYnkgb3RoZXIgYWN0b3JzIGFuZCBkbyBub3QgaW5mbHVlbmNlIG9yIG1vdmUgb3RoZXIgYWN0b3JzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbGxpc2lvblR5cGVbQ29sbGlzaW9uVHlwZVtcIlBhc3NpdmVcIl0gPSAxXSA9IFwiUGFzc2l2ZVwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFjdG9ycyB3aXRoIHRoZSBgQWN0aXZlYCBzZXR0aW5nIHJhaXNlIGNvbGxpc2lvbiBldmVudHMgYW5kIHBhcnRpY2lwYXRlXHJcbiAgICAgICAgICogaW4gY29sbGlzaW9ucyB3aXRoIG90aGVyIGFjdG9ycyBhbmQgd2lsbCBiZSBwdXNoIG9yIG1vdmVkIGJ5IGFjdG9ycyBzaGFyaW5nXHJcbiAgICAgICAgICogdGhlIGBBY3RpdmVgIG9yIGBGaXhlZGAgc2V0dGluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xsaXNpb25UeXBlW0NvbGxpc2lvblR5cGVbXCJBY3RpdmVcIl0gPSAyXSA9IFwiQWN0aXZlXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWN0b3JzIHdpdGggdGhlIGBGaXhlZGAgc2V0dGluZyByYWlzZSBjb2xsaXNpb24gZXZlbnRzIGFuZCBwYXJ0aWNpcGF0ZSBpblxyXG4gICAgICAgICAqIGNvbGxpc2lvbnMgd2l0aCBvdGhlciBhY3RvcnMuIEFjdG9ycyB3aXRoIHRoZSBgRml4ZWRgIHNldHRpbmcgd2lsbCBub3QgYmVcclxuICAgICAgICAgKiBwdXNoZWQgb3IgbW92ZWQgYnkgb3RoZXIgYWN0b3JzIHNoYXJpbmcgdGhlIGBGaXhlZGAuIFRoaW5rIG9mIEZpeGVkXHJcbiAgICAgICAgICogYWN0b3JzIGFzIFwiaW1tb3ZhYmxlL29uc3RvcHBhYmxlXCIgb2JqZWN0cy4gSWYgdHdvIGBGaXhlZGAgYWN0b3JzIG1lZXQgdGhleSB3aWxsXHJcbiAgICAgICAgICogbm90IGJlIHB1c2hlZCBvciBtb3ZlZCBieSBlYWNoIG90aGVyLCB0aGV5IHdpbGwgbm90IGludGVyYWN0IGV4Y2VwdCB0byB0aHJvd1xyXG4gICAgICAgICAqIGNvbGxpc2lvbiBldmVudHMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sbGlzaW9uVHlwZVtDb2xsaXNpb25UeXBlW1wiRml4ZWRcIl0gPSAzXSA9IFwiRml4ZWRcIjtcclxuICAgIH0pKENvbGxpc2lvblR5cGUgPSBleHBvcnRzLkNvbGxpc2lvblR5cGUgfHwgKGV4cG9ydHMuQ29sbGlzaW9uVHlwZSA9IHt9KSk7XHJcbn0pO1xyXG5kZWZpbmUoXCJBY3Rpb25zL0FjdGlvblwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkFjdGlvbnMvUm90YXRpb25UeXBlXCIsIFwiQWxnZWJyYVwiLCBcIlV0aWwvTG9nXCIsIFwiVXRpbC9VdGlsXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgUm90YXRpb25UeXBlXzIsIEFsZ2VicmFfMjUsIExvZ18xNywgVXRpbCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICB2YXIgRWFzZVRvID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBFYXNlVG8oYWN0b3IsIHgsIHksIGR1cmF0aW9uLCBlYXNpbmdGY24pIHtcclxuICAgICAgICAgICAgdGhpcy5hY3RvciA9IGFjdG9yO1xyXG4gICAgICAgICAgICB0aGlzLmVhc2luZ0ZjbiA9IGVhc2luZ0ZjbjtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudExlcnBUaW1lID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fbGVycER1cmF0aW9uID0gMSAqIDEwMDA7IC8vIDEgc2Vjb25kXHJcbiAgICAgICAgICAgIHRoaXMuX2xlcnBTdGFydCA9IG5ldyBBbGdlYnJhXzI1LlZlY3RvcigwLCAwKTtcclxuICAgICAgICAgICAgdGhpcy5fbGVycEVuZCA9IG5ldyBBbGdlYnJhXzI1LlZlY3RvcigwLCAwKTtcclxuICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2xlcnBEdXJhdGlvbiA9IGR1cmF0aW9uO1xyXG4gICAgICAgICAgICB0aGlzLl9sZXJwRW5kID0gbmV3IEFsZ2VicmFfMjUuVmVjdG9yKHgsIHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBFYXNlVG8ucHJvdG90eXBlLl9pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9sZXJwU3RhcnQgPSBuZXcgQWxnZWJyYV8yNS5WZWN0b3IodGhpcy5hY3Rvci5wb3MueCwgdGhpcy5hY3Rvci5wb3MueSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRMZXJwVGltZSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gdGhpcy5fbGVycFN0YXJ0LmRpc3RhbmNlKHRoaXMuX2xlcnBFbmQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRWFzZVRvLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBuZXdYID0gdGhpcy5hY3Rvci5wb3MueDtcclxuICAgICAgICAgICAgdmFyIG5ld1kgPSB0aGlzLmFjdG9yLnBvcy55O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudExlcnBUaW1lIDwgdGhpcy5fbGVycER1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbGVycEVuZC54IDwgdGhpcy5fbGVycFN0YXJ0LngpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdYID0gdGhpcy5fbGVycFN0YXJ0LnggLSAodGhpcy5lYXNpbmdGY24odGhpcy5fY3VycmVudExlcnBUaW1lLCB0aGlzLl9sZXJwRW5kLngsIHRoaXMuX2xlcnBTdGFydC54LCB0aGlzLl9sZXJwRHVyYXRpb24pIC0gdGhpcy5fbGVycEVuZC54KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1ggPSB0aGlzLmVhc2luZ0Zjbih0aGlzLl9jdXJyZW50TGVycFRpbWUsIHRoaXMuX2xlcnBTdGFydC54LCB0aGlzLl9sZXJwRW5kLngsIHRoaXMuX2xlcnBEdXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbGVycEVuZC55IDwgdGhpcy5fbGVycFN0YXJ0LnkpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdZID0gdGhpcy5fbGVycFN0YXJ0LnkgLSAodGhpcy5lYXNpbmdGY24odGhpcy5fY3VycmVudExlcnBUaW1lLCB0aGlzLl9sZXJwRW5kLnksIHRoaXMuX2xlcnBTdGFydC55LCB0aGlzLl9sZXJwRHVyYXRpb24pIC0gdGhpcy5fbGVycEVuZC55KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1kgPSB0aGlzLmVhc2luZ0Zjbih0aGlzLl9jdXJyZW50TGVycFRpbWUsIHRoaXMuX2xlcnBTdGFydC55LCB0aGlzLl9sZXJwRW5kLnksIHRoaXMuX2xlcnBEdXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnBvcy54ID0gbmV3WDtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IucG9zLnkgPSBuZXdZO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudExlcnBUaW1lICs9IGRlbHRhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5wb3MueCA9IHRoaXMuX2xlcnBFbmQueDtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IucG9zLnkgPSB0aGlzLl9sZXJwRW5kLnk7XHJcbiAgICAgICAgICAgICAgICAvL3RoaXMuX2xlcnBTdGFydCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAvL3RoaXMuX2xlcnBFbmQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgLy90aGlzLl9jdXJyZW50TGVycFRpbWUgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBFYXNlVG8ucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoYWN0b3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgKG5ldyBBbGdlYnJhXzI1LlZlY3RvcihhY3Rvci5wb3MueCwgYWN0b3IucG9zLnkpKS5kaXN0YW5jZSh0aGlzLl9sZXJwU3RhcnQpID49IHRoaXMuX2Rpc3RhbmNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRWFzZVRvLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEVhc2VUby5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gRWFzZVRvO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuRWFzZVRvID0gRWFzZVRvO1xyXG4gICAgdmFyIE1vdmVUbyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gTW92ZVRvKGFjdG9yLCBkZXN0eCwgZGVzdHksIHNwZWVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RvciA9IGFjdG9yO1xyXG4gICAgICAgICAgICB0aGlzLl9lbmQgPSBuZXcgQWxnZWJyYV8yNS5WZWN0b3IoZGVzdHgsIGRlc3R5KTtcclxuICAgICAgICAgICAgdGhpcy5fc3BlZWQgPSBzcGVlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgTW92ZVRvLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoX2RlbHRhKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydCA9IG5ldyBBbGdlYnJhXzI1LlZlY3Rvcih0aGlzLl9hY3Rvci5wb3MueCwgdGhpcy5fYWN0b3IucG9zLnkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9zdGFydC5kaXN0YW5jZSh0aGlzLl9lbmQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlyID0gdGhpcy5fZW5kLnN1Yih0aGlzLl9zdGFydCkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG0gPSB0aGlzLl9kaXIuc2NhbGUodGhpcy5fc3BlZWQpO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rvci52ZWwueCA9IG0ueDtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IudmVsLnkgPSBtLnk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ29tcGxldGUodGhpcy5fYWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci5wb3MueCA9IHRoaXMuX2VuZC54O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3IucG9zLnkgPSB0aGlzLl9lbmQueTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnZlbC55ID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnZlbC54ID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgTW92ZVRvLnByb3RvdHlwZS5pc0NvbXBsZXRlID0gZnVuY3Rpb24gKGFjdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8IChuZXcgQWxnZWJyYV8yNS5WZWN0b3IoYWN0b3IucG9zLngsIGFjdG9yLnBvcy55KSkuZGlzdGFuY2UodGhpcy5fc3RhcnQpID49IHRoaXMuX2Rpc3RhbmNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgTW92ZVRvLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rvci52ZWwueSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yLnZlbC54ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBNb3ZlVG8ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gTW92ZVRvO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuTW92ZVRvID0gTW92ZVRvO1xyXG4gICAgdmFyIE1vdmVCeSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gTW92ZUJ5KGFjdG9yLCBkZXN0eCwgZGVzdHksIHRpbWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yID0gYWN0b3I7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZCA9IG5ldyBBbGdlYnJhXzI1LlZlY3RvcihkZXN0eCwgZGVzdHkpO1xyXG4gICAgICAgICAgICBpZiAodGltZSA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBMb2dfMTcuTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoJ0F0dGVtcHRlZCB0byBtb3ZlQnkgdGltZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gemVybyA6ICcgKyB0aW1lKTtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IG1vdmUgaW4gdGltZSA8PSAwJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fdGltZSA9IHRpbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE1vdmVCeS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKF9kZWx0YSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnQgPSBuZXcgQWxnZWJyYV8yNS5WZWN0b3IodGhpcy5fYWN0b3IucG9zLngsIHRoaXMuX2FjdG9yLnBvcy55KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gdGhpcy5fc3RhcnQuZGlzdGFuY2UodGhpcy5fZW5kKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RpciA9IHRoaXMuX2VuZC5zdWIodGhpcy5fc3RhcnQpLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3BlZWQgPSB0aGlzLl9kaXN0YW5jZSAvICh0aGlzLl90aW1lIC8gMTAwMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG0gPSB0aGlzLl9kaXIuc2NhbGUodGhpcy5fc3BlZWQpO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rvci52ZWwueCA9IG0ueDtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IudmVsLnkgPSBtLnk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ29tcGxldGUodGhpcy5fYWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci5wb3MueCA9IHRoaXMuX2VuZC54O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3IucG9zLnkgPSB0aGlzLl9lbmQueTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnZlbC55ID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnZlbC54ID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgTW92ZUJ5LnByb3RvdHlwZS5pc0NvbXBsZXRlID0gZnVuY3Rpb24gKGFjdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8IChuZXcgQWxnZWJyYV8yNS5WZWN0b3IoYWN0b3IucG9zLngsIGFjdG9yLnBvcy55KSkuZGlzdGFuY2UodGhpcy5fc3RhcnQpID49IHRoaXMuX2Rpc3RhbmNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgTW92ZUJ5LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rvci52ZWwueSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yLnZlbC54ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBNb3ZlQnkucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gTW92ZUJ5O1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuTW92ZUJ5ID0gTW92ZUJ5O1xyXG4gICAgdmFyIEZvbGxvdyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gRm9sbG93KGFjdG9yLCBhY3RvclRvRm9sbG93LCBmb2xsb3dEaXN0YW5jZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IgPSBhY3RvcjtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3JUb0ZvbGxvdyA9IGFjdG9yVG9Gb2xsb3c7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSBuZXcgQWxnZWJyYV8yNS5WZWN0b3IodGhpcy5fYWN0b3IucG9zLngsIHRoaXMuX2FjdG9yLnBvcy55KTtcclxuICAgICAgICAgICAgdGhpcy5fZW5kID0gbmV3IEFsZ2VicmFfMjUuVmVjdG9yKGFjdG9yVG9Gb2xsb3cucG9zLngsIGFjdG9yVG9Gb2xsb3cucG9zLnkpO1xyXG4gICAgICAgICAgICB0aGlzLl9tYXhpbXVtRGlzdGFuY2UgPSAoZm9sbG93RGlzdGFuY2UgIT09IHVuZGVmaW5lZCkgPyBmb2xsb3dEaXN0YW5jZSA6IHRoaXMuX2N1cnJlbnQuZGlzdGFuY2UodGhpcy5fZW5kKTtcclxuICAgICAgICAgICAgdGhpcy5fc3BlZWQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBGb2xsb3cucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChfZGVsdGEpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlQmV0d2VlbiA9IHRoaXMuX2N1cnJlbnQuZGlzdGFuY2UodGhpcy5fZW5kKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RpciA9IHRoaXMuX2VuZC5zdWIodGhpcy5fY3VycmVudCkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGFjdG9yVG9Gb2xsb3dTcGVlZCA9IE1hdGguc3FydChNYXRoLnBvdyh0aGlzLl9hY3RvclRvRm9sbG93LnZlbC54LCAyKSArIE1hdGgucG93KHRoaXMuX2FjdG9yVG9Gb2xsb3cudmVsLnksIDIpKTtcclxuICAgICAgICAgICAgaWYgKGFjdG9yVG9Gb2xsb3dTcGVlZCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3BlZWQgPSBhY3RvclRvRm9sbG93U3BlZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudC54ID0gdGhpcy5fYWN0b3IucG9zLng7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQueSA9IHRoaXMuX2FjdG9yLnBvcy55O1xyXG4gICAgICAgICAgICB0aGlzLl9lbmQueCA9IHRoaXMuX2FjdG9yVG9Gb2xsb3cucG9zLng7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZC55ID0gdGhpcy5fYWN0b3JUb0ZvbGxvdy5wb3MueTtcclxuICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2VCZXR3ZWVuID0gdGhpcy5fY3VycmVudC5kaXN0YW5jZSh0aGlzLl9lbmQpO1xyXG4gICAgICAgICAgICB0aGlzLl9kaXIgPSB0aGlzLl9lbmQuc3ViKHRoaXMuX2N1cnJlbnQpLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fZGlzdGFuY2VCZXR3ZWVuID49IHRoaXMuX21heGltdW1EaXN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG0gPSB0aGlzLl9kaXIuc2NhbGUodGhpcy5fc3BlZWQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3IudmVsLnggPSBtLng7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci52ZWwueSA9IG0ueTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnZlbC54ID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnZlbC55ID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0NvbXBsZXRlKCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8gdGhpcyBzaG91bGQgbmV2ZXIgb2NjdXJcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnBvcy54ID0gdGhpcy5fZW5kLng7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci5wb3MueSA9IHRoaXMuX2VuZC55O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3IudmVsLnkgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3IudmVsLnggPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBGb2xsb3cucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yLnZlbC55ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IudmVsLnggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEZvbGxvdy5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gdGhlIGFjdG9yIGZvbGxvd2luZyBzaG91bGQgbmV2ZXIgc3RvcCB1bmxlc3Mgc3BlY2lmaWVkIHRvIGRvIHNvXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRm9sbG93LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEZvbGxvdztcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkZvbGxvdyA9IEZvbGxvdztcclxuICAgIHZhciBNZWV0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBNZWV0KGFjdG9yLCBhY3RvclRvTWVldCwgc3BlZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3NwZWVkV2FzU3BlY2lmaWVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yID0gYWN0b3I7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yVG9NZWV0ID0gYWN0b3JUb01lZXQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSBuZXcgQWxnZWJyYV8yNS5WZWN0b3IodGhpcy5fYWN0b3IucG9zLngsIHRoaXMuX2FjdG9yLnBvcy55KTtcclxuICAgICAgICAgICAgdGhpcy5fZW5kID0gbmV3IEFsZ2VicmFfMjUuVmVjdG9yKGFjdG9yVG9NZWV0LnBvcy54LCBhY3RvclRvTWVldC5wb3MueSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3NwZWVkID0gc3BlZWQgfHwgMDtcclxuICAgICAgICAgICAgaWYgKHNwZWVkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NwZWVkV2FzU3BlY2lmaWVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBNZWV0LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoX2RlbHRhKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXN0YW5jZUJldHdlZW4gPSB0aGlzLl9jdXJyZW50LmRpc3RhbmNlKHRoaXMuX2VuZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXIgPSB0aGlzLl9lbmQuc3ViKHRoaXMuX2N1cnJlbnQpLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBhY3RvclRvTWVldFNwZWVkID0gTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMuX2FjdG9yVG9NZWV0LnZlbC54LCAyKSArIE1hdGgucG93KHRoaXMuX2FjdG9yVG9NZWV0LnZlbC55LCAyKSk7XHJcbiAgICAgICAgICAgIGlmICgoYWN0b3JUb01lZXRTcGVlZCAhPT0gMCkgJiYgKCF0aGlzLl9zcGVlZFdhc1NwZWNpZmllZCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NwZWVkID0gYWN0b3JUb01lZXRTcGVlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50LnggPSB0aGlzLl9hY3Rvci5wb3MueDtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudC55ID0gdGhpcy5fYWN0b3IucG9zLnk7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZC54ID0gdGhpcy5fYWN0b3JUb01lZXQucG9zLng7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZC55ID0gdGhpcy5fYWN0b3JUb01lZXQucG9zLnk7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlQmV0d2VlbiA9IHRoaXMuX2N1cnJlbnQuZGlzdGFuY2UodGhpcy5fZW5kKTtcclxuICAgICAgICAgICAgdGhpcy5fZGlyID0gdGhpcy5fZW5kLnN1Yih0aGlzLl9jdXJyZW50KS5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgdmFyIG0gPSB0aGlzLl9kaXIuc2NhbGUodGhpcy5fc3BlZWQpO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rvci52ZWwueCA9IG0ueDtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IudmVsLnkgPSBtLnk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ29tcGxldGUoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3IucG9zLnggPSB0aGlzLl9lbmQueDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnBvcy55ID0gdGhpcy5fZW5kLnk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci52ZWwueSA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci52ZWwueCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIE1lZXQucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8ICh0aGlzLl9kaXN0YW5jZUJldHdlZW4gPD0gMSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBNZWV0LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rvci52ZWwueSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yLnZlbC54ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBNZWV0LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIE1lZXQ7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5NZWV0ID0gTWVldDtcclxuICAgIHZhciBSb3RhdGVUbyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gUm90YXRlVG8oYWN0b3IsIGFuZ2xlUmFkaWFucywgc3BlZWQsIHJvdGF0aW9uVHlwZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IgPSBhY3RvcjtcclxuICAgICAgICAgICAgdGhpcy5fZW5kID0gYW5nbGVSYWRpYW5zO1xyXG4gICAgICAgICAgICB0aGlzLl9zcGVlZCA9IHNwZWVkO1xyXG4gICAgICAgICAgICB0aGlzLl9yb3RhdGlvblR5cGUgPSByb3RhdGlvblR5cGUgfHwgUm90YXRpb25UeXBlXzIuUm90YXRpb25UeXBlLlNob3J0ZXN0UGF0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgUm90YXRlVG8ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChfZGVsdGEpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ID0gdGhpcy5fYWN0b3Iucm90YXRpb247XHJcbiAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UxID0gTWF0aC5hYnModGhpcy5fZW5kIC0gdGhpcy5fc3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlMiA9IFV0aWwuVHdvUEkgLSBkaXN0YW5jZTE7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UxID4gZGlzdGFuY2UyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2hvcnREaXN0YW5jZSA9IGRpc3RhbmNlMjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb25nRGlzdGFuY2UgPSBkaXN0YW5jZTE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydERpc3RhbmNlID0gZGlzdGFuY2UxO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdEaXN0YW5jZSA9IGRpc3RhbmNlMjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0ZXN0UGF0aElzUG9zaXRpdmUgPSAodGhpcy5fc3RhcnQgLSB0aGlzLl9lbmQgKyBVdGlsLlR3b1BJKSAlIFV0aWwuVHdvUEkgPj0gTWF0aC5QSTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcm90YXRpb25UeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBSb3RhdGlvblR5cGVfMi5Sb3RhdGlvblR5cGUuU2hvcnRlc3RQYXRoOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IHRoaXMuX3Nob3J0RGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zaG9ydGVzdFBhdGhJc1Bvc2l0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBSb3RhdGlvblR5cGVfMi5Sb3RhdGlvblR5cGUuTG9uZ2VzdFBhdGg6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gdGhpcy5fbG9uZ0Rpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fc2hvcnRlc3RQYXRoSXNQb3NpdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUm90YXRpb25UeXBlXzIuUm90YXRpb25UeXBlLkNsb2Nrd2lzZTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Nob3J0ZXN0UGF0aElzUG9zaXRpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gdGhpcy5fc2hvcnREaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gdGhpcy5fbG9uZ0Rpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUm90YXRpb25UeXBlXzIuUm90YXRpb25UeXBlLkNvdW50ZXJDbG9ja3dpc2U6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3Nob3J0ZXN0UGF0aElzUG9zaXRpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gdGhpcy5fc2hvcnREaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gdGhpcy5fbG9uZ0Rpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yLnJ4ID0gdGhpcy5fZGlyZWN0aW9uICogdGhpcy5fc3BlZWQ7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ29tcGxldGUoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3Iucm90YXRpb24gPSB0aGlzLl9lbmQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci5yeCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgUm90YXRlVG8ucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZVRyYXZlbGxlZCA9IE1hdGguYWJzKHRoaXMuX2FjdG9yLnJvdGF0aW9uIC0gdGhpcy5fc3RhcnQpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZCB8fCAoZGlzdGFuY2VUcmF2ZWxsZWQgPj0gTWF0aC5hYnModGhpcy5fZGlzdGFuY2UpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFJvdGF0ZVRvLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rvci5yeCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUm90YXRlVG8ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gUm90YXRlVG87XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5Sb3RhdGVUbyA9IFJvdGF0ZVRvO1xyXG4gICAgdmFyIFJvdGF0ZUJ5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBSb3RhdGVCeShhY3RvciwgYW5nbGVSYWRpYW5zLCB0aW1lLCByb3RhdGlvblR5cGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yID0gYWN0b3I7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZCA9IGFuZ2xlUmFkaWFucztcclxuICAgICAgICAgICAgdGhpcy5fdGltZSA9IHRpbWU7XHJcbiAgICAgICAgICAgIHRoaXMuX3JvdGF0aW9uVHlwZSA9IHJvdGF0aW9uVHlwZSB8fCBSb3RhdGlvblR5cGVfMi5Sb3RhdGlvblR5cGUuU2hvcnRlc3RQYXRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBSb3RhdGVCeS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKF9kZWx0YSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnQgPSB0aGlzLl9hY3Rvci5yb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZTEgPSBNYXRoLmFicyh0aGlzLl9lbmQgLSB0aGlzLl9zdGFydCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UyID0gVXRpbC5Ud29QSSAtIGRpc3RhbmNlMTtcclxuICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZTEgPiBkaXN0YW5jZTIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydERpc3RhbmNlID0gZGlzdGFuY2UyO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdEaXN0YW5jZSA9IGRpc3RhbmNlMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0RGlzdGFuY2UgPSBkaXN0YW5jZTE7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9uZ0Rpc3RhbmNlID0gZGlzdGFuY2UyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRlc3RQYXRoSXNQb3NpdGl2ZSA9ICh0aGlzLl9zdGFydCAtIHRoaXMuX2VuZCArIFV0aWwuVHdvUEkpICUgVXRpbC5Ud29QSSA+PSBNYXRoLlBJO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9yb3RhdGlvblR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFJvdGF0aW9uVHlwZV8yLlJvdGF0aW9uVHlwZS5TaG9ydGVzdFBhdGg6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gdGhpcy5fc2hvcnREaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Nob3J0ZXN0UGF0aElzUG9zaXRpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFJvdGF0aW9uVHlwZV8yLlJvdGF0aW9uVHlwZS5Mb25nZXN0UGF0aDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9sb25nRGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zaG9ydGVzdFBhdGhJc1Bvc2l0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBSb3RhdGlvblR5cGVfMi5Sb3RhdGlvblR5cGUuQ2xvY2t3aXNlOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fc2hvcnREaXN0YW5jZSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IHRoaXMuX3Nob3J0RGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IHRoaXMuX2xvbmdEaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFJvdGF0aW9uVHlwZV8yLlJvdGF0aW9uVHlwZS5Db3VudGVyQ2xvY2t3aXNlOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Nob3J0RGlzdGFuY2UgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9zaG9ydERpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9sb25nRGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGVlZCA9IE1hdGguYWJzKHRoaXMuX2Rpc3RhbmNlIC8gdGhpcy5fdGltZSAqIDEwMDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yLnJ4ID0gdGhpcy5fZGlyZWN0aW9uICogdGhpcy5fc3BlZWQ7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ29tcGxldGUoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3Iucm90YXRpb24gPSB0aGlzLl9lbmQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci5yeCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgUm90YXRlQnkucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZVRyYXZlbGxlZCA9IE1hdGguYWJzKHRoaXMuX2FjdG9yLnJvdGF0aW9uIC0gdGhpcy5fc3RhcnQpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZCB8fCAoZGlzdGFuY2VUcmF2ZWxsZWQgPj0gTWF0aC5hYnModGhpcy5fZGlzdGFuY2UpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFJvdGF0ZUJ5LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rvci5yeCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUm90YXRlQnkucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gUm90YXRlQnk7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5Sb3RhdGVCeSA9IFJvdGF0ZUJ5O1xyXG4gICAgdmFyIFNjYWxlVG8gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIFNjYWxlVG8oYWN0b3IsIHNjYWxlWCwgc2NhbGVZLCBzcGVlZFgsIHNwZWVkWSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IgPSBhY3RvcjtcclxuICAgICAgICAgICAgdGhpcy5fZW5kWCA9IHNjYWxlWDtcclxuICAgICAgICAgICAgdGhpcy5fZW5kWSA9IHNjYWxlWTtcclxuICAgICAgICAgICAgdGhpcy5fc3BlZWRYID0gc3BlZWRYO1xyXG4gICAgICAgICAgICB0aGlzLl9zcGVlZFkgPSBzcGVlZFk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFNjYWxlVG8ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChfZGVsdGEpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0WCA9IHRoaXMuX2FjdG9yLnNjYWxlLng7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydFkgPSB0aGlzLl9hY3Rvci5zY2FsZS55O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2VYID0gTWF0aC5hYnModGhpcy5fZW5kWCAtIHRoaXMuX3N0YXJ0WCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXN0YW5jZVkgPSBNYXRoLmFicyh0aGlzLl9lbmRZIC0gdGhpcy5fc3RhcnRZKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIShNYXRoLmFicyh0aGlzLl9hY3Rvci5zY2FsZS54IC0gdGhpcy5fc3RhcnRYKSA+PSB0aGlzLl9kaXN0YW5jZVgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9uWCA9IHRoaXMuX2VuZFkgPCB0aGlzLl9zdGFydFkgPyAtMSA6IDE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci5zeCA9IHRoaXMuX3NwZWVkWCAqIGRpcmVjdGlvblg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci5zeCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCEoTWF0aC5hYnModGhpcy5fYWN0b3Iuc2NhbGUueSAtIHRoaXMuX3N0YXJ0WSkgPj0gdGhpcy5fZGlzdGFuY2VZKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRpcmVjdGlvblkgPSB0aGlzLl9lbmRZIDwgdGhpcy5fc3RhcnRZID8gLTEgOiAxO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3Iuc3kgPSB0aGlzLl9zcGVlZFkgKiBkaXJlY3Rpb25ZO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3Iuc3kgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ29tcGxldGUoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3Iuc2NhbGUueCA9IHRoaXMuX2VuZFg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci5zY2FsZS55ID0gdGhpcy5fZW5kWTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnN4ID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnN5ID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgU2NhbGVUby5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgKChNYXRoLmFicyh0aGlzLl9hY3Rvci5zY2FsZS55IC0gdGhpcy5fc3RhcnRYKSA+PSB0aGlzLl9kaXN0YW5jZVgpICYmXHJcbiAgICAgICAgICAgICAgICAoTWF0aC5hYnModGhpcy5fYWN0b3Iuc2NhbGUueSAtIHRoaXMuX3N0YXJ0WSkgPj0gdGhpcy5fZGlzdGFuY2VZKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTY2FsZVRvLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rvci5zeCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yLnN5ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTY2FsZVRvLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFNjYWxlVG87XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5TY2FsZVRvID0gU2NhbGVUbztcclxuICAgIHZhciBTY2FsZUJ5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBTY2FsZUJ5KGFjdG9yLCBzY2FsZVgsIHNjYWxlWSwgdGltZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IgPSBhY3RvcjtcclxuICAgICAgICAgICAgdGhpcy5fZW5kWCA9IHNjYWxlWDtcclxuICAgICAgICAgICAgdGhpcy5fZW5kWSA9IHNjYWxlWTtcclxuICAgICAgICAgICAgdGhpcy5fc3BlZWRYID0gKHRoaXMuX2VuZFggLSB0aGlzLl9hY3Rvci5zY2FsZS54KSAvIHRpbWUgKiAxMDAwO1xyXG4gICAgICAgICAgICB0aGlzLl9zcGVlZFkgPSAodGhpcy5fZW5kWSAtIHRoaXMuX2FjdG9yLnNjYWxlLnkpIC8gdGltZSAqIDEwMDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFNjYWxlQnkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChfZGVsdGEpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0WCA9IHRoaXMuX2FjdG9yLnNjYWxlLng7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydFkgPSB0aGlzLl9hY3Rvci5zY2FsZS55O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2VYID0gTWF0aC5hYnModGhpcy5fZW5kWCAtIHRoaXMuX3N0YXJ0WCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXN0YW5jZVkgPSBNYXRoLmFicyh0aGlzLl9lbmRZIC0gdGhpcy5fc3RhcnRZKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZGlyZWN0aW9uWCA9IHRoaXMuX2VuZFggPCB0aGlzLl9zdGFydFggPyAtMSA6IDE7XHJcbiAgICAgICAgICAgIHZhciBkaXJlY3Rpb25ZID0gdGhpcy5fZW5kWSA8IHRoaXMuX3N0YXJ0WSA/IC0xIDogMTtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3Iuc3ggPSB0aGlzLl9zcGVlZFggKiBkaXJlY3Rpb25YO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rvci5zeSA9IHRoaXMuX3NwZWVkWSAqIGRpcmVjdGlvblk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ29tcGxldGUoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3Iuc2NhbGUueCA9IHRoaXMuX2VuZFg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci5zY2FsZS55ID0gdGhpcy5fZW5kWTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnN4ID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnN5ID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgU2NhbGVCeS5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgKChNYXRoLmFicyh0aGlzLl9hY3Rvci5zY2FsZS54IC0gdGhpcy5fc3RhcnRYKSA+PSB0aGlzLl9kaXN0YW5jZVgpICYmXHJcbiAgICAgICAgICAgICAgICAoTWF0aC5hYnModGhpcy5fYWN0b3Iuc2NhbGUueSAtIHRoaXMuX3N0YXJ0WSkgPj0gdGhpcy5fZGlzdGFuY2VZKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTY2FsZUJ5LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rvci5zeCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yLnN5ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTY2FsZUJ5LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFNjYWxlQnk7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5TY2FsZUJ5ID0gU2NhbGVCeTtcclxuICAgIHZhciBEZWxheSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gRGVsYXkoYWN0b3IsIGRlbGF5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VsYXBzZWRUaW1lID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yID0gYWN0b3I7XHJcbiAgICAgICAgICAgIHRoaXMuX2RlbGF5ID0gZGVsYXk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIERlbGF5LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnggPSB0aGlzLl9hY3Rvci5wb3MueDtcclxuICAgICAgICAgICAgdGhpcy55ID0gdGhpcy5fYWN0b3IucG9zLnk7XHJcbiAgICAgICAgICAgIHRoaXMuX2VsYXBzZWRUaW1lICs9IGRlbHRhO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRGVsYXkucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8ICh0aGlzLl9lbGFwc2VkVGltZSA+PSB0aGlzLl9kZWxheSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBEZWxheS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBEZWxheS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VsYXBzZWRUaW1lID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIERlbGF5O1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuRGVsYXkgPSBEZWxheTtcclxuICAgIHZhciBCbGluayA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gQmxpbmsoYWN0b3IsIHRpbWVWaXNpYmxlLCB0aW1lTm90VmlzaWJsZSwgbnVtQmxpbmtzKSB7XHJcbiAgICAgICAgICAgIGlmIChudW1CbGlua3MgPT09IHZvaWQgMCkgeyBudW1CbGlua3MgPSAxOyB9XHJcbiAgICAgICAgICAgIHRoaXMuX3RpbWVWaXNpYmxlID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fdGltZU5vdFZpc2libGUgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9lbGFwc2VkVGltZSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3RvdGFsVGltZSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RvciA9IGFjdG9yO1xyXG4gICAgICAgICAgICB0aGlzLl90aW1lVmlzaWJsZSA9IHRpbWVWaXNpYmxlO1xyXG4gICAgICAgICAgICB0aGlzLl90aW1lTm90VmlzaWJsZSA9IHRpbWVOb3RWaXNpYmxlO1xyXG4gICAgICAgICAgICB0aGlzLl9kdXJhdGlvbiA9ICh0aW1lVmlzaWJsZSArIHRpbWVOb3RWaXNpYmxlKSAqIG51bUJsaW5rcztcclxuICAgICAgICB9XHJcbiAgICAgICAgQmxpbmsucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2VsYXBzZWRUaW1lICs9IGRlbHRhO1xyXG4gICAgICAgICAgICB0aGlzLl90b3RhbFRpbWUgKz0gZGVsdGE7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9hY3Rvci52aXNpYmxlICYmIHRoaXMuX2VsYXBzZWRUaW1lID49IHRoaXMuX3RpbWVWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lbGFwc2VkVGltZSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9hY3Rvci52aXNpYmxlICYmIHRoaXMuX2VsYXBzZWRUaW1lID49IHRoaXMuX3RpbWVOb3RWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VsYXBzZWRUaW1lID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0NvbXBsZXRlKCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBCbGluay5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgKHRoaXMuX3RvdGFsVGltZSA+PSB0aGlzLl9kdXJhdGlvbik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBCbGluay5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQmxpbmsucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2VsYXBzZWRUaW1lID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fdG90YWxUaW1lID0gMDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBCbGluaztcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkJsaW5rID0gQmxpbms7XHJcbiAgICB2YXIgRmFkZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gRmFkZShhY3RvciwgZW5kT3BhY2l0eSwgc3BlZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fbXVsdGlwbGllciA9IDE7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RvciA9IGFjdG9yO1xyXG4gICAgICAgICAgICB0aGlzLl9lbmRPcGFjaXR5ID0gZW5kT3BhY2l0eTtcclxuICAgICAgICAgICAgdGhpcy5fc3BlZWQgPSBzcGVlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgRmFkZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAvLyBkZXRlcm1pbmUgZGlyZWN0aW9uIHdoZW4gd2Ugc3RhcnRcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbmRPcGFjaXR5IDwgdGhpcy5fYWN0b3Iub3BhY2l0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX211bHRpcGxpZXIgPSAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX211bHRpcGxpZXIgPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9zcGVlZCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLm9wYWNpdHkgKz0gdGhpcy5fbXVsdGlwbGllciAqIChNYXRoLmFicyh0aGlzLl9hY3Rvci5vcGFjaXR5IC0gdGhpcy5fZW5kT3BhY2l0eSkgKiBkZWx0YSkgLyB0aGlzLl9zcGVlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9zcGVlZCAtPSBkZWx0YTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci5vcGFjaXR5ID0gdGhpcy5fZW5kT3BhY2l0eTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBMb2dfMTcuTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ1tBY3Rpb24gZmFkZV0gQWN0b3Igb3BhY2l0eTonLCB0aGlzLl9hY3Rvci5vcGFjaXR5KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEZhZGUucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8IChNYXRoLmFicyh0aGlzLl9hY3Rvci5vcGFjaXR5IC0gdGhpcy5fZW5kT3BhY2l0eSkgPCAwLjA1KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEZhZGUucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRmFkZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBGYWRlO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuRmFkZSA9IEZhZGU7XHJcbiAgICB2YXIgRGllID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBEaWUoYWN0b3IpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RvciA9IGFjdG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBEaWUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChfZGVsdGEpIHtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IuYWN0aW9uUXVldWUuY2xlYXJBY3Rpb25zKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yLmtpbGwoKTtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBEaWUucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRGllLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XHJcbiAgICAgICAgRGllLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuOyB9O1xyXG4gICAgICAgIHJldHVybiBEaWU7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5EaWUgPSBEaWU7XHJcbiAgICB2YXIgQ2FsbE1ldGhvZCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gQ2FsbE1ldGhvZChhY3RvciwgbWV0aG9kKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21ldGhvZCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5faGFzQmVlbkNhbGxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RvciA9IGFjdG9yO1xyXG4gICAgICAgICAgICB0aGlzLl9tZXRob2QgPSBtZXRob2Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIENhbGxNZXRob2QucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChfZGVsdGEpIHtcclxuICAgICAgICAgICAgdGhpcy5fbWV0aG9kLmNhbGwodGhpcy5fYWN0b3IpO1xyXG4gICAgICAgICAgICB0aGlzLl9oYXNCZWVuQ2FsbGVkID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIENhbGxNZXRob2QucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYXNCZWVuQ2FsbGVkO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQ2FsbE1ldGhvZC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhc0JlZW5DYWxsZWQgPSBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIENhbGxNZXRob2QucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhc0JlZW5DYWxsZWQgPSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIENhbGxNZXRob2Q7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5DYWxsTWV0aG9kID0gQ2FsbE1ldGhvZDtcclxuICAgIHZhciBSZXBlYXQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIFJlcGVhdChhY3RvciwgcmVwZWF0LCBhY3Rpb25zKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IgPSBhY3RvcjtcclxuICAgICAgICAgICAgdGhpcy5fYWN0aW9uUXVldWUgPSBuZXcgQWN0aW9uUXVldWUoYWN0b3IpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZXBlYXQgPSByZXBlYXQ7XHJcbiAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsUmVwZWF0ID0gcmVwZWF0O1xyXG4gICAgICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IGFjdGlvbnMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgYWN0aW9uc1tpXS5yZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aW9uUXVldWUuYWRkKGFjdGlvbnNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDtcclxuICAgICAgICB9XHJcbiAgICAgICAgUmVwZWF0LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcclxuICAgICAgICAgICAgdGhpcy54ID0gdGhpcy5fYWN0b3IucG9zLng7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHRoaXMuX2FjdG9yLnBvcy55O1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2FjdGlvblF1ZXVlLmhhc05leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aW9uUXVldWUucmVzZXQoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlcGVhdC0tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvblF1ZXVlLnVwZGF0ZShkZWx0YSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBSZXBlYXQucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8ICh0aGlzLl9yZXBlYXQgPD0gMCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBSZXBlYXQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUmVwZWF0LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVwZWF0ID0gdGhpcy5fb3JpZ2luYWxSZXBlYXQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gUmVwZWF0O1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuUmVwZWF0ID0gUmVwZWF0O1xyXG4gICAgdmFyIFJlcGVhdEZvcmV2ZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIFJlcGVhdEZvcmV2ZXIoYWN0b3IsIGFjdGlvbnMpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RvciA9IGFjdG9yO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25RdWV1ZSA9IG5ldyBBY3Rpb25RdWV1ZShhY3Rvcik7XHJcbiAgICAgICAgICAgIHZhciBpID0gMCwgbGVuID0gYWN0aW9ucy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhY3Rpb25zW2ldLnJlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rpb25RdWV1ZS5hZGQoYWN0aW9uc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgO1xyXG4gICAgICAgIH1cclxuICAgICAgICBSZXBlYXRGb3JldmVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcclxuICAgICAgICAgICAgdGhpcy54ID0gdGhpcy5fYWN0b3IucG9zLng7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHRoaXMuX2FjdG9yLnBvcy55O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fc3RvcHBlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fYWN0aW9uUXVldWUuaGFzTmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rpb25RdWV1ZS5yZXNldCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvblF1ZXVlLnVwZGF0ZShkZWx0YSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBSZXBlYXRGb3JldmVyLnByb3RvdHlwZS5pc0NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFJlcGVhdEZvcmV2ZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25RdWV1ZS5jbGVhckFjdGlvbnMoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFJlcGVhdEZvcmV2ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XHJcbiAgICAgICAgcmV0dXJuIFJlcGVhdEZvcmV2ZXI7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5SZXBlYXRGb3JldmVyID0gUmVwZWF0Rm9yZXZlcjtcclxuICAgIC8qKlxyXG4gICAgICogQWN0aW9uIFF1ZXVlc1xyXG4gICAgICpcclxuICAgICAqIEFjdGlvbiBxdWV1ZXMgYXJlIHBhcnQgb2YgdGhlIFtbQWN0aW9uQ29udGV4dHxBY3Rpb24gQVBJXV0gYW5kXHJcbiAgICAgKiBzdG9yZSB0aGUgbGlzdCBvZiBhY3Rpb25zIHRvIGJlIGV4ZWN1dGVkIGZvciBhbiBbW0FjdG9yXV0uXHJcbiAgICAgKlxyXG4gICAgICogQWN0b3JzIGltcGxlbWVudCBbW0FjdG9yLmFjdGlvbnNdXSB3aGljaCBjYW4gYmUgbWFuaXB1bGF0ZWQgYnlcclxuICAgICAqIGFkdmFuY2VkIHVzZXJzIHRvIGFkanVzdCB0aGUgYWN0aW9ucyBjdXJyZW50bHkgYmVpbmcgZXhlY3V0ZWQgaW4gdGhlXHJcbiAgICAgKiBxdWV1ZS5cclxuICAgICAqL1xyXG4gICAgdmFyIEFjdGlvblF1ZXVlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBBY3Rpb25RdWV1ZShhY3Rvcikge1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25zID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbXBsZXRlZEFjdGlvbnMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IgPSBhY3RvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgQWN0aW9uUXVldWUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5fYWN0aW9ucy5wdXNoKGFjdGlvbik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBY3Rpb25RdWV1ZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGFjdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9hY3Rpb25zLmluZGV4T2YoYWN0aW9uKTtcclxuICAgICAgICAgICAgdGhpcy5fYWN0aW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQWN0aW9uUXVldWUucHJvdG90eXBlLmNsZWFyQWN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fYWN0aW9ucy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9jb21wbGV0ZWRBY3Rpb25zLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50QWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50QWN0aW9uLnN0b3AoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgQWN0aW9uUXVldWUucHJvdG90eXBlLmdldEFjdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hY3Rpb25zLmNvbmNhdCh0aGlzLl9jb21wbGV0ZWRBY3Rpb25zKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEFjdGlvblF1ZXVlLnByb3RvdHlwZS5oYXNOZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWN0aW9ucy5sZW5ndGggPiAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQWN0aW9uUXVldWUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25zID0gdGhpcy5nZXRBY3Rpb25zKCk7XHJcbiAgICAgICAgICAgIHZhciBpID0gMCwgbGVuID0gdGhpcy5fYWN0aW9ucy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rpb25zW2ldLnJlc2V0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fY29tcGxldGVkQWN0aW9ucyA9IFtdO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQWN0aW9uUXVldWUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fYWN0aW9ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50QWN0aW9uID0gdGhpcy5fYWN0aW9uc1swXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRBY3Rpb24udXBkYXRlKGRlbHRhKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50QWN0aW9uLmlzQ29tcGxldGUodGhpcy5fYWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29tcGxldGVkQWN0aW9ucy5wdXNoKHRoaXMuX2FjdGlvbnMuc2hpZnQoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBBY3Rpb25RdWV1ZTtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkFjdGlvblF1ZXVlID0gQWN0aW9uUXVldWU7XHJcbn0pO1xyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIHdpbmRvdyA9IHsgYXVkaW9Db250ZXh0OiBmdW5jdGlvbiAoKSB7IHJldHVybjsgfSB9O1xyXG59XHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xyXG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9XHJcbiAgICAgICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxyXG4gICAgICAgICAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChjYWxsYmFjaykgeyB3aW5kb3cuc2V0SW50ZXJ2YWwoY2FsbGJhY2ssIDEwMDAgLyA2MCk7IH07XHJcbn1cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICF3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUpIHtcclxuICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9XHJcbiAgICAgICAgd2luZG93LndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XHJcbiAgICAgICAgICAgIHdpbmRvdy5tb3pDYW5jZWxBbmltYXRpb25GcmFtZSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybjsgfTtcclxufVxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgIXdpbmRvdy5BdWRpb0NvbnRleHQpIHtcclxuICAgIHdpbmRvdy5BdWRpb0NvbnRleHQgPSB3aW5kb3cuQXVkaW9Db250ZXh0IHx8XHJcbiAgICAgICAgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCB8fFxyXG4gICAgICAgIHdpbmRvdy5tb3pBdWRpb0NvbnRleHQgfHxcclxuICAgICAgICB3aW5kb3cubXNBdWRpb0NvbnRleHQgfHxcclxuICAgICAgICB3aW5kb3cub0F1ZGlvQ29udGV4dDtcclxufVxyXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgIXdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKSB7XHJcbiAgICB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XHJcbn1cclxuLy8gUG9seWZpbGwgZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9mb3JFYWNoXHJcbi8vIFByb2R1Y3Rpb24gc3RlcHMgb2YgRUNNQS0yNjIsIEVkaXRpb24gNSwgMTUuNC40LjE4XHJcbi8vIFJlZmVyZW5jZTogaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS40LjQuMThcclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuaWYgKCFBcnJheS5wcm90b3R5cGUuZm9yRWFjaCkge1xyXG4gICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHRoaXNBcmcpIHtcclxuICAgICAgICB2YXIgVCwgaztcclxuICAgICAgICBpZiAodGhpcyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RoaXMgaXMgbnVsbCBvciBub3QgZGVmaW5lZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyAxLiBMZXQgTyBiZSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgVG9PYmplY3QgcGFzc2luZyB0aGUgfHRoaXN8IHZhbHVlIGFzIHRoZSBhcmd1bWVudC4gXHJcbiAgICAgICAgdmFyIE8gPSBPYmplY3QodGhpcyk7XHJcbiAgICAgICAgLy8gMi4gTGV0IGxlblZhbHVlIGJlIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgR2V0IGludGVybmFsIG1ldGhvZCBvZiBPIHdpdGggdGhlIGFyZ3VtZW50IFwibGVuZ3RoXCIuXHJcbiAgICAgICAgLy8gMy4gTGV0IGxlbiBiZSBUb1VpbnQzMihsZW5WYWx1ZSkuXHJcbiAgICAgICAgdmFyIGxlbiA9IE8ubGVuZ3RoID4+PiAwO1xyXG4gICAgICAgIC8vIDQuIElmIElzQ2FsbGFibGUoY2FsbGJhY2spIGlzIGZhbHNlLCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXHJcbiAgICAgICAgLy8gU2VlOiBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3g5LjExXHJcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNhbGxiYWNrICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA1LiBJZiB0aGlzQXJnIHdhcyBzdXBwbGllZCwgbGV0IFQgYmUgdGhpc0FyZzsgZWxzZSBsZXQgVCBiZSB1bmRlZmluZWQuXHJcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIFQgPSB0aGlzQXJnO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA2LiBMZXQgayBiZSAwXHJcbiAgICAgICAgayA9IDA7XHJcbiAgICAgICAgLy8gNy4gUmVwZWF0LCB3aGlsZSBrIDwgbGVuXHJcbiAgICAgICAgd2hpbGUgKGsgPCBsZW4pIHtcclxuICAgICAgICAgICAgdmFyIGtWYWx1ZTtcclxuICAgICAgICAgICAgLy8gYS4gTGV0IFBrIGJlIFRvU3RyaW5nKGspLlxyXG4gICAgICAgICAgICAvLyAgIFRoaXMgaXMgaW1wbGljaXQgZm9yIExIUyBvcGVyYW5kcyBvZiB0aGUgaW4gb3BlcmF0b3JcclxuICAgICAgICAgICAgLy8gYi4gTGV0IGtQcmVzZW50IGJlIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgSGFzUHJvcGVydHkgaW50ZXJuYWwgbWV0aG9kIG9mIE8gd2l0aCBhcmd1bWVudCBQay5cclxuICAgICAgICAgICAgLy8gICBUaGlzIHN0ZXAgY2FuIGJlIGNvbWJpbmVkIHdpdGggY1xyXG4gICAgICAgICAgICAvLyBjLiBJZiBrUHJlc2VudCBpcyB0cnVlLCB0aGVuXHJcbiAgICAgICAgICAgIGlmIChrIGluIE8pIHtcclxuICAgICAgICAgICAgICAgIC8vIGkuIExldCBrVmFsdWUgYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBHZXQgaW50ZXJuYWwgbWV0aG9kIG9mIE8gd2l0aCBhcmd1bWVudCBQay5cclxuICAgICAgICAgICAgICAgIGtWYWx1ZSA9IE9ba107XHJcbiAgICAgICAgICAgICAgICAvLyBpaS4gQ2FsbCB0aGUgQ2FsbCBpbnRlcm5hbCBtZXRob2Qgb2YgY2FsbGJhY2sgd2l0aCBUIGFzIHRoZSB0aGlzIHZhbHVlIGFuZFxyXG4gICAgICAgICAgICAgICAgLy8gYXJndW1lbnQgbGlzdCBjb250YWluaW5nIGtWYWx1ZSwgaywgYW5kIE8uXHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKFQsIGtWYWx1ZSwgaywgTyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZC4gSW5jcmVhc2UgayBieSAxLlxyXG4gICAgICAgICAgICBrKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDguIHJldHVybiB1bmRlZmluZWRcclxuICAgIH07XHJcbn1cclxuLy8gUG9seWZpbGwgZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zb21lXHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbmlmICghQXJyYXkucHJvdG90eXBlLnNvbWUpIHtcclxuICAgIEFycmF5LnByb3RvdHlwZS5zb21lID0gZnVuY3Rpb24gKGZ1biAvKiwgdGhpc0FyZyAqLykge1xyXG4gICAgICAgICd1c2Ugc3RyaWN0JztcclxuICAgICAgICBpZiAodGhpcyA9PT0gdm9pZCAwIHx8IHRoaXMgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdCA9IE9iamVjdCh0aGlzKTtcclxuICAgICAgICB2YXIgbGVuID0gdC5sZW5ndGggPj4+IDA7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBmdW4gIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdGhpc0FyZyA9IGFyZ3VtZW50cy5sZW5ndGggPj0gMiA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChpIGluIHQgJiYgZnVuLmNhbGwodGhpc0FyZywgdFtpXSwgaSwgdCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbn1cclxuLy8gUG9seWZpbGwgZnJvbSAgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vYmluZCNQb2x5ZmlsbFxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5pZiAoIUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kKSB7XHJcbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChvVGhpcykge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcyAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAvLyBjbG9zZXN0IHRoaW5nIHBvc3NpYmxlIHRvIHRoZSBFQ01BU2NyaXB0IDVcclxuICAgICAgICAgICAgLy8gaW50ZXJuYWwgSXNDYWxsYWJsZSBmdW5jdGlvblxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCAtIHdoYXQgaXMgdHJ5aW5nIHRvIGJlIGJvdW5kIGlzIG5vdCBjYWxsYWJsZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYUFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLCBmVG9CaW5kID0gdGhpcywgZk5PUCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuOyB9LCBmQm91bmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmVG9CaW5kLmFwcGx5KHRoaXMgaW5zdGFuY2VvZiBmTk9QICYmIG9UaGlzXHJcbiAgICAgICAgICAgICAgICA/IHRoaXNcclxuICAgICAgICAgICAgICAgIDogb1RoaXMsIGFBcmdzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBmTk9QLnByb3RvdHlwZSA9IHRoaXMucHJvdG90eXBlO1xyXG4gICAgICAgIGZCb3VuZC5wcm90b3R5cGUgPSBuZXcgZk5PUCgpO1xyXG4gICAgICAgIHJldHVybiBmQm91bmQ7XHJcbiAgICB9O1xyXG59XHJcbiAgICAvL1RoZSBtb2R1bGVzIGZvciB5b3VyIHByb2plY3Qgd2lsbCBiZSBpbmxpbmVkIGFib3ZlXHJcbiAgICAvL3RoaXMgc25pcHBldC4gQXNrIGFsbW9uZCB0byBzeW5jaHJvbm91c2x5IHJlcXVpcmUgdGhlXHJcbiAgICAvL21vZHVsZSB2YWx1ZSBmb3IgJ21haW4nIGhlcmUgYW5kIHJldHVybiBpdCBhcyB0aGVcclxuICAgIC8vdmFsdWUgdG8gdXNlIGZvciB0aGUgcHVibGljIEFQSSBmb3IgdGhlIGJ1aWx0IGZpbGUuXHJcbiAgICByZXR1cm4gcmVxdWlyZSgnSW5kZXgnKTtcclxufSkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1leGNhbGlidXIuanMubWFwIiwiaW1wb3J0ICogYXMgZXggZnJvbSAnZXhjYWxpYnVyJztcclxuaW1wb3J0IHsgUmVzb3VyY2UgfSBmcm9tICcuLi8uLi9yZXNvdXJjZSc7XHJcbmltcG9ydCB7IEdhbWVTZXR0aW5ncyB9IGZyb20gJy4uLy4uL2dhbWVzZXR0aW5ncyc7XHJcbmltcG9ydCB7IEdhbWVTY2VuZSB9IGZyb20gJy4uLy4uL3NjZW5lcy9nYW1lU2NlbmUvZ2FtZXNjZW5lJztcclxuXHJcbmNvbnN0IG9ialNwcml0ZXMgPSBbUmVzb3VyY2UuQ2hlbWljYWxQbGFudCwgUmVzb3VyY2UuUmFkaW9Ub3dlcl07XHJcblxyXG5jbGFzcyBCYWNrZ3JvdW5kT2JqZWN0IGV4dGVuZHMgZXguQWN0b3Ige1xyXG4gICAgcHJvdGVjdGVkIGdhbWVTY2VuZTogR2FtZVNjZW5lO1xyXG5cclxuXHJcbiAgICBjb25zdHJ1Y3RvcihzY2VuZTogR2FtZVNjZW5lKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy54ID0gMS4xKkdhbWVTZXR0aW5ncy5XSURUSCArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIEdhbWVTZXR0aW5ncy5CR19WQVJJQUJJTElUWSk7XHJcbiAgICAgICAgdGhpcy55ID0gR2FtZVNldHRpbmdzLkhFSUdIVCAtIEdhbWVTZXR0aW5ncy5HUk9VTkRfSEVJR0hUO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciByYW5kaSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG9ialNwcml0ZXMubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgdGhpcy5hbmNob3Iuc2V0VG8oMCwgMCk7XHJcblxyXG4gICAgICAgIHZhciBzcHJpdGUgPSBvYmpTcHJpdGVzW3JhbmRpXS5hc1Nwcml0ZSgpO1xyXG4gICAgICAgIHNwcml0ZS5hbmNob3Iuc2V0VG8oMCwgMSk7XHJcbiAgICAgICAgdGhpcy5hZGREcmF3aW5nKHNwcml0ZSk7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0SGVpZ2h0KHNwcml0ZS5oZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuc2V0V2lkdGgoc3ByaXRlLndpZHRoKTtcclxuXHJcbiAgICAgICAgdGhpcy5nYW1lU2NlbmUgPSBzY2VuZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25Jbml0aWFsaXplKGVuZ2luZTogZXguRW5naW5lKSB7XHJcbiAgICAgICAgLy8gZG8gc3R1ZmZcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdXBkYXRlKGVuZ2luZTogZXguRW5naW5lLCBkZWx0YTogbnVtYmVyKSB7XHJcbiAgICAgIHN1cGVyLnVwZGF0ZShlbmdpbmUsIGRlbHRhKTsgLy8gY2FsbCBiYXNlIHVwZGF0ZSBsb2dpY1xyXG5cclxuICAgICAgaWYodGhpcy5nYW1lU2NlbmUuZ2FtZU92ZXIgfHwgIXRoaXMuZ2FtZVNjZW5lLmdhbWVTdGFydGVkKVxyXG4gICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgdGhpcy54IC09IEdhbWVTZXR0aW5ncy5CR19IU1BFRUQgKiBkZWx0YS8xMDAwO1xyXG5cclxuICAgICAgICBpZih0aGlzLnggPCAtR2FtZVNldHRpbmdzLldJRFRILzIpIHtcclxuICAgICAgICAgICAgdGhpcy5raWxsKCk7XHJcbiAgICAgICAgfVxyXG4gICB9XHJcbn1cclxuXHJcbmV4cG9ydCB7IEJhY2tncm91bmRPYmplY3QgfTsiLCJpbXBvcnQgKiBhcyBleCBmcm9tICdleGNhbGlidXInO1xyXG5pbXBvcnQgeyBSZXNvdXJjZSB9IGZyb20gJy4uLy4uL3Jlc291cmNlJztcclxuaW1wb3J0IHsgR2FtZVNldHRpbmdzIH0gZnJvbSAnLi4vLi4vZ2FtZXNldHRpbmdzJztcclxuaW1wb3J0IHsgR2FtZVNjZW5lIH0gZnJvbSAnLi4vLi4vc2NlbmVzL2dhbWVTY2VuZS9nYW1lc2NlbmUnO1xyXG5cclxuY29uc3QgcGVzdFNwcml0ZXMgPSBbUmVzb3VyY2UuUm5kcCwgUmVzb3VyY2UuU21ydHgsIFJlc291cmNlLkluc2N0V2FzcCwgUmVzb3VyY2UuQ2hvZ29dO1xyXG5cclxuY2xhc3MgUGVzdGljaWRlIGV4dGVuZHMgZXguQWN0b3Ige1xyXG4gICAgcHJvdGVjdGVkIHRvcFBhcnQ6IGV4LkFjdG9yO1xyXG4gICAgcHJvdGVjdGVkIGJvdHRvbVBhcnQ6IGV4LkFjdG9yO1xyXG4gICAgcHJvdGVjdGVkIGdhbWVTY2VuZTogR2FtZVNjZW5lO1xyXG4gICAgcHJvdGVjdGVkIHBhc3NlZDogYm9vbGVhbjtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcih4aTogbnVtYmVyLCB5aTogbnVtYmVyLCB5U3BhY2U6IG51bWJlciwgc2NlbmU6IEdhbWVTY2VuZSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IHhpO1xyXG4gICAgICAgIHRoaXMuc2V0V2lkdGgoMC44KkdhbWVTZXR0aW5ncy5QRVNUX1dJRFRIKTtcclxuICAgICAgICB0aGlzLnNldEhlaWdodCh5U3BhY2UgKyAyICogR2FtZVNldHRpbmdzLlBFU1RfSEVJR0hUKTtcclxuXHJcbiAgICAgICAgdmFyIHJhbmRpO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgcmFuZGkgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBwZXN0U3ByaXRlcy5sZW5ndGgpO1xyXG4gICAgICAgIH0gd2hpbGUocmFuZGkgPT0gc2NlbmUubGFzdFBlc3QpO1xyXG4gICAgICAgIHNjZW5lLmxhc3RQZXN0ID0gcmFuZGk7XHJcblxyXG4gICAgICAgIHRoaXMudG9wUGFydCA9IG5ldyBleC5BY3RvcigpO1xyXG4gICAgICAgIHZhciB0b3BTcHJpdGUgPSBuZXcgZXguU3ByaXRlKHBlc3RTcHJpdGVzW3JhbmRpXSwgMCwgMCwgR2FtZVNldHRpbmdzLlBFU1RfV0lEVEgsIEdhbWVTZXR0aW5ncy5QRVNUX0hFSUdIVCk7XHJcbiAgICAgICAgdG9wU3ByaXRlLmZsaXBWZXJ0aWNhbCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy50b3BQYXJ0LmFkZERyYXdpbmcodG9wU3ByaXRlKTtcclxuICAgICAgICB0aGlzLnRvcFBhcnQueCA9IDA7XHJcbiAgICAgICAgdGhpcy50b3BQYXJ0LnkgPSB5aSAtIChHYW1lU2V0dGluZ3MuUEVTVF9IRUlHSFQgKyB5U3BhY2UpIC8gMjtcclxuICAgICAgICB0aGlzLnRvcFBhcnQuc2V0V2lkdGgoR2FtZVNldHRpbmdzLlBFU1RfV0lEVEgpO1xyXG4gICAgICAgIHRoaXMudG9wUGFydC5zZXRIZWlnaHQoR2FtZVNldHRpbmdzLlBFU1RfSEVJR0hUKTtcclxuICAgICAgICB0aGlzLmFkZCh0aGlzLnRvcFBhcnQpO1xyXG5cclxuICAgICAgICB0aGlzLmJvdHRvbVBhcnQgPSBuZXcgZXguQWN0b3IoKTtcclxuICAgICAgICB2YXIgYm90dG9tU3ByaXRlID0gbmV3IGV4LlNwcml0ZShwZXN0U3ByaXRlc1tyYW5kaV0sIDAsIDAsIEdhbWVTZXR0aW5ncy5QRVNUX1dJRFRILCBHYW1lU2V0dGluZ3MuUEVTVF9IRUlHSFQpO1xyXG4gICAgICAgIC8vYm90dG9tU3ByaXRlLmZsaXBWZXJ0aWNhbCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYm90dG9tUGFydC5hZGREcmF3aW5nKGJvdHRvbVNwcml0ZSk7XHJcbiAgICAgICAgdGhpcy5ib3R0b21QYXJ0LnggPSAwO1xyXG4gICAgICAgIHRoaXMuYm90dG9tUGFydC55ID0geWkgKyAoR2FtZVNldHRpbmdzLlBFU1RfSEVJR0hUICsgeVNwYWNlKSAvIDI7XHJcbiAgICAgICAgdGhpcy5ib3R0b21QYXJ0LnNldFdpZHRoKEdhbWVTZXR0aW5ncy5QRVNUX1dJRFRIKTtcclxuICAgICAgICB0aGlzLmJvdHRvbVBhcnQuc2V0SGVpZ2h0KEdhbWVTZXR0aW5ncy5QRVNUX0hFSUdIVCk7XHJcbiAgICAgICAgdGhpcy5hZGQodGhpcy5ib3R0b21QYXJ0KTtcclxuXHJcbiAgICAgICAgdGhpcy5nYW1lU2NlbmUgPSBzY2VuZTtcclxuICAgICAgICB0aGlzLnBhc3NlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvbkluaXRpYWxpemUoZW5naW5lOiBleC5FbmdpbmUpIHtcclxuICAgICAgICAvLyBkbyBzdHVmZlxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB1cGRhdGUoZW5naW5lOiBleC5FbmdpbmUsIGRlbHRhOiBudW1iZXIpIHtcclxuICAgICAgc3VwZXIudXBkYXRlKGVuZ2luZSwgZGVsdGEpOyAvLyBjYWxsIGJhc2UgdXBkYXRlIGxvZ2ljXHJcblxyXG4gICAgICBpZih0aGlzLmdhbWVTY2VuZS5nYW1lT3ZlciB8fCAhdGhpcy5nYW1lU2NlbmUuZ2FtZVN0YXJ0ZWQpXHJcbiAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICB0aGlzLnggLT0gR2FtZVNldHRpbmdzLkhTUEVFRCAqIGRlbHRhLzEwMDA7XHJcblxyXG4gICAgICBpZih0aGlzLnRvcFBhcnQuY29sbGlkZXModGhpcy5nYW1lU2NlbmUucGxheWVyKSAhPSBudWxsIHx8IHRoaXMuYm90dG9tUGFydC5jb2xsaWRlcyh0aGlzLmdhbWVTY2VuZS5wbGF5ZXIpICE9IG51bGwpXHJcbiAgICAgICAgIHRoaXMuZ2FtZVNjZW5lLnNldEdhbWVPdmVyKCk7XHJcblxyXG4gICAgICBpZih0aGlzLnggPCBHYW1lU2V0dGluZ3MuUEVTVF9XSURUSC8yKSB7XHJcbiAgICAgICAgICBpZighdGhpcy5wYXNzZWQpIHtcclxuICAgICAgICAgICAgICB0aGlzLnBhc3NlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgdGhpcy5nYW1lU2NlbmUuc2NvcmUrKztcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZih0aGlzLnggPCAtR2FtZVNldHRpbmdzLlBFU1RfV0lEVEgvMikge1xyXG4gICAgICAgICAgICAgIHRoaXMua2lsbCgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgIH1cclxufVxyXG5cclxuZXhwb3J0IHsgUGVzdGljaWRlIH07IiwiaW1wb3J0ICogYXMgZXggZnJvbSAnZXhjYWxpYnVyJztcclxuaW1wb3J0IHsgUmVzb3VyY2UgfSBmcm9tICcuLi8uLi9yZXNvdXJjZSc7XHJcbmltcG9ydCB7IEdhbWVTZXR0aW5ncyB9IGZyb20gJy4uLy4uL2dhbWVzZXR0aW5ncyc7XHJcbmltcG9ydCB7IEdhbWVTY2VuZSB9IGZyb20gJy4uLy4uL3NjZW5lcy9nYW1lU2NlbmUvZ2FtZXNjZW5lJztcclxuXHJcbmNsYXNzIFBsYXllciBleHRlbmRzIGV4LkFjdG9yIHtcclxuICAgIHB1YmxpYyB5cG9zOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgeXNwZWVkOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgeWFjYzogbnVtYmVyO1xyXG4gICAgcHJvdGVjdGVkIHByZXNzZWQ6IGJvb2xlYW47XHJcbiAgICBwdWJsaWMgZmxhcEFuaW1hdGlvbjogZXguQW5pbWF0aW9uO1xyXG4gICAgLy9wcml2YXRlIGdhbWVTdGFydGVkOiBib29sZWFuO1xyXG4gICAgcHJvdGVjdGVkIGdhbWVTY2VuZTogR2FtZVNjZW5lO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHNjZW5lOiBHYW1lU2NlbmUpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG5cclxuICAgICAgICB0aGlzLnNldFdpZHRoKDQyKTtcclxuICAgICAgICB0aGlzLnNldEhlaWdodCgzMik7XHJcbiAgICAgICAgdGhpcy54ID0gMTAwO1xyXG5cclxuICAgICAgICB0aGlzLnlwb3MgPSBHYW1lU2V0dGluZ3MuSEVJR0hULzI7XHJcbiAgICAgICAgdGhpcy55c3BlZWQgPSAwO1xyXG4gICAgICAgIHRoaXMueWFjYyA9IEdhbWVTZXR0aW5ncy5HUkFWSVRZO1xyXG4gICAgICAgIHRoaXMucHJlc3NlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMueSA9IHRoaXMueXBvcztcclxuXHJcbiAgICAgICAgLy90aGlzLmdhbWVTdGFydGVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHRoaXMuZ2FtZVNjZW5lID0gc2NlbmU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uSW5pdGlhbGl6ZShlbmdpbmU6IGV4LkVuZ2luZSkge1xyXG4gICAgICAgIHRoaXMuYWRkRHJhd2luZyhcImlkbGVcIiwgbmV3IGV4LlNwcml0ZShSZXNvdXJjZS5UeFBsYXllciwgMCwgMCwgNjQsIDY0KSk7XHJcbiAgICAgICAgdGhpcy5zZXREcmF3aW5nKFwiaWRsZVwiKTtcclxuXHJcbiAgICAgICAgY29uc3QgcGxheWVySWRsZVNoZWV0ID0gbmV3IGV4LlNwcml0ZVNoZWV0KFJlc291cmNlLlR4UGxheWVyLCAxNiwgMSwgNjQsIDY0KTtcclxuICAgICAgICB0aGlzLmZsYXBBbmltYXRpb24gPSBwbGF5ZXJJZGxlU2hlZXQuZ2V0QW5pbWF0aW9uQmV0d2VlbihlbmdpbmUsIDEsIDE2LCAzKTtcclxuICAgICAgICB0aGlzLmZsYXBBbmltYXRpb24ubG9vcCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYWRkRHJhd2luZyhcImZsYXBcIiwgdGhpcy5mbGFwQW5pbWF0aW9uKTtcclxuXHJcbiAgICAgICAgZW5naW5lLmlucHV0LnBvaW50ZXJzLnByaW1hcnkub24oXCJkb3duXCIsIHRoaXMub25QcmVzcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uUHJlc3MgPSAoKSA9PiB7XHJcbiAgICAgICAgLy90aGlzLmdhbWVTdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnByZXNzZWQgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyByZXNldCA9ICgpID0+IHtcclxuICAgICAgICB0aGlzLnlwb3MgPSBHYW1lU2V0dGluZ3MuSEVJR0hULzI7XHJcbiAgICAgICAgdGhpcy55c3BlZWQgPSAwO1xyXG4gICAgICAgIHRoaXMueWFjYyA9IEdhbWVTZXR0aW5ncy5HUkFWSVRZO1xyXG4gICAgICAgIHRoaXMucHJlc3NlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMueSA9IHRoaXMueXBvcztcclxuICAgICAgICB0aGlzLnJvdGF0aW9uID0gMDtcclxuXHJcbiAgICAgICAgLy90aGlzLmdhbWVTdGFydGVkID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHVwZGF0ZShlbmdpbmU6IGV4LkVuZ2luZSwgZGVsdGE6IG51bWJlcikge1xyXG4gICAgICBzdXBlci51cGRhdGUoZW5naW5lLCBkZWx0YSk7IC8vIGNhbGwgYmFzZSB1cGRhdGUgbG9naWNcclxuXHJcbiAgICAgIGlmKHRoaXMuZ2FtZVNjZW5lLmdhbWVPdmVyIHx8ICF0aGlzLmdhbWVTY2VuZS5nYW1lU3RhcnRlZClcclxuICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGlmKHRoaXMucHJlc3NlZCkge1xyXG4gICAgICAgICAgdGhpcy55c3BlZWQgPSBHYW1lU2V0dGluZ3MuRk9SQ0U7XHJcbiAgICAgICAgICB0aGlzLnNldERyYXdpbmcoXCJmbGFwXCIpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2VcclxuICAgICAgICAgIHRoaXMueXNwZWVkID0gR2FtZVNldHRpbmdzLkdSQVZJVFkgKyAodGhpcy55c3BlZWQgLSBHYW1lU2V0dGluZ3MuR1JBVklUWSkgKiAoTWF0aC5leHAoLWRlbHRhLygxMDAwKkdhbWVTZXR0aW5ncy5JTkVSVElBKSkpO1xyXG5cclxuICAgICAgdGhpcy55cG9zICs9IHRoaXMueXNwZWVkICogZGVsdGEvMTAwMDtcclxuICAgICAgdGhpcy55ID0gdGhpcy55cG9zO1xyXG4gICAgICAvL3RoaXMucm90YXRpb24gPSBNYXRoLm1heCgtMC4zLCBNYXRoLm1pbigwLjMsIE1hdGguYXRhbjIodGhpcy55c3BlZWQsIEdhbWVTZXR0aW5ncy5IU1BFRUQpLzIpKTtcclxuICAgICAgdGhpcy5yb3RhdGlvbiA9IHRoaXMueXNwZWVkIDwgMzAwID8gLTAuMyA6ICh0aGlzLnlzcGVlZCA+IDYwMCA/IDAuMyA6IC0wLjkgKyAwLjAwMiAqIHRoaXMueXNwZWVkKTtcclxuXHJcbiAgICAgIHRoaXMucHJlc3NlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgaWYodGhpcy5mbGFwQW5pbWF0aW9uLmlzRG9uZSgpKVxyXG4gICAgICAgICAgdGhpcy5zZXREcmF3aW5nKFwiaWRsZVwiKTtcclxuXHJcblxyXG4gICAgICBpZih0aGlzLmNvbGxpZGVzKHRoaXMuZ2FtZVNjZW5lLmdyb3VuZCkgIT0gbnVsbClcclxuICAgICAgICAgdGhpcy5nYW1lU2NlbmUuc2V0R2FtZU92ZXIoKTtcclxuICAgfVxyXG59XHJcblxyXG5leHBvcnQgeyBQbGF5ZXIgfTsiLCJleHBvcnQgbmFtZXNwYWNlIENvbW11bmljYXRpb24ge1xyXG4gICAgLy8gY2xhc3MgU2NvcmVNZXNzYWdlIHtcclxuICAgIC8vICAgICBwdWJsaWMgbWVzc2FnZVR5cGU6IHN0cmluZztcclxuICAgIC8vICAgICBwdWJsaWMgc2NvcmU6IG51bWJlcjtcclxuXHJcbiAgICAvLyAgICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAvLyAgICAgICAgIHRoaXMubWVzc2FnZVR5cGUgPSBcIlNDT1JFXCI7XHJcbiAgICAvLyAgICAgfVxyXG4gICAgLy8gfVxyXG5cclxuICAgIGV4cG9ydCBmdW5jdGlvbiBwb3N0U2NvcmUgKG5ld1Njb3JlOiBudW1iZXIpIHtcclxuICAgICAgICB2YXIgbXNnID0ge21lc3NhZ2VUeXBlOiBcIlNDT1JFXCIsIHNjb3JlOiBuZXdTY29yZX07XHJcbiAgICAgICAgd2luZG93LnBhcmVudC5wb3N0TWVzc2FnZShtc2csIFwiKlwiKTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKG1zZyk7XHJcbiAgICB9XHJcbn0iLCJleHBvcnQgbmFtZXNwYWNlIEdhbWVTZXR0aW5ncyB7XHJcbiAgICBleHBvcnQgY29uc3QgV0lEVEggPSA4MDA7XHJcbiAgICBleHBvcnQgY29uc3QgSEVJR0hUID0gNjAwO1xyXG5cclxuICAgIGV4cG9ydCBjb25zdCBHUkFWSVRZID0gODAwO1xyXG4gICAgZXhwb3J0IGNvbnN0IEZPUkNFID0gLTgwMDtcclxuICAgIGV4cG9ydCBjb25zdCBJTkVSVElBID0gMC4zO1xyXG4gICAgZXhwb3J0IGNvbnN0IEhTUEVFRCA9IDIwMDtcclxuXHJcbiAgICBleHBvcnQgY29uc3QgVElNRV9JTlRFUlZBTCA9IDEuNTtcclxuICAgIGV4cG9ydCBjb25zdCBWQVJJQUJJTElUWSA9IDEwMDtcclxuICAgIGV4cG9ydCBjb25zdCBNQVhfU1BBQ0UgPSAxODA7XHJcbiAgICBleHBvcnQgY29uc3QgTUlOX1NQQUNFID0gMTAwO1xyXG4gICAgZXhwb3J0IGNvbnN0IFNDT1JFX01BWF9ESUZGID0gMTAwO1xyXG4gICAgZXhwb3J0IGNvbnN0IFNUQVJUX1ZfTElNSVQgPSAwLjI7XHJcbiAgICBleHBvcnQgY29uc3QgRU5EX1ZfTElNSVQgPSAxO1xyXG5cclxuICAgIGV4cG9ydCBjb25zdCBCR19USU1FX0lOVEVSVkFMID0gMzA7XHJcbiAgICBleHBvcnQgY29uc3QgQkdfSFNQRUVEID0gODA7XHJcbiAgICBleHBvcnQgY29uc3QgQkdfVkFSSUFCSUxJVFkgPSAzMDA7XHJcblxyXG4gICAgZXhwb3J0IGNvbnN0IEdST1VORF9IRUlHSFQgPSA2NDtcclxuICAgIGV4cG9ydCBjb25zdCBQRVNUX0hFSUdIVCA9IDUxMjtcclxuICAgIGV4cG9ydCBjb25zdCBQRVNUX1dJRFRIID0gNjQ7XHJcbn0iLCJpbXBvcnQgKiBhcyBleCBmcm9tICdleGNhbGlidXInO1xyXG5pbXBvcnQgeyBHYW1lU2NlbmUgfSBmcm9tICcuL3NjZW5lcy9nYW1lU2NlbmUvZ2FtZXNjZW5lJztcclxuaW1wb3J0IHsgUGxheWVyIH0gZnJvbSAnLi9hY3RvcnMvcGxheWVyL3BsYXllcic7XHJcbmltcG9ydCB7IFJlc291cmNlIH0gZnJvbSAnLi9yZXNvdXJjZSc7XHJcbmltcG9ydCB7IEdhbWVTZXR0aW5ncyB9IGZyb20gJy4vZ2FtZXNldHRpbmdzJztcclxuXHJcbmNsYXNzIEdhbWUgZXh0ZW5kcyBleC5FbmdpbmUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoeyB3aWR0aDogR2FtZVNldHRpbmdzLldJRFRILFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBHYW1lU2V0dGluZ3MuSEVJR0hULFxyXG4gICAgICAgICAgICAgICAgZGlzcGxheU1vZGU6IGV4LkRpc3BsYXlNb2RlLkZpeGVkLFxyXG4gICAgICAgICAgICAgICAgcG9pbnRlclNjb3BlOiBleC5JbnB1dC5Qb2ludGVyU2NvcGUuQ2FudmFzIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGFydChsb2FkZXI/OiBleC5JTG9hZGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLnN0YXJ0KGxvYWRlcik7XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciBsb2FkZXIgPSBuZXcgZXguTG9hZGVyKCk7XHJcbmZvcih2YXIgcmVzb3VyY2UgaW4gUmVzb3VyY2Upe1xyXG4gICAgbG9hZGVyLmFkZFJlc291cmNlKFJlc291cmNlW3Jlc291cmNlXSk7XHJcbn1cclxuXHJcbmNvbnN0IGdhbWUgPSBuZXcgR2FtZSgpO1xyXG5jb25zdCBnYW1lU2NlbmUgPSBuZXcgR2FtZVNjZW5lKCk7XHJcblxyXG5nYW1lLmFkZCgnZ2FtZVNjZW5lJywgZ2FtZVNjZW5lKTtcclxuXHJcbmdhbWUuc3RhcnQobG9hZGVyKS50aGVuKCgpID0+IHtcclxuICAgIGdhbWUuZ29Ub1NjZW5lKCdnYW1lU2NlbmUnKTtcclxufSk7XHJcbiIsImltcG9ydCAqIGFzIGV4IGZyb20gJ2V4Y2FsaWJ1cic7XHJcblxyXG4vLyBJbWFnZSBhbmQgc291bmQgcmVzb3VyY2VzIHRvIGJlIGxvYWRlZFxyXG52YXIgUmVzb3VyY2UgPSB7XHJcblx0QmFja2dyb3VuZDogbmV3IGV4LlRleHR1cmUoXCJhc3NldHMvYmFja2dyb3VuZC5wbmdcIiksXHJcblxyXG4gICAgVHhQbGF5ZXI6IG5ldyBleC5UZXh0dXJlKFwiYXNzZXRzL2JlZS5wbmdcIiksXHJcbiAgICBHcm91bmQ6IG5ldyBleC5UZXh0dXJlKFwiYXNzZXRzL2dyb3VuZC5wbmdcIiksXHJcblxyXG4gICAgUm5kcDogbmV3IGV4LlRleHR1cmUoXCJhc3NldHMvcm5kcC5wbmdcIiksXHJcbiAgICBTbXJ0eDogbmV3IGV4LlRleHR1cmUoXCJhc3NldHMvc21ydHgucG5nXCIpLFxyXG4gICAgSW5zY3RXYXNwOiBuZXcgZXguVGV4dHVyZShcImFzc2V0cy9pbnNjdF93YXNwLnBuZ1wiKSxcclxuICAgIENob2dvOiBuZXcgZXguVGV4dHVyZShcImFzc2V0cy9jaG9nby5wbmdcIiksXHJcblxyXG4gICAgQ2hlbWljYWxQbGFudDogbmV3IGV4LlRleHR1cmUoXCJhc3NldHMvY2hlbWljYWxfcGxhbnQucG5nXCIpLFxyXG4gICAgUmFkaW9Ub3dlcjogbmV3IGV4LlRleHR1cmUoXCJhc3NldHMvcmFkaW9fdG93ZXIucG5nXCIpXHJcbn1cclxuXHJcbmV4cG9ydCB7IFJlc291cmNlIH07IiwiaW1wb3J0ICogYXMgZXggZnJvbSAnZXhjYWxpYnVyJztcclxuaW1wb3J0IHsgUmVzb3VyY2UgfSBmcm9tICcuLi8uLi9yZXNvdXJjZSc7XHJcbmltcG9ydCB7IFBsYXllciB9IGZyb20gJy4uLy4uL2FjdG9ycy9wbGF5ZXIvcGxheWVyJztcclxuaW1wb3J0IHsgUGVzdGljaWRlIH0gZnJvbSAnLi4vLi4vYWN0b3JzL29ic3RhY2xlcy9wZXN0aWNpZGUnO1xyXG5pbXBvcnQgeyBCYWNrZ3JvdW5kT2JqZWN0IH0gZnJvbSAnLi4vLi4vYWN0b3JzL2RlY29yL2JhY2tncm91bmRPYmplY3QnO1xyXG5pbXBvcnQgeyBHYW1lU2V0dGluZ3MgfSBmcm9tICcuLi8uLi9nYW1lc2V0dGluZ3MnO1xyXG5pbXBvcnQgeyBDb21tdW5pY2F0aW9uIH0gZnJvbSAnLi4vLi4vY29tbXVuaWNhdGlvbic7XHJcbi8vaW1wb3J0IHsgSW5wdXQgfSBmcm9tICdleGNhbGlidXInO1xyXG5cclxuXHJcbmNsYXNzIEdhbWVTY2VuZSBleHRlbmRzIGV4LlNjZW5lIHtcclxuICAgIHB1YmxpYyBzY29yZTogbnVtYmVyO1xyXG5cclxuICAgIHB1YmxpYyBwbGF5ZXI6IFBsYXllcjtcclxuICAgIHByb3RlY3RlZCBjZW50ZXJMYWJlbDogZXguTGFiZWw7XHJcbiAgICBwcm90ZWN0ZWQgcmVzdGFydExhYmVsOiBleC5MYWJlbDtcclxuICAgIHByb3RlY3RlZCBzY29yZUxhYmVsOiBleC5MYWJlbDtcclxuXHJcbiAgICBwcm90ZWN0ZWQgbGFzdE9ic3RhY2xlVGltZTogbnVtYmVyO1xyXG4gICAgcHJvdGVjdGVkIGxhc3RPYnN0YWNsZVk6IG51bWJlcjtcclxuICAgIHB1YmxpYyBsYXN0UGVzdDogbnVtYmVyO1xyXG4gICAgcHJvdGVjdGVkIGxhc3RCYWNrZ3JvdW5kVGltZTogbnVtYmVyO1xyXG5cclxuICAgIHB1YmxpYyBnYW1lU3RhcnRlZDogYm9vbGVhbjtcclxuICAgIHB1YmxpYyBnYW1lT3ZlcjogYm9vbGVhbjtcclxuICAgIHB1YmxpYyByZXNldFNjZW5lOiBib29sZWFuO1xyXG4gICAgcHVibGljIGNhblJlc3RhcnQ6IGJvb2xlYW47XHJcblxyXG4gICAgcHVibGljIGdyb3VuZDogZXguQWN0b3I7XHJcblxyXG4gICAgcHVibGljIG9uSW5pdGlhbGl6ZShlbmdpbmU6IGV4LkVuZ2luZSkge1xyXG4gICAgICAgIHRoaXMuc2NvcmUgPSAwO1xyXG5cclxuICAgICAgICB2YXIgYmFja2dyb3VuZCA9IG5ldyBleC5BY3RvcigpO1xyXG4gICAgICAgIGJhY2tncm91bmQuYWRkRHJhd2luZyhSZXNvdXJjZS5CYWNrZ3JvdW5kLmFzU3ByaXRlKCkpO1xyXG4gICAgICAgIHRoaXMuYWRkKGJhY2tncm91bmQpO1xyXG4gICAgICAgIGJhY2tncm91bmQueCA9IEdhbWVTZXR0aW5ncy5XSURUSC8yO1xyXG4gICAgICAgIGJhY2tncm91bmQueSA9IEdhbWVTZXR0aW5ncy5IRUlHSFQvMjtcclxuICAgICAgICBiYWNrZ3JvdW5kLnogPSAtMTA7XHJcblxyXG4gICAgICAgIHRoaXMucGxheWVyID0gbmV3IFBsYXllcih0aGlzKTtcclxuICAgICAgICB0aGlzLmFkZCh0aGlzLnBsYXllcik7XHJcbiAgICAgICAgdGhpcy5wbGF5ZXIueiA9IDc7XHJcblxyXG4gICAgICAgIHRoaXMubGFzdE9ic3RhY2xlVGltZSA9IEdhbWVTZXR0aW5ncy5USU1FX0lOVEVSVkFMO1xyXG4gICAgICAgIHRoaXMubGFzdE9ic3RhY2xlWSA9IEdhbWVTZXR0aW5ncy5IRUlHSFQvMjtcclxuICAgICAgICB0aGlzLmxhc3RQZXN0ID0gLTE7XHJcbiAgICAgICAgdGhpcy5sYXN0QmFja2dyb3VuZFRpbWUgPSBHYW1lU2V0dGluZ3MuQkdfVElNRV9JTlRFUlZBTDtcclxuXHJcbiAgICAgICAgdGhpcy5jZW50ZXJMYWJlbCA9IG5ldyBleC5MYWJlbChcIkNsaWNrIHRvIHN0YXJ0IGZsYXBwaW5nLlwiLCBHYW1lU2V0dGluZ3MuV0lEVEgvMiwgR2FtZVNldHRpbmdzLkhFSUdIVC8yLCBcIkFyaWFsXCIpO1xyXG4gICAgICAgIHRoaXMuY2VudGVyTGFiZWwudGV4dEFsaWduID0gZXguVGV4dEFsaWduLkNlbnRlcjtcclxuICAgICAgICB0aGlzLmNlbnRlckxhYmVsLmJhc2VBbGlnbiA9IGV4LkJhc2VBbGlnbi5NaWRkbGU7XHJcbiAgICAgICAgdGhpcy5jZW50ZXJMYWJlbC5mb250U2l6ZSA9IDQyO1xyXG4gICAgICAgIHRoaXMuY2VudGVyTGFiZWwuY29sb3IgPSBleC5Db2xvci5XaGl0ZTtcclxuICAgICAgICB0aGlzLmFkZCh0aGlzLmNlbnRlckxhYmVsKTtcclxuICAgICAgICB0aGlzLmNlbnRlckxhYmVsLnogPSAxMDtcclxuXHJcbiAgICAgICAgdGhpcy5yZXN0YXJ0TGFiZWwgPSBuZXcgZXguTGFiZWwoXCJjbGljayB0byByZXN0YXJ0XCIsIEdhbWVTZXR0aW5ncy5XSURUSC8yLCBHYW1lU2V0dGluZ3MuSEVJR0hULzIgKyAzMiwgXCJBcmlhbFwiKTtcclxuICAgICAgICB0aGlzLnJlc3RhcnRMYWJlbC50ZXh0QWxpZ24gPSBleC5UZXh0QWxpZ24uQ2VudGVyO1xyXG4gICAgICAgIHRoaXMucmVzdGFydExhYmVsLmJhc2VBbGlnbiA9IGV4LkJhc2VBbGlnbi5Ub3A7XHJcbiAgICAgICAgdGhpcy5yZXN0YXJ0TGFiZWwuZm9udFNpemUgPSAyODtcclxuICAgICAgICB0aGlzLnJlc3RhcnRMYWJlbC5jb2xvciA9IGV4LkNvbG9yLldoaXRlO1xyXG4gICAgICAgIHRoaXMuYWRkKHRoaXMucmVzdGFydExhYmVsKTtcclxuICAgICAgICB0aGlzLnJlc3RhcnRMYWJlbC56ID0gMTA7XHJcbiAgICAgICAgdGhpcy5yZXN0YXJ0TGFiZWwudmlzaWJsZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICB0aGlzLnNjb3JlTGFiZWwgPSBuZXcgZXguTGFiZWwoXCIwXCIsIEdhbWVTZXR0aW5ncy5XSURUSC0zMiwgMzIsIFwiQXJpYWxcIik7XHJcbiAgICAgICAgdGhpcy5zY29yZUxhYmVsLnRleHRBbGlnbiA9IGV4LlRleHRBbGlnbi5SaWdodDtcclxuICAgICAgICB0aGlzLnNjb3JlTGFiZWwuYmFzZUFsaWduID0gZXguQmFzZUFsaWduLlRvcDtcclxuICAgICAgICB0aGlzLnNjb3JlTGFiZWwuZm9udFNpemUgPSA0MjtcclxuICAgICAgICB0aGlzLnNjb3JlTGFiZWwuY29sb3IgPSBleC5Db2xvci5XaGl0ZTtcclxuICAgICAgICB0aGlzLmFkZCh0aGlzLnNjb3JlTGFiZWwpO1xyXG4gICAgICAgIHRoaXMuc2NvcmVMYWJlbC56ID0gMTA7XHJcblxyXG4gICAgICAgIHRoaXMuZ2FtZVN0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmdhbWVPdmVyID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5yZXNldFNjZW5lID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jYW5SZXN0YXJ0ID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHRoaXMuZ3JvdW5kID0gbmV3IGV4LkFjdG9yKCk7XHJcbiAgICAgICAgdGhpcy5ncm91bmQuYWRkRHJhd2luZyhSZXNvdXJjZS5Hcm91bmQuYXNTcHJpdGUoKSk7XHJcbiAgICAgICAgdGhpcy5ncm91bmQueCA9IEdhbWVTZXR0aW5ncy5XSURUSC8yO1xyXG4gICAgICAgIHRoaXMuZ3JvdW5kLnkgPSBHYW1lU2V0dGluZ3MuSEVJR0hUIC0gR2FtZVNldHRpbmdzLkdST1VORF9IRUlHSFQvMjtcclxuICAgICAgICB0aGlzLmdyb3VuZC5zZXRXaWR0aChHYW1lU2V0dGluZ3MuV0lEVEgpO1xyXG4gICAgICAgIHRoaXMuZ3JvdW5kLnNldEhlaWdodChHYW1lU2V0dGluZ3MuR1JPVU5EX0hFSUdIVCk7XHJcbiAgICAgICAgdGhpcy5hZGQodGhpcy5ncm91bmQpO1xyXG4gICAgICAgIHRoaXMuZ3JvdW5kLnogPSA1O1xyXG5cclxuICAgICAgICBlbmdpbmUuaW5wdXQucG9pbnRlcnMucHJpbWFyeS5vbihcImRvd25cIiwgdGhpcy5vblByZXNzKTtcclxuICAgICAgICAvL2VuZ2luZS5pbnB1dC5rZXlib2FyZC5vbihcInByZXNzXCIsIChldnQ6IElucHV0LktleUV2ZW50KSA9PiB7IGlmKGV2dC5rZXkgPT0gSW5wdXQuS2V5cy5TcGFjZSkgdGhpcy5vblNwYWNlKCkgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuY2FtZXJhLnBvcyA9IG5ldyBleC5WZWN0b3IoR2FtZVNldHRpbmdzLldJRFRILzIsIEdhbWVTZXR0aW5ncy5IRUlHSFQvMik7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uUHJlc3MgPSAoKSA9PiB7XHJcbiAgICAgICAgaWYoIXRoaXMuZ2FtZVN0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5nYW1lU3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuY2VudGVyTGFiZWwudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodGhpcy5nYW1lT3ZlciAmJiB0aGlzLmNhblJlc3RhcnQpXHJcbiAgICAgICAgICAgIHRoaXMucmVzZXRTY2VuZSA9IHRydWU7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHB1YmxpYyB1cGRhdGUoZW5naW5lOiBleC5FbmdpbmUsIGRlbHRhOiBudW1iZXIpIHtcclxuICAgICAgICBzdXBlci51cGRhdGUoZW5naW5lLCBkZWx0YSk7XHJcblxyXG4gICAgICAgIGlmKHRoaXMuZ2FtZU92ZXIgJiYgIXRoaXMuY2FuUmVzdGFydCkge1xyXG4gICAgICAgICAgICB0aGlzLmxhc3RPYnN0YWNsZVRpbWUgKz0gZGVsdGEvMTAwMDtcclxuICAgICAgICAgICAgaWYodGhpcy5sYXN0T2JzdGFjbGVUaW1lID4gMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYW5SZXN0YXJ0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVzdGFydExhYmVsLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZih0aGlzLnJlc2V0U2NlbmUpIHtcclxuICAgICAgICAgICAgZm9yKHZhciBhYyBpbiB0aGlzLmFjdG9ycykge1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5hY3RvcnNbYWNdIGluc3RhbmNlb2YgUGVzdGljaWRlIHx8IHRoaXMuYWN0b3JzW2FjXSBpbnN0YW5jZW9mIEJhY2tncm91bmRPYmplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yc1thY10ua2lsbCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnBsYXllci5yZXNldCgpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zY29yZSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMucmVzdGFydExhYmVsLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5jZW50ZXJMYWJlbC50ZXh0ID0gXCJDbGljayB0byBzdGFydCBmbGFwcGluZy5cIjtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZVN0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5nYW1lT3ZlciA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmNhblJlc3RhcnQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubGFzdE9ic3RhY2xlVGltZSA9IEdhbWVTZXR0aW5ncy5USU1FX0lOVEVSVkFMO1xyXG4gICAgICAgICAgICB0aGlzLmxhc3RPYnN0YWNsZVkgPSBHYW1lU2V0dGluZ3MuSEVJR0hULzI7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmxhc3RCYWNrZ3JvdW5kVGltZSA9IEdhbWVTZXR0aW5ncy5CR19USU1FX0lOVEVSVkFMO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5yZXNldFNjZW5lID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBlbHNlIGlmKHRoaXMuZ2FtZU92ZXIgfHwgIXRoaXMuZ2FtZVN0YXJ0ZWQpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAvL3N1cGVyLnVwZGF0ZShlbmdpbmUsIGRlbHRhKTsgLy8gY2FsbCBiYXNlIHVwZGF0ZSBsb2dpY1xyXG5cclxuICAgICAgICAgICAgdGhpcy5sYXN0T2JzdGFjbGVUaW1lICs9IGRlbHRhLzEwMDA7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdEJhY2tncm91bmRUaW1lICs9IGRlbHRhLzEwMDA7XHJcblxyXG4gICAgICAgICAgICBpZih0aGlzLmxhc3RPYnN0YWNsZVRpbWUgPiBHYW1lU2V0dGluZ3MuVElNRV9JTlRFUlZBTCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvc3ggPSBHYW1lU2V0dGluZ3MuV0lEVEggKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBHYW1lU2V0dGluZ3MuVkFSSUFCSUxJVFkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNwYWNlWSA9IE1hdGguZmxvb3IoR2FtZVNldHRpbmdzLk1BWF9TUEFDRSAtIChHYW1lU2V0dGluZ3MuTUFYX1NQQUNFIC0gR2FtZVNldHRpbmdzLk1JTl9TUEFDRSkgLyBHYW1lU2V0dGluZ3MuU0NPUkVfTUFYX0RJRkYpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvc3k7XHJcbiAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zeSA9IE1hdGguZmxvb3Ioc3BhY2VZICsgTWF0aC5yYW5kb20oKSAqIChHYW1lU2V0dGluZ3MuSEVJR0hUIC0gR2FtZVNldHRpbmdzLkdST1VORF9IRUlHSFQgLSAyKnNwYWNlWSkpXHJcbiAgICAgICAgICAgICAgICB9IHdoaWxlKE1hdGguYWJzKHBvc3kgLSB0aGlzLmxhc3RPYnN0YWNsZVkpID4gKEdhbWVTZXR0aW5ncy5TVEFSVF9WX0xJTUlUICsgKEdhbWVTZXR0aW5ncy5FTkRfVl9MSU1JVCAtIEdhbWVTZXR0aW5ncy5TVEFSVF9WX0xJTUlUKSAqIHRoaXMuc2NvcmUgLyBHYW1lU2V0dGluZ3MuU0NPUkVfTUFYX0RJRkYpICogR2FtZVNldHRpbmdzLkhFSUdIVCk7XHJcbiAgICAgICAgICAgICAgICAvL2FsZXJ0KHBvc3ggKyBcIiBcIiArIHBvc3kgKyBcIiBcIiArIHNwYWNlWSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGQobmV3IFBlc3RpY2lkZShwb3N4LCBwb3N5LCBzcGFjZVksIHRoaXMpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubGFzdE9ic3RhY2xlWSA9IHBvc3k7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RPYnN0YWNsZVRpbWUgPSAwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgaWYodGhpcy5sYXN0QmFja2dyb3VuZFRpbWUgPiBHYW1lU2V0dGluZ3MuQkdfVElNRV9JTlRFUlZBTCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGJnID0gbmV3IEJhY2tncm91bmRPYmplY3QodGhpcylcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGJnKTtcclxuICAgICAgICAgICAgICAgIGJnLnogPSAtM1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0QmFja2dyb3VuZFRpbWUgPSAwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNjb3JlTGFiZWwudGV4dCA9IHRoaXMuc2NvcmUudG9TdHJpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldEdhbWVPdmVyID0gKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuZ2FtZU92ZXIgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuY2VudGVyTGFiZWwudGV4dCA9IFwiR2FtZSBPdmVyXCJcclxuICAgICAgICB0aGlzLmNlbnRlckxhYmVsLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMubGFzdE9ic3RhY2xlVGltZSA9IDA7XHJcblxyXG4gICAgICAgIENvbW11bmljYXRpb24ucG9zdFNjb3JlKHRoaXMuc2NvcmUpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvbkFjdGl2YXRlKCkge31cclxuICAgIHB1YmxpYyBvbkRlYWN0aXZhdGUoKSB7fVxyXG59XHJcblxyXG5leHBvcnQgeyBHYW1lU2NlbmUgfTsiXSwic291cmNlUm9vdCI6IiJ9