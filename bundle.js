/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/excalibur/dist/excalibur.js":
/*!**************************************************!*\
  !*** ./node_modules/excalibur/dist/excalibur.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;/*! excalibur - v0.15.0 - 2018-02-17
* https://github.com/excaliburjs/Excalibur
* Copyright (c) 2018 Excalibur.js <https://github.com/excaliburjs/Excalibur/graphs/contributors>; Licensed BSD-2-Clause
* @preserve */
(function (root, factory) {
    if (true) {
        // AMD. Register as an anonymous module.
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function (b) {
            return (root.ex = factory(b));
        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function () {
    //almond, and your modules will be inlined here
/**
 * @license almond 0.3.3 Copyright jQuery Foundation and other contributors.
 * Released under MIT license, http://github.com/requirejs/almond/LICENSE
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice,
        jsSuffixRegExp = /\.js$/;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap, lastIndex,
            foundI, foundStarMap, starI, i, j, part, normalizedBaseParts,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name) {
            name = name.split('/');
            lastIndex = name.length - 1;

            // If wanting node ID compatibility, strip .js from end
            // of IDs. Have to do this here, and not in nameToUrl
            // because node allows either .js or non .js to map
            // to same file.
            if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
            }

            // Starts with a '.' so need the baseName
            if (name[0].charAt(0) === '.' && baseParts) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that 'directory' and not name of the baseName's
                //module. For instance, baseName of 'one/two/three', maps to
                //'one/two/three.js', but we want the directory, 'one/two' for
                //this normalization.
                normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                name = normalizedBaseParts.concat(name);
            }

            //start trimDots
            for (i = 0; i < name.length; i++) {
                part = name[i];
                if (part === '.') {
                    name.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    // If at the start, or previous value is still ..,
                    // keep them so that when converted to a path it may
                    // still work when converted to a path, even though
                    // as an ID it is less than ideal. In larger point
                    // releases, may be better to just kick out an error.
                    if (i === 0 || (i === 1 && name[2] === '..') || name[i - 1] === '..') {
                        continue;
                    } else if (i > 0) {
                        name.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
            //end trimDots

            name = name.join('/');
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            var args = aps.call(arguments, 0);

            //If first arg is not require('string'), and there is only
            //one arg, it is the array form without a callback. Insert
            //a null so that the following concat is correct.
            if (typeof args[0] !== 'string' && args.length === 1) {
                args.push(null);
            }
            return req.apply(undef, args.concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    //Creates a parts array for a relName where first part is plugin ID,
    //second part is resource ID. Assumes relName has already been normalized.
    function makeRelParts(relName) {
        return relName ? splitPrefix(relName) : [];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relParts) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0],
            relResourceName = relParts[1];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relResourceName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relResourceName));
            } else {
                name = normalize(name, relResourceName);
            }
        } else {
            name = normalize(name, relResourceName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i, relParts,
            args = [],
            callbackType = typeof callback,
            usingExports;

        //Use name if no relName
        relName = relName || name;
        relParts = makeRelParts(relName);

        //Call the callback to define the module, if necessary.
        if (callbackType === 'undefined' || callbackType === 'function') {
            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relParts);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback ? callback.apply(defined[name], args) : undefined;

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, makeRelParts(callback)).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (config.deps) {
                req(config.deps, config.callback);
            }
            if (!callback) {
                return;
            }

            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        return req(cfg);
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {
        if (typeof name !== 'string') {
            throw new Error('See almond README: incorrect module build, no module name');
        }

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());
/*! excalibur - v0.15.0 - 2018-02-17
* https://github.com/excaliburjs/Excalibur
* Copyright (c) 2018 Excalibur.js <https://github.com/excaliburjs/Excalibur/graphs/contributors>; Licensed BSD-2-Clause
* @preserve */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define("Actions/RotationType", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * An enum that describes the strategies that rotation actions can use
     */
    var RotationType;
    (function (RotationType) {
        /**
         * Rotation via `ShortestPath` will use the smallest angle
         * between the starting and ending points. This strategy is the default behavior.
         */
        RotationType[RotationType["ShortestPath"] = 0] = "ShortestPath";
        /**
         * Rotation via `LongestPath` will use the largest angle
         * between the starting and ending points.
         */
        RotationType[RotationType["LongestPath"] = 1] = "LongestPath";
        /**
         * Rotation via `Clockwise` will travel in a clockwise direction,
         * regardless of the starting and ending points.
         */
        RotationType[RotationType["Clockwise"] = 2] = "Clockwise";
        /**
         * Rotation via `CounterClockwise` will travel in a counterclockwise direction,
         * regardless of the starting and ending points.
         */
        RotationType[RotationType["CounterClockwise"] = 3] = "CounterClockwise";
    })(RotationType = exports.RotationType || (exports.RotationType = {}));
});
define("Algebra", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A 2D vector on a plane.
     */
    var Vector = (function () {
        /**
         * @param x  X component of the Vector
         * @param y  Y component of the Vector
         */
        function Vector(x, y) {
            this.x = x;
            this.y = y;
        }
        /**
         * Returns a vector of unit length in the direction of the specified angle in Radians.
         * @param angle The angle to generate the vector
         */
        Vector.fromAngle = function (angle) {
            return new Vector(Math.cos(angle), Math.sin(angle));
        };
        /**
         * Checks if vector is not null, undefined, or if any of its components are NaN or Infinity.
         */
        Vector.isValid = function (vec) {
            if (vec === null || vec === undefined) {
                return false;
            }
            if (isNaN(vec.x) || isNaN(vec.y)) {
                return false;
            }
            if (vec.x === Infinity ||
                vec.y === Infinity ||
                vec.x === -Infinity ||
                vec.y === Infinity) {
                return false;
            }
            return true;
        };
        /**
         * Calculates distance between two Vectors
         * @param vec1
         * @param vec2
         */
        Vector.distance = function (vec1, vec2) {
            return Math.sqrt(Math.pow(vec1.x - vec2.x, 2) + Math.pow(vec1.y - vec2.y, 2));
        };
        /**
         * Sets the x and y components at once
         */
        Vector.prototype.setTo = function (x, y) {
            this.x = x;
            this.y = y;
        };
        /**
         * Compares this point against another and tests for equality
         * @param point  The other point to compare to
         */
        Vector.prototype.equals = function (vector, tolerance) {
            if (tolerance === void 0) { tolerance = .001; }
            return Math.abs(this.x - vector.x) <= tolerance && Math.abs(this.y - vector.y) <= tolerance;
        };
        /**
         * The distance to another vector. If no other Vector is specified, this will return the [[magnitude]].
         * @param v  The other vector. Leave blank to use origin vector.
         */
        Vector.prototype.distance = function (v) {
            if (!v) {
                v = Vector.Zero;
            }
            return Math.sqrt(Math.pow(this.x - v.x, 2) + Math.pow(this.y - v.y, 2));
        };
        /**
         * The magnitude (size) of the Vector
         */
        Vector.prototype.magnitude = function () {
            return this.distance();
        };
        /**
         * Normalizes a vector to have a magnitude of 1.
         */
        Vector.prototype.normalize = function () {
            var d = this.distance();
            if (d > 0) {
                return new Vector(this.x / d, this.y / d);
            }
            else {
                return new Vector(0, 1);
            }
        };
        /**
         * Returns the average (midpoint) between the current point and the specified
         */
        Vector.prototype.average = function (vec) {
            return this.add(vec).scale(.5);
        };
        /**
         * Scales a vector's by a factor of size
         * @param size  The factor to scale the magnitude by
         */
        Vector.prototype.scale = function (size) {
            return new Vector(this.x * size, this.y * size);
        };
        /**
         * Adds one vector to another
         * @param v The vector to add
         */
        Vector.prototype.add = function (v) {
            return new Vector(this.x + v.x, this.y + v.y);
        };
        /**
         * Subtracts a vector from another, if you subract vector `B.sub(A)` the resulting vector points from A -> B
         * @param v The vector to subtract
         */
        Vector.prototype.sub = function (v) {
            return new Vector(this.x - v.x, this.y - v.y);
        };
        /**
         * Adds one vector to this one modifying the original
         * @param v The vector to add
         */
        Vector.prototype.addEqual = function (v) {
            this.x += v.x;
            this.y += v.y;
            return this;
        };
        /**
         * Subtracts a vector from this one modifying the original
         * @parallel v The vector to subtract
         */
        Vector.prototype.subEqual = function (v) {
            this.x -= v.x;
            this.y -= v.y;
            return this;
        };
        /**
         * Scales this vector by a factor of size and modifies the original
         */
        Vector.prototype.scaleEqual = function (size) {
            this.x *= size;
            this.y *= size;
            return this;
        };
        /**
         * Performs a dot product with another vector
         * @param v  The vector to dot
         */
        Vector.prototype.dot = function (v) {
            return this.x * v.x + this.y * v.y;
        };
        Vector.prototype.cross = function (v) {
            if (v instanceof Vector) {
                return this.x * v.y - this.y * v.x;
            }
            else if (typeof v === 'number') {
                return new Vector(v * this.y, -v * this.x);
            }
        };
        /**
         * Returns the perpendicular vector to this one
         */
        Vector.prototype.perpendicular = function () {
            return new Vector(this.y, -this.x);
        };
        /**
         * Returns the normal vector to this one, same as the perpendicular of length 1
         */
        Vector.prototype.normal = function () {
            return this.perpendicular().normalize();
        };
        /**
         * Negate the current vector
         */
        Vector.prototype.negate = function () {
            return this.scale(-1);
        };
        /**
         * Returns the angle of this vector.
         */
        Vector.prototype.toAngle = function () {
            return Math.atan2(this.y, this.x);
        };
        /**
         * Rotates the current vector around a point by a certain number of
         * degrees in radians
         */
        Vector.prototype.rotate = function (angle, anchor) {
            if (!anchor) {
                anchor = new Vector(0, 0);
            }
            var sinAngle = Math.sin(angle);
            var cosAngle = Math.cos(angle);
            var x = cosAngle * (this.x - anchor.x) - sinAngle * (this.y - anchor.y) + anchor.x;
            var y = sinAngle * (this.x - anchor.x) + cosAngle * (this.y - anchor.y) + anchor.y;
            return new Vector(x, y);
        };
        /**
         * Creates new vector that has the same values as the previous.
         */
        Vector.prototype.clone = function () {
            return new Vector(this.x, this.y);
        };
        /**
         * Returns a string repesentation of the vector.
         */
        Vector.prototype.toString = function () {
            return "(" + this.x + ", " + this.y + ")";
        };
        return Vector;
    }());
    /**
     * A (0, 0) vector
     */
    Vector.Zero = new Vector(0, 0);
    /**
     * A (1, 1) vector
     */
    Vector.One = new Vector(1, 1);
    /**
     * A (0.5, 0.5) vector
     */
    Vector.Half = new Vector(0.5, 0.5);
    /**
     * A unit vector pointing up (0, -1)
     */
    Vector.Up = new Vector(0, -1);
    /**
     * A unit vector pointing down (0, 1)
     */
    Vector.Down = new Vector(0, 1);
    /**
     * A unit vector pointing left (-1, 0)
     */
    Vector.Left = new Vector(-1, 0);
    /**
     * A unit vector pointing right (1, 0)
     */
    Vector.Right = new Vector(1, 0);
    exports.Vector = Vector;
    /**
     * A 2D ray that can be cast into the scene to do collision detection
     */
    var Ray = (function () {
        /**
         * @param pos The starting position for the ray
         * @param dir The vector indicating the direction of the ray
         */
        function Ray(pos, dir) {
            this.pos = pos;
            this.dir = dir.normalize();
        }
        /**
         * Tests a whether this ray intersects with a line segment. Returns a number greater than or equal to 0 on success.
         * This number indicates the mathematical intersection time.
         * @param line  The line to test
         */
        Ray.prototype.intersect = function (line) {
            var numerator = line.begin.sub(this.pos);
            // Test is line and ray are parallel and non intersecting
            if (this.dir.cross(line.getSlope()) === 0 && numerator.cross(this.dir) !== 0) {
                return -1;
            }
            // Lines are parallel
            var divisor = (this.dir.cross(line.getSlope()));
            if (divisor === 0) {
                return -1;
            }
            var t = numerator.cross(line.getSlope()) / divisor;
            if (t >= 0) {
                var u = (numerator.cross(this.dir) / divisor) / line.getLength();
                if (u >= 0 && u <= 1) {
                    return t;
                }
            }
            return -1;
        };
        /**
         * Returns the point of intersection given the intersection time
         */
        Ray.prototype.getPoint = function (time) {
            return this.pos.add(this.dir.scale(time));
        };
        return Ray;
    }());
    exports.Ray = Ray;
    /**
     * A 2D line segment
     */
    var Line = (function () {
        /**
         * @param begin  The starting point of the line segment
         * @param end  The ending point of the line segment
         */
        function Line(begin, end) {
            this.begin = begin;
            this.end = end;
        }
        Object.defineProperty(Line.prototype, "slope", {
            /**
             * Gets the raw slope (m) of the line. Will return (+/-)Infinity for vertical lines.
             */
            get: function () {
                return (this.end.y - this.begin.y) / (this.end.x - this.begin.x);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Line.prototype, "intercept", {
            /**
             * Gets the Y-intercept (b) of the line. Will return (+/-)Infinity if there is no intercept.
             */
            get: function () {
                return this.begin.y - (this.slope * this.begin.x);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Gets the normal of the line
         */
        Line.prototype.normal = function () {
            return this.end.sub(this.begin).normal();
        };
        /**
         * Returns the slope of the line in the form of a vector
         */
        Line.prototype.getSlope = function () {
            var begin = this.begin;
            var end = this.end;
            var distance = begin.distance(end);
            return end.sub(begin).scale(1 / distance);
        };
        /**
         * Returns the length of the line segment in pixels
         */
        Line.prototype.getLength = function () {
            var begin = this.begin;
            var end = this.end;
            var distance = begin.distance(end);
            return distance;
        };
        /**
         * Find the perpendicular distance from the line to a point
         * https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
         * @param point
         */
        Line.prototype.distanceToPoint = function (point) {
            var x0 = point.x;
            var y0 = point.y;
            var l = this.getLength();
            var dy = this.end.y - this.begin.y;
            var dx = this.end.x - this.begin.x;
            var distance = Math.abs(dy * x0 - dx * y0 + this.end.x * this.begin.y - this.end.y * this.begin.x) / l;
            return distance;
        };
        /**
         * Finds a point on the line given only an X or a Y value. Given an X value, the function returns
         * a new point with the calculated Y value and vice-versa.
         *
         * @param x The known X value of the target point
         * @param y The known Y value of the target point
         * @returns A new point with the other calculated axis value
         */
        Line.prototype.findPoint = function (x, y) {
            if (x === void 0) { x = null; }
            if (y === void 0) { y = null; }
            var m = this.slope;
            var b = this.intercept;
            if (x !== null) {
                return new Vector(x, (m * x) + b);
            }
            else if (y !== null) {
                return new Vector((y - b) / m, y);
            }
            else {
                throw new Error('You must provide an X or a Y value');
            }
        };
        /**
         * @see http://stackoverflow.com/a/11908158/109458
         */
        Line.prototype.hasPoint = function () {
            var currPoint;
            var threshold = 0;
            if (typeof arguments[0] === 'number' &&
                typeof arguments[1] === 'number') {
                currPoint = new Vector(arguments[0], arguments[1]);
                threshold = arguments[2] || 0;
            }
            else if (arguments[0] instanceof Vector) {
                currPoint = arguments[0];
                threshold = arguments[1] || 0;
            }
            else {
                throw 'Could not determine the arguments for Vector.hasPoint';
            }
            var dxc = currPoint.x - this.begin.x;
            var dyc = currPoint.y - this.begin.y;
            var dx1 = this.end.x - this.begin.x;
            var dy1 = this.end.y - this.begin.y;
            var cross = dxc * dy1 - dyc * dx1;
            // check whether point lines on the line
            if (Math.abs(cross) > threshold) {
                return false;
            }
            // check whether point lies in-between start and end
            if (Math.abs(dx1) >= Math.abs(dy1)) {
                return dx1 > 0
                    ? this.begin.x <= currPoint.x && currPoint.x <= this.end.x
                    : this.end.x <= currPoint.x && currPoint.x <= this.begin.x;
            }
            else {
                return dy1 > 0
                    ? this.begin.y <= currPoint.y && currPoint.y <= this.end.y
                    : this.end.y <= currPoint.y && currPoint.y <= this.begin.y;
            }
        };
        return Line;
    }());
    exports.Line = Line;
    /**
     * A 1 dimensional projection on an axis, used to test overlaps
     */
    var Projection = (function () {
        function Projection(min, max) {
            this.min = min;
            this.max = max;
        }
        Projection.prototype.overlaps = function (projection) {
            return this.max > projection.min && projection.max > this.min;
        };
        Projection.prototype.getOverlap = function (projection) {
            if (this.overlaps(projection)) {
                if (this.max > projection.max) {
                    return projection.max - this.min;
                }
                else {
                    return this.max - projection.min;
                }
            }
            return 0;
        };
        return Projection;
    }());
    exports.Projection = Projection;
});
define("Physics", ["require", "exports", "Algebra"], function (require, exports, Algebra_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Possible collision resolution strategies
     *
     * The default is [[CollisionResolutionStrategy.Box]] which performs simple axis aligned arcade style physics.
     *
     * More advanced rigid body physics are enabled by setting [[CollisionResolutionStrategy.RigidBody]] which allows for complicated
     * simulated physical interactions.
     */
    var CollisionResolutionStrategy;
    (function (CollisionResolutionStrategy) {
        CollisionResolutionStrategy[CollisionResolutionStrategy["Box"] = 0] = "Box";
        CollisionResolutionStrategy[CollisionResolutionStrategy["RigidBody"] = 1] = "RigidBody";
    })(CollisionResolutionStrategy = exports.CollisionResolutionStrategy || (exports.CollisionResolutionStrategy = {}));
    /**
     * Possible broadphase collision pair identification strategies
     *
     * The default strategy is [[BroadphaseStrategy.DynamicAABBTree]] which uses a binary tree of axis-aligned bounding boxes to identify
     * potential collision pairs which is O(nlog(n)) faster. The other possible strategy is the [[BroadphaseStrategy.Naive]] strategy
     * which loops over every object for every object in the scene to identify collision pairs which is O(n^2) slower.
     */
    var BroadphaseStrategy;
    (function (BroadphaseStrategy) {
        BroadphaseStrategy[BroadphaseStrategy["Naive"] = 0] = "Naive";
        BroadphaseStrategy[BroadphaseStrategy["DynamicAABBTree"] = 1] = "DynamicAABBTree";
    })(BroadphaseStrategy = exports.BroadphaseStrategy || (exports.BroadphaseStrategy = {}));
    /**
     * Possible numerical integrators for position and velocity
     */
    var Integrator;
    (function (Integrator) {
        Integrator[Integrator["Euler"] = 0] = "Euler";
    })(Integrator = exports.Integrator || (exports.Integrator = {}));
    /**
     * The [[Physics]] object is the global configuration object for all Excalibur physics.
     *
     * [[include:Physics.md]]
     */
    /* istanbul ignore next */
    var Physics = (function () {
        function Physics() {
        }
        /**
         * Configures Excalibur to use box physics. Box physics which performs simple axis aligned arcade style physics.
         */
        Physics.useBoxPhysics = function () {
            Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Box;
        };
        /**
         * Configures Excalibur to use rigid body physics. Rigid body physics allows for complicated
         * simulated physical interactions.
         */
        Physics.useRigidBodyPhysics = function () {
            Physics.collisionResolutionStrategy = CollisionResolutionStrategy.RigidBody;
        };
        return Physics;
    }());
    /**
     * Global acceleration that is applied to all vanilla actors (it wont effect [[Label|labels]], [[UIActor|ui actors]], or
     * [[Trigger|triggers]] in Excalibur that have an [[CollisionType.Active|active]] collision type).
     *
     *
     * This is a great way to globally simulate effects like gravity.
     */
    Physics.acc = new Algebra_1.Vector(0, 0);
    /**
     * Globally switches all Excalibur physics behavior on or off.
     */
    Physics.enabled = true;
    /**
     * Gets or sets the number of collision passes for Excalibur to perform on physics bodies.
     *
     * Reducing collision passes may cause things not to collide as expected in your game, but may increase performance.
     *
     * More passes can improve the visual quality of collisions when many objects are on the screen. This can reduce jitter, improve the
     * collision resolution of fast move objects, or the stability of large numbers of objects stacked together.
     *
     * Fewer passes will improve the performance of the game at the cost of collision quality, more passes will improve quality at the
     * cost of performance.
     *
     * The default is set to 5 passes which is a good start.
     */
    Physics.collisionPasses = 5;
    /**
     * Gets or sets the broadphase pair identification strategy.
     *
     * The default strategy is [[BroadphaseStrategy.DynamicAABBTree]] which uses a binary tree of axis-aligned bounding boxes to identify
     * potential collision pairs which is O(nlog(n)) faster. The other possible strategy is the [[BroadphaseStrategy.Naive]] strategy
     * which loops over every object for every object in the scene to identify collision pairs which is O(n^2) slower.
     */
    Physics.broadphaseStrategy = BroadphaseStrategy.DynamicAABBTree;
    /**
     * Globally switches the debug information for the broadphase strategy
     */
    Physics.broadphaseDebug = false;
    /**
     * Show the normals as a result of collision on the screen.
     */
    Physics.showCollisionNormals = false;
    /**
     * Show the position, velocity, and acceleration as graphical vectors.
     */
    Physics.showMotionVectors = false;
    /**
     * Show the axis-aligned bounding boxes of the collision bodies on the screen.
     */
    Physics.showBounds = false;
    /**
     * Show the bounding collision area shapes
     */
    Physics.showArea = false;
    /**
     * Show points of collision interpreted by excalibur as a result of collision.
     */
    Physics.showContacts = false;
    /**
     * Show the surface normals of the collision areas.
     */
    Physics.showNormals = false;
    /**
     * Gets or sets the global collision resolution strategy (narrowphase).
     *
     * The default is [[CollisionResolutionStrategy.Box]] which performs simple axis aligned arcade style physics.
     *
     * More advanced rigid body physics are enabled by setting [[CollisionResolutionStrategy.RigidBody]] which allows for complicated
     * simulated physical interactions.
     */
    Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Box;
    /**
     * The default mass to use if none is specified
     */
    Physics.defaultMass = 10;
    /**
     * Gets or sets the position and velocity positional integrator, currently only Euler is supported.
     */
    Physics.integrator = Integrator.Euler;
    /**
     * Number of steps to use in integration. A higher number improves the positional accuracy over time. This can be useful to increase
     * if you have fast moving objects in your simulation or you have a large number of objects and need to increase stability.
     */
    Physics.integrationSteps = 1;
    /**
     * Gets or sets whether rotation is allowed in a RigidBody collision resolution
     */
    Physics.allowRigidBodyRotation = true;
    /**
     * Small value to help collision passes settle themselves after the narrowphase.
     */
    Physics.collisionShift = .001;
    /**
     * Factor to add to the RigidBody BoundingBox, bounding box (dimensions += vel * dynamicTreeVelocityMultiplyer);
     */
    Physics.dynamicTreeVelocityMultiplyer = 2;
    /**
     * Pad RigidBody BoundingBox by a constant amount
     */
    Physics.boundsPadding = 5;
    /**
     * Surface epsilon is used to help deal with surface penatration
     */
    Physics.surfaceEpsilon = .1;
    /**
     * Enable fast moving body checking, this enables checking for collision pairs via raycast for fast moving objects to prevent
     * bodies from tunneling through one another.
     */
    Physics.checkForFastBodies = true;
    /**
     * Disable minimum fast moving body raycast, by default if ex.Physics.checkForFastBodies = true Excalibur will only check if the
     * body is moving at least half of its minimum diminension in an update. If ex.Physics.disableMinimumSpeedForFastBody is set to true,
     * Excalibur will always perform the fast body raycast regardless of speed.
     */
    Physics.disableMinimumSpeedForFastBody = false;
    exports.Physics = Physics;
});
define("Util/EasingFunctions", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Standard easing functions for motion in Excalibur, defined on a domain of [0, duration] and a range from [+startValue,+endValue]
     * Given a time, the function will return a value from positive startValue to positive endValue.
     *
     * ```js
     * function Linear (t) {
     *    return t * t;
     * }
     *
     * // accelerating from zero velocity
     * function EaseInQuad (t) {
     *    return t * t;
     * }
     *
     * // decelerating to zero velocity
     * function EaseOutQuad (t) {
     *    return t * (2 - t);
     * }
     *
     * // acceleration until halfway, then deceleration
     * function EaseInOutQuad (t) {
     *    return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
     * }
     *
     * // accelerating from zero velocity
     * function EaseInCubic (t) {
     *    return t * t * t;
     * }
     *
     * // decelerating to zero velocity
     * function EaseOutCubic (t) {
     *    return (--t) * t * t + 1;
     * }
     *
     * // acceleration until halfway, then deceleration
     * function EaseInOutCubic (t) {
     *    return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
     * }
     * ```
     */
    var EasingFunctions = (function () {
        function EasingFunctions() {
        }
        return EasingFunctions;
    }());
    EasingFunctions.Linear = function (currentTime, startValue, endValue, duration) {
        endValue = (endValue - startValue);
        return endValue * currentTime / duration + startValue;
    };
    EasingFunctions.EaseInQuad = function (currentTime, startValue, endValue, duration) {
        endValue = (endValue - startValue);
        currentTime /= duration;
        return endValue * currentTime * currentTime + startValue;
    };
    EasingFunctions.EaseOutQuad = function (currentTime, startValue, endValue, duration) {
        endValue = (endValue - startValue);
        currentTime /= duration;
        return -endValue * currentTime * (currentTime - 2) + startValue;
    };
    EasingFunctions.EaseInOutQuad = function (currentTime, startValue, endValue, duration) {
        endValue = (endValue - startValue);
        currentTime /= duration / 2;
        if (currentTime < 1) {
            return endValue / 2 * currentTime * currentTime + startValue;
        }
        currentTime--;
        return -endValue / 2 * (currentTime * (currentTime - 2) - 1) + startValue;
    };
    EasingFunctions.EaseInCubic = function (currentTime, startValue, endValue, duration) {
        endValue = (endValue - startValue);
        currentTime /= duration;
        return endValue * currentTime * currentTime * currentTime + startValue;
    };
    EasingFunctions.EaseOutCubic = function (currentTime, startValue, endValue, duration) {
        endValue = (endValue - startValue);
        currentTime /= duration;
        currentTime--;
        return endValue * (currentTime * currentTime * currentTime + 1) + startValue;
    };
    EasingFunctions.EaseInOutCubic = function (currentTime, startValue, endValue, duration) {
        endValue = (endValue - startValue);
        currentTime /= duration / 2;
        if (currentTime < 1) {
            return endValue / 2 * currentTime * currentTime * currentTime + startValue;
        }
        currentTime -= 2;
        return endValue / 2 * (currentTime * currentTime * currentTime + 2) + startValue;
    };
    exports.EasingFunctions = EasingFunctions;
});
// Promises/A+ Spec http://promises-aplus.github.io/promises-spec/
define("Promises", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Valid states for a promise to be in
     */
    var PromiseState;
    (function (PromiseState) {
        PromiseState[PromiseState["Resolved"] = 0] = "Resolved";
        PromiseState[PromiseState["Rejected"] = 1] = "Rejected";
        PromiseState[PromiseState["Pending"] = 2] = "Pending";
    })(PromiseState = exports.PromiseState || (exports.PromiseState = {}));
    /**
     * Promises are used to do asynchronous work and they are useful for
     * creating a chain of actions. In Excalibur they are used for loading,
     * sounds, animation, actions, and more.
     *
     * [[include:Promises.md]]
     */
    var Promise = (function () {
        function Promise() {
            this._state = PromiseState.Pending;
            this._successCallbacks = [];
            this._rejectCallback = function () { return; };
        }
        /**
         * Create and resolve a Promise with an optional value
         * @param value  An optional value to wrap in a resolved promise
         */
        Promise.resolve = function (value) {
            var promise = (new Promise()).resolve(value);
            return promise;
        };
        /**
         * Create and reject a Promise with an optional value
         * @param value  An optional value to wrap in a rejected promise
         */
        Promise.reject = function (value) {
            var promise = (new Promise()).reject(value);
            return promise;
        };
        Promise.join = function () {
            var promises = [];
            if (arguments.length > 0 && !Array.isArray(arguments[0])) {
                for (var _i = 0; _i < arguments.length; _i++) {
                    promises[_i - 0] = arguments[_i];
                }
            }
            else if (arguments.length === 1 && Array.isArray(arguments[0])) {
                promises = arguments[0];
            }
            var joinedPromise = new Promise();
            if (!promises || !promises.length) {
                return joinedPromise.resolve();
            }
            var total = promises.length;
            var successes = 0;
            var rejects = 0;
            var errors = [];
            promises.forEach(function (p) {
                p.then(function () {
                    successes += 1;
                    if (successes === total) {
                        joinedPromise.resolve();
                    }
                    else if (successes + rejects + errors.length === total) {
                        joinedPromise.reject(errors);
                    }
                }, function () {
                    rejects += 1;
                    if (successes + rejects + errors.length === total) {
                        joinedPromise.reject(errors);
                    }
                }).error(function (e) {
                    errors.push(e);
                    if ((errors.length + successes + rejects) === total) {
                        joinedPromise.reject(errors);
                    }
                });
            });
            return joinedPromise;
        };
        /**
         * Chain success and reject callbacks after the promise is resolved
         * @param successCallback  Call on resolution of promise
         * @param rejectCallback   Call on rejection of promise
         */
        Promise.prototype.then = function (successCallback, rejectCallback) {
            if (successCallback) {
                this._successCallbacks.push(successCallback);
                // If the promise is already resovled call immediately
                if (this.state() === PromiseState.Resolved) {
                    try {
                        successCallback.call(this, this._value);
                    }
                    catch (e) {
                        this._handleError(e);
                    }
                }
            }
            if (rejectCallback) {
                this._rejectCallback = rejectCallback;
                // If the promise is already rejected call immediately
                if (this.state() === PromiseState.Rejected) {
                    try {
                        rejectCallback.call(this, this._value);
                    }
                    catch (e) {
                        this._handleError(e);
                    }
                }
            }
            return this;
        };
        /**
         * Add an error callback to the promise
         * @param errorCallback  Call if there was an error in a callback
         */
        Promise.prototype.error = function (errorCallback) {
            if (errorCallback) {
                this._errorCallback = errorCallback;
            }
            return this;
        };
        /**
         * Resolve the promise and pass an option value to the success callbacks
         * @param value  Value to pass to the success callbacks
         */
        Promise.prototype.resolve = function (value) {
            var _this = this;
            if (this._state === PromiseState.Pending) {
                this._value = value;
                try {
                    this._state = PromiseState.Resolved;
                    this._successCallbacks.forEach(function (cb) {
                        cb.call(_this, _this._value);
                    });
                }
                catch (e) {
                    this._handleError(e);
                }
            }
            else {
                throw new Error('Cannot resolve a promise that is not in a pending state!');
            }
            return this;
        };
        /**
         * Reject the promise and pass an option value to the reject callbacks
         * @param value  Value to pass to the reject callbacks
         */
        Promise.prototype.reject = function (value) {
            if (this._state === PromiseState.Pending) {
                this._value = value;
                try {
                    this._state = PromiseState.Rejected;
                    this._rejectCallback.call(this, this._value);
                }
                catch (e) {
                    this._handleError(e);
                }
            }
            else {
                throw new Error('Cannot reject a promise that is not in a pending state!');
            }
            return this;
        };
        /**
         * Inspect the current state of a promise
         */
        Promise.prototype.state = function () {
            return this._state;
        };
        Promise.prototype._handleError = function (e) {
            if (this._errorCallback) {
                this._errorCallback.call(this, e);
            }
            else {
                // rethrow error
                throw e;
            }
        };
        return Promise;
    }());
    exports.Promise = Promise;
});
/**
 * Pseudo-Random Utility
 *
 * A pseudo-random utility to add seeded random support for help in
 * generating things like terrain or reproducible randomness. Uses the
 * [Mersenne Twister](https://en.wikipedia.org/wiki/Mersenne_Twister) algorithm.
 *
 * [[include:Random.md]]
 */
define("Math/Random", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * 32-bit mask
     */
    var BITMASK32 = 0xFFFFFFFF;
    /**
     * Pseudo-random number generator following the Mersenne_Twister algorithm. Given a seed this generator will produce the same sequence
     * of numbers each time it is called.
     * See https://en.wikipedia.org/wiki/Mersenne_Twister for more details.
     * Uses the MT19937-32 (2002) implementation documented here http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html
     *
     * Api inspired by http://chancejs.com/# https://github.com/chancejs/chancejs
     */
    var Random = (function () {
        /**
         * If no seed is specified, the Date.now() is used
         */
        function Random(seed) {
            this.seed = seed;
            // Separation point of one one word, the number of bits in the lower bitmask 0 <= r <= w-1
            this._lowerMask = 0x7FFFFFFF; // 31 bits same as _r
            this._upperMask = 0x80000000; // 34 high bits
            // Word size, 64 bits
            this._w = 32;
            // Degree of recurrance
            this._n = 624;
            // Middle word, an offset used in the recurrance defining the series x, 1<=m<n
            this._m = 397;
            // coefficients of teh rational normal form twist matrix
            this._a = 0x9908B0DF;
            // tempering bit shifts and masks
            this._u = 11;
            this._s = 7;
            this._b = 0x9d2c5680;
            this._t = 15;
            this._c = 0xefc60000;
            this._l = 18;
            this._f = 1812433253;
            this._mt = new Array(this._n);
            // need to mask to support higher bit machines
            this._mt[0] = (seed || Date.now()) >>> 0;
            for (var i = 1; i < this._n; i++) {
                var s = this._mt[i - 1] ^ (this._mt[i - 1] >>> (this._w - 2));
                // numbers are bigger than the JS max safe int, add in 16-bit chunks to prevent IEEE rounding errors on high bits         
                this._mt[i] = (((this._f * ((s & 0xFFFF0000) >>> 16)) << 16) + (this._f * (s & 0xFFFF)) + i) >>> 0;
            }
            this._index = this._n;
        }
        /**
         * Apply the twist
         */
        Random.prototype._twist = function () {
            var mag01 = [0x0, this._a];
            var y = 0;
            for (var i = 0; i < this._n - this._m; i++) {
                y = (this._mt[i] & this._upperMask) | (this._mt[i + 1] & this._lowerMask);
                this._mt[i] = this._mt[i + this._m] ^ (y >>> 1) ^ mag01[y & 0x1] & BITMASK32;
            }
            for (; i < this._n - 1; i++) {
                y = (this._mt[i] & this._upperMask) | (this._mt[i + 1] & this._lowerMask);
                this._mt[i] = this._mt[i + (this._m - this._n)] ^ (y >>> 1) ^ mag01[y & 0x1] & BITMASK32;
            }
            y = (this._mt[this._n - 1] & this._upperMask) | (this._mt[0] & this._lowerMask);
            this._mt[this._n - 1] = this._mt[this._m - 1] ^ (y >>> 1) ^ mag01[y & 0x1] & BITMASK32;
            this._index = 0;
        };
        /**
         * Return next 32 bit integer number in sequence
         */
        Random.prototype.nextInt = function () {
            if (this._index >= this._n) {
                this._twist();
            }
            var y = this._mt[this._index++];
            y ^= y >>> this._u;
            y ^= ((y << this._s) & this._b);
            y ^= ((y << this._t) & this._c);
            y ^= (y >>> this._l);
            return y >>> 0;
        };
        /**
         * Return a random floating point number between [0, 1)
         */
        Random.prototype.next = function () {
            return this.nextInt() * (1.0 / 4294967296.0); // divided by 2^32
        };
        /**
         * Return a random floating point in range [min, max) min is included, max is not included
         */
        Random.prototype.floating = function (min, max) {
            return (max - min) * this.next() + min;
        };
        /**
         * Return a random integer in range [min, max] min is included, max is included.
         * Implemented with rejection sampling, see https://medium.com/@betable/tifu-by-using-math-random-f1c308c4fd9d#.i13tdiu5a
         */
        Random.prototype.integer = function (min, max) {
            return Math.floor((max - min + 1) * this.next() + min);
        };
        /**
         * Returns true or false randomly with 50/50 odds by default.
         * By default the likelihood of returning a true is .5 (50%).
         * @param likelihood takes values between [0, 1]
         */
        Random.prototype.bool = function (likelihood) {
            if (likelihood === void 0) { likelihood = .5; }
            return this.next() <= likelihood;
        };
        /**
         * Returns one element from an array at random
         */
        Random.prototype.pickOne = function (array) {
            return array[this.integer(0, array.length - 1)];
        };
        /**
         * Returns a new array random picking elements from the original
         * @param array Original array to pick from
         * @param numPicks can be any positive number
         * @param allowDuplicates indicates whether the returned set is allowed duplicates (it does not mean there will always be duplicates
         * just that it is possible)
         */
        Random.prototype.pickSet = function (array, numPicks, allowDuplicates) {
            if (allowDuplicates === void 0) { allowDuplicates = false; }
            if (allowDuplicates) {
                return this._pickSetWithDuplicates(array, numPicks);
            }
            else {
                return this._pickSetWithoutDuplicates(array, numPicks);
            }
        };
        /**
         * Returns a new array randomly picking elements in the original (not reused)
         * @param numPicks must be less than or equal to the number of elements in the array.
         */
        Random.prototype._pickSetWithoutDuplicates = function (array, numPicks) {
            if (numPicks > array.length || numPicks < 0) {
                throw new Error('Invalid number of elements to pick, must pick a value 0 < n <= length');
            }
            if (numPicks === array.length) {
                return array;
            }
            var result = new Array(numPicks);
            var currentPick = 0;
            var tempArray = array.slice(0);
            while (currentPick < numPicks) {
                var index = this.integer(0, tempArray.length - 1);
                result[currentPick++] = tempArray[index];
                tempArray.splice(index, 1);
            }
            return result;
        };
        /**
         * Returns a new array random picking elements from the original allowing duplicates
         * @param numPicks can be any positive number
         */
        Random.prototype._pickSetWithDuplicates = function (array, numPicks) {
            // Typescript numbers are all floating point, so do we add check for int? (or floor the input?)
            if (numPicks < 0) {
                throw new Error('Invalid number of elements to pick, must pick a value 0 <= n < MAX_INT');
            }
            var result = new Array(numPicks);
            for (var i = 0; i < numPicks; i++) {
                result.push(this.pickOne(array));
            }
            return result;
        };
        /**
         * Returns a new array that has its elements shuffled. Using the Fisher/Yates method
         * https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
         */
        Random.prototype.shuffle = function (array) {
            var tempArray = array.slice(0);
            var swap = null;
            for (var i = 0; i < tempArray.length - 2; i++) {
                var randomIndex = this.integer(i, tempArray.length - 1);
                swap = tempArray[i];
                tempArray[i] = tempArray[randomIndex];
                tempArray[randomIndex] = swap;
            }
            return tempArray;
        };
        /**
         * Generate a list of random integer numbers
         * @param length the length of the final array
         * @param min the minimum integer number to generate inclusive
         * @param max the maximum integer number to generate inclusive
         */
        Random.prototype.range = function (length, min, max) {
            var result = new Array(length);
            for (var i = 0; i < length; i++) {
                result[i] = this.integer(min, max);
            }
            return result;
        };
        /**
         * Returns the result of a d4 dice roll
         */
        Random.prototype.d4 = function () {
            return this.integer(1, 4);
        };
        /**
         * Returns the result of a d6 dice roll
         */
        Random.prototype.d6 = function () {
            return this.integer(1, 6);
        };
        /**
         * Returns the result of a d8 dice roll
         */
        Random.prototype.d8 = function () {
            return this.integer(1, 8);
        };
        /**
         * Returns the result of a d10 dice roll
         */
        Random.prototype.d10 = function () {
            return this.integer(1, 10);
        };
        /**
         * Returns the result of a d12 dice roll
         */
        Random.prototype.d12 = function () {
            return this.integer(1, 12);
        };
        /**
         * Returns the result of a d20 dice roll
         */
        Random.prototype.d20 = function () {
            return this.integer(1, 20);
        };
        return Random;
    }());
    exports.Random = Random;
});
define("Collision/Side", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * An enum that describes the sides of an Actor for collision
     */
    var Side;
    (function (Side) {
        Side[Side["None"] = 0] = "None";
        Side[Side["Top"] = 1] = "Top";
        Side[Side["Bottom"] = 2] = "Bottom";
        Side[Side["Left"] = 3] = "Left";
        Side[Side["Right"] = 4] = "Right";
    })(Side = exports.Side || (exports.Side = {}));
});
define("Util/Util", ["require", "exports", "Algebra", "Math/Random", "Collision/Side"], function (require, exports, Algebra_2, Random_1, Side_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Two PI constant
     */
    exports.TwoPI = Math.PI * 2;
    /**
     * Merges one or more objects into a single target object
     *
     * @returns Merged object with properties from other objects
     * @credit https://gomakethings.com/vanilla-javascript-version-of-jquery-extend/
     */
    function extend() {
        var extended = {};
        var deep = false;
        var i = 0;
        var length = arguments.length;
        // Check if a deep merge
        if (Object.prototype.toString.call(arguments[0]) === '[object Boolean]') {
            deep = arguments[0];
            i++;
        }
        // Merge the object into the extended object
        var assignExists = typeof Object.assign === 'function';
        var merge = null;
        if (!assignExists) {
            merge = function (obj) {
                for (var prop in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, prop)) {
                        // If deep merge and property is an object, merge properties
                        if (deep && Object.prototype.toString.call(obj[prop]) === '[object Object]') {
                            extended[prop] = extend(true, extended[prop], obj[prop]);
                        }
                        else {
                            extended[prop] = obj[prop];
                        }
                    }
                }
            };
        }
        else {
            merge = Object.assign;
        }
        // Loop through each object and conduct a merge
        for (; i < length; i++) {
            var obj = arguments[i];
            if (!assignExists) {
                merge(obj);
            }
            else {
                merge(extended, obj);
            }
        }
        return extended;
    }
    exports.extend = extend;
    function base64Encode(inputStr) {
        var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
        var outputStr = '';
        var i = 0;
        while (i < inputStr.length) {
            //all three "& 0xff" added below are there to fix a known bug
            //with bytes returned by xhr.responseText
            var byte1 = inputStr.charCodeAt(i++) & 0xff;
            var byte2 = inputStr.charCodeAt(i++) & 0xff;
            var byte3 = inputStr.charCodeAt(i++) & 0xff;
            var enc1 = byte1 >> 2;
            var enc2 = ((byte1 & 3) << 4) | (byte2 >> 4);
            var enc3, enc4;
            if (isNaN(byte2)) {
                enc3 = enc4 = 64;
            }
            else {
                enc3 = ((byte2 & 15) << 2) | (byte3 >> 6);
                if (isNaN(byte3)) {
                    enc4 = 64;
                }
                else {
                    enc4 = byte3 & 63;
                }
            }
            outputStr += b64.charAt(enc1) + b64.charAt(enc2) + b64.charAt(enc3) + b64.charAt(enc4);
        }
        return outputStr;
    }
    exports.base64Encode = base64Encode;
    /**
     * Clamps a value between a min and max inclusive
     */
    function clamp(val, min, max) {
        return Math.min(Math.max(min, val), max);
    }
    exports.clamp = clamp;
    function randomInRange(min, max, random) {
        if (random === void 0) { random = new Random_1.Random(); }
        return random ? random.floating(min, max) : min + Math.random() * (max - min);
    }
    exports.randomInRange = randomInRange;
    function randomIntInRange(min, max, random) {
        if (random === void 0) { random = new Random_1.Random(); }
        return random ? random.integer(min, max) : Math.round(randomInRange(min, max));
    }
    exports.randomIntInRange = randomIntInRange;
    function canonicalizeAngle(angle) {
        var tmpAngle = angle;
        if (angle > exports.TwoPI) {
            while (tmpAngle > exports.TwoPI) {
                tmpAngle -= exports.TwoPI;
            }
        }
        if (angle < 0) {
            while (tmpAngle < 0) {
                tmpAngle += exports.TwoPI;
            }
        }
        return tmpAngle;
    }
    exports.canonicalizeAngle = canonicalizeAngle;
    function toDegrees(radians) {
        return 180 / Math.PI * radians;
    }
    exports.toDegrees = toDegrees;
    function toRadians(degrees) {
        return degrees / 180 * Math.PI;
    }
    exports.toRadians = toRadians;
    function getPosition(el) {
        var oLeft = 0, oTop = 0;
        var calcOffsetLeft = function (parent) {
            oLeft += parent.offsetLeft;
            if (parent.offsetParent) {
                calcOffsetLeft(parent.offsetParent);
            }
        };
        var calcOffsetTop = function (parent) {
            oTop += parent.offsetTop;
            if (parent.offsetParent) {
                calcOffsetTop(parent.offsetParent);
            }
        };
        calcOffsetLeft(el);
        calcOffsetTop(el);
        return new Algebra_2.Vector(oLeft, oTop);
    }
    exports.getPosition = getPosition;
    function addItemToArray(item, array) {
        if (array.indexOf(item) === -1) {
            array.push(item);
            return true;
        }
        return false;
    }
    exports.addItemToArray = addItemToArray;
    function removeItemFromArray(item, array) {
        var index = -1;
        if ((index = array.indexOf(item)) > -1) {
            array.splice(index, 1);
            return true;
        }
        return false;
    }
    exports.removeItemFromArray = removeItemFromArray;
    function contains(array, obj) {
        for (var i = 0; i < array.length; i++) {
            if (array[i] === obj) {
                return true;
            }
        }
        return false;
    }
    exports.contains = contains;
    function getOppositeSide(side) {
        if (side === Side_1.Side.Top) {
            return Side_1.Side.Bottom;
        }
        if (side === Side_1.Side.Bottom) {
            return Side_1.Side.Top;
        }
        if (side === Side_1.Side.Left) {
            return Side_1.Side.Right;
        }
        if (side === Side_1.Side.Right) {
            return Side_1.Side.Left;
        }
        return Side_1.Side.None;
    }
    exports.getOppositeSide = getOppositeSide;
    function getSideFromVector(direction) {
        var directions = [Algebra_2.Vector.Left, Algebra_2.Vector.Right, Algebra_2.Vector.Up, Algebra_2.Vector.Down];
        var directionEnum = [Side_1.Side.Left, Side_1.Side.Right, Side_1.Side.Top, Side_1.Side.Bottom];
        var max = -Number.MAX_VALUE;
        var maxIndex = -1;
        for (var i = 0; i < directions.length; i++) {
            if (directions[i].dot(direction) > max) {
                max = directions[i].dot(direction);
                maxIndex = i;
            }
        }
        return directionEnum[maxIndex];
    }
    exports.getSideFromVector = getSideFromVector;
    /**
     * Excalibur's dynamically resizing collection
     */
    var Collection = (function () {
        /**
         * @param initialSize  Initial size of the internal backing array
         */
        function Collection(initialSize) {
            if (initialSize === void 0) { initialSize = Collection.DefaultSize; }
            this._internalArray = null;
            this._endPointer = 0;
            this._internalArray = new Array(initialSize);
        }
        Collection.prototype._resize = function () {
            var newSize = this._internalArray.length * 2;
            var newArray = new Array(newSize);
            var count = this.count();
            for (var i = 0; i < count; i++) {
                newArray[i] = this._internalArray[i];
            }
            delete this._internalArray;
            this._internalArray = newArray;
        };
        /**
         * Push elements to the end of the collection
         */
        Collection.prototype.push = function (element) {
            if (this._endPointer === this._internalArray.length) {
                this._resize();
            }
            return this._internalArray[this._endPointer++] = element;
        };
        /**
         * Removes elements from the end of the collection
         */
        Collection.prototype.pop = function () {
            this._endPointer = this._endPointer - 1 < 0 ? 0 : this._endPointer - 1;
            return this._internalArray[this._endPointer];
        };
        /**
         * Returns the count of the collection
         */
        Collection.prototype.count = function () {
            return this._endPointer;
        };
        /**
         * Empties the collection
         */
        Collection.prototype.clear = function () {
            this._endPointer = 0;
        };
        /**
         * Returns the size of the internal backing array
         */
        Collection.prototype.internalSize = function () {
            return this._internalArray.length;
        };
        /**
         * Returns an element at a specific index
         * @param index  Index of element to retrieve
         */
        Collection.prototype.elementAt = function (index) {
            if (index >= this.count()) {
                //Logger.getInstance().error('Invalid parameter: ' + index);
                throw new Error('Invalid index ' + index);
            }
            return this._internalArray[index];
        };
        /**
         * Inserts an element at a specific index
         * @param index  Index to insert the element
         * @param value  Element to insert
         */
        Collection.prototype.insert = function (index, value) {
            if (index >= this.count()) {
                this._resize();
            }
            return this._internalArray[index] = value;
        };
        /**
         * Removes an element at a specific index
         * @param index  Index of element to remove
         */
        Collection.prototype.remove = function (index) {
            var count = this.count();
            if (count === 0) {
                //Logger.getInstance().error('Invalid parameter: ' + index);
                throw new Error('Invalid parameter ' + index);
            }
            // O(n) Shift
            var removed = this._internalArray[index];
            for (var i = index; i < count; i++) {
                this._internalArray[i] = this._internalArray[i + 1];
            }
            this._endPointer--;
            return removed;
        };
        /**
         * Removes an element by reference
         * @param element  Element to retrieve
         */
        Collection.prototype.removeElement = function (element) {
            var index = this._internalArray.indexOf(element);
            this.remove(index);
        };
        /**
         * Returns a array representing the collection
         */
        Collection.prototype.toArray = function () {
            return this._internalArray.slice(0, this._endPointer);
        };
        /**
         * Iterate over every element in the collection
         * @param func  Callback to call for each element passing a reference to the element and its index, returned values are ignored
         */
        Collection.prototype.forEach = function (func) {
            var i = 0, count = this.count();
            for (i; i < count; i++) {
                func.call(this, this._internalArray[i], i);
            }
        };
        /**
         * Mutate every element in the collection
         * @param func  Callback to call for each element passing a reference to the element and its index, any values returned mutate
         * the collection
         */
        Collection.prototype.map = function (func) {
            var count = this.count();
            for (var i = 0; i < count; i++) {
                this._internalArray[i] = func.call(this, this._internalArray[i], i);
            }
        };
        return Collection;
    }());
    /**
     * Default collection size
     */
    Collection.DefaultSize = 200;
    exports.Collection = Collection;
});
define("Camera", ["require", "exports", "Util/EasingFunctions", "Promises", "Algebra", "Util/Util"], function (require, exports, EasingFunctions_1, Promises_1, Algebra_3, Util_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Container to house convenience strategy methods
     * @internal
     */
    var StrategyContainer = (function () {
        function StrategyContainer(camera) {
            this.camera = camera;
        }
        /**
         * Creates and adds the [[LockCameraToActorStrategy]] on the current camera.
         * @param actor The actor to lock the camera to
         */
        StrategyContainer.prototype.lockToActor = function (actor) {
            this.camera.addStrategy(new LockCameraToActorStrategy(actor));
        };
        /**
         * Creates and adds the [[LockCameraToActorAxisStrategy]] on the current camera
         * @param actor The actor to lock the camera to
         * @param axis The axis to follow the actor on
         */
        StrategyContainer.prototype.lockToActorAxis = function (actor, axis) {
            this.camera.addStrategy(new LockCameraToActorAxisStrategy(actor, axis));
        };
        /**
         * Creates and adds the [[ElasticToActorStrategy]] on the current camera
         * If cameraElasticity < cameraFriction < 1.0, the behavior will be a dampened spring that will slowly end at the target without bouncing
         * If cameraFriction < cameraElasticity < 1.0, the behavior will be an oscillationg spring that will over
         * correct and bounce around the target
         *
         * @param target Target actor to elastically follow
         * @param cameraElasticity [0 - 1.0] The higher the elasticity the more force that will drive the camera towards the target
         * @param cameraFriction [0 - 1.0] The higher the friction the more that the camera will resist motion towards the target
         */
        StrategyContainer.prototype.elasticToActor = function (actor, cameraElasticity, cameraFriction) {
            this.camera.addStrategy(new ElasticToActorStrategy(actor, cameraElasticity, cameraFriction));
        };
        /**
         * Creates and adds the [[RadiusAroundActorStrategy]] on the current camera
         * @param target Target actor to follow when it is "radius" pixels away
         * @param radius Number of pixels away before the camera will follow
         */
        StrategyContainer.prototype.radiusAroundActor = function (actor, radius) {
            this.camera.addStrategy(new RadiusAroundActorStrategy(actor, radius));
        };
        return StrategyContainer;
    }());
    exports.StrategyContainer = StrategyContainer;
    /**
     * Camera axis enum
     */
    var Axis;
    (function (Axis) {
        Axis[Axis["X"] = 0] = "X";
        Axis[Axis["Y"] = 1] = "Y";
    })(Axis = exports.Axis || (exports.Axis = {}));
    /**
     * Lock a camera to the exact x/y postition of an actor.
     */
    var LockCameraToActorStrategy = (function () {
        function LockCameraToActorStrategy(target) {
            this.target = target;
            this.action = function (target, _cam, _eng, _delta) {
                var center = target.getCenter();
                return center;
            };
        }
        return LockCameraToActorStrategy;
    }());
    exports.LockCameraToActorStrategy = LockCameraToActorStrategy;
    /**
     * Lock a camera to a specific axis around an actor.
     */
    var LockCameraToActorAxisStrategy = (function () {
        function LockCameraToActorAxisStrategy(target, axis) {
            var _this = this;
            this.target = target;
            this.axis = axis;
            this.action = function (target, cam, _eng, _delta) {
                var center = target.getCenter();
                var currentFocus = cam.getFocus();
                if (_this.axis === Axis.X) {
                    return new Algebra_3.Vector(center.x, currentFocus.y);
                }
                else {
                    return new Algebra_3.Vector(currentFocus.x, center.y);
                }
            };
        }
        return LockCameraToActorAxisStrategy;
    }());
    exports.LockCameraToActorAxisStrategy = LockCameraToActorAxisStrategy;
    /**
     * Using [Hook's law](https://en.wikipedia.org/wiki/Hooke's_law), elastically move the camera towards the target actor.
     */
    var ElasticToActorStrategy = (function () {
        /**
         * If cameraElasticity < cameraFriction < 1.0, the behavior will be a dampened spring that will slowly end at the target without bouncing
         * If cameraFriction < cameraElasticity < 1.0, the behavior will be an oscillationg spring that will over
         * correct and bounce around the target
         *
         * @param target Target actor to elastically follow
         * @param cameraElasticity [0 - 1.0] The higher the elasticity the more force that will drive the camera towards the target
         * @param cameraFriction [0 - 1.0] The higher the friction the more that the camera will resist motion towards the target
         */
        function ElasticToActorStrategy(target, cameraElasticity, cameraFriction) {
            var _this = this;
            this.target = target;
            this.cameraElasticity = cameraElasticity;
            this.cameraFriction = cameraFriction;
            this.action = function (target, cam, _eng, _delta) {
                var position = target.getCenter();
                var focus = cam.getFocus();
                var cameraVel = new Algebra_3.Vector(cam.dx, cam.dy);
                // Calculate the strech vector, using the spring equation
                // F = kX
                // https://en.wikipedia.org/wiki/Hooke's_law
                // Apply to the current camera velocity
                var stretch = position.sub(focus).scale(_this.cameraElasticity); // stretch is X
                cameraVel = cameraVel.add(stretch);
                // Calculate the friction (-1 to apply a force in the opposition of motion)
                // Apply to the current camera velocity
                var friction = cameraVel.scale(-1).scale(_this.cameraFriction);
                cameraVel = cameraVel.add(friction);
                // Update position by velocity deltas
                focus = focus.add(cameraVel);
                return focus;
            };
        }
        return ElasticToActorStrategy;
    }());
    exports.ElasticToActorStrategy = ElasticToActorStrategy;
    var RadiusAroundActorStrategy = (function () {
        /**
         *
         * @param target Target actor to follow when it is "radius" pixels away
         * @param radius Number of pixels away before the camera will follow
         */
        function RadiusAroundActorStrategy(target, radius) {
            var _this = this;
            this.target = target;
            this.radius = radius;
            this.action = function (target, cam, _eng, _delta) {
                var position = target.getCenter();
                var focus = cam.getFocus();
                var direction = position.sub(focus);
                var distance = direction.magnitude();
                if (distance >= _this.radius) {
                    var offset = distance - _this.radius;
                    return focus.add(direction.normalize().scale(offset));
                }
                return focus;
            };
        }
        return RadiusAroundActorStrategy;
    }());
    exports.RadiusAroundActorStrategy = RadiusAroundActorStrategy;
    /**
     * Cameras
     *
     * [[BaseCamera]] is the base class for all Excalibur cameras. Cameras are used
     * to move around your game and set focus. They are used to determine
     * what is "off screen" and can be used to scale the game.
     *
     * [[include:Cameras.md]]
     */
    var BaseCamera = (function () {
        function BaseCamera() {
            this._cameraStrategies = [];
            this.strategy = new StrategyContainer(this);
            // camera physical quantities
            this.z = 1;
            this.dx = 0;
            this.dy = 0;
            this.dz = 0;
            this.ax = 0;
            this.ay = 0;
            this.az = 0;
            this.rotation = 0;
            this.rx = 0;
            this._x = 0;
            this._y = 0;
            this._cameraMoving = false;
            this._currentLerpTime = 0;
            this._lerpDuration = 1000; // 1 second   
            this._lerpStart = null;
            this._lerpEnd = null;
            //camera effects
            this._isShaking = false;
            this._shakeMagnitudeX = 0;
            this._shakeMagnitudeY = 0;
            this._shakeDuration = 0;
            this._elapsedShakeTime = 0;
            this._xShake = 0;
            this._yShake = 0;
            this._isZooming = false;
            this._maxZoomScale = 1;
            this._zoomIncrement = 0.01;
            this._easing = EasingFunctions_1.EasingFunctions.EaseInOutCubic;
        }
        Object.defineProperty(BaseCamera.prototype, "x", {
            /**
             * Get the camera's x position
             */
            get: function () {
                return this._x;
            },
            /**
             * Set the camera's x position (cannot be set when following an [[Actor]] or when moving)
             */
            set: function (value) {
                if (!this._follow && !this._cameraMoving) {
                    this._x = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseCamera.prototype, "y", {
            /**
             * Get the camera's y position
             */
            get: function () {
                return this._y;
            },
            /**
             * Set the camera's y position (cannot be set when following an [[Actor]] or when moving)
             */
            set: function (value) {
                if (!this._follow && !this._cameraMoving) {
                    this._y = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseCamera.prototype, "pos", {
            /**
             * Get the camera's position as a vector
             */
            get: function () {
                return new Algebra_3.Vector(this.x, this.y);
            },
            /**
             * Set the cameras position
             */
            set: function (value) {
                this.x = value.x;
                this.y = value.y;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseCamera.prototype, "vel", {
            /**
             * Get the camera's velocity as a vector
             */
            get: function () {
                return new Algebra_3.Vector(this.dx, this.dy);
            },
            /**
             * Set the camera's velocity
             */
            set: function (value) {
                this.dx = value.x;
                this.dy = value.y;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns the focal point of the camera, a new point giving the x and y position of the camera
         */
        BaseCamera.prototype.getFocus = function () {
            return new Algebra_3.Vector(this.x, this.y);
        };
        /**
         * This moves the camera focal point to the specified position using specified easing function. Cannot move when following an Actor.
         *
         * @param pos The target position to move to
         * @param duration The duration in milliseconds the move should last
         * @param [easingFn] An optional easing function ([[ex.EasingFunctions.EaseInOutCubic]] by default)
         * @returns A [[Promise]] that resolves when movement is finished, including if it's interrupted.
         *          The [[Promise]] value is the [[Vector]] of the target position. It will be rejected if a move cannot be made.
         */
        BaseCamera.prototype.move = function (pos, duration, easingFn) {
            if (easingFn === void 0) { easingFn = EasingFunctions_1.EasingFunctions.EaseInOutCubic; }
            if (typeof easingFn !== 'function') {
                throw 'Please specify an EasingFunction';
            }
            // cannot move when following an actor
            if (this._follow) {
                return new Promises_1.Promise().reject(pos);
            }
            // resolve existing promise, if any
            if (this._lerpPromise && this._lerpPromise.state() === Promises_1.PromiseState.Pending) {
                this._lerpPromise.resolve(pos);
            }
            this._lerpPromise = new Promises_1.Promise();
            this._lerpStart = this.getFocus().clone();
            this._lerpDuration = duration;
            this._lerpEnd = pos;
            this._currentLerpTime = 0;
            this._cameraMoving = true;
            this._easing = easingFn;
            return this._lerpPromise;
        };
        /**
         * Sets the camera to shake at the specified magnitudes for the specified duration
         * @param magnitudeX  The x magnitude of the shake
         * @param magnitudeY  The y magnitude of the shake
         * @param duration    The duration of the shake in milliseconds
         */
        BaseCamera.prototype.shake = function (magnitudeX, magnitudeY, duration) {
            this._isShaking = true;
            this._shakeMagnitudeX = magnitudeX;
            this._shakeMagnitudeY = magnitudeY;
            this._shakeDuration = duration;
        };
        /**
         * Zooms the camera in or out by the specified scale over the specified duration.
         * If no duration is specified, it take effect immediately.
         * @param scale    The scale of the zoom
         * @param duration The duration of the zoom in milliseconds
         */
        BaseCamera.prototype.zoom = function (scale, duration) {
            if (duration === void 0) { duration = 0; }
            this._zoomPromise = new Promises_1.Promise();
            if (duration) {
                this._isZooming = true;
                this._maxZoomScale = scale;
                this._zoomIncrement = (scale - this.z) / duration;
            }
            else {
                this._isZooming = false;
                this.z = scale;
                this._zoomPromise.resolve(true);
            }
            return this._zoomPromise;
        };
        /**
         * Gets the current zoom scale
         */
        BaseCamera.prototype.getZoom = function () {
            return this.z;
        };
        /**
         * Adds a new camera strategy to this camera
         * @param cameraStrategy Instance of an [[ICameraStrategy]]
         */
        BaseCamera.prototype.addStrategy = function (cameraStrategy) {
            this._cameraStrategies.push(cameraStrategy);
        };
        /**
         * Removes a camera strategy by reference
         * @param cameraStrategy Instance of an [[ICameraStrategy]]
         */
        BaseCamera.prototype.removeStrategy = function (cameraStrategy) {
            Util_1.removeItemFromArray(cameraStrategy, this._cameraStrategies);
        };
        /**
         * Clears all camera strategies from the camera
         */
        BaseCamera.prototype.clearAllStrategies = function () {
            this._cameraStrategies.length = 0;
        };
        BaseCamera.prototype.update = function (_engine, delta) {
            // Update placements based on linear algebra
            this._x += this.dx * delta / 1000;
            this._y += this.dy * delta / 1000;
            this.z += this.dz * delta / 1000;
            this.dx += this.ax * delta / 1000;
            this.dy += this.ay * delta / 1000;
            this.dz += this.az * delta / 1000;
            this.rotation += this.rx * delta / 1000;
            if (this._isZooming) {
                var newZoom = this.z + this._zoomIncrement * delta;
                this.z = newZoom;
                if (this._zoomIncrement > 0) {
                    if (newZoom >= this._maxZoomScale) {
                        this._isZooming = false;
                        this.z = this._maxZoomScale;
                        this._zoomPromise.resolve(true);
                    }
                }
                else {
                    if (newZoom <= this._maxZoomScale) {
                        this._isZooming = false;
                        this.z = this._maxZoomScale;
                        this._zoomPromise.resolve(true);
                    }
                }
            }
            if (this._cameraMoving) {
                if (this._currentLerpTime < this._lerpDuration) {
                    if (this._lerpEnd.x < this._lerpStart.x) {
                        this._x = this._lerpStart.x - (this._easing(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x);
                    }
                    else {
                        this._x = this._easing(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration);
                    }
                    if (this._lerpEnd.y < this._lerpStart.y) {
                        this._y = this._lerpStart.y - (this._easing(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y);
                    }
                    else {
                        this._y = this._easing(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);
                    }
                    this._currentLerpTime += delta;
                }
                else {
                    this._x = this._lerpEnd.x;
                    this._y = this._lerpEnd.y;
                    this._lerpPromise.resolve(this._lerpEnd);
                    this._lerpStart = null;
                    this._lerpEnd = null;
                    this._currentLerpTime = 0;
                    this._cameraMoving = false;
                }
            }
            if (this._isDoneShaking()) {
                this._isShaking = false;
                this._elapsedShakeTime = 0;
                this._shakeMagnitudeX = 0;
                this._shakeMagnitudeY = 0;
                this._shakeDuration = 0;
                this._xShake = 0;
                this._yShake = 0;
            }
            else {
                this._elapsedShakeTime += delta;
                this._xShake = (Math.random() * this._shakeMagnitudeX | 0) + 1;
                this._yShake = (Math.random() * this._shakeMagnitudeY | 0) + 1;
            }
            for (var _i = 0, _a = this._cameraStrategies; _i < _a.length; _i++) {
                var s = _a[_i];
                this.pos = s.action.call(s, s.target, this, _engine, delta);
            }
        };
        /**
         * Applies the relevant transformations to the game canvas to "move" or apply effects to the Camera
         * @param ctx    Canvas context to apply transformations
         * @param delta  The number of milliseconds since the last update
         */
        BaseCamera.prototype.draw = function (ctx) {
            var focus = this.getFocus();
            var canvasWidth = ctx.canvas.width;
            var canvasHeight = ctx.canvas.height;
            var pixelRatio = window.devicePixelRatio;
            var zoom = this.getZoom();
            var newCanvasWidth = (canvasWidth / zoom) / pixelRatio;
            var newCanvasHeight = (canvasHeight / zoom) / pixelRatio;
            ctx.scale(zoom, zoom);
            ctx.translate(-focus.x + newCanvasWidth / 2 + this._xShake, -focus.y + newCanvasHeight / 2 + this._yShake);
        };
        BaseCamera.prototype.debugDraw = function (ctx) {
            var focus = this.getFocus();
            ctx.fillStyle = 'red';
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(focus.x, focus.y, 15, 0, Math.PI * 2);
            ctx.closePath();
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(focus.x, focus.y, 5, 0, Math.PI * 2);
            ctx.closePath();
            ctx.stroke();
        };
        BaseCamera.prototype._isDoneShaking = function () {
            return !(this._isShaking) || (this._elapsedShakeTime >= this._shakeDuration);
        };
        return BaseCamera;
    }());
    exports.BaseCamera = BaseCamera;
});
define("Configurable", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function Configurable(base) {
        return (function (_super) {
            __extends(class_1, _super);
            function class_1() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var _this = _super.apply(this, args) || this;
                //get the number of arguments that aren't undefined. TS passes a value to all parameters
                //of whatever ctor is the implementation, so args.length doesn't work here.
                var size = args.filter(function (value) { return value !== undefined; }).length;
                if (size === 1 && args[0] && typeof args[0] === 'object' && !(args[0] instanceof Array)) {
                    _this.assign(args[0]);
                }
                return _this;
            }
            class_1.prototype.assign = function (props) {
                //set the value of every property that was passed in,
                //if the constructor previously set this value, it will be overridden here
                for (var k in props) {
                    if (typeof this[k] !== 'function') {
                        this[k] = props[k];
                    }
                }
            };
            return class_1;
        }(base));
    }
    exports.Configurable = Configurable;
});
define("DebugFlags", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Drawing/Color", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Provides standard colors (e.g. [[Color.Black]])
     * but you can also create custom colors using RGB, HSL, or Hex. Also provides
     * useful color operations like [[Color.lighten]], [[Color.darken]], and more.
     *
     * [[include:Colors.md]]
     */
    var Color = (function () {
        /**
         * Creates a new instance of Color from an r, g, b, a
         *
         * @param r  The red component of color (0-255)
         * @param g  The green component of color (0-255)
         * @param b  The blue component of color (0-255)
         * @param a  The alpha component of color (0-1.0)
         */
        function Color(r, g, b, a) {
            this.r = r;
            this.g = g;
            this.b = b;
            this.a = (a != null ? a : 1);
        }
        /**
         * Creates a new instance of Color from an r, g, b, a
         *
         * @param r  The red component of color (0-255)
         * @param g  The green component of color (0-255)
         * @param b  The blue component of color (0-255)
         * @param a  The alpha component of color (0-1.0)
         */
        Color.fromRGB = function (r, g, b, a) {
            return new Color(r, g, b, a);
        };
        /**
         * Creates a new inscance of Color from a hex string
         *
         * @param hex  CSS color string of the form #ffffff, the alpha component is optional
         */
        Color.fromHex = function (hex) {
            var hexRegEx = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i;
            var match = null;
            if (match = hex.match(hexRegEx)) {
                var r = parseInt(match[1], 16);
                var g = parseInt(match[2], 16);
                var b = parseInt(match[3], 16);
                var a = 1;
                if (match[4]) {
                    a = parseInt(match[4], 16) / 255;
                }
                return new Color(r, g, b, a);
            }
            else {
                throw new Error('Invalid hex string: ' + hex);
            }
        };
        /**
         * Creats a new instance of Color from hsla values
         *
         * @param h  Hue is represented [0-1]
         * @param s  Saturation is represented [0-1]
         * @param l  Luminance is represented [0-1]
         * @param a  Alpha is represented [0-1]
         */
        Color.fromHSL = function (h, s, l, a) {
            if (a === void 0) { a = 1.0; }
            var temp = new HSLColor(h, s, l, a);
            return temp.toRGBA();
        };
        /**
         * Lightens the current color by a specified amount
         *
         * @param factor  The amount to lighten by [0-1]
         */
        Color.prototype.lighten = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            var temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
            temp.l += (temp.l * factor);
            return temp.toRGBA();
        };
        /**
         * Darkens the current color by a specified amount
         *
         * @param factor  The amount to darken by [0-1]
         */
        Color.prototype.darken = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            var temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
            temp.l -= (temp.l * factor);
            return temp.toRGBA();
        };
        /**
         * Saturates the current color by a specified amount
         *
         * @param factor  The amount to saturate by [0-1]
         */
        Color.prototype.saturate = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            var temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
            temp.s += (temp.s * factor);
            return temp.toRGBA();
        };
        /**
         * Desaturates the current color by a specified amount
         *
         * @param factor  The amount to desaturate by [0-1]
         */
        Color.prototype.desaturate = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            var temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
            temp.s -= (temp.s * factor);
            return temp.toRGBA();
        };
        /**
         * Multiplies a color by another, results in a darker color
         *
         * @param color  The other color
         */
        Color.prototype.mulitiply = function (color) {
            var newR = ((color.r / 255 * this.r / 255) * 255);
            var newG = ((color.g / 255 * this.g / 255) * 255);
            var newB = ((color.b / 255 * this.b / 255) * 255);
            var newA = (color.a * this.a);
            return new Color(newR, newG, newB, newA);
        };
        /**
         * Screens a color by another, results in a lighter color
         *
         * @param color  The other color
         */
        Color.prototype.screen = function (color) {
            var color1 = color.invert();
            var color2 = color.invert();
            return color1.mulitiply(color2).invert();
        };
        /**
         * Inverts the current color
         */
        Color.prototype.invert = function () {
            return new Color(255 - this.r, 255 - this.g, 255 - this.b, 1.0 - this.a);
        };
        /**
         * Averages the current color with another
         *
         * @param color  The other color
         */
        Color.prototype.average = function (color) {
            var newR = (color.r + this.r) / 2;
            var newG = (color.g + this.g) / 2;
            var newB = (color.b + this.b) / 2;
            var newA = (color.a + this.a) / 2;
            return new Color(newR, newG, newB, newA);
        };
        /**
         * Returns a CSS string representation of a color.
         *
         * @param format Color representation, accepts: rgb, hsl, or hex
         */
        Color.prototype.toString = function (format) {
            if (format === void 0) { format = 'rgb'; }
            switch (format) {
                case 'rgb':
                    return this.toRGBA();
                case 'hsl':
                    return this.toHSLA();
                case 'hex':
                    return this.toHex();
                default:
                    throw new Error('Invalid Color format');
            }
        };
        /**
         * Returns Hex Value of a color component
         * @param c color component
         * @see https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
         */
        Color.prototype._componentToHex = function (c) {
            var hex = c.toString(16);
            return hex.length === 1 ? '0' + hex : hex;
        };
        /**
         * Return Hex representation of a color.
         */
        Color.prototype.toHex = function () {
            return '#' + this._componentToHex(this.r) + this._componentToHex(this.g) + this._componentToHex(this.b);
        };
        /**
         * Return RGBA representation of a color.
         */
        Color.prototype.toRGBA = function () {
            var result = String(this.r.toFixed(0)) + ', ' + String(this.g.toFixed(0)) + ', ' + String(this.b.toFixed(0));
            if (this.a !== undefined || this.a !== null) {
                return 'rgba(' + result + ', ' + String(this.a) + ')';
            }
            return 'rgb(' + result + ')';
        };
        /**
         * Return HSLA representation of a color.
         */
        Color.prototype.toHSLA = function () {
            return HSLColor.fromRGBA(this.r, this.g, this.b, this.a).toString();
        };
        /**
         * Returns a CSS string representation of a color.
         */
        Color.prototype.fillStyle = function () {
            return this.toString();
        };
        /**
         * Returns a clone of the current color.
         */
        Color.prototype.clone = function () {
            return new Color(this.r, this.g, this.b, this.a);
        };
        return Color;
    }());
    /**
     * Black (#000000)
     */
    Color.Black = Color.fromHex('#000000');
    /**
     * White (#FFFFFF)
     */
    Color.White = Color.fromHex('#FFFFFF');
    /**
     * Gray (#808080)
     */
    Color.Gray = Color.fromHex('#808080');
    /**
     * Light gray (#D3D3D3)
     */
    Color.LightGray = Color.fromHex('#D3D3D3');
    /**
     * Dark gray (#A9A9A9)
     */
    Color.DarkGray = Color.fromHex('#A9A9A9');
    /**
     * Yellow (#FFFF00)
     */
    Color.Yellow = Color.fromHex('#FFFF00');
    /**
     * Orange (#FFA500)
     */
    Color.Orange = Color.fromHex('#FFA500');
    /**
     * Red (#FF0000)
     */
    Color.Red = Color.fromHex('#FF0000');
    /**
     * Vermillion (#FF5B31)
     */
    Color.Vermillion = Color.fromHex('#FF5B31');
    /**
     * Rose (#FF007F)
     */
    Color.Rose = Color.fromHex('#FF007F');
    /**
     * Magenta (#FF00FF)
     */
    Color.Magenta = Color.fromHex('#FF00FF');
    /**
     * Violet (#7F00FF)
     */
    Color.Violet = Color.fromHex('#7F00FF');
    /**
     * Blue (#0000FF)
     */
    Color.Blue = Color.fromHex('#0000FF');
    /**
     * Azure (#007FFF)
     */
    Color.Azure = Color.fromHex('#007FFF');
    /**
     * Cyan (#00FFFF)
     */
    Color.Cyan = Color.fromHex('#00FFFF');
    /**
     * Viridian (#59978F)
     */
    Color.Viridian = Color.fromHex('#59978F');
    /**
     * Green (#00FF00)
     */
    Color.Green = Color.fromHex('#00FF00');
    /**
     * Chartreuse (#7FFF00)
     */
    Color.Chartreuse = Color.fromHex('#7FFF00');
    /**
     * Transparent (#FFFFFF00)
     */
    Color.Transparent = Color.fromHex('#FFFFFF00');
    exports.Color = Color;
    /**
     * Internal HSL Color representation
     *
     * http://en.wikipedia.org/wiki/HSL_and_HSV
     * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
     */
    var HSLColor = (function () {
        function HSLColor(h, s, l, a) {
            this.h = h;
            this.s = s;
            this.l = l;
            this.a = a;
        }
        HSLColor.hue2rgb = function (p, q, t) {
            if (t < 0) {
                t += 1;
            }
            if (t > 1) {
                t -= 1;
            }
            if (t < 1 / 6) {
                return p + (q - p) * 6 * t;
            }
            if (t < 1 / 2) {
                return q;
            }
            if (t < 2 / 3) {
                return p + (q - p) * (2 / 3 - t) * 6;
            }
            return p;
        };
        HSLColor.fromRGBA = function (r, g, b, a) {
            r /= 255;
            g /= 255;
            b /= 255;
            var max = Math.max(r, g, b), min = Math.min(r, g, b);
            var h, s, l = (max + min) / 2;
            if (max === min) {
                h = s = 0; // achromatic
            }
            else {
                var d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r:
                        h = (g - b) / d + (g < b ? 6 : 0);
                        break;
                    case g:
                        h = (b - r) / d + 2;
                        break;
                    case b:
                        h = (r - g) / d + 4;
                        break;
                }
                h /= 6;
            }
            return new HSLColor(h, s, l, a);
        };
        HSLColor.prototype.toRGBA = function () {
            var r, g, b;
            if (this.s === 0) {
                r = g = b = this.l; // achromatic
            }
            else {
                var q = this.l < 0.5 ? this.l * (1 + this.s) : this.l + this.s - this.l * this.s;
                var p = 2 * this.l - q;
                r = HSLColor.hue2rgb(p, q, this.h + 1 / 3);
                g = HSLColor.hue2rgb(p, q, this.h);
                b = HSLColor.hue2rgb(p, q, this.h - 1 / 3);
            }
            return new Color(r * 255, g * 255, b * 255, this.a);
        };
        HSLColor.prototype.toString = function () {
            var h = this.h.toFixed(0), s = this.s.toFixed(0), l = this.l.toFixed(0), a = this.a.toFixed(0);
            return "hsla(" + h + ", " + s + ", " + l + ", " + a + ")";
        };
        return HSLColor;
    }());
});
define("Collision/CollisionContact", ["require", "exports", "Actor", "Algebra", "Physics", "Events", "Util/Util"], function (require, exports, Actor_1, Algebra_4, Physics_1, Events_1, Util) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Collision contacts are used internally by Excalibur to resolve collision between actors. This
     * Pair prevents collisions from being evaluated more than one time
     */
    var CollisionContact = (function () {
        function CollisionContact(bodyA, bodyB, mtv, point, normal) {
            this.bodyA = bodyA;
            this.bodyB = bodyB;
            this.mtv = mtv;
            this.point = point;
            this.normal = normal;
        }
        CollisionContact.prototype.resolve = function (strategy) {
            if (strategy === Physics_1.CollisionResolutionStrategy.RigidBody) {
                this._resolveRigidBodyCollision();
            }
            else if (strategy === Physics_1.CollisionResolutionStrategy.Box) {
                this._resolveBoxCollision();
            }
            else {
                throw new Error('Unknown collision resolution strategy');
            }
        };
        CollisionContact.prototype._applyBoxImpulse = function (bodyA, bodyB, mtv) {
            if (bodyA.collisionType === Actor_1.CollisionType.Active &&
                bodyB.collisionType !== Actor_1.CollisionType.Passive) {
                // Resolve overlaps
                if (bodyA.collisionType === Actor_1.CollisionType.Active &&
                    bodyB.collisionType === Actor_1.CollisionType.Active) {
                    // split overlaps if both are Active
                    mtv = mtv.scale(.5);
                }
                // Apply mtv
                bodyA.pos.y += mtv.y;
                bodyA.pos.x += mtv.x;
                // non-zero intersection on the y axis
                if (this.mtv.x !== 0) {
                    var velX = 0;
                    // both bodies are traveling in the same direction (negative or positive)
                    if (bodyA.vel.x < 0 && bodyB.vel.x < 0) {
                        velX = Math.min(bodyA.vel.x, bodyB.vel.x);
                    }
                    else if (bodyA.vel.x > 0 && bodyB.vel.x > 0) {
                        velX = Math.max(bodyA.vel.x, bodyB.vel.x);
                    }
                    else if (bodyB.collisionType === Actor_1.CollisionType.Fixed) {
                        // bodies are traveling in opposite directions
                        if (bodyA.pos.sub(bodyB.pos).dot(bodyA.vel) > 0) {
                            velX = bodyA.vel.x;
                        }
                        else {
                            // bodyA is heading towards b
                            velX = bodyB.vel.x;
                        }
                    }
                    bodyA.vel.x = velX;
                }
                if (this.mtv.y !== 0) {
                    var velY = 0;
                    // both bodies are traveling in the same direction (negative or positive)
                    if (bodyA.vel.y < 0 && bodyB.vel.y < 0) {
                        velY = Math.min(bodyA.vel.y, bodyB.vel.y);
                    }
                    else if (bodyA.vel.y > 0 && bodyB.vel.y > 0) {
                        velY = Math.max(bodyA.vel.y, bodyB.vel.y);
                    }
                    else if (bodyB.collisionType === Actor_1.CollisionType.Fixed) {
                        // bodies are traveling in opposite directions
                        if (bodyA.pos.sub(bodyB.pos).dot(bodyA.vel) > 0) {
                            velY = bodyA.vel.y;
                        }
                        else {
                            // bodyA is heading towards b
                            velY = bodyB.vel.y;
                        }
                    }
                    bodyA.vel.y = velY;
                }
                bodyA.emit('postcollision', new Events_1.PostCollisionEvent(bodyA, bodyB, Util.getSideFromVector(mtv), mtv));
            }
        };
        CollisionContact.prototype._resolveBoxCollision = function () {
            var bodyA = this.bodyA.body.actor;
            var bodyB = this.bodyB.body.actor;
            var side = Util.getSideFromVector(this.mtv);
            var mtv = this.mtv.negate();
            // Publish collision events on both participants
            bodyA.emit('precollision', new Events_1.PreCollisionEvent(bodyA, bodyB, side, mtv));
            bodyB.emit('precollision', new Events_1.PreCollisionEvent(bodyB, bodyA, Util.getOppositeSide(side), mtv.negate()));
            this._applyBoxImpulse(bodyA, bodyB, mtv);
            this._applyBoxImpulse(bodyB, bodyA, mtv.negate());
        };
        CollisionContact.prototype._resolveRigidBodyCollision = function () {
            // perform collison on bounding areas
            var bodyA = this.bodyA.body;
            var bodyB = this.bodyB.body;
            var mtv = this.mtv; // normal pointing away from bodyA
            var normal = this.normal; // normal pointing away from bodyA
            if (bodyA.actor === bodyB.actor) {
                return;
            }
            // Publish collision events on both participants
            var side = Util.getSideFromVector(this.mtv);
            bodyA.actor.emit('precollision', new Events_1.PreCollisionEvent(this.bodyA.body.actor, this.bodyB.body.actor, side, this.mtv));
            bodyB.actor.emit('precollision', new Events_1.PreCollisionEvent(this.bodyB.body.actor, this.bodyA.body.actor, Util.getOppositeSide(side), this.mtv.negate()));
            // If any of the participants are passive then short circuit
            if (bodyA.actor.collisionType === Actor_1.CollisionType.Passive ||
                bodyB.actor.collisionType === Actor_1.CollisionType.Passive) {
                return;
            }
            var invMassA = bodyA.actor.collisionType === Actor_1.CollisionType.Fixed ? 0 : 1 / bodyA.mass;
            var invMassB = bodyB.actor.collisionType === Actor_1.CollisionType.Fixed ? 0 : 1 / bodyB.mass;
            var invMoiA = bodyA.actor.collisionType === Actor_1.CollisionType.Fixed ? 0 : 1 / bodyA.moi;
            var invMoiB = bodyB.actor.collisionType === Actor_1.CollisionType.Fixed ? 0 : 1 / bodyB.moi;
            // average restitution more relistic
            var coefRestitution = Math.min(bodyA.restitution, bodyB.restitution);
            var coefFriction = Math.min(bodyA.friction, bodyB.friction);
            normal = normal.normalize();
            var tangent = normal.normal().normalize();
            var ra = this.point.sub(this.bodyA.getCenter()); // point relative to bodyA position
            var rb = this.point.sub(this.bodyB.getCenter()); /// point relative to bodyB
            // Relative velocity in linear terms
            // Angular to linear velocity formula -> omega = v/r
            var rv = bodyB.vel.add(rb.cross(-bodyB.rx)).sub(bodyA.vel.sub(ra.cross(bodyA.rx)));
            var rvNormal = rv.dot(normal);
            var rvTangent = rv.dot(tangent);
            var raTangent = ra.dot(tangent);
            var raNormal = ra.dot(normal);
            var rbTangent = rb.dot(tangent);
            var rbNormal = rb.dot(normal);
            // If objects are moving away ignore
            if (rvNormal > 0) {
                return;
            }
            // Collision impulse formula from Chris Hecker
            // https://en.wikipedia.org/wiki/Collision_response
            var impulse = -((1 + coefRestitution) * rvNormal) /
                ((invMassA + invMassB) + invMoiA * raTangent * raTangent + invMoiB * rbTangent * rbTangent);
            if (bodyA.actor.collisionType === Actor_1.CollisionType.Fixed) {
                bodyB.vel = bodyB.vel.add(normal.scale(impulse * invMassB));
                if (Physics_1.Physics.allowRigidBodyRotation) {
                    bodyB.rx -= impulse * invMoiB * -rb.cross(normal);
                }
                bodyB.addMtv(mtv);
            }
            else if (bodyB.actor.collisionType === Actor_1.CollisionType.Fixed) {
                bodyA.vel = bodyA.vel.sub(normal.scale(impulse * invMassA));
                if (Physics_1.Physics.allowRigidBodyRotation) {
                    bodyA.rx += impulse * invMoiA * -ra.cross(normal);
                }
                bodyA.addMtv(mtv.negate());
            }
            else {
                bodyB.vel = bodyB.vel.add(normal.scale(impulse * invMassB));
                bodyA.vel = bodyA.vel.sub(normal.scale(impulse * invMassA));
                if (Physics_1.Physics.allowRigidBodyRotation) {
                    bodyB.rx -= impulse * invMoiB * -rb.cross(normal);
                    bodyA.rx += impulse * invMoiA * -ra.cross(normal);
                }
                // Split the mtv in half for the two bodies, potentially we could do something smarter here
                bodyB.addMtv(mtv.scale(.5));
                bodyA.addMtv(mtv.scale(-.5));
            }
            // Friction portion of impulse
            if (coefFriction && rvTangent) {
                // Columb model of friction, formula for impulse due to friction from  
                // https://en.wikipedia.org/wiki/Collision_response
                // tangent force exerted by body on another in contact
                var t = rv.sub(normal.scale(rv.dot(normal))).normalize();
                // impulse in the direction of tangent force
                var jt = rv.dot(t) / (invMassA + invMassB + raNormal * raNormal * invMoiA + rbNormal * rbNormal * invMoiB);
                var frictionImpulse = new Algebra_4.Vector(0, 0);
                if (Math.abs(jt) <= impulse * coefFriction) {
                    frictionImpulse = t.scale(jt).negate();
                }
                else {
                    frictionImpulse = t.scale(-impulse * coefFriction);
                }
                if (bodyA.actor.collisionType === Actor_1.CollisionType.Fixed) {
                    // apply frictional impulse
                    bodyB.vel = bodyB.vel.add(frictionImpulse.scale(invMassB));
                    if (Physics_1.Physics.allowRigidBodyRotation) {
                        bodyB.rx += frictionImpulse.dot(t) * invMoiB * rb.cross(t);
                    }
                }
                else if (bodyB.actor.collisionType === Actor_1.CollisionType.Fixed) {
                    // apply frictional impulse
                    bodyA.vel = bodyA.vel.sub(frictionImpulse.scale(invMassA));
                    if (Physics_1.Physics.allowRigidBodyRotation) {
                        bodyA.rx -= frictionImpulse.dot(t) * invMoiA * ra.cross(t);
                    }
                }
                else {
                    // apply frictional impulse
                    bodyB.vel = bodyB.vel.add(frictionImpulse.scale(invMassB));
                    bodyA.vel = bodyA.vel.sub(frictionImpulse.scale(invMassA));
                    // apply frictional impulse
                    if (Physics_1.Physics.allowRigidBodyRotation) {
                        bodyB.rx += frictionImpulse.dot(t) * invMoiB * rb.cross(t);
                        bodyA.rx -= frictionImpulse.dot(t) * invMoiA * ra.cross(t);
                    }
                }
            }
            bodyA.actor.emit('postcollision', new Events_1.PostCollisionEvent(this.bodyA.body.actor, this.bodyB.body.actor, side, this.mtv));
            bodyB.actor.emit('postcollision', new Events_1.PostCollisionEvent(this.bodyB.body.actor, this.bodyA.body.actor, Util.getOppositeSide(side), this.mtv.negate()));
        };
        return CollisionContact;
    }());
    exports.CollisionContact = CollisionContact;
});
define("Collision/ICollisionArea", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Collision/CircleArea", ["require", "exports", "Collision/BoundingBox", "Collision/PolygonArea", "Collision/EdgeArea", "Collision/CollisionJumpTable", "Algebra", "Physics", "Drawing/Color"], function (require, exports, BoundingBox_1, PolygonArea_1, EdgeArea_1, CollisionJumpTable_1, Algebra_5, Physics_2, Color_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * This is a circle collision area for the excalibur rigid body physics simulation
     */
    var CircleArea = (function () {
        function CircleArea(options) {
            /**
             * This is the center position of the circle, relative to the body position
             */
            this.pos = Algebra_5.Vector.Zero.clone();
            this.pos = options.pos || Algebra_5.Vector.Zero.clone();
            this.radius = options.radius || 0;
            this.body = options.body || null;
        }
        /**
         * Get the center of the collision area in world coordinates
         */
        CircleArea.prototype.getCenter = function () {
            if (this.body) {
                return this.pos.add(this.body.pos);
            }
            return this.pos;
        };
        /**
         * Tests if a point is contained in this collision area
         */
        CircleArea.prototype.contains = function (point) {
            var distance = this.body.pos.distance(point);
            if (distance <= this.radius) {
                return true;
            }
            return false;
        };
        /**
         * Casts a ray at the CircleArea and returns the nearest point of collision
         * @param ray
         */
        CircleArea.prototype.rayCast = function (ray, max) {
            if (max === void 0) { max = Infinity; }
            //https://en.wikipedia.org/wiki/Line%E2%80%93sphere_intersection
            var c = this.getCenter();
            var dir = ray.dir;
            var orig = ray.pos;
            var discriminant = Math.sqrt(Math.pow(dir.dot(orig.sub(c)), 2) -
                Math.pow(orig.sub(c).distance(), 2) +
                Math.pow(this.radius, 2));
            if (discriminant < 0) {
                // no intersection
                return null;
            }
            else {
                var toi = 0;
                if (discriminant === 0) {
                    toi = -dir.dot(orig.sub(c));
                    if (toi > 0 && toi < max) {
                        return ray.getPoint(toi);
                    }
                    return null;
                }
                else {
                    var toi1 = -dir.dot(orig.sub(c)) + discriminant;
                    var toi2 = -dir.dot(orig.sub(c)) - discriminant;
                    var mintoi = Math.min(toi1, toi2);
                    if (mintoi <= max) {
                        return ray.getPoint(mintoi);
                    }
                    return null;
                }
            }
        };
        /**
         * @inheritdoc
         */
        CircleArea.prototype.collide = function (area) {
            if (area instanceof CircleArea) {
                return CollisionJumpTable_1.CollisionJumpTable.CollideCircleCircle(this, area);
            }
            else if (area instanceof PolygonArea_1.PolygonArea) {
                return CollisionJumpTable_1.CollisionJumpTable.CollideCirclePolygon(this, area);
            }
            else if (area instanceof EdgeArea_1.EdgeArea) {
                return CollisionJumpTable_1.CollisionJumpTable.CollideCircleEdge(this, area);
            }
            else {
                throw new Error("Circle could not collide with unknown ICollisionArea " + typeof area);
            }
        };
        /**
         * Find the point on the shape furthest in the direction specified
         */
        CircleArea.prototype.getFurthestPoint = function (direction) {
            return this.getCenter().add(direction.normalize().scale(this.radius));
        };
        /**
         * Get the axis aligned bounding box for the circle area
         */
        CircleArea.prototype.getBounds = function () {
            return new BoundingBox_1.BoundingBox(this.pos.x + this.body.pos.x - this.radius, this.pos.y + this.body.pos.y - this.radius, this.pos.x + this.body.pos.x + this.radius, this.pos.y + this.body.pos.y + this.radius);
        };
        /**
         * Get axis not implemented on circles, since there are infinite axis in a circle
         */
        CircleArea.prototype.getAxes = function () {
            return null;
        };
        /**
         * Returns the moment of inertia of a circle given it's mass
         * https://en.wikipedia.org/wiki/List_of_moments_of_inertia
         */
        CircleArea.prototype.getMomentOfInertia = function () {
            var mass = this.body ? this.body.mass : Physics_2.Physics.defaultMass;
            return (mass * this.radius * this.radius) / 2;
        };
        /**
         * Tests the separating axis theorem for circles against polygons
         */
        CircleArea.prototype.testSeparatingAxisTheorem = function (polygon) {
            var axes = polygon.getAxes();
            var pc = polygon.getCenter();
            // Special SAT with circles
            var closestPointOnPoly = polygon.getFurthestPoint(this.pos.sub(pc));
            axes.push(this.pos.sub(closestPointOnPoly).normalize());
            var minOverlap = Number.MAX_VALUE;
            var minAxis = null;
            var minIndex = -1;
            for (var i = 0; i < axes.length; i++) {
                var proj1 = polygon.project(axes[i]);
                var proj2 = this.project(axes[i]);
                var overlap = proj1.getOverlap(proj2);
                if (overlap <= 0) {
                    return null;
                }
                else {
                    if (overlap < minOverlap) {
                        minOverlap = overlap;
                        minAxis = axes[i];
                        minIndex = i;
                    }
                }
            }
            if (minIndex < 0) {
                return null;
            }
            return minAxis.normalize().scale(minOverlap);
        };
        /* istanbul ignore next */
        CircleArea.prototype.recalc = function () {
            // circles don't cache
        };
        /**
         * Project the circle along a specified axis
         */
        CircleArea.prototype.project = function (axis) {
            var scalars = [];
            var point = this.getCenter();
            var dotProduct = point.dot(axis);
            scalars.push(dotProduct);
            scalars.push(dotProduct + this.radius);
            scalars.push(dotProduct - this.radius);
            return new Algebra_5.Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));
        };
        /* istanbul ignore next */
        CircleArea.prototype.debugDraw = function (ctx, color) {
            if (color === void 0) { color = Color_1.Color.Green.clone(); }
            var pos = this.body ? this.body.pos.add(this.pos) : this.pos;
            var rotation = this.body ? this.body.rotation : 0;
            ctx.beginPath();
            ctx.strokeStyle = color.toString();
            ctx.arc(pos.x, pos.y, this.radius, 0, Math.PI * 2);
            ctx.closePath();
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(pos.x, pos.y);
            ctx.lineTo(Math.cos(rotation) * this.radius + pos.x, Math.sin(rotation) * this.radius + pos.y);
            ctx.closePath();
            ctx.stroke();
        };
        return CircleArea;
    }());
    exports.CircleArea = CircleArea;
});
define("Collision/CollisionJumpTable", ["require", "exports", "Collision/CollisionContact", "Collision/PolygonArea"], function (require, exports, CollisionContact_1, PolygonArea_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CollisionJumpTable = {
        CollideCircleCircle: function (circleA, circleB) {
            var radius = circleA.radius + circleB.radius;
            var circleAPos = circleA.body.pos.add(circleA.pos);
            var circleBPos = circleB.body.pos.add(circleB.pos);
            if (circleAPos.distance(circleBPos) > radius) {
                return null;
            }
            var axisOfCollision = circleBPos.sub(circleAPos).normalize();
            var mvt = axisOfCollision.scale(radius - circleBPos.distance(circleAPos));
            var pointOfCollision = circleA.getFurthestPoint(axisOfCollision);
            return new CollisionContact_1.CollisionContact(circleA, circleB, mvt, pointOfCollision, axisOfCollision);
        },
        CollideCirclePolygon: function (circle, polygon) {
            var minAxis = circle.testSeparatingAxisTheorem(polygon);
            if (!minAxis) {
                return null;
            }
            // make sure that the minAxis is pointing away from circle
            var samedir = minAxis.dot(polygon.getCenter().sub(circle.getCenter()));
            minAxis = samedir < 0 ? minAxis.negate() : minAxis;
            var verts = [];
            var point1 = polygon.getFurthestPoint(minAxis.negate());
            var point2 = circle.getFurthestPoint(minAxis); //.add(cc);
            if (circle.contains(point1)) {
                verts.push(point1);
            }
            if (polygon.contains(point2)) {
                verts.push(point2);
            }
            if (verts.length === 0) {
                return null;
            }
            return new CollisionContact_1.CollisionContact(circle, polygon, minAxis, verts.length === 2 ? verts[0].average(verts[1]) : verts[0], minAxis.normalize());
        },
        CollideCircleEdge: function (circle, edge) {
            // center of the circle
            var cc = circle.getCenter();
            // vector in the direction of the edge
            var e = edge.end.sub(edge.begin);
            // amount of overlap with the circle's center along the edge direction
            var u = e.dot(edge.end.sub(cc));
            var v = e.dot(cc.sub(edge.begin));
            // Potential region A collision (circle is on the left side of the edge, before the beginning)
            if (v <= 0) {
                var da = edge.begin.sub(cc);
                var dda = da.dot(da); // quick and dirty way of calc'n distance in r^2 terms saves some sqrts
                // save some sqrts
                if (dda > circle.radius * circle.radius) {
                    return null; // no collision
                }
                return new CollisionContact_1.CollisionContact(circle, edge, da.normalize().scale(circle.radius - Math.sqrt(dda)), edge.begin, da.normalize());
            }
            // Potential region B collision (circle is on the right side of the edge, after the end)
            if (u <= 0) {
                var db = edge.end.sub(cc);
                var ddb = db.dot(db);
                if (ddb > circle.radius * circle.radius) {
                    return null;
                }
                return new CollisionContact_1.CollisionContact(circle, edge, db.normalize().scale(circle.radius - Math.sqrt(ddb)), edge.end, db.normalize());
            }
            // Otherwise potential region AB collision (circle is in the middle of the edge between the beginning and end)
            var den = e.dot(e);
            var pointOnEdge = (edge.begin.scale(u).add(edge.end.scale(v))).scale(1 / den);
            var d = cc.sub(pointOnEdge);
            var dd = d.dot(d);
            if (dd > circle.radius * circle.radius) {
                return null; // no collision
            }
            var n = e.perpendicular();
            // flip correct direction
            if (n.dot(cc.sub(edge.begin)) < 0) {
                n.x = -n.x;
                n.y = -n.y;
            }
            n = n.normalize();
            var mvt = n.scale(Math.abs(circle.radius - Math.sqrt(dd)));
            return new CollisionContact_1.CollisionContact(circle, edge, mvt.negate(), pointOnEdge, n.negate());
        },
        CollideEdgeEdge: function () {
            // Edge-edge collision doesn't make sense
            return null;
        },
        CollidePolygonEdge: function (polygon, edge) {
            // 3 cases:
            // (1) Polygon lands on the full face
            // (2) Polygon lands on the right point
            // (3) Polygon lands on the left point
            var e = edge.end.sub(edge.begin);
            var edgeNormal = e.normal();
            if (polygon.contains(edge.begin)) {
                var _a = polygon.getClosestFace(edge.begin), mtv = _a.distance, face = _a.face;
                if (mtv) {
                    return new CollisionContact_1.CollisionContact(polygon, edge, mtv.negate(), edge.begin.add(mtv.negate()), face.normal().negate());
                }
            }
            if (polygon.contains(edge.end)) {
                var _b = polygon.getClosestFace(edge.end), mtv = _b.distance, face = _b.face;
                if (mtv) {
                    return new CollisionContact_1.CollisionContact(polygon, edge, mtv.negate(), edge.end.add(mtv.negate()), face.normal().negate());
                }
            }
            var pc = polygon.getCenter();
            var ec = edge.getCenter();
            var dir = ec.sub(pc).normalize();
            // build a temporary polygon from the edge to use SAT
            var linePoly = new PolygonArea_2.PolygonArea({
                points: [
                    edge.begin,
                    edge.end,
                    edge.end.add(dir.scale(30)),
                    edge.begin.add(dir.scale(30))
                ]
            });
            var minAxis = polygon.testSeparatingAxisTheorem(linePoly);
            // no minAxis, no overlap, no collision
            if (!minAxis) {
                return null;
            }
            // flip the normal and axis to always have positive collisions
            edgeNormal = edgeNormal.dot(dir) < 0 ? edgeNormal.negate() : edgeNormal;
            minAxis = minAxis.dot(dir) < 0 ? minAxis.negate() : minAxis;
            return new CollisionContact_1.CollisionContact(polygon, edge, minAxis, polygon.getFurthestPoint(edgeNormal), edgeNormal);
        },
        CollidePolygonPolygon: function (polyA, polyB) {
            // do a SAT test to find a min axis if it exists
            var minAxis = polyA.testSeparatingAxisTheorem(polyB);
            // no overlap, no collision return null
            if (!minAxis) {
                return null;
            }
            // make sure that minAxis is pointing from A -> B
            var sameDir = minAxis.dot(polyB.getCenter().sub(polyA.getCenter()));
            minAxis = sameDir < 0 ? minAxis.negate() : minAxis;
            // find rough point of collision
            // todo this could be better
            var verts = [];
            var pointA = polyA.getFurthestPoint(minAxis);
            var pointB = polyB.getFurthestPoint(minAxis.negate());
            if (polyB.contains(pointA)) {
                verts.push(pointA);
            }
            if (polyA.contains(pointB)) {
                verts.push(pointB);
            }
            // no candidates, pick something
            if (verts.length === 0) {
                verts.push(pointB);
            }
            var contact = verts.length === 2 ? verts[0].add(verts[1]).scale(.5) : verts[0];
            return new CollisionContact_1.CollisionContact(polyA, polyB, minAxis, contact, minAxis.normalize());
        }
    };
});
define("Collision/PolygonArea", ["require", "exports", "Drawing/Color", "Physics", "Collision/BoundingBox", "Collision/EdgeArea", "Collision/CollisionJumpTable", "Collision/CircleArea", "Algebra"], function (require, exports, Color_2, Physics_3, BoundingBox_2, EdgeArea_2, CollisionJumpTable_2, CircleArea_1, Algebra_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Polygon collision area for detecting collisions for actors, or independently
     */
    var PolygonArea = (function () {
        function PolygonArea(options) {
            this._transformedPoints = [];
            this._axes = [];
            this._sides = [];
            this.pos = options.pos || Algebra_6.Vector.Zero.clone();
            var winding = !!options.clockwiseWinding;
            this.points = (winding ? options.points.reverse() : options.points) || [];
            this.body = options.body || null;
            // calculate initial transformation
            this._calculateTransformation();
        }
        /**
         * Get the center of the collision area in world coordinates
         */
        PolygonArea.prototype.getCenter = function () {
            if (this.body) {
                return this.body.pos.add(this.pos);
            }
            return this.pos;
        };
        /**
         * Calculates the underlying transformation from the body relative space to world space
         */
        PolygonArea.prototype._calculateTransformation = function () {
            var pos = this.body ? this.body.pos.add(this.pos) : this.pos;
            var angle = this.body ? this.body.rotation : 0;
            var len = this.points.length;
            this._transformedPoints.length = 0; // clear out old transform
            for (var i = 0; i < len; i++) {
                this._transformedPoints[i] = this.points[i].rotate(angle).add(pos);
            }
        };
        /**
         * Gets the points that make up the polygon in world space, from actor relative space (if specified)
         */
        PolygonArea.prototype.getTransformedPoints = function () {
            if (!this._transformedPoints.length) {
                this._calculateTransformation();
            }
            ;
            return this._transformedPoints;
        };
        /**
         * Gets the sides of the polygon in world space
         */
        PolygonArea.prototype.getSides = function () {
            if (this._sides.length) {
                return this._sides;
            }
            var lines = [];
            var points = this.getTransformedPoints();
            var len = points.length;
            for (var i = 0; i < len; i++) {
                lines.push(new Algebra_6.Line(points[i], points[(i - 1 + len) % len]));
            }
            this._sides = lines;
            return this._sides;
        };
        PolygonArea.prototype.recalc = function () {
            this._sides.length = 0;
            this._axes.length = 0;
            this._transformedPoints.length = 0;
            this.getTransformedPoints();
            this.getAxes();
            this.getSides();
        };
        /**
         * Tests if a point is contained in this collision area in world space
         */
        PolygonArea.prototype.contains = function (point) {
            // Always cast to the right, as long as we cast in a consitent fixed direction we
            // will be fine
            var testRay = new Algebra_6.Ray(point, new Algebra_6.Vector(1, 0));
            var intersectCount = this.getSides().reduce(function (accum, side) {
                if (testRay.intersect(side) >= 0) {
                    return accum + 1;
                }
                return accum;
            }, 0);
            if (intersectCount % 2 === 0) {
                return false;
            }
            return true;
        };
        /**
         * Returns a collision contact if the 2 collision areas collide, otherwise collide will
         * return null.
         * @param area
         */
        PolygonArea.prototype.collide = function (area) {
            if (area instanceof CircleArea_1.CircleArea) {
                return CollisionJumpTable_2.CollisionJumpTable.CollideCirclePolygon(area, this);
            }
            else if (area instanceof PolygonArea) {
                return CollisionJumpTable_2.CollisionJumpTable.CollidePolygonPolygon(this, area);
            }
            else if (area instanceof EdgeArea_2.EdgeArea) {
                return CollisionJumpTable_2.CollisionJumpTable.CollidePolygonEdge(this, area);
            }
            else {
                throw new Error("Polygon could not collide with unknown ICollisionArea " + typeof area);
            }
        };
        /**
         * Find the point on the shape furthest in the direction specified
         */
        PolygonArea.prototype.getFurthestPoint = function (direction) {
            var pts = this.getTransformedPoints();
            var furthestPoint = null;
            var maxDistance = -Number.MAX_VALUE;
            for (var i = 0; i < pts.length; i++) {
                var distance = direction.dot(pts[i]);
                if (distance > maxDistance) {
                    maxDistance = distance;
                    furthestPoint = pts[i];
                }
            }
            return furthestPoint;
        };
        /**
         * Finds the closes face to the point using perpendicular distance
         * @param point point to test against polygon
         */
        PolygonArea.prototype.getClosestFace = function (point) {
            var sides = this.getSides();
            var min = Number.POSITIVE_INFINITY;
            var faceIndex = -1;
            var distance = -1;
            for (var i = 0; i < sides.length; i++) {
                var dist = sides[i].distanceToPoint(point);
                if (dist < min) {
                    min = dist;
                    faceIndex = i;
                    distance = dist;
                }
            }
            if (faceIndex !== -1) {
                return {
                    distance: sides[faceIndex].normal().scale(distance),
                    face: sides[faceIndex]
                };
            }
            return null;
        };
        /**
         * Get the axis aligned bounding box for the polygon area
         */
        PolygonArea.prototype.getBounds = function () {
            // todo there is a faster way to do this
            var points = this.getTransformedPoints();
            var minX = points.reduce(function (prev, curr) {
                return Math.min(prev, curr.x);
            }, 999999999);
            var maxX = points.reduce(function (prev, curr) {
                return Math.max(prev, curr.x);
            }, -99999999);
            var minY = points.reduce(function (prev, curr) {
                return Math.min(prev, curr.y);
            }, 9999999999);
            var maxY = points.reduce(function (prev, curr) {
                return Math.max(prev, curr.y);
            }, -9999999999);
            return new BoundingBox_2.BoundingBox(minX, minY, maxX, maxY);
        };
        /**
         * Get the moment of inertia for an arbitrary polygon
         * https://en.wikipedia.org/wiki/List_of_moments_of_inertia
         */
        PolygonArea.prototype.getMomentOfInertia = function () {
            var mass = this.body ? this.body.mass : Physics_3.Physics.defaultMass;
            var numerator = 0;
            var denominator = 0;
            for (var i = 0; i < this.points.length; i++) {
                var iplusone = (i + 1) % this.points.length;
                var crossTerm = this.points[iplusone].cross(this.points[i]);
                numerator += crossTerm * (this.points[i].dot(this.points[i]) +
                    this.points[i].dot(this.points[iplusone]) +
                    this.points[iplusone].dot(this.points[iplusone]));
                denominator += crossTerm;
            }
            return (mass / 6) * (numerator / denominator);
        };
        /**
         * Casts a ray into the polygon and returns a vector representing the point of contact (in world space) or null if no collision.
         */
        PolygonArea.prototype.rayCast = function (ray, max) {
            if (max === void 0) { max = Infinity; }
            // find the minimum contact time greater than 0
            // contact times less than 0 are behind the ray and we don't want those
            var sides = this.getSides();
            var len = sides.length;
            var minContactTime = Number.MAX_VALUE;
            var contactIndex = -1;
            for (var i = 0; i < len; i++) {
                var contactTime = ray.intersect(sides[i]);
                if (contactTime >= 0 && contactTime < minContactTime && contactTime <= max) {
                    minContactTime = contactTime;
                    contactIndex = i;
                }
            }
            // contact was found
            if (contactIndex >= 0) {
                return ray.getPoint(minContactTime);
            }
            // no contact found
            return null;
        };
        /**
         * Get the axis associated with the edge
         */
        PolygonArea.prototype.getAxes = function () {
            if (this._axes.length) {
                return this._axes;
            }
            var axes = [];
            var points = this.getTransformedPoints();
            var len = points.length;
            for (var i = 0; i < len; i++) {
                axes.push(points[i].sub(points[(i + 1) % len]).normal());
            }
            this._axes = axes;
            return this._axes;
        };
        /**
         * Perform Separating Axis test against another polygon, returns null if no overlap in polys
         * Reference http://www.dyn4j.org/2010/01/sat/
         */
        PolygonArea.prototype.testSeparatingAxisTheorem = function (other) {
            var poly1 = this;
            var poly2 = other;
            var axes = poly1.getAxes().concat(poly2.getAxes());
            var minOverlap = Number.MAX_VALUE;
            var minAxis = null;
            var minIndex = -1;
            for (var i = 0; i < axes.length; i++) {
                var proj1 = poly1.project(axes[i]);
                var proj2 = poly2.project(axes[i]);
                var overlap = proj1.getOverlap(proj2);
                if (overlap <= 0) {
                    return null;
                }
                else {
                    if (overlap < minOverlap) {
                        minOverlap = overlap;
                        minAxis = axes[i];
                        minIndex = i;
                    }
                }
            }
            // Sanity check
            if (minIndex === -1) {
                return null;
            }
            return minAxis.normalize().scale(minOverlap);
        };
        /**
         * Project the edges of the polygon along a specified axis
         */
        PolygonArea.prototype.project = function (axis) {
            var points = this.getTransformedPoints();
            var len = points.length;
            var min = Number.MAX_VALUE;
            var max = -Number.MAX_VALUE;
            for (var i = 0; i < len; i++) {
                var scalar = points[i].dot(axis);
                min = Math.min(min, scalar);
                max = Math.max(max, scalar);
            }
            return new Algebra_6.Projection(min, max);
        };
        /* istanbul ignore next */
        PolygonArea.prototype.debugDraw = function (ctx, color) {
            if (color === void 0) { color = Color_2.Color.Red.clone(); }
            ctx.beginPath();
            ctx.strokeStyle = color.toString();
            // Iterate through the supplied points and construct a 'polygon'
            var firstPoint = this.getTransformedPoints()[0];
            ctx.moveTo(firstPoint.x, firstPoint.y);
            this.getTransformedPoints().forEach(function (point) {
                ctx.lineTo(point.x, point.y);
            });
            ctx.lineTo(firstPoint.x, firstPoint.y);
            ctx.closePath();
            ctx.stroke();
        };
        return PolygonArea;
    }());
    exports.PolygonArea = PolygonArea;
});
define("Collision/BoundingBox", ["require", "exports", "Collision/PolygonArea", "Algebra", "Drawing/Color"], function (require, exports, PolygonArea_3, Algebra_7, Color_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Axis Aligned collision primitive for Excalibur.
     */
    var BoundingBox = (function () {
        /**
         * @param left    x coordinate of the left edge
         * @param top     y coordinate of the top edge
         * @param right   x coordinate of the right edge
         * @param bottom  y coordinate of the bottom edge
         */
        function BoundingBox(left, top, right, bottom) {
            if (left === void 0) { left = 0; }
            if (top === void 0) { top = 0; }
            if (right === void 0) { right = 0; }
            if (bottom === void 0) { bottom = 0; }
            this.left = left;
            this.top = top;
            this.right = right;
            this.bottom = bottom;
        }
        BoundingBox.fromPoints = function (points) {
            var minX = Infinity;
            var minY = Infinity;
            var maxX = -Infinity;
            var maxY = -Infinity;
            for (var i = 0; i < points.length; i++) {
                if (points[i].x < minX) {
                    minX = points[i].x;
                }
                if (points[i].x > maxX) {
                    maxX = points[i].x;
                }
                if (points[i].y < minY) {
                    minY = points[i].y;
                }
                if (points[i].y > maxY) {
                    maxY = points[i].y;
                }
            }
            return new BoundingBox(minX, minY, maxX, maxY);
        };
        /**
         * Returns the calculated width of the bounding box
         */
        BoundingBox.prototype.getWidth = function () {
            return this.right - this.left;
        };
        /**
         * Returns the calculated height of the bounding box
         */
        BoundingBox.prototype.getHeight = function () {
            return this.bottom - this.top;
        };
        /**
         * Rotates a bounding box by and angle and around a point, if no point is specified (0, 0) is used by default
         */
        BoundingBox.prototype.rotate = function (angle, point) {
            if (point === void 0) { point = Algebra_7.Vector.Zero.clone(); }
            var points = this.getPoints().map(function (p) { return p.rotate(angle, point); });
            return BoundingBox.fromPoints(points);
        };
        /**
         * Returns the perimeter of the bounding box
         */
        BoundingBox.prototype.getPerimeter = function () {
            var wx = this.getWidth();
            var wy = this.getHeight();
            return 2 * (wx + wy);
        };
        BoundingBox.prototype.getPoints = function () {
            var results = [];
            results.push(new Algebra_7.Vector(this.left, this.top));
            results.push(new Algebra_7.Vector(this.right, this.top));
            results.push(new Algebra_7.Vector(this.right, this.bottom));
            results.push(new Algebra_7.Vector(this.left, this.bottom));
            return results;
        };
        /**
         * Creates a Polygon collision area from the points of the bounding box
         */
        BoundingBox.prototype.toPolygon = function (actor) {
            return new PolygonArea_3.PolygonArea({
                body: actor ? actor.body : null,
                points: this.getPoints(),
                pos: Algebra_7.Vector.Zero.clone()
            });
        };
        /**
         * Determines whether a ray intersects with a bounding box
         */
        BoundingBox.prototype.rayCast = function (ray, farClipDistance) {
            if (farClipDistance === void 0) { farClipDistance = Infinity; }
            // algorithm from https://tavianator.com/fast-branchless-raybounding-box-intersections/ 
            var tmin = -Infinity;
            var tmax = +Infinity;
            var xinv = ray.dir.x === 0 ? Number.MAX_VALUE : (1 / ray.dir.x);
            var yinv = ray.dir.y === 0 ? Number.MAX_VALUE : (1 / ray.dir.y);
            var tx1 = (this.left - ray.pos.x) * xinv;
            var tx2 = (this.right - ray.pos.x) * xinv;
            tmin = Math.min(tx1, tx2);
            tmax = Math.max(tx1, tx2);
            var ty1 = (this.top - ray.pos.y) * yinv;
            var ty2 = (this.bottom - ray.pos.y) * yinv;
            tmin = Math.max(tmin, Math.min(ty1, ty2));
            tmax = Math.min(tmax, Math.max(ty1, ty2));
            return tmax >= Math.max(0, tmin) && tmin < farClipDistance;
        };
        BoundingBox.prototype.rayCastTime = function (ray, farClipDistance) {
            if (farClipDistance === void 0) { farClipDistance = Infinity; }
            // algorithm from https://tavianator.com/fast-branchless-raybounding-box-intersections/ 
            var tmin = -Infinity;
            var tmax = +Infinity;
            var xinv = ray.dir.x === 0 ? Number.MAX_VALUE : (1 / ray.dir.x);
            var yinv = ray.dir.y === 0 ? Number.MAX_VALUE : (1 / ray.dir.y);
            var tx1 = (this.left - ray.pos.x) * xinv;
            var tx2 = (this.right - ray.pos.x) * xinv;
            tmin = Math.min(tx1, tx2);
            tmax = Math.max(tx1, tx2);
            var ty1 = (this.top - ray.pos.y) * yinv;
            var ty2 = (this.bottom - ray.pos.y) * yinv;
            tmin = Math.max(tmin, Math.min(ty1, ty2));
            tmax = Math.min(tmax, Math.max(ty1, ty2));
            if (tmax >= Math.max(0, tmin) && tmin < farClipDistance) {
                return tmin;
            }
            return -1;
        };
        BoundingBox.prototype.contains = function (val) {
            if (val instanceof Algebra_7.Vector) {
                return (this.left <= val.x && this.top <= val.y && this.bottom >= val.y && this.right >= val.x);
            }
            else if (val instanceof BoundingBox) {
                if (this.left < val.left &&
                    this.top < val.top &&
                    val.bottom < this.bottom &&
                    val.right < this.right) {
                    return true;
                }
                return false;
            }
            return false;
        };
        /**
         * Combines this bounding box and another together returning a new bounding box
         * @param other  The bounding box to combine
         */
        BoundingBox.prototype.combine = function (other) {
            var compositeBB = new BoundingBox(Math.min(this.left, other.left), Math.min(this.top, other.top), Math.max(this.right, other.right), Math.max(this.bottom, other.bottom));
            return compositeBB;
        };
        /**
         * Test wether this bounding box collides with another returning,
         * the intersection vector that can be used to resolve the collision. If there
         * is no collision null is returned.
         * @param collidable  Other collidable to test
         */
        BoundingBox.prototype.collides = function (collidable) {
            if (collidable instanceof BoundingBox) {
                var other = collidable;
                var totalBoundingBox = this.combine(other);
                // If the total bounding box is less than the sum of the 2 bounds then there is collision
                if (totalBoundingBox.getWidth() < other.getWidth() + this.getWidth() &&
                    totalBoundingBox.getHeight() < other.getHeight() + this.getHeight()) {
                    // collision
                    var overlapX = 0;
                    if (this.right >= other.left && this.right <= other.right) {
                        overlapX = other.left - this.right;
                    }
                    else {
                        overlapX = other.right - this.left;
                    }
                    var overlapY = 0;
                    if (this.top <= other.bottom && this.top >= other.top) {
                        overlapY = other.bottom - this.top;
                    }
                    else {
                        overlapY = other.top - this.bottom;
                    }
                    if (Math.abs(overlapX) < Math.abs(overlapY)) {
                        return new Algebra_7.Vector(overlapX, 0);
                    }
                    else {
                        return new Algebra_7.Vector(0, overlapY);
                    }
                }
                else {
                    return null;
                }
            }
            return null;
        };
        /* istanbul ignore next */
        BoundingBox.prototype.debugDraw = function (ctx, color) {
            if (color === void 0) { color = Color_3.Color.Yellow; }
            ctx.strokeStyle = color.toString();
            ctx.strokeRect(this.left, this.top, this.getWidth(), this.getHeight());
        };
        return BoundingBox;
    }());
    exports.BoundingBox = BoundingBox;
});
define("Collision/EdgeArea", ["require", "exports", "Collision/BoundingBox", "Collision/CollisionJumpTable", "Collision/CircleArea", "Collision/PolygonArea", "Algebra", "Physics", "Drawing/Color"], function (require, exports, BoundingBox_3, CollisionJumpTable_3, CircleArea_2, PolygonArea_4, Algebra_8, Physics_4, Color_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var EdgeArea = (function () {
        function EdgeArea(options) {
            this.begin = options.begin || Algebra_8.Vector.Zero.clone();
            this.end = options.end || Algebra_8.Vector.Zero.clone();
            this.body = options.body || null;
            this.pos = this.getCenter();
        }
        /**
         * Get the center of the collision area in world coordinates
         */
        EdgeArea.prototype.getCenter = function () {
            var pos = this.begin.average(this.end).add(this._getBodyPos());
            return pos;
        };
        EdgeArea.prototype._getBodyPos = function () {
            var bodyPos = Algebra_8.Vector.Zero.clone();
            if (this.body.pos) {
                bodyPos = this.body.pos;
            }
            return bodyPos;
        };
        EdgeArea.prototype._getTransformedBegin = function () {
            var angle = this.body ? this.body.rotation : 0;
            return this.begin.rotate(angle).add(this._getBodyPos());
        };
        EdgeArea.prototype._getTransformedEnd = function () {
            var angle = this.body ? this.body.rotation : 0;
            return this.end.rotate(angle).add(this._getBodyPos());
        };
        /**
         * Returns the slope of the line in the form of a vector
         */
        EdgeArea.prototype.getSlope = function () {
            var begin = this._getTransformedBegin();
            var end = this._getTransformedEnd();
            var distance = begin.distance(end);
            return end.sub(begin).scale(1 / distance);
        };
        /**
         * Returns the length of the line segment in pixels
         */
        EdgeArea.prototype.getLength = function () {
            var begin = this._getTransformedBegin();
            var end = this._getTransformedEnd();
            var distance = begin.distance(end);
            return distance;
        };
        /**
         * Tests if a point is contained in this collision area
         */
        EdgeArea.prototype.contains = function () {
            return false;
        };
        /**
         * @inheritdoc
         */
        EdgeArea.prototype.rayCast = function (ray, max) {
            if (max === void 0) { max = Infinity; }
            var numerator = this._getTransformedBegin().sub(ray.pos);
            // Test is line and ray are parallel and non intersecting
            if (ray.dir.cross(this.getSlope()) === 0 && numerator.cross(ray.dir) !== 0) {
                return null;
            }
            // Lines are parallel
            var divisor = (ray.dir.cross(this.getSlope()));
            if (divisor === 0) {
                return null;
            }
            var t = numerator.cross(this.getSlope()) / divisor;
            if (t >= 0 && t <= max) {
                var u = (numerator.cross(ray.dir) / divisor) / this.getLength();
                if (u >= 0 && u <= 1) {
                    return ray.getPoint(t);
                }
            }
            return null;
        };
        /**
         * @inheritdoc
         */
        EdgeArea.prototype.collide = function (area) {
            if (area instanceof CircleArea_2.CircleArea) {
                return CollisionJumpTable_3.CollisionJumpTable.CollideCircleEdge(area, this);
            }
            else if (area instanceof PolygonArea_4.PolygonArea) {
                return CollisionJumpTable_3.CollisionJumpTable.CollidePolygonEdge(area, this);
            }
            else if (area instanceof EdgeArea) {
                return CollisionJumpTable_3.CollisionJumpTable.CollideEdgeEdge();
            }
            else {
                throw new Error("Edge could not collide with unknown ICollisionArea " + typeof area);
            }
        };
        /**
         * Find the point on the shape furthest in the direction specified
         */
        EdgeArea.prototype.getFurthestPoint = function (direction) {
            var transformedBegin = this._getTransformedBegin();
            var transformedEnd = this._getTransformedEnd();
            if (direction.dot(transformedBegin) > 0) {
                return transformedBegin;
            }
            else {
                return transformedEnd;
            }
        };
        /**
         * Get the axis aligned bounding box for the circle area
         */
        EdgeArea.prototype.getBounds = function () {
            var transformedBegin = this._getTransformedBegin();
            var transformedEnd = this._getTransformedEnd();
            return new BoundingBox_3.BoundingBox(Math.min(transformedBegin.x, transformedEnd.x), Math.min(transformedBegin.y, transformedEnd.y), Math.max(transformedBegin.x, transformedEnd.x), Math.max(transformedBegin.y, transformedEnd.y));
        };
        /**
         * Get the axis associated with the edge
         */
        EdgeArea.prototype.getAxes = function () {
            var e = this._getTransformedEnd().sub(this._getTransformedBegin());
            var edgeNormal = e.normal();
            var axes = [];
            axes.push(edgeNormal);
            axes.push(edgeNormal.negate());
            axes.push(edgeNormal.normal());
            axes.push(edgeNormal.normal().negate());
            return axes;
        };
        /**
         * Get the moment of inertia for an edge
         * https://en.wikipedia.org/wiki/List_of_moments_of_inertia
         */
        EdgeArea.prototype.getMomentOfInertia = function () {
            var mass = this.body ? this.body.mass : Physics_4.Physics.defaultMass;
            var length = this.end.sub(this.begin).distance() / 2;
            return mass * length * length;
        };
        /**
         * @inheritdoc
         */
        EdgeArea.prototype.recalc = function () {
            // edges don't have any cached data
        };
        /**
         * Project the edge along a specified axis
         */
        EdgeArea.prototype.project = function (axis) {
            var scalars = [];
            var points = [this._getTransformedBegin(), this._getTransformedEnd()];
            var len = points.length;
            for (var i = 0; i < len; i++) {
                scalars.push(points[i].dot(axis));
            }
            return new Algebra_8.Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));
        };
        /* istanbul ignore next */
        EdgeArea.prototype.debugDraw = function (ctx, color) {
            if (color === void 0) { color = Color_4.Color.Red.clone(); }
            ctx.strokeStyle = color.toString();
            ctx.beginPath();
            ctx.moveTo(this.begin.x, this.begin.y);
            ctx.lineTo(this.end.x, this.end.y);
            ctx.closePath();
            ctx.stroke();
        };
        return EdgeArea;
    }());
    exports.EdgeArea = EdgeArea;
});
define("Util/DrawUtil", ["require", "exports", "Drawing/Color"], function (require, exports, Color_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Draw a line on canvas context
     *
     * @param ctx The canvas context
     * @param color The color of the line
     * @param x1 The start x coordinate
     * @param y1 The start y coordinate
     * @param x2 The ending x coordinate
     * @param y2 The ending y coordinate
     * @param thickness The line thickness
     * @param cap The [[LineCapStyle]] (butt, round, or square)
     */
    /* istanbul ignore next */
    function line(ctx, color, x1, y1, x2, y2, thickness, cap) {
        if (color === void 0) { color = Color_5.Color.Red.clone(); }
        if (thickness === void 0) { thickness = 1; }
        if (cap === void 0) { cap = 'butt'; }
        ctx.beginPath();
        ctx.lineWidth = thickness;
        ctx.lineCap = cap;
        ctx.strokeStyle = color.toString();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.closePath();
        ctx.stroke();
    }
    exports.line = line;
    /**
     * Draw the vector as a point onto the canvas.
     */
    /* istanbul ignore next */
    function point(ctx, color, point) {
        if (color === void 0) { color = Color_5.Color.Red.clone(); }
        ctx.beginPath();
        ctx.strokeStyle = color.toString();
        ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
        ctx.closePath();
        ctx.stroke();
    }
    exports.point = point;
    /**
     * Draw the vector as a line onto the canvas starting a origin point.
     */
    /* istanbul ignore next */
    function vector(ctx, color, origin, vector, scale) {
        if (scale === void 0) { scale = 1.0; }
        var c = color ? color.toString() : 'blue';
        var v = vector.scale(scale);
        ctx.beginPath();
        ctx.strokeStyle = c;
        ctx.moveTo(origin.x, origin.y);
        ctx.lineTo(origin.x + v.x, origin.y + v.y);
        ctx.closePath();
        ctx.stroke();
    }
    exports.vector = vector;
    /**
     * Draw a round rectangle on a canvas context
     *
     * @param ctx The canvas context
     * @param x The top-left x coordinate
     * @param y The top-left y coordinate
     * @param width The width of the rectangle
     * @param height The height of the rectangle
     * @param radius The border radius of the rectangle
     * @param fill The [[Color]] to fill rectangle with
     * @param stroke The [[Color]] to stroke rectangle with
     */
    function roundRect(ctx, x, y, width, height, radius, stroke, fill) {
        if (radius === void 0) { radius = 5; }
        if (stroke === void 0) { stroke = Color_5.Color.White; }
        if (fill === void 0) { fill = null; }
        var br;
        if (typeof radius === 'number') {
            br = { tl: radius, tr: radius, br: radius, bl: radius };
        }
        else {
            var defaultRadius = { tl: 0, tr: 0, br: 0, bl: 0 };
            for (var prop in defaultRadius) {
                if (defaultRadius.hasOwnProperty(prop)) {
                    var side = prop;
                    br[side] = radius[side] || defaultRadius[side];
                }
            }
        }
        ctx.beginPath();
        ctx.moveTo(x + br.tl, y);
        ctx.lineTo(x + width - br.tr, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + br.tr);
        ctx.lineTo(x + width, y + height - br.br);
        ctx.quadraticCurveTo(x + width, y + height, x + width - br.br, y + height);
        ctx.lineTo(x + br.bl, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - br.bl);
        ctx.lineTo(x, y + br.tl);
        ctx.quadraticCurveTo(x, y, x + br.tl, y);
        ctx.closePath();
        if (fill) {
            ctx.fillStyle = fill.toString();
            ctx.fill();
        }
        if (stroke) {
            ctx.strokeStyle = stroke.toString();
            ctx.stroke();
        }
    }
    exports.roundRect = roundRect;
    function circle(ctx, x, y, radius, stroke, fill) {
        if (stroke === void 0) { stroke = Color_5.Color.White; }
        if (fill === void 0) { fill = null; }
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.closePath();
        if (fill) {
            ctx.fillStyle = fill.toString();
            ctx.fill();
        }
        if (stroke) {
            ctx.strokeStyle = stroke.toString();
            ctx.stroke();
        }
    }
    exports.circle = circle;
});
define("Collision/Body", ["require", "exports", "Physics", "Collision/EdgeArea", "Collision/CircleArea", "Collision/PolygonArea", "Collision/Pair", "Algebra", "Drawing/Color", "Util/DrawUtil"], function (require, exports, Physics_5, EdgeArea_3, CircleArea_3, PolygonArea_5, Pair_1, Algebra_9, Color_6, DrawUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Body = (function () {
        /**
         * Constructs a new physics body associated with an actor
         */
        function Body(actor) {
            this.actor = actor;
            /**
             * [[ICollisionArea|Collision area]] of this physics body, defines the shape for rigid body collision
             */
            this.collisionArea = null;
            /**
             * The (x, y) position of the actor this will be in the middle of the actor if the
             * [[Actor.anchor]] is set to (0.5, 0.5) which is default.
             * If you want the (x, y) position to be the top left of the actor specify an anchor of (0, 0).
             */
            this.pos = new Algebra_9.Vector(0, 0);
            /**
             * The position of the actor last frame (x, y) in pixels
             */
            this.oldPos = new Algebra_9.Vector(0, 0);
            /**
             * The current velocity vector (vx, vy) of the actor in pixels/second
             */
            this.vel = new Algebra_9.Vector(0, 0);
            /**
             * The velocity of the actor last frame (vx, vy) in pixels/second
             */
            this.oldVel = new Algebra_9.Vector(0, 0);
            /**
             * The curret acceleration vector (ax, ay) of the actor in pixels/second/second. An acceleration pointing down such as (0, 100) may
             * be useful to simulate a gravitational effect.
             */
            this.acc = new Algebra_9.Vector(0, 0);
            /**
             * The current torque applied to the actor
             */
            this.torque = 0;
            /**
             * The current mass of the actor, mass can be thought of as the resistance to acceleration.
             */
            this.mass = 1.0;
            /**
             * The current moment of inertia, moi can be thought of as the resistance to rotation.
             */
            this.moi = 1000;
            /**
             * The current "motion" of the actor, used to calculated sleep in the physics simulation
             */
            this.motion = 10;
            /**
             * The coefficient of friction on this actor
             */
            this.friction = .99;
            /**
             * The coefficient of restitution of this actor, represents the amount of energy preserved after collision
             */
            this.restitution = .2;
            /**
             * The rotation of the actor in radians
             */
            this.rotation = 0; // radians
            /**
             * The rotational velocity of the actor in radians/second
             */
            this.rx = 0; //radians/sec
            this._totalMtv = Algebra_9.Vector.Zero.clone();
        }
        /**
         * Add minimum translation vectors accumulated during the current frame to resolve collisions.
         */
        Body.prototype.addMtv = function (mtv) {
            this._totalMtv.addEqual(mtv);
        };
        /**
         * Applies the accumulated translation vectors to the actors position
         */
        Body.prototype.applyMtv = function () {
            this.pos.addEqual(this._totalMtv);
            this._totalMtv.setTo(0, 0);
        };
        /**
         * Returns the body's [[BoundingBox]] calculated for this instant in world space.
         */
        Body.prototype.getBounds = function () {
            if (Physics_5.Physics.collisionResolutionStrategy === Physics_5.CollisionResolutionStrategy.Box) {
                return this.actor.getBounds();
            }
            else {
                return this.collisionArea.getBounds();
            }
        };
        /**
         * Returns the actor's [[BoundingBox]] relative to the actors position.
         */
        Body.prototype.getRelativeBounds = function () {
            if (Physics_5.Physics.collisionResolutionStrategy === Physics_5.CollisionResolutionStrategy.Box) {
                return this.actor.getRelativeBounds();
            }
            else {
                return this.actor.getRelativeBounds();
            }
        };
        /**
         * Updates the collision area geometry and internal caches
         */
        Body.prototype.update = function () {
            if (this.collisionArea) {
                this.collisionArea.recalc();
            }
        };
        /**
         * Sets up a box collision area based on the current bounds of the associated actor of this physics body.
         *
         * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
         */
        Body.prototype.useBoxCollision = function (center) {
            if (center === void 0) { center = Algebra_9.Vector.Zero.clone(); }
            this.collisionArea = new PolygonArea_5.PolygonArea({
                body: this,
                points: this.actor.getRelativeBounds().getPoints(),
                pos: center // position relative to actor
            });
            // in case of a nan moi, coalesce to a safe default
            this.moi = this.collisionArea.getMomentOfInertia() || this.moi;
        };
        /**
         * Sets up a polygon collision area based on a list of of points relative to the anchor of the associated actor of this physics body.
         *
         * Only [convex polygon](https://en.wikipedia.org/wiki/Convex_polygon) definitions are supported.
         *
         * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
         */
        Body.prototype.usePolygonCollision = function (points, center) {
            if (center === void 0) { center = Algebra_9.Vector.Zero.clone(); }
            this.collisionArea = new PolygonArea_5.PolygonArea({
                body: this,
                points: points,
                pos: center // position relative to actor
            });
            // in case of a nan moi, collesce to a safe default
            this.moi = this.collisionArea.getMomentOfInertia() || this.moi;
        };
        /**
         * Sets up a [[CircleArea|circle collision area]] with a specified radius in pixels.
         *
         * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
         */
        Body.prototype.useCircleCollision = function (radius, center) {
            if (center === void 0) { center = Algebra_9.Vector.Zero.clone(); }
            if (!radius) {
                radius = this.actor.getWidth() / 2;
            }
            this.collisionArea = new CircleArea_3.CircleArea({
                body: this,
                radius: radius,
                pos: center
            });
            this.moi = this.collisionArea.getMomentOfInertia() || this.moi;
        };
        /**
         * Sets up an [[EdgeArea|edge collision]] with a start point and an end point relative to the anchor of the associated actor
         * of this physics body.
         *
         * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
         */
        Body.prototype.useEdgeCollision = function (begin, end) {
            this.collisionArea = new EdgeArea_3.EdgeArea({
                begin: begin,
                end: end,
                body: this
            });
            this.moi = this.collisionArea.getMomentOfInertia() || this.moi;
        };
        /* istanbul ignore next */
        Body.prototype.debugDraw = function (ctx) {
            // Draw motion vectors
            if (Physics_5.Physics.showMotionVectors) {
                DrawUtil.vector(ctx, Color_6.Color.Yellow, this.pos, (this.acc.add(Physics_5.Physics.acc)));
                DrawUtil.vector(ctx, Color_6.Color.Red, this.pos, (this.vel));
                DrawUtil.point(ctx, Color_6.Color.Red, this.pos);
            }
            if (Physics_5.Physics.showBounds) {
                this.getBounds().debugDraw(ctx, Color_6.Color.Yellow);
            }
            if (Physics_5.Physics.showArea) {
                this.collisionArea.debugDraw(ctx, Color_6.Color.Green);
            }
        };
        /**
         * Returns a boolean indicating whether this body collided with
         * or was in stationary contact with
         * the body of the other [[Actor]]
         */
        Body.prototype.touching = function (other) {
            var pair = new Pair_1.Pair(this, other.body);
            pair.collide();
            if (pair.collision) {
                return true;
            }
            return false;
        };
        return Body;
    }());
    exports.Body = Body;
});
define("Collision/Pair", ["require", "exports", "Physics", "Drawing/Color", "Actor", "Util/DrawUtil"], function (require, exports, Physics_6, Color_7, Actor_2, DrawUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Models a potential collision between 2 bodies
     */
    var Pair = (function () {
        function Pair(bodyA, bodyB) {
            this.bodyA = bodyA;
            this.bodyB = bodyB;
            this.id = null;
            this.collision = null;
            this.id = Pair.calculatePairHash(bodyA, bodyB);
        }
        Object.defineProperty(Pair.prototype, "canCollide", {
            /**
             * Returns whether or not it is possible for the pairs to collide
             */
            get: function () {
                var actorA = this.bodyA.actor;
                var actorB = this.bodyB.actor;
                // if both are fixed short circuit
                if (actorA.collisionType === Actor_2.CollisionType.Fixed && actorB.collisionType === Actor_2.CollisionType.Fixed) {
                    return false;
                }
                // if the other is prevent collision or is dead short circuit
                if (actorB.collisionType === Actor_2.CollisionType.PreventCollision || actorB.isKilled()) {
                    return false;
                }
                return true;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Runs the collison intersection logic on the members of this pair
         */
        Pair.prototype.collide = function () {
            this.collision = this.bodyA.collisionArea.collide(this.bodyB.collisionArea);
        };
        /**
         * Resovles the collision body position and velocity if a collision occured
         */
        Pair.prototype.resolve = function (strategy) {
            if (this.collision) {
                this.collision.resolve(strategy);
            }
        };
        /**
         * Calculates the unique pair hash id for this collision pair
         */
        Pair.calculatePairHash = function (bodyA, bodyB) {
            if (bodyA.actor.id < bodyB.actor.id) {
                return "#" + bodyA.actor.id + "+" + bodyB.actor.id;
            }
            else {
                return "#" + bodyB.actor.id + "+" + bodyA.actor.id;
            }
        };
        /* istanbul ignore next */
        Pair.prototype.debugDraw = function (ctx) {
            if (this.collision) {
                if (Physics_6.Physics.showContacts) {
                    DrawUtil.point(ctx, Color_7.Color.Red, this.collision.point);
                }
                if (Physics_6.Physics.showCollisionNormals) {
                    DrawUtil.vector(ctx, Color_7.Color.Cyan, this.collision.point, this.collision.normal, 30);
                }
            }
        };
        return Pair;
    }());
    exports.Pair = Pair;
});
define("Debug", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Debug statistics and flags for Excalibur. If polling these values, it would be
     * best to do so on the `postupdate` event for [[Engine]], after all values have been
     * updated during a frame.
     */
    var Debug = (function () {
        function Debug() {
            /**
             * Performance statistics
             */
            this.stats = {
                /**
                 * Current frame statistics. Engine reuses this instance, use [[FrameStats.clone]] to copy frame stats.
                 * Best accessed on [[postframe]] event. See [[IFrameStats]]
                 */
                currFrame: new FrameStats(),
                /**
                 * Previous frame statistics. Engine reuses this instance, use [[FrameStats.clone]] to copy frame stats.
                 * Best accessed on [[preframe]] event. Best inspected on engine event `preframe`. See [[IFrameStats]]
                 */
                prevFrame: new FrameStats()
            };
        }
        return Debug;
    }());
    exports.Debug = Debug;
    /**
     * Implementation of a frame's stats. Meant to have values copied via [[FrameStats.reset]], avoid
     * creating instances of this every frame.
     */
    var FrameStats = (function () {
        function FrameStats() {
            this._id = 0;
            this._delta = 0;
            this._fps = 0;
            this._actorStats = {
                alive: 0,
                killed: 0,
                ui: 0,
                get remaining() {
                    return this.alive - this.killed;
                },
                get total() {
                    return this.remaining + this.ui;
                }
            };
            this._durationStats = {
                update: 0,
                draw: 0,
                get total() {
                    return this.update + this.draw;
                }
            };
            this._physicsStats = new PhysicsStats();
        }
        /**
         * Zero out values or clone other IFrameStat stats. Allows instance reuse.
         *
         * @param [otherStats] Optional stats to clone
         */
        FrameStats.prototype.reset = function (otherStats) {
            if (otherStats) {
                this.id = otherStats.id;
                this.delta = otherStats.delta;
                this.fps = otherStats.fps;
                this.actors.alive = otherStats.actors.alive;
                this.actors.killed = otherStats.actors.killed;
                this.actors.ui = otherStats.actors.ui;
                this.duration.update = otherStats.duration.update;
                this.duration.draw = otherStats.duration.draw;
                this._physicsStats.reset(otherStats.physics);
            }
            else {
                this.id = this.delta = this.fps = 0;
                this.actors.alive = this.actors.killed = this.actors.ui = 0;
                this.duration.update = this.duration.draw = 0;
                this._physicsStats.reset();
            }
        };
        /**
         * Provides a clone of this instance.
         */
        FrameStats.prototype.clone = function () {
            var fs = new FrameStats();
            fs.reset(this);
            return fs;
        };
        Object.defineProperty(FrameStats.prototype, "id", {
            /**
             * Gets the frame's id
             */
            get: function () {
                return this._id;
            },
            /**
             * Sets the frame's id
             */
            set: function (value) {
                this._id = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FrameStats.prototype, "delta", {
            /**
             * Gets the frame's delta (time since last frame)
             */
            get: function () {
                return this._delta;
            },
            /**
             * Sets the frame's delta (time since last frame). Internal use only.
             * @internal
             */
            set: function (value) {
                this._delta = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FrameStats.prototype, "fps", {
            /**
             * Gets the frame's frames-per-second (FPS)
             */
            get: function () {
                return this._fps;
            },
            /**
             * Sets the frame's frames-per-second (FPS). Internal use only.
             * @internal
             */
            set: function (value) {
                this._fps = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FrameStats.prototype, "actors", {
            /**
             * Gets the frame's actor statistics
             */
            get: function () {
                return this._actorStats;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FrameStats.prototype, "duration", {
            /**
             * Gets the frame's duration statistics
             */
            get: function () {
                return this._durationStats;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FrameStats.prototype, "physics", {
            /**
             * Gets the frame's physics statistics
             */
            get: function () {
                return this._physicsStats;
            },
            enumerable: true,
            configurable: true
        });
        return FrameStats;
    }());
    exports.FrameStats = FrameStats;
    var PhysicsStats = (function () {
        function PhysicsStats() {
            this._pairs = 0;
            this._collisions = 0;
            this._collidersHash = {};
            this._fastBodies = 0;
            this._fastBodyCollisions = 0;
            this._broadphase = 0;
            this._narrowphase = 0;
        }
        /**
         * Zero out values or clone other IPhysicsStats stats. Allows instance reuse.
         *
         * @param [otherStats] Optional stats to clone
         */
        PhysicsStats.prototype.reset = function (otherStats) {
            if (otherStats) {
                this.pairs = otherStats.pairs;
                this.collisions = otherStats.collisions;
                this.collidersHash = otherStats.collidersHash;
                this.fastBodies = otherStats.fastBodies;
                this.fastBodyCollisions = otherStats.fastBodyCollisions;
                this.broadphase = otherStats.broadphase;
                this.narrowphase = otherStats.narrowphase;
            }
            else {
                this.pairs = this.collisions = this.fastBodies = 0;
                this.fastBodyCollisions = this.broadphase = this.narrowphase = 0;
                this.collidersHash = {};
            }
        };
        /**
         * Provides a clone of this instance.
         */
        PhysicsStats.prototype.clone = function () {
            var ps = new PhysicsStats();
            ps.reset(this);
            return ps;
        };
        Object.defineProperty(PhysicsStats.prototype, "pairs", {
            get: function () {
                return this._pairs;
            },
            set: function (value) {
                this._pairs = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PhysicsStats.prototype, "collisions", {
            get: function () {
                return this._collisions;
            },
            set: function (value) {
                this._collisions = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PhysicsStats.prototype, "collidersHash", {
            get: function () {
                return this._collidersHash;
            },
            set: function (colliders) {
                this._collidersHash = colliders;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PhysicsStats.prototype, "fastBodies", {
            get: function () {
                return this._fastBodies;
            },
            set: function (value) {
                this._fastBodies = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PhysicsStats.prototype, "fastBodyCollisions", {
            get: function () {
                return this._fastBodyCollisions;
            },
            set: function (value) {
                this._fastBodyCollisions = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PhysicsStats.prototype, "broadphase", {
            get: function () {
                return this._broadphase;
            },
            set: function (value) {
                this._broadphase = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PhysicsStats.prototype, "narrowphase", {
            get: function () {
                return this._narrowphase;
            },
            set: function (value) {
                this._narrowphase = value;
            },
            enumerable: true,
            configurable: true
        });
        return PhysicsStats;
    }());
    exports.PhysicsStats = PhysicsStats;
});
define("Interfaces/IEvented", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("EventDispatcher", ["require", "exports", "Events"], function (require, exports, Events_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Excalibur's internal event dispatcher implementation.
     * Callbacks are fired immediately after an event is published.
     * Typically you will use [[Class.eventDispatcher]] since most classes in
     * Excalibur inherit from [[Class]]. You will rarely create an `EventDispatcher`
     * yourself.
     *
     * [[include:Events.md]]
     */
    var EventDispatcher = (function () {
        /**
         * @param target  The object that will be the recipient of events from this event dispatcher
         */
        function EventDispatcher(target) {
            this._handlers = {};
            this._wiredEventDispatchers = [];
            this._target = target;
        }
        /**
         * Emits an event for target
         * @param eventName  The name of the event to publish
         * @param event      Optionally pass an event data object to the handler
         */
        EventDispatcher.prototype.emit = function (eventName, event) {
            if (!eventName) {
                // key not mapped
                return;
            }
            eventName = eventName.toLowerCase();
            var target = this._target;
            if (!event) {
                event = new Events_2.GameEvent();
            }
            event.target = target;
            var i, len;
            if (this._handlers[eventName]) {
                i = 0;
                len = this._handlers[eventName].length;
                for (i; i < len; i++) {
                    this._handlers[eventName][i].call(target, event);
                }
            }
            i = 0;
            len = this._wiredEventDispatchers.length;
            for (i; i < len; i++) {
                this._wiredEventDispatchers[i].emit(eventName, event);
            }
        };
        /**
         * Subscribe an event handler to a particular event name, multiple handlers per event name are allowed.
         * @param eventName  The name of the event to subscribe to
         * @param handler    The handler callback to fire on this event
         */
        EventDispatcher.prototype.on = function (eventName, handler) {
            eventName = eventName.toLowerCase();
            if (!this._handlers[eventName]) {
                this._handlers[eventName] = [];
            }
            this._handlers[eventName].push(handler);
            // meta event handlers
            if (eventName !== 'unsubscribe' && eventName !== 'subscribe') {
                this.emit('subscribe', new Events_2.SubscribeEvent(eventName, handler));
            }
        };
        /**
         * Unsubscribe an event handler(s) from an event. If a specific handler
         * is specified for an event, only that handler will be unsubscribed.
         * Otherwise all handlers will be unsubscribed for that event.
         *
         * @param eventName  The name of the event to unsubscribe
         * @param handler    Optionally the specific handler to unsubscribe
         *
         */
        EventDispatcher.prototype.off = function (eventName, handler) {
            eventName = eventName.toLowerCase();
            var eventHandlers = this._handlers[eventName];
            if (eventHandlers) {
                // if no explicit handler is give with the event name clear all handlers
                if (!handler) {
                    this._handlers[eventName].length = 0;
                }
                else {
                    var index = eventHandlers.indexOf(handler);
                    this._handlers[eventName].splice(index, 1);
                }
            }
            // meta event handlers
            if (eventName !== 'unsubscribe' && eventName !== 'subscribe') {
                this.emit('unsubscribe', new Events_2.UnsubscribeEvent(eventName, handler));
            }
        };
        /**
         * Once listens to an event one time, then unsubscribes from that event
         *
         * @param eventName The name of the event to subscribe to once
         * @param handler   The handler of the event that will be auto unsubscribed
         */
        EventDispatcher.prototype.once = function (eventName, handler) {
            var _this = this;
            var metaHandler = function (event) {
                var ev = event || new Events_2.GameEvent();
                ev.target = ev.target || _this._target;
                _this.off(eventName, handler);
                handler.call(ev.target, ev);
            };
            this.on(eventName, metaHandler);
        };
        /**
         * Wires this event dispatcher to also recieve events from another
         */
        EventDispatcher.prototype.wire = function (eventDispatcher) {
            eventDispatcher._wiredEventDispatchers.push(this);
        };
        /**
         * Unwires this event dispatcher from another
         */
        EventDispatcher.prototype.unwire = function (eventDispatcher) {
            var index = eventDispatcher._wiredEventDispatchers.indexOf(this);
            if (index > -1) {
                eventDispatcher._wiredEventDispatchers.splice(index, 1);
            }
        };
        return EventDispatcher;
    }());
    exports.EventDispatcher = EventDispatcher;
});
define("Actions/ActionContext", ["require", "exports", "Actions/Action", "Promises", "Util/EasingFunctions"], function (require, exports, Actions, Promises_2, EasingFunctions_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The fluent Action API allows you to perform "actions" on
     * [[Actor|Actors]] such as following, moving, rotating, and
     * more. You can implement your own actions by implementing
     * the [[IAction]] interface.
     *
     * [[include:Actions.md]]
     */
    var ActionContext = (function () {
        function ActionContext() {
            this._actors = [];
            this._queues = [];
            if (arguments !== null) {
                this._actors = Array.prototype.slice.call(arguments, 0);
                this._queues = this._actors.map(function (a) {
                    return a.actionQueue;
                });
            }
        }
        /**
         * Clears all queued actions from the Actor
         */
        ActionContext.prototype.clearActions = function () {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].clearActions();
            }
        };
        ActionContext.prototype.addActorToContext = function (actor) {
            this._actors.push(actor);
            // if we run into problems replace the line below with:
            this._queues.push(actor.actionQueue);
        };
        ActionContext.prototype.removeActorFromContext = function (actor) {
            var index = this._actors.indexOf(actor);
            if (index > -1) {
                this._actors.splice(index, 1);
                this._queues.splice(index, 1);
            }
        };
        /**
         * This method will move an actor to the specified `x` and `y` position over the
         * specified duration using a given [[EasingFunctions]] and return back the actor. This
         * method is part of the actor 'Action' fluent API allowing action chaining.
         * @param x         The x location to move the actor to
         * @param y         The y location to move the actor to
         * @param duration  The time it should take the actor to move to the new location in milliseconds
         * @param easingFcn Use [[EasingFunctions]] or a custom function to use to calculate position
         */
        ActionContext.prototype.easeTo = function (x, y, duration, easingFcn) {
            if (easingFcn === void 0) { easingFcn = EasingFunctions_2.EasingFunctions.Linear; }
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.EaseTo(this._actors[i], x, y, duration, easingFcn));
            }
            return this;
        };
        /**
         * This method will move an actor to the specified x and y position at the
         * speed specified (in pixels per second) and return back the actor. This
         * method is part of the actor 'Action' fluent API allowing action chaining.
         * @param x      The x location to move the actor to
         * @param y      The y location to move the actor to
         * @param speed  The speed in pixels per second to move
         */
        ActionContext.prototype.moveTo = function (x, y, speed) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.MoveTo(this._actors[i], x, y, speed));
            }
            return this;
        };
        /**
         * This method will move an actor to the specified x and y position by a
         * certain time (in milliseconds). This method is part of the actor
         * 'Action' fluent API allowing action chaining.
         * @param x     The x location to move the actor to
         * @param y     The y location to move the actor to
         * @param time  The time it should take the actor to move to the new location in milliseconds
         */
        ActionContext.prototype.moveBy = function (x, y, time) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.MoveBy(this._actors[i], x, y, time));
            }
            return this;
        };
        /**
         * This method will rotate an actor to the specified angle at the speed
         * specified (in radians per second) and return back the actor. This
         * method is part of the actor 'Action' fluent API allowing action chaining.
         * @param angleRadians  The angle to rotate to in radians
         * @param speed         The angular velocity of the rotation specified in radians per second
         * @param rotationType  The [[RotationType]] to use for this rotation
         */
        ActionContext.prototype.rotateTo = function (angleRadians, speed, rotationType) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.RotateTo(this._actors[i], angleRadians, speed, rotationType));
            }
            return this;
        };
        /**
         * This method will rotate an actor to the specified angle by a certain
         * time (in milliseconds) and return back the actor. This method is part
         * of the actor 'Action' fluent API allowing action chaining.
         * @param angleRadians  The angle to rotate to in radians
         * @param time          The time it should take the actor to complete the rotation in milliseconds
         * @param rotationType  The [[RotationType]] to use for this rotation
         */
        ActionContext.prototype.rotateBy = function (angleRadians, time, rotationType) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.RotateBy(this._actors[i], angleRadians, time, rotationType));
            }
            return this;
        };
        /**
         * This method will scale an actor to the specified size at the speed
         * specified (in magnitude increase per second) and return back the
         * actor. This method is part of the actor 'Action' fluent API allowing
         * action chaining.
         * @param sizeX   The scaling factor to apply on X axis
         * @param sizeY   The scaling factor to apply on Y axis
         * @param speedX  The speed of scaling specified in magnitude increase per second on X axis
         * @param speedY  The speed of scaling specified in magnitude increase per second on Y axis
         */
        ActionContext.prototype.scaleTo = function (sizeX, sizeY, speedX, speedY) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.ScaleTo(this._actors[i], sizeX, sizeY, speedX, speedY));
            }
            return this;
        };
        /**
         * This method will scale an actor to the specified size by a certain time
         * (in milliseconds) and return back the actor. This method is part of the
         * actor 'Action' fluent API allowing action chaining.
         * @param sizeX   The scaling factor to apply on X axis
         * @param sizeY   The scaling factor to apply on Y axis
         * @param time    The time it should take to complete the scaling in milliseconds
         */
        ActionContext.prototype.scaleBy = function (sizeX, sizeY, time) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.ScaleBy(this._actors[i], sizeX, sizeY, time));
            }
            return this;
        };
        /**
         * This method will cause an actor to blink (become visible and not
         * visible). Optionally, you may specify the number of blinks. Specify the amount of time
         * the actor should be visible per blink, and the amount of time not visible.
         * This method is part of the actor 'Action' fluent API allowing action chaining.
         * @param timeVisible     The amount of time to stay visible per blink in milliseconds
         * @param timeNotVisible  The amount of time to stay not visible per blink in milliseconds
         * @param numBlinks       The number of times to blink
         */
        ActionContext.prototype.blink = function (timeVisible, timeNotVisible, numBlinks) {
            if (numBlinks === void 0) { numBlinks = 1; }
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.Blink(this._actors[i], timeVisible, timeNotVisible, numBlinks));
            }
            return this;
        };
        /**
         * This method will cause an actor's opacity to change from its current value
         * to the provided value by a specified time (in milliseconds). This method is
         * part of the actor 'Action' fluent API allowing action chaining.
         * @param opacity  The ending opacity
         * @param time     The time it should take to fade the actor (in milliseconds)
         */
        ActionContext.prototype.fade = function (opacity, time) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.Fade(this._actors[i], opacity, time));
            }
            return this;
        };
        /**
         * This method will delay the next action from executing for a certain
         * amount of time (in milliseconds). This method is part of the actor
         * 'Action' fluent API allowing action chaining.
         * @param time  The amount of time to delay the next action in the queue from executing in milliseconds
         */
        ActionContext.prototype.delay = function (time) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.Delay(this._actors[i], time));
            }
            return this;
        };
        /**
         * This method will add an action to the queue that will remove the actor from the
         * scene once it has completed its previous actions. Any actions on the
         * action queue after this action will not be executed.
         */
        ActionContext.prototype.die = function () {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.Die(this._actors[i]));
            }
            return this;
        };
        /**
         * This method allows you to call an arbitrary method as the next action in the
         * action queue. This is useful if you want to execute code in after a specific
         * action, i.e An actor arrives at a destination after traversing a path
         */
        ActionContext.prototype.callMethod = function (method) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.CallMethod(this._actors[i], method));
            }
            return this;
        };
        /**
         * This method will cause the actor to repeat all of the previously
         * called actions a certain number of times. If the number of repeats
         * is not specified it will repeat forever. This method is part of
         * the actor 'Action' fluent API allowing action chaining
         * @param times  The number of times to repeat all the previous actions in the action queue. If nothing is specified the actions
         * will repeat forever
         */
        ActionContext.prototype.repeat = function (times) {
            if (!times) {
                this.repeatForever();
                return this;
            }
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.Repeat(this._actors[i], times, this._actors[i].actionQueue.getActions()));
            }
            return this;
        };
        /**
         * This method will cause the actor to repeat all of the previously
         * called actions forever. This method is part of the actor 'Action'
         * fluent API allowing action chaining.
         */
        ActionContext.prototype.repeatForever = function () {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                this._queues[i].add(new Actions.RepeatForever(this._actors[i], this._actors[i].actionQueue.getActions()));
            }
            return this;
        };
        /**
         * This method will cause the actor to follow another at a specified distance
         * @param actor           The actor to follow
         * @param followDistance  The distance to maintain when following, if not specified the actor will follow at the current distance.
         */
        ActionContext.prototype.follow = function (actor, followDistance) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                if (followDistance === undefined) {
                    this._queues[i].add(new Actions.Follow(this._actors[i], actor));
                }
                else {
                    this._queues[i].add(new Actions.Follow(this._actors[i], actor, followDistance));
                }
            }
            return this;
        };
        /**
         * This method will cause the actor to move towards another until they
         * collide "meet" at a specified speed.
         * @param actor  The actor to meet
         * @param speed  The speed in pixels per second to move, if not specified it will match the speed of the other actor
         */
        ActionContext.prototype.meet = function (actor, speed) {
            var i = 0, len = this._queues.length;
            for (i; i < len; i++) {
                if (speed === undefined) {
                    this._queues[i].add(new Actions.Meet(this._actors[i], actor));
                }
                else {
                    this._queues[i].add(new Actions.Meet(this._actors[i], actor, speed));
                }
            }
            return this;
        };
        /**
         * Returns a promise that resolves when the current action queue up to now
         * is finished.
         */
        ActionContext.prototype.asPromise = function () {
            var _this = this;
            var promises = this._queues.map(function (q, i) {
                var temp = new Promises_2.Promise();
                q.add(new Actions.CallMethod(_this._actors[i], function () {
                    temp.resolve();
                }));
                return temp;
            });
            return Promises_2.Promise.join.apply(this, promises);
        };
        return ActionContext;
    }());
    exports.ActionContext = ActionContext;
});
define("Util/Log", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Logging level that Excalibur will tag
     */
    var LogLevel;
    (function (LogLevel) {
        LogLevel[LogLevel["Debug"] = 0] = "Debug";
        LogLevel[LogLevel["Info"] = 1] = "Info";
        LogLevel[LogLevel["Warn"] = 2] = "Warn";
        LogLevel[LogLevel["Error"] = 3] = "Error";
        LogLevel[LogLevel["Fatal"] = 4] = "Fatal";
    })(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
    /**
     * Static singleton that represents the logging facility for Excalibur.
     * Excalibur comes built-in with a [[ConsoleAppender]] and [[ScreenAppender]].
     * Derive from [[IAppender]] to create your own logging appenders.
     *
     * [[include:Logger.md]]
     */
    var Logger = (function () {
        function Logger() {
            this._appenders = [];
            /**
             * Gets or sets the default logging level. Excalibur will only log
             * messages if equal to or above this level. Default: [[LogLevel.Info]]
             */
            this.defaultLevel = LogLevel.Info;
            if (Logger._instance) {
                throw new Error('Logger is a singleton');
            }
            Logger._instance = this;
            // Default console appender
            Logger._instance.addAppender(new ConsoleAppender());
            return Logger._instance;
        }
        /**
         * Gets the current static instance of Logger
         */
        Logger.getInstance = function () {
            if (Logger._instance == null) {
                Logger._instance = new Logger();
            }
            return Logger._instance;
        };
        /**
         * Adds a new [[IAppender]] to the list of appenders to write to
         */
        Logger.prototype.addAppender = function (appender) {
            this._appenders.push(appender);
        };
        /**
         * Clears all appenders from the logger
         */
        Logger.prototype.clearAppenders = function () {
            this._appenders.length = 0;
        };
        /**
         * Logs a message at a given LogLevel
         * @param level  The LogLevel`to log the message at
         * @param args   An array of arguments to write to an appender
         */
        Logger.prototype._log = function (level, args) {
            if (level == null) {
                level = this.defaultLevel;
            }
            var i = 0, len = this._appenders.length;
            for (i; i < len; i++) {
                if (level >= this.defaultLevel) {
                    this._appenders[i].log(level, args);
                }
            }
        };
        /**
         * Writes a log message at the [[LogLevel.Debug]] level
         * @param args  Accepts any number of arguments
         */
        Logger.prototype.debug = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            this._log(LogLevel.Debug, args);
        };
        /**
         * Writes a log message at the [[LogLevel.Info]] level
         * @param args  Accepts any number of arguments
         */
        Logger.prototype.info = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            this._log(LogLevel.Info, args);
        };
        /**
         * Writes a log message at the [[LogLevel.Warn]] level
         * @param args  Accepts any number of arguments
         */
        Logger.prototype.warn = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            this._log(LogLevel.Warn, args);
        };
        /**
         * Writes a log message at the [[LogLevel.Error]] level
         * @param args  Accepts any number of arguments
         */
        Logger.prototype.error = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            this._log(LogLevel.Error, args);
        };
        /**
         * Writes a log message at the [[LogLevel.Fatal]] level
         * @param args  Accepts any number of arguments
         */
        Logger.prototype.fatal = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            this._log(LogLevel.Fatal, args);
        };
        return Logger;
    }());
    Logger._instance = null;
    exports.Logger = Logger;
    /**
     * Console appender for browsers (i.e. `console.log`)
     */
    var ConsoleAppender = (function () {
        function ConsoleAppender() {
        }
        /**
         * Logs a message at the given [[LogLevel]]
         * @param level  Level to log at
         * @param args   Arguments to log
         */
        ConsoleAppender.prototype.log = function (level, args) {
            // Check for console support
            if (!console && !console.log && console.warn && console.error) {
                // todo maybe do something better than nothing
                return;
            }
            // Create a new console args array
            var consoleArgs = [];
            consoleArgs.unshift.apply(consoleArgs, args);
            consoleArgs.unshift('[' + LogLevel[level] + '] : ');
            if (level < LogLevel.Warn) {
                // Call .log for Debug/Info
                if (console.log.apply) {
                    // this is required on some older browsers that don't support apply on console.log :(
                    console.log.apply(console, consoleArgs);
                }
                else {
                    console.log(consoleArgs.join(' '));
                }
            }
            else if (level < LogLevel.Error) {
                // Call .warn for Warn
                if (console.warn.apply) {
                    console.warn.apply(console, consoleArgs);
                }
                else {
                    console.warn(consoleArgs.join(' '));
                }
            }
            else {
                // Call .error for Error/Fatal
                if (console.error.apply) {
                    console.error.apply(console, consoleArgs);
                }
                else {
                    console.error(consoleArgs.join(' '));
                }
            }
        };
        return ConsoleAppender;
    }());
    exports.ConsoleAppender = ConsoleAppender;
    /**
     * On-screen (canvas) appender
     */
    var ScreenAppender = (function () {
        /**
         * @param width   Width of the screen appender in pixels
         * @param height  Height of the screen appender in pixels
         */
        function ScreenAppender(width, height) {
            // @todo Clean this up
            this._messages = [];
            this._canvas = document.createElement('canvas');
            this._canvas.width = width || window.innerWidth;
            this._canvas.height = height || window.innerHeight;
            this._canvas.style.position = 'absolute';
            this._ctx = this._canvas.getContext('2d');
            document.body.appendChild(this._canvas);
        }
        /**
         * Logs a message at the given [[LogLevel]]
         * @param level  Level to log at
         * @param args   Arguments to log
         */
        ScreenAppender.prototype.log = function (level, args) {
            var message = args.join(',');
            this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
            this._messages.unshift('[' + LogLevel[level] + '] : ' + message);
            var pos = 10;
            var opacity = 1.0;
            for (var i = 0; i < this._messages.length; i++) {
                this._ctx.fillStyle = 'rgba(255,255,255,' + opacity.toFixed(2) + ')';
                this._ctx.fillText(this._messages[i], 200, pos);
                pos += 10;
                opacity = opacity > 0 ? opacity - .05 : 0;
            }
        };
        return ScreenAppender;
    }());
    exports.ScreenAppender = ScreenAppender;
});
define("Actions/IActionable", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Group", ["require", "exports", "Algebra", "Actions/ActionContext", "Actor", "Util/Log", "Class"], function (require, exports, Algebra_10, ActionContext_1, Actor_3, Log_1, Class_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Groups are used for logically grouping Actors so they can be acted upon
     * in bulk.
     *
     * [[include:Groups.md]]
     */
    var Group = (function (_super) {
        __extends(Group, _super);
        function Group(name, scene) {
            var _this = _super.call(this) || this;
            _this.name = name;
            _this.scene = scene;
            _this._logger = Log_1.Logger.getInstance();
            _this._members = [];
            _this.actions = new ActionContext_1.ActionContext();
            if (scene == null) {
                _this._logger.error('Invalid constructor arguments passed to Group: ', name, ', scene must not be null!');
            }
            else {
                var existingGroup = scene.groups[name];
                if (existingGroup) {
                    _this._logger.warn('Group with name', name, 'already exists. This new group will replace it.');
                }
                scene.groups[name] = _this;
            }
            return _this;
        }
        Group.prototype.add = function (actorOrActors) {
            if (actorOrActors instanceof Actor_3.Actor) {
                actorOrActors = [].concat(actorOrActors);
            }
            var i = 0, len = actorOrActors.length, groupIdx;
            for (i; i < len; i++) {
                groupIdx = this.getMembers().indexOf(actorOrActors[i]);
                if (groupIdx === -1) {
                    this._members.push(actorOrActors[i]);
                    this.scene.add(actorOrActors[i]);
                    this.actions.addActorToContext(actorOrActors[i]);
                    this.eventDispatcher.wire(actorOrActors[i].eventDispatcher);
                }
            }
        };
        Group.prototype.remove = function (actor) {
            var index = this._members.indexOf(actor);
            if (index > -1) {
                this._members.splice(index, 1);
                this.actions.removeActorFromContext(actor);
                this.eventDispatcher.unwire(actor.eventDispatcher);
            }
        };
        Group.prototype.move = function (args) {
            var i = 0, members = this.getMembers(), len = members.length;
            if (arguments.length === 1 && args instanceof Algebra_10.Vector) {
                for (i; i < len; i++) {
                    members[i].pos.x += args.x;
                    members[i].pos.y += args.y;
                }
            }
            else if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
                var x = arguments[0];
                var y = arguments[1];
                for (i; i < len; i++) {
                    members[i].pos.x += x;
                    members[i].pos.y += y;
                }
            }
            else {
                this._logger.error('Invalid arguments passed to group move', this.name, 'args:', arguments);
            }
        };
        Group.prototype.rotate = function (angle) {
            if (typeof angle !== 'number') {
                this._logger.error('Invalid arguments passed to group rotate', this.name, 'args:', arguments);
                return;
            }
            for (var _i = 0, _a = this.getMembers(); _i < _a.length; _i++) {
                var member = _a[_i];
                member.rotation += angle;
            }
        };
        Group.prototype.on = function (eventName, handler) {
            this.eventDispatcher.on(eventName, handler);
        };
        Group.prototype.off = function (eventName, handler) {
            this.eventDispatcher.off(eventName, handler);
        };
        Group.prototype.emit = function (topic, event) {
            this.eventDispatcher.emit(topic, event);
        };
        Group.prototype.contains = function (actor) {
            return this.getMembers().indexOf(actor) > -1;
        };
        Group.prototype.getMembers = function () {
            return this._members;
        };
        Group.prototype.getRandomMember = function () {
            return this._members[Math.floor(Math.random() * this._members.length)];
        };
        Group.prototype.getBounds = function () {
            return this.getMembers().map(function (a) { return a.getBounds(); }).reduce(function (prev, curr) {
                return prev.combine(curr);
            });
        };
        return Group;
    }(Class_1.Class));
    exports.Group = Group;
});
/**
 * These effects can be applied to any bitmap image but are mainly used
 * for [[Sprite]] effects or [[Animation]] effects.
 *
 * [[include:SpriteEffects.md]]
 */
define("Drawing/SpriteEffects", ["require", "exports", "Drawing/Color"], function (require, exports, Color_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Applies the "Grayscale" effect to a sprite, removing color information.
     */
    var Grayscale = (function () {
        function Grayscale() {
        }
        Grayscale.prototype.updatePixel = function (x, y, imageData) {
            var firstPixel = (x + y * imageData.width) * 4;
            var pixel = imageData.data;
            var avg = (pixel[firstPixel + 0] + pixel[firstPixel + 1] + pixel[firstPixel + 2]) / 3;
            pixel[firstPixel + 0] = avg;
            pixel[firstPixel + 1] = avg;
            pixel[firstPixel + 2] = avg;
        };
        return Grayscale;
    }());
    exports.Grayscale = Grayscale;
    /**
     * Applies the "Invert" effect to a sprite, inverting the pixel colors.
     */
    var Invert = (function () {
        function Invert() {
        }
        Invert.prototype.updatePixel = function (x, y, imageData) {
            var firstPixel = (x + y * imageData.width) * 4;
            var pixel = imageData.data;
            pixel[firstPixel + 0] = 255 - pixel[firstPixel + 0];
            pixel[firstPixel + 1] = 255 - pixel[firstPixel + 1];
            pixel[firstPixel + 2] = 255 - pixel[firstPixel + 2];
        };
        return Invert;
    }());
    exports.Invert = Invert;
    /**
     * Applies the "Opacity" effect to a sprite, setting the alpha of all pixels to a given value.
     */
    var Opacity = (function () {
        /**
         * @param opacity  The new opacity of the sprite from 0-1.0
         */
        function Opacity(opacity) {
            this.opacity = opacity;
        }
        Opacity.prototype.updatePixel = function (x, y, imageData) {
            var firstPixel = (x + y * imageData.width) * 4;
            var pixel = imageData.data;
            if (pixel[firstPixel + 3] !== 0) {
                pixel[firstPixel + 3] = Math.round(this.opacity * pixel[firstPixel + 3]);
            }
        };
        return Opacity;
    }());
    exports.Opacity = Opacity;
    /**
     * Applies the "Colorize" effect to a sprite, changing the color channels of all the pixels to an
     * average of the original color and the provided color
     */
    var Colorize = (function () {
        /**
         * @param color  The color to apply to the sprite
         */
        function Colorize(color) {
            this.color = color;
        }
        Colorize.prototype.updatePixel = function (x, y, imageData) {
            var firstPixel = (x + y * imageData.width) * 4;
            var pixel = imageData.data;
            if (pixel[firstPixel + 3] !== 0) {
                pixel[firstPixel + 0] = (pixel[firstPixel + 0] + this.color.r) / 2;
                pixel[firstPixel + 1] = (pixel[firstPixel + 1] + this.color.g) / 2;
                pixel[firstPixel + 2] = (pixel[firstPixel + 2] + this.color.b) / 2;
            }
        };
        return Colorize;
    }());
    exports.Colorize = Colorize;
    /**
     * Applies the "Lighten" effect to a sprite, changes the lightness of the color according to HSL
     */
    var Lighten = (function () {
        /**
         * @param factor  The factor of the effect between 0-1
         */
        function Lighten(factor) {
            if (factor === void 0) { factor = 0.1; }
            this.factor = factor;
        }
        Lighten.prototype.updatePixel = function (x, y, imageData) {
            var firstPixel = (x + y * imageData.width) * 4;
            var pixel = imageData.data;
            var color = Color_8.Color.fromRGB(pixel[firstPixel + 0], pixel[firstPixel + 1], pixel[firstPixel + 2], pixel[firstPixel + 3]).lighten(this.factor);
            pixel[firstPixel + 0] = color.r;
            pixel[firstPixel + 1] = color.g;
            pixel[firstPixel + 2] = color.b;
            pixel[firstPixel + 3] = color.a;
        };
        return Lighten;
    }());
    exports.Lighten = Lighten;
    /**
     * Applies the "Darken" effect to a sprite, changes the darkness of the color according to HSL
     */
    var Darken = (function () {
        /**
         * @param factor  The factor of the effect between 0-1
         */
        function Darken(factor) {
            if (factor === void 0) { factor = 0.1; }
            this.factor = factor;
        }
        Darken.prototype.updatePixel = function (x, y, imageData) {
            var firstPixel = (x + y * imageData.width) * 4;
            var pixel = imageData.data;
            var color = Color_8.Color.fromRGB(pixel[firstPixel + 0], pixel[firstPixel + 1], pixel[firstPixel + 2], pixel[firstPixel + 3]).darken(this.factor);
            pixel[firstPixel + 0] = color.r;
            pixel[firstPixel + 1] = color.g;
            pixel[firstPixel + 2] = color.b;
            pixel[firstPixel + 3] = color.a;
        };
        return Darken;
    }());
    exports.Darken = Darken;
    /**
     * Applies the "Saturate" effect to a sprite, saturates the color according to HSL
     */
    var Saturate = (function () {
        /**
         * @param factor  The factor of the effect between 0-1
         */
        function Saturate(factor) {
            if (factor === void 0) { factor = 0.1; }
            this.factor = factor;
        }
        Saturate.prototype.updatePixel = function (x, y, imageData) {
            var firstPixel = (x + y * imageData.width) * 4;
            var pixel = imageData.data;
            var color = Color_8.Color.fromRGB(pixel[firstPixel + 0], pixel[firstPixel + 1], pixel[firstPixel + 2], pixel[firstPixel + 3]).saturate(this.factor);
            pixel[firstPixel + 0] = color.r;
            pixel[firstPixel + 1] = color.g;
            pixel[firstPixel + 2] = color.b;
            pixel[firstPixel + 3] = color.a;
        };
        return Saturate;
    }());
    exports.Saturate = Saturate;
    /**
     * Applies the "Desaturate" effect to a sprite, desaturates the color according to HSL
     */
    var Desaturate = (function () {
        /**
         * @param factor  The factor of the effect between 0-1
         */
        function Desaturate(factor) {
            if (factor === void 0) { factor = 0.1; }
            this.factor = factor;
        }
        Desaturate.prototype.updatePixel = function (x, y, imageData) {
            var firstPixel = (x + y * imageData.width) * 4;
            var pixel = imageData.data;
            var color = Color_8.Color.fromRGB(pixel[firstPixel + 0], pixel[firstPixel + 1], pixel[firstPixel + 2], pixel[firstPixel + 3]).desaturate(this.factor);
            pixel[firstPixel + 0] = color.r;
            pixel[firstPixel + 1] = color.g;
            pixel[firstPixel + 2] = color.b;
            pixel[firstPixel + 3] = color.a;
        };
        return Desaturate;
    }());
    exports.Desaturate = Desaturate;
    /**
     * Applies the "Fill" effect to a sprite, changing the color channels of all non-transparent pixels to match
     * a given color
     */
    var Fill = (function () {
        /**
         * @param color  The color to apply to the sprite
         */
        function Fill(color) {
            this.color = color;
        }
        Fill.prototype.updatePixel = function (x, y, imageData) {
            var firstPixel = (x + y * imageData.width) * 4;
            var pixel = imageData.data;
            if (pixel[firstPixel + 3] !== 0) {
                pixel[firstPixel + 0] = this.color.r;
                pixel[firstPixel + 1] = this.color.g;
                pixel[firstPixel + 2] = this.color.b;
            }
        };
        return Fill;
    }());
    exports.Fill = Fill;
});
define("Interfaces/IDrawable", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Interfaces/ILoadable", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Resources/Resource", ["require", "exports", "Class", "Promises", "Util/Log"], function (require, exports, Class_2, Promises_3, Log_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The [[Resource]] type allows games built in Excalibur to load generic resources.
     * For any type of remote resource it is recommended to use [[Resource]] for preloading.
     *
     * [[include:Resources.md]]
     */
    var Resource = (function (_super) {
        __extends(Resource, _super);
        /**
         * @param path          Path to the remote resource
         * @param responseType  The type to expect as a response: "" | "arraybuffer" | "blob" | "document" | "json" | "text";
         * @param bustCache     Whether or not to cache-bust requests
         */
        function Resource(path, responseType, bustCache) {
            if (bustCache === void 0) { bustCache = true; }
            var _this = _super.call(this) || this;
            _this.path = path;
            _this.responseType = responseType;
            _this.bustCache = bustCache;
            _this.data = null;
            _this.logger = Log_2.Logger.getInstance();
            _this.onprogress = function () { return; };
            _this.oncomplete = function () { return; };
            _this.onerror = function () { return; };
            return _this;
        }
        /**
         * Returns true if the Resource is completely loaded and is ready
         * to be drawn.
         */
        Resource.prototype.isLoaded = function () {
            return this.data !== null;
        };
        Resource.prototype.wireEngine = function (_engine) {
            // override me
        };
        Resource.prototype._cacheBust = function (uri) {
            var query = /\?\w*=\w*/;
            if (query.test(uri)) {
                uri += ('&__=' + Date.now());
            }
            else {
                uri += ('?__=' + Date.now());
            }
            return uri;
        };
        Resource.prototype._start = function () {
            this.logger.debug('Started loading resource ' + this.path);
        };
        /**
         * Begin loading the resource and returns a promise to be resolved on completion
         */
        Resource.prototype.load = function () {
            var _this = this;
            var complete = new Promises_3.Promise();
            // Exit early if we already have data
            if (this.data !== null) {
                this.logger.debug('Already have data for resource', this.path);
                complete.resolve(this.data);
                this.oncomplete();
                return complete;
            }
            var request = new XMLHttpRequest();
            request.open('GET', this.bustCache ? this._cacheBust(this.path) : this.path, true);
            request.responseType = this.responseType;
            request.onloadstart = function () { _this._start(); };
            request.onprogress = this.onprogress;
            request.onerror = this.onerror;
            request.onload = function () {
                // XHR on file:// success status is 0, such as with PhantomJS
                if (request.status !== 0 && request.status !== 200) {
                    _this.logger.error('Failed to load resource ', _this.path, ' server responded with error code', request.status);
                    _this.onerror(request.response);
                    complete.resolve(request.response);
                    return;
                }
                _this.data = _this.processData(request.response);
                _this.oncomplete();
                _this.logger.debug('Completed loading resource', _this.path);
                complete.resolve(_this.data);
            };
            request.send();
            return complete;
        };
        /**
         * Returns the loaded data once the resource is loaded
         */
        Resource.prototype.getData = function () {
            return this.data;
        };
        /**
         * Sets the data for this resource directly
         */
        Resource.prototype.setData = function (data) {
            this.data = this.processData(data);
        };
        /**
         * This method is meant to be overriden to handle any additional
         * processing. Such as decoding downloaded audio bits.
         */
        Resource.prototype.processData = function (data) {
            // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseType
            // Blob requires an object url
            if (this.responseType === 'blob') {
                return URL.createObjectURL(data);
            }
            return data;
        };
        return Resource;
    }(Class_2.Class));
    exports.Resource = Resource;
});
define("Resources/Texture", ["require", "exports", "Resources/Resource", "Promises", "Drawing/Sprite"], function (require, exports, Resource_1, Promises_4, Sprite_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The [[Texture]] object allows games built in Excalibur to load image resources.
     * [[Texture]] is an [[ILoadable]] which means it can be passed to a [[Loader]]
     * to pre-load before starting a level or game.
     *
     * [[include:Textures.md]]
     */
    var Texture = (function (_super) {
        __extends(Texture, _super);
        /**
         * @param path       Path to the image resource
         * @param bustCache  Optionally load texture with cache busting
         */
        function Texture(path, bustCache) {
            if (bustCache === void 0) { bustCache = true; }
            var _this = _super.call(this, path, 'blob', bustCache) || this;
            _this.path = path;
            _this.bustCache = bustCache;
            /**
             * A [[Promise]] that resolves when the Texture is loaded.
             */
            _this.loaded = new Promises_4.Promise();
            _this._isLoaded = false;
            _this._sprite = null;
            _this._sprite = new Sprite_1.Sprite(_this, 0, 0, 0, 0);
            return _this;
        }
        /**
         * Returns true if the Texture is completely loaded and is ready
         * to be drawn.
         */
        Texture.prototype.isLoaded = function () {
            return this._isLoaded;
        };
        /**
         * Begins loading the texture and returns a promise to be resolved on completion
         */
        Texture.prototype.load = function () {
            var _this = this;
            var complete = new Promises_4.Promise();
            var loaded = _super.prototype.load.call(this);
            loaded.then(function () {
                _this.image = new Image();
                _this.image.addEventListener('load', function () {
                    _this._isLoaded = true;
                    _this.width = _this._sprite.swidth = _this._sprite.naturalWidth = _this._sprite.width = _this.image.naturalWidth;
                    _this.height = _this._sprite.sheight = _this._sprite.naturalHeight = _this._sprite.height = _this.image.naturalHeight;
                    _this.loaded.resolve(_this.image);
                    complete.resolve(_this.image);
                });
                _this.image.src = _super.prototype.getData.call(_this);
            }, function () {
                complete.reject('Error loading texture.');
            });
            return complete;
        };
        Texture.prototype.asSprite = function () {
            return this._sprite;
        };
        return Texture;
    }(Resource_1.Resource));
    exports.Texture = Texture;
});
define("Drawing/Sprite", ["require", "exports", "Drawing/SpriteEffects", "Drawing/Color", "Resources/Texture", "Algebra", "Util/Log", "Util/Util", "Configurable"], function (require, exports, Effects, Color_9, Texture_1, Algebra_11, Log_3, Util_2, Configurable_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @hidden
     */
    var SpriteImpl = (function () {
        /**
         * @param image   The backing image texture to build the Sprite
         * @param sx      The x position of the sprite
         * @param sy      The y position of the sprite
         * @param swidth  The width of the sprite in pixels
         * @param sheight The height of the sprite in pixels
         */
        function SpriteImpl(imageOrConfig, sx, sy, swidth, sheight) {
            var _this = this;
            this.rotation = 0.0;
            this.anchor = new Algebra_11.Vector(0.0, 0.0);
            this.scale = new Algebra_11.Vector(1, 1);
            this.logger = Log_3.Logger.getInstance();
            /**
             * Draws the sprite flipped vertically
             */
            this.flipVertical = false;
            /**
             * Draws the sprite flipped horizontally
             */
            this.flipHorizontal = false;
            this.width = 0;
            this.height = 0;
            this.effects = [];
            this.sx = 0;
            this.sy = 0;
            this.swidth = 0;
            this.sheight = 0;
            this.naturalWidth = 0;
            this.naturalHeight = 0;
            this._spriteCanvas = null;
            this._spriteCtx = null;
            this._pixelData = null;
            this._pixelsLoaded = false;
            this._dirtyEffect = false;
            if (sx < 0 || sy < 0 || swidth < 0 || sheight < 0) {
                this.logger.error('Sprite cannot have any negative dimensions x:', sx, 'y:', sy, 'width:', swidth, 'height:', sheight);
            }
            var image = imageOrConfig;
            if (imageOrConfig && !(imageOrConfig instanceof Texture_1.Texture)) {
                sx = imageOrConfig.sx;
                sy = imageOrConfig.sy;
                swidth = imageOrConfig.swidth;
                sheight = imageOrConfig.sheight;
                image = imageOrConfig.image;
            }
            this.sx = sx || 0;
            this.sy = sy || 0;
            this.swidth = swidth || 0;
            this.sheight = sheight || 0;
            this._texture = image;
            this._spriteCanvas = document.createElement('canvas');
            this._spriteCanvas.width = swidth;
            this._spriteCanvas.height = sheight;
            this._spriteCtx = this._spriteCanvas.getContext('2d');
            this._texture.loaded.then(function () {
                _this._spriteCanvas.width = _this._spriteCanvas.width || _this._texture.image.naturalWidth;
                _this._spriteCanvas.height = _this._spriteCanvas.height || _this._texture.image.naturalHeight;
                _this._loadPixels();
                _this._dirtyEffect = true;
            }).error(function (e) {
                _this.logger.error('Error loading texture ', _this._texture.path, e);
            });
            this.width = swidth;
            this.height = sheight;
            this.naturalWidth = swidth;
            this.naturalHeight = sheight;
        }
        SpriteImpl.prototype._loadPixels = function () {
            if (this._texture.isLoaded() && !this._pixelsLoaded) {
                var naturalWidth = this._texture.image.naturalWidth || 0;
                var naturalHeight = this._texture.image.naturalHeight || 0;
                if (this.swidth > naturalWidth) {
                    this.logger.warn('The sprite width', this.swidth, 'exceeds the width', naturalWidth, 'of the backing texture', this._texture.path);
                }
                if (this.sheight > naturalHeight) {
                    this.logger.warn('The sprite height', this.sheight, 'exceeds the height', naturalHeight, 'of the backing texture', this._texture.path);
                }
                this._spriteCtx.drawImage(this._texture.image, Util_2.clamp(this.sx, 0, naturalWidth), Util_2.clamp(this.sy, 0, naturalHeight), Util_2.clamp(this.swidth, 0, naturalWidth), Util_2.clamp(this.sheight, 0, naturalHeight), 0, 0, this.swidth, this.sheight);
                this._pixelsLoaded = true;
            }
        };
        /**
         * Applies the [[Opacity]] effect to a sprite, setting the alpha of all pixels to a given value
         */
        SpriteImpl.prototype.opacity = function (value) {
            this.addEffect(new Effects.Opacity(value));
        };
        /**
         * Applies the [[Grayscale]] effect to a sprite, removing color information.
         */
        SpriteImpl.prototype.grayscale = function () {
            this.addEffect(new Effects.Grayscale());
        };
        /**
         * Applies the [[Invert]] effect to a sprite, inverting the pixel colors.
         */
        SpriteImpl.prototype.invert = function () {
            this.addEffect(new Effects.Invert());
        };
        /**
         * Applies the [[Fill]] effect to a sprite, changing the color channels of all non-transparent pixels to match a given color
         */
        SpriteImpl.prototype.fill = function (color) {
            this.addEffect(new Effects.Fill(color));
        };
        /**
         * Applies the [[Colorize]] effect to a sprite, changing the color channels of all pixels to be the average of the original color
         * and the provided color.
         */
        SpriteImpl.prototype.colorize = function (color) {
            this.addEffect(new Effects.Colorize(color));
        };
        /**
         * Applies the [[Lighten]] effect to a sprite, changes the lightness of the color according to HSL
         */
        SpriteImpl.prototype.lighten = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            this.addEffect(new Effects.Lighten(factor));
        };
        /**
         * Applies the [[Darken]] effect to a sprite, changes the darkness of the color according to HSL
         */
        SpriteImpl.prototype.darken = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            this.addEffect(new Effects.Darken(factor));
        };
        /**
         * Applies the [[Saturate]] effect to a sprite, saturates the color according to HSL
         */
        SpriteImpl.prototype.saturate = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            this.addEffect(new Effects.Saturate(factor));
        };
        /**
         * Applies the [[Desaturate]] effect to a sprite, desaturates the color according to HSL
         */
        SpriteImpl.prototype.desaturate = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            this.addEffect(new Effects.Desaturate(factor));
        };
        /**
         * Adds a new [[ISpriteEffect]] to this drawing.
         * @param effect  Effect to add to the this drawing
         */
        SpriteImpl.prototype.addEffect = function (effect) {
            this.effects.push(effect);
            // We must check if the texture and the backing sprite pixels are loaded as well before 
            // an effect can be applied
            if (!this._texture.isLoaded() || !this._pixelsLoaded) {
                this._dirtyEffect = true;
            }
            else {
                this._applyEffects();
            }
        };
        SpriteImpl.prototype.removeEffect = function (param) {
            var indexToRemove = -1;
            if (typeof param === 'number') {
                indexToRemove = param;
            }
            else {
                indexToRemove = this.effects.indexOf(param);
            }
            // bounds check
            if (indexToRemove < 0 || indexToRemove >= this.effects.length) {
                return;
            }
            this.effects.splice(indexToRemove, 1);
            // We must check if the texture and the backing sprite pixels are loaded as well before 
            // an effect can be applied
            if (!this._texture.isLoaded() || !this._pixelsLoaded) {
                this._dirtyEffect = true;
            }
            else {
                this._applyEffects();
            }
        };
        SpriteImpl.prototype._applyEffects = function () {
            var naturalWidth = this._texture.image.naturalWidth || 0;
            var naturalHeight = this._texture.image.naturalHeight || 0;
            this._spriteCtx.clearRect(0, 0, this.swidth, this.sheight);
            this._spriteCtx.drawImage(this._texture.image, Util_2.clamp(this.sx, 0, naturalWidth), Util_2.clamp(this.sy, 0, naturalHeight), Util_2.clamp(this.swidth, 0, naturalWidth), Util_2.clamp(this.sheight, 0, naturalHeight), 0, 0, this.swidth, this.sheight);
            this._pixelData = this._spriteCtx.getImageData(0, 0, this.swidth, this.sheight);
            var i = 0, x = 0, y = 0, len = this.effects.length;
            for (i; i < len; i++) {
                y = 0;
                for (y; y < this.sheight; y++) {
                    x = 0;
                    for (x; x < this.swidth; x++) {
                        this.effects[i].updatePixel(x, y, this._pixelData);
                    }
                }
            }
            this._spriteCtx.clearRect(0, 0, this.swidth, this.sheight);
            this._spriteCtx.putImageData(this._pixelData, 0, 0);
            this._dirtyEffect = false;
        };
        /**
         * Clears all effects from the drawing and return it to its original state.
         */
        SpriteImpl.prototype.clearEffects = function () {
            this.effects.length = 0;
            this._applyEffects();
        };
        /**
         * Resets the internal state of the drawing (if any)
         */
        SpriteImpl.prototype.reset = function () {
            // do nothing
        };
        SpriteImpl.prototype.debugDraw = function (ctx, x, y) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(this.rotation);
            var scaledSWidth = this.width * this.scale.x;
            var scaledSHeight = this.height * this.scale.y;
            var xpoint = (scaledSWidth) * this.anchor.x;
            var ypoint = (scaledSHeight) * this.anchor.y;
            ctx.strokeStyle = Color_9.Color.Black.toString();
            ctx.strokeRect(-xpoint, -ypoint, scaledSWidth, scaledSHeight);
            ctx.restore();
        };
        /**
         * Draws the sprite appropriately to the 2D rendering context, at an x and y coordinate.
         * @param ctx  The 2D rendering context
         * @param x    The x coordinate of where to draw
         * @param y    The y coordinate of where to draw
         */
        SpriteImpl.prototype.draw = function (ctx, x, y) {
            if (this._dirtyEffect) {
                this._applyEffects();
            }
            // calculating current dimensions
            this.width = this.naturalWidth * this.scale.x;
            this.height = this.naturalHeight * this.scale.y;
            ctx.save();
            var xpoint = this.width * this.anchor.x;
            var ypoint = this.height * this.anchor.y;
            ctx.translate(x, y);
            ctx.rotate(this.rotation);
            var scaledSWidth = this.swidth * this.scale.x;
            var scaledSHeight = this.sheight * this.scale.y;
            // todo cache flipped sprites
            if (this.flipHorizontal) {
                ctx.translate(scaledSWidth, 0);
                ctx.scale(-1, 1);
            }
            if (this.flipVertical) {
                ctx.translate(0, scaledSHeight);
                ctx.scale(1, -1);
            }
            ctx.drawImage(this._spriteCanvas, 0, 0, this.swidth, this.sheight, -xpoint, -ypoint, scaledSWidth, scaledSHeight);
            ctx.restore();
        };
        /**
         * Produces a copy of the current sprite
         */
        SpriteImpl.prototype.clone = function () {
            var result = new Sprite(this._texture, this.sx, this.sy, this.swidth, this.sheight);
            result.scale = this.scale.clone();
            result.rotation = this.rotation;
            result.flipHorizontal = this.flipHorizontal;
            result.flipVertical = this.flipVertical;
            var i = 0, len = this.effects.length;
            for (i; i < len; i++) {
                result.addEffect(this.effects[i]);
            }
            return result;
        };
        return SpriteImpl;
    }());
    exports.SpriteImpl = SpriteImpl;
    /**
     * A [[Sprite]] is one of the main drawing primitives. It is responsible for drawing
     * images or parts of images from a [[Texture]] resource to the screen.
     *
     * [[include:Sprites.md]]
     */
    var Sprite = (function (_super) {
        __extends(Sprite, _super);
        function Sprite(imageOrConfig, sx, sy, swidth, sheight) {
            return _super.call(this, imageOrConfig, sx, sy, swidth, sheight) || this;
        }
        return Sprite;
    }(Configurable_1.Configurable(SpriteImpl)));
    exports.Sprite = Sprite;
});
define("Drawing/Animation", ["require", "exports", "Drawing/SpriteEffects", "Algebra", "Engine", "Util/Util", "Configurable"], function (require, exports, Effects, Algebra_12, Engine_1, Util, Configurable_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @hidden
     */
    var AnimationImpl = (function () {
        /**
         * Typically you will use a [[SpriteSheet]] to generate an [[Animation]].
         *
         * @param engine  Reference to the current game engine
         * @param images  An array of sprites to create the frames for the animation
         * @param speed   The number in milliseconds to display each frame in the animation
         * @param loop    Indicates whether the animation should loop after it is completed
         */
        function AnimationImpl(engineOrConfig, sprites, speed, loop) {
            /**
             * The sprite frames to play, in order. See [[SpriteSheet.getAnimationForAll]] to quickly
             * generate an [[Animation]].
             */
            this.sprites = [];
            /**
             * Current frame index being shown
             */
            this.currentFrame = 0;
            this._oldTime = Date.now();
            this.anchor = new Algebra_12.Vector(0.0, 0.0);
            this.rotation = 0.0;
            this.scale = new Algebra_12.Vector(1, 1);
            /**
             * Indicates whether the animation should loop after it is completed
             */
            this.loop = true;
            /**
             * Indicates the frame index the animation should freeze on for a non-looping
             * animation. By default it is the last frame.
             */
            this.freezeFrame = -1;
            /**
             * Flip each frame vertically. Sets [[Sprite.flipVertical]].
             */
            this.flipVertical = false;
            /**
             * Flip each frame horizontally. Sets [[Sprite.flipHorizontal]].
             */
            this.flipHorizontal = false;
            this.width = 0;
            this.height = 0;
            this.naturalWidth = 0;
            this.naturalHeight = 0;
            var engine = engineOrConfig;
            if (engineOrConfig && !(engineOrConfig instanceof Engine_1.Engine)) {
                var config = engineOrConfig;
                engine = config.engine;
                sprites = config.sprites;
                speed = config.speed;
                loop = config.loop;
            }
            this.sprites = sprites;
            this.speed = speed;
            this._engine = engine;
            if (loop != null) {
                this.loop = loop;
            }
            if (sprites && sprites[0]) {
                this.height = sprites[0] ? sprites[0].height : 0;
                this.width = sprites[0] ? sprites[0].width : 0;
                this.naturalWidth = sprites[0] ? sprites[0].naturalWidth : 0;
                this.naturalHeight = sprites[0] ? sprites[0].naturalHeight : 0;
                this.freezeFrame = sprites.length - 1;
            }
        }
        /**
         * Applies the opacity effect to a sprite, setting the alpha of all pixels to a given value
         */
        AnimationImpl.prototype.opacity = function (value) {
            this.addEffect(new Effects.Opacity(value));
        };
        /**
         * Applies the grayscale effect to a sprite, removing color information.
         */
        AnimationImpl.prototype.grayscale = function () {
            this.addEffect(new Effects.Grayscale());
        };
        /**
         * Applies the invert effect to a sprite, inverting the pixel colors.
         */
        AnimationImpl.prototype.invert = function () {
            this.addEffect(new Effects.Invert());
        };
        /**
         * Applies the fill effect to a sprite, changing the color channels of all non-transparent pixels to match a given color
         */
        AnimationImpl.prototype.fill = function (color) {
            this.addEffect(new Effects.Fill(color));
        };
        /**
         * Applies the colorize effect to a sprite, changing the color channels of all pixels to be the average of the original color and the
         * provided color.
         */
        AnimationImpl.prototype.colorize = function (color) {
            this.addEffect(new Effects.Colorize(color));
        };
        /**
         * Applies the lighten effect to a sprite, changes the lightness of the color according to hsl
         */
        AnimationImpl.prototype.lighten = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            this.addEffect(new Effects.Lighten(factor));
        };
        /**
         * Applies the darken effect to a sprite, changes the darkness of the color according to hsl
         */
        AnimationImpl.prototype.darken = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            this.addEffect(new Effects.Darken(factor));
        };
        /**
         * Applies the saturate effect to a sprite, saturates the color according to hsl
         */
        AnimationImpl.prototype.saturate = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            this.addEffect(new Effects.Saturate(factor));
        };
        /**
         * Applies the desaturate effect to a sprite, desaturates the color according to hsl
         */
        AnimationImpl.prototype.desaturate = function (factor) {
            if (factor === void 0) { factor = 0.1; }
            this.addEffect(new Effects.Desaturate(factor));
        };
        /**
         * Add a [[ISpriteEffect]] manually
         */
        AnimationImpl.prototype.addEffect = function (effect) {
            for (var i in this.sprites) {
                this.sprites[i].addEffect(effect);
            }
        };
        AnimationImpl.prototype.removeEffect = function (param) {
            for (var i in this.sprites) {
                this.sprites[i].removeEffect(param);
            }
        };
        /**
         * Clear all sprite effects
         */
        AnimationImpl.prototype.clearEffects = function () {
            for (var i in this.sprites) {
                this.sprites[i].clearEffects();
            }
        };
        AnimationImpl.prototype._setAnchor = function (point) {
            //if (!this.anchor.equals(point)) {
            for (var i in this.sprites) {
                this.sprites[i].anchor.setTo(point.x, point.y);
            }
            //}
        };
        AnimationImpl.prototype._setRotation = function (radians) {
            //if (this.rotation !== radians) {
            for (var i in this.sprites) {
                this.sprites[i].rotation = radians;
            }
            //}
        };
        AnimationImpl.prototype._setScale = function (scale) {
            //if (!this.scale.equals(scale)) {
            for (var i in this.sprites) {
                this.sprites[i].scale = scale;
            }
            //}
        };
        /**
         * Resets the animation to first frame.
         */
        AnimationImpl.prototype.reset = function () {
            this.currentFrame = 0;
        };
        /**
         * Indicates whether the animation is complete, animations that loop are never complete.
         */
        AnimationImpl.prototype.isDone = function () {
            return (!this.loop && this.currentFrame >= this.sprites.length);
        };
        /**
         * Not meant to be called by game developers. Ticks the animation forward internally and
         * calculates whether to change to the frame.
         * @internal
         */
        AnimationImpl.prototype.tick = function () {
            var time = Date.now();
            if ((time - this._oldTime) > this.speed) {
                this.currentFrame = (this.loop ? (this.currentFrame + 1) % this.sprites.length : this.currentFrame + 1);
                this._oldTime = time;
            }
        };
        AnimationImpl.prototype._updateValues = function () {
            this._setAnchor(this.anchor);
            this._setRotation(this.rotation);
            this._setScale(this.scale);
        };
        /**
         * Skips ahead a specified number of frames in the animation
         * @param frames  Frames to skip ahead
         */
        AnimationImpl.prototype.skip = function (frames) {
            this.currentFrame = (this.currentFrame + frames) % this.sprites.length;
        };
        AnimationImpl.prototype.draw = function (ctx, x, y) {
            this.tick();
            this._updateValues();
            var currSprite;
            if (this.currentFrame < this.sprites.length) {
                currSprite = this.sprites[this.currentFrame];
                if (this.flipVertical) {
                    currSprite.flipVertical = this.flipVertical;
                }
                if (this.flipHorizontal) {
                    currSprite.flipHorizontal = this.flipHorizontal;
                }
                currSprite.draw(ctx, x, y);
            }
            if (this.freezeFrame !== -1 && this.currentFrame >= this.sprites.length) {
                currSprite = this.sprites[Util.clamp(this.freezeFrame, 0, this.sprites.length - 1)];
                currSprite.draw(ctx, x, y);
            }
            // add the calculated width
            if (currSprite) {
                this.width = currSprite.width;
                this.height = currSprite.height;
            }
        };
        /**
         * Plays an animation at an arbitrary location in the game.
         * @param x  The x position in the game to play
         * @param y  The y position in the game to play
         */
        AnimationImpl.prototype.play = function (x, y) {
            this.reset();
            this._engine.playAnimation(this, x, y);
        };
        return AnimationImpl;
    }());
    exports.AnimationImpl = AnimationImpl;
    /**
     * Animations allow you to display a series of images one after another,
     * creating the illusion of change. Generally these images will come from a [[SpriteSheet]] source.
     *
     * [[include:Animations.md]]
     */
    var Animation = (function (_super) {
        __extends(Animation, _super);
        function Animation(engineOrConfig, images, speed, loop) {
            return _super.call(this, engineOrConfig, images, speed, loop) || this;
        }
        return Animation;
    }(Configurable_2.Configurable(AnimationImpl)));
    exports.Animation = Animation;
});
define("Drawing/SpriteSheet", ["require", "exports", "Drawing/Sprite", "Drawing/Animation", "Drawing/Color", "Drawing/SpriteEffects", "Resources/Texture", "Util/Log", "Label", "Configurable"], function (require, exports, Sprite_2, Animation_1, Color_10, Effects, Texture_2, Log_4, Label_1, Configurable_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @hidden
     */
    var SpriteSheetImpl = (function () {
        /**
         * @param image     The backing image texture to build the SpriteSheet
         * @param columns   The number of columns in the image texture
         * @param rows      The number of rows in the image texture
         * @param spWidth   The width of each individual sprite in pixels
         * @param spHeight  The height of each individual sprite in pixels
         */
        function SpriteSheetImpl(imageOrConfigOrSprites, columns, rows, spWidth, spHeight) {
            this.sprites = [];
            this.image = null;
            this.columns = 0;
            this.rows = 0;
            var loadFromImage = false;
            if (imageOrConfigOrSprites instanceof Array) {
                this.sprites = imageOrConfigOrSprites;
            }
            else {
                if (imageOrConfigOrSprites && !(imageOrConfigOrSprites instanceof Texture_2.Texture)) {
                    this.columns = imageOrConfigOrSprites.columns;
                    this.rows = imageOrConfigOrSprites.rows;
                    this.spWidth = imageOrConfigOrSprites.spWidth;
                    this.spHeight = imageOrConfigOrSprites.spHeight;
                    this.image = imageOrConfigOrSprites.image;
                }
                else {
                    this.image = imageOrConfigOrSprites;
                    this.columns = columns;
                    this.rows = rows;
                    this.spWidth = spWidth;
                    this.spHeight = spHeight;
                }
                this.sprites = new Array(this.columns * this.rows);
                loadFromImage = true;
            }
            // TODO: Inspect actual image dimensions with preloading
            /*if(spWidth * columns > this.internalImage.naturalWidth){
               throw new Error("SpriteSheet specified is wider than image width");
            }
      
            if(spHeight * rows > this.internalImage.naturalHeight){
               throw new Error("SpriteSheet specified is higher than image height");
            }*/
            if (loadFromImage) {
                var i = 0;
                var j = 0;
                for (i = 0; i < this.rows; i++) {
                    for (j = 0; j < this.columns; j++) {
                        this.sprites[j + i * this.columns] = new Sprite_2.Sprite(this.image, j * this.spWidth, i * this.spHeight, this.spWidth, this.spHeight);
                    }
                }
            }
        }
        /**
         * Create an animation from the this SpriteSheet by listing out the
         * sprite indices. Sprites are organized in row major order in the SpriteSheet.
         * @param engine   Reference to the current game [[Engine]]
         * @param indices  An array of sprite indices to use in the animation
         * @param speed    The number in milliseconds to display each frame in the animation
         */
        SpriteSheetImpl.prototype.getAnimationByIndices = function (engine, indices, speed) {
            var _this = this;
            var images = indices.map(function (index) {
                return _this.sprites[index];
            });
            images = images.map(function (i) {
                return i.clone();
            });
            return new Animation_1.Animation(engine, images, speed);
        };
        /**
         * Create an animation from the this SpriteSheet by specifing the range of
         * images with the beginning (inclusive) and ending (exclusive) index
         * For example `getAnimationBetween(engine, 0, 5, 200)` returns an animation with 5 frames.
         * @param engine      Reference to the current game Engine
         * @param beginIndex  The index to start taking frames (inclusive)
         * @param endIndex    The index to stop taking frames (exclusive)
         * @param speed       The number in milliseconds to display each frame in the animation
         */
        SpriteSheetImpl.prototype.getAnimationBetween = function (engine, beginIndex, endIndex, speed) {
            var images = this.sprites.slice(beginIndex, endIndex);
            images = images.map(function (i) {
                return i.clone();
            });
            return new Animation_1.Animation(engine, images, speed);
        };
        /**
         * Treat the entire SpriteSheet as one animation, organizing the frames in
         * row major order.
         * @param engine  Reference to the current game [[Engine]]
         * @param speed   The number in milliseconds to display each frame the animation
         */
        SpriteSheetImpl.prototype.getAnimationForAll = function (engine, speed) {
            var sprites = this.sprites.map(function (i) {
                return i.clone();
            });
            return new Animation_1.Animation(engine, sprites, speed);
        };
        /**
         * Retreive a specific sprite from the SpriteSheet by its index. Sprites are organized
         * in row major order in the SpriteSheet.
         * @param index  The index of the sprite
         */
        SpriteSheetImpl.prototype.getSprite = function (index) {
            if (index >= 0 && index < this.sprites.length) {
                return this.sprites[index];
            }
            else {
                throw new Error('Invalid index: ' + index);
            }
        };
        return SpriteSheetImpl;
    }());
    exports.SpriteSheetImpl = SpriteSheetImpl;
    /**
     * Sprite sheets are a useful mechanism for slicing up image resources into
     * separate sprites or for generating in game animations. [[Sprite|Sprites]] are organized
     * in row major order in the [[SpriteSheet]].
     *
     * [[include:SpriteSheets.md]]
     */
    var SpriteSheet = (function (_super) {
        __extends(SpriteSheet, _super);
        function SpriteSheet(imageOrConfigOrSprites, columns, rows, spWidth, spHeight) {
            return _super.call(this, imageOrConfigOrSprites, columns, rows, spWidth, spHeight) || this;
        }
        return SpriteSheet;
    }(Configurable_3.Configurable(SpriteSheetImpl)));
    exports.SpriteSheet = SpriteSheet;
    var SpriteFontImpl = (function (_super) {
        __extends(SpriteFontImpl, _super);
        /**
         * @param image           The backing image texture to build the SpriteFont
         * @param alphabet        A string representing all the characters in the image, in row major order.
         * @param caseInsensitive  Indicate whether this font takes case into account
         * @param columns         The number of columns of characters in the image
         * @param rows            The number of rows of characters in the image
         * @param spWidth         The width of each character in pixels
         * @param spHeight        The height of each character in pixels
         */
        function SpriteFontImpl(imageOrConfig, alphabet, caseInsensitive, columns, rows, spWidth, spHeight) {
            var _this = _super.call(this, imageOrConfig instanceof Texture_2.Texture ? { image: imageOrConfig, spWidth: spWidth,
                spHeight: spHeight, rows: rows, columns: columns } : imageOrConfig) || this;
            _this._currentColor = Color_10.Color.Black.clone();
            _this._currentOpacity = 1.0;
            _this._sprites = {};
            // text shadow
            _this._textShadowOn = false;
            _this._textShadowDirty = true;
            _this._textShadowColor = Color_10.Color.Black.clone();
            _this._textShadowSprites = {};
            _this._shadowOffsetX = 5;
            _this._shadowOffsetY = 5;
            if (imageOrConfig && !(imageOrConfig instanceof Texture_2.Texture)) {
                alphabet = imageOrConfig.alphabet;
                caseInsensitive = imageOrConfig.caseInsensitive;
            }
            _this._alphabet = alphabet;
            _this._caseInsensitive = caseInsensitive;
            _this._sprites = _this.getTextSprites();
            return _this;
        }
        /**
         * Returns a dictionary that maps each character in the alphabet to the appropriate [[Sprite]].
         */
        SpriteFontImpl.prototype.getTextSprites = function () {
            var lookup = {};
            for (var i = 0; i < this._alphabet.length; i++) {
                var char = this._alphabet[i];
                if (this._caseInsensitive) {
                    char = char.toLowerCase();
                }
                lookup[char] = this.sprites[i].clone();
            }
            return lookup;
        };
        /**
         * Sets the text shadow for sprite fonts
         * @param offsetX      The x offset in pixels to place the shadow
         * @param offsetY      The y offset in pixels to place the shadow
         * @param shadowColor  The color of the text shadow
         */
        SpriteFontImpl.prototype.setTextShadow = function (offsetX, offsetY, shadowColor) {
            this._textShadowOn = true;
            this._shadowOffsetX = offsetX;
            this._shadowOffsetY = offsetY;
            this._textShadowColor = shadowColor.clone();
            this._textShadowDirty = true;
            for (var character in this._sprites) {
                this._textShadowSprites[character] = this._sprites[character].clone();
            }
        };
        /**
         * Toggles text shadows on or off
         */
        SpriteFontImpl.prototype.useTextShadow = function (on) {
            this._textShadowOn = on;
            if (on) {
                this.setTextShadow(5, 5, this._textShadowColor);
            }
        };
        /**
         * Draws the current sprite font
         */
        SpriteFontImpl.prototype.draw = function (ctx, text, x, y, options) {
            options = this._parseOptions(options);
            if (this._currentColor.toString() !== options.color.toString() || this._currentOpacity !== options.opacity) {
                this._currentOpacity = options.opacity;
                this._currentColor = options.color;
                for (var char in this._sprites) {
                    this._sprites[char].clearEffects();
                    this._sprites[char].fill(options.color);
                    this._sprites[char].opacity(options.opacity);
                }
            }
            if (this._textShadowOn && this._textShadowDirty && this._textShadowColor) {
                for (var characterShadow in this._textShadowSprites) {
                    this._textShadowSprites[characterShadow].clearEffects();
                    this._textShadowSprites[characterShadow].addEffect(new Effects.Fill(this._textShadowColor.clone()));
                }
                this._textShadowDirty = false;
            }
            // find the current length of text in pixels
            var sprite = this.sprites[0];
            // find the current height fo the text in pixels
            var height = sprite.sheight;
            // calculate appropriate scale for font size
            var scale = options.fontSize / height;
            var length = (text.length * sprite.swidth * scale) + (text.length * options.letterSpacing);
            var currX = x;
            if (options.textAlign === Label_1.TextAlign.Left || options.textAlign === Label_1.TextAlign.Start) {
                currX = x;
            }
            else if (options.textAlign === Label_1.TextAlign.Right || options.textAlign === Label_1.TextAlign.End) {
                currX = x - length;
            }
            else if (options.textAlign === Label_1.TextAlign.Center) {
                currX = x - length / 2;
            }
            var currY = y - height * scale;
            if (options.baseAlign === Label_1.BaseAlign.Top || options.baseAlign === Label_1.BaseAlign.Hanging) {
                currY = y;
            }
            else if (options.baseAlign === Label_1.BaseAlign.Ideographic ||
                options.baseAlign === Label_1.BaseAlign.Bottom ||
                options.baseAlign === Label_1.BaseAlign.Alphabetic) {
                currY = y - height * scale;
            }
            else if (options.baseAlign === Label_1.BaseAlign.Middle) {
                currY = y - (height * scale) / 2;
            }
            for (var i = 0; i < text.length; i++) {
                var character = text[i];
                if (this._caseInsensitive) {
                    character = character.toLowerCase();
                }
                try {
                    // if text shadow
                    if (this._textShadowOn) {
                        this._textShadowSprites[character].scale.x = scale;
                        this._textShadowSprites[character].scale.y = scale;
                        this._textShadowSprites[character].draw(ctx, currX + this._shadowOffsetX, currY + this._shadowOffsetY);
                    }
                    var charSprite = this._sprites[character];
                    charSprite.scale.x = scale;
                    charSprite.scale.y = scale;
                    charSprite.draw(ctx, currX, currY);
                    currX += (charSprite.width + options.letterSpacing);
                }
                catch (e) {
                    Log_4.Logger.getInstance().error("SpriteFont Error drawing char " + character);
                }
            }
        };
        SpriteFontImpl.prototype._parseOptions = function (options) {
            return {
                fontSize: options.fontSize || 10,
                letterSpacing: options.letterSpacing || 0,
                color: options.color || Color_10.Color.Black.clone(),
                textAlign: typeof options.textAlign === undefined ? Label_1.TextAlign.Left : options.textAlign,
                baseAlign: typeof options.baseAlign === undefined ? Label_1.BaseAlign.Bottom : options.baseAlign,
                maxWidth: options.maxWidth || -1,
                opacity: options.opacity || 0
            };
        };
        return SpriteFontImpl;
    }(SpriteSheet));
    exports.SpriteFontImpl = SpriteFontImpl;
    /**
     * Sprite fonts are a used in conjunction with a [[Label]] to specify
     * a particular bitmap as a font. Note that some font features are not
     * supported by Sprite fonts.
     *
     * [[include:SpriteFonts.md]]
     */
    var SpriteFont = (function (_super) {
        __extends(SpriteFont, _super);
        function SpriteFont(imageOrConfig, alphabet, caseInsensitive, columns, rows, spWidth, spHeight) {
            return _super.call(this, imageOrConfig, alphabet, caseInsensitive, columns, rows, spWidth, spHeight) || this;
        }
        return SpriteFont;
    }(Configurable_3.Configurable(SpriteFontImpl)));
    exports.SpriteFont = SpriteFont;
});
define("Label", ["require", "exports", "Drawing/Color", "Actor", "Configurable"], function (require, exports, Color_11, Actor_4, Configurable_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Enum representing the different font size units
     * https://developer.mozilla.org/en-US/docs/Web/CSS/font-size
     */
    var FontUnit;
    (function (FontUnit) {
        /**
         * Em is a scalable unit, 1 em is equal to the current font size of the current element, parent elements can effect em values
         */
        FontUnit[FontUnit["Em"] = 0] = "Em";
        /**
         * Rem is similar to the Em, it is a scalable unit. 1 rem is eqaul to the font size of the root element
         */
        FontUnit[FontUnit["Rem"] = 1] = "Rem";
        /**
         * Pixel is a unit of length in screen pixels
         */
        FontUnit[FontUnit["Px"] = 2] = "Px";
        /**
         * Point is a physical unit length (1/72 of an inch)
         */
        FontUnit[FontUnit["Pt"] = 3] = "Pt";
        /**
         * Percent is a scalable unit similar to Em, the only difference is the Em units scale faster when Text-Size stuff
         */
        FontUnit[FontUnit["Percent"] = 4] = "Percent";
    })(FontUnit = exports.FontUnit || (exports.FontUnit = {}));
    /**
     * Enum representing the different horizontal text alignments
     */
    var TextAlign;
    (function (TextAlign) {
        /**
         * The text is left-aligned.
         */
        TextAlign[TextAlign["Left"] = 0] = "Left";
        /**
         * The text is right-aligned.
         */
        TextAlign[TextAlign["Right"] = 1] = "Right";
        /**
         * The text is centered.
         */
        TextAlign[TextAlign["Center"] = 2] = "Center";
        /**
         * The text is aligned at the normal start of the line (left-aligned for left-to-right locales,
         * right-aligned for right-to-left locales).
         */
        TextAlign[TextAlign["Start"] = 3] = "Start";
        /**
         * The text is aligned at the normal end of the line (right-aligned for left-to-right locales,
         * left-aligned for right-to-left locales).
         */
        TextAlign[TextAlign["End"] = 4] = "End";
    })(TextAlign = exports.TextAlign || (exports.TextAlign = {}));
    /**
     * Enum representing the different baseline text alignments
     */
    var BaseAlign;
    (function (BaseAlign) {
        /**
         * The text baseline is the top of the em square.
         */
        BaseAlign[BaseAlign["Top"] = 0] = "Top";
        /**
         * The text baseline is the hanging baseline.  Currently unsupported; this will act like
         * alphabetic.
         */
        BaseAlign[BaseAlign["Hanging"] = 1] = "Hanging";
        /**
         * The text baseline is the middle of the em square.
         */
        BaseAlign[BaseAlign["Middle"] = 2] = "Middle";
        /**
         * The text baseline is the normal alphabetic baseline.
         */
        BaseAlign[BaseAlign["Alphabetic"] = 3] = "Alphabetic";
        /**
         * The text baseline is the ideographic baseline; this is the bottom of
         * the body of the characters, if the main body of characters protrudes
         * beneath the alphabetic baseline.  Currently unsupported; this will
         * act like alphabetic.
         */
        BaseAlign[BaseAlign["Ideographic"] = 4] = "Ideographic";
        /**
         * The text baseline is the bottom of the bounding box.  This differs
         * from the ideographic baseline in that the ideographic baseline
         * doesn't consider descenders.
         */
        BaseAlign[BaseAlign["Bottom"] = 5] = "Bottom";
    })(BaseAlign = exports.BaseAlign || (exports.BaseAlign = {}));
    /**
     * Enum representing the different possible font styles
     */
    var FontStyle;
    (function (FontStyle) {
        FontStyle[FontStyle["Normal"] = 0] = "Normal";
        FontStyle[FontStyle["Italic"] = 1] = "Italic";
        FontStyle[FontStyle["Oblique"] = 2] = "Oblique";
    })(FontStyle = exports.FontStyle || (exports.FontStyle = {}));
    /**
     * @hidden
     */
    var LabelImpl = (function (_super) {
        __extends(LabelImpl, _super);
        /**
         * @param text        The text of the label
         * @param x           The x position of the label
         * @param y           The y position of the label
         * @param fontFamily  Use any valid CSS font string for the label's font. Web fonts are supported. Default is `10px sans-serif`.
         * @param spriteFont  Use an Excalibur sprite font for the label's font, if a SpriteFont is provided it will take precedence
         * over a css font.
         */
        function LabelImpl(textOrConfig, x, y, fontFamily, spriteFont) {
            var _this = _super.call(this, textOrConfig && typeof textOrConfig === 'object' ? {
                x: textOrConfig.x,
                y: textOrConfig.y
            } : { x: x, y: y }) || this;
            /**
             * Sets or gets the bold property of the label's text, by default it's false
             */
            _this.bold = false;
            /**
             * The font size in the selected units, default is 10 (default units is pixel)
             */
            _this.fontSize = 10;
            /**
             * The font style for this label, the default is [[FontStyle.Normal]]
             */
            _this.fontStyle = FontStyle.Normal;
            /**
             * The css units for a font size such as px, pt, em (SpriteFont only support px), by default is 'px';
             */
            _this.fontUnit = FontUnit.Px;
            /**
             * Gets or sets the horizontal text alignment property for the label.
             */
            _this.textAlign = TextAlign.Left;
            /**
             * Gets or sets the baseline alignment property for the label.
             */
            _this.baseAlign = BaseAlign.Bottom;
            /**
             * Gets or sets the letter spacing on a Label. Only supported with Sprite Fonts.
             */
            _this.letterSpacing = 0; //px
            /**
             * Whether or not the [[SpriteFont]] will be case-sensitive when matching characters.
             */
            _this.caseInsensitive = true;
            var text = '';
            if (textOrConfig && typeof textOrConfig === 'object') {
                fontFamily = textOrConfig.fontFamily;
                spriteFont = textOrConfig.spriteFont;
                text = textOrConfig.text;
            }
            else {
                text = textOrConfig;
            }
            _this.text = text || '';
            _this.color = Color_11.Color.Black.clone();
            _this.spriteFont = spriteFont;
            _this.collisionType = Actor_4.CollisionType.PreventCollision;
            _this.fontFamily = fontFamily || 'sans-serif'; // coalesce to default canvas font
            _this._textShadowOn = false;
            _this._shadowOffsetX = 0;
            _this._shadowOffsetY = 0;
            if (spriteFont) {
                //this._textSprites = spriteFont.getTextSprites();
            }
            return _this;
        }
        /**
         * Returns the width of the text in the label (in pixels);
         * @param ctx  Rendering context to measure the string with
         */
        LabelImpl.prototype.getTextWidth = function (ctx) {
            var oldFont = ctx.font;
            ctx.font = this._fontString;
            var width = ctx.measureText(this.text).width;
            ctx.font = oldFont;
            return width;
        };
        // TypeScript doesn't support string enums :(
        LabelImpl.prototype._lookupFontUnit = function (fontUnit) {
            switch (fontUnit) {
                case FontUnit.Em:
                    return 'em';
                case FontUnit.Rem:
                    return 'rem';
                case FontUnit.Pt:
                    return 'pt';
                case FontUnit.Px:
                    return 'px';
                case FontUnit.Percent:
                    return '%';
                default:
                    return 'px';
            }
        };
        LabelImpl.prototype._lookupTextAlign = function (textAlign) {
            switch (textAlign) {
                case TextAlign.Left:
                    return 'left';
                case TextAlign.Right:
                    return 'right';
                case TextAlign.Center:
                    return 'center';
                case TextAlign.End:
                    return 'end';
                case TextAlign.Start:
                    return 'start';
                default:
                    return 'start';
            }
        };
        LabelImpl.prototype._lookupBaseAlign = function (baseAlign) {
            switch (baseAlign) {
                case BaseAlign.Alphabetic:
                    return 'alphabetic';
                case BaseAlign.Bottom:
                    return 'bottom';
                case BaseAlign.Hanging:
                    return 'hangin';
                case BaseAlign.Ideographic:
                    return 'ideographic';
                case BaseAlign.Middle:
                    return 'middle';
                case BaseAlign.Top:
                    return 'top';
                default:
                    return 'alphabetic';
            }
        };
        LabelImpl.prototype._lookupFontStyle = function (fontStyle) {
            var boldstring = this.bold ? ' bold' : '';
            switch (fontStyle) {
                case FontStyle.Italic:
                    return 'italic' + boldstring;
                case FontStyle.Normal:
                    return 'normal' + boldstring;
                case FontStyle.Oblique:
                    return 'oblique' + boldstring;
                default:
                    return 'normal' + boldstring;
            }
        };
        /**
         * Sets the text shadow for sprite fonts
         * @param offsetX      The x offset in pixels to place the shadow
         * @param offsetY      The y offset in pixels to place the shadow
         * @param shadowColor  The color of the text shadow
         */
        LabelImpl.prototype.setTextShadow = function (offsetX, offsetY, shadowColor) {
            this.spriteFont.setTextShadow(offsetX, offsetY, shadowColor);
        };
        /**
         * Toggles text shadows on or off, only applies when using sprite fonts
         */
        LabelImpl.prototype.useTextShadow = function (on) {
            this.spriteFont.useTextShadow(on);
        };
        /**
         * Clears the current text shadow
         */
        LabelImpl.prototype.clearTextShadow = function () {
            this._textShadowOn = false;
            this._shadowOffsetX = 0;
            this._shadowOffsetY = 0;
        };
        LabelImpl.prototype.update = function (engine, delta) {
            _super.prototype.update.call(this, engine, delta);
        };
        LabelImpl.prototype.draw = function (ctx, delta) {
            ctx.save();
            ctx.translate(this.pos.x, this.pos.y);
            ctx.scale(this.scale.x, this.scale.y);
            ctx.rotate(this.rotation);
            if (this._textShadowOn) {
                ctx.save();
                ctx.translate(this._shadowOffsetX, this._shadowOffsetY);
                this._fontDraw(ctx);
                ctx.restore();
            }
            this._fontDraw(ctx);
            _super.prototype.draw.call(this, ctx, delta);
            ctx.restore();
        };
        LabelImpl.prototype._fontDraw = function (ctx) {
            if (this.spriteFont) {
                this.spriteFont.draw(ctx, this.text, 0, 0, {
                    color: this.color.clone(),
                    baseAlign: this.baseAlign,
                    textAlign: this.textAlign,
                    fontSize: this.fontSize,
                    letterSpacing: this.letterSpacing,
                    opacity: this.opacity
                });
            }
            else {
                var oldAlign = ctx.textAlign;
                var oldTextBaseline = ctx.textBaseline;
                ctx.textAlign = this._lookupTextAlign(this.textAlign);
                ctx.textBaseline = this._lookupBaseAlign(this.baseAlign);
                if (this.color) {
                    this.color.a = this.opacity;
                }
                ctx.fillStyle = this.color.toString();
                ctx.font = this._fontString;
                if (this.maxWidth) {
                    ctx.fillText(this.text, 0, 0, this.maxWidth);
                }
                else {
                    ctx.fillText(this.text, 0, 0);
                }
                ctx.textAlign = oldAlign;
                ctx.textBaseline = oldTextBaseline;
            }
        };
        Object.defineProperty(LabelImpl.prototype, "_fontString", {
            get: function () {
                return this._lookupFontStyle(this.fontStyle) + " " + this.fontSize + this._lookupFontUnit(this.fontUnit) + " " + this.fontFamily;
            },
            enumerable: true,
            configurable: true
        });
        LabelImpl.prototype.debugDraw = function (ctx) {
            _super.prototype.debugDraw.call(this, ctx);
        };
        return LabelImpl;
    }(Actor_4.Actor));
    exports.LabelImpl = LabelImpl;
    /**
     * Labels are the way to draw small amounts of text to the screen. They are
     * actors and inherit all of the benefits and capabilities.
     *
     * [[include:Labels.md]]
     */
    var Label = (function (_super) {
        __extends(Label, _super);
        function Label(textOrConfig, x, y, fontFamily, spriteFont) {
            return _super.call(this, textOrConfig, x, y, fontFamily, spriteFont) || this;
        }
        return Label;
    }(Configurable_4.Configurable(LabelImpl)));
    exports.Label = Label;
});
define("Interfaces/IAudio", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Interfaces/IAudioImplementation", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Resources/Sound", ["require", "exports", "Util/Log", "Util/Util", "Promises"], function (require, exports, Log_5, Util, Promises_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // set up audio context reference
    // when we introduce multi-tracking, we may need to move this to a factory method
    if (window.AudioContext) {
        var audioContext = new window.AudioContext();
    }
    /**
     * An audio implementation for HTML5 audio.
     */
    var AudioTag = (function () {
        function AudioTag() {
            this.responseType = 'blob';
        }
        /**
         * Transforms raw Blob data into a object URL for use in audio tag
         */
        AudioTag.prototype.processData = function (data) {
            var url = URL.createObjectURL(data);
            return Promises_5.Promise.resolve(url);
        };
        /**
         * Creates a new instance of an audio tag referencing the provided audio URL
         */
        AudioTag.prototype.createInstance = function (url) {
            return new AudioTagInstance(url);
        };
        return AudioTag;
    }());
    exports.AudioTag = AudioTag;
    /**
     * An audio implementation for Web Audio API.
     */
    var WebAudio = (function () {
        function WebAudio() {
            this._logger = Log_5.Logger.getInstance();
            this.responseType = 'arraybuffer';
        }
        /**
         * Processes raw arraybuffer data and decodes into WebAudio buffer (async).
         */
        WebAudio.prototype.processData = function (data) {
            var _this = this;
            var complete = new Promises_5.Promise();
            audioContext.decodeAudioData(data, function (buffer) {
                complete.resolve(buffer);
            }, function () {
                _this._logger.error('Unable to decode ' +
                    ' this browser may not fully support this format, or the file may be corrupt, ' +
                    'if this is an mp3 try removing id3 tags and album art from the file.');
                complete.resolve(undefined);
            });
            return complete;
        };
        /**
         * Creates a new WebAudio AudioBufferSourceNode to play a sound instance
         */
        WebAudio.prototype.createInstance = function (buffer) {
            return new WebAudioInstance(buffer);
        };
        /**
         * Play an empty sound to unlock Safari WebAudio context. Call this function
         * right after a user interaction event. Typically used by [[PauseAfterLoader]]
         * @source https://paulbakaus.com/tutorials/html5/web-audio-on-ios/
         */
        WebAudio.unlock = function () {
            if (WebAudio._unlocked || !audioContext) {
                return;
            }
            // create empty buffer and play it
            var buffer = audioContext.createBuffer(1, 1, 22050);
            var source = audioContext.createBufferSource();
            var ended = false;
            source.buffer = buffer;
            source.connect(audioContext.destination);
            source.onended = function () { return ended = true; };
            if (source.noteOn) {
                // deprecated
                source.noteOn(0);
            }
            else {
                source.start(0);
            }
            // by checking the play state after some time, we know if we're really unlocked
            setTimeout(function () {
                if (source.playbackState) {
                    var legacySource = source;
                    if (legacySource.playbackState === legacySource.PLAYING_STATE ||
                        legacySource.playbackState === legacySource.FINISHED_STATE) {
                        WebAudio._unlocked = true;
                    }
                }
                else {
                    if (audioContext.currentTime > 0 || ended) {
                        WebAudio._unlocked = true;
                    }
                }
            }, 0);
        };
        WebAudio.isUnlocked = function () {
            return this._unlocked;
        };
        return WebAudio;
    }());
    WebAudio._unlocked = false;
    exports.WebAudio = WebAudio;
    /**
     * Factory method that gets the audio implementation to use
     */
    function getAudioImplementation() {
        if (window.AudioContext) {
            return new WebAudio();
        }
        else {
            return new AudioTag();
        }
    }
    exports.getAudioImplementation = getAudioImplementation;
    ;
    /**
     * The [[Sound]] object allows games built in Excalibur to load audio
     * components, from soundtracks to sound effects. [[Sound]] is an [[ILoadable]]
     * which means it can be passed to a [[Loader]] to pre-load before a game or level.
     *
     * [[include:Sounds.md]]
     */
    var Sound = (function () {
        /**
         * @param paths A list of audio sources (clip.wav, clip.mp3, clip.ogg) for this audio clip. This is done for browser compatibility.
         */
        function Sound() {
            var paths = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                paths[_i] = arguments[_i];
            }
            this._logger = Log_5.Logger.getInstance();
            this._data = null;
            this._tracks = [];
            this._isLoaded = false;
            this._isPaused = false;
            this._loop = false;
            this._volume = 1.0;
            this.onprogress = function () { return; };
            this.oncomplete = function () { return; };
            this.onerror = function () { return; };
            this._wasPlayingOnHidden = false;
            /* Chrome : MP3, WAV, Ogg
               * Firefox : WAV, Ogg,
               * IE : MP3, WAV coming soon
               * Safari MP3, WAV, Ogg
               */
            this.path = '';
            for (var _a = 0, paths_1 = paths; _a < paths_1.length; _a++) {
                var path = paths_1[_a];
                if (Sound.canPlayFile(path)) {
                    this.path = path;
                    break;
                }
            }
            if (!this.path) {
                this._logger.warn('This browser does not support any of the audio files specified:', paths.join(', '));
                this._logger.warn('Attempting to use', paths[0]);
                this.path = paths[0]; // select the first specified
            }
            this.sound = getAudioImplementation();
        }
        /**
         * Whether or not the browser can play this file as HTML5 Audio
         */
        Sound.canPlayFile = function (file) {
            try {
                var a = new Audio();
                var filetype = /.*\.([A-Za-z0-9]+)$/;
                var type = file.match(filetype)[1];
                if (a.canPlayType('audio/' + type)) {
                    return true;
                }
                else {
                    return false;
                }
            }
            catch (e) {
                Log_5.Logger.getInstance().warn('Cannot determine audio support, assuming no support for the Audio Tag', e);
                return false;
            }
        };
        Sound.prototype.wireEngine = function (engine) {
            var _this = this;
            if (engine) {
                this._engine = engine;
                this._engine.on('hidden', function () {
                    if (engine.pauseAudioWhenHidden && _this.isPlaying()) {
                        _this._wasPlayingOnHidden = true;
                        _this.pause();
                    }
                });
                this._engine.on('visible', function () {
                    if (engine.pauseAudioWhenHidden && _this._wasPlayingOnHidden) {
                        _this.play();
                        _this._wasPlayingOnHidden = false;
                    }
                });
            }
        };
        /**
         * Returns how many instances of the sound are currently playing
         */
        Sound.prototype.instanceCount = function () {
            return this._tracks.length;
        };
        /**
         * Sets the volume of the sound clip
         * @param volume  A volume value between 0-1.0
         */
        Sound.prototype.setVolume = function (volume) {
            this._volume = volume;
            for (var _i = 0, _a = this._tracks; _i < _a.length; _i++) {
                var track = _a[_i];
                track.setVolume(volume);
            }
            this._logger.debug('Set volume for all instances of sound', this.path, 'to', volume);
        };
        /**
         * Indicates whether the clip should loop when complete
         * @param loop  Set the looping flag
         */
        Sound.prototype.setLoop = function (loop) {
            this._loop = loop;
            for (var _i = 0, _a = this._tracks; _i < _a.length; _i++) {
                var track = _a[_i];
                track.setLoop(loop);
            }
            this._logger.debug('Set loop for all instances of sound', this.path, 'to', loop);
        };
        /**
         * Whether or not the sound is playing right now
         */
        Sound.prototype.isPlaying = function () {
            return this._tracks.some(function (t) { return t.isPlaying(); });
        };
        /**
         * Play the sound, returns a promise that resolves when the sound is done playing
         * An optional volume argument can be passed in to play the sound. Max volume is 1.0
         */
        Sound.prototype.play = function (volume) {
            var _this = this;
            if (this._isLoaded) {
                var resumed = [];
                // ensure we resume *current* tracks (if paused)
                for (var _i = 0, _a = this._tracks; _i < _a.length; _i++) {
                    var track = _a[_i];
                    resumed.push(track.play());
                }
                // when paused, don't start playing new track
                if (this._isPaused) {
                    this._isPaused = false;
                    this._logger.debug('Resuming paused instances for sound', this.path, this._tracks);
                    // resolve when resumed tracks are done
                    return Promises_5.Promise.join(resumed);
                }
                // push a new track
                var newTrack = this.sound.createInstance(this._data);
                newTrack.setLoop(this._loop);
                if (volume) {
                    newTrack.setVolume(Util.clamp(volume, 0.0, 1.0));
                }
                else {
                    newTrack.setVolume(this._volume);
                }
                this._tracks.push(newTrack);
                this._logger.debug('Playing new instance for sound', this.path);
                return newTrack.play().then(function () {
                    // when done, remove track
                    _this._tracks.splice(_this._tracks.indexOf(newTrack), 1);
                    return true;
                });
            }
            else {
                return Promises_5.Promise.resolve(true);
            }
        };
        /**
         * Stop the sound, and do not rewind
         */
        Sound.prototype.pause = function () {
            for (var _i = 0, _a = this._tracks; _i < _a.length; _i++) {
                var track = _a[_i];
                track.pause();
            }
            this._isPaused = true;
            this._logger.debug('Paused all instances of sound', this.path);
        };
        /**
         * Stop the sound and rewind
         */
        Sound.prototype.stop = function () {
            this._isPaused = false;
            var tracks = this._tracks.concat([]);
            for (var _i = 0, tracks_1 = tracks; _i < tracks_1.length; _i++) {
                var track = tracks_1[_i];
                track.stop();
            }
            this._logger.debug('Stopped all instances of sound', this.path);
        };
        /**
         * Returns true if the sound is loaded
         */
        Sound.prototype.isLoaded = function () {
            return this._isLoaded;
        };
        /**
         * Begins loading the sound and returns a promise to be resolved on completion
         */
        Sound.prototype.load = function () {
            var _this = this;
            var complete = new Promises_5.Promise();
            if (!!this.getData()) {
                this._logger.debug('Already have data for audio resource', this.path);
                complete.resolve(this.sound);
                this.oncomplete();
                return complete;
            }
            this._logger.debug('Started loading sound', this.path);
            try {
                this._fetchResource(function (request) {
                    if (request.status !== 200) {
                        _this._logger.error('Failed to load audio resource ', _this.path, ' server responded with error code', request.status);
                        _this.onerror(request.response);
                        complete.resolve(null);
                        return;
                    }
                    // load sound
                    _this.setData(request.response).then(function () {
                        _this.oncomplete();
                        _this._logger.debug('Completed loading sound', _this.path);
                        complete.resolve(_this.sound);
                    }, function (e) { return complete.resolve(e); });
                });
            }
            catch (e) {
                this._logger.error('Error loading sound! If this is a cross origin error, \
            you must host your sound with your html and javascript.');
                this.onerror(e);
                complete.resolve(e);
            }
            return complete;
        };
        /* istanbul ignore next */
        Sound.prototype._fetchResource = function (onload) {
            var request = new XMLHttpRequest();
            request.open('GET', this.path, true);
            request.responseType = this.sound.responseType;
            request.onprogress = this.onprogress;
            request.onerror = this.onerror;
            request.onload = function () { return onload(request); };
            request.send();
        };
        /**
         * Gets the raw sound data (e.g. blob URL or AudioBuffer)
         */
        Sound.prototype.getData = function () {
            return this._data;
        };
        /**
         * Sets raw sound data and returns a Promise that is resolved when sound data is processed
         *
         * @param data The XHR data for the sound implementation to process (Blob or ArrayBuffer)
         */
        Sound.prototype.setData = function (data) {
            var _this = this;
            return this.sound.processData(data).then(function (data) {
                _this._isLoaded = true;
                _this._data = _this.processData(data);
                return data;
            });
        };
        /**
         * Set the raw sound data (e.g. blob URL or AudioBuffer)
         */
        Sound.prototype.processData = function (data) {
            return data;
        };
        return Sound;
    }());
    exports.Sound = Sound;
    /**
     * Internal class representing a HTML5 audio instance
     */
    /* istanbul ignore next */
    var AudioTagInstance = (function () {
        function AudioTagInstance(src) {
            this._isPlaying = false;
            this._isPaused = false;
            this._loop = false;
            this._audioElement = new Audio(src);
        }
        AudioTagInstance.prototype.isPlaying = function () {
            return this._isPlaying;
        };
        Object.defineProperty(AudioTagInstance.prototype, "loop", {
            get: function () {
                return this._loop;
            },
            enumerable: true,
            configurable: true
        });
        AudioTagInstance.prototype.setLoop = function (value) {
            this._loop = value;
            this._audioElement.loop = value;
            this._wireUpOnEnded();
        };
        AudioTagInstance.prototype.setVolume = function (value) {
            this._audioElement.volume = Util.clamp(value, 0, 1.0);
        };
        AudioTagInstance.prototype.play = function () {
            if (this._isPaused) {
                this._resume();
            }
            else if (!this._isPlaying) {
                this._start();
            }
            return this._playingPromise;
        };
        AudioTagInstance.prototype._start = function () {
            this._audioElement.load();
            this._audioElement.loop = this._loop;
            this._audioElement.play();
            this._isPlaying = true;
            this._isPaused = false;
            this._playingPromise = new Promises_5.Promise();
            this._wireUpOnEnded();
        };
        AudioTagInstance.prototype._resume = function () {
            if (!this._isPaused) {
                return;
            }
            this._audioElement.play();
            this._isPaused = false;
            this._isPlaying = true;
            this._wireUpOnEnded();
        };
        AudioTagInstance.prototype.pause = function () {
            if (!this._isPlaying) {
                return;
            }
            this._audioElement.pause();
            this._isPaused = true;
            this._isPlaying = false;
        };
        AudioTagInstance.prototype.stop = function () {
            if (!this._isPlaying) {
                return;
            }
            this._audioElement.pause();
            this._audioElement.currentTime = 0;
            this._handleOnEnded();
        };
        AudioTagInstance.prototype._wireUpOnEnded = function () {
            var _this = this;
            if (!this._loop) {
                this._audioElement.onended = function () { return _this._handleOnEnded(); };
            }
        };
        AudioTagInstance.prototype._handleOnEnded = function () {
            this._isPlaying = false;
            this._isPaused = false;
            this._playingPromise.resolve(true);
        };
        return AudioTagInstance;
    }());
    /**
     * Internal class representing a Web Audio AudioBufferSourceNode instance
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API
     */
    /* istanbul ignore next */
    var WebAudioInstance = (function () {
        function WebAudioInstance(_buffer) {
            this._buffer = _buffer;
            this._volumeNode = audioContext.createGain();
            this._isPlaying = false;
            this._isPaused = false;
            this._loop = false;
            /**
             * Current playback offset (in seconds)
             */
            this._currentOffset = 0;
        }
        WebAudioInstance.prototype.isPlaying = function () {
            return this._isPlaying;
        };
        WebAudioInstance.prototype.setVolume = function (value) {
            if (this._volumeNode.gain.setTargetAtTime) {
                this._volumeNode.gain.setTargetAtTime(Util.clamp(value, 0, 1.0), audioContext.currentTime, 0);
            }
            else {
                this._volumeNode.gain.value = Util.clamp(value, 0, 1.0);
            }
        };
        WebAudioInstance.prototype.setLoop = function (value) {
            this._loop = value;
            if (this._bufferSource) {
                this._bufferSource.loop = value;
                this._wireUpOnEnded();
            }
        };
        WebAudioInstance.prototype.play = function () {
            if (this._isPaused) {
                this._resume();
            }
            else if (!this._isPlaying) {
                this._start();
            }
            return this._playingPromise;
        };
        WebAudioInstance.prototype._start = function () {
            this._volumeNode.connect(audioContext.destination);
            this._createBufferSource();
            this._bufferSource.start(0, 0);
            this._startTime = new Date().getTime();
            this._currentOffset = 0;
            this._isPlaying = true;
            this._isPaused = false;
            this._playingPromise = new Promises_5.Promise();
            this._wireUpOnEnded();
        };
        WebAudioInstance.prototype._resume = function () {
            if (!this._isPaused) {
                return;
            }
            // a buffer source can only be started once
            // so we need to dispose of the previous instance before
            // "resuming" the next one
            this._bufferSource.onended = null; // dispose of any previous event handler
            this._createBufferSource();
            var duration = (1 / this._bufferSource.playbackRate.value) * this._buffer.duration;
            this._bufferSource.start(0, this._currentOffset % duration);
            this._isPaused = false;
            this._isPlaying = true;
            this._wireUpOnEnded();
        };
        WebAudioInstance.prototype._createBufferSource = function () {
            this._bufferSource = audioContext.createBufferSource();
            this._bufferSource.buffer = this._buffer;
            this._bufferSource.loop = this._loop;
            this._bufferSource.playbackRate.value = 1.0;
            this._bufferSource.connect(this._volumeNode);
        };
        WebAudioInstance.prototype.pause = function () {
            if (!this._isPlaying) {
                return;
            }
            this._bufferSource.stop(0);
            // Playback rate will be a scale factor of how fast/slow the audio is being played
            // default is 1.0
            // we need to invert it to get the time scale
            var pbRate = 1 / (this._bufferSource.playbackRate.value || 1.0);
            this._currentOffset = ((new Date().getTime() - this._startTime) * pbRate) / 1000; // in seconds
            this._isPaused = true;
            this._isPlaying = false;
        };
        WebAudioInstance.prototype.stop = function () {
            if (!this._isPlaying) {
                return;
            }
            this._bufferSource.stop(0);
            // handler will not be wired up if we were looping
            if (!this._bufferSource.onended) {
                this._handleOnEnded();
            }
            this._currentOffset = 0;
            this._isPlaying = false;
            this._isPaused = false;
        };
        WebAudioInstance.prototype._wireUpOnEnded = function () {
            var _this = this;
            if (!this._loop) {
                this._bufferSource.onended = function () { return _this._handleOnEnded(); };
            }
        };
        WebAudioInstance.prototype._handleOnEnded = function () {
            // pausing calls stop(0) which triggers onended event
            // so we don't "resolve" yet (when we resume we'll try again)
            if (!this._isPaused) {
                this._isPlaying = false;
                this._playingPromise.resolve(true);
            }
        };
        return WebAudioInstance;
    }());
});
define("Interfaces/ILoader", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Loader", ["require", "exports", "Drawing/Color", "Resources/Sound", "Util/Log", "Promises", "Class", "Util/DrawUtil"], function (require, exports, Color_12, Sound_1, Log_6, Promises_6, Class_3, DrawUtil) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Pre-loading assets
     *
     * The loader provides a mechanism to preload multiple resources at
     * one time. The loader must be passed to the engine in order to
     * trigger the loading progress bar.
     *
     * The [[Loader]] itself implements [[ILoadable]] so you can load loaders.
     *
     * ## Example: Pre-loading resources for a game
     *
     * ```js
     * // create a loader
     * var loader = new ex.Loader();
     *
     * // create a resource dictionary (best practice is to keep a separate file)
     * var resources = {
     *   TextureGround: new ex.Texture("/images/textures/ground.png"),
     *   SoundDeath: new ex.Sound("/sound/death.wav", "/sound/death.mp3")
     * };
     *
     * // loop through dictionary and add to loader
     * for (var loadable in resources) {
     *   if (resources.hasOwnProperty(loadable)) {
     *     loader.addResource(resources[loadable]);
     *   }
     * }
     *
     * // start game
     * game.start(loader).then(function () {
     *   console.log("Game started!");
     * });
     * ```
     */
    var Loader = (function (_super) {
        __extends(Loader, _super);
        /**
         * @param loadables  Optionally provide the list of resources you want to load at constructor time
         */
        function Loader(loadables) {
            var _this = _super.call(this) || this;
            _this._resourceList = [];
            _this._index = 0;
            _this._resourceCount = 0;
            _this._numLoaded = 0;
            _this._progressCounts = {};
            _this._totalCounts = {};
            // logo drawing stuff
            /* tslint:disable:max-line-length */
            // base64 string encoding of the excalibur logo (logo-white.png)
            _this.logo = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAdQAAAB2CAYAAABxhGI9AAAACXBIWXMAAAsSAAALEgHS3X78AAAKnUlEQVR42u3dP2wjSx0H8N8hJIonIRmJjsq0SBR+BQ1dcqKhe0lD77SvSwpKkJKGPulpktfRIMUdEqKIqV57rpAokM4dbSiyq7ONPTP7x39ifz7SFbnEnp3xer47O7uzH15fXwMA6OYHmgAABCoACFQAEKgAgEAFAIEKAAIVAAQqACBQAUCgAoBABQCBCgAIVAAQqAAgUAFAoAIAAhUABCoACFQAEKgAgECFLbmOiNeFf2PbAyz68Pr6qhUgbRwR92v+/zwiJrYHMEKFMmcN///UtgcQqFBk1PD/97U9Qx8VCFSgu4EmAIEKAAIVAAQqACBQ4Z25jojP8eX+0WtNAgIVaOY+Im5j+eKh24h41jQgUIEyZ7F5NaPU7wCBCiwYd/w9cOB+qAlgJ3KLLow0EV198803RWvJfvfddx+0lhEqHKu5JgAjVCBvlhmFzjQRXUekHz9+TP79y8uLRjNChXfvoePvAYEKxNtj1e42/O5JoIJABcrdRMRVLM+X3kTEpaaB988cKuzWg9EobTWdMx0Oly8uN4dqhAoARqgnaN3arHfqu7OyH8ItKLVB/P+CEfMTHyGPY3npx1m8zWGDEeoBfUk/xdti57dr/r1Wv2+6EPow3tZ5rRdS72s1neuF97xvWd+XTH0/V+UMttDWqbI/r2nrxfp+jv2uSjSO7S+OXy/A/3lN+9xX5T5HxEUPZZ0tfB71+w57eJ/HFu+z+jkv1u92YX9fbI/HhX3JA9rp5MPr66tWaG9UfUGbrHIzi7cLUyYFf/tpTady03EEeL8mUJ6i7MKYNvWNqr4Pe2jradXO60LrvPAz2PQ5RPX684ah8dxD+2zantnCgVipSVV+m/tgB9W2DDq2Sx/vM95wcHhZhWVJm8yrv58cSgfTdc70+++/X/r522+/tUKSEepBqo+om4ZLPerMjUwuNnQCtx1GWJtee1FwdD5uWd86xLs8UaVt2aNEO1/saZ/Z5rYMW4zq6v34rGV9Bg3q2eZ9SkeNm9qwyUh30OPIHYFKx5FG03C7znSOqYBq+qW/zpQ3anH037TNHluG6f0WPsPhHvab4QFty7ogOeuxDYcNy2/zu2214WNYWxmBurNO8bGn97pNBOO8xy/9uCorZZ4I2r4C7aJgO7ZV9iE49Dm6NvOWx+pWE9CUq3zbdTp9doz38TbXtzqH9RT5CyWe422OaZoZGeZCabrhPQY9HjwsjpTvCg4YtlE2+Ta/j2bzn8fqrDqgm+6yUHOmAvWUjAtGhbNYvsBknDnqH1Qhc7VmxHgeb/NbudA5j/UXlYwif2p6luhAc9teu1npiHKnDs8if6tCm7JLX3NKpgttXe9ruc9mHMd7a83iwdxF5vt8tutARaCeklRnNK9C8WnNF7geJQ4T4XG3JhSnVdilQrG+yOnrlVHfsEGYzhNBn7Lu6tS7+HJafJQ4EMiNlNqWXZ9WPvVgnVYHG5M1ByDXkT6leX2EgTqJtyt45yv7S2qO3sEZjZhDLXeR+YKdJ0Zdk8QocvH9N732KrNtq+FZ/zzIHABcJrYpd+Xv14lOd5ap76SgrduW/VTQ1qcQpqnbgu4ifZvUMNpd9XuoZmvCtPaQ2Y/BCHVLgbrJTeRPDdVf6pfMKDU2fOkHmVFFfXr3MsouLsnNvV5kRoe5+s431PeuoKPqWnaurY/ZPBEeqwceN4l96iwO6H7Mjq4y7VGPVNe10VaZMzVCPVWpI/Z6FZbcv5fMqGCU+dLfFGzj58jP8+bCdJCo7yzKTwdOF0bu9Ug7V4c+yz7FJfYeGoysUss0HssIdVZwYLDujMqlESoCdTtGsZtbHnJBeNdDSJSs0jTKdMJN1HNX54Wv7bvsU9NkVJVa13dX+/wuArV0X/l5RHyo/lnfF4G6p6DrS0kHdtXhy35TGErDPYZUn2WfWqDOo/lVqdMD2O/hKJhD7S/odukymq9s02QN4EEPR/zbaOumZc+r15zK1Zqznl9jsfiemTM1QmV3HUuTkedlg9HIQzRbUD93dfC+2tpj2fIHEH2+RqCCQH13gZq7hWXTNpVu19OB1fc9nQ0AKOKUb5lU0P1kDyOneoWk0lOZ9cIP0x7qu8+2BhCoR2wYu1+e7DmaXzBSsu5vaX1ne2zrpmUPTmxf7PM1Dm4y/vC7ny7Nif7+z/9ZmtM0Z3panPLtPmra9f16bcK0Dpbnwk43Vd/RHtu6zfNQTy1QBy3aqG2g9nVmxml+BOoJyT3NpWmn9xhfFnu4bvDa+44BXhqqfdf3uUF9+yz77AT31Yue2mjecYQ62NLfgkA9ghHqLNEhNem4H1c6vdyDxhf/bpz5m4coW/c39wi6VH2bPtHlcaV9cvXts+zxCe6rTeqc2ndL7uGd93QwM9bFcAzMoZZ7SgTBbWx+asui61h/iq1+RmjqdbnQXQ3T1DNQ63V/U9ucqm/pMzPb1rePsk/1iTOjgvatR4W3Lc8ULB78pELyrnAfeTcj1NU509/86mfJ33/8+Mf00a05UyPUEw7UVCeWG/WNEiExyHRMt5ltW30izUPk18ytt7lNfc8i//DvtvXto+ySA5BjljsLUF8lPkqMPEtW1JomDsiGBZ9Byb4NAvUITSN9GuwsIj6t6UTOqk7jJREkmzqli8xIs96udSO20sX0H1vW92IL9e1a9rgqVyf91gbPsTy9UD9n9lOkT8k+RfkFR5PMNqxOcdSf32PBvg3vilO+zdxE+okx9Wm0ph36XYsRZCpMF993GOk5qvqB3Dct6jvssb67KvuUNJ3frw92bhr8/STSF0JdRPMLpUCgnsgo9S76PZ246ZFk1wWvK5m3vVoYvW1Sz7nN91jfXbQ1ZQc7TW6HeaoOalypG/8/p/rP1aNAc6ZHzSnfdqPUPhdy2PQw6Nz9gSVhuhiqueUHR3uu7y7K3rdDX4u46ZrPbUa0IFBZ0seKQ3XQTRt2vm3W/a2DbNKys++rvm3ep6+y1x2UdP3bWU9lzra47U1GmlctX/sQ23t+aOlByLTh/4NAPaCRxtcdO5HLSJ/6vNtCwGx67VPmPbvWd1q9frKHtp4kAqRJ2HR9j762JfX3bZ//elPtj13PPDx1+D5tqk/Xi6NO8SHz7MmH19dXrdBNfVFP6T2PT1UHNit87/t4m5+aRH+nQBdvqyhZDKJLfZs8h7XPsqdV2ZOV+tanKB8aln0dyxdAXbV4j4gvt4oMOrbP6vbU73NW7TMlbdTnPrWpfqXfh9HKZ9vke7KuTeZRNtXRSe6+1FV//ce/ln5eXfsXgcqXzr6+9261M3moOoa7E6nvTZTfy7iNsmfb7kjfgXGsvxe0vihsEts9HTquPpt1q1vtahu2TqAiUAEEKj0zhwoARqgAu/OnX/442WH+9xc/Wvr58re/Tr7f41/+ZsRqhAoACFQAEKgAcHjMoQJskJsz/eqrr5Z+vvr7v5fmQFevAl5lztQIFQAQqAAgUAHgIJlDBdhgdQ41N2eKESoAIFABQKACwFEwhwoARqgAIFABQKACAAIVAAQqAAhUABCoAIBABQCBCgACFQAEKgAgUAFAoAKAQAUAgQoACFQAEKgAIFABQKACAAIVAAQqAAhUABCoAIBABQCBCgACFQAQqAAgUAFAoAKAQAUAlvwPcFDns1DsH4sAAAAASUVORK5CYII=';
            /* tslint:enable:max-line-length */
            _this.logoWidth = 468;
            _this.logoHeight = 118;
            _this.backgroundColor = '#176BAA';
            _this.getData = function () { return; };
            _this.setData = function () { return; };
            _this.processData = function () { return; };
            _this.onprogress = function (e) {
                Log_6.Logger.getInstance().debug('[ex.Loader] Loading ' + (100 * e.loaded / e.total).toFixed(0));
                return;
            };
            _this.oncomplete = function () { return; };
            _this.onerror = function () { return; };
            if (loadables) {
                _this.addResources(loadables);
            }
            return _this;
        }
        Object.defineProperty(Loader.prototype, "_image", {
            get: function () {
                if (!this._imageElement) {
                    this._imageElement = new Image();
                    this._imageElement.src = this.logo;
                }
                return this._imageElement;
            },
            enumerable: true,
            configurable: true
        });
        ;
        Loader.prototype.wireEngine = function (engine) {
            this._engine = engine;
        };
        /**
         * Add a resource to the loader to load
         * @param loadable  Resource to add
         */
        Loader.prototype.addResource = function (loadable) {
            var key = this._index++;
            this._resourceList.push(loadable);
            this._progressCounts[key] = 0;
            this._totalCounts[key] = 1;
            this._resourceCount++;
        };
        /**
         * Add a list of resources to the loader to load
         * @param loadables  The list of resources to load
         */
        Loader.prototype.addResources = function (loadables) {
            var i = 0, len = loadables.length;
            for (i; i < len; i++) {
                this.addResource(loadables[i]);
            }
        };
        /**
         * Returns true if the loader has completely loaded all resources
         */
        Loader.prototype.isLoaded = function () {
            return this._numLoaded === this._resourceCount;
        };
        /**
         * Begin loading all of the supplied resources, returning a promise
         * that resolves when loading of all is complete
         */
        Loader.prototype.load = function () {
            var _this = this;
            var complete = new Promises_6.Promise();
            var me = this;
            if (this._resourceList.length === 0) {
                me.oncomplete.call(me);
                return complete.resolve();
            }
            var progressArray = new Array(this._resourceList.length);
            var progressChunks = this._resourceList.length;
            this._resourceList.forEach(function (r, i) {
                if (_this._engine) {
                    r.wireEngine(_this._engine);
                }
                r.onprogress = function (e) {
                    var total = e.total;
                    var loaded = e.loaded;
                    progressArray[i] = { loaded: ((loaded / total) * (100 / progressChunks)), total: 100 };
                    var progressResult = progressArray.reduce(function (accum, next) {
                        return { loaded: (accum.loaded + next.loaded), total: 100 };
                    }, { loaded: 0, total: 100 });
                    me.onprogress.call(me, progressResult);
                };
                r.oncomplete = r.onerror = function () {
                    me._numLoaded++;
                    if (me._numLoaded === me._resourceCount) {
                        me.oncomplete.call(me);
                        complete.resolve();
                    }
                };
            });
            function loadNext(list, index) {
                if (!list[index]) {
                    return;
                }
                list[index].load().then(function () {
                    loadNext(list, index + 1);
                });
            }
            loadNext(this._resourceList, 0);
            return complete;
        };
        /**
         * Loader draw function. Draws the default Excalibur loading screen.
         * Override `logo`, `logoWidth`, `logoHeight` and `backgroundColor` properties
         * to customize the drawing, or just override entire method.
         */
        Loader.prototype.draw = function (ctx) {
            var canvasHeight = this._engine.canvasHeight / window.devicePixelRatio;
            var canvasWidth = this._engine.canvasWidth / window.devicePixelRatio;
            ctx.fillStyle = this.backgroundColor;
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            var y = canvasHeight / 2;
            var width = Math.min(this.logoWidth, canvasWidth * 0.75);
            var x = (canvasWidth / 2) - (width / 2);
            var imageHeight = Math.floor(width * (this.logoHeight / this.logoWidth)); // OG height/width factor
            var oldAntialias = this._engine.getAntialiasing();
            this._engine.setAntialiasing(true);
            ctx.drawImage(this._image, 0, 0, this.logoWidth, this.logoHeight, x, y - imageHeight - 20, width, imageHeight);
            // loading box
            ctx.lineWidth = 2;
            DrawUtil.roundRect(ctx, x, y, width, 20, 10);
            var progress = width * (this._numLoaded / this._resourceCount);
            var margin = 5;
            var progressWidth = progress - margin * 2;
            var height = 20 - margin * 2;
            DrawUtil.roundRect(ctx, x + margin, y + margin, progressWidth > 0 ? progressWidth : 0, height, 5, null, Color_12.Color.White);
            this._engine.setAntialiasing(oldAntialias);
        };
        /**
         * Perform any calculations or logic in the `update` method. The default `Loader` does not
         * do anything in this method so it is safe to override.
         */
        Loader.prototype.update = function (_engine, _delta) {
            // overridable update
        };
        return Loader;
    }(Class_3.Class));
    exports.Loader = Loader;
    /**
     * A [[Loader]] that pauses after loading to allow user
     * to proceed to play the game. Typically you will
     * want to use this loader for iOS to allow sounds
     * to play after loading (Apple Safari requires user
     * interaction to allow sounds, even for games)
     *
     * **Note:** Because Loader is not part of a Scene, you must
     * call `update` and `draw` manually on "child" objects.
     *
     * ## Implementing a Trigger
     *
     * The `PauseAfterLoader` requires an element to act as the trigger button
     * to start the game.
     *
     * For example, let's create an `<a>` tag to be our trigger and call it `tap-to-play`.
     *
     * ```html
     * <div id="wrapper">
     *    <canvas id="game"></canvas>
     *    <a id="tap-to-play" href='javascript:void(0);'>Tap to Play</a>
     * </div>
     * ```
     *
     * We've put it inside a wrapper to position it properly over the game canvas.
     *
     * Now let's add some CSS to style it (insert into `<head>`):
     *
     * ```html
     * <style>
     *     #wrapper {
     *         position: relative;
     *         width: 500px;
     *         height: 500px;
     *     }
     *     #tap-to-play {
     *         display: none;
     *         font-size: 24px;
     *         font-family: sans-serif;
     *         text-align: center;
     *         border: 3px solid white;
     *         position: absolute;
     *         color: white;
     *         width: 200px;
     *         height: 50px;
     *         line-height: 50px;
     *         text-decoration: none;
     *         left: 147px;
     *         top: 80%;
     *     }
     * </style>
     * ```
     *
     * Now we can create a `PauseAfterLoader` with a reference to our trigger button:
     *
     * ```ts
     * var loader = new ex.PauseAfterLoader('tap-to-play', [...]);
     * ```
     *
     * ## Use PauseAfterLoader for iOS
     *
     * The primary use case for pausing before starting the game is to
     * pass Apple's requirement of user interaction. The Web Audio context
     * in Safari is disabled by default until user interaction.
     *
     * Therefore, you can use this snippet to only use PauseAfterLoader when
     * iOS is detected (see [this thread](http://stackoverflow.com/questions/9038625/detect-if-device-is-ios)
     * for more techniques).
     *
     * ```ts
     * var iOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !(<any>window).MSStream;
     * var loader: ex.Loader = iOS ? new ex.PauseAfterLoader('tap-to-play') : new ex.Loader();
     *
     * loader.addResource(...);
     * ```
     */
    var PauseAfterLoader = (function (_super) {
        __extends(PauseAfterLoader, _super);
        function PauseAfterLoader(triggerElementId, loadables) {
            var _this = _super.call(this, loadables) || this;
            _this._handleOnTrigger = function () {
                if (_this._waitPromise.state() !== Promises_6.PromiseState.Pending) {
                    return false;
                }
                // unlock Safari WebAudio context
                Sound_1.WebAudio.unlock();
                // continue to play game
                _this._waitPromise.resolve(_this._loadedValue);
                // hide DOM element
                _this._playTrigger.style.display = 'none';
                return false;
            };
            _this._playTrigger = document.getElementById(triggerElementId);
            _this._playTrigger.addEventListener('click', _this._handleOnTrigger);
            return _this;
        }
        PauseAfterLoader.prototype.load = function () {
            var _this = this;
            this._waitPromise = new Promises_6.Promise();
            // wait until user indicates to proceed before finishing load
            _super.prototype.load.call(this).then(function (value) {
                _this._loadedValue = value;
                // show element
                _this._playTrigger.style.display = 'block';
            }, function (value) {
                _this._waitPromise.reject(value);
            });
            return this._waitPromise;
        };
        return PauseAfterLoader;
    }(Loader));
    exports.PauseAfterLoader = PauseAfterLoader;
});
define("Interfaces/IActorTrait", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Traits/CapturePointer", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Propogates pointer events to the actor
     */
    var CapturePointer = (function () {
        function CapturePointer() {
        }
        CapturePointer.prototype.update = function (actor, engine) {
            if (!actor.enableCapturePointer) {
                return;
            }
            if (actor.isKilled()) {
                return;
            }
            engine.input.pointers.propogate(actor);
        };
        return CapturePointer;
    }());
    exports.CapturePointer = CapturePointer;
});
define("Traits/EulerMovement", ["require", "exports", "Physics", "Actor"], function (require, exports, Physics_7, Actor_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var EulerMovement = (function () {
        function EulerMovement() {
        }
        EulerMovement.prototype.update = function (actor, _engine, delta) {
            // Update placements based on linear algebra
            var seconds = delta / 1000;
            var totalAcc = actor.acc.clone();
            // Only active vanilla actors are affected by global acceleration
            if (actor.collisionType === Actor_5.CollisionType.Active) {
                totalAcc.addEqual(Physics_7.Physics.acc);
            }
            actor.oldVel = actor.vel;
            actor.vel.addEqual(totalAcc.scale(seconds));
            actor.pos.addEqual(actor.vel.scale(seconds)).addEqual(totalAcc.scale(0.5 * seconds * seconds));
            actor.rx += actor.torque * (1.0 / actor.moi) * seconds;
            actor.rotation += actor.rx * seconds;
            actor.scale.x += actor.sx * delta / 1000;
            actor.scale.y += actor.sy * delta / 1000;
        };
        return EulerMovement;
    }());
    exports.EulerMovement = EulerMovement;
});
define("Util/CullingBox", ["require", "exports", "Algebra", "Drawing/Color"], function (require, exports, Algebra_13, Color_13) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CullingBox = (function () {
        function CullingBox() {
            this._topLeft = new Algebra_13.Vector(0, 0);
            this._topRight = new Algebra_13.Vector(0, 0);
            this._bottomLeft = new Algebra_13.Vector(0, 0);
            this._bottomRight = new Algebra_13.Vector(0, 0);
        }
        CullingBox.prototype.isSpriteOffScreen = function (actor, engine) {
            var drawingWidth = actor.currentDrawing.width;
            var drawingHeight = actor.currentDrawing.height;
            var rotation = actor.rotation;
            var anchor = actor.getCenter();
            var worldPos = actor.getWorldPos();
            this._topLeft.x = worldPos.x - (drawingWidth / 2);
            this._topLeft.y = worldPos.y - (drawingHeight / 2);
            this._topLeft = this._topLeft.rotate(rotation, anchor);
            this._topRight.x = worldPos.x + (drawingWidth / 2);
            this._topRight.y = worldPos.y - (drawingHeight / 2);
            this._topRight = this._topRight.rotate(rotation, anchor);
            this._bottomLeft.x = worldPos.x - (drawingWidth / 2);
            this._bottomLeft.y = worldPos.y + (drawingHeight / 2);
            this._bottomLeft = this._bottomLeft.rotate(rotation, anchor);
            this._bottomRight.x = worldPos.x + (drawingWidth / 2);
            this._bottomRight.y = worldPos.y + (drawingHeight / 2);
            this._bottomRight = this._bottomRight.rotate(rotation, anchor);
            ///
            var topLeftScreen = engine.worldToScreenCoordinates(this._topLeft);
            var topRightScreen = engine.worldToScreenCoordinates(this._topRight);
            var bottomLeftScreen = engine.worldToScreenCoordinates(this._bottomLeft);
            var bottomRightScreen = engine.worldToScreenCoordinates(this._bottomRight);
            this._xCoords = [];
            this._yCoords = [];
            this._xCoords.push(topLeftScreen.x, topRightScreen.x, bottomLeftScreen.x, bottomRightScreen.x);
            this._yCoords.push(topLeftScreen.y, topRightScreen.y, bottomLeftScreen.y, bottomRightScreen.y);
            this._xMin = Math.min.apply(null, this._xCoords);
            this._yMin = Math.min.apply(null, this._yCoords);
            this._xMax = Math.max.apply(null, this._xCoords);
            this._yMax = Math.max.apply(null, this._yCoords);
            var minWorld = engine.screenToWorldCoordinates(new Algebra_13.Vector(this._xMin, this._yMin));
            var maxWorld = engine.screenToWorldCoordinates(new Algebra_13.Vector(this._xMax, this._yMax));
            this._xMinWorld = minWorld.x;
            this._yMinWorld = minWorld.y;
            this._xMaxWorld = maxWorld.x;
            this._yMaxWorld = maxWorld.y;
            var boundingPoints = [
                new Algebra_13.Vector(this._xMin, this._yMin),
                new Algebra_13.Vector(this._xMax, this._yMin),
                new Algebra_13.Vector(this._xMin, this._yMax),
                new Algebra_13.Vector(this._xMax, this._yMax)
            ]; // bottomright
            // sprite can be wider than canvas screen (and still visible within canvas)
            // top or bottom of sprite must be within canvas
            if (boundingPoints[0].x < 0 && boundingPoints[1].x > engine.canvas.clientWidth &&
                (boundingPoints[0].y > 0 || boundingPoints[2].y < engine.canvas.clientHeight)) {
                return false;
            }
            // sprite can be taller than canvas screen (and still visible within canvas)
            // left or right of sprite must be within canvas
            if (boundingPoints[0].y < 0 && boundingPoints[2].y > engine.canvas.clientHeight &&
                (boundingPoints[1].x > 0 || boundingPoints[0].x < engine.canvas.clientWidth)) {
                return false;
            }
            // otherwise if any corner is visible, we're not offscreen
            for (var i = 0; i < boundingPoints.length; i++) {
                if (boundingPoints[i].x > 0 &&
                    boundingPoints[i].y > 0 &&
                    boundingPoints[i].x < engine.canvas.clientWidth &&
                    boundingPoints[i].y < engine.canvas.clientHeight) {
                    return false;
                }
            }
            return true;
        };
        CullingBox.prototype.debugDraw = function (ctx) {
            // bounding rectangle
            ctx.beginPath();
            ctx.strokeStyle = Color_13.Color.White.toString();
            ctx.rect(this._xMinWorld, this._yMinWorld, this._xMaxWorld - this._xMinWorld, this._yMaxWorld - this._yMinWorld);
            ctx.stroke();
            ctx.fillStyle = Color_13.Color.Red.toString();
            ctx.beginPath();
            ctx.arc(this._topLeft.x, this._topLeft.y, 5, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = Color_13.Color.Green.toString();
            ctx.beginPath();
            ctx.arc(this._topRight.x, this._topRight.y, 5, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = Color_13.Color.Blue.toString();
            ctx.beginPath();
            ctx.arc(this._bottomLeft.x, this._bottomLeft.y, 5, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = Color_13.Color.Magenta.toString();
            ctx.beginPath();
            ctx.arc(this._bottomRight.x, this._bottomRight.y, 5, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fill();
        };
        return CullingBox;
    }());
    exports.CullingBox = CullingBox;
});
define("Traits/OffscreenCulling", ["require", "exports", "Util/CullingBox", "Algebra", "Events"], function (require, exports, CullingBox_1, Algebra_14, Events_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var OffscreenCulling = (function () {
        function OffscreenCulling() {
            this.cullingBox = new CullingBox_1.CullingBox();
        }
        OffscreenCulling.prototype.update = function (actor, engine) {
            var eventDispatcher = actor.eventDispatcher;
            var anchor = actor.anchor;
            var globalScale = actor.getGlobalScale();
            var width = globalScale.x * actor.getWidth() / actor.scale.x;
            var height = globalScale.y * actor.getHeight() / actor.scale.y;
            var worldPos = actor.getWorldPos();
            var actorScreenCoords = engine.worldToScreenCoordinates(new Algebra_14.Vector(worldPos.x - anchor.x * width, worldPos.y - anchor.y * height));
            var zoom = 1.0;
            if (actor.scene && actor.scene.camera) {
                zoom = Math.abs(actor.scene.camera.getZoom());
            }
            var isSpriteOffScreen = true;
            if (actor.currentDrawing != null) {
                isSpriteOffScreen = this.cullingBox.isSpriteOffScreen(actor, engine);
            }
            if (!actor.isOffScreen) {
                if ((actorScreenCoords.x + width * zoom < 0 ||
                    actorScreenCoords.y + height * zoom < 0 ||
                    actorScreenCoords.x > engine.canvasWidth ||
                    actorScreenCoords.y > engine.canvasHeight) &&
                    isSpriteOffScreen) {
                    eventDispatcher.emit('exitviewport', new Events_3.ExitViewPortEvent(actor));
                    actor.isOffScreen = true;
                }
            }
            else {
                if ((actorScreenCoords.x + width * zoom > 0 &&
                    actorScreenCoords.y + height * zoom > 0 &&
                    actorScreenCoords.x < engine.canvasWidth &&
                    actorScreenCoords.y < engine.canvasHeight) ||
                    !isSpriteOffScreen) {
                    eventDispatcher.emit('enterviewport', new Events_3.EnterViewPortEvent(actor));
                    actor.isOffScreen = false;
                }
            }
        };
        return OffscreenCulling;
    }());
    exports.OffscreenCulling = OffscreenCulling;
});
define("Traits/TileMapCollisionDetection", ["require", "exports", "Actor", "Collision/Side", "Events"], function (require, exports, Actor_6, Side_2, Events_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TileMapCollisionDetection = (function () {
        function TileMapCollisionDetection() {
        }
        TileMapCollisionDetection.prototype.update = function (actor, engine) {
            var eventDispatcher = actor.eventDispatcher;
            if (actor.collisionType !== Actor_6.CollisionType.PreventCollision && engine.currentScene && engine.currentScene.tileMaps) {
                for (var j = 0; j < engine.currentScene.tileMaps.length; j++) {
                    var map = engine.currentScene.tileMaps[j];
                    var intersectMap;
                    var side = Side_2.Side.None;
                    var max = 2;
                    while (intersectMap = map.collides(actor)) {
                        if (max-- < 0) {
                            break;
                        }
                        side = actor.getSideFromIntersect(intersectMap);
                        eventDispatcher.emit('precollision', new Events_4.PreCollisionEvent(actor, null, side, intersectMap));
                        if (actor.collisionType === Actor_6.CollisionType.Active) {
                            actor.pos.y += intersectMap.y;
                            actor.pos.x += intersectMap.x;
                            eventDispatcher.emit('postcollision', new Events_4.PostCollisionEvent(actor, null, side, intersectMap));
                        }
                    }
                }
            }
        };
        return TileMapCollisionDetection;
    }());
    exports.TileMapCollisionDetection = TileMapCollisionDetection;
});
define("Traits/Index", ["require", "exports", "Traits/CapturePointer", "Traits/EulerMovement", "Traits/OffscreenCulling", "Traits/TileMapCollisionDetection"], function (require, exports, CapturePointer_1, EulerMovement_1, OffscreenCulling_1, TileMapCollisionDetection_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(CapturePointer_1);
    __export(EulerMovement_1);
    __export(OffscreenCulling_1);
    __export(TileMapCollisionDetection_1);
});
define("Particles", ["require", "exports", "Actor", "Drawing/Color", "Algebra", "Util/Util", "Util/DrawUtil", "Traits/Index", "Configurable", "Math/Random"], function (require, exports, Actor_7, Color_14, Algebra_15, Util, DrawUtil, Traits, Configurable_5, Random_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * An enum that represents the types of emitter nozzles
     */
    var EmitterType;
    (function (EmitterType) {
        /**
         * Constant for the circular emitter type
         */
        EmitterType[EmitterType["Circle"] = 0] = "Circle";
        /**
         * Constant for the rectangular emitter type
         */
        EmitterType[EmitterType["Rectangle"] = 1] = "Rectangle";
    })(EmitterType = exports.EmitterType || (exports.EmitterType = {}));
    /**
     * @hidden
     */
    var ParticleImpl = (function () {
        function ParticleImpl(emitterOrConfig, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize) {
            this.position = new Algebra_15.Vector(0, 0);
            this.velocity = new Algebra_15.Vector(0, 0);
            this.acceleration = new Algebra_15.Vector(0, 0);
            this.particleRotationalVelocity = 0;
            this.currentRotation = 0;
            this.focus = null;
            this.focusAccel = 0;
            this.opacity = 1;
            this.beginColor = Color_14.Color.White.clone();
            this.endColor = Color_14.Color.White.clone();
            // Life is counted in ms
            this.life = 300;
            this.fadeFlag = false;
            // Color transitions
            this._rRate = 1;
            this._gRate = 1;
            this._bRate = 1;
            this._aRate = 0;
            this._currentColor = Color_14.Color.White.clone();
            this.emitter = null;
            this.particleSize = 5;
            this.particleSprite = null;
            this.sizeRate = 0;
            this.elapsedMultiplier = 0;
            var emitter = emitterOrConfig;
            if (emitter && !(emitterOrConfig instanceof ParticleEmitter)) {
                var config = emitterOrConfig;
                emitter = config.emitter;
                life = config.life;
                opacity = config.opacity;
                endColor = config.endColor;
                beginColor = config.beginColor;
                position = config.position;
                velocity = config.velocity;
                acceleration = config.acceleration;
                startSize = config.startSize;
                endSize = config.endSize;
            }
            this.emitter = emitter;
            this.life = life || this.life;
            this.opacity = opacity || this.opacity;
            this.endColor = endColor || this.endColor.clone();
            this.beginColor = beginColor || this.beginColor.clone();
            this._currentColor = this.beginColor.clone();
            this.position = position || this.position;
            this.velocity = velocity || this.velocity;
            this.acceleration = acceleration || this.acceleration;
            this._rRate = (this.endColor.r - this.beginColor.r) / this.life;
            this._gRate = (this.endColor.g - this.beginColor.g) / this.life;
            this._bRate = (this.endColor.b - this.beginColor.b) / this.life;
            this._aRate = this.opacity / this.life;
            this.startSize = startSize || 0;
            this.endSize = endSize || 0;
            if ((this.endSize > 0) && (this.startSize > 0)) {
                this.sizeRate = (this.endSize - this.startSize) / this.life;
                this.particleSize = this.startSize;
            }
        }
        ParticleImpl.prototype.kill = function () {
            this.emitter.removeParticle(this);
        };
        ParticleImpl.prototype.update = function (delta) {
            this.life = this.life - delta;
            this.elapsedMultiplier = this.elapsedMultiplier + delta;
            if (this.life < 0) {
                this.kill();
            }
            if (this.fadeFlag) {
                this.opacity = Util.clamp(this._aRate * this.life, 0.0001, 1);
            }
            if ((this.startSize > 0) && (this.endSize > 0)) {
                this.particleSize = Util.clamp(this.sizeRate * delta + this.particleSize, Math.min(this.startSize, this.endSize), Math.max(this.startSize, this.endSize));
            }
            this._currentColor.r = Util.clamp(this._currentColor.r + this._rRate * delta, 0, 255);
            this._currentColor.g = Util.clamp(this._currentColor.g + this._gRate * delta, 0, 255);
            this._currentColor.b = Util.clamp(this._currentColor.b + this._bRate * delta, 0, 255);
            this._currentColor.a = Util.clamp(this.opacity, 0.0001, 1);
            if (this.focus) {
                var accel = this.focus.sub(this.position).normalize().scale(this.focusAccel).scale(delta / 1000);
                this.velocity = this.velocity.add(accel);
            }
            else {
                this.velocity = this.velocity.add(this.acceleration.scale(delta / 1000));
            }
            this.position = this.position.add(this.velocity.scale(delta / 1000));
            if (this.particleRotationalVelocity) {
                this.currentRotation = (this.currentRotation + this.particleRotationalVelocity * delta / 1000) % (2 * Math.PI);
            }
        };
        ParticleImpl.prototype.draw = function (ctx) {
            if (this.particleSprite) {
                this.particleSprite.rotation = this.currentRotation;
                this.particleSprite.scale.setTo(this.particleSize, this.particleSize);
                this.particleSprite.draw(ctx, this.position.x, this.position.y);
                return;
            }
            this._currentColor.a = Util.clamp(this.opacity, 0.0001, 1);
            ctx.fillStyle = this._currentColor.toString();
            ctx.beginPath();
            ctx.arc(this.position.x, this.position.y, this.particleSize, 0, Math.PI * 2);
            ctx.fill();
            ctx.closePath();
        };
        return ParticleImpl;
    }());
    exports.ParticleImpl = ParticleImpl;
    /**
     * Particle is used in a [[ParticleEmitter]]
     */
    var Particle = (function (_super) {
        __extends(Particle, _super);
        function Particle(emitterOrConfig, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize) {
            return _super.call(this, emitterOrConfig, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize) || this;
        }
        return Particle;
    }(Configurable_5.Configurable(ParticleImpl)));
    exports.Particle = Particle;
    /**
     * @hidden
     */
    var ParticleEmitterImpl = (function (_super) {
        __extends(ParticleEmitterImpl, _super);
        /**
         * @param x       The x position of the emitter
         * @param y       The y position of the emitter
         * @param width   The width of the emitter
         * @param height  The height of the emitter
         */
        function ParticleEmitterImpl(xOrConfig, y, width, height) {
            var _this = _super.call(this, typeof xOrConfig === 'number' ? { x: xOrConfig, y: y, width: width, height: height } : xOrConfig) || this;
            _this.numParticles = 0;
            /**
             * Gets or sets the isEmitting flag
             */
            _this.isEmitting = true;
            /**
             * Gets or sets the backing particle collection
             */
            _this.particles = null;
            /**
             * Gets or sets the backing deadParticle collection
             */
            _this.deadParticles = null;
            /**
             * Gets or sets the minimum particle velocity
             */
            _this.minVel = 0;
            /**
             * Gets or sets the maximum particle velocity
             */
            _this.maxVel = 0;
            /**
             * Gets or sets the acceleration vector for all particles
             */
            _this.acceleration = new Algebra_15.Vector(0, 0);
            /**
             * Gets or sets the minimum angle in radians
             */
            _this.minAngle = 0;
            /**
             * Gets or sets the maximum angle in radians
             */
            _this.maxAngle = 0;
            /**
             * Gets or sets the emission rate for particles (particles/sec)
             */
            _this.emitRate = 1; //particles/sec
            /**
             * Gets or sets the life of each particle in milliseconds
             */
            _this.particleLife = 2000;
            /**
             * Gets or sets the opacity of each particle from 0 to 1.0
             */
            _this.opacity = 1;
            /**
             * Gets or sets the fade flag which causes particles to gradually fade out over the course of their life.
             */
            _this.fadeFlag = false;
            /**
             * Gets or sets the optional focus where all particles should accelerate towards
             */
            _this.focus = null;
            /**
             * Gets or sets the acceleration for focusing particles if a focus has been specified
             */
            _this.focusAccel = 1;
            /*
             * Gets or sets the optional starting size for the particles
             */
            _this.startSize = null;
            /*
             * Gets or sets the optional ending size for the particles
             */
            _this.endSize = null;
            /**
             * Gets or sets the minimum size of all particles
             */
            _this.minSize = 5;
            /**
             * Gets or sets the maximum size of all particles
             */
            _this.maxSize = 5;
            /**
             * Gets or sets the beginning color of all particles
             */
            _this.beginColor = Color_14.Color.White.clone();
            /**
             * Gets or sets the ending color of all particles
             */
            _this.endColor = Color_14.Color.White.clone();
            /**
             * Gets or sets the sprite that a particle should use
             * @warning Performance intensive
             */
            _this.particleSprite = null;
            /**
             * Gets or sets the emitter type for the particle emitter
             */
            _this.emitterType = EmitterType.Rectangle;
            /**
             * Gets or sets the emitter radius, only takes effect when the [[emitterType]] is [[EmitterType.Circle]]
             */
            _this.radius = 0;
            /**
             * Gets or sets the particle rotational speed velocity
             */
            _this.particleRotationalVelocity = 0;
            /**
             * Indicates whether particles should start with a random rotation
             */
            _this.randomRotation = false;
            _this._particlesToEmit = 0;
            _this.collisionType = Actor_7.CollisionType.PreventCollision;
            _this.particles = new Util.Collection();
            _this.deadParticles = new Util.Collection();
            _this.random = new Random_2.Random();
            // Remove offscreen culling from particle emitters
            for (var i = 0; i < _this.traits.length; i++) {
                if (_this.traits[i] instanceof Traits.OffscreenCulling) {
                    _this.traits.splice(i, 1);
                }
            }
            return _this;
        }
        ParticleEmitterImpl.prototype.removeParticle = function (particle) {
            this.deadParticles.push(particle);
        };
        /**
         * Causes the emitter to emit particles
         * @param particleCount  Number of particles to emit right now
         */
        ParticleEmitterImpl.prototype.emitParticles = function (particleCount) {
            for (var i = 0; i < particleCount; i++) {
                this.particles.push(this._createParticle());
            }
        };
        ParticleEmitterImpl.prototype.clearParticles = function () {
            this.particles.clear();
        };
        // Creates a new particle given the constraints of the emitter
        ParticleEmitterImpl.prototype._createParticle = function () {
            // todo implement emitter constraints;
            var ranX = 0;
            var ranY = 0;
            var angle = Util.randomInRange(this.minAngle, this.maxAngle, this.random);
            var vel = Util.randomInRange(this.minVel, this.maxVel, this.random);
            var size = this.startSize || Util.randomInRange(this.minSize, this.maxSize, this.random);
            var dx = vel * Math.cos(angle);
            var dy = vel * Math.sin(angle);
            if (this.emitterType === EmitterType.Rectangle) {
                ranX = Util.randomInRange(this.pos.x, this.pos.x + this.getWidth(), this.random);
                ranY = Util.randomInRange(this.pos.y, this.pos.y + this.getHeight(), this.random);
            }
            else if (this.emitterType === EmitterType.Circle) {
                var radius = Util.randomInRange(0, this.radius, this.random);
                ranX = radius * Math.cos(angle) + this.pos.x;
                ranY = radius * Math.sin(angle) + this.pos.y;
            }
            var p = new Particle(this, this.particleLife, this.opacity, this.beginColor, this.endColor, new Algebra_15.Vector(ranX, ranY), new Algebra_15.Vector(dx, dy), this.acceleration, this.startSize, this.endSize);
            p.fadeFlag = this.fadeFlag;
            p.particleSize = size;
            if (this.particleSprite) {
                p.particleSprite = this.particleSprite;
            }
            p.particleRotationalVelocity = this.particleRotationalVelocity;
            if (this.randomRotation) {
                p.currentRotation = Util.randomInRange(0, Math.PI * 2, this.random);
            }
            if (this.focus) {
                p.focus = this.focus.add(new Algebra_15.Vector(this.pos.x, this.pos.y));
                p.focusAccel = this.focusAccel;
            }
            return p;
        };
        ParticleEmitterImpl.prototype.update = function (engine, delta) {
            var _this = this;
            _super.prototype.update.call(this, engine, delta);
            if (this.isEmitting) {
                this._particlesToEmit += this.emitRate * (delta / 1000);
                //var numParticles = Math.ceil(this.emitRate * delta / 1000);
                if (this._particlesToEmit > 1.0) {
                    this.emitParticles(Math.floor(this._particlesToEmit));
                    this._particlesToEmit = this._particlesToEmit - Math.floor(this._particlesToEmit);
                }
            }
            this.particles.forEach(function (p) { return p.update(delta); });
            this.deadParticles.forEach(function (p) { return _this.particles.removeElement(p); });
            this.deadParticles.clear();
        };
        ParticleEmitterImpl.prototype.draw = function (ctx) {
            // todo is there a more efficient to draw 
            // possibly use a webgl offscreen canvas and shaders to do particles?
            this.particles.forEach(function (p) { return p.draw(ctx); });
        };
        ParticleEmitterImpl.prototype.debugDraw = function (ctx) {
            _super.prototype.debugDraw.call(this, ctx);
            ctx.fillStyle = Color_14.Color.Black.toString();
            ctx.fillText('Particles: ' + this.particles.count(), this.pos.x, this.pos.y + 20);
            if (this.focus) {
                ctx.fillRect(this.focus.x + this.pos.x, this.focus.y + this.pos.y, 3, 3);
                DrawUtil.line(ctx, Color_14.Color.Yellow, this.focus.x + this.pos.x, this.focus.y + this.pos.y, _super.prototype.getCenter.call(this).x, _super.prototype.getCenter.call(this).y);
                ctx.fillText('Focus', this.focus.x + this.pos.x, this.focus.y + this.pos.y);
            }
        };
        return ParticleEmitterImpl;
    }(Actor_7.Actor));
    exports.ParticleEmitterImpl = ParticleEmitterImpl;
    /**
     * Using a particle emitter is a great way to create interesting effects
     * in your game, like smoke, fire, water, explosions, etc. `ParticleEmitter`
     * extend [[Actor]] allowing you to use all of the features that come with.
     *
     * [[include:Particles.md]]
     */
    var ParticleEmitter = (function (_super) {
        __extends(ParticleEmitter, _super);
        function ParticleEmitter(xOrConfig, y, width, height) {
            return _super.call(this, xOrConfig, y, width, height) || this;
        }
        return ParticleEmitter;
    }(Configurable_5.Configurable(ParticleEmitterImpl)));
    exports.ParticleEmitter = ParticleEmitter;
});
define("TileMap", ["require", "exports", "Collision/BoundingBox", "Drawing/Color", "Class", "Algebra", "Util/Log", "Events", "Configurable"], function (require, exports, BoundingBox_4, Color_15, Class_4, Algebra_16, Log_7, Events, Configurable_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @hidden
     */
    var TileMapImpl = (function (_super) {
        __extends(TileMapImpl, _super);
        /**
         * @param x             The x coordinate to anchor the TileMap's upper left corner (should not be changed once set)
         * @param y             The y coordinate to anchor the TileMap's upper left corner (should not be changed once set)
         * @param cellWidth     The individual width of each cell (in pixels) (should not be changed once set)
         * @param cellHeight    The individual height of each cell (in pixels) (should not be changed once set)
         * @param rows          The number of rows in the TileMap (should not be changed once set)
         * @param cols          The number of cols in the TileMap (should not be changed once set)
         */
        function TileMapImpl(xOrConfig, y, cellWidth, cellHeight, rows, cols) {
            var _this = _super.call(this) || this;
            _this._collidingX = -1;
            _this._collidingY = -1;
            _this._onScreenXStart = 0;
            _this._onScreenXEnd = 9999;
            _this._onScreenYStart = 0;
            _this._onScreenYEnd = 9999;
            _this._spriteSheets = {};
            _this.logger = Log_7.Logger.getInstance();
            _this.data = [];
            if (xOrConfig && typeof xOrConfig === 'object') {
                var config = xOrConfig;
                xOrConfig = config.x;
                y = config.y;
                cellWidth = config.cellWidth;
                cellHeight = config.cellHeight;
                rows = config.rows;
                cols = config.cols;
            }
            _this.data = new Array(rows * cols);
            for (var i = 0; i < cols; i++) {
                for (var j = 0; j < rows; j++) {
                    (function () {
                        var cd = new Cell(i * cellWidth + xOrConfig, j * cellHeight + y, cellWidth, cellHeight, i + j * cols);
                        _this.data[i + j * cols] = cd;
                    })();
                }
            }
            return _this;
        }
        TileMapImpl.prototype.on = function (eventName, handler) {
            _super.prototype.on.call(this, eventName, handler);
        };
        TileMapImpl.prototype.registerSpriteSheet = function (key, spriteSheet) {
            this._spriteSheets[key] = spriteSheet;
        };
        /**
         * Returns the intersection vector that can be used to resolve collisions with actors. If there
         * is no collision null is returned.
         */
        TileMapImpl.prototype.collides = function (actor) {
            var width = actor.pos.x + actor.getWidth();
            var height = actor.pos.y + actor.getHeight();
            var actorBounds = actor.getBounds();
            var overlaps = [];
            // trace points for overlap
            for (var x = actorBounds.left; x <= width; x += Math.min(actor.getWidth() / 2, this.cellWidth / 2)) {
                for (var y = actorBounds.top; y <= height; y += Math.min(actor.getHeight() / 2, this.cellHeight / 2)) {
                    var cell = this.getCellByPoint(x, y);
                    if (cell && cell.solid) {
                        var overlap = actorBounds.collides(cell.getBounds());
                        var dir = actor.getCenter().sub(cell.getCenter());
                        if (overlap && overlap.dot(dir) > 0) {
                            overlaps.push(overlap);
                        }
                    }
                }
            }
            if (overlaps.length === 0) {
                return null;
            }
            // Return the smallest change other than zero
            var result = overlaps.reduce(function (accum, next) {
                var x = accum.x;
                var y = accum.y;
                if (Math.abs(accum.x) < Math.abs(next.x)) {
                    x = next.x;
                }
                if (Math.abs(accum.y) < Math.abs(next.y)) {
                    y = next.y;
                }
                return new Algebra_16.Vector(x, y);
            });
            return result;
        };
        /**
         * Returns the [[Cell]] by index (row major order)
         */
        TileMapImpl.prototype.getCellByIndex = function (index) {
            return this.data[index];
        };
        /**
         * Returns the [[Cell]] by its x and y coordinates
         */
        TileMapImpl.prototype.getCell = function (x, y) {
            if (x < 0 || y < 0 || x >= this.cols || y >= this.rows) {
                return null;
            }
            return this.data[x + y * this.cols];
        };
        /**
         * Returns the [[Cell]] by testing a point in global coordinates,
         * returns `null` if no cell was found.
         */
        TileMapImpl.prototype.getCellByPoint = function (x, y) {
            x = Math.floor((x - this.x) / this.cellWidth);
            y = Math.floor((y - this.y) / this.cellHeight);
            var cell = this.getCell(x, y);
            if (x >= 0 && y >= 0 && x < this.cols && y < this.rows && cell) {
                return cell;
            }
            return null;
        };
        TileMapImpl.prototype.update = function (engine, delta) {
            this.emit('preupdate', new Events.PreUpdateEvent(engine, delta, this));
            var worldCoordsUpperLeft = engine.screenToWorldCoordinates(new Algebra_16.Vector(0, 0));
            var worldCoordsLowerRight = engine.screenToWorldCoordinates(new Algebra_16.Vector(engine.canvas.clientWidth, engine.canvas.clientHeight));
            this._onScreenXStart = Math.max(Math.floor(worldCoordsUpperLeft.x / this.cellWidth) - 2, 0);
            this._onScreenYStart = Math.max(Math.floor((worldCoordsUpperLeft.y - this.y) / this.cellHeight) - 2, 0);
            this._onScreenXEnd = Math.max(Math.floor(worldCoordsLowerRight.x / this.cellWidth) + 2, 0);
            this._onScreenYEnd = Math.max(Math.floor((worldCoordsLowerRight.y - this.y) / this.cellHeight) + 2, 0);
            this.emit('postupdate', new Events.PostUpdateEvent(engine, delta, this));
        };
        /**
         * Draws the tile map to the screen. Called by the [[Scene]].
         * @param ctx    The current rendering context
         * @param delta  The number of milliseconds since the last draw
         */
        TileMapImpl.prototype.draw = function (ctx, delta) {
            this.emit('predraw', new Events.PreDrawEvent(ctx, delta, this));
            ctx.save();
            ctx.translate(this.x, this.y);
            var x = this._onScreenXStart, xEnd = Math.min(this._onScreenXEnd, this.cols);
            var y = this._onScreenYStart, yEnd = Math.min(this._onScreenYEnd, this.rows);
            var cs, csi, cslen;
            for (x; x < xEnd; x++) {
                for (y; y < yEnd; y++) {
                    // get non-negative tile sprites
                    cs = this.getCell(x, y).sprites.filter(function (s) {
                        return s.spriteId > -1;
                    });
                    for (csi = 0, cslen = cs.length; csi < cslen; csi++) {
                        var ss = this._spriteSheets[cs[csi].spriteSheetKey];
                        // draw sprite, warning if sprite doesn't exist
                        if (ss) {
                            var sprite = ss.getSprite(cs[csi].spriteId);
                            if (sprite) {
                                sprite.draw(ctx, x * this.cellWidth, y * this.cellHeight);
                            }
                            else {
                                this.logger.warn('Sprite does not exist for id', cs[csi].spriteId, 'in sprite sheet', cs[csi].spriteSheetKey, sprite, ss);
                            }
                        }
                        else {
                            this.logger.warn('Sprite sheet', cs[csi].spriteSheetKey, 'does not exist', ss);
                        }
                    }
                }
                y = this._onScreenYStart;
            }
            ctx.restore();
            this.emit('postdraw', new Events.PostDrawEvent(ctx, delta, this));
        };
        /**
         * Draws all the tile map's debug info. Called by the [[Scene]].
         * @param ctx  The current rendering context
         */
        TileMapImpl.prototype.debugDraw = function (ctx) {
            var width = this.cols * this.cellWidth;
            var height = this.rows * this.cellHeight;
            ctx.save();
            ctx.strokeStyle = Color_15.Color.Red.toString();
            for (var x = 0; x < this.cols + 1; x++) {
                ctx.beginPath();
                ctx.moveTo(this.x + x * this.cellWidth, this.y);
                ctx.lineTo(this.x + x * this.cellWidth, this.y + height);
                ctx.stroke();
            }
            for (var y = 0; y < this.rows + 1; y++) {
                ctx.beginPath();
                ctx.moveTo(this.x, this.y + y * this.cellHeight);
                ctx.lineTo(this.x + width, this.y + y * this.cellHeight);
                ctx.stroke();
            }
            var solid = Color_15.Color.Red.clone();
            solid.a = .3;
            this.data.filter(function (cell) {
                return cell.solid;
            }).forEach(function (cell) {
                ctx.fillStyle = solid.toString();
                ctx.fillRect(cell.x, cell.y, cell.width, cell.height);
            });
            if (this._collidingY > -1 && this._collidingX > -1) {
                ctx.fillStyle = Color_15.Color.Cyan.toString();
                ctx.fillRect(this.x + this._collidingX * this.cellWidth, this.y + this._collidingY * this.cellHeight, this.cellWidth, this.cellHeight);
            }
            ctx.restore();
        };
        return TileMapImpl;
    }(Class_4.Class));
    exports.TileMapImpl = TileMapImpl;
    /**
     * The [[TileMap]] class provides a lightweight way to do large complex scenes with collision
     * without the overhead of actors.
     *
     * [[include:TileMaps.md]]
     */
    var TileMap = (function (_super) {
        __extends(TileMap, _super);
        function TileMap(xOrConfig, y, cellWidth, cellHeight, rows, cols) {
            return _super.call(this, xOrConfig, y, cellWidth, cellHeight, rows, cols) || this;
        }
        return TileMap;
    }(Configurable_6.Configurable(TileMapImpl)));
    exports.TileMap = TileMap;
    /**
     * Tile sprites are used to render a specific sprite from a [[TileMap]]'s spritesheet(s)
     */
    var TileSprite = (function () {
        /**
         * @param spriteSheetKey  The key of the spritesheet to use
         * @param spriteId        The index of the sprite in the [[SpriteSheet]]
         */
        function TileSprite(spriteSheetKey, spriteId) {
            this.spriteSheetKey = spriteSheetKey;
            this.spriteId = spriteId;
        }
        return TileSprite;
    }());
    exports.TileSprite = TileSprite;
    /**
     * @hidden
     */
    var CellImpl = (function () {
        /**
         * @param x       Gets or sets x coordinate of the cell in world coordinates
         * @param y       Gets or sets y coordinate of the cell in world coordinates
         * @param width   Gets or sets the width of the cell
         * @param height  Gets or sets the height of the cell
         * @param index   The index of the cell in row major order
         * @param solid   Gets or sets whether this cell is solid
         * @param sprites The list of tile sprites to use to draw in this cell (in order)
         */
        function CellImpl(xOrConfig, y, width, height, index, solid, sprites) {
            if (solid === void 0) { solid = false; }
            if (sprites === void 0) { sprites = []; }
            this.solid = false;
            this.sprites = [];
            if (xOrConfig && typeof xOrConfig === 'object') {
                var config = xOrConfig;
                xOrConfig = config.x;
                y = config.y;
                width = config.width;
                height = config.height;
                index = config.index;
                solid = config.solid;
                sprites = config.sprites;
            }
            this.x = xOrConfig;
            this.y = y;
            this.width = width;
            this.height = height;
            this.index = index;
            this.solid = solid;
            this.sprites = sprites;
            this._bounds = new BoundingBox_4.BoundingBox(this.x, this.y, this.x + this.width, this.y + this.height);
        }
        /**
         * Returns the bounding box for this cell
         */
        CellImpl.prototype.getBounds = function () {
            return this._bounds;
        };
        /**
         * Gets the center coordinate of this cell
         */
        CellImpl.prototype.getCenter = function () {
            return new Algebra_16.Vector(this.x + this.width / 2, this.y + this.height / 2);
        };
        /**
         * Add another [[TileSprite]] to this cell
         */
        CellImpl.prototype.pushSprite = function (tileSprite) {
            this.sprites.push(tileSprite);
        };
        /**
         * Remove an instance of [[TileSprite]] from this cell
         */
        CellImpl.prototype.removeSprite = function (tileSprite) {
            var index = -1;
            if ((index = this.sprites.indexOf(tileSprite)) > -1) {
                this.sprites.splice(index, 1);
            }
        };
        /**
         * Clear all sprites from this cell
         */
        CellImpl.prototype.clearSprites = function () {
            this.sprites.length = 0;
        };
        return CellImpl;
    }());
    exports.CellImpl = CellImpl;
    /**
     * TileMap Cell
     *
     * A light-weight object that occupies a space in a collision map. Generally
     * created by a [[TileMap]].
     *
     * Cells can draw multiple sprites. Note that the order of drawing is the order
     * of the sprites in the array so the last one will be drawn on top. You can
     * use transparency to create layers this way.
     */
    var Cell = (function (_super) {
        __extends(Cell, _super);
        function Cell(xOrConfig, y, width, height, index, solid, sprites) {
            return _super.call(this, xOrConfig, y, width, height, index, solid, sprites) || this;
        }
        return Cell;
    }(Configurable_6.Configurable(CellImpl)));
    exports.Cell = Cell;
});
define("Timer", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The Excalibur timer hooks into the internal timer and fires callbacks,
     * after a certain interval, optionally repeating.
     */
    var Timer = (function () {
        /**
         * @param fcn        The callback to be fired after the interval is complete.
         * @param interval   Interval length
         * @param repeats    Indicates whether this call back should be fired only once, or repeat after every interval as completed.
         */
        function Timer(fcn, interval, repeats) {
            this.id = 0;
            this.interval = 10;
            this.fcn = function () { return; };
            this.repeats = false;
            this._elapsedTime = 0;
            this._totalTimeAlive = 0;
            this._paused = false;
            this.complete = false;
            this.scene = null;
            this.id = Timer.id++;
            this.interval = interval || this.interval;
            this.fcn = fcn || this.fcn;
            this.repeats = repeats || this.repeats;
        }
        /**
         * Updates the timer after a certain number of milliseconds have elapsed. This is used internally by the engine.
         * @param delta  Number of elapsed milliseconds since the last update.
         */
        Timer.prototype.update = function (delta) {
            if (!this._paused) {
                this._totalTimeAlive += delta;
                this._elapsedTime += delta;
                if (!this.complete && this._elapsedTime >= this.interval) {
                    this.fcn.call(this);
                    if (this.repeats) {
                        this._elapsedTime = 0;
                    }
                    else {
                        this.complete = true;
                    }
                }
            }
        };
        /**
         * Resets the timer so that it can be reused, and optionally reconfigure the timers interval.
         * @param newInterval If specified, sets a new non-negative interval in milliseconds to refire the callback
         */
        Timer.prototype.reset = function (newInterval) {
            if (!!newInterval && newInterval >= 0) {
                this.interval = newInterval;
            }
            this.complete = false;
            this._elapsedTime = 0;
        };
        Timer.prototype.getTimeRunning = function () {
            return this._totalTimeAlive;
        };
        /**
         * Pauses the timer so that no more time will be incremented towards the next call
         */
        Timer.prototype.pause = function () {
            this._paused = true;
        };
        /**
         * Unpauses the timer. Time will now increment towards the next call
         */
        Timer.prototype.unpause = function () {
            this._paused = false;
        };
        /**
         * Cancels the timer, preventing any further executions.
         */
        Timer.prototype.cancel = function () {
            if (this.scene) {
                this.scene.cancelTimer(this);
            }
        };
        return Timer;
    }());
    Timer.id = 0;
    exports.Timer = Timer;
});
define("Trigger", ["require", "exports", "Drawing/Color", "Actions/Action", "EventDispatcher", "Actor", "Algebra", "Events", "Util/Util"], function (require, exports, Color_16, Action_1, EventDispatcher_1, Actor_8, Algebra_17, Events_5, Util) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var triggerDefaults = {
        pos: Algebra_17.Vector.Zero.clone(),
        width: 10,
        height: 10,
        visible: false,
        action: function () { return; },
        filter: function () { return true; },
        repeat: -1
    };
    /**
     * Triggers are a method of firing arbitrary code on collision. These are useful
     * as 'buttons', 'switches', or to trigger effects in a game. By default triggers
     * are invisible, and can only be seen when [[Trigger.visible]] is set to `true`.
     *
     * [[include:Triggers.md]]
     */
    var Trigger = (function (_super) {
        __extends(Trigger, _super);
        /**
         *
         * @param opts Trigger options
         */
        function Trigger(opts) {
            var _this = _super.call(this, opts.pos.x, opts.pos.y, opts.width, opts.height) || this;
            /**
             * Action to fire when triggered by collision
             */
            _this.action = function () { return; };
            /**
             * Filter to add additional granularity to action dispatch, if a filter is specified the action will only fire when
             * filter return true for the collided actor.
             */
            _this.filter = function () { return true; };
            /**
             * Number of times to repeat before killing the trigger,
             */
            _this.repeat = -1;
            opts = Util.extend({}, triggerDefaults, opts);
            _this.filter = opts.filter || _this.filter;
            _this.repeat = opts.repeat || _this.repeat;
            _this.action = opts.action || _this.action;
            if (opts.target) {
                _this.target = opts.target;
            }
            _this.visible = opts.visible;
            _this.collisionType = Actor_8.CollisionType.Passive;
            _this.eventDispatcher = new EventDispatcher_1.EventDispatcher(_this);
            _this.actionQueue = new Action_1.ActionQueue(_this);
            _this.on('collisionstart', function (evt) {
                if (_this.filter(evt.other)) {
                    _this.emit('enter', new Events_5.EnterTriggerEvent(_this, evt.other));
                    _this._dispatchAction();
                    // remove trigger if its done, -1 repeat forever
                    if (_this.repeat === 0) {
                        _this.kill();
                    }
                }
            });
            _this.on('collisionend', function (evt) {
                if (_this.filter(evt.other)) {
                    _this.emit('exit', new Events_5.ExitTriggerEvent(_this, evt.other));
                }
            });
            return _this;
        }
        Object.defineProperty(Trigger.prototype, "target", {
            get: function () {
                return this._target;
            },
            set: function (target) {
                this._target = target;
                this.filter = function (actor) { return actor === target; };
            },
            enumerable: true,
            configurable: true
        });
        Trigger.prototype._initialize = function (engine) {
            _super.prototype._initialize.call(this, engine);
        };
        Trigger.prototype._dispatchAction = function () {
            this.action.call(this);
            this.repeat--;
        };
        /* istanbul ignore next */
        Trigger.prototype.debugDraw = function (ctx) {
            _super.prototype.debugDraw.call(this, ctx);
            // Meant to draw debug information about actors
            ctx.save();
            ctx.translate(this.pos.x, this.pos.y);
            var bb = this.getBounds();
            var wp = this.getWorldPos();
            bb.left = bb.left - wp.x;
            bb.right = bb.right - wp.x;
            bb.top = bb.top - wp.y;
            bb.bottom = bb.bottom - wp.y;
            // Currently collision primitives cannot rotate 
            // ctx.rotate(this.rotation);
            ctx.fillStyle = Color_16.Color.Violet.toString();
            ctx.strokeStyle = Color_16.Color.Violet.toString();
            ctx.fillText('Trigger', 10, 10);
            bb.debugDraw(ctx);
            ctx.restore();
        };
        return Trigger;
    }(Actor_8.Actor));
    exports.Trigger = Trigger;
});
define("Actions/Index", ["require", "exports", "Actions/ActionContext", "Actions/RotationType", "Actions/Action"], function (require, exports, ActionContext_2, RotationType_1, actions) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(ActionContext_2);
    __export(RotationType_1);
    exports.Actions = actions;
    // legacy Internal.Actions namespace support
    exports.Internal = { Actions: actions };
});
define("Collision/DynamicTree", ["require", "exports", "Physics", "Collision/BoundingBox", "Util/Log"], function (require, exports, Physics_8, BoundingBox_5, Log_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Dynamic Tree Node used for tracking bounds within the tree
     */
    var TreeNode = (function () {
        function TreeNode(parent) {
            this.parent = parent;
            this.parent = parent || null;
            this.body = null;
            this.bounds = new BoundingBox_5.BoundingBox();
            this.left = null;
            this.right = null;
            this.height = 0;
        }
        TreeNode.prototype.isLeaf = function () {
            return (!this.left && !this.right);
        };
        return TreeNode;
    }());
    exports.TreeNode = TreeNode;
    /**
     * The DynamicTrees provides a spatial partiioning data structure for quickly querying for overlapping bounding boxes for
     * all tracked bodies. The worst case performance of this is O(n*log(n)) where n is the number of bodies in the tree.
     *
     * Internally the bounding boxes are organized as a balanced binary tree of bounding boxes, where the leaf nodes are tracked bodies.
     * Every non-leaf node is a bounding box that contains child bounding boxes.
     */
    var DynamicTree = (function () {
        function DynamicTree(worldBounds) {
            if (worldBounds === void 0) { worldBounds = new BoundingBox_5.BoundingBox(-Number.MAX_VALUE, -Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE); }
            this.worldBounds = worldBounds;
            this.root = null;
            this.nodes = {};
        }
        /**
         * Inserts a node into the dynamic tree
         */
        DynamicTree.prototype._insert = function (leaf) {
            // If there are no nodes in the tree, make this the root leaf
            if (this.root === null) {
                this.root = leaf;
                this.root.parent = null;
                return;
            }
            // Search the tree for a node that is not a leaf and find the best place to insert
            var leafAABB = leaf.bounds;
            var currentRoot = this.root;
            while (!currentRoot.isLeaf()) {
                var left = currentRoot.left;
                var right = currentRoot.right;
                var area = currentRoot.bounds.getPerimeter();
                var combinedAABB = currentRoot.bounds.combine(leafAABB);
                var combinedArea = combinedAABB.getPerimeter();
                // Calculate cost heuristic for creating a new parent and leaf
                var cost = 2 * combinedArea;
                // Minimum cost of pushing the leaf down the tree
                var inheritanceCost = 2 * (combinedArea - area);
                // Cost of descending
                var leftCost = 0;
                var leftCombined = leafAABB.combine(left.bounds);
                var newArea;
                var oldArea;
                if (left.isLeaf()) {
                    leftCost = leftCombined.getPerimeter() + inheritanceCost;
                }
                else {
                    oldArea = left.bounds.getPerimeter();
                    newArea = leftCombined.getPerimeter();
                    leftCost = (newArea - oldArea) + inheritanceCost;
                }
                var rightCost = 0;
                var rightCombined = leafAABB.combine(right.bounds);
                if (right.isLeaf()) {
                    rightCost = rightCombined.getPerimeter() + inheritanceCost;
                }
                else {
                    oldArea = right.bounds.getPerimeter();
                    newArea = rightCombined.getPerimeter();
                    rightCost = (newArea - oldArea) + inheritanceCost;
                }
                // cost is acceptable
                if (cost < leftCost && cost < rightCost) {
                    break;
                }
                // Descend to the depths
                if (leftCost < rightCost) {
                    currentRoot = left;
                }
                else {
                    currentRoot = right;
                }
            }
            // Create the new parent node and insert into the tree
            var oldParent = currentRoot.parent;
            var newParent = new TreeNode(oldParent);
            newParent.bounds = leafAABB.combine(currentRoot.bounds);
            newParent.height = currentRoot.height + 1;
            if (oldParent !== null) {
                // The sibling node was not the root
                if (oldParent.left === currentRoot) {
                    oldParent.left = newParent;
                }
                else {
                    oldParent.right = newParent;
                }
                newParent.left = currentRoot;
                newParent.right = leaf;
                currentRoot.parent = newParent;
                leaf.parent = newParent;
            }
            else {
                // The sibling node was the root
                newParent.left = currentRoot;
                newParent.right = leaf;
                currentRoot.parent = newParent;
                leaf.parent = newParent;
                this.root = newParent;
            }
            // Walk up the tree fixing heights and AABBs
            var currentNode = leaf.parent;
            while (currentNode) {
                currentNode = this._balance(currentNode);
                if (!currentNode.left) {
                    throw new Error('Parent of current leaf cannot have a null left child' + currentNode);
                }
                if (!currentNode.right) {
                    throw new Error('Parent of current leaf cannot have a null right child' + currentNode);
                }
                currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);
                currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);
                currentNode = currentNode.parent;
            }
        };
        /**
         * Removes a node from the dynamic tree
         */
        DynamicTree.prototype._remove = function (leaf) {
            if (leaf === this.root) {
                this.root = null;
                return;
            }
            var parent = leaf.parent;
            var grandParent = parent.parent;
            var sibling;
            if (parent.left === leaf) {
                sibling = parent.right;
            }
            else {
                sibling = parent.left;
            }
            if (grandParent) {
                if (grandParent.left === parent) {
                    grandParent.left = sibling;
                }
                else {
                    grandParent.right = sibling;
                }
                sibling.parent = grandParent;
                var currentNode = grandParent;
                while (currentNode) {
                    currentNode = this._balance(currentNode);
                    currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);
                    currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);
                    currentNode = currentNode.parent;
                }
            }
            else {
                this.root = sibling;
                sibling.parent = null;
            }
        };
        /**
         * Tracks a body in the dynamic tree
         */
        DynamicTree.prototype.trackBody = function (body) {
            var node = new TreeNode();
            node.body = body;
            node.bounds = body.getBounds();
            node.bounds.left -= 2;
            node.bounds.top -= 2;
            node.bounds.right += 2;
            node.bounds.bottom += 2;
            this.nodes[body.actor.id] = node;
            this._insert(node);
        };
        /**
         * Updates the dynamic tree given the current bounds of each body being tracked
         */
        DynamicTree.prototype.updateBody = function (body) {
            var node = this.nodes[body.actor.id];
            if (!node) {
                return false;
            }
            var b = body.getBounds();
            // if the body is outside the world no longer update it
            if (!this.worldBounds.contains(b)) {
                Log_8.Logger.getInstance().warn('Actor with id ' + body.actor.id +
                    ' is outside the world bounds and will no longer be tracked for physics');
                this.untrackBody(body);
                return false;
            }
            if (node.bounds.contains(b)) {
                return false;
            }
            this._remove(node);
            b.left -= Physics_8.Physics.boundsPadding;
            b.top -= Physics_8.Physics.boundsPadding;
            b.right += Physics_8.Physics.boundsPadding;
            b.bottom += Physics_8.Physics.boundsPadding;
            var multdx = body.vel.x * Physics_8.Physics.dynamicTreeVelocityMultiplyer;
            var multdy = body.vel.y * Physics_8.Physics.dynamicTreeVelocityMultiplyer;
            if (multdx < 0) {
                b.left += multdx;
            }
            else {
                b.right += multdx;
            }
            if (multdy < 0) {
                b.top += multdy;
            }
            else {
                b.bottom += multdy;
            }
            node.bounds = b;
            this._insert(node);
            return true;
        };
        /**
         * Untracks a body from the dynamic tree
         */
        DynamicTree.prototype.untrackBody = function (body) {
            var node = this.nodes[body.actor.id];
            if (!node) {
                return;
            }
            this._remove(node);
            this.nodes[body.actor.id] = null;
            delete this.nodes[body.actor.id];
        };
        /**
         * Balances the tree about a node
         */
        DynamicTree.prototype._balance = function (node) {
            if (node === null) {
                throw new Error('Cannot balance at null node');
            }
            if (node.isLeaf() || node.height < 2) {
                return node;
            }
            var left = node.left;
            var right = node.right;
            var a = node;
            var b = left;
            var c = right;
            var d = left.left;
            var e = left.right;
            var f = right.left;
            var g = right.right;
            var balance = c.height - b.height;
            // Rotate c node up
            if (balance > 1) {
                // Swap the right node with it's parent
                c.left = a;
                c.parent = a.parent;
                a.parent = c;
                // The original node's old parent should point to the right node
                // this is mega confusing
                if (c.parent) {
                    if (c.parent.left === a) {
                        c.parent.left = c;
                    }
                    else {
                        c.parent.right = c;
                    }
                }
                else {
                    this.root = c;
                }
                // Rotate
                if (f.height > g.height) {
                    c.right = f;
                    a.right = g;
                    g.parent = a;
                    a.bounds = b.bounds.combine(g.bounds);
                    c.bounds = a.bounds.combine(f.bounds);
                    a.height = 1 + Math.max(b.height, g.height);
                    c.height = 1 + Math.max(a.height, f.height);
                }
                else {
                    c.right = g;
                    a.right = f;
                    f.parent = a;
                    a.bounds = b.bounds.combine(f.bounds);
                    c.bounds = a.bounds.combine(g.bounds);
                    a.height = 1 + Math.max(b.height, f.height);
                    c.height = 1 + Math.max(a.height, g.height);
                }
                return c;
            }
            // Rotate left node up
            if (balance < -1) {
                // swap
                b.left = a;
                b.parent = a.parent;
                a.parent = b;
                // node's old parent should point to b
                if (b.parent) {
                    if (b.parent.left === a) {
                        b.parent.left = b;
                    }
                    else {
                        if (b.parent.right !== a) {
                            throw 'Error rotating Dynamic Tree';
                        }
                        b.parent.right = b;
                    }
                }
                else {
                    this.root = b;
                }
                // rotate
                if (d.height > e.height) {
                    b.right = d;
                    a.left = e;
                    e.parent = a;
                    a.bounds = c.bounds.combine(e.bounds);
                    b.bounds = a.bounds.combine(d.bounds);
                    a.height = 1 + Math.max(c.height, e.height);
                    b.height = 1 + Math.max(a.height, d.height);
                }
                else {
                    b.right = e;
                    a.left = d;
                    d.parent = a;
                    a.bounds = c.bounds.combine(d.bounds);
                    b.bounds = a.bounds.combine(e.bounds);
                    a.height = 1 + Math.max(c.height, d.height);
                    b.height = 1 + Math.max(a.height, e.height);
                }
                return b;
            }
            return node;
        };
        /**
         * Returns the internal height of the tree, shorter trees are better. Performance drops as the tree grows
         */
        DynamicTree.prototype.getHeight = function () {
            if (this.root === null) {
                return 0;
            }
            return this.root.height;
        };
        /**
         * Queries the Dynamic Axis Aligned Tree for bodies that could be colliding with the provided body.
         *
         * In the query callback, it will be passed a potential collider. Returning true from this callback indicates
         * that you are complete with your query and you do not want to continue. Returning false will continue searching
         * the tree until all possible colliders have been returned.
         */
        DynamicTree.prototype.query = function (body, callback) {
            var bounds = body.getBounds();
            var helper = function (currentNode) {
                if (currentNode && currentNode.bounds.collides(bounds)) {
                    if (currentNode.isLeaf() && currentNode.body !== body) {
                        if (callback.call(body, currentNode.body)) {
                            return true;
                        }
                    }
                    else {
                        return helper(currentNode.left) || helper(currentNode.right);
                    }
                }
                return false;
            };
            helper(this.root);
        };
        /**
         * Queries the Dynamic Axis Aligned Tree for bodies that could be intersecting. By default the raycast query uses an infinitely
         * long ray to test the tree specified by `max`.
         *
         * In the query callback, it will be passed a potential body that intersects with the racast. Returning true from this
         * callback indicates that your are complete with your query and do not want to continue. Return false will continue searching
         * the tree until all possible bodies that would intersect with the ray have been returned.
         */
        DynamicTree.prototype.rayCastQuery = function (ray, max, callback) {
            if (max === void 0) { max = Infinity; }
            var helper = function (currentNode) {
                if (currentNode && currentNode.bounds.rayCast(ray, max)) {
                    if (currentNode.isLeaf()) {
                        if (callback.call(ray, currentNode.body)) {
                            // ray hit a leaf! return the body
                            return true;
                        }
                    }
                    else {
                        // ray hit but not at a leaf, recurse deeper
                        return helper(currentNode.left) || helper(currentNode.right);
                    }
                }
                return false; // ray missed         
            };
            helper(this.root);
        };
        DynamicTree.prototype.getNodes = function () {
            var helper = function (currentNode) {
                if (currentNode) {
                    return [currentNode].concat(helper(currentNode.left), helper(currentNode.right));
                }
                else {
                    return [];
                }
            };
            return helper(this.root);
        };
        DynamicTree.prototype.debugDraw = function (ctx) {
            // draw all the nodes in the Dynamic Tree
            var helper = function (currentNode) {
                if (currentNode) {
                    if (currentNode.isLeaf()) {
                        ctx.lineWidth = 1;
                        ctx.strokeStyle = 'green';
                    }
                    else {
                        ctx.lineWidth = 1;
                        ctx.strokeStyle = 'white';
                    }
                    currentNode.bounds.debugDraw(ctx);
                    if (currentNode.left) {
                        helper(currentNode.left);
                    }
                    if (currentNode.right) {
                        helper(currentNode.right);
                    }
                }
            };
            helper(this.root);
        };
        return DynamicTree;
    }());
    exports.DynamicTree = DynamicTree;
});
define("Collision/ICollisionResolver", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Collision/DynamicTreeCollisionBroadphase", ["require", "exports", "Physics", "Collision/DynamicTree", "Collision/Pair", "Algebra", "Actor", "Util/Log", "Events"], function (require, exports, Physics_9, DynamicTree_1, Pair_2, Algebra_18, Actor_9, Log_9, Events_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DynamicTreeCollisionBroadphase = (function () {
        function DynamicTreeCollisionBroadphase() {
            this._dynamicCollisionTree = new DynamicTree_1.DynamicTree();
            this._collisionHash = {};
            this._collisionPairCache = [];
            this._lastFramePairs = [];
            this._lastFramePairsHash = {};
        }
        /**
         * Tracks a physics body for collisions
         */
        DynamicTreeCollisionBroadphase.prototype.track = function (target) {
            if (!target) {
                Log_9.Logger.getInstance().warn('Cannot track null physics body');
                return;
            }
            this._dynamicCollisionTree.trackBody(target);
        };
        /**
         * Untracks a physics body
         */
        DynamicTreeCollisionBroadphase.prototype.untrack = function (target) {
            if (!target) {
                Log_9.Logger.getInstance().warn('Cannot untrack a null physics body');
                return;
            }
            this._dynamicCollisionTree.untrackBody(target);
        };
        DynamicTreeCollisionBroadphase.prototype._canCollide = function (actorA, actorB) {
            // if the collision pair has been calculated already short circuit
            var hash = Pair_2.Pair.calculatePairHash(actorA.body, actorB.body);
            if (this._collisionHash[hash]) {
                return false; // pair exists easy exit return false
            }
            // if both are fixed short circuit
            if (actorA.collisionType === Actor_9.CollisionType.Fixed && actorB.collisionType === Actor_9.CollisionType.Fixed) {
                return false;
            }
            // if the other is prevent collision or is dead short circuit
            if (actorB.collisionType === Actor_9.CollisionType.PreventCollision || actorB.isKilled()) {
                return false;
            }
            // they can collide
            return true;
        };
        /**
         * Detects potential collision pairs in a broadphase approach with the dynamic aabb tree strategy
         */
        DynamicTreeCollisionBroadphase.prototype.broadphase = function (targets, delta, stats) {
            var _this = this;
            var seconds = delta / 1000;
            // TODO optimization use only the actors that are moving to start 
            // Retrieve the list of potential colliders, exclude killed, prevented, and self
            var potentialColliders = targets.filter(function (other) {
                return !other.isKilled() && other.collisionType !== Actor_9.CollisionType.PreventCollision;
            });
            // clear old list of collision pairs
            this._collisionPairCache = [];
            this._collisionHash = {};
            // check for normal collision pairs
            var actor;
            for (var j = 0, l = potentialColliders.length; j < l; j++) {
                actor = potentialColliders[j];
                // Query the collision tree for potential colliders
                this._dynamicCollisionTree.query(actor.body, function (other) {
                    if (_this._canCollide(actor, other.actor)) {
                        var pair = new Pair_2.Pair(actor.body, other);
                        _this._collisionHash[pair.id] = true;
                        _this._collisionPairCache.push(pair);
                    }
                    // Always return false, to query whole tree. Returning true in the query method stops searching
                    return false;
                });
            }
            if (stats) {
                stats.physics.pairs = this._collisionPairCache.length;
            }
            // Check dynamic tree for fast moving objects
            // Fast moving objects are those moving at least there smallest bound per frame
            if (Physics_9.Physics.checkForFastBodies) {
                for (var _i = 0, potentialColliders_1 = potentialColliders; _i < potentialColliders_1.length; _i++) {
                    var actor = potentialColliders_1[_i];
                    // Skip non-active objects. Does not make sense on other collison types
                    if (actor.collisionType !== Actor_9.CollisionType.Active) {
                        continue;
                    }
                    ;
                    // Maximum travel distance next frame
                    var updateDistance = (actor.vel.magnitude() * seconds) +
                        (actor.acc.magnitude() * .5 * seconds * seconds); // acc term
                    // Find the minimum dimension
                    var minDimension = Math.min(actor.body.getBounds().getHeight(), actor.body.getBounds().getWidth());
                    if (Physics_9.Physics.disableMinimumSpeedForFastBody || updateDistance > (minDimension / 2)) {
                        if (stats) {
                            stats.physics.fastBodies++;
                        }
                        // start with the oldPos because the integration for actors has already happened
                        // objects resting on a surface may be slightly penatrating in the current position
                        var updateVec = actor.pos.sub(actor.oldPos);
                        var centerPoint = actor.body.collisionArea.getCenter();
                        var furthestPoint = actor.body.collisionArea.getFurthestPoint(actor.vel);
                        var origin = furthestPoint.sub(updateVec);
                        var ray = new Algebra_18.Ray(origin, actor.vel);
                        // back the ray up by -2x surfaceEpsilon to account for fast moving objects starting on the surface 
                        ray.pos = ray.pos.add(ray.dir.scale(-2 * Physics_9.Physics.surfaceEpsilon));
                        var minBody;
                        var minTranslate = new Algebra_18.Vector(Infinity, Infinity);
                        this._dynamicCollisionTree.rayCastQuery(ray, updateDistance + Physics_9.Physics.surfaceEpsilon * 2, function (other) {
                            if (actor.body !== other && other.collisionArea) {
                                var hitPoint = other.collisionArea.rayCast(ray, updateDistance + Physics_9.Physics.surfaceEpsilon * 10);
                                if (hitPoint) {
                                    var translate = hitPoint.sub(origin);
                                    if (translate.magnitude() < minTranslate.magnitude()) {
                                        minTranslate = translate;
                                        minBody = other;
                                    }
                                }
                            }
                            return false;
                        });
                        if (minBody && Algebra_18.Vector.isValid(minTranslate)) {
                            var pair = new Pair_2.Pair(actor.body, minBody);
                            if (!this._collisionHash[pair.id]) {
                                this._collisionHash[pair.id] = true;
                                this._collisionPairCache.push(pair);
                            }
                            // move the fast moving object to the other body
                            // need to push into the surface by ex.Physics.surfaceEpsilon
                            var shift = centerPoint.sub(furthestPoint);
                            actor.pos = origin.add(shift).add(minTranslate).add(ray.dir.scale(2 * Physics_9.Physics.surfaceEpsilon));
                            actor.body.collisionArea.recalc();
                            if (stats) {
                                stats.physics.fastBodyCollisions++;
                            }
                        }
                    }
                }
            }
            // return cache
            return this._collisionPairCache;
        };
        /**
         * Applies narrow phase on collision pairs to find actual area intersections
         * Adds actual colliding pairs to stats' Frame data
         */
        DynamicTreeCollisionBroadphase.prototype.narrowphase = function (pairs, stats) {
            for (var i = 0; i < pairs.length; i++) {
                pairs[i].collide();
                if (stats && pairs[i].collision) {
                    stats.physics.collisions++;
                    stats.physics.collidersHash[pairs[i].id] = pairs[i];
                }
            }
            return pairs.filter(function (p) { return p.collision; });
        };
        /**
         * Perform collision resolution given a strategy (rigid body or box) and move objects out of intersect.
         */
        DynamicTreeCollisionBroadphase.prototype.resolve = function (pairs, delta, strategy) {
            for (var _i = 0, pairs_1 = pairs; _i < pairs_1.length; _i++) {
                var pair = pairs_1[_i];
                pair.resolve(strategy);
                if (pair.collision) {
                    pair.bodyA.applyMtv();
                    pair.bodyB.applyMtv();
                    // todo still don't like this, this is a small integration step to resolve narrowphase collisions
                    pair.bodyA.actor.integrate(delta * Physics_9.Physics.collisionShift);
                    pair.bodyB.actor.integrate(delta * Physics_9.Physics.collisionShift);
                }
            }
            return pairs.filter(function (p) { return p.canCollide; });
        };
        DynamicTreeCollisionBroadphase.prototype.runCollisionStartEnd = function (pairs) {
            var currentFrameHash = {};
            for (var _i = 0, pairs_2 = pairs; _i < pairs_2.length; _i++) {
                var p = pairs_2[_i];
                // load currentFrameHash
                currentFrameHash[p.id] = p;
                // find all new collisions
                if (!this._lastFramePairsHash[p.id]) {
                    var actor1 = p.bodyA.actor;
                    var actor2 = p.bodyB.actor;
                    actor1.emit('collisionstart', new Events_6.CollisionStartEvent(actor1, actor2, p));
                    actor2.emit('collisionstart', new Events_6.CollisionStartEvent(actor2, actor1, p));
                }
            }
            // find all old collisions
            for (var _a = 0, _b = this._lastFramePairs; _a < _b.length; _a++) {
                var p = _b[_a];
                if (!currentFrameHash[p.id]) {
                    var actor1 = p.bodyA.actor;
                    var actor2 = p.bodyB.actor;
                    actor1.emit('collisionend', new Events_6.CollisionEndEvent(actor1, actor2));
                    actor2.emit('collisionend', new Events_6.CollisionEndEvent(actor2, actor1));
                }
            }
            // reset the last frame cache
            this._lastFramePairs = pairs;
            this._lastFramePairsHash = currentFrameHash;
        };
        /**
         * Update the dynamic tree positions
         */
        DynamicTreeCollisionBroadphase.prototype.update = function (targets) {
            var updated = 0, i = 0, len = targets.length;
            for (i; i < len; i++) {
                if (this._dynamicCollisionTree.updateBody(targets[i].body)) {
                    updated++;
                }
            }
            return updated;
        };
        /* istanbul ignore next */
        DynamicTreeCollisionBroadphase.prototype.debugDraw = function (ctx) {
            if (Physics_9.Physics.broadphaseDebug) {
                this._dynamicCollisionTree.debugDraw(ctx);
            }
            if (Physics_9.Physics.showContacts || Physics_9.Physics.showCollisionNormals) {
                for (var _i = 0, _a = this._collisionPairCache; _i < _a.length; _i++) {
                    var pair = _a[_i];
                    pair.debugDraw(ctx);
                }
            }
        };
        return DynamicTreeCollisionBroadphase;
    }());
    exports.DynamicTreeCollisionBroadphase = DynamicTreeCollisionBroadphase;
});
define("Collision/IPhysics", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Collision/NaiveCollisionBroadphase", ["require", "exports", "Physics", "Collision/CollisionContact", "Collision/Pair", "Actor", "Events"], function (require, exports, Physics_10, CollisionContact_2, Pair_3, Actor_10, Events_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var NaiveCollisionBroadphase = (function () {
        function NaiveCollisionBroadphase() {
            this._lastFramePairs = [];
            this._lastFramePairsHash = {};
        }
        NaiveCollisionBroadphase.prototype.track = function () {
            // pass
        };
        NaiveCollisionBroadphase.prototype.untrack = function () {
            // pass
        };
        /**
         * Detects potential collision pairs in a broadphase approach with the dynamic aabb tree strategy
         */
        NaiveCollisionBroadphase.prototype.broadphase = function (targets) {
            // Retrieve the list of potential colliders, exclude killed, prevented, and self
            var potentialColliders = targets.filter(function (other) {
                return !other.isKilled() && other.collisionType !== Actor_10.CollisionType.PreventCollision;
            });
            var actor1;
            var actor2;
            var collisionPairs = [];
            for (var j = 0, l = potentialColliders.length; j < l; j++) {
                actor1 = potentialColliders[j];
                for (var i = j + 1; i < l; i++) {
                    actor2 = potentialColliders[i];
                    var minimumTranslationVector;
                    if (minimumTranslationVector = actor1.collides(actor2)) {
                        var pair = new Pair_3.Pair(actor1.body, actor2.body);
                        pair.collision = new CollisionContact_2.CollisionContact(actor1.collisionArea, actor2.collisionArea, minimumTranslationVector, actor1.pos, minimumTranslationVector);
                        if (!collisionPairs.some(function (cp) {
                            return cp.id === pair.id;
                        })) {
                            collisionPairs.push(pair);
                        }
                    }
                }
            }
            return collisionPairs;
        };
        /**
         * Identify actual collisions from those pairs, and calculate collision impulse
         */
        NaiveCollisionBroadphase.prototype.narrowphase = function (pairs) {
            return pairs;
        };
        NaiveCollisionBroadphase.prototype.runCollisionStartEnd = function (pairs) {
            var currentFrameHash = {};
            for (var _i = 0, pairs_3 = pairs; _i < pairs_3.length; _i++) {
                var p = pairs_3[_i];
                // load currentFrameHash
                currentFrameHash[p.id] = p;
                // find all new collisions
                if (!this._lastFramePairsHash[p.id]) {
                    var actor1 = p.bodyA.actor;
                    var actor2 = p.bodyB.actor;
                    actor1.emit('collisionstart', new Events_7.CollisionStartEvent(actor1, actor2, p));
                    actor2.emit('collisionstart', new Events_7.CollisionStartEvent(actor2, actor1, p));
                }
            }
            // find all old collisions
            for (var _a = 0, _b = this._lastFramePairs; _a < _b.length; _a++) {
                var p = _b[_a];
                if (!currentFrameHash[p.id]) {
                    var actor1 = p.bodyA.actor;
                    var actor2 = p.bodyB.actor;
                    actor1.emit('collisionend', new Events_7.CollisionEndEvent(actor1, actor2));
                    actor2.emit('collisionend', new Events_7.CollisionEndEvent(actor2, actor1));
                }
            }
            // reset the last frame cache
            this._lastFramePairs = pairs;
            this._lastFramePairsHash = currentFrameHash;
        };
        /**
         * Resolve the position and velocity of the physics bodies
         */
        NaiveCollisionBroadphase.prototype.resolve = function (pairs) {
            for (var _i = 0, pairs_4 = pairs; _i < pairs_4.length; _i++) {
                var pair = pairs_4[_i];
                pair.resolve(Physics_10.Physics.collisionResolutionStrategy);
            }
            return pairs.filter(function (p) { return p.canCollide; });
        };
        NaiveCollisionBroadphase.prototype.update = function () {
            return 0;
        };
        NaiveCollisionBroadphase.prototype.debugDraw = function () {
            return;
        };
        return NaiveCollisionBroadphase;
    }());
    exports.NaiveCollisionBroadphase = NaiveCollisionBroadphase;
});
define("Collision/Index", ["require", "exports", "Collision/Body", "Collision/BoundingBox", "Collision/CircleArea", "Collision/CollisionContact", "Collision/CollisionJumpTable", "Collision/DynamicTree", "Collision/DynamicTreeCollisionBroadphase", "Collision/EdgeArea", "Collision/NaiveCollisionBroadphase", "Collision/Pair", "Collision/PolygonArea", "Collision/Side"], function (require, exports, Body_1, BoundingBox_6, CircleArea_4, CollisionContact_3, CollisionJumpTable_4, DynamicTree_2, DynamicTreeCollisionBroadphase_1, EdgeArea_4, NaiveCollisionBroadphase_1, Pair_4, PolygonArea_6, Side_3) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(Body_1);
    __export(BoundingBox_6);
    __export(CircleArea_4);
    __export(CollisionContact_3);
    __export(CollisionJumpTable_4);
    __export(DynamicTree_2);
    __export(DynamicTreeCollisionBroadphase_1);
    __export(EdgeArea_4);
    __export(NaiveCollisionBroadphase_1);
    __export(Pair_4);
    __export(PolygonArea_6);
    __export(Side_3);
});
define("Drawing/Polygon", ["require", "exports", "Algebra"], function (require, exports, Algebra_19) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Creates a closed polygon drawing given a list of [[Vector]]s.
     *
     * @warning Use sparingly as Polygons are performance intensive
     */
    var Polygon = (function () {
        /**
         * @param points  The vectors to use to build the polygon in order
         */
        function Polygon(points) {
            /**
             * The width of the lines of the polygon
             */
            this.lineWidth = 5;
            /**
             * Indicates whether the polygon is filled or not.
             */
            this.filled = false;
            this._points = [];
            this.anchor = new Algebra_19.Vector(0, 0);
            this.rotation = 0;
            this.scale = new Algebra_19.Vector(1, 1);
            this._points = points;
            var minX = this._points.reduce(function (prev, curr) {
                return Math.min(prev, curr.x);
            }, 0);
            var maxX = this._points.reduce(function (prev, curr) {
                return Math.max(prev, curr.x);
            }, 0);
            this.width = maxX - minX;
            var minY = this._points.reduce(function (prev, curr) {
                return Math.min(prev, curr.y);
            }, 0);
            var maxY = this._points.reduce(function (prev, curr) {
                return Math.max(prev, curr.y);
            }, 0);
            this.height = maxY - minY;
            this.naturalHeight = this.height;
            this.naturalWidth = this.width;
        }
        /**
         * @notimplemented Effects are not supported on `Polygon`
         */
        Polygon.prototype.addEffect = function () {
            // not supported on polygons
        };
        /**
         * @notimplemented Effects are not supported on `Polygon`
         */
        Polygon.prototype.removeEffect = function () {
            // not supported on polygons
        };
        /**
         * @notimplemented Effects are not supported on `Polygon`
         */
        Polygon.prototype.clearEffects = function () {
            // not supported on polygons
        };
        Polygon.prototype.reset = function () {
            //pass
        };
        Polygon.prototype.draw = function (ctx, x, y) {
            ctx.save();
            ctx.translate(x + this.anchor.x, y + this.anchor.y);
            ctx.scale(this.scale.x, this.scale.y);
            ctx.rotate(this.rotation);
            ctx.beginPath();
            ctx.lineWidth = this.lineWidth;
            // Iterate through the supplied points and construct a 'polygon'
            var firstPoint = this._points[0];
            ctx.moveTo(firstPoint.x, firstPoint.y);
            var i = 0, len = this._points.length;
            for (i; i < len; i++) {
                ctx.lineTo(this._points[i].x, this._points[i].y);
            }
            ctx.lineTo(firstPoint.x, firstPoint.y);
            ctx.closePath();
            if (this.filled) {
                ctx.fillStyle = this.fillColor.toString();
                ctx.fill();
            }
            ctx.strokeStyle = this.lineColor.toString();
            if (this.flipHorizontal) {
                ctx.translate(this.width, 0);
                ctx.scale(-1, 1);
            }
            if (this.flipVertical) {
                ctx.translate(0, this.height);
                ctx.scale(1, -1);
            }
            ctx.stroke();
            ctx.restore();
        };
        return Polygon;
    }());
    exports.Polygon = Polygon;
});
define("Drawing/Index", ["require", "exports", "Drawing/Animation", "Drawing/Color", "Drawing/Polygon", "Drawing/Sprite", "Drawing/SpriteSheet", "Drawing/SpriteEffects"], function (require, exports, Animation_2, Color_17, Polygon_1, Sprite_3, SpriteSheet_1, effects) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Animation = Animation_2.Animation;
    __export(Color_17);
    __export(Polygon_1);
    exports.Sprite = Sprite_3.Sprite;
    exports.SpriteSheet = SpriteSheet_1.SpriteSheet;
    exports.SpriteFont = SpriteSheet_1.SpriteFont;
    exports.Effects = effects;
});
define("Interfaces/Index", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("Math/PerlinNoise", ["require", "exports", "Math/Random", "Drawing/Color", "Util/Util"], function (require, exports, Random_3, Color_18, Util) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _lerp(time, a, b) {
        return a + time * (b - a);
    }
    function _fade(t) {
        return t * t * t * (t * (t * 6 - 15) + 10);
    }
    /**
     * Generates perlin noise based on the 2002 Siggraph paper http://mrl.nyu.edu/~perlin/noise/
     * Also https://flafla2.github.io/2014/08/09/perlinnoise.html
     */
    var PerlinGenerator = (function () {
        function PerlinGenerator(options) {
            this._perm = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225,
                140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26,
                197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136,
                171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60,
                211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80,
                73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198,
                173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206,
                59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70,
                221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178,
                185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81,
                51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115,
                121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195,
                78, 66, 215, 61, 156, 180];
            this._p = new Uint8Array(512);
            this._defaultPerlinOptions = {
                octaves: 1,
                frequency: 1,
                amplitude: 1,
                persistance: .5
            };
            options = Util.extend({}, this._defaultPerlinOptions, options);
            this.persistance = options.persistance;
            this.amplitude = options.amplitude;
            this.frequency = options.frequency;
            this.octaves = options.octaves;
            if (options.seed) {
                this._random = new Random_3.Random(options.seed);
            }
            else {
                this._random = new Random_3.Random();
            }
            this._perm = this._random.shuffle(this._perm);
            for (var i = 0; i < 512; i++) {
                this._p[i] = this._perm[i % 256] & 0xFF;
            }
        }
        PerlinGenerator.prototype.noise = function () {
            var amp = this.amplitude;
            var freq = this.frequency;
            var total = 0;
            var maxValue = 0;
            for (var i = 0; i < this.octaves; i++) {
                switch (arguments.length) {
                    case 1:
                        total += this._noise1d(arguments[0] * freq) * amp;
                        break;
                    case 2:
                        total += this._noise2d(arguments[0] * freq, arguments[1] * freq) * amp;
                        break;
                    case 3:
                        total += this._noise3d(arguments[0] * freq, arguments[1] * freq, arguments[2] * freq) * amp;
                        break;
                    /* istanbul ignore next */
                    default: throw new Error('Invalid arguments for perlin noise');
                }
                maxValue += amp;
                amp *= this.persistance;
                freq *= 2;
            }
            return total / maxValue;
        };
        /**
         * Generates a list starting at 0 and ending at 1 of contious perlin noise, by default the step is 1/length;
         *
         */
        PerlinGenerator.prototype.sequence = function (length, step) {
            if (!step) {
                step = 1 / length;
            }
            var array = new Array(length);
            for (var i = 0; i < length; i++) {
                array[i] = this.noise(i * step);
            }
            return array;
        };
        /**
         * Generates a 2D grid of perlin noise given a step value packed into a 1D array i = (x + y*width),
         * by default the step will 1/(min(dimension))
         */
        PerlinGenerator.prototype.grid = function (width, height, step) {
            if (!step) {
                step = 1 / (Math.min(width, height));
            }
            var array = new Array(width * height);
            for (var y = 0; y < height; y++) {
                for (var x = 0; x < width; x++) {
                    array[x + y * width] = this.noise(x * step, y * step);
                }
            }
            return array;
        };
        PerlinGenerator.prototype._gradient3d = function (hash, x, y, z) {
            var h = hash & 0xF;
            var u = h < 8 ? x : y;
            var v = h < 4 ? y : ((h === 12 || h === 14) ? x : z);
            return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
        };
        PerlinGenerator.prototype._gradient2d = function (hash, x, y) {
            var value = (hash & 1) === 0 ? x : y;
            return (hash & 2) === 0 ? -value : value;
        };
        PerlinGenerator.prototype._gradient1d = function (hash, x) {
            return (hash & 1) === 0 ? -x : x;
        };
        PerlinGenerator.prototype._noise1d = function (x) {
            var intX = Math.floor(x) & 0xFF; // force 0-255 integers to lookup in permutation
            x -= Math.floor(x);
            var fadeX = _fade(x);
            return (_lerp(fadeX, this._gradient1d(this._p[intX], x), this._gradient1d(this._p[intX + 1], x - 1)) + 1) / 2;
        };
        PerlinGenerator.prototype._noise2d = function (x, y) {
            var intX = Math.floor(x) & 0xFF;
            var intY = Math.floor(y) & 0xFF;
            x -= Math.floor(x);
            y -= Math.floor(y);
            var fadeX = _fade(x);
            var fadeY = _fade(y);
            var a = this._p[intX] + intY;
            var b = this._p[intX + 1] + intY;
            return (_lerp(fadeY, _lerp(fadeX, this._gradient2d(this._p[a], x, y), this._gradient2d(this._p[b], x - 1, y)), _lerp(fadeX, this._gradient2d(this._p[a + 1], x, y - 1), this._gradient2d(this._p[b + 1], x - 1, y - 1))) + 1) / 2;
        };
        PerlinGenerator.prototype._noise3d = function (x, y, z) {
            var intX = Math.floor(x) & 0xFF;
            var intY = Math.floor(y) & 0xFF;
            var intZ = Math.floor(z) & 0xFF;
            x -= Math.floor(x);
            y -= Math.floor(y);
            z -= Math.floor(z);
            var fadeX = _fade(x);
            var fadeY = _fade(y);
            var fadeZ = _fade(z);
            var a = this._p[intX] + intY;
            var b = this._p[intX + 1] + intY;
            var aa = this._p[a] + intZ;
            var ba = this._p[b] + intZ;
            var ab = this._p[a + 1] + intZ;
            var bb = this._p[b + 1] + intZ;
            return (_lerp(fadeZ, _lerp(fadeY, _lerp(fadeX, this._gradient3d(this._p[aa], x, y, z), this._gradient3d(this._p[ba], x - 1, y, z)), _lerp(fadeX, this._gradient3d(this._p[ab], x, y - 1, z), this._gradient3d(this._p[bb], x - 1, y - 1, z))), _lerp(fadeY, _lerp(fadeX, this._gradient3d(this._p[aa + 1], x, y, z - 1), this._gradient3d(this._p[ba + 1], x - 1, y, z - 1)), _lerp(fadeX, this._gradient3d(this._p[ab + 1], x, y - 1, z - 1), this._gradient3d(this._p[bb + 1], x - 1, y - 1, z - 1)))) + 1) / 2;
        };
        return PerlinGenerator;
    }());
    exports.PerlinGenerator = PerlinGenerator;
    /**
     * A helper to draw 2D perlin maps given a perlin generator and a function
     */
    var PerlinDrawer2D = (function () {
        /**
         * @param generator - An existing perlin generator
         * @param colorFcn - A color function that takes a value between [0, 255] derived from the perlin generator, and returns a color
         */
        function PerlinDrawer2D(generator, colorFcn) {
            this.generator = generator;
            this.colorFcn = colorFcn;
            if (!colorFcn) {
                this.colorFcn = function (val) { return val < 125 ? Color_18.Color.Black : Color_18.Color.White; };
            }
        }
        /**
         * Returns an image of 2D perlin noise
         */
        PerlinDrawer2D.prototype.image = function (width, height) {
            var image = document.createElement('img');
            var canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            var ctx = canvas.getContext('2d');
            this.draw(ctx, 0, 0, width, height);
            image.src = canvas.toDataURL();
            return image;
        };
        /**
         * This draws a 2D perlin grid on a canvas context, not recommended to be called every frame due to performance
         */
        PerlinDrawer2D.prototype.draw = function (ctx, x, y, width, height) {
            var grid = this.generator.grid(width, height);
            var imageData = ctx.getImageData(x, y, width, height);
            for (var j = 0; j < height; j++) {
                for (var i = 0; i < width; i++) {
                    var val = grid[i + width * j];
                    var c = Math.floor(val * 255) & 0xff;
                    var pixel = (i + j * imageData.width) * 4;
                    var color = this.colorFcn(c);
                    imageData.data[pixel] = color.r;
                    imageData.data[pixel + 1] = color.g;
                    imageData.data[pixel + 2] = color.b;
                    imageData.data[pixel + 3] = Math.floor(color.a * 255);
                }
            }
            ctx.putImageData(imageData, x, y);
        };
        return PerlinDrawer2D;
    }());
    exports.PerlinDrawer2D = PerlinDrawer2D;
});
define("Math/Index", ["require", "exports", "Math/PerlinNoise", "Math/Random"], function (require, exports, PerlinNoise_1, Random_4) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(PerlinNoise_1);
    __export(Random_4);
});
define("PostProcessing/IPostProcessor", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("PostProcessing/ColorBlindCorrector", ["require", "exports", "Util/Log"], function (require, exports, Log_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ColorBlindness;
    (function (ColorBlindness) {
        ColorBlindness[ColorBlindness["Protanope"] = 0] = "Protanope";
        ColorBlindness[ColorBlindness["Deuteranope"] = 1] = "Deuteranope";
        ColorBlindness[ColorBlindness["Tritanope"] = 2] = "Tritanope";
    })(ColorBlindness = exports.ColorBlindness || (exports.ColorBlindness = {}));
    /**
     * This post processor can correct colors and simulate color blindness.
     * It is possible to use this on every game, but the game's performance
     * will suffer measurably. It's better to use it as a helpful tool while developing your game.
     * Remember, the best practice is to design with color blindness in mind.
     *
     * [[include:ColorBlind.md]]
     */
    var ColorBlindCorrector = (function () {
        function ColorBlindCorrector(engine, simulate, colorMode) {
            if (simulate === void 0) { simulate = false; }
            if (colorMode === void 0) { colorMode = ColorBlindness.Protanope; }
            this.engine = engine;
            this.simulate = simulate;
            this.colorMode = colorMode;
            this._vertexShader = 'attribute vec2 a_position;' +
                'attribute vec2 a_texCoord;' +
                'uniform vec2 u_resolution;' +
                'varying vec2 v_texCoord;' +
                'void main() {' +
                // convert the rectangle from pixels to 0.0 to 1.0
                'vec2 zeroToOne = a_position / u_resolution;' +
                // convert from 0->1 to 0->2
                'vec2 zeroToTwo = zeroToOne * 2.0;' +
                // convert from 0->2 to -1->+1 (clipspace)
                'vec2 clipSpace = zeroToTwo - 1.0;' +
                'gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);' +
                // pass the texCoord to the fragment shader
                // The GPU will interpolate this value between points.
                'v_texCoord = a_texCoord;' +
                '}';
            this._fragmentShader = 'precision mediump float;' +
                // our texture
                'uniform sampler2D u_image;' +
                // the texCoords passed in from the vertex shader.
                'varying vec2 v_texCoord;' +
                // Color blind conversions
                /*'mat3 m[9] =' +
                '{' +
                   'mat3(1.0, 0.0, 0.0,  0.0, 1.0, 0.0,  0.0, 0.0, 1.0  ),' + // normal
                   'mat3(0.567, 0.433, 0.0,  0.558, 0.442, 0.0,  0.0, 0.242, 0.758),' + // protanopia
                   'mat3(0.817, 0.183, 0.0,  0.333, 0.667, 0.0,  0.0, 0.125,0.875),' + // protanomaly
                   'mat3(0.625, 0.375, 0.0,  0.7, 0.3, 0.0,  0.0, 0.3,0.7  ),' + // deuteranopia
                   'mat3(0.8, 0.2, 0.0,  0.258, 0.742, 0.0,  0.0, 0.142,0.858),' + // deuteranomaly
                   'mat3(0.95, 0.05, 0.0,  0.0, 0.433, 0.567,  0.0, 0.475,0.525),' + // tritanopia
                   'mat3(0.967, 0.033, 0.0,  0.0, 0.733, 0.267,  0.0, 0.183,0.817),' + // tritanomaly
                   'mat3(0.299, 0.587, 0.114,  0.299, 0.587, 0.114,  0.299, 0.587,0.114),' + // achromatopsia
                   'mat3(0.618, 0.320, 0.062,  0.163, 0.775, 0.062,  0.163, 0.320,0.516)' +  // achromatomaly
                '};' +*/
                'void main() {' +
                'vec4 o =  texture2D(u_image, v_texCoord);' +
                // RGB to LMS matrix conversion
                'float L = (17.8824 * o.r) + (43.5161 * o.g) + (4.11935 * o.b);' +
                'float M = (3.45565 * o.r) + (27.1554 * o.g) + (3.86714 * o.b);' +
                'float S = (0.0299566 * o.r) + (0.184309 * o.g) + (1.46709 * o.b);' +
                // Simulate color blindness
                '//MODE CODE//' +
                /* Deuteranope for testing
                'float l = 1.0 * L + 0.0 * M + 0.0 * S;' +
                      'float m = 0.494207 * L + 0.0 * M + 1.24827 * S;' +
                      'float s = 0.0 * L + 0.0 * M + 1.0 * S;' +*/
                // LMS to RGB matrix conversion
                'vec4 error;' +
                'error.r = (0.0809444479 * l) + (-0.130504409 * m) + (0.116721066 * s);' +
                'error.g = (-0.0102485335 * l) + (0.0540193266 * m) + (-0.113614708 * s);' +
                'error.b = (-0.000365296938 * l) + (-0.00412161469 * m) + (0.693511405 * s);' +
                'error.a = 1.0;' +
                'vec4 diff = o - error;' +
                'vec4 correction;' +
                'correction.r = 0.0;' +
                'correction.g =  (diff.r * 0.7) + (diff.g * 1.0);' +
                'correction.b =  (diff.r * 0.7) + (diff.b * 1.0);' +
                'correction = o + correction;' +
                'correction.a = o.a;' +
                '//SIMULATE//' +
                '}';
            this._internalCanvas = document.createElement('canvas');
            this._internalCanvas.width = engine.drawWidth;
            this._internalCanvas.height = engine.drawHeight;
            this._gl = this._internalCanvas.getContext('webgl', { preserveDrawingBuffer: true });
            this._program = this._gl.createProgram();
            var fragmentShader = this._getShader('Fragment', this._getFragmentShaderByMode(colorMode));
            var vertextShader = this._getShader('Vertex', this._vertexShader);
            this._gl.attachShader(this._program, vertextShader);
            this._gl.attachShader(this._program, fragmentShader);
            this._gl.linkProgram(this._program);
            if (!this._gl.getProgramParameter(this._program, this._gl.LINK_STATUS)) {
                Log_10.Logger.getInstance().error('Unable to link shader program!');
            }
            this._gl.useProgram(this._program);
        }
        ColorBlindCorrector.prototype._getFragmentShaderByMode = function (colorMode) {
            var code = '';
            if (colorMode === ColorBlindness.Protanope) {
                code =
                    'float l = 0.0 * L + 2.02344 * M + -2.52581 * S;' +
                        'float m = 0.0 * L + 1.0 * M + 0.0 * S;' +
                        'float s = 0.0 * L + 0.0 * M + 1.0 * S;';
            }
            else if (colorMode === ColorBlindness.Deuteranope) {
                code =
                    'float l = 1.0 * L + 0.0 * M + 0.0 * S;' +
                        'float m = 0.494207 * L + 0.0 * M + 1.24827 * S;' +
                        'float s = 0.0 * L + 0.0 * M + 1.0 * S;';
            }
            else if (colorMode === ColorBlindness.Tritanope) {
                code =
                    'float l = 1.0 * L + 0.0 * M + 0.0 * S;' +
                        'float m = 0.0 * L + 1.0 * M + 0.0 * S;' +
                        'float s = -0.395913 * L + 0.801109 * M + 0.0 * S;';
            }
            if (this.simulate) {
                this._fragmentShader = this._fragmentShader.replace('//SIMULATE//', 'gl_FragColor = error.rgba;');
            }
            else {
                this._fragmentShader = this._fragmentShader.replace('//SIMULATE//', 'gl_FragColor = correction.rgba;');
            }
            return this._fragmentShader.replace('//MODE CODE//', code);
        };
        ColorBlindCorrector.prototype._setRectangle = function (x, y, width, height) {
            var x1 = x;
            var x2 = x + width;
            var y1 = y;
            var y2 = y + height;
            this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array([
                x1, y1,
                x2, y1,
                x1, y2,
                x1, y2,
                x2, y1,
                x2, y2
            ]), this._gl.STATIC_DRAW);
        };
        ColorBlindCorrector.prototype._getShader = function (type, program) {
            var shader;
            if (type === 'Fragment') {
                shader = this._gl.createShader(this._gl.FRAGMENT_SHADER);
            }
            else if (type === 'Vertex') {
                shader = this._gl.createShader(this._gl.VERTEX_SHADER);
            }
            else {
                Log_10.Logger.getInstance().error('Error unknown shader type', type);
            }
            this._gl.shaderSource(shader, program);
            this._gl.compileShader(shader);
            if (!this._gl.getShaderParameter(shader, this._gl.COMPILE_STATUS)) {
                Log_10.Logger.getInstance().error('Unable to compile shader!', this._gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        };
        ColorBlindCorrector.prototype.process = function (image, out) {
            // look up where the vertex data needs to go.
            var positionLocation = this._gl.getAttribLocation(this._program, 'a_position');
            var texCoordLocation = this._gl.getAttribLocation(this._program, 'a_texCoord');
            var texCoordBuffer = this._gl.createBuffer();
            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, texCoordBuffer);
            this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array([
                0.0, 0.0,
                1.0, 0.0,
                0.0, 1.0,
                0.0, 1.0,
                1.0, 0.0,
                1.0, 1.0
            ]), this._gl.STATIC_DRAW);
            this._gl.enableVertexAttribArray(texCoordLocation);
            this._gl.vertexAttribPointer(texCoordLocation, 2, this._gl.FLOAT, false, 0, 0);
            // Create a texture.
            var texture = this._gl.createTexture();
            this._gl.bindTexture(this._gl.TEXTURE_2D, texture);
            // Set the parameters so we can render any size image.
            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE);
            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);
            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.NEAREST);
            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.NEAREST);
            // Flip the texture when unpacking into the gl context, gl reads textures in the opposite order as everything else :/
            this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, 1);
            // Upload the image into the texture.
            this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, image);
            // lookup uniforms
            var resolutionLocation = this._gl.getUniformLocation(this._program, 'u_resolution');
            // set the resolution
            this._gl.uniform2f(resolutionLocation, this._internalCanvas.width, this._internalCanvas.height);
            // Create a buffer for the position of the rectangle corners.
            var positionBuffer = this._gl.createBuffer();
            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, positionBuffer);
            this._gl.enableVertexAttribArray(positionLocation);
            this._gl.vertexAttribPointer(positionLocation, 2, this._gl.FLOAT, false, 0, 0);
            // Set a rectangle the same size as the image.
            this._setRectangle(0, 0, image.width, image.height);
            // Draw the rectangle.
            this._gl.drawArrays(this._gl.TRIANGLES, 0, 6);
            // Grab tranformed image from internal canvas
            var pixelData = new Uint8Array(image.width * image.height * 4);
            this._gl.readPixels(0, 0, image.width, image.height, this._gl.RGBA, this._gl.UNSIGNED_BYTE, pixelData);
            image.data.set(pixelData);
            out.putImageData(image, 0, 0);
        };
        return ColorBlindCorrector;
    }());
    exports.ColorBlindCorrector = ColorBlindCorrector;
});
define("PostProcessing/Index", ["require", "exports", "PostProcessing/ColorBlindCorrector"], function (require, exports, ColorBlindCorrector_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(ColorBlindCorrector_1);
});
define("Resources/Index", ["require", "exports", "Resources/Resource", "Resources/Sound", "Resources/Texture"], function (require, exports, Resource_2, Sound_2, Texture_3) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(Resource_2);
    __export(Sound_2);
    __export(Texture_3);
});
define("Input/Gamepad", ["require", "exports", "Class", "Events"], function (require, exports, Class_5, Events_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Excalibur leverages the HTML5 Gamepad API [where it is supported](http://caniuse.com/#feat=gamepad)
     * to provide controller support for your games.
     *
     * [[include:Gamepads.md]]
     */
    var Gamepads = (function (_super) {
        __extends(Gamepads, _super);
        function Gamepads() {
            var _this = _super.call(this) || this;
            /**
             * Whether or not to poll for Gamepad input (default: `false`)
             */
            _this.enabled = false;
            /**
             * Whether or not Gamepad API is supported
             */
            _this.supported = !!navigator.getGamepads;
            _this._gamePadTimeStamps = [0, 0, 0, 0];
            _this._oldPads = [];
            _this._pads = [];
            _this._initSuccess = false;
            _this._navigator = navigator;
            _this._minimumConfiguration = null;
            return _this;
        }
        Gamepads.prototype.init = function () {
            if (!this.supported) {
                return;
            }
            if (this._initSuccess) {
                return;
            }
            // In Chrome, this will return 4 undefined items until a button is pressed
            // In FF, this will not return any items until a button is pressed
            this._oldPads = this._clonePads(this._navigator.getGamepads());
            if (this._oldPads.length && this._oldPads[0]) {
                this._initSuccess = true;
            }
        };
        /**
         * Sets the minimum gamepad configuration, for example {axis: 4, buttons: 4} means
         * this game requires at minimum 4 axis inputs and 4 buttons, this is not restrictive
         * all other controllers with more axis or buttons are valid as well. If no minimum
         * configuration is set all pads are valid.
         */
        Gamepads.prototype.setMinimumGamepadConfiguration = function (config) {
            this._enableAndUpdate(); // if config is used, implicitly enable
            this._minimumConfiguration = config;
        };
        /**
         * When implicitly enabled, set the enabled flag and run an update so information is updated
         */
        Gamepads.prototype._enableAndUpdate = function () {
            if (!this.enabled) {
                this.enabled = true;
                this.update();
            }
        };
        /**
         * Checks a navigator gamepad against the minimum configuration if present.
         */
        Gamepads.prototype._isGamepadValid = function (pad) {
            if (!this._minimumConfiguration) {
                return true;
            }
            ;
            if (!pad) {
                return false;
            }
            ;
            var axesLength = pad.axes.filter(function (value) {
                return (typeof value !== undefined);
            }).length;
            var buttonLength = pad.buttons.filter(function (value) {
                return (typeof value !== undefined);
            }).length;
            return axesLength >= this._minimumConfiguration.axis &&
                buttonLength >= this._minimumConfiguration.buttons &&
                pad.connected;
        };
        Gamepads.prototype.on = function (eventName, handler) {
            this._enableAndUpdate(); // implicitly enable
            _super.prototype.on.call(this, eventName, handler);
        };
        Gamepads.prototype.off = function (eventName, handler) {
            this._enableAndUpdate(); // implicitly enable
            _super.prototype.off.call(this, eventName, handler);
        };
        /**
         * Updates Gamepad state and publishes Gamepad events
         */
        Gamepads.prototype.update = function () {
            if (!this.enabled || !this.supported) {
                return;
            }
            this.init();
            var gamepads = this._navigator.getGamepads();
            for (var i = 0; i < gamepads.length; i++) {
                if (!gamepads[i]) {
                    var gamepad = this.at(i);
                    // If was connected, but now isn't emit the disconnect event
                    if (gamepad.connected) {
                        this.eventDispatcher.emit('disconnect', new Events_8.GamepadDisconnectEvent(i, gamepad));
                    }
                    // Reset connection status
                    gamepad.connected = false;
                    continue;
                }
                else {
                    if (!this.at(i).connected && this._isGamepadValid(gamepads[i])) {
                        this.eventDispatcher.emit('connect', new Events_8.GamepadConnectEvent(i, this.at(i)));
                    }
                    // Set connection status
                    this.at(i).connected = true;
                }
                ;
                // Only supported in Chrome
                if (gamepads[i].timestamp && gamepads[i].timestamp === this._gamePadTimeStamps[i]) {
                    continue;
                }
                this._gamePadTimeStamps[i] = gamepads[i].timestamp;
                // Add reference to navigator gamepad
                this.at(i).navigatorGamepad = gamepads[i];
                // Buttons
                var b, bi, a, ai, value;
                for (b in Buttons) {
                    bi = Buttons[b];
                    if (typeof bi === 'number') {
                        if (gamepads[i].buttons[bi]) {
                            value = gamepads[i].buttons[bi].value;
                            if (value !== this._oldPads[i].getButton(bi)) {
                                if (gamepads[i].buttons[bi].pressed) {
                                    this.at(i).updateButton(bi, value);
                                    this.at(i).eventDispatcher.emit('button', new Events_8.GamepadButtonEvent(bi, value, this.at(i)));
                                }
                                else {
                                    this.at(i).updateButton(bi, 0);
                                }
                            }
                        }
                    }
                }
                // Axes
                for (a in Axes) {
                    ai = Axes[a];
                    if (typeof ai === 'number') {
                        value = gamepads[i].axes[ai];
                        if (value !== this._oldPads[i].getAxes(ai)) {
                            this.at(i).updateAxes(ai, value);
                            this.at(i).eventDispatcher.emit('axis', new Events_8.GamepadAxisEvent(ai, value, this.at(i)));
                        }
                    }
                }
                this._oldPads[i] = this._clonePad(gamepads[i]);
            }
        };
        /**
         * Safely retrieves a Gamepad at a specific index and creates one if it doesn't yet exist
         */
        Gamepads.prototype.at = function (index) {
            this._enableAndUpdate(); // implicitly enable gamepads when at() is called         
            if (index >= this._pads.length) {
                // Ensure there is a pad to retrieve
                for (var i = this._pads.length - 1, max = index; i < max; i++) {
                    this._pads.push(new Gamepad());
                    this._oldPads.push(new Gamepad());
                }
            }
            return this._pads[index];
        };
        /**
         * Returns a list of all valid gamepads that meet the minimum configuration requirement.
         */
        Gamepads.prototype.getValidGamepads = function () {
            this._enableAndUpdate();
            var result = [];
            for (var i = 0; i < this._pads.length; i++) {
                if (this._isGamepadValid(this.at(i).navigatorGamepad) && this.at(i).connected) {
                    result.push(this.at(i));
                }
            }
            return result;
        };
        /**
         * Gets the number of connected gamepads
         */
        Gamepads.prototype.count = function () {
            return this._pads.filter(function (p) { return p.connected; }).length;
        };
        Gamepads.prototype._clonePads = function (pads) {
            var arr = [];
            for (var i = 0, len = pads.length; i < len; i++) {
                arr.push(this._clonePad(pads[i]));
            }
            return arr;
        };
        /**
         * Fastest way to clone a known object is to do it yourself
         */
        Gamepads.prototype._clonePad = function (pad) {
            var i, len;
            var clonedPad = new Gamepad();
            if (!pad) {
                return clonedPad;
            }
            for (i = 0, len = pad.buttons.length; i < len; i++) {
                if (pad.buttons[i]) {
                    clonedPad.updateButton(i, pad.buttons[i].value);
                }
            }
            for (i = 0, len = pad.axes.length; i < len; i++) {
                clonedPad.updateAxes(i, pad.axes[i]);
            }
            return clonedPad;
        };
        return Gamepads;
    }(Class_5.Class));
    /**
     * The minimum value an axis has to move before considering it a change
     */
    Gamepads.MinAxisMoveThreshold = 0.05;
    exports.Gamepads = Gamepads;
    /**
     * Gamepad holds state information for a connected controller. See [[Gamepads]]
     * for more information on handling controller input.
     */
    var Gamepad = (function (_super) {
        __extends(Gamepad, _super);
        function Gamepad() {
            var _this = _super.call(this) || this;
            _this.connected = false;
            _this._buttons = new Array(16);
            _this._axes = new Array(4);
            var i;
            for (i = 0; i < _this._buttons.length; i++) {
                _this._buttons[i] = 0;
            }
            for (i = 0; i < _this._axes.length; i++) {
                _this._axes[i] = 0;
            }
            return _this;
        }
        /**
         * Whether or not the given button is pressed
         * @param button     The button to query
         * @param threshold  The threshold over which the button is considered to be pressed
         */
        Gamepad.prototype.isButtonPressed = function (button, threshold) {
            if (threshold === void 0) { threshold = 1; }
            return this._buttons[button] >= threshold;
        };
        /**
         * Gets the given button value between 0 and 1
         */
        Gamepad.prototype.getButton = function (button) {
            return this._buttons[button];
        };
        /**
         * Gets the given axis value between -1 and 1. Values below
         * [[MinAxisMoveThreshold]] are considered 0.
         */
        Gamepad.prototype.getAxes = function (axes) {
            var value = this._axes[axes];
            if (Math.abs(value) < Gamepads.MinAxisMoveThreshold) {
                return 0;
            }
            else {
                return value;
            }
        };
        Gamepad.prototype.updateButton = function (buttonIndex, value) {
            this._buttons[buttonIndex] = value;
        };
        Gamepad.prototype.updateAxes = function (axesIndex, value) {
            this._axes[axesIndex] = value;
        };
        return Gamepad;
    }(Class_5.Class));
    exports.Gamepad = Gamepad;
    /**
     * Gamepad Buttons enumeration
     */
    var Buttons;
    (function (Buttons) {
        /**
         * Face 1 button (e.g. A)
         */
        Buttons[Buttons["Face1"] = 0] = "Face1";
        /**
         * Face 2 button (e.g. B)
         */
        Buttons[Buttons["Face2"] = 1] = "Face2";
        /**
         * Face 3 button (e.g. X)
         */
        Buttons[Buttons["Face3"] = 2] = "Face3";
        /**
         * Face 4 button (e.g. Y)
         */
        Buttons[Buttons["Face4"] = 3] = "Face4";
        /**
         * Left bumper button
         */
        Buttons[Buttons["LeftBumper"] = 4] = "LeftBumper";
        /**
         * Right bumper button
         */
        Buttons[Buttons["RightBumper"] = 5] = "RightBumper";
        /**
         * Left trigger button
         */
        Buttons[Buttons["LeftTrigger"] = 6] = "LeftTrigger";
        /**
         * Right trigger button
         */
        Buttons[Buttons["RightTrigger"] = 7] = "RightTrigger";
        /**
         * Select button
         */
        Buttons[Buttons["Select"] = 8] = "Select";
        /**
         * Start button
         */
        Buttons[Buttons["Start"] = 9] = "Start";
        /**
         * Left analog stick press (e.g. L3)
         */
        Buttons[Buttons["LeftStick"] = 10] = "LeftStick";
        /**
         * Right analog stick press (e.g. R3)
         */
        Buttons[Buttons["RightStick"] = 11] = "RightStick";
        /**
         * D-pad up
         */
        Buttons[Buttons["DpadUp"] = 12] = "DpadUp";
        /**
         * D-pad down
         */
        Buttons[Buttons["DpadDown"] = 13] = "DpadDown";
        /**
         * D-pad left
         */
        Buttons[Buttons["DpadLeft"] = 14] = "DpadLeft";
        /**
         * D-pad right
         */
        Buttons[Buttons["DpadRight"] = 15] = "DpadRight";
    })(Buttons = exports.Buttons || (exports.Buttons = {}));
    /**
     * Gamepad Axes enumeration
     */
    var Axes;
    (function (Axes) {
        /**
         * Left analogue stick X direction
         */
        Axes[Axes["LeftStickX"] = 0] = "LeftStickX";
        /**
         * Left analogue stick Y direction
         */
        Axes[Axes["LeftStickY"] = 1] = "LeftStickY";
        /**
         * Right analogue stick X direction
         */
        Axes[Axes["RightStickX"] = 2] = "RightStickX";
        /**
         * Right analogue stick Y direction
         */
        Axes[Axes["RightStickY"] = 3] = "RightStickY";
    })(Axes = exports.Axes || (exports.Axes = {}));
});
define("Input/Pointer", ["require", "exports", "Engine", "Events", "UIActor", "Algebra", "Class", "Util/Util"], function (require, exports, Engine_2, Events_9, UIActor_1, Algebra_20, Class_6, Util) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The type of pointer for a [[PointerEvent]].
     */
    var PointerType;
    (function (PointerType) {
        PointerType[PointerType["Touch"] = 0] = "Touch";
        PointerType[PointerType["Mouse"] = 1] = "Mouse";
        PointerType[PointerType["Pen"] = 2] = "Pen";
        PointerType[PointerType["Unknown"] = 3] = "Unknown";
    })(PointerType = exports.PointerType || (exports.PointerType = {}));
    /**
     * The mouse button being pressed.
     */
    var PointerButton;
    (function (PointerButton) {
        PointerButton[PointerButton["Left"] = 0] = "Left";
        PointerButton[PointerButton["Middle"] = 1] = "Middle";
        PointerButton[PointerButton["Right"] = 2] = "Right";
        PointerButton[PointerButton["Unknown"] = 3] = "Unknown";
    })(PointerButton = exports.PointerButton || (exports.PointerButton = {}));
    var WheelDeltaMode;
    (function (WheelDeltaMode) {
        WheelDeltaMode[WheelDeltaMode["Pixel"] = 0] = "Pixel";
        WheelDeltaMode[WheelDeltaMode["Line"] = 1] = "Line";
        WheelDeltaMode[WheelDeltaMode["Page"] = 2] = "Page";
    })(WheelDeltaMode = exports.WheelDeltaMode || (exports.WheelDeltaMode = {}));
    /**
     * Determines the scope of handling mouse/touch events. See [[Pointers]] for more information.
     */
    var PointerScope;
    (function (PointerScope) {
        /**
         * Handle events on the `canvas` element only. Events originating outside the
         * `canvas` will not be handled.
         */
        PointerScope[PointerScope["Canvas"] = 0] = "Canvas";
        /**
         * Handles events on the entire document. All events will be handled by Excalibur.
         */
        PointerScope[PointerScope["Document"] = 1] = "Document";
    })(PointerScope = exports.PointerScope || (exports.PointerScope = {}));
    /**
     * A constant used to normalize wheel events across different browsers
     *
     * This normalization factor is pulled from https://developer.mozilla.org/en-US/docs/Web/Events/wheel#Listening_to_this_event_across_browser
     */
    var ScrollWheelNormalizationFactor = -1 / 40;
    /**
     * Pointer events
     *
     * Represents a mouse, touch, or stylus event. See [[Pointers]] for more information on
     * handling pointer input.
     *
     * For mouse-based events, you can inspect [[PointerEvent.button]] to see what button was pressed.
     */
    var PointerEvent = (function (_super) {
        __extends(PointerEvent, _super);
        /**
         * @param pageX        The `x` coordinate of the event (in document coordinates)
         * @param pageY        The `y` coordinate of the event (in document coordinates)
         * @param screenX      The `x` coordinate of the event (in screen coordinates)
         * @param screenY      The `y` coordinate of the event (in screen coordinates)
         * @param index        The index of the pointer (zero-based)
         * @param pointerType  The type of pointer
         * @param button       The button pressed (if [[PointerType.Mouse]])
         * @param ev           The raw DOM event being handled
         * @param pos          (Will be added to signature in 0.14.0 release) The position of the event (in world coordinates)
         */
        function PointerEvent(x, y, pageX, pageY, screenX, screenY, index, pointerType, button, ev) {
            var _this = _super.call(this) || this;
            _this.x = x;
            _this.y = y;
            _this.pageX = pageX;
            _this.pageY = pageY;
            _this.screenX = screenX;
            _this.screenY = screenY;
            _this.index = index;
            _this.pointerType = pointerType;
            _this.button = button;
            _this.ev = ev;
            return _this;
        }
        Object.defineProperty(PointerEvent.prototype, "pos", {
            get: function () {
                return new Algebra_20.Vector(this.x, this.y);
            },
            enumerable: true,
            configurable: true
        });
        return PointerEvent;
    }(Events_9.GameEvent));
    exports.PointerEvent = PointerEvent;
    ;
    /**
     * Wheel Events
     *
     * Represents a mouse wheel event. See [[Pointers]] for more information on
     * handling point input.
     */
    var WheelEvent = (function (_super) {
        __extends(WheelEvent, _super);
        /**
         * @param x            The `x` coordinate of the event (in world coordinates)
         * @param y            The `y` coordinate of the event (in world coordinates)
         * @param pageX        The `x` coordinate of the event (in document coordinates)
         * @param pageY        The `y` coordinate of the event (in document coordinates)
         * @param screenX      The `x` coordinate of the event (in screen coordinates)
         * @param screenY      The `y` coordinate of the event (in screen coordinates)
         * @param index        The index of the pointer (zero-based)
         * @param deltaX       The type of pointer
         * @param deltaY       The type of pointer
         * @param deltaZ       The type of pointer
         * @param deltaMode    The type of movement [[WheelDeltaMode]]
         * @param ev           The raw DOM event being handled
         */
        function WheelEvent(x, y, pageX, pageY, screenX, screenY, index, deltaX, deltaY, deltaZ, deltaMode, ev) {
            var _this = _super.call(this) || this;
            _this.x = x;
            _this.y = y;
            _this.pageX = pageX;
            _this.pageY = pageY;
            _this.screenX = screenX;
            _this.screenY = screenY;
            _this.index = index;
            _this.deltaX = deltaX;
            _this.deltaY = deltaY;
            _this.deltaZ = deltaZ;
            _this.deltaMode = deltaMode;
            _this.ev = ev;
            return _this;
        }
        return WheelEvent;
    }(Events_9.GameEvent));
    exports.WheelEvent = WheelEvent;
    ;
    /**
     * Handles pointer events (mouse, touch, stylus, etc.) and normalizes to
     * [W3C Pointer Events](http://www.w3.org/TR/pointerevents/).
     *
     * [[include:Pointers.md]]
     */
    var Pointers = (function (_super) {
        __extends(Pointers, _super);
        function Pointers(engine) {
            var _this = _super.call(this) || this;
            _this._pointerDown = [];
            _this._pointerUp = [];
            _this._pointerMove = [];
            _this._pointerCancel = [];
            _this._wheel = [];
            _this._pointers = [];
            _this._activePointers = [];
            _this._engine = engine;
            _this._pointers.push(new Pointer());
            _this._activePointers = [-1];
            _this.primary = _this._pointers[0];
            return _this;
        }
        Pointers.prototype.on = function (eventName, handler) {
            _super.prototype.on.call(this, eventName, handler);
        };
        /**
         * Initializes pointer event listeners
         */
        Pointers.prototype.init = function (target) {
            target = target || this._engine.canvas;
            // Touch Events
            target.addEventListener('touchstart', this._handleTouchEvent('down', this._pointerDown));
            target.addEventListener('touchend', this._handleTouchEvent('up', this._pointerUp));
            target.addEventListener('touchmove', this._handleTouchEvent('move', this._pointerMove));
            target.addEventListener('touchcancel', this._handleTouchEvent('cancel', this._pointerCancel));
            // W3C Pointer Events
            // Current: IE11, IE10
            if (window.PointerEvent) {
                // IE11
                this._engine.canvas.style.touchAction = 'none';
                target.addEventListener('pointerdown', this._handlePointerEvent('down', this._pointerDown));
                target.addEventListener('pointerup', this._handlePointerEvent('up', this._pointerUp));
                target.addEventListener('pointermove', this._handlePointerEvent('move', this._pointerMove));
                target.addEventListener('pointercancel', this._handlePointerEvent('cancel', this._pointerMove));
            }
            else if (window.MSPointerEvent) {
                // IE10
                this._engine.canvas.style.msTouchAction = 'none';
                target.addEventListener('MSPointerDown', this._handlePointerEvent('down', this._pointerDown));
                target.addEventListener('MSPointerUp', this._handlePointerEvent('up', this._pointerUp));
                target.addEventListener('MSPointerMove', this._handlePointerEvent('move', this._pointerMove));
                target.addEventListener('MSPointerCancel', this._handlePointerEvent('cancel', this._pointerMove));
            }
            else {
                // Mouse Events
                target.addEventListener('mousedown', this._handleMouseEvent('down', this._pointerDown));
                target.addEventListener('mouseup', this._handleMouseEvent('up', this._pointerUp));
                target.addEventListener('mousemove', this._handleMouseEvent('move', this._pointerMove));
            }
            // MDN MouseWheelEvent
            if ('onwheel' in document.createElement('div')) {
                // Modern Browsers
                target.addEventListener('wheel', this._handleWheelEvent('wheel', this._wheel));
            }
            else if (document.onmousewheel !== undefined) {
                // Webkit and IE
                target.addEventListener('mousewheel', this._handleWheelEvent('wheel', this._wheel));
            }
            else {
                // Remaining browser and older Firefox
                target.addEventListener('MozMousePixelScroll', this._handleWheelEvent('wheel', this._wheel));
            }
        };
        Pointers.prototype.update = function () {
            this._pointerUp.length = 0;
            this._pointerDown.length = 0;
            this._pointerMove.length = 0;
            this._pointerCancel.length = 0;
            this._wheel.length = 0;
        };
        /**
         * Safely gets a Pointer at a specific index and initializes one if it doesn't yet exist
         * @param index  The pointer index to retrieve
         */
        Pointers.prototype.at = function (index) {
            if (index >= this._pointers.length) {
                // Ensure there is a pointer to retrieve
                for (var i = this._pointers.length - 1, max = index; i < max; i++) {
                    this._pointers.push(new Pointer());
                    this._activePointers.push(-1);
                }
            }
            return this._pointers[index];
        };
        /**
         * Get number of pointers being watched
         */
        Pointers.prototype.count = function () {
            return this._pointers.length;
        };
        /**
         * Propogates events to actor if necessary
         */
        Pointers.prototype.propogate = function (actor) {
            var isUIActor = actor instanceof UIActor_1.UIActor;
            var i = 0, len = this._pointerUp.length;
            for (i; i < len; i++) {
                if (actor.contains(this._pointerUp[i].x, this._pointerUp[i].y, !isUIActor)) {
                    actor.eventDispatcher.emit('pointerup', this._pointerUp[i]);
                }
            }
            i = 0;
            len = this._pointerDown.length;
            for (i; i < len; i++) {
                if (actor.contains(this._pointerDown[i].x, this._pointerDown[i].y, !isUIActor)) {
                    actor.eventDispatcher.emit('pointerdown', this._pointerDown[i]);
                }
            }
            if (actor.capturePointer.captureMoveEvents) {
                i = 0;
                len = this._pointerMove.length;
                for (i; i < len; i++) {
                    if (actor.contains(this._pointerMove[i].x, this._pointerMove[i].y, !isUIActor)) {
                        actor.eventDispatcher.emit('pointermove', this._pointerMove[i]);
                    }
                }
            }
            i = 0;
            len = this._pointerCancel.length;
            for (i; i < len; i++) {
                if (actor.contains(this._pointerCancel[i].x, this._pointerCancel[i].y, !isUIActor)) {
                    actor.eventDispatcher.emit('pointercancel', this._pointerCancel[i]);
                }
            }
            i = 0;
            len = this._wheel.length;
            for (i; i < len; i++) {
                if (actor.contains(this._wheel[i].x, this._wheel[i].y, !isUIActor)) {
                    actor.eventDispatcher.emit('pointerwheel', this._wheel[i]);
                }
            }
        };
        Pointers.prototype._handleMouseEvent = function (eventName, eventArr) {
            var _this = this;
            return function (e) {
                e.preventDefault();
                var x = e.pageX - Util.getPosition(_this._engine.canvas).x;
                var y = e.pageY - Util.getPosition(_this._engine.canvas).y;
                var transformedPoint = _this._engine.screenToWorldCoordinates(new Algebra_20.Vector(x, y));
                var pe = new PointerEvent(transformedPoint.x, transformedPoint.y, e.pageX, e.pageY, x, y, 0, PointerType.Mouse, e.button, e);
                eventArr.push(pe);
                _this.at(0).eventDispatcher.emit(eventName, pe);
            };
        };
        Pointers.prototype._handleTouchEvent = function (eventName, eventArr) {
            var _this = this;
            return function (e) {
                e.preventDefault();
                for (var i = 0, len = e.changedTouches.length; i < len; i++) {
                    var index = _this._pointers.length > 1 ? _this._getPointerIndex(e.changedTouches[i].identifier) : 0;
                    if (index === -1) {
                        continue;
                    }
                    var x = e.changedTouches[i].pageX - Util.getPosition(_this._engine.canvas).x;
                    var y = e.changedTouches[i].pageY - Util.getPosition(_this._engine.canvas).y;
                    var transformedPoint = _this._engine.screenToWorldCoordinates(new Algebra_20.Vector(x, y));
                    var pe = new PointerEvent(transformedPoint.x, transformedPoint.y, e.changedTouches[i].pageX, e.changedTouches[i].pageY, x, y, index, PointerType.Touch, PointerButton.Unknown, e);
                    eventArr.push(pe);
                    _this.at(index).eventDispatcher.emit(eventName, pe);
                    // only with multi-pointer
                    if (_this._pointers.length > 1) {
                        if (eventName === 'up') {
                            // remove pointer ID from pool when pointer is lifted
                            _this._activePointers[index] = -1;
                        }
                        else if (eventName === 'down') {
                            // set pointer ID to given index
                            _this._activePointers[index] = e.changedTouches[i].identifier;
                        }
                    }
                }
            };
        };
        Pointers.prototype._handlePointerEvent = function (eventName, eventArr) {
            var _this = this;
            return function (e) {
                e.preventDefault();
                // get the index for this pointer ID if multi-pointer is asked for
                var index = _this._pointers.length > 1 ? _this._getPointerIndex(e.pointerId) : 0;
                if (index === -1) {
                    return;
                }
                var x = e.pageX - Util.getPosition(_this._engine.canvas).x;
                var y = e.pageY - Util.getPosition(_this._engine.canvas).y;
                var transformedPoint = _this._engine.screenToWorldCoordinates(new Algebra_20.Vector(x, y));
                var pe = new PointerEvent(transformedPoint.x, transformedPoint.y, e.pageX, e.pageY, x, y, index, _this._stringToPointerType(e.pointerType), e.button, e);
                eventArr.push(pe);
                _this.at(index).eventDispatcher.emit(eventName, pe);
                // only with multi-pointer
                if (_this._pointers.length > 1) {
                    if (eventName === 'up') {
                        // remove pointer ID from pool when pointer is lifted
                        _this._activePointers[index] = -1;
                    }
                    else if (eventName === 'down') {
                        // set pointer ID to given index
                        _this._activePointers[index] = e.pointerId;
                    }
                }
            };
        };
        Pointers.prototype._handleWheelEvent = function (eventName, eventArr) {
            var _this = this;
            return function (e) {
                // Should we prevent page scroll because of this event
                if (_this._engine.pageScrollPreventionMode === Engine_2.ScrollPreventionMode.All ||
                    (_this._engine.pageScrollPreventionMode === Engine_2.ScrollPreventionMode.Canvas && e.target === _this._engine.canvas)) {
                    e.preventDefault();
                }
                var x = e.pageX - Util.getPosition(_this._engine.canvas).x;
                var y = e.pageY - Util.getPosition(_this._engine.canvas).y;
                var transformedPoint = _this._engine.screenToWorldCoordinates(new Algebra_20.Vector(x, y));
                // deltaX, deltaY, and deltaZ are the standard modern properties
                // wheelDeltaX, wheelDeltaY, are legacy properties in webkit browsers and older IE
                // e.detail is only used in opera
                var deltaX = e.deltaX ||
                    (e.wheelDeltaX * ScrollWheelNormalizationFactor) ||
                    0;
                var deltaY = e.deltaY ||
                    (e.wheelDeltaY * ScrollWheelNormalizationFactor) ||
                    (e.wheelDelta * ScrollWheelNormalizationFactor) ||
                    e.detail ||
                    0;
                var deltaZ = e.deltaZ || 0;
                var deltaMode = WheelDeltaMode.Pixel;
                if (e.deltaMode) {
                    if (e.deltaMode === 1) {
                        deltaMode = WheelDeltaMode.Line;
                    }
                    else if (e.deltaMode === 2) {
                        deltaMode = WheelDeltaMode.Page;
                    }
                }
                var we = new WheelEvent(transformedPoint.x, transformedPoint.y, e.pageX, e.pageY, x, y, 0, deltaX, deltaY, deltaZ, deltaMode, e);
                eventArr.push(we);
                _this.at(0).eventDispatcher.emit(eventName, we);
            };
        };
        /**
         * Gets the index of the pointer specified for the given pointer ID or finds the next empty pointer slot available.
         * This is required because IE10/11 uses incrementing pointer IDs so we need to store a mapping of ID => idx
         */
        Pointers.prototype._getPointerIndex = function (pointerId) {
            var idx;
            if ((idx = this._activePointers.indexOf(pointerId)) > -1) {
                return idx;
            }
            for (var i = 0; i < this._activePointers.length; i++) {
                if (this._activePointers[i] === -1) {
                    return i;
                }
            }
            // ignore pointer because game isn't watching
            return -1;
        };
        Pointers.prototype._stringToPointerType = function (s) {
            switch (s) {
                case 'touch':
                    return PointerType.Touch;
                case 'mouse':
                    return PointerType.Mouse;
                case 'pen':
                    return PointerType.Pen;
                default:
                    return PointerType.Unknown;
            }
        };
        return Pointers;
    }(Class_6.Class));
    exports.Pointers = Pointers;
    /**
     * Captures and dispatches PointerEvents
     */
    var Pointer = (function (_super) {
        __extends(Pointer, _super);
        function Pointer() {
            var _this = _super.call(this) || this;
            /**
             * The last position on the document this pointer was at. Can be `null` if pointer was never active.
             */
            _this.lastPagePos = null;
            /**
             * The last position on the screen this pointer was at. Can be `null` if pointer was never active.
             */
            _this.lastScreenPos = null;
            /**
             * The last position in the game world coordinates this pointer was at. Can be `null` if pointer was never active.
             */
            _this.lastWorldPos = null;
            _this.on('move', _this._onPointerMove);
            return _this;
        }
        Pointer.prototype._onPointerMove = function (ev) {
            this.lastWorldPos = new Algebra_20.Vector(ev.x, ev.y);
            this.lastPagePos = new Algebra_20.Vector(ev.pageX, ev.pageY);
            this.lastScreenPos = new Algebra_20.Vector(ev.screenX, ev.screenY);
        };
        return Pointer;
    }(Class_6.Class));
    exports.Pointer = Pointer;
});
define("Input/Keyboard", ["require", "exports", "Class", "Events"], function (require, exports, Class_7, Events_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Enum representing input key codes
     */
    var Keys;
    (function (Keys) {
        Keys[Keys["Num1"] = 97] = "Num1";
        Keys[Keys["Num2"] = 98] = "Num2";
        Keys[Keys["Num3"] = 99] = "Num3";
        Keys[Keys["Num4"] = 100] = "Num4";
        Keys[Keys["Num5"] = 101] = "Num5";
        Keys[Keys["Num6"] = 102] = "Num6";
        Keys[Keys["Num7"] = 103] = "Num7";
        Keys[Keys["Num8"] = 104] = "Num8";
        Keys[Keys["Num9"] = 105] = "Num9";
        Keys[Keys["Num0"] = 96] = "Num0";
        Keys[Keys["Numlock"] = 144] = "Numlock";
        Keys[Keys["Semicolon"] = 186] = "Semicolon";
        Keys[Keys["A"] = 65] = "A";
        Keys[Keys["B"] = 66] = "B";
        Keys[Keys["C"] = 67] = "C";
        Keys[Keys["D"] = 68] = "D";
        Keys[Keys["E"] = 69] = "E";
        Keys[Keys["F"] = 70] = "F";
        Keys[Keys["G"] = 71] = "G";
        Keys[Keys["H"] = 72] = "H";
        Keys[Keys["I"] = 73] = "I";
        Keys[Keys["J"] = 74] = "J";
        Keys[Keys["K"] = 75] = "K";
        Keys[Keys["L"] = 76] = "L";
        Keys[Keys["M"] = 77] = "M";
        Keys[Keys["N"] = 78] = "N";
        Keys[Keys["O"] = 79] = "O";
        Keys[Keys["P"] = 80] = "P";
        Keys[Keys["Q"] = 81] = "Q";
        Keys[Keys["R"] = 82] = "R";
        Keys[Keys["S"] = 83] = "S";
        Keys[Keys["T"] = 84] = "T";
        Keys[Keys["U"] = 85] = "U";
        Keys[Keys["V"] = 86] = "V";
        Keys[Keys["W"] = 87] = "W";
        Keys[Keys["X"] = 88] = "X";
        Keys[Keys["Y"] = 89] = "Y";
        Keys[Keys["Z"] = 90] = "Z";
        Keys[Keys["Shift"] = 16] = "Shift";
        Keys[Keys["Alt"] = 18] = "Alt";
        Keys[Keys["Up"] = 38] = "Up";
        Keys[Keys["Down"] = 40] = "Down";
        Keys[Keys["Left"] = 37] = "Left";
        Keys[Keys["Right"] = 39] = "Right";
        Keys[Keys["Space"] = 32] = "Space";
        Keys[Keys["Esc"] = 27] = "Esc";
    })(Keys = exports.Keys || (exports.Keys = {}));
    ;
    /**
     * Event thrown on a game object for a key event
     */
    var KeyEvent = (function (_super) {
        __extends(KeyEvent, _super);
        /**
         * @param key  The key responsible for throwing the event
         */
        function KeyEvent(key) {
            var _this = _super.call(this) || this;
            _this.key = key;
            return _this;
        }
        return KeyEvent;
    }(Events_10.GameEvent));
    exports.KeyEvent = KeyEvent;
    /**
     * Provides keyboard support for Excalibur.
     *
     * [[include:Keyboard.md]]
     */
    var Keyboard = (function (_super) {
        __extends(Keyboard, _super);
        function Keyboard() {
            var _this = _super.call(this) || this;
            _this._keys = [];
            _this._keysUp = [];
            _this._keysDown = [];
            return _this;
        }
        Keyboard.prototype.on = function (eventName, handler) {
            _super.prototype.on.call(this, eventName, handler);
        };
        /**
         * Initialize Keyboard event listeners
         */
        Keyboard.prototype.init = function (global) {
            var _this = this;
            global = global || window;
            global.addEventListener('blur', function () {
                _this._keys.length = 0; // empties array efficiently
            });
            // key up is on window because canvas cannot have focus
            global.addEventListener('keyup', function (ev) {
                var code = _this._normalizeKeyCode(ev.keyCode);
                var key = _this._keys.indexOf(code);
                _this._keys.splice(key, 1);
                _this._keysUp.push(code);
                var keyEvent = new KeyEvent(code);
                // alias the old api, we may want to deprecate this in the future
                _this.eventDispatcher.emit('up', keyEvent);
                _this.eventDispatcher.emit('release', keyEvent);
            });
            // key down is on window because canvas cannot have focus
            global.addEventListener('keydown', function (ev) {
                var code = _this._normalizeKeyCode(ev.keyCode);
                if (_this._keys.indexOf(code) === -1) {
                    _this._keys.push(code);
                    _this._keysDown.push(code);
                    var keyEvent = new KeyEvent(code);
                    _this.eventDispatcher.emit('down', keyEvent);
                    _this.eventDispatcher.emit('press', keyEvent);
                }
            });
        };
        Keyboard.prototype.update = function () {
            // Reset keysDown and keysUp after update is complete
            this._keysDown.length = 0;
            this._keysUp.length = 0;
            // Emit synthetic "hold" event
            for (var i = 0; i < this._keys.length; i++) {
                this.eventDispatcher.emit('hold', new KeyEvent(this._keys[i]));
            }
        };
        /**
         * Gets list of keys being pressed down
         */
        Keyboard.prototype.getKeys = function () {
            return this._keys;
        };
        /**
         * Tests if a certain key was just pressed this frame. This is cleared at the end of the update frame.
         * @param key Test whether a key was just pressed
         */
        Keyboard.prototype.wasPressed = function (key) {
            return this._keysDown.indexOf(key) > -1;
        };
        /**
         * Tests if a certain key is held down. This is persisted between frames.
         * @param key  Test whether a key is held down
         */
        Keyboard.prototype.isHeld = function (key) {
            return this._keys.indexOf(key) > -1;
        };
        /**
         * Tests if a certain key was just released this frame. This is cleared at the end of the update frame.
         * @param key  Test whether a key was just released
         */
        Keyboard.prototype.wasReleased = function (key) {
            return this._keysUp.indexOf(key) > -1;
        };
        /**
         * Normalizes some browser event key codes to map to standard Excalibur key codes
         * @param code Event keyCode
         * @see http://unixpapa.com/js/key.html
         */
        Keyboard.prototype._normalizeKeyCode = function (code) {
            switch (code) {
                case 59:
                    return Keys.Semicolon;
                default:
                    return code;
            }
        };
        return Keyboard;
    }(Class_7.Class));
    exports.Keyboard = Keyboard;
});
define("Input/IEngineInput", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
/**
 * Provides support for mice, keyboards, and controllers.
 *
 * [[include:Input.md]]
 */
define("Input/Index", ["require", "exports", "Input/Gamepad", "Input/Pointer", "Input/Keyboard"], function (require, exports, Gamepad_1, Pointer_1, Keyboard_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @typedoc
     */
    __export(Gamepad_1);
    __export(Pointer_1);
    __export(Keyboard_1);
});
define("Util/Index", ["require", "exports", "Util/Util", "Util/DrawUtil"], function (require, exports, Util_3, drawUtil) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(Util_3);
    exports.DrawUtil = drawUtil;
});
define("Util/Decorators", ["require", "exports", "Util/Log", "Util/Util"], function (require, exports, Log_11, Util) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Obsolete decorator for marking Excalibur methods obsolete, you can optionally specify a custom message and/or alternate replacement
     * method do the deprecated one. Inspired by https://github.com/jayphelps/core-decorators.js
     */
    function obsolete(options) {
        options = Util.extend({}, { message: 'This method will be removed in future versions of Excalibur.', alternateMethod: null }, options);
        return function (target, property, descriptor) {
            if (!(typeof descriptor.value === 'function' ||
                typeof descriptor.get === 'function' ||
                typeof descriptor.set === 'function')) {
                throw new SyntaxError('Only functions/getters/setters can be marked as obsolete');
            }
            var methodSignature = "" + (target.name || '') + (target.name ? '.' : '') + property;
            var message = methodSignature + " is marked obsolete: " + options.message +
                (options.alternateMethod ? " Use " + options.alternateMethod + " instead" : '');
            var method = Util.extend({}, descriptor);
            if (descriptor.value) {
                method.value = function () {
                    Log_11.Logger.getInstance().warn(message);
                    return descriptor.value.apply(this, arguments);
                };
                return method;
            }
            if (descriptor.get) {
                method.get = function () {
                    Log_11.Logger.getInstance().warn(message);
                    return descriptor.get.apply(this, arguments);
                };
            }
            if (descriptor.set) {
                method.set = function () {
                    Log_11.Logger.getInstance().warn(message);
                    return descriptor.set.apply(this, arguments);
                };
            }
            return method;
        };
    }
    exports.obsolete = obsolete;
});
define("Util/Detector", ["require", "exports", "Util/Log"], function (require, exports, Log_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * This is the list of features that will be used to log the supported
     * features to the console when Detector.logBrowserFeatures() is called.
     */
    var REPORTED_FEATURES = {
        webgl: 'WebGL',
        webaudio: 'WebAudio',
        gamepadapi: 'Gamepad API'
    };
    /**
     * Excalibur internal feature detection helper class
     */
    var Detector = (function () {
        function Detector() {
            this._features = null;
            this.failedTests = [];
            // critical browser features required for ex to run
            this._criticalTests = {
                // Test canvas/2d context support
                canvasSupport: function () {
                    var elem = document.createElement('canvas');
                    return !!(elem.getContext && elem.getContext('2d'));
                },
                // Test array buffer support ex uses for downloading binary data
                arrayBufferSupport: function () {
                    var xhr = new XMLHttpRequest();
                    xhr.open('GET', '/');
                    try {
                        xhr.responseType = 'arraybuffer';
                    }
                    catch (e) {
                        return false;
                    }
                    return xhr.responseType === 'arraybuffer';
                },
                // Test data urls ex uses for sprites
                dataUrlSupport: function () {
                    var canvas = document.createElement('canvas');
                    return canvas.toDataURL('image/png').indexOf('data:image/png') === 0;
                },
                // Test object url support for loading
                objectUrlSupport: function () {
                    return ('URL' in window) && ('revokeObjectURL' in URL) && ('createObjectURL' in URL);
                },
                // RGBA support for colors
                rgbaSupport: function () {
                    var style = document.createElement('a').style;
                    style.cssText = 'background-color:rgba(150,255,150,.5)';
                    return ('' + style.backgroundColor).indexOf('rgba') > -1;
                }
            };
            // warnings excalibur performance will be degraded
            this._warningTest = {
                webAudioSupport: function () {
                    return !!(window.AudioContext ||
                        window.webkitAudioContext ||
                        window.mozAudioContext ||
                        window.msAudioContext ||
                        window.oAudioContext);
                },
                webglSupport: function () {
                    var elem = document.createElement('canvas');
                    return !!(elem.getContext && elem.getContext('webgl'));
                }
            };
            this._features = this._loadBrowserFeatures();
        }
        /**
         * Returns a map of currently supported browser features. This method
         * treats the features as a singleton and will only calculate feature
         * support if it has not previously been done.
         */
        Detector.prototype.getBrowserFeatures = function () {
            if (this._features === null) {
                this._features = this._loadBrowserFeatures();
            }
            return this._features;
        };
        /**
         * Report on non-critical browser support for debugging purposes.
         * Use native browser console colors for visibility.
         */
        Detector.prototype.logBrowserFeatures = function () {
            var msg = '%cSUPPORTED BROWSER FEATURES\n==========================%c\n';
            var args = [
                'font-weight: bold; color: navy',
                'font-weight: normal; color: inherit'
            ];
            var supported = this.getBrowserFeatures();
            for (var _i = 0, _a = Object.keys(REPORTED_FEATURES); _i < _a.length; _i++) {
                var feature = _a[_i];
                if (supported[feature]) {
                    msg += '(%c\u2713%c)'; // (✓)
                    args.push('font-weight: bold; color: green');
                    args.push('font-weight: normal; color: inherit');
                }
                else {
                    msg += '(%c\u2717%c)'; // (✗)
                    args.push('font-weight: bold; color: red');
                    args.push('font-weight: normal; color: inherit');
                }
                ;
                msg += ' ' + REPORTED_FEATURES[feature] + '\n';
            }
            args.unshift(msg);
            console.log.apply(console, args);
        };
        /**
         * Executes several IIFE's to get a constant reference to supported
         * features within the current execution context.
         */
        Detector.prototype._loadBrowserFeatures = function () {
            var _this = this;
            return {
                // IIFE to check canvas support
                canvas: (function () {
                    return _this._criticalTests.canvasSupport();
                })(),
                // IIFE to check arraybuffer support
                arraybuffer: (function () {
                    return _this._criticalTests.arrayBufferSupport();
                })(),
                // IIFE to check dataurl support
                dataurl: (function () {
                    return _this._criticalTests.dataUrlSupport();
                })(),
                // IIFE to check objecturl support
                objecturl: (function () {
                    return _this._criticalTests.objectUrlSupport();
                })(),
                // IIFE to check rgba support
                rgba: (function () {
                    return _this._criticalTests.rgbaSupport();
                })(),
                // IIFE to check webaudio support
                webaudio: (function () {
                    return _this._warningTest.webAudioSupport();
                })(),
                // IIFE to check webgl support
                webgl: (function () {
                    return _this._warningTest.webglSupport();
                })(),
                // IIFE to check gamepadapi support
                gamepadapi: (function () {
                    return !!navigator.getGamepads;
                })()
            };
        };
        Detector.prototype.test = function () {
            // Critical test will for ex not to run
            var failedCritical = false;
            for (var test in this._criticalTests) {
                if (!this._criticalTests[test].call(this)) {
                    this.failedTests.push(test);
                    Log_12.Logger.getInstance().error('Critical browser feature missing, Excalibur requires:', test);
                    failedCritical = true;
                }
            }
            if (failedCritical) {
                return false;
            }
            // Warning tests do not for ex to return false to compatibility
            for (var warning in this._warningTest) {
                if (!this._warningTest[warning]()) {
                    Log_12.Logger.getInstance().warn('Warning browser feature missing, Excalibur will have reduced performance:', warning);
                }
            }
            return true;
        };
        return Detector;
    }());
    exports.Detector = Detector;
});
define("Util/SortedList", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A sorted list implementation. NOTE: this implementation is not self-balancing
     */
    var SortedList = (function () {
        function SortedList(getComparable) {
            this._getComparable = getComparable;
        }
        SortedList.prototype.find = function (element) {
            return this._find(this._root, element);
        };
        SortedList.prototype._find = function (node, element) {
            if (node == null) {
                return false;
            }
            else if (this._getComparable.call(element) === node.getKey()) {
                if (node.getData().indexOf(element) > -1) {
                    return true;
                }
                else {
                    return false;
                }
            }
            else if (this._getComparable.call(element) < node.getKey()) {
                return this._find(node.getLeft(), element);
            }
            else {
                return this._find(node.getRight(), element);
            }
        };
        // returns the array of elements at a specific key value
        SortedList.prototype.get = function (key) {
            return this._get(this._root, key);
        };
        SortedList.prototype._get = function (node, key) {
            if (node == null) {
                return [];
            }
            else if (key === node.getKey()) {
                return node.getData();
            }
            else if (key < node.getKey()) {
                return this._get(node.getLeft(), key);
            }
            else {
                return this._get(node.getRight(), key);
            }
        };
        SortedList.prototype.add = function (element) {
            if (this._root == null) {
                this._root = new BinaryTreeNode(this._getComparable.call(element), [element], null, null);
                return true;
            }
            else {
                return this._insert(this._root, element);
            }
        };
        SortedList.prototype._insert = function (node, element) {
            if (node != null) {
                if (this._getComparable.call(element) === node.getKey()) {
                    if (node.getData().indexOf(element) > -1) {
                        return false; // the element we're trying to insert already exists
                    }
                    else {
                        node.getData().push(element);
                        return true;
                    }
                }
                else if (this._getComparable.call(element) < node.getKey()) {
                    if (node.getLeft() == null) {
                        node.setLeft(new BinaryTreeNode(this._getComparable.call(element), [element], null, null));
                        return true;
                    }
                    else {
                        return this._insert(node.getLeft(), element);
                    }
                }
                else {
                    if (node.getRight() == null) {
                        node.setRight(new BinaryTreeNode(this._getComparable.call(element), [element], null, null));
                        return true;
                    }
                    else {
                        return this._insert(node.getRight(), element);
                    }
                }
            }
            return false;
        };
        SortedList.prototype.removeByComparable = function (element) {
            this._root = this._remove(this._root, element);
        };
        SortedList.prototype._remove = function (node, element) {
            if (node == null) {
                return null;
            }
            else if (this._getComparable.call(element) === node.getKey()) {
                var elementIndex = node.getData().indexOf(element);
                // if the node contains the element, remove the element
                if (elementIndex > -1) {
                    node.getData().splice(elementIndex, 1);
                    // if we have removed the last element at this node, remove the node
                    if (node.getData().length === 0) {
                        // if the node is a leaf
                        if (node.getLeft() == null && node.getRight() == null) {
                            return null;
                        }
                        else if (node.getLeft() == null) {
                            return node.getRight();
                        }
                        else if (node.getRight() == null) {
                            return node.getLeft();
                        }
                        // if node has 2 children
                        var temp = this._findMinNode(node.getRight());
                        node.setKey(temp.getKey());
                        node.setData(temp.getData());
                        node.setRight(this._cleanup(node.getRight(), temp)); //"cleanup nodes" (move them up recursively)
                        return node;
                    }
                    else {
                        // this prevents the node from being removed since it still contains elements
                        return node;
                    }
                }
            }
            else if (this._getComparable.call(element) < node.getKey()) {
                node.setLeft(this._remove(node.getLeft(), element));
                return node;
            }
            else {
                node.setRight(this._remove(node.getRight(), element));
                return node;
            }
            return null;
        };
        // called once we have successfully removed the element we wanted, recursively corrects the part of the tree below the removed node
        SortedList.prototype._cleanup = function (node, element) {
            var comparable = element.getKey();
            if (node == null) {
                return null;
            }
            else if (comparable === node.getKey()) {
                // if the node is a leaf
                if (node.getLeft() == null && node.getRight() == null) {
                    return null;
                }
                else if (node.getLeft() == null) {
                    return node.getRight();
                }
                else if (node.getRight() == null) {
                    return node.getLeft();
                }
                // if node has 2 children
                var temp = this._findMinNode(node.getRight());
                node.setKey(temp.getKey());
                node.setData(temp.getData());
                node.setRight(this._cleanup(node.getRight(), temp));
                return node;
            }
            else if (this._getComparable.call(element) < node.getKey()) {
                node.setLeft(this._cleanup(node.getLeft(), element));
                return node;
            }
            else {
                node.setRight(this._cleanup(node.getRight(), element));
                return node;
            }
        };
        SortedList.prototype._findMinNode = function (node) {
            var current = node;
            while (current.getLeft() != null) {
                current = current.getLeft();
            }
            return current;
        };
        SortedList.prototype.list = function () {
            var results = new Array();
            this._list(this._root, results);
            return results;
        };
        SortedList.prototype._list = function (treeNode, results) {
            if (treeNode != null) {
                this._list(treeNode.getLeft(), results);
                treeNode.getData().forEach(function (element) {
                    results.push(element);
                });
                this._list(treeNode.getRight(), results);
            }
        };
        return SortedList;
    }());
    exports.SortedList = SortedList;
    /**
     * A tree node part of [[SortedList]]
     */
    var BinaryTreeNode = (function () {
        function BinaryTreeNode(key, data, left, right) {
            this._key = key;
            this._data = data;
            this._left = left;
            this._right = right;
        }
        BinaryTreeNode.prototype.getKey = function () {
            return this._key;
        };
        BinaryTreeNode.prototype.setKey = function (key) {
            this._key = key;
        };
        BinaryTreeNode.prototype.getData = function () {
            return this._data;
        };
        BinaryTreeNode.prototype.setData = function (data) {
            this._data = data;
        };
        BinaryTreeNode.prototype.getLeft = function () {
            return this._left;
        };
        BinaryTreeNode.prototype.setLeft = function (left) {
            this._left = left;
        };
        BinaryTreeNode.prototype.getRight = function () {
            return this._right;
        };
        BinaryTreeNode.prototype.setRight = function (right) {
            this._right = right;
        };
        return BinaryTreeNode;
    }());
    exports.BinaryTreeNode = BinaryTreeNode;
    /**
     * Mock element for testing
     *
     * @internal
     */
    var MockedElement = (function () {
        function MockedElement(key) {
            this._key = 0;
            this._key = key;
        }
        MockedElement.prototype.getTheKey = function () {
            return this._key;
        };
        MockedElement.prototype.setKey = function (key) {
            this._key = key;
        };
        return MockedElement;
    }());
    exports.MockedElement = MockedElement;
});
define("Index", ["require", "exports", "Actor", "Algebra", "Camera", "Class", "Configurable", "Debug", "Engine", "EventDispatcher", "Events", "Group", "Label", "Loader", "Particles", "Physics", "Promises", "Scene", "TileMap", "Timer", "Trigger", "UIActor", "Actions/Index", "Collision/Index", "Drawing/Index", "Math/Index", "PostProcessing/Index", "Resources/Index", "Events", "Input/Index", "Traits/Index", "Util/Index", "Util/Decorators", "Util/Detector", "Util/CullingBox", "Util/EasingFunctions", "Util/Log", "Util/SortedList"], function (require, exports, Actor_11, Algebra_21, Camera_1, Class_8, Configurable_7, Debug_1, Engine_3, EventDispatcher_2, Events_11, Group_1, Label_2, Loader_1, Particles_1, Physics_11, Promises_7, Scene_1, TileMap_1, Timer_1, Trigger_1, UIActor_2, Index_1, Index_2, Index_3, Index_4, Index_5, Index_6, events, input, traits, util, Decorators_1, Detector_1, CullingBox_2, EasingFunctions_3, Log_13, SortedList_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The current Excalibur version string
     */
    exports.EX_VERSION = '0.15.0';
    exports.Actor = Actor_11.Actor;
    exports.CollisionType = Actor_11.CollisionType;
    __export(Algebra_21);
    __export(Camera_1);
    __export(Class_8);
    __export(Configurable_7);
    __export(Debug_1);
    __export(Engine_3);
    __export(EventDispatcher_2);
    __export(Events_11);
    __export(Group_1);
    exports.Label = Label_2.Label;
    exports.FontStyle = Label_2.FontStyle;
    exports.FontUnit = Label_2.FontUnit;
    exports.TextAlign = Label_2.TextAlign;
    exports.BaseAlign = Label_2.BaseAlign;
    __export(Loader_1);
    exports.Particle = Particles_1.Particle;
    exports.ParticleEmitter = Particles_1.ParticleEmitter;
    exports.EmitterType = Particles_1.EmitterType;
    __export(Physics_11);
    __export(Promises_7);
    __export(Scene_1);
    exports.TileMap = TileMap_1.TileMap;
    exports.Cell = TileMap_1.Cell;
    exports.TileSprite = TileMap_1.TileSprite;
    __export(Timer_1);
    __export(Trigger_1);
    __export(UIActor_2);
    __export(Index_1);
    __export(Index_2);
    __export(Index_3);
    __export(Index_4);
    __export(Index_5);
    __export(Index_6);
    exports.Events = events;
    exports.Input = input;
    exports.Traits = traits;
    exports.Util = util;
    __export(Decorators_1);
    __export(Detector_1);
    __export(CullingBox_2);
    __export(EasingFunctions_3);
    __export(Log_13);
    __export(SortedList_1);
});
define("Engine", ["require", "exports", "Index", "Promises", "Algebra", "UIActor", "Actor", "Timer", "TileMap", "Loader", "Util/Detector", "Events", "Util/Log", "Drawing/Color", "Scene", "Debug", "Class", "Input/Index", "Util/Util", "Collision/BoundingBox"], function (require, exports, Index_7, Promises_8, Algebra_22, UIActor_3, Actor_12, Timer_2, TileMap_2, Loader_2, Detector_2, Events_12, Log_14, Color_19, Scene_2, Debug_2, Class_9, Input, Util, BoundingBox_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Enum representing the different display modes available to Excalibur
     */
    var DisplayMode;
    (function (DisplayMode) {
        /**
         * Show the game as full screen
         */
        DisplayMode[DisplayMode["FullScreen"] = 0] = "FullScreen";
        /**
         * Scale the game to the parent DOM container
         */
        DisplayMode[DisplayMode["Container"] = 1] = "Container";
        /**
         * Show the game as a fixed size
         */
        DisplayMode[DisplayMode["Fixed"] = 2] = "Fixed";
        /**
         * Allow the game to be positioned with the [[IEngineOptions.position]] option
         */
        DisplayMode[DisplayMode["Position"] = 3] = "Position";
    })(DisplayMode = exports.DisplayMode || (exports.DisplayMode = {}));
    /**
     * Enum representing the different mousewheel event bubble prevention
     */
    var ScrollPreventionMode;
    (function (ScrollPreventionMode) {
        /**
         * Do not prevent any page scrolling
         */
        ScrollPreventionMode[ScrollPreventionMode["None"] = 0] = "None";
        /**
         * Prevent page scroll if mouse is over the game canvas
         */
        ScrollPreventionMode[ScrollPreventionMode["Canvas"] = 1] = "Canvas";
        /**
         * Prevent all page scrolling via mouse wheel
         */
        ScrollPreventionMode[ScrollPreventionMode["All"] = 2] = "All";
    })(ScrollPreventionMode = exports.ScrollPreventionMode || (exports.ScrollPreventionMode = {}));
    /**
     * The Excalibur Engine
     *
     * The [[Engine]] is the main driver for a game. It is responsible for
     * starting/stopping the game, maintaining state, transmitting events,
     * loading resources, and managing the scene.
     *
     * [[include:Engine.md]]
     */
    var Engine = (function (_super) {
        __extends(Engine, _super);
        /**
         * Creates a new game using the given [[IEngineOptions]]. By default, if no options are provided,
         * the game will be rendered full screen (taking up all available browser window space).
         * You can customize the game rendering through [[IEngineOptions]].
         *
         * Example:
         *
         * ```js
         * var game = new ex.Engine({
         *   width: 0, // the width of the canvas
         *   height: 0, // the height of the canvas
         *   canvasElementId: '', // the DOM canvas element ID, if you are providing your own
         *   displayMode: ex.DisplayMode.FullScreen, // the display mode
         *   pointerScope: ex.Input.PointerScope.Document, // the scope of capturing pointer (mouse/touch) events
         *   backgroundColor: ex.Color.fromHex('#2185d0') // background color of the engine
         * });
         *
         * // call game.start, which is a Promise
         * game.start().then(function () {
         *   // ready, set, go!
         * });
         * ```
         */
        function Engine(options) {
            var _this = _super.call(this) || this;
            _this._hasStarted = false;
            /**
             * Access Excalibur debugging functionality.
             */
            _this.debug = new Debug_2.Debug();
            /**
             * Gets or sets the list of post processors to apply at the end of drawing a frame (such as [[ColorBlindCorrector]])
             */
            _this.postProcessors = [];
            /**
             * Contains all the scenes currently registered with Excalibur
             */
            _this.scenes = {};
            _this._animations = [];
            /**
             * Indicates whether the engine is set to fullscreen or not
             */
            _this.isFullscreen = false;
            /**
             * Indicates the current [[DisplayMode]] of the engine.
             */
            _this.displayMode = DisplayMode.FullScreen;
            /**
             * Indicates whether audio should be paused when the game is no longer visible.
             */
            _this.pauseAudioWhenHidden = true;
            /**
             * Indicates whether the engine should draw with debug information
             */
            _this.isDebug = false;
            _this.debugColor = new Color_19.Color(255, 255, 255);
            /**
             * The action to take when a fatal exception is thrown
             */
            _this.onFatalException = function (e) { Log_14.Logger.getInstance().fatal(e); };
            _this._isSmoothingEnabled = true;
            _this._timescale = 1.0;
            _this._isLoading = false;
            options = Util.extend({}, Engine._DefaultEngineOptions, options);
            // Check compatibility 
            var detector = new Detector_2.Detector();
            if (!options.suppressMinimumBrowserFeatureDetection && !(_this._compatible = detector.test())) {
                var message = document.createElement('div');
                message.innerText = 'Sorry, your browser does not support all the features needed for Excalibur';
                document.body.appendChild(message);
                detector.failedTests.forEach(function (test) {
                    var testMessage = document.createElement('div');
                    testMessage.innerText = 'Browser feature missing ' + test;
                    document.body.appendChild(testMessage);
                });
                if (options.canvasElementId) {
                    var canvas = document.getElementById(options.canvasElementId);
                    if (canvas) {
                        canvas.parentElement.removeChild(canvas);
                    }
                }
                return _this;
            }
            else {
                _this._compatible = true;
            }
            // Use native console API for color fun
            if (console.log && !options.suppressConsoleBootMessage) {
                console.log("%cPowered by Excalibur.js (v" + Index_7.EX_VERSION + ")", 'background: #176BAA; color: white; border-radius: 5px; padding: 15px; font-size: 1.5em; line-height: 80px;');
                console.log('\n\
      /| ________________\n\
O|===|* >________________>\n\
      \\|');
                console.log('Visit', 'http://excaliburjs.com', 'for more information');
            }
            _this._logger = Log_14.Logger.getInstance();
            // If debug is enabled, let's log browser features to the console.
            if (_this._logger.defaultLevel === Log_14.LogLevel.Debug) {
                detector.logBrowserFeatures();
            }
            _this._logger.debug('Building engine...');
            _this.canvasElementId = options.canvasElementId;
            if (options.canvasElementId) {
                _this._logger.debug('Using Canvas element specified: ' + options.canvasElementId);
                _this.canvas = document.getElementById(options.canvasElementId);
            }
            else {
                _this._logger.debug('Using generated canvas element');
                _this.canvas = document.createElement('canvas');
            }
            if (options.width && options.height) {
                if (options.displayMode === undefined) {
                    _this.displayMode = DisplayMode.Fixed;
                }
                _this._logger.debug('Engine viewport is size ' + options.width + ' x ' + options.height);
                _this.canvas.width = options.width;
                _this.canvas.height = options.height;
            }
            else if (!options.displayMode) {
                _this._logger.debug('Engine viewport is fullscreen');
                _this.displayMode = DisplayMode.FullScreen;
            }
            if (options.backgroundColor) {
                _this.backgroundColor = options.backgroundColor.clone();
            }
            _this._loader = new Loader_2.Loader();
            _this._initialize(options);
            _this.rootScene = _this.currentScene = new Scene_2.Scene(_this);
            _this.addScene('root', _this.rootScene);
            _this.goToScene('root');
            return _this;
        }
        Object.defineProperty(Engine.prototype, "canvasWidth", {
            /**
             * The width of the game canvas in pixels (physical width component of the
             * resolution of the canvas element)
             */
            get: function () {
                return this.canvas.width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "halfCanvasWidth", {
            /**
             * Returns half width of the game canvas in pixels (half physical width component)
             */
            get: function () {
                return this.canvas.width / 2;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "canvasHeight", {
            /**
             * The height of the game canvas in pixels, (physical height component of
             * the resolution of the canvas element)
             */
            get: function () {
                return this.canvas.height;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "halfCanvasHeight", {
            /**
             * Returns half height of the game canvas in pixels (half physical height component)
             */
            get: function () {
                return this.canvas.height / 2;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "drawWidth", {
            /**
             * Returns the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
             */
            get: function () {
                if (this.currentScene && this.currentScene.camera) {
                    return (this.canvasWidth / this.currentScene.camera.getZoom()) / this.pixelRatio;
                }
                return this.canvasWidth / this.pixelRatio;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "halfDrawWidth", {
            /**
             * Returns half the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
             */
            get: function () {
                return this.drawWidth / 2;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "drawHeight", {
            /**
             * Returns the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
             */
            get: function () {
                if (this.currentScene && this.currentScene.camera) {
                    return (this.canvasHeight / this.currentScene.camera.getZoom()) / this.pixelRatio;
                }
                return this.canvasHeight / this.pixelRatio;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "halfDrawHeight", {
            /**
             * Returns half the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
             */
            get: function () {
                return this.drawHeight / 2;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "isHiDpi", {
            /**
             * Returns whether excalibur detects the current screen to be HiDPI
             */
            get: function () {
                return this.pixelRatio !== 1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "stats", {
            /**
             * Access [[stats]] that holds frame statistics.
             */
            get: function () {
                return this.debug.stats;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Engine.prototype, "pixelRatio", {
            /**
             * Returns the calculated pixel ration for use in rendering
             */
            get: function () {
                var devicePixelRatio = window.devicePixelRatio || 1;
                var pixelRatio = devicePixelRatio;
                return pixelRatio;
            },
            enumerable: true,
            configurable: true
        });
        Engine.prototype.on = function (eventName, handler) {
            _super.prototype.on.call(this, eventName, handler);
        };
        /**
         * Returns a BoundingBox of the top left corner of the screen
         * and the bottom right corner of the screen.
         */
        Engine.prototype.getWorldBounds = function () {
            var left = this.screenToWorldCoordinates(Algebra_22.Vector.Zero).x;
            var top = this.screenToWorldCoordinates(Algebra_22.Vector.Zero).y;
            var right = left + this.drawWidth;
            var bottom = top + this.drawHeight;
            return new BoundingBox_7.BoundingBox(left, top, right, bottom);
        };
        Object.defineProperty(Engine.prototype, "timescale", {
            /**
             * Gets the current engine timescale factor (default is 1.0 which is 1:1 time)
             */
            get: function () {
                return this._timescale;
            },
            /**
             * Sets the current engine timescale factor. Useful for creating slow-motion effects or fast-forward effects
             * when using time-based movement.
             */
            set: function (value) {
                if (value <= 0) {
                    Log_14.Logger.getInstance().error('Cannot set engine.timescale to a value of 0 or less than 0.');
                    return;
                }
                this._timescale = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Plays a sprite animation on the screen at the specified `x` and `y`
         * (in game coordinates, not screen pixels). These animations play
         * independent of actors, and will be cleaned up internally as soon
         * as they are complete. Note animations that loop will never be
         * cleaned up.
         *
         * @param animation  Animation to play
         * @param x          x game coordinate to play the animation
         * @param y          y game coordinate to play the animation
         */
        Engine.prototype.playAnimation = function (animation, x, y) {
            this._animations.push(new AnimationNode(animation, x, y));
        };
        /**
         * Adds a [[TileMap]] to the [[currentScene]], once this is done the TileMap
         * will be drawn and updated.
         */
        Engine.prototype.addTileMap = function (tileMap) {
            this.currentScene.addTileMap(tileMap);
        };
        /**
         * Removes a [[TileMap]] from the [[currentScene]], it will no longer be drawn or updated.
         */
        Engine.prototype.removeTileMap = function (tileMap) {
            this.currentScene.removeTileMap(tileMap);
        };
        /**
         * Adds a [[Timer]] to the [[currentScene]].
         * @param timer  The timer to add to the [[currentScene]].
         */
        Engine.prototype.addTimer = function (timer) {
            return this.currentScene.addTimer(timer);
        };
        /**
         * Removes a [[Timer]] from the [[currentScene]].
         * @param timer  The timer to remove to the [[currentScene]].
         */
        Engine.prototype.removeTimer = function (timer) {
            return this.currentScene.removeTimer(timer);
        };
        /**
         * Adds a [[Scene]] to the engine, think of scenes in Excalibur as you
         * would levels or menus.
         *
         * @param key  The name of the scene, must be unique
         * @param scene The scene to add to the engine
         */
        Engine.prototype.addScene = function (key, scene) {
            if (this.scenes[key]) {
                this._logger.warn('Scene', key, 'already exists overwriting');
            }
            this.scenes[key] = scene;
            scene.engine = this;
        };
        /**
         * @internal
         */
        Engine.prototype.removeScene = function (entity) {
            if (entity instanceof Scene_2.Scene) {
                // remove scene
                for (var key in this.scenes) {
                    if (this.scenes.hasOwnProperty(key)) {
                        if (this.scenes[key] === entity) {
                            delete this.scenes[key];
                        }
                    }
                }
            }
            if (typeof entity === 'string') {
                // remove scene
                delete this.scenes[entity];
            }
        };
        Engine.prototype.add = function (entity) {
            if (entity instanceof UIActor_3.UIActor) {
                this.currentScene.addUIActor(entity);
                return;
            }
            if (entity instanceof Actor_12.Actor) {
                this._addChild(entity);
            }
            if (entity instanceof Timer_2.Timer) {
                this.addTimer(entity);
            }
            if (entity instanceof TileMap_2.TileMap) {
                this.addTileMap(entity);
            }
            if (arguments.length === 2) {
                this.addScene(arguments[0], arguments[1]);
            }
        };
        Engine.prototype.remove = function (entity) {
            if (entity instanceof UIActor_3.UIActor) {
                this.currentScene.removeUIActor(entity);
                return;
            }
            if (entity instanceof Actor_12.Actor) {
                this._removeChild(entity);
            }
            if (entity instanceof Timer_2.Timer) {
                this.removeTimer(entity);
            }
            if (entity instanceof TileMap_2.TileMap) {
                this.removeTileMap(entity);
            }
            if (entity instanceof Scene_2.Scene) {
                this.removeScene(entity);
            }
            if (typeof entity === 'string') {
                this.removeScene(entity);
            }
        };
        /**
         * Adds an actor to the [[currentScene]] of the game. This is synonymous
         * to calling `engine.currentScene.add(actor)`.
         *
         * Actors can only be drawn if they are a member of a scene, and only
         * the [[currentScene]] may be drawn or updated.
         *
         * @param actor  The actor to add to the [[currentScene]]
         */
        Engine.prototype._addChild = function (actor) {
            this.currentScene.add(actor);
        };
        /**
         * Removes an actor from the [[currentScene]] of the game. This is synonymous
         * to calling `engine.currentScene.remove(actor)`.
         * Actors that are removed from a scene will no longer be drawn or updated.
         *
         * @param actor  The actor to remove from the [[currentScene]].
         */
        Engine.prototype._removeChild = function (actor) {
            this.currentScene.remove(actor);
        };
        /**
         * Changes the currently updating and drawing scene to a different,
         * named scene. Calls the [[Scene]] lifecycle events.
         * @param key  The key of the scene to transition to.
         */
        Engine.prototype.goToScene = function (key) {
            if (this.scenes[key]) {
                var oldScene = this.currentScene;
                var newScene = this.scenes[key];
                this._logger.debug('Going to scene:', key);
                // only deactivate when initialized
                if (this.currentScene.isInitialized) {
                    this.currentScene.onDeactivate.call(this.currentScene);
                    this.currentScene.eventDispatcher.emit('deactivate', new Events_12.DeactivateEvent(newScene, this.currentScene));
                }
                // set current scene to new one
                this.currentScene = newScene;
                // initialize the current scene if has not been already
                this.currentScene._initialize(this);
                this.currentScene.onActivate.call(this.currentScene);
                this.currentScene.eventDispatcher.emit('activate', new Events_12.ActivateEvent(oldScene, this.currentScene));
            }
            else {
                this._logger.error('Scene', key, 'does not exist!');
            }
        };
        /**
         * Transforms the current x, y from screen coordinates to world coordinates
         * @param point  Screen coordinate to convert
         */
        Engine.prototype.screenToWorldCoordinates = function (point) {
            var newX = point.x;
            var newY = point.y;
            // transform back to world space
            newX = (newX / this.canvas.clientWidth) * this.drawWidth;
            newY = (newY / this.canvas.clientHeight) * this.drawHeight;
            // transform based on zoom
            newX = newX - this.halfDrawWidth;
            newY = newY - this.halfDrawHeight;
            // shift by focus
            if (this.currentScene && this.currentScene.camera) {
                var focus = this.currentScene.camera.getFocus();
                newX += focus.x;
                newY += focus.y;
            }
            return new Algebra_22.Vector(Math.floor(newX), Math.floor(newY));
        };
        /**
         * Transforms a world coordinate, to a screen coordinate
         * @param point  World coordinate to convert
         */
        Engine.prototype.worldToScreenCoordinates = function (point) {
            var screenX = point.x;
            var screenY = point.y;
            // shift by focus
            if (this.currentScene && this.currentScene.camera) {
                var focus = this.currentScene.camera.getFocus();
                screenX -= focus.x;
                screenY -= focus.y;
            }
            // transform back on zoom
            screenX = screenX + this.halfDrawWidth;
            screenY = screenY + this.halfDrawHeight;
            // transform back to screen space
            screenX = (screenX * this.canvas.clientWidth) / this.drawWidth;
            screenY = (screenY * this.canvas.clientHeight) / this.drawHeight;
            return new Algebra_22.Vector(Math.floor(screenX), Math.floor(screenY));
        };
        /**
         * Sets the internal canvas height based on the selected display mode.
         */
        Engine.prototype._setHeightByDisplayMode = function (parent) {
            if (this.displayMode === DisplayMode.Container) {
                this.canvas.width = parent.clientWidth;
                this.canvas.height = parent.clientHeight;
            }
            if (this.displayMode === DisplayMode.FullScreen) {
                document.body.style.margin = '0px';
                document.body.style.overflow = 'hidden';
                this.canvas.width = parent.innerWidth;
                this.canvas.height = parent.innerHeight;
            }
        };
        /**
         * Initializes the internal canvas, rendering context, displaymode, and native event listeners
         */
        Engine.prototype._initialize = function (options) {
            var _this = this;
            if (options.displayMode) {
                this.displayMode = options.displayMode;
            }
            if (this.displayMode === DisplayMode.FullScreen || this.displayMode === DisplayMode.Container) {
                var parent = (this.displayMode === DisplayMode.Container ?
                    (this.canvas.parentElement || document.body) : window);
                this._setHeightByDisplayMode(parent);
                window.addEventListener('resize', function () {
                    _this._logger.debug('View port resized');
                    _this._setHeightByDisplayMode(parent);
                    _this._logger.info('parent.clientHeight ' + parent.clientHeight);
                    _this.setAntialiasing(_this._isSmoothingEnabled);
                });
            }
            else if (this.displayMode === DisplayMode.Position) {
                this._intializeDisplayModePosition(options);
            }
            // initialize inputs
            this.input = {
                keyboard: new Input.Keyboard(),
                pointers: new Input.Pointers(this),
                gamepads: new Input.Gamepads()
            };
            this.input.keyboard.init();
            this.input.pointers.init(options && options.pointerScope === Input.PointerScope.Document ? document : this.canvas);
            this.input.gamepads.init();
            this.pageScrollPreventionMode = options.scrollPreventionMode;
            // Issue #385 make use of the visibility api
            // https://developer.mozilla.org/en-US/docs/Web/Guide/User_experience/Using_the_Page_Visibility_API
            var hidden, visibilityChange;
            if (typeof document.hidden !== 'undefined') {
                hidden = 'hidden';
                visibilityChange = 'visibilitychange';
            }
            else if ('msHidden' in document) {
                hidden = 'msHidden';
                visibilityChange = 'msvisibilitychange';
            }
            else if ('webkitHidden' in document) {
                hidden = 'webkitHidden';
                visibilityChange = 'webkitvisibilitychange';
            }
            document.addEventListener(visibilityChange, function () {
                if (document[hidden]) {
                    _this.eventDispatcher.emit('hidden', new Events_12.HiddenEvent(_this));
                    _this._logger.debug('Window hidden');
                }
                else {
                    _this.eventDispatcher.emit('visible', new Events_12.VisibleEvent(_this));
                    _this._logger.debug('Window visible');
                }
            });
            this.ctx = this.canvas.getContext('2d');
            if (!options.suppressHiDPIScaling) {
                this._initializeHiDpi();
            }
            if (!this.canvasElementId) {
                document.body.appendChild(this.canvas);
            }
        };
        Engine.prototype._intializeDisplayModePosition = function (options) {
            if (!options.position) {
                throw new Error('DisplayMode of Position was selected but no position option was given');
            }
            else {
                this.canvas.style.display = 'block';
                this.canvas.style.position = 'absolute';
                if (typeof options.position === 'string') {
                    var specifiedPosition = options.position.split(' ');
                    switch (specifiedPosition[0]) {
                        case 'top':
                            this.canvas.style.top = '0px';
                            break;
                        case 'bottom':
                            this.canvas.style.bottom = '0px';
                            break;
                        case 'middle':
                            this.canvas.style.top = '50%';
                            var offsetY = -this.halfDrawHeight;
                            this.canvas.style.marginTop = offsetY.toString();
                            break;
                        default:
                            throw new Error('Invalid Position Given');
                    }
                    if (specifiedPosition[1]) {
                        switch (specifiedPosition[1]) {
                            case 'left':
                                this.canvas.style.left = '0px';
                                break;
                            case 'right':
                                this.canvas.style.right = '0px';
                                break;
                            case 'center':
                                this.canvas.style.left = '50%';
                                var offsetX = -this.halfDrawWidth;
                                this.canvas.style.marginLeft = offsetX.toString();
                                break;
                            default:
                                throw new Error('Invalid Position Given');
                        }
                    }
                }
                else {
                    if (options.position.top) {
                        typeof options.position.top === 'number' ?
                            this.canvas.style.top = options.position.top.toString() + 'px' :
                            this.canvas.style.top = options.position.top;
                    }
                    if (options.position.right) {
                        typeof options.position.right === 'number' ?
                            this.canvas.style.right = options.position.right.toString() + 'px' :
                            this.canvas.style.right = options.position.right;
                    }
                    if (options.position.bottom) {
                        typeof options.position.bottom === 'number' ?
                            this.canvas.style.bottom = options.position.bottom.toString() + 'px' :
                            this.canvas.style.bottom = options.position.bottom;
                    }
                    if (options.position.left) {
                        typeof options.position.left === 'number' ?
                            this.canvas.style.left = options.position.left.toString() + 'px' :
                            this.canvas.style.left = options.position.left;
                    }
                }
            }
        };
        Engine.prototype._initializeHiDpi = function () {
            // Scale the canvas if needed
            if (this.isHiDpi) {
                var oldWidth = this.canvas.width;
                var oldHeight = this.canvas.height;
                this.canvas.width = oldWidth * this.pixelRatio;
                this.canvas.height = oldHeight * this.pixelRatio;
                this.canvas.style.width = oldWidth + 'px';
                this.canvas.style.height = oldHeight + 'px';
                this._logger.warn("Hi DPI screen detected, resetting canvas resolution from \n                           " + oldWidth + "x" + oldHeight + " to " + this.canvas.width + "x" + this.canvas.height + " \n                           css size will remain " + oldWidth + "x" + oldHeight);
                this.ctx.scale(this.pixelRatio, this.pixelRatio);
                this._logger.warn("Canvas drawing context was scaled by " + this.pixelRatio);
            }
        };
        /**
         * If supported by the browser, this will set the antialiasing flag on the
         * canvas. Set this to `false` if you want a 'jagged' pixel art look to your
         * image resources.
         * @param isSmooth  Set smoothing to true or false
         */
        Engine.prototype.setAntialiasing = function (isSmooth) {
            this._isSmoothingEnabled = isSmooth;
            var ctx = this.ctx;
            ctx.imageSmoothingEnabled = isSmooth;
            for (var _i = 0, _a = ['webkitImageSmoothingEnabled', 'mozImageSmoothingEnabled', 'msImageSmoothingEnabled']; _i < _a.length; _i++) {
                var smoothing = _a[_i];
                if (smoothing in ctx) {
                    ctx[smoothing] = isSmooth;
                }
            }
            ;
        };
        /**
         * Return the current smoothing status of the canvas
         */
        Engine.prototype.getAntialiasing = function () {
            return this.ctx.imageSmoothingEnabled ||
                this.ctx.webkitImageSmoothingEnabled ||
                this.ctx.mozImageSmoothingEnabled ||
                this.ctx.msImageSmoothingEnabled;
        };
        /**
         * Updates the entire state of the game
         * @param delta  Number of milliseconds elapsed since the last update.
         */
        Engine.prototype._update = function (delta) {
            if (this._isLoading) {
                // suspend updates untill loading is finished
                this._loader.update(this, delta);
                // Update input listeners
                this.input.keyboard.update();
                this.input.pointers.update();
                this.input.gamepads.update();
                return;
            }
            this.emit('preupdate', new Events_12.PreUpdateEvent(this, delta, this));
            // process engine level events
            this.currentScene.update(this, delta);
            // update animations
            this._animations = this._animations.filter(function (a) {
                return !a.animation.isDone();
            });
            // Update input listeners
            this.input.keyboard.update();
            this.input.pointers.update();
            this.input.gamepads.update();
            // Publish update event
            this.emit('postupdate', new Events_12.PostUpdateEvent(this, delta, this));
        };
        /**
         * Draws the entire game
         * @param delta  Number of milliseconds elapsed since the last draw.
         */
        Engine.prototype._draw = function (delta) {
            var ctx = this.ctx;
            this.emit('predraw', new Events_12.PreDrawEvent(ctx, delta, this));
            if (this._isLoading) {
                this._loader.draw(ctx, delta);
                // Drawing nothing else while loading
                return;
            }
            ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
            ctx.fillStyle = this.backgroundColor.toString();
            ctx.fillRect(0, 0, this.canvasWidth, this.canvasHeight);
            this.currentScene.draw(this.ctx, delta);
            // todo needs to be a better way of doing this
            var a = 0, len = this._animations.length;
            for (a; a < len; a++) {
                this._animations[a].animation.draw(ctx, this._animations[a].x, this._animations[a].y);
            }
            // Draw debug information
            if (this.isDebug) {
                this.ctx.font = 'Consolas';
                this.ctx.fillStyle = this.debugColor.toString();
                var keys = this.input.keyboard.getKeys();
                for (var j = 0; j < keys.length; j++) {
                    this.ctx.fillText(keys[j].toString() + ' : ' + (Input.Keys[keys[j]] ? Input.Keys[keys[j]] : 'Not Mapped'), 100, 10 * j + 10);
                }
                this.ctx.fillText('FPS:' + this.stats.currFrame.fps.toFixed(2).toString(), 10, 10);
            }
            // Post processing
            for (var i = 0; i < this.postProcessors.length; i++) {
                this.postProcessors[i].process(this.ctx.getImageData(0, 0, this.canvasWidth, this.canvasHeight), this.ctx);
            }
            this.emit('postdraw', new Events_12.PostDrawEvent(ctx, delta, this));
        };
        /**
         * Starts the internal game loop for Excalibur after loading
         * any provided assets.
         * @param loader  Optional [[ILoader]] to use to load resources. The default loader is [[Loader]], override to provide your own
         * custom loader.
         */
        Engine.prototype.start = function (loader) {
            var _this = this;
            if (!this._compatible) {
                var promise = new Promises_8.Promise();
                return promise.reject('Excalibur is incompatible with your browser');
            }
            var loadingComplete;
            if (loader) {
                this._loader = loader;
                this._loader.wireEngine(this);
                loadingComplete = this.load(this._loader);
            }
            else {
                loadingComplete = Promises_8.Promise.resolve();
            }
            loadingComplete.then(function () {
                _this.emit('start', new Events_12.GameStartEvent(_this));
            });
            if (!this._hasStarted) {
                this._hasStarted = true;
                this._logger.debug('Starting game...');
                Engine.createMainLoop(this, window.requestAnimationFrame, Date.now)();
                this._logger.debug('Game started');
            }
            else {
                // Game already started;
            }
            return loadingComplete;
        };
        Engine.createMainLoop = function (game, raf, nowFn) {
            var lastTime = nowFn();
            return function mainloop() {
                if (!game._hasStarted) {
                    return;
                }
                try {
                    game._requestId = raf(mainloop);
                    game.emit('preframe', new Events_12.PreFrameEvent(game, game.stats.prevFrame));
                    // Get the time to calculate time-elapsed
                    var now = nowFn();
                    var elapsed = Math.floor(now - lastTime) || 1;
                    // Resolves issue #138 if the game has been paused, or blurred for 
                    // more than a 200 milliseconds, reset elapsed time to 1. This improves reliability 
                    // and provides more expected behavior when the engine comes back
                    // into focus
                    if (elapsed > 200) {
                        elapsed = 1;
                    }
                    var delta = elapsed * game.timescale;
                    // reset frame stats (reuse existing instances)
                    var frameId = game.stats.prevFrame.id + 1;
                    game.stats.prevFrame.reset(game.stats.currFrame);
                    game.stats.currFrame.reset();
                    game.stats.currFrame.id = frameId;
                    game.stats.currFrame.delta = delta;
                    game.stats.currFrame.fps = 1.0 / (delta / 1000);
                    var beforeUpdate = nowFn();
                    game._update(delta);
                    var afterUpdate = nowFn();
                    game._draw(delta);
                    var afterDraw = nowFn();
                    game.stats.currFrame.duration.update = afterUpdate - beforeUpdate;
                    game.stats.currFrame.duration.draw = afterDraw - afterUpdate;
                    lastTime = now;
                    game.emit('postframe', new Events_12.PostFrameEvent(game, game.stats.currFrame));
                }
                catch (e) {
                    window.cancelAnimationFrame(game._requestId);
                    game.stop();
                    game.onFatalException(e);
                }
            };
        };
        /**
         * Stops Excalibur's main loop, useful for pausing the game.
         */
        Engine.prototype.stop = function () {
            if (this._hasStarted) {
                this.emit('stop', new Events_12.GameStopEvent(this));
                this._hasStarted = false;
                this._logger.debug('Game stopped');
            }
        };
        /**
         * Returns the Engine's Running status, Useful for checking whether engine is running or paused.
         */
        Engine.prototype.isPaused = function () {
            return !(this._hasStarted);
        };
        /**
         * Takes a screen shot of the current viewport and returns it as an
         * HTML Image Element.
         */
        Engine.prototype.screenshot = function () {
            var result = new Image();
            var raw = this.canvas.toDataURL('image/png');
            result.src = raw;
            return result;
        };
        /**
         * Another option available to you to load resources into the game.
         * Immediately after calling this the game will pause and the loading screen
         * will appear.
         * @param loader  Some [[ILoadable]] such as a [[Loader]] collection, [[Sound]], or [[Texture]].
         */
        Engine.prototype.load = function (loader) {
            var _this = this;
            var complete = new Promises_8.Promise();
            this._isLoading = true;
            loader.load().then(function () {
                setTimeout(function () {
                    _this._isLoading = false;
                    complete.resolve();
                }, 500);
            });
            return complete;
        };
        return Engine;
    }(Class_9.Class));
    /**
     * Default [[IEngineOptions]]
     */
    Engine._DefaultEngineOptions = {
        width: 0,
        height: 0,
        canvasElementId: '',
        pointerScope: Input.PointerScope.Document,
        suppressConsoleBootMessage: null,
        suppressMinimumBrowserFeatureDetection: null,
        suppressHiDPIScaling: null,
        scrollPreventionMode: ScrollPreventionMode.Canvas,
        backgroundColor: Color_19.Color.fromHex('#2185d0') // Excalibur blue
    };
    exports.Engine = Engine;
    /**
     * @internal
     */
    var AnimationNode = (function () {
        function AnimationNode(animation, x, y) {
            this.animation = animation;
            this.x = x;
            this.y = y;
        }
        return AnimationNode;
    }());
});
define("UIActor", ["require", "exports", "Algebra", "Actor", "Traits/Index"], function (require, exports, Algebra_23, Actor_13, Traits) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Helper [[Actor]] primitive for drawing UI's, optimized for UI drawing. Does
     * not participate in collisions. Drawn on top of all other actors.
     */
    var UIActor = (function (_super) {
        __extends(UIActor, _super);
        /**
         * @param x       The starting x coordinate of the actor
         * @param y       The starting y coordinate of the actor
         * @param width   The starting width of the actor
         * @param height  The starting height of the actor
         */
        function UIActor(xOrConfig, y, width, height) {
            var _this = this;
            if (typeof (xOrConfig !== 'object')) {
                _this = _super.call(this, xOrConfig, y, width, height) || this;
            }
            else {
                _this = _super.call(this, xOrConfig) || this;
            }
            _this.traits = [];
            _this.traits.push(new Traits.CapturePointer());
            _this.anchor.setTo(0, 0);
            _this.collisionType = Actor_13.CollisionType.PreventCollision;
            _this.enableCapturePointer = true;
            return _this;
        }
        UIActor.prototype.onInitialize = function (engine) {
            this._engine = engine;
        };
        UIActor.prototype.contains = function (x, y, useWorld) {
            if (useWorld === void 0) { useWorld = true; }
            if (useWorld) {
                return _super.prototype.contains.call(this, x, y);
            }
            var coords = this._engine.worldToScreenCoordinates(new Algebra_23.Vector(x, y));
            return _super.prototype.contains.call(this, coords.x, coords.y);
        };
        return UIActor;
    }(Actor_13.Actor));
    exports.UIActor = UIActor;
});
define("Util/Actors", ["require", "exports", "UIActor", "Label", "Trigger"], function (require, exports, UIActor_4, Label_3, Trigger_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isVanillaActor(actor) {
        return !(actor instanceof UIActor_4.UIActor) &&
            !(actor instanceof Trigger_2.Trigger) &&
            !(actor instanceof Label_3.Label);
    }
    exports.isVanillaActor = isVanillaActor;
    function isUIActor(actor) {
        return actor instanceof UIActor_4.UIActor;
    }
    exports.isUIActor = isUIActor;
});
define("Scene", ["require", "exports", "UIActor", "Physics", "Events", "Util/Log", "Timer", "Collision/DynamicTreeCollisionBroadphase", "Util/SortedList", "Group", "TileMap", "Camera", "Actor", "Class", "Util/Util", "Util/Actors", "Trigger"], function (require, exports, UIActor_5, Physics_12, Events_13, Log_15, Timer_3, DynamicTreeCollisionBroadphase_2, SortedList_2, Group_2, TileMap_3, Camera_2, Actor_14, Class_10, Util, ActorUtils, Trigger_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * [[Actor|Actors]] are composed together into groupings called Scenes in
     * Excalibur. The metaphor models the same idea behind real world
     * actors in a scene. Only actors in scenes will be updated and drawn.
     *
     * Typical usages of a scene include: levels, menus, loading screens, etc.
     *
     * [[include:Scenes.md]]
     */
    var Scene = (function (_super) {
        __extends(Scene, _super);
        function Scene(engine) {
            var _this = _super.call(this) || this;
            /**
             * The actors in the current scene
             */
            _this.actors = [];
            /**
             * The triggers in the current scene
             */
            _this.triggers = [];
            /**
             * The [[TileMap]]s in the scene, if any
             */
            _this.tileMaps = [];
            /**
             * The [[Group]]s in the scene, if any
             */
            _this.groups = {};
            /**
             * The [[UIActor]]s in a scene, if any; these are drawn last
             */
            _this.uiActors = [];
            _this._isInitialized = false;
            _this._sortedDrawingTree = new SortedList_2.SortedList(Actor_14.Actor.prototype.getZIndex);
            _this._broadphase = new DynamicTreeCollisionBroadphase_2.DynamicTreeCollisionBroadphase();
            _this._killQueue = [];
            _this._triggerKillQueue = [];
            _this._timers = [];
            _this._cancelQueue = [];
            _this._logger = Log_15.Logger.getInstance();
            _this.camera = new Camera_2.BaseCamera();
            if (engine) {
                _this.camera.x = engine.halfDrawWidth;
                _this.camera.y = engine.halfDrawHeight;
            }
            return _this;
        }
        Scene.prototype.on = function (eventName, handler) {
            _super.prototype.on.call(this, eventName, handler);
        };
        /**
         * This is called before the first update of the [[Scene]]. Initializes scene members like the camera. This method is meant to be
         * overridden. This is where initialization of child actors should take place.
         */
        Scene.prototype.onInitialize = function (engine) {
            // will be overridden
            if (this.camera) {
                this.camera.x = engine.halfDrawWidth;
                this.camera.y = engine.halfDrawHeight;
            }
            this._logger.debug('Scene.onInitialize', this, engine);
        };
        /**
         * This is called when the scene is made active and started. It is meant to be overriden,
         * this is where you should setup any DOM UI or event handlers needed for the scene.
         */
        Scene.prototype.onActivate = function () {
            // will be overridden
            this._logger.debug('Scene.onActivate', this);
        };
        /**
         * This is called when the scene is made transitioned away from and stopped. It is meant to be overriden,
         * this is where you should cleanup any DOM UI or event handlers needed for the scene.
         */
        Scene.prototype.onDeactivate = function () {
            // will be overridden
            this._logger.debug('Scene.onDeactivate', this);
        };
        /**
         * Initializes actors in the scene
         */
        Scene.prototype._initializeChildren = function () {
            for (var _i = 0, _a = this.actors; _i < _a.length; _i++) {
                var child = _a[_i];
                child._initialize(this.engine);
            }
        };
        Object.defineProperty(Scene.prototype, "isInitialized", {
            /**
             * Gets whether or not the [[Scene]] has been initialized
             */
            get: function () {
                return this._isInitialized;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Initializes the scene before the first update, meant to be called by engine not by users of
         * Excalibur
         * @internal
         */
        Scene.prototype._initialize = function (engine) {
            if (!this.isInitialized) {
                this.onInitialize.call(this, engine);
                this.eventDispatcher.emit('initialize', new Events_13.InitializeEvent(engine, this));
                this._initializeChildren();
                this._isInitialized = true;
            }
        };
        /**
         * Updates all the actors and timers in the scene. Called by the [[Engine]].
         * @param engine  Reference to the current Engine
         * @param delta   The number of milliseconds since the last update
         */
        Scene.prototype.update = function (engine, delta) {
            this.emit('preupdate', new Events_13.PreUpdateEvent(engine, delta, this));
            var i, len;
            // Remove timers in the cancel queue before updating them
            for (i = 0, len = this._cancelQueue.length; i < len; i++) {
                this.removeTimer(this._cancelQueue[i]);
            }
            this._cancelQueue.length = 0;
            // Cycle through timers updating timers
            for (var _i = 0, _a = this._timers; _i < _a.length; _i++) {
                var timer = _a[_i];
                timer.update(delta);
            }
            ;
            // Cycle through actors updating UI actors
            for (i = 0, len = this.uiActors.length; i < len; i++) {
                this.uiActors[i].update(engine, delta);
            }
            // Cycle through actors updating tile maps
            for (i = 0, len = this.tileMaps.length; i < len; i++) {
                this.tileMaps[i].update(engine, delta);
            }
            // Cycle through actors updating actors
            for (i = 0, len = this.actors.length; i < len; i++) {
                this.actors[i].update(engine, delta);
            }
            // Cycle through triggers updating
            for (i = 0, len = this.triggers.length; i < len; i++) {
                this.triggers[i].update(engine, delta);
            }
            this._collectActorStats(engine);
            // Run the broadphase and narrowphase
            if (this._broadphase && Physics_12.Physics.enabled) {
                var beforeBroadphase = Date.now();
                this._broadphase.update(this.actors, delta);
                var pairs = this._broadphase.broadphase(this.actors, delta, engine.stats.currFrame);
                var afterBroadphase = Date.now();
                var beforeNarrowphase = Date.now();
                var iter = Physics_12.Physics.collisionPasses;
                var collisionDelta = delta / iter;
                while (iter > 0) {
                    // Run the narrowphase
                    pairs = this._broadphase.narrowphase(pairs, engine.stats.currFrame);
                    // Run collision resolution strategy
                    pairs = this._broadphase.resolve(pairs, collisionDelta, Physics_12.Physics.collisionResolutionStrategy);
                    this._broadphase.runCollisionStartEnd(pairs);
                    iter--;
                }
                var afterNarrowphase = Date.now();
                engine.stats.currFrame.physics.broadphase = afterBroadphase - beforeBroadphase;
                engine.stats.currFrame.physics.narrowphase = afterNarrowphase - beforeNarrowphase;
            }
            engine.stats.currFrame.actors.killed = this._killQueue.length + this._triggerKillQueue.length;
            this._processKillQueue(this._killQueue, this.actors);
            this._processKillQueue(this._triggerKillQueue, this.triggers);
            if (this.camera) {
                this.camera.update(engine, delta);
            }
            this.emit('postupdate', new Events_13.PostUpdateEvent(engine, delta, this));
        };
        Scene.prototype._processKillQueue = function (killQueue, collection) {
            // Remove actors from scene graph after being killed
            var actorIndex;
            for (var _i = 0, killQueue_1 = killQueue; _i < killQueue_1.length; _i++) {
                var killed = killQueue_1[_i];
                actorIndex = collection.indexOf(killed);
                if (actorIndex > -1) {
                    this._sortedDrawingTree.removeByComparable(killed);
                    collection.splice(actorIndex, 1);
                }
            }
            killQueue.length = 0;
        };
        /**
         * Draws all the actors in the Scene. Called by the [[Engine]].
         * @param ctx    The current rendering context
         * @param delta  The number of milliseconds since the last draw
         */
        Scene.prototype.draw = function (ctx, delta) {
            this.emit('predraw', new Events_13.PreDrawEvent(ctx, delta, this));
            ctx.save();
            if (this.camera) {
                this.camera.draw(ctx);
            }
            var i, len;
            for (i = 0, len = this.tileMaps.length; i < len; i++) {
                this.tileMaps[i].draw(ctx, delta);
            }
            var sortedChildren = this._sortedDrawingTree.list();
            for (i = 0, len = sortedChildren.length; i < len; i++) {
                // only draw actors that are visible and on screen
                if (sortedChildren[i].visible && !sortedChildren[i].isOffScreen) {
                    sortedChildren[i].draw(ctx, delta);
                }
            }
            if (this.engine && this.engine.isDebug) {
                ctx.strokeStyle = 'yellow';
                this.debugDraw(ctx);
            }
            ctx.restore();
            for (i = 0, len = this.uiActors.length; i < len; i++) {
                // only draw ui actors that are visible and on screen
                if (this.uiActors[i].visible) {
                    this.uiActors[i].draw(ctx, delta);
                }
            }
            if (this.engine && this.engine.isDebug) {
                for (i = 0, len = this.uiActors.length; i < len; i++) {
                    this.uiActors[i].debugDraw(ctx);
                }
            }
            this.emit('postdraw', new Events_13.PostDrawEvent(ctx, delta, this));
        };
        /**
         * Draws all the actors' debug information in the Scene. Called by the [[Engine]].
         * @param ctx  The current rendering context
         */
        /* istanbul ignore next */
        Scene.prototype.debugDraw = function (ctx) {
            this.emit('predebugdraw', new Events_13.PreDebugDrawEvent(ctx, this));
            var i, len;
            for (i = 0, len = this.tileMaps.length; i < len; i++) {
                this.tileMaps[i].debugDraw(ctx);
            }
            for (i = 0, len = this.actors.length; i < len; i++) {
                this.actors[i].debugDraw(ctx);
            }
            for (i = 0, len = this.triggers.length; i < len; i++) {
                this.triggers[i].debugDraw(ctx);
            }
            this._broadphase.debugDraw(ctx, 20);
            this.camera.debugDraw(ctx);
            this.emit('postdebugdraw', new Events_13.PostDebugDrawEvent(ctx, this));
        };
        /**
         * Checks whether an actor is contained in this scene or not
         */
        Scene.prototype.contains = function (actor) {
            return this.actors.indexOf(actor) > -1;
        };
        Scene.prototype.add = function (entity) {
            if (entity instanceof Actor_14.Actor) {
                entity.unkill();
            }
            if (entity instanceof UIActor_5.UIActor) {
                if (!Util.contains(this.uiActors, entity)) {
                    this.addUIActor(entity);
                }
                return;
            }
            if (entity instanceof Actor_14.Actor) {
                if (!Util.contains(this.actors, entity)) {
                    this._addChild(entity);
                }
                return;
            }
            if (entity instanceof Timer_3.Timer) {
                if (!Util.contains(this._timers, entity)) {
                    this.addTimer(entity);
                }
                return;
            }
            if (entity instanceof TileMap_3.TileMap) {
                if (!Util.contains(this.tileMaps, entity)) {
                    this.addTileMap(entity);
                }
            }
        };
        Scene.prototype.remove = function (entity) {
            if (entity instanceof UIActor_5.UIActor) {
                this.removeUIActor(entity);
                return;
            }
            if (entity instanceof Actor_14.Actor) {
                this._broadphase.untrack(entity.body);
                this._removeChild(entity);
            }
            if (entity instanceof Timer_3.Timer) {
                this.removeTimer(entity);
            }
            if (entity instanceof TileMap_3.TileMap) {
                this.removeTileMap(entity);
            }
        };
        /**
         * Adds (any) actor to act as a piece of UI, meaning it is always positioned
         * in screen coordinates. UI actors do not participate in collisions.
         * @todo Should this be `UIActor` only?
         */
        Scene.prototype.addUIActor = function (actor) {
            this.uiActors.push(actor);
            actor.scene = this;
        };
        /**
         * Removes an actor as a piece of UI
         */
        Scene.prototype.removeUIActor = function (actor) {
            var index = this.uiActors.indexOf(actor);
            if (index > -1) {
                this.uiActors.splice(index, 1);
            }
        };
        /**
         * Adds an actor to the scene, once this is done the actor will be drawn and updated.
         */
        Scene.prototype._addChild = function (actor) {
            this._broadphase.track(actor.body);
            actor.scene = this;
            if (actor instanceof Trigger_3.Trigger) {
                this.triggers.push(actor);
            }
            else {
                this.actors.push(actor);
            }
            this._sortedDrawingTree.add(actor);
        };
        /**
         * Adds a [[TileMap]] to the scene, once this is done the TileMap will be drawn and updated.
         */
        Scene.prototype.addTileMap = function (tileMap) {
            this.tileMaps.push(tileMap);
        };
        /**
         * Removes a [[TileMap]] from the scene, it will no longer be drawn or updated.
         */
        Scene.prototype.removeTileMap = function (tileMap) {
            var index = this.tileMaps.indexOf(tileMap);
            if (index > -1) {
                this.tileMaps.splice(index, 1);
            }
        };
        /**
         * Removes an actor from the scene, it will no longer be drawn or updated.
         */
        Scene.prototype._removeChild = function (actor) {
            this._broadphase.untrack(actor.body);
            if (actor instanceof Trigger_3.Trigger) {
                this._triggerKillQueue.push(actor);
            }
            else {
                this._killQueue.push(actor);
            }
            actor.parent = null;
        };
        /**
         * Adds a [[Timer]] to the scene
         * @param timer  The timer to add
         */
        Scene.prototype.addTimer = function (timer) {
            this._timers.push(timer);
            timer.scene = this;
            return timer;
        };
        /**
         * Removes a [[Timer]] from the scene.
         * @warning Can be dangerous, use [[cancelTimer]] instead
         * @param timer  The timer to remove
         */
        Scene.prototype.removeTimer = function (timer) {
            var i = this._timers.indexOf(timer);
            if (i !== -1) {
                this._timers.splice(i, 1);
            }
            return timer;
        };
        /**
         * Cancels a [[Timer]], removing it from the scene nicely
         * @param timer  The timer to cancel
         */
        Scene.prototype.cancelTimer = function (timer) {
            this._cancelQueue.push(timer);
            return timer;
        };
        /**
         * Tests whether a [[Timer]] is active in the scene
         */
        Scene.prototype.isTimerActive = function (timer) {
            return (this._timers.indexOf(timer) > -1 && !timer.complete);
        };
        /**
         * Creates and adds a [[Group]] to the scene with a name
         */
        Scene.prototype.createGroup = function (name) {
            return new Group_2.Group(name, this);
        };
        /**
         * Returns a [[Group]] by name
         */
        Scene.prototype.getGroup = function (name) {
            return this.groups[name];
        };
        Scene.prototype.removeGroup = function (group) {
            if (typeof group === 'string') {
                delete this.groups[group];
            }
            else if (group instanceof Group_2.Group) {
                delete this.groups[group.name];
            }
            else {
                this._logger.error('Invalid arguments to removeGroup', group);
            }
        };
        /**
         * Removes the given actor from the sorted drawing tree
         */
        Scene.prototype.cleanupDrawTree = function (actor) {
            this._sortedDrawingTree.removeByComparable(actor);
        };
        /**
         * Updates the given actor's position in the sorted drawing tree
         */
        Scene.prototype.updateDrawTree = function (actor) {
            this._sortedDrawingTree.add(actor);
        };
        Scene.prototype._collectActorStats = function (engine) {
            for (var _i = 0, _a = this.uiActors; _i < _a.length; _i++) {
                var _ui = _a[_i];
                engine.stats.currFrame.actors.ui++;
            }
            for (var _b = 0, _c = this.actors; _b < _c.length; _b++) {
                var actor = _c[_b];
                engine.stats.currFrame.actors.alive++;
                for (var _d = 0, _e = actor.children; _d < _e.length; _d++) {
                    var child = _e[_d];
                    if (ActorUtils.isUIActor(child)) {
                        engine.stats.currFrame.actors.ui++;
                    }
                    else {
                        engine.stats.currFrame.actors.alive++;
                    }
                }
            }
        };
        return Scene;
    }(Class_10.Class));
    exports.Scene = Scene;
});
define("Events", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Base event type in Excalibur that all other event types derive from. Not all event types are thrown on all Excalibur game objects,
     * some events are unique to a type, others are not.
     *
     */
    var GameEvent = (function () {
        function GameEvent() {
        }
        return GameEvent;
    }());
    exports.GameEvent = GameEvent;
    /**
     * The 'kill' event is emitted on actors when it is killed. The target is the actor that was killed.
     */
    var KillEvent = (function (_super) {
        __extends(KillEvent, _super);
        function KillEvent(target) {
            var _this = _super.call(this) || this;
            _this.target = target;
            return _this;
        }
        return KillEvent;
    }(GameEvent));
    exports.KillEvent = KillEvent;
    /**
     * The 'start' event is emitted on engine when has started and is ready for interaction.
     */
    var GameStartEvent = (function (_super) {
        __extends(GameStartEvent, _super);
        function GameStartEvent(target) {
            var _this = _super.call(this) || this;
            _this.target = target;
            return _this;
        }
        return GameStartEvent;
    }(GameEvent));
    exports.GameStartEvent = GameStartEvent;
    /**
     * The 'stop' event is emitted on engine when has been stopped and will no longer take input, update or draw.
     */
    var GameStopEvent = (function (_super) {
        __extends(GameStopEvent, _super);
        function GameStopEvent(target) {
            var _this = _super.call(this) || this;
            _this.target = target;
            return _this;
        }
        return GameStopEvent;
    }(GameEvent));
    exports.GameStopEvent = GameStopEvent;
    /**
     * The 'predraw' event is emitted on actors, scenes, and engine before drawing starts. Actors' predraw happens inside their graphics
     * transform so that all drawing takes place with the actor as the origin.
     *
     */
    var PreDrawEvent = (function (_super) {
        __extends(PreDrawEvent, _super);
        function PreDrawEvent(ctx, delta, target) {
            var _this = _super.call(this) || this;
            _this.ctx = ctx;
            _this.delta = delta;
            _this.target = target;
            return _this;
        }
        return PreDrawEvent;
    }(GameEvent));
    exports.PreDrawEvent = PreDrawEvent;
    /**
     * The 'postdraw' event is emitted on actors, scenes, and engine after drawing finishes. Actors' postdraw happens inside their graphics
     * transform so that all drawing takes place with the actor as the origin.
     *
     */
    var PostDrawEvent = (function (_super) {
        __extends(PostDrawEvent, _super);
        function PostDrawEvent(ctx, delta, target) {
            var _this = _super.call(this) || this;
            _this.ctx = ctx;
            _this.delta = delta;
            _this.target = target;
            return _this;
        }
        return PostDrawEvent;
    }(GameEvent));
    exports.PostDrawEvent = PostDrawEvent;
    /**
     * The 'predebugdraw' event is emitted on actors, scenes, and engine before debug drawing starts.
     */
    var PreDebugDrawEvent = (function (_super) {
        __extends(PreDebugDrawEvent, _super);
        function PreDebugDrawEvent(ctx, target) {
            var _this = _super.call(this) || this;
            _this.ctx = ctx;
            _this.target = target;
            return _this;
        }
        return PreDebugDrawEvent;
    }(GameEvent));
    exports.PreDebugDrawEvent = PreDebugDrawEvent;
    /**
     * The 'postdebugdraw' event is emitted on actors, scenes, and engine after debug drawing starts.
     */
    var PostDebugDrawEvent = (function (_super) {
        __extends(PostDebugDrawEvent, _super);
        function PostDebugDrawEvent(ctx, target) {
            var _this = _super.call(this) || this;
            _this.ctx = ctx;
            _this.target = target;
            return _this;
        }
        return PostDebugDrawEvent;
    }(GameEvent));
    exports.PostDebugDrawEvent = PostDebugDrawEvent;
    /**
     * The 'preupdate' event is emitted on actors, scenes, and engine before the update starts.
     */
    var PreUpdateEvent = (function (_super) {
        __extends(PreUpdateEvent, _super);
        function PreUpdateEvent(engine, delta, target) {
            var _this = _super.call(this) || this;
            _this.engine = engine;
            _this.delta = delta;
            _this.target = target;
            return _this;
        }
        return PreUpdateEvent;
    }(GameEvent));
    exports.PreUpdateEvent = PreUpdateEvent;
    /**
     * The 'postupdate' event is emitted on actors, scenes, and engine after the update ends.
     */
    var PostUpdateEvent = (function (_super) {
        __extends(PostUpdateEvent, _super);
        function PostUpdateEvent(engine, delta, target) {
            var _this = _super.call(this) || this;
            _this.engine = engine;
            _this.delta = delta;
            _this.target = target;
            return _this;
        }
        return PostUpdateEvent;
    }(GameEvent));
    exports.PostUpdateEvent = PostUpdateEvent;
    /**
     * The 'preframe' event is emitted on the engine, before the frame begins.
     */
    var PreFrameEvent = (function (_super) {
        __extends(PreFrameEvent, _super);
        function PreFrameEvent(engine, prevStats) {
            var _this = _super.call(this) || this;
            _this.engine = engine;
            _this.prevStats = prevStats;
            _this.target = engine;
            return _this;
        }
        return PreFrameEvent;
    }(GameEvent));
    exports.PreFrameEvent = PreFrameEvent;
    /**
     * The 'postframe' event is emitted on the engine, after a frame ends.
     */
    var PostFrameEvent = (function (_super) {
        __extends(PostFrameEvent, _super);
        function PostFrameEvent(engine, stats) {
            var _this = _super.call(this) || this;
            _this.engine = engine;
            _this.stats = stats;
            _this.target = engine;
            return _this;
        }
        return PostFrameEvent;
    }(GameEvent));
    exports.PostFrameEvent = PostFrameEvent;
    /**
     * Event received when a gamepad is connected to Excalibur. [[Gamepads]] receives this event.
     */
    var GamepadConnectEvent = (function (_super) {
        __extends(GamepadConnectEvent, _super);
        function GamepadConnectEvent(index, gamepad) {
            var _this = _super.call(this) || this;
            _this.index = index;
            _this.gamepad = gamepad;
            _this.target = gamepad;
            return _this;
        }
        return GamepadConnectEvent;
    }(GameEvent));
    exports.GamepadConnectEvent = GamepadConnectEvent;
    /**
     * Event received when a gamepad is disconnected from Excalibur. [[Gamepads]] receives this event.
     */
    var GamepadDisconnectEvent = (function (_super) {
        __extends(GamepadDisconnectEvent, _super);
        function GamepadDisconnectEvent(index, gamepad) {
            var _this = _super.call(this) || this;
            _this.index = index;
            _this.gamepad = gamepad;
            _this.target = gamepad;
            return _this;
        }
        return GamepadDisconnectEvent;
    }(GameEvent));
    exports.GamepadDisconnectEvent = GamepadDisconnectEvent;
    /**
     * Gamepad button event. See [[Gamepads]] for information on responding to controller input. [[Gamepad]] instances receive this event;
     */
    var GamepadButtonEvent = (function (_super) {
        __extends(GamepadButtonEvent, _super);
        /**
         * @param button  The Gamepad button
         * @param value   A numeric value between 0 and 1
         */
        function GamepadButtonEvent(button, value, target) {
            var _this = _super.call(this) || this;
            _this.button = button;
            _this.value = value;
            _this.target = target;
            return _this;
        }
        return GamepadButtonEvent;
    }(GameEvent));
    exports.GamepadButtonEvent = GamepadButtonEvent;
    /**
     * Gamepad axis event. See [[Gamepads]] for information on responding to controller input. [[Gamepad]] instances receive this event;
     */
    var GamepadAxisEvent = (function (_super) {
        __extends(GamepadAxisEvent, _super);
        /**
         * @param axis  The Gamepad axis
         * @param value A numeric value between -1 and 1
         */
        function GamepadAxisEvent(axis, value, target) {
            var _this = _super.call(this) || this;
            _this.axis = axis;
            _this.value = value;
            _this.target = target;
            return _this;
        }
        return GamepadAxisEvent;
    }(GameEvent));
    exports.GamepadAxisEvent = GamepadAxisEvent;
    /**
     * Subscribe event thrown when handlers for events other than subscribe are added. Meta event that is received by
     * [[EventDispatcher|event dispatchers]].
     */
    var SubscribeEvent = (function (_super) {
        __extends(SubscribeEvent, _super);
        function SubscribeEvent(topic, handler) {
            var _this = _super.call(this) || this;
            _this.topic = topic;
            _this.handler = handler;
            return _this;
        }
        return SubscribeEvent;
    }(GameEvent));
    exports.SubscribeEvent = SubscribeEvent;
    /**
     * Unsubscribe event thrown when handlers for events other than unsubscribe are removed. Meta event that is received by
     * [[EventDispatcher|event dispatchers]].
     */
    var UnsubscribeEvent = (function (_super) {
        __extends(UnsubscribeEvent, _super);
        function UnsubscribeEvent(topic, handler) {
            var _this = _super.call(this) || this;
            _this.topic = topic;
            _this.handler = handler;
            return _this;
        }
        return UnsubscribeEvent;
    }(GameEvent));
    exports.UnsubscribeEvent = UnsubscribeEvent;
    /**
     * Event received by the [[Engine]] when the browser window is visible on a screen.
     */
    var VisibleEvent = (function (_super) {
        __extends(VisibleEvent, _super);
        function VisibleEvent(target) {
            var _this = _super.call(this) || this;
            _this.target = target;
            return _this;
        }
        return VisibleEvent;
    }(GameEvent));
    exports.VisibleEvent = VisibleEvent;
    /**
     * Event received by the [[Engine]] when the browser window is hidden from all screens.
     */
    var HiddenEvent = (function (_super) {
        __extends(HiddenEvent, _super);
        function HiddenEvent(target) {
            var _this = _super.call(this) || this;
            _this.target = target;
            return _this;
        }
        return HiddenEvent;
    }(GameEvent));
    exports.HiddenEvent = HiddenEvent;
    /**
     * Event thrown on an [[Actor|actor]] when a collision will occur this frame if it resolves
     */
    var PreCollisionEvent = (function (_super) {
        __extends(PreCollisionEvent, _super);
        /**
         * @param actor         The actor the event was thrown on
         * @param other         The actor that will collided with the current actor
         * @param side          The side that will be collided with the current actor
         * @param intersection  Intersection vector
         */
        function PreCollisionEvent(actor, other, side, intersection) {
            var _this = _super.call(this) || this;
            _this.actor = actor;
            _this.other = other;
            _this.side = side;
            _this.intersection = intersection;
            _this.target = actor;
            return _this;
        }
        return PreCollisionEvent;
    }(GameEvent));
    exports.PreCollisionEvent = PreCollisionEvent;
    /**
     * Event thrown on an [[Actor|actor]] when a collision has been resolved (body reacted) this frame
     */
    var PostCollisionEvent = (function (_super) {
        __extends(PostCollisionEvent, _super);
        /**
         * @param actor         The actor the event was thrown on
         * @param other         The actor that did collide with the current actor
         * @param side          The side that did collide with the current actor
         * @param intersection  Intersection vector
         */
        function PostCollisionEvent(actor, other, side, intersection) {
            var _this = _super.call(this) || this;
            _this.actor = actor;
            _this.other = other;
            _this.side = side;
            _this.intersection = intersection;
            _this.target = actor;
            return _this;
        }
        return PostCollisionEvent;
    }(GameEvent));
    exports.PostCollisionEvent = PostCollisionEvent;
    /**
     * Event thrown the first time an [[Actor|actor]] collides with another, after an actor is in contact normal collision events are fired.
     */
    var CollisionStartEvent = (function (_super) {
        __extends(CollisionStartEvent, _super);
        /**
         *
         */
        function CollisionStartEvent(actor, other, pair) {
            var _this = _super.call(this) || this;
            _this.actor = actor;
            _this.other = other;
            _this.pair = pair;
            _this.target = actor;
            return _this;
        }
        return CollisionStartEvent;
    }(GameEvent));
    exports.CollisionStartEvent = CollisionStartEvent;
    /**
     * Event thrown when the [[Actor|actor]] is no longer colliding with another
     */
    var CollisionEndEvent = (function (_super) {
        __extends(CollisionEndEvent, _super);
        /**
         *
         */
        function CollisionEndEvent(actor, other) {
            var _this = _super.call(this) || this;
            _this.actor = actor;
            _this.other = other;
            _this.target = actor;
            return _this;
        }
        return CollisionEndEvent;
    }(GameEvent));
    exports.CollisionEndEvent = CollisionEndEvent;
    /**
     * Event thrown on an [[Actor]] and a [[Scene]] only once before the first update call
     */
    var InitializeEvent = (function (_super) {
        __extends(InitializeEvent, _super);
        /**
         * @param engine  The reference to the current engine
         */
        function InitializeEvent(engine, target) {
            var _this = _super.call(this) || this;
            _this.engine = engine;
            _this.target = target;
            return _this;
        }
        return InitializeEvent;
    }(GameEvent));
    exports.InitializeEvent = InitializeEvent;
    /**
     * Event thrown on a [[Scene]] on activation
     */
    var ActivateEvent = (function (_super) {
        __extends(ActivateEvent, _super);
        /**
         * @param oldScene  The reference to the old scene
         */
        function ActivateEvent(oldScene, target) {
            var _this = _super.call(this) || this;
            _this.oldScene = oldScene;
            _this.target = target;
            return _this;
        }
        return ActivateEvent;
    }(GameEvent));
    exports.ActivateEvent = ActivateEvent;
    /**
     * Event thrown on a [[Scene]] on deactivation
     */
    var DeactivateEvent = (function (_super) {
        __extends(DeactivateEvent, _super);
        /**
         * @param newScene  The reference to the new scene
         */
        function DeactivateEvent(newScene, target) {
            var _this = _super.call(this) || this;
            _this.newScene = newScene;
            _this.target = target;
            return _this;
        }
        return DeactivateEvent;
    }(GameEvent));
    exports.DeactivateEvent = DeactivateEvent;
    /**
     * Event thrown on an [[Actor]] when it completely leaves the screen.
     */
    var ExitViewPortEvent = (function (_super) {
        __extends(ExitViewPortEvent, _super);
        function ExitViewPortEvent(target) {
            var _this = _super.call(this) || this;
            _this.target = target;
            return _this;
        }
        return ExitViewPortEvent;
    }(GameEvent));
    exports.ExitViewPortEvent = ExitViewPortEvent;
    /**
     * Event thrown on an [[Actor]] when it completely leaves the screen.
     */
    var EnterViewPortEvent = (function (_super) {
        __extends(EnterViewPortEvent, _super);
        function EnterViewPortEvent(target) {
            var _this = _super.call(this) || this;
            _this.target = target;
            return _this;
        }
        return EnterViewPortEvent;
    }(GameEvent));
    exports.EnterViewPortEvent = EnterViewPortEvent;
    var EnterTriggerEvent = (function (_super) {
        __extends(EnterTriggerEvent, _super);
        function EnterTriggerEvent(target, actor) {
            var _this = _super.call(this) || this;
            _this.target = target;
            _this.actor = actor;
            return _this;
        }
        return EnterTriggerEvent;
    }(GameEvent));
    exports.EnterTriggerEvent = EnterTriggerEvent;
    var ExitTriggerEvent = (function (_super) {
        __extends(ExitTriggerEvent, _super);
        function ExitTriggerEvent(target, actor) {
            var _this = _super.call(this) || this;
            _this.target = target;
            _this.actor = actor;
            return _this;
        }
        return ExitTriggerEvent;
    }(GameEvent));
    exports.ExitTriggerEvent = ExitTriggerEvent;
});
define("Class", ["require", "exports", "EventDispatcher"], function (require, exports, EventDispatcher_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Excalibur base class that provides basic functionality such as [[EventDispatcher]]
     * and extending abilities for vanilla Javascript projects
     */
    var Class = (function () {
        function Class() {
            this.eventDispatcher = new EventDispatcher_3.EventDispatcher(this);
        }
        /**
         * Alias for `addEventListener`. You can listen for a variety of
         * events off of the engine; see the events section below for a complete list.
         * @param eventName  Name of the event to listen for
         * @param handler    Event handler for the thrown event
         */
        Class.prototype.on = function (eventName, handler) {
            this.eventDispatcher.on(eventName, handler);
        };
        /**
         * Alias for `removeEventListener`. If only the eventName is specified
         * it will remove all handlers registered for that specific event. If the eventName
         * and the handler instance are specified only that handler will be removed.
         *
         * @param eventName  Name of the event to listen for
         * @param handler    Event handler for the thrown event
         */
        Class.prototype.off = function (eventName, handler) {
            this.eventDispatcher.off(eventName, handler);
        };
        /**
         * Emits a new event
         * @param eventName   Name of the event to emit
         * @param eventObject Data associated with this event
         */
        Class.prototype.emit = function (eventName, eventObject) {
            this.eventDispatcher.emit(eventName, eventObject);
        };
        /**
         * Once listens to an event one time, then unsubscribes from that event
         *
         * @param eventName The name of the event to subscribe to once
         * @param handler   The handler of the event that will be auto unsubscribed
         */
        Class.prototype.once = function (eventName, handler) {
            this.eventDispatcher.once(eventName, handler);
        };
        /**
         * You may wish to extend native Excalibur functionality in vanilla Javascript.
         * Any method on a class inheriting [[Class]] may be extended to support
         * additional functionality. In the example below we create a new type called `MyActor`.
         *
         *
         * ```js
         * var MyActor = Actor.extend({
         *
         *    constructor: function() {
         *       this.newprop = 'something';
         *       Actor.apply(this, arguments);
         *    },
         *
         *    update: function(engine, delta) {
         *       // Implement custom update
         *       // Call super constructor update
         *       Actor.prototype.update.call(this, engine, delta);
         *
         *       console.log("Something cool!");
         *    }
         * });
         *
         * var myActor = new MyActor(100, 100, 100, 100, Color.Azure);
         * ```
         *
         * In TypeScript, you only need to use the `extends` syntax, you do not need
         * to use this method of extension.
         *
         * @param methods A JSON object contain any methods/properties you want to extend
         */
        Class.extend = function (methods) {
            var parent = this;
            var child;
            if (methods && methods.hasOwnProperty('constructor')) {
                child = methods.constructor;
            }
            else {
                child = function () { return parent.apply(this, arguments); };
            }
            // Using constructor allows JS to lazily instantiate super classes
            var Super = function () { this.constructor = child; };
            Super.prototype = parent.prototype;
            child.prototype = new Super;
            if (methods) {
                for (var prop in methods) {
                    if (methods.hasOwnProperty(prop)) {
                        child.prototype[prop] = methods[prop];
                    }
                }
            }
            // Make subclasses extendable
            child.extend = Class.extend;
            return child;
        };
        return Class;
    }());
    exports.Class = Class;
});
define("Actor", ["require", "exports", "Physics", "Class", "Collision/BoundingBox", "Resources/Texture", "Events", "Drawing/Color", "Drawing/Sprite", "Util/Log", "Actions/ActionContext", "Actions/Action", "Algebra", "Collision/Body", "Collision/Side", "Configurable", "Traits/Index", "Drawing/SpriteEffects", "Util/Util"], function (require, exports, Physics_13, Class_11, BoundingBox_8, Texture_4, Events_14, Color_20, Sprite_4, Log_16, ActionContext_3, Action_2, Algebra_24, Body_2, Side_4, Configurable_8, Traits, Effects, Util) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @hidden
     */
    var ActorImpl = (function (_super) {
        __extends(ActorImpl, _super);
        /**
         * @param x       The starting x coordinate of the actor
         * @param y       The starting y coordinate of the actor
         * @param width   The starting width of the actor
         * @param height  The starting height of the actor
         * @param color   The starting color of the actor. Leave null to draw a transparent actor. The opacity of the color will be used as the
         * initial [[opacity]].
         */
        function ActorImpl(xOrConfig, y, width, height, color) {
            var _this = _super.call(this) || this;
            /**
             * The unique identifier for the actor
             */
            _this.id = ActorImpl.maxId++;
            /**
             * The physics body the is associated with this actor. The body is the container for all physical properties, like position, velocity,
             * acceleration, mass, inertia, etc.
             */
            _this.body = new Body_2.Body(_this);
            _this._height = 0;
            _this._width = 0;
            /**
             * The scale vector of the actor
             */
            _this.scale = new Algebra_24.Vector(1, 1);
            /**
             * The x scalar velocity of the actor in scale/second
             */
            _this.sx = 0; //scale/sec
            /**
             * The y scalar velocity of the actor in scale/second
             */
            _this.sy = 0; //scale/sec
            /**
             * Indicates whether the actor is physically in the viewport
             */
            _this.isOffScreen = false;
            /**
             * The visibility of an actor
             */
            _this.visible = true;
            /**
             * The opacity of an actor. Passing in a color in the [[constructor]] will use the
             * color's opacity.
             */
            _this.opacity = 1;
            _this.previousOpacity = 1;
            /**
             * Convenience reference to the global logger
             */
            _this.logger = Log_16.Logger.getInstance();
            /**
             * The scene that the actor is in
             */
            _this.scene = null;
            /**
             * The parent of this actor
             */
            _this.parent = null;
            // TODO: Replace this with the new actor collection once z-indexing is built
            /**
             * The children of this actor
             */
            _this.children = [];
            /**
             * Gets or sets the current collision type of this actor. By
             * default it is ([[CollisionType.PreventCollision]]).
             */
            _this.collisionType = CollisionType.PreventCollision;
            _this.collisionGroups = [];
            _this._collisionHandlers = {};
            _this._isInitialized = false;
            _this.frames = {};
            _this._effectsDirty = false;
            /**
             * Access to the current drawing for the actor, this can be
             * an [[Animation]], [[Sprite]], or [[Polygon]].
             * Set drawings with [[setDrawing]].
             */
            _this.currentDrawing = null;
            /**
             * Modify the current actor update pipeline.
             */
            _this.traits = [];
            /**
             * Whether or not to enable the [[CapturePointer]] trait that propagates
             * pointer events to this actor
             */
            _this.enableCapturePointer = false;
            /**
             * Configuration for [[CapturePointer]] trait
             */
            _this.capturePointer = {
                captureMoveEvents: false
            };
            _this._zIndex = 0;
            _this._isKilled = false;
            _this._opacityFx = new Effects.Opacity(_this.opacity);
            if (xOrConfig && typeof xOrConfig === 'object') {
                var config = xOrConfig;
                xOrConfig = config.pos ? config.pos.x : config.x;
                y = config.pos ? config.pos.y : config.y;
                width = config.width;
                height = config.height;
            }
            _this.pos.x = xOrConfig || 0;
            _this.pos.y = y || 0;
            _this._width = width || 0;
            _this._height = height || 0;
            if (color) {
                _this.color = color;
                // set default opacity of an actor to the color
                _this.opacity = color.a;
            }
            // Build default pipeline
            //this.traits.push(new ex.Traits.EulerMovement());
            // TODO: TileMaps should be converted to a collision area
            _this.traits.push(new Traits.TileMapCollisionDetection());
            _this.traits.push(new Traits.OffscreenCulling());
            _this.traits.push(new Traits.CapturePointer());
            // Build the action queue
            _this.actionQueue = new Action_2.ActionQueue(_this);
            _this.actions = new ActionContext_3.ActionContext(_this);
            // default anchor is in the middle
            _this.anchor = new Algebra_24.Vector(.5, .5);
            // Initialize default collision area to be box
            _this.body.useBoxCollision();
            return _this;
        }
        Object.defineProperty(ActorImpl.prototype, "collisionArea", {
            /**
             * Gets the collision area shape to use for collision possible options are [CircleArea|circles], [PolygonArea|polygons], and
             * [EdgeArea|edges].
             */
            get: function () {
                return this.body.collisionArea;
            },
            /**
             * Gets the collision area shape to use for collision possible options are [CircleArea|circles], [PolygonArea|polygons], and
             * [EdgeArea|edges].
             */
            set: function (area) {
                this.body.collisionArea = area;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "x", {
            /**
             * Gets the x position of the actor relative to it's parent (if any)
             */
            get: function () {
                return this.body.pos.x;
            },
            /**
             * Sets the x position of the actor relative to it's parent (if any)
             */
            set: function (theX) {
                this.body.pos.x = theX;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "y", {
            /**
             * Gets the y position of the actor relative to it's parent (if any)
             */
            get: function () {
                return this.body.pos.y;
            },
            /**
             * Sets the y position of the actor relative to it's parent (if any)
             */
            set: function (theY) {
                this.body.pos.y = theY;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "pos", {
            /**
             * Gets the position vector of the actor in pixels
             */
            get: function () {
                return this.body.pos;
            },
            /**
             * Sets the position vector of the actor in pixels
             */
            set: function (thePos) {
                this.body.pos.setTo(thePos.x, thePos.y);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "oldPos", {
            /**
             * Gets the position vector of the actor from the last frame
             */
            get: function () {
                return this.body.oldPos;
            },
            /**
             * Sets the position vector of the actor in the last frame
             */
            set: function (thePos) {
                this.body.oldPos.setTo(thePos.x, thePos.y);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "vel", {
            /**
             * Gets the velocity vector of the actor in pixels/sec
             */
            get: function () {
                return this.body.vel;
            },
            /**
             * Sets the velocity vector of the actor in pixels/sec
             */
            set: function (theVel) {
                this.body.vel.setTo(theVel.x, theVel.y);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "oldVel", {
            /**
             * Gets the velocity vector of the actor from the last frame
             */
            get: function () {
                return this.body.oldVel;
            },
            /**
             * Sets the velocity vector of the actor from the last frame
             */
            set: function (theVel) {
                this.body.oldVel.setTo(theVel.x, theVel.y);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "acc", {
            /**
             * Gets the acceleration vector of the actor in pixels/second/second. An acceleration pointing down such as (0, 100) may be
             * useful to simulate a gravitational effect.
             */
            get: function () {
                return this.body.acc;
            },
            /**
             * Sets the acceleration vector of teh actor in pixels/second/second
             */
            set: function (theAcc) {
                this.body.acc.setTo(theAcc.x, theAcc.y);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "rotation", {
            /**
             * Gets the rotation of the actor in radians. 1 radian = 180/PI Degrees.
             */
            get: function () {
                return this.body.rotation;
            },
            /**
             * Sets the rotation of the actor in radians. 1 radian = 180/PI Degrees.
             */
            set: function (theAngle) {
                this.body.rotation = theAngle;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "rx", {
            /**
             * Gets the rotational velocity of the actor in radians/second
             */
            get: function () {
                return this.body.rx;
            },
            /**
             * Sets the rotational velocity of the actor in radians/sec
             */
            set: function (angularVelocity) {
                this.body.rx = angularVelocity;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "torque", {
            /**
             * Gets the current torque applied to the actor. Torque can be thought of as rotational force
             */
            get: function () {
                return this.body.torque;
            },
            /**
             * Sets the current torque applied to the actor. Torque can be thought of as rotational force
             */
            set: function (theTorque) {
                this.body.torque = theTorque;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "mass", {
            /**
             * Get the current mass of the actor, mass can be thought of as the resistance to acceleration.
             */
            get: function () {
                return this.body.mass;
            },
            /**
             * Sets the mass of the actor, mass can be thought of as the resistance to acceleration.
             */
            set: function (theMass) {
                this.body.mass = theMass;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "moi", {
            /**
             * Gets the current moment of inertia, moi can be thought of as the resistance to rotation.
             */
            get: function () {
                return this.body.moi;
            },
            /**
             * Sets the current moment of inertia, moi can be thought of as the resistance to rotation.
             */
            set: function (theMoi) {
                this.body.moi = theMoi;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "friction", {
            /**
             * Gets the coefficient of friction on this actor, this can be thought of as how sticky or slippery an object is.
             */
            get: function () {
                return this.body.friction;
            },
            /**
             * Sets the coefficient of friction of this actor, this can ve thought of as how stick or slippery an object is.
             */
            set: function (theFriction) {
                this.body.friction = theFriction;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "restitution", {
            /**
             * Gets the coefficient of restitution of this actor, represents the amount of energy preserved after collision. Think of this
             * as bounciness.
             */
            get: function () {
                return this.body.restitution;
            },
            /**
             * Sets the coefficient of restitution of this actor, represents the amount of energy preserved after collision. Think of this
             * as bounciness.
             */
            set: function (theRestitution) {
                this.body.restitution = theRestitution;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActorImpl.prototype, "color", {
            /**
             * Sets the color of the actor. A rectangle of this color will be
             * drawn if no [[IDrawable]] is specified as the actors drawing.
             *
             * The default is `null` which prevents a rectangle from being drawn.
             */
            get: function () {
                return this._color;
            },
            set: function (v) {
                this._color = v.clone();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * This is called before the first update of the actor. This method is meant to be
         * overridden. This is where initialization of child actors should take place.
         */
        ActorImpl.prototype.onInitialize = function (_engine) {
            // Override me
        };
        Object.defineProperty(ActorImpl.prototype, "isInitialized", {
            /**
             * Gets wether the actor is Initialized
             */
            get: function () {
                return this._isInitialized;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Initializes this actor and all it's child actors, meant to be called by the Scene before first update not by users of Excalibur.
         * @internal
         */
        ActorImpl.prototype._initialize = function (engine) {
            if (!this.isInitialized) {
                this.onInitialize(engine);
                this.eventDispatcher.emit('initialize', new Events_14.InitializeEvent(engine, this));
                this._isInitialized = true;
            }
            for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
                var child = _a[_i];
                child._initialize(engine);
            }
        };
        ActorImpl.prototype._checkForPointerOptIn = function (eventName) {
            if (eventName) {
                var normalized = eventName.toLowerCase();
                if (normalized === 'pointerup' || normalized === 'pointerdown' || normalized === 'pointermove') {
                    this.enableCapturePointer = true;
                    if (normalized === 'pointermove') {
                        this.capturePointer.captureMoveEvents = true;
                    }
                }
            }
        };
        ActorImpl.prototype.on = function (eventName, handler) {
            this._checkForPointerOptIn(eventName);
            this.eventDispatcher.on(eventName, handler);
        };
        ActorImpl.prototype.once = function (eventName, handler) {
            this._checkForPointerOptIn(eventName);
            this.eventDispatcher.once(eventName, handler);
        };
        /**
         * If the current actor is a member of the scene, this will remove
         * it from the scene graph. It will no longer be drawn or updated.
         */
        ActorImpl.prototype.kill = function () {
            if (this.scene) {
                this.emit('kill', new Events_14.KillEvent(this));
                this.scene.remove(this);
                this._isKilled = true;
            }
            else {
                this.logger.warn('Cannot kill actor, it was never added to the Scene');
            }
        };
        /**
         * If the current actor is killed, it will now not be killed.
         */
        ActorImpl.prototype.unkill = function () {
            this._isKilled = false;
        };
        /**
         * Indicates wether the actor has been killed.
         */
        ActorImpl.prototype.isKilled = function () {
            return this._isKilled;
        };
        /**
         * Adds a child actor to this actor. All movement of the child actor will be
         * relative to the parent actor. Meaning if the parent moves the child will
         * move with it.
         * @param actor The child actor to add
         */
        ActorImpl.prototype.add = function (actor) {
            actor.collisionType = CollisionType.PreventCollision;
            if (Util.addItemToArray(actor, this.children)) {
                actor.parent = this;
            }
        };
        /**
         * Removes a child actor from this actor.
         * @param actor The child actor to remove
         */
        ActorImpl.prototype.remove = function (actor) {
            if (Util.removeItemFromArray(actor, this.children)) {
                actor.parent = null;
            }
        };
        ActorImpl.prototype.setDrawing = function (key) {
            key = key.toString();
            if (this.currentDrawing !== this.frames[key]) {
                if (this.frames[key] != null) {
                    this.frames[key].reset();
                    this.currentDrawing = this.frames[key];
                }
                else {
                    Log_16.Logger.getInstance().error('the specified drawing key \'' + key + '\' does not exist');
                }
            }
        };
        ActorImpl.prototype.addDrawing = function () {
            if (arguments.length === 2) {
                this.frames[arguments[0]] = arguments[1];
                if (!this.currentDrawing) {
                    this.currentDrawing = arguments[1];
                }
                this._effectsDirty = true;
            }
            else {
                if (arguments[0] instanceof Sprite_4.Sprite) {
                    this.addDrawing('default', arguments[0]);
                }
                if (arguments[0] instanceof Texture_4.Texture) {
                    this.addDrawing('default', arguments[0].asSprite());
                }
            }
        };
        Object.defineProperty(ActorImpl.prototype, "z", {
            get: function () {
                return this.getZIndex();
            },
            set: function (newZ) {
                this.setZIndex(newZ);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Gets the z-index of an actor. The z-index determines the relative order an actor is drawn in.
         * Actors with a higher z-index are drawn on top of actors with a lower z-index
         */
        ActorImpl.prototype.getZIndex = function () {
            return this._zIndex;
        };
        /**
         * Sets the z-index of an actor and updates it in the drawing list for the scene.
         * The z-index determines the relative order an actor is drawn in.
         * Actors with a higher z-index are drawn on top of actors with a lower z-index
         * @param newIndex new z-index to assign
         */
        ActorImpl.prototype.setZIndex = function (newIndex) {
            this.scene.cleanupDrawTree(this);
            this._zIndex = newIndex;
            this.scene.updateDrawTree(this);
        };
        /**
         * Adds an actor to a collision group. Actors with no named collision groups are
         * considered to be in every collision group.
         *
         * Once in a collision group(s) actors will only collide with other actors in
         * that group.
         *
         * @param name The name of the collision group
         */
        ActorImpl.prototype.addCollisionGroup = function (name) {
            this.collisionGroups.push(name);
        };
        /**
         * Removes an actor from a collision group.
         * @param name The name of the collision group
         */
        ActorImpl.prototype.removeCollisionGroup = function (name) {
            var index = this.collisionGroups.indexOf(name);
            if (index !== -1) {
                this.collisionGroups.splice(index, 1);
            }
        };
        /**
         * Get the center point of an actor
         */
        ActorImpl.prototype.getCenter = function () {
            return new Algebra_24.Vector(this.pos.x + this.getWidth() / 2 - this.anchor.x * this.getWidth(), this.pos.y + this.getHeight() / 2 - this.anchor.y * this.getHeight());
        };
        /**
         * Gets the calculated width of an actor, factoring in scale
         */
        ActorImpl.prototype.getWidth = function () {
            return this._width * this.getGlobalScale().x;
        };
        /**
         * Sets the width of an actor, factoring in the current scale
         */
        ActorImpl.prototype.setWidth = function (width) {
            this._width = width / this.scale.x;
        };
        /**
         * Gets the calculated height of an actor, factoring in scale
         */
        ActorImpl.prototype.getHeight = function () {
            return this._height * this.getGlobalScale().y;
        };
        /**
         * Sets the height of an actor, factoring in the current scale
         */
        ActorImpl.prototype.setHeight = function (height) {
            this._height = height / this.scale.y;
        };
        /**
         * Gets the left edge of the actor
         */
        ActorImpl.prototype.getLeft = function () {
            return this.getBounds().left;
        };
        /**
         * Gets the right edge of the actor
         */
        ActorImpl.prototype.getRight = function () {
            return this.getBounds().right;
        };
        /**
         * Gets the top edge of the actor
         */
        ActorImpl.prototype.getTop = function () {
            return this.getBounds().top;
        };
        /**
         * Gets the bottom edge of the actor
         */
        ActorImpl.prototype.getBottom = function () {
            return this.getBounds().bottom;
        };
        /**
         * Gets this actor's rotation taking into account any parent relationships
         *
         * @returns Rotation angle in radians
         */
        ActorImpl.prototype.getWorldRotation = function () {
            if (!this.parent) {
                return this.rotation;
            }
            return this.rotation + this.parent.getWorldRotation();
        };
        /**
         * Gets an actor's world position taking into account parent relationships, scaling, rotation, and translation
         *
         * @returns Position in world coordinates
         */
        ActorImpl.prototype.getWorldPos = function () {
            if (!this.parent) {
                return this.pos.clone();
            }
            // collect parents                  
            var parents = [];
            var root = this;
            parents.push(this);
            // find parents
            while (root.parent) {
                root = root.parent;
                parents.push(root);
            }
            // calculate position       
            var x = parents.reduceRight(function (px, p) {
                if (p.parent) {
                    return px + (p.pos.x * p.getGlobalScale().x);
                }
                return px + p.pos.x;
            }, 0);
            var y = parents.reduceRight(function (py, p) {
                if (p.parent) {
                    return py + (p.pos.y * p.getGlobalScale().y);
                }
                return py + p.pos.y;
            }, 0);
            // rotate around root anchor
            var ra = root.getWorldPos(); // 10, 10
            var r = this.getWorldRotation();
            return new Algebra_24.Vector(x, y).rotate(r, ra);
        };
        /**
         * Gets the global scale of the Actor
         */
        ActorImpl.prototype.getGlobalScale = function () {
            if (!this.parent) {
                return new Algebra_24.Vector(this.scale.x, this.scale.y);
            }
            var parentScale = this.parent.getGlobalScale();
            return new Algebra_24.Vector(this.scale.x * parentScale.x, this.scale.y * parentScale.y);
        };
        /**
         * Returns the actor's [[BoundingBox]] calculated for this instant in world space.
         */
        ActorImpl.prototype.getBounds = function () {
            // todo cache bounding box
            var anchor = this._getCalculatedAnchor();
            var pos = this.getWorldPos();
            return new BoundingBox_8.BoundingBox(pos.x - anchor.x, pos.y - anchor.y, pos.x + this.getWidth() - anchor.x, pos.y + this.getHeight() - anchor.y).rotate(this.rotation, pos);
        };
        /**
         * Returns the actor's [[BoundingBox]] relative to the actors position.
         */
        ActorImpl.prototype.getRelativeBounds = function () {
            // todo cache bounding box
            var anchor = this._getCalculatedAnchor();
            return new BoundingBox_8.BoundingBox(-anchor.x, -anchor.y, this.getWidth() - anchor.x, this.getHeight() - anchor.y).rotate(this.rotation);
        };
        /**
         * Tests whether the x/y specified are contained in the actor
         * @param x  X coordinate to test (in world coordinates)
         * @param y  Y coordinate to test (in world coordinates)
         * @param recurse checks whether the x/y are contained in any child actors (if they exist).
         */
        ActorImpl.prototype.contains = function (x, y, recurse) {
            if (recurse === void 0) { recurse = false; }
            var containment = this.getBounds().contains(new Algebra_24.Vector(x, y));
            if (recurse) {
                return containment || this.children.some(function (child) {
                    return child.contains(x, y, true);
                });
            }
            return containment;
        };
        /**
         * Returns the side of the collision based on the intersection
         * @param intersect The displacement vector returned by a collision
         */
        ActorImpl.prototype.getSideFromIntersect = function (intersect) {
            if (intersect) {
                if (Math.abs(intersect.x) > Math.abs(intersect.y)) {
                    if (intersect.x < 0) {
                        return Side_4.Side.Right;
                    }
                    return Side_4.Side.Left;
                }
                else {
                    if (intersect.y < 0) {
                        return Side_4.Side.Bottom;
                    }
                    return Side_4.Side.Top;
                }
            }
            return Side_4.Side.None;
        };
        /**
         * Test whether the actor has collided with another actor, returns the side of the current actor that collided.
         * @param actor The other actor to test
         */
        ActorImpl.prototype.collidesWithSide = function (actor) {
            var separationVector = this.collides(actor);
            if (!separationVector) {
                return Side_4.Side.None;
            }
            if (Math.abs(separationVector.x) > Math.abs(separationVector.y)) {
                if (this.pos.x < actor.pos.x) {
                    return Side_4.Side.Right;
                }
                else {
                    return Side_4.Side.Left;
                }
            }
            else {
                if (this.pos.y < actor.pos.y) {
                    return Side_4.Side.Bottom;
                }
                else {
                    return Side_4.Side.Top;
                }
            }
        };
        /**
         * Test whether the actor has collided with another actor, returns the intersection vector on collision. Returns
         * `null` when there is no collision;
         * @param actor The other actor to test
         */
        ActorImpl.prototype.collides = function (actor) {
            var bounds = this.getBounds();
            var otherBounds = actor.getBounds();
            var intersect = bounds.collides(otherBounds);
            return intersect;
        };
        /**
         * Register a handler to fire when this actor collides with another in a specified group
         * @param group The group name to listen for
         * @param func The callback to fire on collision with another actor from the group. The callback is passed the other actor.
         */
        ActorImpl.prototype.onCollidesWith = function (group, func) {
            if (!this._collisionHandlers[group]) {
                this._collisionHandlers[group] = [];
            }
            this._collisionHandlers[group].push(func);
        };
        ActorImpl.prototype.getCollisionHandlers = function () {
            return this._collisionHandlers;
        };
        /**
         * Removes all collision handlers for this group on this actor
         * @param group Group to remove all handlers for on this actor.
         */
        ActorImpl.prototype.removeCollidesWith = function (group) {
            this._collisionHandlers[group] = [];
        };
        /**
         * Returns true if the two actors are less than or equal to the distance specified from each other
         * @param actor     Actor to test
         * @param distance  Distance in pixels to test
         */
        ActorImpl.prototype.within = function (actor, distance) {
            return Math.sqrt(Math.pow(this.pos.x - actor.pos.x, 2) + Math.pow(this.pos.y - actor.pos.y, 2)) <= distance;
        };
        ActorImpl.prototype._getCalculatedAnchor = function () {
            return new Algebra_24.Vector(this.getWidth() * this.anchor.x, this.getHeight() * this.anchor.y);
        };
        ActorImpl.prototype._reapplyEffects = function (drawing) {
            drawing.removeEffect(this._opacityFx);
            drawing.addEffect(this._opacityFx);
        };
        /**
         * Perform euler integration at the specified time step
         */
        ActorImpl.prototype.integrate = function (delta) {
            // Update placements based on linear algebra
            var seconds = delta / 1000;
            var totalAcc = this.acc.clone();
            // Only active vanilla actors are affected by global acceleration
            if (this.collisionType === CollisionType.Active) {
                totalAcc.addEqual(Physics_13.Physics.acc);
            }
            this.vel.addEqual(totalAcc.scale(seconds));
            this.pos.addEqual(this.vel.scale(seconds)).addEqual(totalAcc.scale(0.5 * seconds * seconds));
            this.rx += this.torque * (1.0 / this.moi) * seconds;
            this.rotation += this.rx * seconds;
            this.scale.x += this.sx * delta / 1000;
            this.scale.y += this.sy * delta / 1000;
            // Update physics body
            this.body.update();
        };
        /**
         * Called by the Engine, updates the state of the actor
         * @param engine The reference to the current game engine
         * @param delta  The time elapsed since the last update in milliseconds
         */
        ActorImpl.prototype.update = function (engine, delta) {
            this._initialize(engine);
            this.emit('preupdate', new Events_14.PreUpdateEvent(engine, delta, this));
            // Update action queue
            this.actionQueue.update(delta);
            // Update color only opacity
            if (this.color) {
                this.color.a = this.opacity;
            }
            // calculate changing opacity
            if (this.previousOpacity !== this.opacity) {
                this.previousOpacity = this.opacity;
                this._opacityFx.opacity = this.opacity;
                this._effectsDirty = true;
            }
            // Capture old values before integration step updates them
            this.oldVel.setTo(this.vel.x, this.vel.y);
            this.oldPos.setTo(this.pos.x, this.pos.y);
            // Run Euler integration
            this.integrate(delta);
            // Update actor pipeline (movement, collision detection, event propagation, offscreen culling)
            for (var _i = 0, _a = this.traits; _i < _a.length; _i++) {
                var trait = _a[_i];
                trait.update(this, engine, delta);
            }
            // Update child actors
            for (var i = 0; i < this.children.length; i++) {
                this.children[i].update(engine, delta);
            }
            this.emit('postupdate', new Events_14.PostUpdateEvent(engine, delta, this));
        };
        /**
         * Called by the Engine, draws the actor to the screen
         * @param ctx   The rendering context
         * @param delta The time since the last draw in milliseconds
         */
        ActorImpl.prototype.draw = function (ctx, delta) {
            ctx.save();
            ctx.translate(this.pos.x, this.pos.y);
            ctx.rotate(this.rotation);
            ctx.scale(this.scale.x, this.scale.y);
            // translate canvas by anchor offset
            ctx.save();
            ctx.translate(-(this._width * this.anchor.x), -(this._height * this.anchor.y));
            this.emit('predraw', new Events_14.PreDrawEvent(ctx, delta, this));
            if (this.currentDrawing) {
                var drawing = this.currentDrawing;
                // See https://github.com/excaliburjs/Excalibur/pull/619 for discussion on this formula          
                var offsetX = (this._width - drawing.naturalWidth * drawing.scale.x) * this.anchor.x;
                var offsetY = (this._height - drawing.naturalHeight * drawing.scale.y) * this.anchor.y;
                if (this._effectsDirty) {
                    this._reapplyEffects(this.currentDrawing);
                    this._effectsDirty = false;
                }
                this.currentDrawing.draw(ctx, offsetX, offsetY);
            }
            else {
                if (this.color) {
                    ctx.fillStyle = this.color.toString();
                    ctx.fillRect(0, 0, this._width, this._height);
                }
            }
            ctx.restore();
            // Draw child actors
            for (var i = 0; i < this.children.length; i++) {
                if (this.children[i].visible) {
                    this.children[i].draw(ctx, delta);
                }
            }
            this.emit('postdraw', new Events_14.PostDrawEvent(ctx, delta, this));
            ctx.restore();
        };
        /**
         * Called by the Engine, draws the actors debugging to the screen
         * @param ctx The rendering context
         */
        /* istanbul ignore next */
        ActorImpl.prototype.debugDraw = function (ctx) {
            this.emit('predebugdraw', new Events_14.PreDebugDrawEvent(ctx, this));
            this.body.debugDraw(ctx);
            // Draw actor bounding box
            var bb = this.getBounds();
            bb.debugDraw(ctx);
            // Draw actor Id
            ctx.fillText('id: ' + this.id, bb.left + 3, bb.top + 10);
            // Draw actor anchor Vector
            ctx.fillStyle = Color_20.Color.Yellow.toString();
            ctx.beginPath();
            ctx.arc(this.getWorldPos().x, this.getWorldPos().y, 3, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fill();
            // Culling Box debug draw
            for (var j = 0; j < this.traits.length; j++) {
                if (this.traits[j] instanceof Traits.OffscreenCulling) {
                    this.traits[j].cullingBox.debugDraw(ctx);
                }
            }
            // Unit Circle debug draw
            ctx.strokeStyle = Color_20.Color.Yellow.toString();
            ctx.beginPath();
            var radius = Math.min(this.getWidth(), this.getHeight());
            ctx.arc(this.getWorldPos().x, this.getWorldPos().y, radius, 0, Math.PI * 2);
            ctx.closePath();
            ctx.stroke();
            var ticks = {
                '0 Pi': 0,
                'Pi/2': Math.PI / 2,
                'Pi': Math.PI,
                '3/2 Pi': 3 * Math.PI / 2
            };
            var oldFont = ctx.font;
            for (var tick in ticks) {
                ctx.fillStyle = Color_20.Color.Yellow.toString();
                ctx.font = '14px';
                ctx.textAlign = 'center';
                ctx.fillText(tick, this.getWorldPos().x + Math.cos(ticks[tick]) * (radius + 10), this.getWorldPos().y + Math.sin(ticks[tick]) * (radius + 10));
            }
            ctx.font = oldFont;
            // Draw child actors
            for (var i = 0; i < this.children.length; i++) {
                this.children[i].debugDraw(ctx);
            }
            this.emit('postdebugdraw', new Events_14.PostDebugDrawEvent(ctx, this));
        };
        return ActorImpl;
    }(Class_11.Class));
    /**
     * Indicates the next id to be set
     */
    ActorImpl.maxId = 0;
    exports.ActorImpl = ActorImpl;
    /**
     * The most important primitive in Excalibur is an `Actor`. Anything that
     * can move on the screen, collide with another `Actor`, respond to events,
     * or interact with the current scene, must be an actor. An `Actor` **must**
     * be part of a [[Scene]] for it to be drawn to the screen.
     *
     * [[include:Actors.md]]
     *
     *
     * [[include:Constructors.md]]
     *
     */
    var Actor = (function (_super) {
        __extends(Actor, _super);
        function Actor(xOrConfig, y, width, height, color) {
            return _super.call(this, xOrConfig, y, width, height, color) || this;
        }
        return Actor;
    }(Configurable_8.Configurable(ActorImpl)));
    exports.Actor = Actor;
    /**
     * An enum that describes the types of collisions actors can participate in
     */
    var CollisionType;
    (function (CollisionType) {
        /**
         * Actors with the `PreventCollision` setting do not participate in any
         * collisions and do not raise collision events.
         */
        CollisionType[CollisionType["PreventCollision"] = 0] = "PreventCollision";
        /**
         * Actors with the `Passive` setting only raise collision events, but are not
         * influenced or moved by other actors and do not influence or move other actors.
         */
        CollisionType[CollisionType["Passive"] = 1] = "Passive";
        /**
         * Actors with the `Active` setting raise collision events and participate
         * in collisions with other actors and will be push or moved by actors sharing
         * the `Active` or `Fixed` setting.
         */
        CollisionType[CollisionType["Active"] = 2] = "Active";
        /**
         * Actors with the `Fixed` setting raise collision events and participate in
         * collisions with other actors. Actors with the `Fixed` setting will not be
         * pushed or moved by other actors sharing the `Fixed`. Think of Fixed
         * actors as "immovable/onstoppable" objects. If two `Fixed` actors meet they will
         * not be pushed or moved by each other, they will not interact except to throw
         * collision events.
         */
        CollisionType[CollisionType["Fixed"] = 3] = "Fixed";
    })(CollisionType = exports.CollisionType || (exports.CollisionType = {}));
});
define("Actions/Action", ["require", "exports", "Actions/RotationType", "Algebra", "Util/Log", "Util/Util"], function (require, exports, RotationType_2, Algebra_25, Log_17, Util) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var EaseTo = (function () {
        function EaseTo(actor, x, y, duration, easingFcn) {
            this.actor = actor;
            this.easingFcn = easingFcn;
            this._currentLerpTime = 0;
            this._lerpDuration = 1 * 1000; // 1 second
            this._lerpStart = new Algebra_25.Vector(0, 0);
            this._lerpEnd = new Algebra_25.Vector(0, 0);
            this._initialized = false;
            this._stopped = false;
            this._distance = 0;
            this._lerpDuration = duration;
            this._lerpEnd = new Algebra_25.Vector(x, y);
        }
        EaseTo.prototype._initialize = function () {
            this._lerpStart = new Algebra_25.Vector(this.actor.pos.x, this.actor.pos.y);
            this._currentLerpTime = 0;
            this._distance = this._lerpStart.distance(this._lerpEnd);
        };
        EaseTo.prototype.update = function (delta) {
            if (!this._initialized) {
                this._initialize();
                this._initialized = true;
            }
            var newX = this.actor.pos.x;
            var newY = this.actor.pos.y;
            if (this._currentLerpTime < this._lerpDuration) {
                if (this._lerpEnd.x < this._lerpStart.x) {
                    newX = this._lerpStart.x - (this.easingFcn(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x);
                }
                else {
                    newX = this.easingFcn(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration);
                }
                if (this._lerpEnd.y < this._lerpStart.y) {
                    newY = this._lerpStart.y - (this.easingFcn(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y);
                }
                else {
                    newY = this.easingFcn(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);
                }
                this.actor.pos.x = newX;
                this.actor.pos.y = newY;
                this._currentLerpTime += delta;
            }
            else {
                this.actor.pos.x = this._lerpEnd.x;
                this.actor.pos.y = this._lerpEnd.y;
                //this._lerpStart = null;
                //this._lerpEnd = null;
                //this._currentLerpTime = 0;
            }
        };
        EaseTo.prototype.isComplete = function (actor) {
            return this._stopped || (new Algebra_25.Vector(actor.pos.x, actor.pos.y)).distance(this._lerpStart) >= this._distance;
        };
        EaseTo.prototype.reset = function () {
            this._initialized = false;
        };
        EaseTo.prototype.stop = function () {
            this._stopped = true;
        };
        return EaseTo;
    }());
    exports.EaseTo = EaseTo;
    var MoveTo = (function () {
        function MoveTo(actor, destx, desty, speed) {
            this._started = false;
            this._stopped = false;
            this._actor = actor;
            this._end = new Algebra_25.Vector(destx, desty);
            this._speed = speed;
        }
        MoveTo.prototype.update = function (_delta) {
            if (!this._started) {
                this._started = true;
                this._start = new Algebra_25.Vector(this._actor.pos.x, this._actor.pos.y);
                this._distance = this._start.distance(this._end);
                this._dir = this._end.sub(this._start).normalize();
            }
            var m = this._dir.scale(this._speed);
            this._actor.vel.x = m.x;
            this._actor.vel.y = m.y;
            if (this.isComplete(this._actor)) {
                this._actor.pos.x = this._end.x;
                this._actor.pos.y = this._end.y;
                this._actor.vel.y = 0;
                this._actor.vel.x = 0;
            }
        };
        MoveTo.prototype.isComplete = function (actor) {
            return this._stopped || (new Algebra_25.Vector(actor.pos.x, actor.pos.y)).distance(this._start) >= this._distance;
        };
        MoveTo.prototype.stop = function () {
            this._actor.vel.y = 0;
            this._actor.vel.x = 0;
            this._stopped = true;
        };
        MoveTo.prototype.reset = function () {
            this._started = false;
        };
        return MoveTo;
    }());
    exports.MoveTo = MoveTo;
    var MoveBy = (function () {
        function MoveBy(actor, destx, desty, time) {
            this._started = false;
            this._stopped = false;
            this._actor = actor;
            this._end = new Algebra_25.Vector(destx, desty);
            if (time <= 0) {
                Log_17.Logger.getInstance().error('Attempted to moveBy time less than or equal to zero : ' + time);
                throw new Error('Cannot move in time <= 0');
            }
            this._time = time;
        }
        MoveBy.prototype.update = function (_delta) {
            if (!this._started) {
                this._started = true;
                this._start = new Algebra_25.Vector(this._actor.pos.x, this._actor.pos.y);
                this._distance = this._start.distance(this._end);
                this._dir = this._end.sub(this._start).normalize();
                this._speed = this._distance / (this._time / 1000);
            }
            var m = this._dir.scale(this._speed);
            this._actor.vel.x = m.x;
            this._actor.vel.y = m.y;
            if (this.isComplete(this._actor)) {
                this._actor.pos.x = this._end.x;
                this._actor.pos.y = this._end.y;
                this._actor.vel.y = 0;
                this._actor.vel.x = 0;
            }
        };
        MoveBy.prototype.isComplete = function (actor) {
            return this._stopped || (new Algebra_25.Vector(actor.pos.x, actor.pos.y)).distance(this._start) >= this._distance;
        };
        MoveBy.prototype.stop = function () {
            this._actor.vel.y = 0;
            this._actor.vel.x = 0;
            this._stopped = true;
        };
        MoveBy.prototype.reset = function () {
            this._started = false;
        };
        return MoveBy;
    }());
    exports.MoveBy = MoveBy;
    var Follow = (function () {
        function Follow(actor, actorToFollow, followDistance) {
            this._started = false;
            this._stopped = false;
            this._actor = actor;
            this._actorToFollow = actorToFollow;
            this._current = new Algebra_25.Vector(this._actor.pos.x, this._actor.pos.y);
            this._end = new Algebra_25.Vector(actorToFollow.pos.x, actorToFollow.pos.y);
            this._maximumDistance = (followDistance !== undefined) ? followDistance : this._current.distance(this._end);
            this._speed = 0;
        }
        Follow.prototype.update = function (_delta) {
            if (!this._started) {
                this._started = true;
                this._distanceBetween = this._current.distance(this._end);
                this._dir = this._end.sub(this._current).normalize();
            }
            var actorToFollowSpeed = Math.sqrt(Math.pow(this._actorToFollow.vel.x, 2) + Math.pow(this._actorToFollow.vel.y, 2));
            if (actorToFollowSpeed !== 0) {
                this._speed = actorToFollowSpeed;
            }
            this._current.x = this._actor.pos.x;
            this._current.y = this._actor.pos.y;
            this._end.x = this._actorToFollow.pos.x;
            this._end.y = this._actorToFollow.pos.y;
            this._distanceBetween = this._current.distance(this._end);
            this._dir = this._end.sub(this._current).normalize();
            if (this._distanceBetween >= this._maximumDistance) {
                var m = this._dir.scale(this._speed);
                this._actor.vel.x = m.x;
                this._actor.vel.y = m.y;
            }
            else {
                this._actor.vel.x = 0;
                this._actor.vel.y = 0;
            }
            if (this.isComplete()) {
                // TODO this should never occur
                this._actor.pos.x = this._end.x;
                this._actor.pos.y = this._end.y;
                this._actor.vel.y = 0;
                this._actor.vel.x = 0;
            }
        };
        Follow.prototype.stop = function () {
            this._actor.vel.y = 0;
            this._actor.vel.x = 0;
            this._stopped = true;
        };
        Follow.prototype.isComplete = function () {
            // the actor following should never stop unless specified to do so
            return this._stopped;
        };
        Follow.prototype.reset = function () {
            this._started = false;
        };
        return Follow;
    }());
    exports.Follow = Follow;
    var Meet = (function () {
        function Meet(actor, actorToMeet, speed) {
            this._started = false;
            this._stopped = false;
            this._speedWasSpecified = false;
            this._actor = actor;
            this._actorToMeet = actorToMeet;
            this._current = new Algebra_25.Vector(this._actor.pos.x, this._actor.pos.y);
            this._end = new Algebra_25.Vector(actorToMeet.pos.x, actorToMeet.pos.y);
            this._speed = speed || 0;
            if (speed !== undefined) {
                this._speedWasSpecified = true;
            }
        }
        Meet.prototype.update = function (_delta) {
            if (!this._started) {
                this._started = true;
                this._distanceBetween = this._current.distance(this._end);
                this._dir = this._end.sub(this._current).normalize();
            }
            var actorToMeetSpeed = Math.sqrt(Math.pow(this._actorToMeet.vel.x, 2) + Math.pow(this._actorToMeet.vel.y, 2));
            if ((actorToMeetSpeed !== 0) && (!this._speedWasSpecified)) {
                this._speed = actorToMeetSpeed;
            }
            this._current.x = this._actor.pos.x;
            this._current.y = this._actor.pos.y;
            this._end.x = this._actorToMeet.pos.x;
            this._end.y = this._actorToMeet.pos.y;
            this._distanceBetween = this._current.distance(this._end);
            this._dir = this._end.sub(this._current).normalize();
            var m = this._dir.scale(this._speed);
            this._actor.vel.x = m.x;
            this._actor.vel.y = m.y;
            if (this.isComplete()) {
                this._actor.pos.x = this._end.x;
                this._actor.pos.y = this._end.y;
                this._actor.vel.y = 0;
                this._actor.vel.x = 0;
            }
        };
        Meet.prototype.isComplete = function () {
            return this._stopped || (this._distanceBetween <= 1);
        };
        Meet.prototype.stop = function () {
            this._actor.vel.y = 0;
            this._actor.vel.x = 0;
            this._stopped = true;
        };
        Meet.prototype.reset = function () {
            this._started = false;
        };
        return Meet;
    }());
    exports.Meet = Meet;
    var RotateTo = (function () {
        function RotateTo(actor, angleRadians, speed, rotationType) {
            this._started = false;
            this._stopped = false;
            this._actor = actor;
            this._end = angleRadians;
            this._speed = speed;
            this._rotationType = rotationType || RotationType_2.RotationType.ShortestPath;
        }
        RotateTo.prototype.update = function (_delta) {
            if (!this._started) {
                this._started = true;
                this._start = this._actor.rotation;
                var distance1 = Math.abs(this._end - this._start);
                var distance2 = Util.TwoPI - distance1;
                if (distance1 > distance2) {
                    this._shortDistance = distance2;
                    this._longDistance = distance1;
                }
                else {
                    this._shortDistance = distance1;
                    this._longDistance = distance2;
                }
                this._shortestPathIsPositive = (this._start - this._end + Util.TwoPI) % Util.TwoPI >= Math.PI;
                switch (this._rotationType) {
                    case RotationType_2.RotationType.ShortestPath:
                        this._distance = this._shortDistance;
                        if (this._shortestPathIsPositive) {
                            this._direction = 1;
                        }
                        else {
                            this._direction = -1;
                        }
                        break;
                    case RotationType_2.RotationType.LongestPath:
                        this._distance = this._longDistance;
                        if (this._shortestPathIsPositive) {
                            this._direction = -1;
                        }
                        else {
                            this._direction = 1;
                        }
                        break;
                    case RotationType_2.RotationType.Clockwise:
                        this._direction = 1;
                        if (this._shortestPathIsPositive) {
                            this._distance = this._shortDistance;
                        }
                        else {
                            this._distance = this._longDistance;
                        }
                        break;
                    case RotationType_2.RotationType.CounterClockwise:
                        this._direction = -1;
                        if (!this._shortestPathIsPositive) {
                            this._distance = this._shortDistance;
                        }
                        else {
                            this._distance = this._longDistance;
                        }
                        break;
                }
            }
            this._actor.rx = this._direction * this._speed;
            if (this.isComplete()) {
                this._actor.rotation = this._end;
                this._actor.rx = 0;
                this._stopped = true;
            }
        };
        RotateTo.prototype.isComplete = function () {
            var distanceTravelled = Math.abs(this._actor.rotation - this._start);
            return this._stopped || (distanceTravelled >= Math.abs(this._distance));
        };
        RotateTo.prototype.stop = function () {
            this._actor.rx = 0;
            this._stopped = true;
        };
        RotateTo.prototype.reset = function () {
            this._started = false;
        };
        return RotateTo;
    }());
    exports.RotateTo = RotateTo;
    var RotateBy = (function () {
        function RotateBy(actor, angleRadians, time, rotationType) {
            this._started = false;
            this._stopped = false;
            this._actor = actor;
            this._end = angleRadians;
            this._time = time;
            this._rotationType = rotationType || RotationType_2.RotationType.ShortestPath;
        }
        RotateBy.prototype.update = function (_delta) {
            if (!this._started) {
                this._started = true;
                this._start = this._actor.rotation;
                var distance1 = Math.abs(this._end - this._start);
                var distance2 = Util.TwoPI - distance1;
                if (distance1 > distance2) {
                    this._shortDistance = distance2;
                    this._longDistance = distance1;
                }
                else {
                    this._shortDistance = distance1;
                    this._longDistance = distance2;
                }
                this._shortestPathIsPositive = (this._start - this._end + Util.TwoPI) % Util.TwoPI >= Math.PI;
                switch (this._rotationType) {
                    case RotationType_2.RotationType.ShortestPath:
                        this._distance = this._shortDistance;
                        if (this._shortestPathIsPositive) {
                            this._direction = 1;
                        }
                        else {
                            this._direction = -1;
                        }
                        break;
                    case RotationType_2.RotationType.LongestPath:
                        this._distance = this._longDistance;
                        if (this._shortestPathIsPositive) {
                            this._direction = -1;
                        }
                        else {
                            this._direction = 1;
                        }
                        break;
                    case RotationType_2.RotationType.Clockwise:
                        this._direction = 1;
                        if (this._shortDistance >= 0) {
                            this._distance = this._shortDistance;
                        }
                        else {
                            this._distance = this._longDistance;
                        }
                        break;
                    case RotationType_2.RotationType.CounterClockwise:
                        this._direction = -1;
                        if (this._shortDistance <= 0) {
                            this._distance = this._shortDistance;
                        }
                        else {
                            this._distance = this._longDistance;
                        }
                        break;
                }
                this._speed = Math.abs(this._distance / this._time * 1000);
            }
            this._actor.rx = this._direction * this._speed;
            if (this.isComplete()) {
                this._actor.rotation = this._end;
                this._actor.rx = 0;
                this._stopped = true;
            }
        };
        RotateBy.prototype.isComplete = function () {
            var distanceTravelled = Math.abs(this._actor.rotation - this._start);
            return this._stopped || (distanceTravelled >= Math.abs(this._distance));
        };
        RotateBy.prototype.stop = function () {
            this._actor.rx = 0;
            this._stopped = true;
        };
        RotateBy.prototype.reset = function () {
            this._started = false;
        };
        return RotateBy;
    }());
    exports.RotateBy = RotateBy;
    var ScaleTo = (function () {
        function ScaleTo(actor, scaleX, scaleY, speedX, speedY) {
            this._started = false;
            this._stopped = false;
            this._actor = actor;
            this._endX = scaleX;
            this._endY = scaleY;
            this._speedX = speedX;
            this._speedY = speedY;
        }
        ScaleTo.prototype.update = function (_delta) {
            if (!this._started) {
                this._started = true;
                this._startX = this._actor.scale.x;
                this._startY = this._actor.scale.y;
                this._distanceX = Math.abs(this._endX - this._startX);
                this._distanceY = Math.abs(this._endY - this._startY);
            }
            if (!(Math.abs(this._actor.scale.x - this._startX) >= this._distanceX)) {
                var directionX = this._endY < this._startY ? -1 : 1;
                this._actor.sx = this._speedX * directionX;
            }
            else {
                this._actor.sx = 0;
            }
            if (!(Math.abs(this._actor.scale.y - this._startY) >= this._distanceY)) {
                var directionY = this._endY < this._startY ? -1 : 1;
                this._actor.sy = this._speedY * directionY;
            }
            else {
                this._actor.sy = 0;
            }
            if (this.isComplete()) {
                this._actor.scale.x = this._endX;
                this._actor.scale.y = this._endY;
                this._actor.sx = 0;
                this._actor.sy = 0;
            }
        };
        ScaleTo.prototype.isComplete = function () {
            return this._stopped || ((Math.abs(this._actor.scale.y - this._startX) >= this._distanceX) &&
                (Math.abs(this._actor.scale.y - this._startY) >= this._distanceY));
        };
        ScaleTo.prototype.stop = function () {
            this._actor.sx = 0;
            this._actor.sy = 0;
            this._stopped = true;
        };
        ScaleTo.prototype.reset = function () {
            this._started = false;
        };
        return ScaleTo;
    }());
    exports.ScaleTo = ScaleTo;
    var ScaleBy = (function () {
        function ScaleBy(actor, scaleX, scaleY, time) {
            this._started = false;
            this._stopped = false;
            this._actor = actor;
            this._endX = scaleX;
            this._endY = scaleY;
            this._speedX = (this._endX - this._actor.scale.x) / time * 1000;
            this._speedY = (this._endY - this._actor.scale.y) / time * 1000;
        }
        ScaleBy.prototype.update = function (_delta) {
            if (!this._started) {
                this._started = true;
                this._startX = this._actor.scale.x;
                this._startY = this._actor.scale.y;
                this._distanceX = Math.abs(this._endX - this._startX);
                this._distanceY = Math.abs(this._endY - this._startY);
            }
            var directionX = this._endX < this._startX ? -1 : 1;
            var directionY = this._endY < this._startY ? -1 : 1;
            this._actor.sx = this._speedX * directionX;
            this._actor.sy = this._speedY * directionY;
            if (this.isComplete()) {
                this._actor.scale.x = this._endX;
                this._actor.scale.y = this._endY;
                this._actor.sx = 0;
                this._actor.sy = 0;
            }
        };
        ScaleBy.prototype.isComplete = function () {
            return this._stopped || ((Math.abs(this._actor.scale.x - this._startX) >= this._distanceX) &&
                (Math.abs(this._actor.scale.y - this._startY) >= this._distanceY));
        };
        ScaleBy.prototype.stop = function () {
            this._actor.sx = 0;
            this._actor.sy = 0;
            this._stopped = true;
        };
        ScaleBy.prototype.reset = function () {
            this._started = false;
        };
        return ScaleBy;
    }());
    exports.ScaleBy = ScaleBy;
    var Delay = (function () {
        function Delay(actor, delay) {
            this._elapsedTime = 0;
            this._started = false;
            this._stopped = false;
            this._actor = actor;
            this._delay = delay;
        }
        Delay.prototype.update = function (delta) {
            if (!this._started) {
                this._started = true;
            }
            this.x = this._actor.pos.x;
            this.y = this._actor.pos.y;
            this._elapsedTime += delta;
        };
        Delay.prototype.isComplete = function () {
            return this._stopped || (this._elapsedTime >= this._delay);
        };
        Delay.prototype.stop = function () {
            this._stopped = true;
        };
        Delay.prototype.reset = function () {
            this._elapsedTime = 0;
            this._started = false;
        };
        return Delay;
    }());
    exports.Delay = Delay;
    var Blink = (function () {
        function Blink(actor, timeVisible, timeNotVisible, numBlinks) {
            if (numBlinks === void 0) { numBlinks = 1; }
            this._timeVisible = 0;
            this._timeNotVisible = 0;
            this._elapsedTime = 0;
            this._totalTime = 0;
            this._stopped = false;
            this._started = false;
            this._actor = actor;
            this._timeVisible = timeVisible;
            this._timeNotVisible = timeNotVisible;
            this._duration = (timeVisible + timeNotVisible) * numBlinks;
        }
        Blink.prototype.update = function (delta) {
            if (!this._started) {
                this._started = true;
            }
            this._elapsedTime += delta;
            this._totalTime += delta;
            if (this._actor.visible && this._elapsedTime >= this._timeVisible) {
                this._actor.visible = false;
                this._elapsedTime = 0;
            }
            if (!this._actor.visible && this._elapsedTime >= this._timeNotVisible) {
                this._actor.visible = true;
                this._elapsedTime = 0;
            }
            if (this.isComplete()) {
                this._actor.visible = true;
            }
        };
        Blink.prototype.isComplete = function () {
            return this._stopped || (this._totalTime >= this._duration);
        };
        Blink.prototype.stop = function () {
            this._actor.visible = true;
            this._stopped = true;
        };
        Blink.prototype.reset = function () {
            this._started = false;
            this._elapsedTime = 0;
            this._totalTime = 0;
        };
        return Blink;
    }());
    exports.Blink = Blink;
    var Fade = (function () {
        function Fade(actor, endOpacity, speed) {
            this._multiplier = 1;
            this._started = false;
            this._stopped = false;
            this._actor = actor;
            this._endOpacity = endOpacity;
            this._speed = speed;
        }
        Fade.prototype.update = function (delta) {
            if (!this._started) {
                this._started = true;
                // determine direction when we start
                if (this._endOpacity < this._actor.opacity) {
                    this._multiplier = -1;
                }
                else {
                    this._multiplier = 1;
                }
            }
            if (this._speed > 0) {
                this._actor.opacity += this._multiplier * (Math.abs(this._actor.opacity - this._endOpacity) * delta) / this._speed;
            }
            this._speed -= delta;
            if (this.isComplete()) {
                this._actor.opacity = this._endOpacity;
            }
            Log_17.Logger.getInstance().debug('[Action fade] Actor opacity:', this._actor.opacity);
        };
        Fade.prototype.isComplete = function () {
            return this._stopped || (Math.abs(this._actor.opacity - this._endOpacity) < 0.05);
        };
        Fade.prototype.stop = function () {
            this._stopped = true;
        };
        Fade.prototype.reset = function () {
            this._started = false;
        };
        return Fade;
    }());
    exports.Fade = Fade;
    var Die = (function () {
        function Die(actor) {
            this._stopped = false;
            this._actor = actor;
        }
        Die.prototype.update = function (_delta) {
            this._actor.actionQueue.clearActions();
            this._actor.kill();
            this._stopped = true;
        };
        Die.prototype.isComplete = function () {
            return this._stopped;
        };
        Die.prototype.stop = function () { return; };
        Die.prototype.reset = function () { return; };
        return Die;
    }());
    exports.Die = Die;
    var CallMethod = (function () {
        function CallMethod(actor, method) {
            this._method = null;
            this._actor = null;
            this._hasBeenCalled = false;
            this._actor = actor;
            this._method = method;
        }
        CallMethod.prototype.update = function (_delta) {
            this._method.call(this._actor);
            this._hasBeenCalled = true;
        };
        CallMethod.prototype.isComplete = function () {
            return this._hasBeenCalled;
        };
        CallMethod.prototype.reset = function () {
            this._hasBeenCalled = false;
        };
        CallMethod.prototype.stop = function () {
            this._hasBeenCalled = true;
        };
        return CallMethod;
    }());
    exports.CallMethod = CallMethod;
    var Repeat = (function () {
        function Repeat(actor, repeat, actions) {
            this._stopped = false;
            this._actor = actor;
            this._actionQueue = new ActionQueue(actor);
            this._repeat = repeat;
            this._originalRepeat = repeat;
            var i = 0, len = actions.length;
            for (i; i < len; i++) {
                actions[i].reset();
                this._actionQueue.add(actions[i]);
            }
            ;
        }
        Repeat.prototype.update = function (delta) {
            this.x = this._actor.pos.x;
            this.y = this._actor.pos.y;
            if (!this._actionQueue.hasNext()) {
                this._actionQueue.reset();
                this._repeat--;
            }
            this._actionQueue.update(delta);
        };
        Repeat.prototype.isComplete = function () {
            return this._stopped || (this._repeat <= 0);
        };
        Repeat.prototype.stop = function () {
            this._stopped = true;
        };
        Repeat.prototype.reset = function () {
            this._repeat = this._originalRepeat;
        };
        return Repeat;
    }());
    exports.Repeat = Repeat;
    var RepeatForever = (function () {
        function RepeatForever(actor, actions) {
            this._stopped = false;
            this._actor = actor;
            this._actionQueue = new ActionQueue(actor);
            var i = 0, len = actions.length;
            for (i; i < len; i++) {
                actions[i].reset();
                this._actionQueue.add(actions[i]);
            }
            ;
        }
        RepeatForever.prototype.update = function (delta) {
            this.x = this._actor.pos.x;
            this.y = this._actor.pos.y;
            if (this._stopped) {
                return;
            }
            if (!this._actionQueue.hasNext()) {
                this._actionQueue.reset();
            }
            this._actionQueue.update(delta);
        };
        RepeatForever.prototype.isComplete = function () {
            return this._stopped;
        };
        RepeatForever.prototype.stop = function () {
            this._stopped = true;
            this._actionQueue.clearActions();
        };
        RepeatForever.prototype.reset = function () { return; };
        return RepeatForever;
    }());
    exports.RepeatForever = RepeatForever;
    /**
     * Action Queues
     *
     * Action queues are part of the [[ActionContext|Action API]] and
     * store the list of actions to be executed for an [[Actor]].
     *
     * Actors implement [[Actor.actions]] which can be manipulated by
     * advanced users to adjust the actions currently being executed in the
     * queue.
     */
    var ActionQueue = (function () {
        function ActionQueue(actor) {
            this._actions = [];
            this._completedActions = [];
            this._actor = actor;
        }
        ActionQueue.prototype.add = function (action) {
            this._actions.push(action);
        };
        ActionQueue.prototype.remove = function (action) {
            var index = this._actions.indexOf(action);
            this._actions.splice(index, 1);
        };
        ActionQueue.prototype.clearActions = function () {
            this._actions.length = 0;
            this._completedActions.length = 0;
            if (this._currentAction) {
                this._currentAction.stop();
            }
        };
        ActionQueue.prototype.getActions = function () {
            return this._actions.concat(this._completedActions);
        };
        ActionQueue.prototype.hasNext = function () {
            return this._actions.length > 0;
        };
        ActionQueue.prototype.reset = function () {
            this._actions = this.getActions();
            var i = 0, len = this._actions.length;
            for (i; i < len; i++) {
                this._actions[i].reset();
            }
            this._completedActions = [];
        };
        ActionQueue.prototype.update = function (delta) {
            if (this._actions.length > 0) {
                this._currentAction = this._actions[0];
                this._currentAction.update(delta);
                if (this._currentAction.isComplete(this._actor)) {
                    this._completedActions.push(this._actions.shift());
                }
            }
        };
        return ActionQueue;
    }());
    exports.ActionQueue = ActionQueue;
});
/* istanbul ignore next */
if (typeof window === 'undefined') {
    window = { audioContext: function () { return; } };
}
/* istanbul ignore next */
if (typeof window !== 'undefined' && !window.requestAnimationFrame) {
    window.requestAnimationFrame =
        window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            function (callback) { window.setInterval(callback, 1000 / 60); };
}
/* istanbul ignore next */
if (typeof window !== 'undefined' && !window.cancelAnimationFrame) {
    window.cancelAnimationFrame =
        window.webkitCancelAnimationFrame ||
            window.mozCancelAnimationFrame ||
            function () { return; };
}
/* istanbul ignore next */
if (typeof window !== 'undefined' && !window.AudioContext) {
    window.AudioContext = window.AudioContext ||
        window.webkitAudioContext ||
        window.mozAudioContext ||
        window.msAudioContext ||
        window.oAudioContext;
}
if (typeof window !== 'undefined' && !window.devicePixelRatio) {
    window.devicePixelRatio = window.devicePixelRatio || 1;
}
// Polyfill from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
// Production steps of ECMA-262, Edition 5, 15.4.4.18
// Reference: http://es5.github.io/#x15.4.4.18
/* istanbul ignore next */
if (!Array.prototype.forEach) {
    Array.prototype.forEach = function (callback, thisArg) {
        var T, k;
        if (this == null) {
            throw new TypeError('this is null or not defined');
        }
        // 1. Let O be the result of calling ToObject passing the |this| value as the argument. 
        var O = Object(this);
        // 2. Let lenValue be the result of calling the Get internal method of O with the argument "length".
        // 3. Let len be ToUint32(lenValue).
        var len = O.length >>> 0;
        // 4. If IsCallable(callback) is false, throw a TypeError exception.
        // See: http://es5.github.com/#x9.11
        if (typeof callback !== 'function') {
            throw new TypeError(callback + ' is not a function');
        }
        // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
        if (arguments.length > 1) {
            T = thisArg;
        }
        // 6. Let k be 0
        k = 0;
        // 7. Repeat, while k < len
        while (k < len) {
            var kValue;
            // a. Let Pk be ToString(k).
            //   This is implicit for LHS operands of the in operator
            // b. Let kPresent be the result of calling the HasProperty internal method of O with argument Pk.
            //   This step can be combined with c
            // c. If kPresent is true, then
            if (k in O) {
                // i. Let kValue be the result of calling the Get internal method of O with argument Pk.
                kValue = O[k];
                // ii. Call the Call internal method of callback with T as the this value and
                // argument list containing kValue, k, and O.
                callback.call(T, kValue, k, O);
            }
            // d. Increase k by 1.
            k++;
        }
        // 8. return undefined
    };
}
// Polyfill from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some
/* istanbul ignore next */
if (!Array.prototype.some) {
    Array.prototype.some = function (fun /*, thisArg */) {
        'use strict';
        if (this === void 0 || this === null) {
            throw new TypeError();
        }
        var t = Object(this);
        var len = t.length >>> 0;
        if (typeof fun !== 'function') {
            throw new TypeError();
        }
        var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
        for (var i = 0; i < len; i++) {
            if (i in t && fun.call(thisArg, t[i], i, t)) {
                return true;
            }
        }
        return false;
    };
}
// Polyfill from  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Polyfill
/* istanbul ignore next */
if (!Function.prototype.bind) {
    Function.prototype.bind = function (oThis) {
        if (typeof this !== 'function') {
            // closest thing possible to the ECMAScript 5
            // internal IsCallable function
            throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
        }
        var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function () { return; }, fBound = function () {
            return fToBind.apply(this instanceof fNOP && oThis
                ? this
                : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));
        };
        fNOP.prototype = this.prototype;
        fBound.prototype = new fNOP();
        return fBound;
    };
}
    //The modules for your project will be inlined above
    //this snippet. Ask almond to synchronously require the
    //module value for 'main' here and return it as the
    //value to use for the public API for the built file.
    return require('Index');
}));
//# sourceMappingURL=excalibur.js.map

/***/ }),

/***/ "./src/actors/obstacles/pesticide.ts":
/*!*******************************************!*\
  !*** ./src/actors/obstacles/pesticide.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ex = __webpack_require__(/*! excalibur */ "./node_modules/excalibur/dist/excalibur.js");
var resource_1 = __webpack_require__(/*! ../../resource */ "./src/resource.ts");
var gamesettings_1 = __webpack_require__(/*! ../../gamesettings */ "./src/gamesettings.ts");
var pestSprites = [resource_1.Resource.Rndp, resource_1.Resource.pesticide1, resource_1.Resource.pesticide2];
var Pesticide = /** @class */ (function (_super) {
    __extends(Pesticide, _super);
    function Pesticide(xi, yi, ySpace, scene) {
        var _this = _super.call(this) || this;
        _this.x = xi;
        _this.setWidth(gamesettings_1.GameSettings.PEST_WIDTH);
        _this.setHeight(ySpace + 2 * gamesettings_1.GameSettings.PEST_HEIGHT);
        _this.topPart = new ex.Actor();
        var topSprite = new ex.Sprite(pestSprites[Math.floor(Math.random() * pestSprites.length)], 0, 0, gamesettings_1.GameSettings.PEST_WIDTH, gamesettings_1.GameSettings.PEST_HEIGHT);
        topSprite.flipVertical = true;
        _this.topPart.addDrawing(topSprite);
        _this.topPart.x = 0;
        _this.topPart.y = yi - (gamesettings_1.GameSettings.PEST_HEIGHT + ySpace) / 2;
        _this.topPart.setWidth(gamesettings_1.GameSettings.PEST_WIDTH);
        _this.topPart.setHeight(gamesettings_1.GameSettings.PEST_HEIGHT);
        _this.add(_this.topPart);
        _this.bottomPart = new ex.Actor();
        var bottomSprite = new ex.Sprite(pestSprites[Math.floor(Math.random() * pestSprites.length)], 0, 0, gamesettings_1.GameSettings.PEST_WIDTH, gamesettings_1.GameSettings.PEST_HEIGHT);
        //bottomSprite.flipVertical = false;
        _this.bottomPart.addDrawing(bottomSprite);
        _this.bottomPart.x = 0;
        _this.bottomPart.y = yi + (gamesettings_1.GameSettings.PEST_HEIGHT + ySpace) / 2;
        _this.bottomPart.setWidth(gamesettings_1.GameSettings.PEST_WIDTH);
        _this.bottomPart.setHeight(gamesettings_1.GameSettings.PEST_HEIGHT);
        _this.add(_this.bottomPart);
        _this.gameScene = scene;
        _this.passed = false;
        return _this;
    }
    Pesticide.prototype.onInitialize = function (engine) {
        // do stuff
    };
    Pesticide.prototype.update = function (engine, delta) {
        _super.prototype.update.call(this, engine, delta); // call base update logic
        if (this.gameScene.gameOver || !this.gameScene.gameStarted)
            return;
        this.x -= gamesettings_1.GameSettings.HSPEED * delta / 1000;
        if (this.topPart.collides(this.gameScene.player) != null || this.bottomPart.collides(this.gameScene.player) != null)
            this.gameScene.setGameOver();
        if (this.x < gamesettings_1.GameSettings.PEST_WIDTH / 2) {
            if (!this.passed) {
                this.passed = true;
                this.gameScene.score++;
            }
            if (this.x < -gamesettings_1.GameSettings.PEST_WIDTH / 2) {
                this.kill();
            }
        }
    };
    return Pesticide;
}(ex.Actor));
exports.Pesticide = Pesticide;


/***/ }),

/***/ "./src/actors/player/player.ts":
/*!*************************************!*\
  !*** ./src/actors/player/player.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ex = __webpack_require__(/*! excalibur */ "./node_modules/excalibur/dist/excalibur.js");
var resource_1 = __webpack_require__(/*! ../../resource */ "./src/resource.ts");
var gamesettings_1 = __webpack_require__(/*! ../../gamesettings */ "./src/gamesettings.ts");
var Player = /** @class */ (function (_super) {
    __extends(Player, _super);
    function Player(scene) {
        var _this = _super.call(this) || this;
        _this.onPress = function () {
            //this.gameStarted = true;
            _this.pressed = true;
        };
        _this.reset = function () {
            _this.ypos = gamesettings_1.GameSettings.HEIGHT / 2;
            _this.yspeed = 0;
            _this.yacc = gamesettings_1.GameSettings.GRAVITY;
            _this.pressed = false;
            _this.y = _this.ypos;
            _this.rotation = 0;
            //this.gameStarted = false;
        };
        _this.setWidth(48);
        _this.setHeight(32);
        _this.x = 100;
        _this.ypos = gamesettings_1.GameSettings.HEIGHT / 2;
        _this.yspeed = 0;
        _this.yacc = gamesettings_1.GameSettings.GRAVITY;
        _this.pressed = false;
        _this.y = _this.ypos;
        //this.gameStarted = false;
        _this.gameScene = scene;
        return _this;
    }
    Player.prototype.onInitialize = function (engine) {
        this.addDrawing("idle", new ex.Sprite(resource_1.Resource.TxPlayer, 0, 0, 64, 64));
        this.setDrawing("idle");
        var playerIdleSheet = new ex.SpriteSheet(resource_1.Resource.TxPlayer, 16, 1, 64, 64);
        this.flapAnimation = playerIdleSheet.getAnimationBetween(engine, 1, 16, 3);
        this.flapAnimation.loop = false;
        this.addDrawing("flap", this.flapAnimation);
        engine.input.pointers.primary.on("down", this.onPress);
    };
    Player.prototype.update = function (engine, delta) {
        _super.prototype.update.call(this, engine, delta); // call base update logic
        if (this.gameScene.gameOver || !this.gameScene.gameStarted)
            return;
        if (this.pressed) {
            this.yspeed = gamesettings_1.GameSettings.FORCE;
            this.setDrawing("flap");
        }
        else
            this.yspeed = gamesettings_1.GameSettings.GRAVITY + (this.yspeed - gamesettings_1.GameSettings.GRAVITY) * (Math.exp(-delta / (1000 * gamesettings_1.GameSettings.INERTIA)));
        this.ypos += this.yspeed * delta / 1000;
        this.y = this.ypos;
        //this.rotation = Math.max(-0.3, Math.min(0.3, Math.atan2(this.yspeed, GameSettings.HSPEED)/2));
        this.rotation = this.yspeed < 300 ? -0.3 : (this.yspeed > 600 ? 0.3 : -0.9 + 0.002 * this.yspeed);
        this.pressed = false;
        if (this.flapAnimation.isDone())
            this.setDrawing("idle");
        if (this.collides(this.gameScene.ground) != null)
            this.gameScene.setGameOver();
    };
    return Player;
}(ex.Actor));
exports.Player = Player;


/***/ }),

/***/ "./src/gamesettings.ts":
/*!*****************************!*\
  !*** ./src/gamesettings.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var GameSettings;
(function (GameSettings) {
    GameSettings.WIDTH = 800;
    GameSettings.HEIGHT = 600;
    GameSettings.GRAVITY = 800;
    GameSettings.FORCE = -800;
    GameSettings.INERTIA = 0.3;
    GameSettings.HSPEED = 200;
    GameSettings.TIME_INTERVAL = 1.5;
    GameSettings.VARIABILITY = 100;
    GameSettings.MAX_SPACE = 160;
    GameSettings.MIN_SPACE = 80;
    GameSettings.SCORE_MAX_DIFF = 100;
    GameSettings.START_V_LIMIT = 0.2;
    GameSettings.END_V_LIMIT = 1;
    GameSettings.GROUND_HEIGHT = 64;
    GameSettings.PEST_HEIGHT = 512;
    GameSettings.PEST_WIDTH = 64;
})(GameSettings = exports.GameSettings || (exports.GameSettings = {}));


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ex = __webpack_require__(/*! excalibur */ "./node_modules/excalibur/dist/excalibur.js");
var gamescene_1 = __webpack_require__(/*! ./scenes/gameScene/gamescene */ "./src/scenes/gameScene/gamescene.ts");
var resource_1 = __webpack_require__(/*! ./resource */ "./src/resource.ts");
var gamesettings_1 = __webpack_require__(/*! ./gamesettings */ "./src/gamesettings.ts");
var Game = /** @class */ (function (_super) {
    __extends(Game, _super);
    function Game() {
        return _super.call(this, { width: gamesettings_1.GameSettings.WIDTH,
            height: gamesettings_1.GameSettings.HEIGHT,
            displayMode: ex.DisplayMode.Fixed,
            pointerScope: ex.Input.PointerScope.Canvas }) || this;
    }
    Game.prototype.start = function (loader) {
        return _super.prototype.start.call(this, loader);
    };
    return Game;
}(ex.Engine));
var loader = new ex.Loader();
for (var resource in resource_1.Resource) {
    loader.addResource(resource_1.Resource[resource]);
}
var game = new Game();
var gameScene = new gamescene_1.GameScene();
game.add('gameScene', gameScene);
game.start(loader).then(function () {
    game.goToScene('gameScene');
});


/***/ }),

/***/ "./src/resource.ts":
/*!*************************!*\
  !*** ./src/resource.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ex = __webpack_require__(/*! excalibur */ "./node_modules/excalibur/dist/excalibur.js");
// Image and sound resources to be loaded
var Resource = {
    TxPlayer: new ex.Texture("assets/bee.png"),
    Ground: new ex.Texture("assets/ground.png"),
    pesticide1: new ex.Texture("assets/pesticide1.png"),
    pesticide2: new ex.Texture("assets/pesticide2.png"),
    Rndp: new ex.Texture("assets/rndp.png")
};
exports.Resource = Resource;


/***/ }),

/***/ "./src/scenes/gameScene/gamescene.ts":
/*!*******************************************!*\
  !*** ./src/scenes/gameScene/gamescene.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ex = __webpack_require__(/*! excalibur */ "./node_modules/excalibur/dist/excalibur.js");
var resource_1 = __webpack_require__(/*! ../../resource */ "./src/resource.ts");
var player_1 = __webpack_require__(/*! ../../actors/player/player */ "./src/actors/player/player.ts");
var pesticide_1 = __webpack_require__(/*! ../../actors/obstacles/pesticide */ "./src/actors/obstacles/pesticide.ts");
var gamesettings_1 = __webpack_require__(/*! ../../gamesettings */ "./src/gamesettings.ts");
//import { Input } from 'excalibur';
var GameScene = /** @class */ (function (_super) {
    __extends(GameScene, _super);
    function GameScene() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.onPress = function () {
            if (!_this.gameStarted) {
                _this.gameStarted = true;
                _this.centerLabel.visible = false;
            }
            if (_this.gameOver && _this.canRestart)
                _this.resetScene = true;
        };
        _this.setGameOver = function () {
            _this.gameOver = true;
            _this.centerLabel.text = "Game Over";
            _this.centerLabel.visible = true;
            _this.lastObstacleTime = 0;
        };
        return _this;
    }
    GameScene.prototype.onInitialize = function (engine) {
        this.score = 0;
        this.player = new player_1.Player(this);
        this.add(this.player);
        this.player.z = 7;
        this.lastObstacleTime = gamesettings_1.GameSettings.TIME_INTERVAL;
        this.lastObstacleY = gamesettings_1.GameSettings.HEIGHT / 2;
        this.centerLabel = new ex.Label("Click to start flapping.", gamesettings_1.GameSettings.WIDTH / 2, gamesettings_1.GameSettings.HEIGHT / 2, "Arial");
        this.centerLabel.textAlign = ex.TextAlign.Center;
        this.centerLabel.baseAlign = ex.BaseAlign.Middle;
        this.centerLabel.fontSize = 42;
        this.centerLabel.color = ex.Color.White;
        this.add(this.centerLabel);
        this.centerLabel.z = 10;
        this.restartLabel = new ex.Label("click to restart", gamesettings_1.GameSettings.WIDTH / 2, gamesettings_1.GameSettings.HEIGHT / 2 + 32, "Arial");
        this.restartLabel.textAlign = ex.TextAlign.Center;
        this.restartLabel.baseAlign = ex.BaseAlign.Top;
        this.restartLabel.fontSize = 28;
        this.restartLabel.color = ex.Color.White;
        this.add(this.restartLabel);
        this.restartLabel.z = 10;
        this.restartLabel.visible = false;
        this.scoreLabel = new ex.Label("0", gamesettings_1.GameSettings.WIDTH - 32, 32, "Arial");
        this.scoreLabel.textAlign = ex.TextAlign.Right;
        this.scoreLabel.baseAlign = ex.BaseAlign.Top;
        this.scoreLabel.fontSize = 42;
        this.scoreLabel.color = ex.Color.White;
        this.add(this.scoreLabel);
        this.scoreLabel.z = 10;
        this.gameStarted = false;
        this.gameOver = false;
        this.resetScene = false;
        this.canRestart = false;
        this.ground = new ex.Actor();
        this.ground.addDrawing(resource_1.Resource.Ground.asSprite());
        this.ground.x = gamesettings_1.GameSettings.WIDTH / 2;
        this.ground.y = gamesettings_1.GameSettings.HEIGHT - gamesettings_1.GameSettings.GROUND_HEIGHT / 2;
        this.ground.setWidth(gamesettings_1.GameSettings.WIDTH);
        this.ground.setHeight(gamesettings_1.GameSettings.GROUND_HEIGHT);
        this.add(this.ground);
        this.ground.z = 5;
        engine.input.pointers.primary.on("down", this.onPress);
        //engine.input.keyboard.on("press", (evt: Input.KeyEvent) => { if(evt.key == Input.Keys.Space) this.onSpace() });
        this.camera.pos = new ex.Vector(gamesettings_1.GameSettings.WIDTH / 2, gamesettings_1.GameSettings.HEIGHT / 2);
    };
    GameScene.prototype.update = function (engine, delta) {
        _super.prototype.update.call(this, engine, delta);
        if (this.gameOver && !this.canRestart) {
            this.lastObstacleTime += delta / 1000;
            if (this.lastObstacleTime > 1) {
                this.canRestart = true;
                this.restartLabel.visible = true;
            }
        }
        if (this.resetScene) {
            for (var ac in this.actors) {
                if (this.actors[ac] instanceof pesticide_1.Pesticide) {
                    this.actors[ac].kill();
                }
            }
            this.player.reset();
            this.score = 0;
            this.restartLabel.visible = false;
            this.centerLabel.text = "Click to start flapping.";
            this.gameStarted = false;
            this.gameOver = false;
            this.canRestart = false;
            this.lastObstacleTime = gamesettings_1.GameSettings.TIME_INTERVAL;
            this.lastObstacleY = gamesettings_1.GameSettings.HEIGHT / 2;
            this.resetScene = false;
        }
        else if (this.gameOver || !this.gameStarted)
            return;
        else {
            //super.update(engine, delta); // call base update logic
            this.lastObstacleTime += delta / 1000;
            if (this.lastObstacleTime > gamesettings_1.GameSettings.TIME_INTERVAL) {
                var posx = gamesettings_1.GameSettings.WIDTH + Math.floor(Math.random() * gamesettings_1.GameSettings.VARIABILITY);
                var spaceY = Math.floor(gamesettings_1.GameSettings.MAX_SPACE - (gamesettings_1.GameSettings.MAX_SPACE - gamesettings_1.GameSettings.MIN_SPACE) / gamesettings_1.GameSettings.SCORE_MAX_DIFF);
                var posy;
                do {
                    posy = Math.floor(spaceY + Math.random() * (gamesettings_1.GameSettings.HEIGHT - gamesettings_1.GameSettings.GROUND_HEIGHT - 2 * spaceY));
                } while (Math.abs(posy - this.lastObstacleY) > (gamesettings_1.GameSettings.START_V_LIMIT + (gamesettings_1.GameSettings.END_V_LIMIT - gamesettings_1.GameSettings.START_V_LIMIT) * this.score / gamesettings_1.GameSettings.SCORE_MAX_DIFF) * gamesettings_1.GameSettings.HEIGHT);
                //alert(posx + " " + posy + " " + spaceY);
                this.add(new pesticide_1.Pesticide(posx, posy, spaceY, this));
                this.lastObstacleY = posy;
                this.lastObstacleTime = 0;
            }
            this.scoreLabel.text = this.score.toString();
        }
    };
    GameScene.prototype.onActivate = function () { };
    GameScene.prototype.onDeactivate = function () { };
    return GameScene;
}(ex.Scene));
exports.GameScene = GameScene;


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V4Y2FsaWJ1ci9kaXN0L2V4Y2FsaWJ1ci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYWN0b3JzL29ic3RhY2xlcy9wZXN0aWNpZGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FjdG9ycy9wbGF5ZXIvcGxheWVyLnRzIiwid2VicGFjazovLy8uL3NyYy9nYW1lc2V0dGluZ3MudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy9yZXNvdXJjZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NlbmVzL2dhbWVTY2VuZS9nYW1lc2NlbmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseURBQWlELGNBQWM7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7OztBQUdBO0FBQ0E7Ozs7Ozs7Ozs7OztnRUNuRUE7QUFDQTtBQUNBLGlHQUFpRztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQUE7QUFDVCxLQUFLLFFBUUw7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG1CQUFtQjtBQUNuQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0MsT0FBTztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiwwQ0FBMEM7QUFDMUM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLHVGQUF1RjtBQUN2RjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxpR0FBaUc7QUFDakc7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQkFBZ0Isc0NBQXNDLGlCQUFpQixFQUFFO0FBQ25GLHlCQUF5Qix1REFBdUQ7QUFDaEY7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLG1FQUFtRTtBQUN4RSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxrQkFBa0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsVUFBVTtBQUN6QywrQkFBK0IsVUFBVTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssZ0hBQWdIO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHFGQUFxRjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDZEQUE2RDtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxtRUFBbUU7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsdUJBQXVCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1QkFBdUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGlCQUFpQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyx5QkFBeUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMEJBQTBCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixZQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSywyQ0FBMkM7QUFDaEQsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFlBQVk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0NBQWdDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdDQUFnQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxzQ0FBc0M7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixXQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFdBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsV0FBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixXQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSywyQ0FBMkM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw2REFBNkQ7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGNBQWM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsZ0JBQWdCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsdUJBQXVCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsNEJBQTRCLEVBQUU7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLEVBQUUsV0FBVyxFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxnQkFBZ0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0JBQWdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHFDQUFxQztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQywyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsd0JBQXdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdCQUFnQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxtQ0FBbUM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxVQUFVO0FBQzVDLGlDQUFpQyxTQUFTO0FBQzFDLG1DQUFtQyxXQUFXO0FBQzlDLG9DQUFvQyxZQUFZO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx1Q0FBdUM7QUFDMUUsNERBQTRELCtCQUErQixFQUFFO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw0QkFBNEI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsNEJBQTRCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw4QkFBOEI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxtQ0FBbUM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQ0FBbUM7QUFDbEUsbUNBQW1DLGVBQWU7QUFDbEQsNkJBQTZCLGNBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1DQUFtQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsYUFBYTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFlBQVk7QUFDNUMsZ0NBQWdDLDhCQUE4QjtBQUM5RCw4QkFBOEIsYUFBYTtBQUMzQztBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw4QkFBOEI7QUFDOUQsOEJBQThCLGFBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHdDQUF3QztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHdDQUF3QztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msd0NBQXdDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsc0RBQXNEO0FBQzdGO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZUFBZTtBQUN0RDtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyx1REFBdUQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMkJBQTJCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxnQkFBZ0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxzQkFBc0IsRUFBRTtBQUMvRTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEUsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsa0JBQWtCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BELDRDQUE0QyxRQUFRO0FBQ3BELHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZ0JBQWdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGtCQUFrQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZUFBZTtBQUMxQywrQkFBK0Isa0JBQWtCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RjtBQUN4RixrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJCQUEyQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyx1REFBdUQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSywwREFBMEQ7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssMERBQTBEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDBEQUEwRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJLGFBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEUsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxxQkFBcUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25ELDJDQUEyQyxRQUFRO0FBQ25ELHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHFCQUFxQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZ0JBQWdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZ0JBQWdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxzQkFBc0IsRUFBRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxnQkFBZ0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGdCQUFnQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msc0JBQXNCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQiw0QkFBNEIsRUFBRTtBQUNuRSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsd0JBQXdCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELCtCQUErQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCwrQkFBK0I7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQseUNBQXlDLFFBQVE7QUFDakQsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRCx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxnQ0FBZ0M7QUFDaEMscUJBQXFCLEdBQUcsd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwyQkFBMkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHlDQUF5QztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGdFQUFnRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxtREFBbUQ7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIseUJBQXlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbUJBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHdCQUF3QixFQUFFO0FBQzNFLHFEQUFxRCx5Q0FBeUMsRUFBRTtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELG9CQUFvQixFQUFFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixVQUFVO0FBQ3JDLCtCQUErQixVQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFlBQVk7QUFDdEQsNkNBQTZDLGFBQWE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0IsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLG9EQUFvRCxhQUFhO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtQkFBbUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtQkFBbUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZUFBZTtBQUNsRCxxQ0FBcUMsY0FBYztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixRQUFRLEVBQUU7QUFDdkMsNkJBQTZCLGFBQWEsRUFBRTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsYUFBYTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxnREFBZ0QseUJBQXlCO0FBQ3pFLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsdUhBQXVIO0FBQ2hLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdCQUFnQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxPQUFPO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLGtDQUFrQztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLG9CQUFvQixFQUFFO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMscUJBQXFCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHFCQUFxQixFQUFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxxQkFBcUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGdCQUFnQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELGdCQUFnQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxPQUFPO0FBQ2pFO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHFCQUFxQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsZ0JBQWdCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHFCQUFxQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMscUJBQXFCLEVBQUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsWUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixZQUFZO0FBQ3ZDLCtCQUErQixXQUFXO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGdFQUFnRTtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsWUFBWTtBQUN2QywrQkFBK0IsV0FBVztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEUsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyx5RUFBeUU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msa0JBQWtCO0FBQ3hELHVDQUF1QyxzQ0FBc0M7QUFDN0U7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVELDJDQUEyQztBQUMzQywyQ0FBMkM7QUFDM0MseUNBQXlDO0FBQ3pDLDhCQUE4QjtBQUM5QjtBQUNBLDREQUE0RDtBQUM1RDtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLGtEQUFrRDtBQUNsRCxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBLHlDQUF5QztBQUN6QyxrQkFBa0I7QUFDbEIsNERBQTREO0FBQzVEO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLDhCQUE4QjtBQUM5QiwwREFBMEQ7QUFDMUQ7QUFDQSwrRUFBK0U7QUFDL0UsK0VBQStFO0FBQy9FLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQsc0VBQXNFO0FBQ3RFLDZEQUE2RDtBQUM3RDtBQUNBLDRCQUE0QjtBQUM1Qix1RkFBdUY7QUFDdkYseUZBQXlGO0FBQ3pGLDRGQUE0RjtBQUM1RiwrQkFBK0I7QUFDL0IsdUNBQXVDO0FBQ3ZDLGlDQUFpQztBQUNqQyxvQ0FBb0M7QUFDcEMsaUVBQWlFO0FBQ2pFLGlFQUFpRTtBQUNqRSw2Q0FBNkM7QUFDN0Msb0NBQW9DO0FBQ3BDO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSw4QkFBOEI7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFLCtEQUErRDtBQUMvRCwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELHdFQUF3RTtBQUN4RSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELCtEQUErRDtBQUMvRCwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBLCtHQUErRztBQUMvRztBQUNBO0FBQ0Esb0hBQW9IO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxvQkFBb0I7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIscUJBQXFCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLGdFQUFnRSxTQUFTO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1QkFBdUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsb0JBQW9CLEVBQUU7QUFDekU7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFNBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsU0FBUztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwyQkFBMkI7QUFDbEQ7QUFDQTtBQUNBLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZUFBZTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssb0RBQW9EO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssMkNBQTJDO0FBQ2hELENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxnRUFBZ0U7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxzRUFBc0U7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUsseUVBQXlFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLG1FQUFtRTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsU0FBUztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFNBQVM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQ0FBaUM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDJDQUEyQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1QkFBdUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEUsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLEdBQUcsaUdBQWlHO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSxpRUFBaUUsZ0JBQWdCO0FBQ2pGO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsaURBQWlEO0FBQ2pELG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLGlEQUFpRDtBQUNqRCxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxnRUFBZ0U7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssMkZBQTJGO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxzQ0FBc0M7QUFDekY7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHLGNBQWMsb0JBQW9CLGVBQWUsa0JBQWtCLG1CQUFtQjtBQUNsTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlIQUF5SCxnQkFBZ0I7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUJBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0NBQWdDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxpQkFBaUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0JBQWdCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsU0FBUztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxnQkFBZ0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxTQUFTO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxTQUFTO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxTQUFTO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQseUJBQXlCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxTQUFTO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxTQUFTO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFNBQVM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0EsaURBQWlELFNBQVM7QUFDMUQ7QUFDQTtBQUNBLG1EQUFtRCxTQUFTO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGdCQUFnQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0JBQWdCO0FBQzlEO0FBQ0E7QUFDQSxxREFBcUQsZ0JBQWdCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsc0NBQXNDO0FBQzNFO0FBQ0E7QUFDQSxxQ0FBcUMsMEJBQTBCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxnQkFBZ0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxpQkFBaUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxnQkFBZ0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMEJBQTBCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBCQUEwQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsd0JBQXdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMEJBQTBCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssc0VBQXNFO0FBQzNFLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZUFBZTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xELDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxRQUFRO0FBQzdEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsY0FBYyw0QkFBNEIsUUFBUSxFQUFFO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx5Q0FBeUM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHLFFBQVEsRUFBRTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzMGZBLDRGQUFnQztBQUNoQyxnRkFBMEM7QUFDMUMsNEZBQWtEO0FBR2xELElBQU0sV0FBVyxHQUFHLENBQUMsbUJBQVEsQ0FBQyxJQUFJLEVBQUUsbUJBQVEsQ0FBQyxVQUFVLEVBQUUsbUJBQVEsQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUU5RTtJQUF3Qiw2QkFBUTtJQU01QixtQkFBWSxFQUFVLEVBQUUsRUFBVSxFQUFFLE1BQWMsRUFBRSxLQUFnQjtRQUFwRSxZQUNJLGlCQUFPLFNBNEJWO1FBMUJHLEtBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQ1osS0FBSSxDQUFDLFFBQVEsQ0FBQywyQkFBWSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ3ZDLEtBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsR0FBRywyQkFBWSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBRXRELEtBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxFQUFFLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDOUIsSUFBSSxTQUFTLEdBQUcsSUFBSSxFQUFFLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLDJCQUFZLENBQUMsVUFBVSxFQUFFLDJCQUFZLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDcEosU0FBUyxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUM7UUFDOUIsS0FBSSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDbkMsS0FBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ25CLEtBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLDJCQUFZLENBQUMsV0FBVyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUM5RCxLQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQywyQkFBWSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQy9DLEtBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLDJCQUFZLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDakQsS0FBSSxDQUFDLEdBQUcsQ0FBQyxLQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFdkIsS0FBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLEVBQUUsQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUNqQyxJQUFJLFlBQVksR0FBRyxJQUFJLEVBQUUsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsMkJBQVksQ0FBQyxVQUFVLEVBQUUsMkJBQVksQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUN2SixvQ0FBb0M7UUFDcEMsS0FBSSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDekMsS0FBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3RCLEtBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLDJCQUFZLENBQUMsV0FBVyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNqRSxLQUFJLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQywyQkFBWSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ2xELEtBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLDJCQUFZLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDcEQsS0FBSSxDQUFDLEdBQUcsQ0FBQyxLQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7UUFFMUIsS0FBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7UUFDdkIsS0FBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUM7O0lBQ3hCLENBQUM7SUFFTSxnQ0FBWSxHQUFuQixVQUFvQixNQUFpQjtRQUNqQyxXQUFXO0lBQ2YsQ0FBQztJQUVNLDBCQUFNLEdBQWIsVUFBYyxNQUFpQixFQUFFLEtBQWE7UUFDNUMsaUJBQU0sTUFBTSxZQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLHlCQUF5QjtRQUV0RCxFQUFFLEVBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQztZQUN0RCxNQUFNLENBQUM7UUFFWCxJQUFJLENBQUMsQ0FBQyxJQUFJLDJCQUFZLENBQUMsTUFBTSxHQUFHLEtBQUssR0FBQyxJQUFJLENBQUM7UUFFM0MsRUFBRSxFQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLElBQUksSUFBSSxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLElBQUksSUFBSSxDQUFDO1lBQ2hILElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxFQUFFLENBQUM7UUFFaEMsRUFBRSxFQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsMkJBQVksQ0FBQyxVQUFVLEdBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNwQyxFQUFFLEVBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztnQkFDZCxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQztnQkFDbkIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUMzQixDQUFDO1lBRUQsRUFBRSxFQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQywyQkFBWSxDQUFDLFVBQVUsR0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNyQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDaEIsQ0FBQztRQUNMLENBQUM7SUFDSixDQUFDO0lBQ0osZ0JBQUM7QUFBRCxDQUFDLENBL0R1QixFQUFFLENBQUMsS0FBSyxHQStEL0I7QUFFUSw4QkFBUzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hFbEIsNEZBQWdDO0FBQ2hDLGdGQUEwQztBQUMxQyw0RkFBa0Q7QUFHbEQ7SUFBcUIsMEJBQVE7SUFTekIsZ0JBQVksS0FBZ0I7UUFBNUIsWUFDSSxpQkFBTyxTQWVWO1FBY00sYUFBTyxHQUFHO1lBQ2IsMEJBQTBCO1lBQzFCLEtBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO1FBQ3hCLENBQUM7UUFFTSxXQUFLLEdBQUc7WUFDWCxLQUFJLENBQUMsSUFBSSxHQUFHLDJCQUFZLENBQUMsTUFBTSxHQUFDLENBQUMsQ0FBQztZQUNsQyxLQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztZQUNoQixLQUFJLENBQUMsSUFBSSxHQUFHLDJCQUFZLENBQUMsT0FBTyxDQUFDO1lBQ2pDLEtBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO1lBQ3JCLEtBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSSxDQUFDLElBQUksQ0FBQztZQUNuQixLQUFJLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQztZQUVsQiwyQkFBMkI7UUFDL0IsQ0FBQztRQXpDRyxLQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ2xCLEtBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDbkIsS0FBSSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUM7UUFFYixLQUFJLENBQUMsSUFBSSxHQUFHLDJCQUFZLENBQUMsTUFBTSxHQUFDLENBQUMsQ0FBQztRQUNsQyxLQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztRQUNoQixLQUFJLENBQUMsSUFBSSxHQUFHLDJCQUFZLENBQUMsT0FBTyxDQUFDO1FBQ2pDLEtBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO1FBQ3JCLEtBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSSxDQUFDLElBQUksQ0FBQztRQUVuQiwyQkFBMkI7UUFFM0IsS0FBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7O0lBQzNCLENBQUM7SUFFTSw2QkFBWSxHQUFuQixVQUFvQixNQUFpQjtRQUNqQyxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBRSxJQUFJLEVBQUUsQ0FBQyxNQUFNLENBQUMsbUJBQVEsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUN4RSxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRXhCLElBQU0sZUFBZSxHQUFHLElBQUksRUFBRSxDQUFDLFdBQVcsQ0FBQyxtQkFBUSxDQUFDLFFBQVEsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUM3RSxJQUFJLENBQUMsYUFBYSxHQUFHLGVBQWUsQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUMzRSxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksR0FBRyxLQUFLLENBQUM7UUFDaEMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBRTVDLE1BQU0sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUMzRCxDQUFDO0lBa0JNLHVCQUFNLEdBQWIsVUFBYyxNQUFpQixFQUFFLEtBQWE7UUFDNUMsaUJBQU0sTUFBTSxZQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLHlCQUF5QjtRQUV0RCxFQUFFLEVBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQztZQUN0RCxNQUFNLENBQUM7UUFFWCxFQUFFLEVBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7WUFDZCxJQUFJLENBQUMsTUFBTSxHQUFHLDJCQUFZLENBQUMsS0FBSyxDQUFDO1lBQ2pDLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDNUIsQ0FBQztRQUNELElBQUk7WUFDQSxJQUFJLENBQUMsTUFBTSxHQUFHLDJCQUFZLENBQUMsT0FBTyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sR0FBRywyQkFBWSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBQyxDQUFDLElBQUksR0FBQywyQkFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUUvSCxJQUFJLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxHQUFDLElBQUksQ0FBQztRQUN0QyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7UUFDbkIsZ0dBQWdHO1FBQ2hHLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLEtBQUssR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFbEcsSUFBSSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUM7UUFFckIsRUFBRSxFQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxFQUFFLENBQUM7WUFDM0IsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUc1QixFQUFFLEVBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxJQUFJLElBQUksQ0FBQztZQUM3QyxJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQ25DLENBQUM7SUFDSixhQUFDO0FBQUQsQ0FBQyxDQWxGb0IsRUFBRSxDQUFDLEtBQUssR0FrRjVCO0FBRVEsd0JBQU07Ozs7Ozs7Ozs7Ozs7OztBQ3pGZixJQUFpQixZQUFZLENBb0I1QjtBQXBCRCxXQUFpQixZQUFZO0lBQ1osa0JBQUssR0FBRyxHQUFHLENBQUM7SUFDWixtQkFBTSxHQUFHLEdBQUcsQ0FBQztJQUViLG9CQUFPLEdBQUcsR0FBRyxDQUFDO0lBQ2Qsa0JBQUssR0FBRyxDQUFDLEdBQUcsQ0FBQztJQUNiLG9CQUFPLEdBQUcsR0FBRyxDQUFDO0lBQ2QsbUJBQU0sR0FBRyxHQUFHLENBQUM7SUFFYiwwQkFBYSxHQUFHLEdBQUcsQ0FBQztJQUNwQix3QkFBVyxHQUFHLEdBQUcsQ0FBQztJQUNsQixzQkFBUyxHQUFHLEdBQUcsQ0FBQztJQUNoQixzQkFBUyxHQUFHLEVBQUUsQ0FBQztJQUNmLDJCQUFjLEdBQUcsR0FBRyxDQUFDO0lBQ3JCLDBCQUFhLEdBQUcsR0FBRyxDQUFDO0lBQ3BCLHdCQUFXLEdBQUcsQ0FBQyxDQUFDO0lBRWhCLDBCQUFhLEdBQUcsRUFBRSxDQUFDO0lBQ25CLHdCQUFXLEdBQUcsR0FBRyxDQUFDO0lBQ2xCLHVCQUFVLEdBQUcsRUFBRSxDQUFDO0FBQ2pDLENBQUMsRUFwQmdCLFlBQVksR0FBWixvQkFBWSxLQUFaLG9CQUFZLFFBb0I1Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BCRCw0RkFBZ0M7QUFDaEMsaUhBQXlEO0FBRXpELDRFQUFzQztBQUN0Qyx3RkFBOEM7QUFFOUM7SUFBbUIsd0JBQVM7SUFDeEI7ZUFDSSxrQkFBTSxFQUFFLEtBQUssRUFBRSwyQkFBWSxDQUFDLEtBQUs7WUFDekIsTUFBTSxFQUFFLDJCQUFZLENBQUMsTUFBTTtZQUMzQixXQUFXLEVBQUUsRUFBRSxDQUFDLFdBQVcsQ0FBQyxLQUFLO1lBQ2pDLFlBQVksRUFBRSxFQUFFLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxNQUFNLEVBQUUsQ0FBQztJQUN6RCxDQUFDO0lBRU0sb0JBQUssR0FBWixVQUFhLE1BQW1CO1FBQzVCLE1BQU0sQ0FBQyxpQkFBTSxLQUFLLFlBQUMsTUFBTSxDQUFDLENBQUM7SUFDL0IsQ0FBQztJQUNMLFdBQUM7QUFBRCxDQUFDLENBWGtCLEVBQUUsQ0FBQyxNQUFNLEdBVzNCO0FBRUQsSUFBSSxNQUFNLEdBQUcsSUFBSSxFQUFFLENBQUMsTUFBTSxFQUFFLENBQUM7QUFDN0IsR0FBRyxFQUFDLElBQUksUUFBUSxJQUFJLG1CQUFRLENBQUMsRUFBQztJQUMxQixNQUFNLENBQUMsV0FBVyxDQUFDLG1CQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztBQUMzQyxDQUFDO0FBRUQsSUFBTSxJQUFJLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQztBQUN4QixJQUFNLFNBQVMsR0FBRyxJQUFJLHFCQUFTLEVBQUUsQ0FBQztBQUVsQyxJQUFJLENBQUMsR0FBRyxDQUFDLFdBQVcsRUFBRSxTQUFTLENBQUMsQ0FBQztBQUVqQyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQztJQUNwQixJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBQ2hDLENBQUMsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7QUMvQkgsNEZBQWdDO0FBRWhDLHlDQUF5QztBQUN6QyxJQUFJLFFBQVEsR0FBRztJQUNkLFFBQVEsRUFBRSxJQUFJLEVBQUUsQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLENBQUM7SUFDMUMsTUFBTSxFQUFFLElBQUksRUFBRSxDQUFDLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQztJQUUzQyxVQUFVLEVBQUUsSUFBSSxFQUFFLENBQUMsT0FBTyxDQUFDLHVCQUF1QixDQUFDO0lBQ25ELFVBQVUsRUFBRSxJQUFJLEVBQUUsQ0FBQyxPQUFPLENBQUMsdUJBQXVCLENBQUM7SUFDbkQsSUFBSSxFQUFFLElBQUksRUFBRSxDQUFDLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQztDQUN2QztBQUVRLDRCQUFROzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDWmpCLDRGQUFnQztBQUNoQyxnRkFBMEM7QUFDMUMsc0dBQW9EO0FBQ3BELHFIQUE2RDtBQUM3RCw0RkFBa0Q7QUFDbEQsb0NBQW9DO0FBR3BDO0lBQXdCLDZCQUFRO0lBQWhDO1FBQUEscUVBMEpDO1FBakZVLGFBQU8sR0FBRztZQUNiLEVBQUUsRUFBQyxDQUFDLEtBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO2dCQUNuQixLQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQztnQkFDeEIsS0FBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO1lBQ3JDLENBQUM7WUFFRCxFQUFFLEVBQUMsS0FBSSxDQUFDLFFBQVEsSUFBSSxLQUFJLENBQUMsVUFBVSxDQUFDO2dCQUNoQyxLQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQztRQUMvQixDQUFDO1FBZ0VNLGlCQUFXLEdBQUc7WUFDakIsS0FBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7WUFDckIsS0FBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLEdBQUcsV0FBVztZQUNuQyxLQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7WUFDaEMsS0FBSSxDQUFDLGdCQUFnQixHQUFHLENBQUMsQ0FBQztRQUM5QixDQUFDOztJQUlMLENBQUM7SUF4SVUsZ0NBQVksR0FBbkIsVUFBb0IsTUFBaUI7UUFDakMsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUM7UUFFZixJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksZUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQy9CLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3RCLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUVsQixJQUFJLENBQUMsZ0JBQWdCLEdBQUcsMkJBQVksQ0FBQyxhQUFhLENBQUM7UUFDbkQsSUFBSSxDQUFDLGFBQWEsR0FBRywyQkFBWSxDQUFDLE1BQU0sR0FBQyxDQUFDLENBQUM7UUFFM0MsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLEVBQUUsQ0FBQyxLQUFLLENBQUMsMEJBQTBCLEVBQUUsMkJBQVksQ0FBQyxLQUFLLEdBQUMsQ0FBQyxFQUFFLDJCQUFZLENBQUMsTUFBTSxHQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUNsSCxJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQztRQUNqRCxJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQztRQUNqRCxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsR0FBRyxFQUFFLENBQUM7UUFDL0IsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUM7UUFDeEMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDM0IsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBRXhCLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxFQUFFLENBQUMsS0FBSyxDQUFDLGtCQUFrQixFQUFFLDJCQUFZLENBQUMsS0FBSyxHQUFDLENBQUMsRUFBRSwyQkFBWSxDQUFDLE1BQU0sR0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ2hILElBQUksQ0FBQyxZQUFZLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDO1FBQ2xELElBQUksQ0FBQyxZQUFZLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDO1FBQy9DLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxHQUFHLEVBQUUsQ0FBQztRQUNoQyxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQztRQUN6QyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztRQUM1QixJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDekIsSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO1FBRWxDLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSwyQkFBWSxDQUFDLEtBQUssR0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ3hFLElBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDO1FBQy9DLElBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDO1FBQzdDLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxHQUFHLEVBQUUsQ0FBQztRQUM5QixJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQztRQUN2QyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUMxQixJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7UUFFdkIsSUFBSSxDQUFDLFdBQVcsR0FBRyxLQUFLLENBQUM7UUFDekIsSUFBSSxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUM7UUFDdEIsSUFBSSxDQUFDLFVBQVUsR0FBRyxLQUFLLENBQUM7UUFDeEIsSUFBSSxDQUFDLFVBQVUsR0FBRyxLQUFLLENBQUM7UUFFeEIsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLEVBQUUsQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUM3QixJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxtQkFBUSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO1FBQ25ELElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLDJCQUFZLENBQUMsS0FBSyxHQUFDLENBQUMsQ0FBQztRQUNyQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRywyQkFBWSxDQUFDLE1BQU0sR0FBRywyQkFBWSxDQUFDLGFBQWEsR0FBQyxDQUFDLENBQUM7UUFDbkUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsMkJBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN6QyxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQywyQkFBWSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQ2xELElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3RCLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUVsQixNQUFNLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDdkQsaUhBQWlIO1FBRWpILElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxHQUFHLElBQUksRUFBRSxDQUFDLE1BQU0sQ0FBQywyQkFBWSxDQUFDLEtBQUssR0FBQyxDQUFDLEVBQUUsMkJBQVksQ0FBQyxNQUFNLEdBQUMsQ0FBQyxDQUFDLENBQUM7SUFDakYsQ0FBQztJQWFNLDBCQUFNLEdBQWIsVUFBYyxNQUFpQixFQUFFLEtBQWE7UUFDMUMsaUJBQU0sTUFBTSxZQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztRQUU1QixFQUFFLEVBQUMsSUFBSSxDQUFDLFFBQVEsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1lBQ25DLElBQUksQ0FBQyxnQkFBZ0IsSUFBSSxLQUFLLEdBQUMsSUFBSSxDQUFDO1lBQ3BDLEVBQUUsRUFBQyxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDM0IsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUM7Z0JBQ3ZCLElBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztZQUNyQyxDQUFDO1FBQ0wsQ0FBQztRQUVELEVBQUUsRUFBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztZQUNqQixHQUFHLEVBQUMsSUFBSSxFQUFFLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7Z0JBQ3hCLEVBQUUsRUFBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxZQUFZLHFCQUFTLENBQUMsQ0FBQyxDQUFDO29CQUN0QyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO2dCQUMzQixDQUFDO1lBQ0wsQ0FBQztZQUVELElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUM7WUFFcEIsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUM7WUFDZixJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUM7WUFDbEMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLEdBQUcsMEJBQTBCLENBQUM7WUFFbkQsSUFBSSxDQUFDLFdBQVcsR0FBRyxLQUFLLENBQUM7WUFDekIsSUFBSSxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUM7WUFDdEIsSUFBSSxDQUFDLFVBQVUsR0FBRyxLQUFLLENBQUM7WUFFeEIsSUFBSSxDQUFDLGdCQUFnQixHQUFHLDJCQUFZLENBQUMsYUFBYSxDQUFDO1lBQ25ELElBQUksQ0FBQyxhQUFhLEdBQUcsMkJBQVksQ0FBQyxNQUFNLEdBQUMsQ0FBQyxDQUFDO1lBRTNDLElBQUksQ0FBQyxVQUFVLEdBQUcsS0FBSyxDQUFDO1FBQzVCLENBQUM7UUFFRCxJQUFJLENBQUMsRUFBRSxFQUFDLElBQUksQ0FBQyxRQUFRLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDO1lBQ3ZDLE1BQU0sQ0FBQztRQUVYLElBQUksQ0FBQyxDQUFDO1lBRUYsd0RBQXdEO1lBRXhELElBQUksQ0FBQyxnQkFBZ0IsSUFBSSxLQUFLLEdBQUMsSUFBSSxDQUFDO1lBRXBDLEVBQUUsRUFBQyxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsMkJBQVksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO2dCQUNwRCxJQUFJLElBQUksR0FBRywyQkFBWSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRywyQkFBWSxDQUFDLFdBQVcsQ0FBQyxDQUFDO2dCQUNyRixJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLDJCQUFZLENBQUMsU0FBUyxHQUFHLENBQUMsMkJBQVksQ0FBQyxTQUFTLEdBQUcsMkJBQVksQ0FBQyxTQUFTLENBQUMsR0FBRywyQkFBWSxDQUFDLGNBQWMsQ0FBQyxDQUFDO2dCQUNsSSxJQUFJLElBQUksQ0FBQztnQkFDVCxHQUFHLENBQUM7b0JBQ0EsSUFBSSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLDJCQUFZLENBQUMsTUFBTSxHQUFHLDJCQUFZLENBQUMsYUFBYSxHQUFHLENBQUMsR0FBQyxNQUFNLENBQUMsQ0FBQztnQkFDN0csQ0FBQyxRQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLDJCQUFZLENBQUMsYUFBYSxHQUFHLENBQUMsMkJBQVksQ0FBQyxXQUFXLEdBQUcsMkJBQVksQ0FBQyxhQUFhLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxHQUFHLDJCQUFZLENBQUMsY0FBYyxDQUFDLEdBQUcsMkJBQVksQ0FBQyxNQUFNLEVBQUU7Z0JBQ3ZNLDBDQUEwQztnQkFFMUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLHFCQUFTLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQztnQkFDbEQsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUM7Z0JBQzFCLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxDQUFDLENBQUM7WUFDOUIsQ0FBQztZQUVELElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDakQsQ0FBQztJQUNMLENBQUM7SUFTTSw4QkFBVSxHQUFqQixjQUFxQixDQUFDO0lBQ2YsZ0NBQVksR0FBbkIsY0FBdUIsQ0FBQztJQUM1QixnQkFBQztBQUFELENBQUMsQ0ExSnVCLEVBQUUsQ0FBQyxLQUFLLEdBMEovQjtBQUVRLDhCQUFTIiwiZmlsZSI6ImJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9pbmRleC50c1wiKTtcbiIsIi8qISBleGNhbGlidXIgLSB2MC4xNS4wIC0gMjAxOC0wMi0xN1xyXG4qIGh0dHBzOi8vZ2l0aHViLmNvbS9leGNhbGlidXJqcy9FeGNhbGlidXJcclxuKiBDb3B5cmlnaHQgKGMpIDIwMTggRXhjYWxpYnVyLmpzIDxodHRwczovL2dpdGh1Yi5jb20vZXhjYWxpYnVyanMvRXhjYWxpYnVyL2dyYXBocy9jb250cmlidXRvcnM+OyBMaWNlbnNlZCBCU0QtMi1DbGF1c2VcclxuKiBAcHJlc2VydmUgKi9cclxuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XHJcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxyXG4gICAgICAgIGRlZmluZShbXSwgZnVuY3Rpb24gKGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChyb290LmV4ID0gZmFjdG9yeShiKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XHJcbiAgICAgICAgLy8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XHJcbiAgICAgICAgLy8gb25seSBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMsXHJcbiAgICAgICAgLy8gbGlrZSBOb2RlLlxyXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBCcm93c2VyIGdsb2JhbHNcclxuICAgICAgICByb290LmV4ID0gZmFjdG9yeSgpO1xyXG4gICAgfVxyXG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcclxuICAgIC8vYWxtb25kLCBhbmQgeW91ciBtb2R1bGVzIHdpbGwgYmUgaW5saW5lZCBoZXJlXHJcbi8qKlxyXG4gKiBAbGljZW5zZSBhbG1vbmQgMC4zLjMgQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMuXHJcbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLCBodHRwOi8vZ2l0aHViLmNvbS9yZXF1aXJlanMvYWxtb25kL0xJQ0VOU0VcclxuICovXHJcbi8vR29pbmcgc2xvcHB5IHRvIGF2b2lkICd1c2Ugc3RyaWN0JyBzdHJpbmcgY29zdCwgYnV0IHN0cmljdCBwcmFjdGljZXMgc2hvdWxkXHJcbi8vYmUgZm9sbG93ZWQuXHJcbi8qZ2xvYmFsIHNldFRpbWVvdXQ6IGZhbHNlICovXHJcblxyXG52YXIgcmVxdWlyZWpzLCByZXF1aXJlLCBkZWZpbmU7XHJcbihmdW5jdGlvbiAodW5kZWYpIHtcclxuICAgIHZhciBtYWluLCByZXEsIG1ha2VNYXAsIGhhbmRsZXJzLFxyXG4gICAgICAgIGRlZmluZWQgPSB7fSxcclxuICAgICAgICB3YWl0aW5nID0ge30sXHJcbiAgICAgICAgY29uZmlnID0ge30sXHJcbiAgICAgICAgZGVmaW5pbmcgPSB7fSxcclxuICAgICAgICBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxyXG4gICAgICAgIGFwcyA9IFtdLnNsaWNlLFxyXG4gICAgICAgIGpzU3VmZml4UmVnRXhwID0gL1xcLmpzJC87XHJcblxyXG4gICAgZnVuY3Rpb24gaGFzUHJvcChvYmosIHByb3ApIHtcclxuICAgICAgICByZXR1cm4gaGFzT3duLmNhbGwob2JqLCBwcm9wKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGEgcmVsYXRpdmUgbW9kdWxlIG5hbWUsIGxpa2UgLi9zb21ldGhpbmcsIG5vcm1hbGl6ZSBpdCB0b1xyXG4gICAgICogYSByZWFsIG5hbWUgdGhhdCBjYW4gYmUgbWFwcGVkIHRvIGEgcGF0aC5cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIHRoZSByZWxhdGl2ZSBuYW1lXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYmFzZU5hbWUgYSByZWFsIG5hbWUgdGhhdCB0aGUgbmFtZSBhcmcgaXMgcmVsYXRpdmVcclxuICAgICAqIHRvLlxyXG4gICAgICogQHJldHVybnMge1N0cmluZ30gbm9ybWFsaXplZCBuYW1lXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZShuYW1lLCBiYXNlTmFtZSkge1xyXG4gICAgICAgIHZhciBuYW1lUGFydHMsIG5hbWVTZWdtZW50LCBtYXBWYWx1ZSwgZm91bmRNYXAsIGxhc3RJbmRleCxcclxuICAgICAgICAgICAgZm91bmRJLCBmb3VuZFN0YXJNYXAsIHN0YXJJLCBpLCBqLCBwYXJ0LCBub3JtYWxpemVkQmFzZVBhcnRzLFxyXG4gICAgICAgICAgICBiYXNlUGFydHMgPSBiYXNlTmFtZSAmJiBiYXNlTmFtZS5zcGxpdChcIi9cIiksXHJcbiAgICAgICAgICAgIG1hcCA9IGNvbmZpZy5tYXAsXHJcbiAgICAgICAgICAgIHN0YXJNYXAgPSAobWFwICYmIG1hcFsnKiddKSB8fCB7fTtcclxuXHJcbiAgICAgICAgLy9BZGp1c3QgYW55IHJlbGF0aXZlIHBhdGhzLlxyXG4gICAgICAgIGlmIChuYW1lKSB7XHJcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNwbGl0KCcvJyk7XHJcbiAgICAgICAgICAgIGxhc3RJbmRleCA9IG5hbWUubGVuZ3RoIC0gMTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHdhbnRpbmcgbm9kZSBJRCBjb21wYXRpYmlsaXR5LCBzdHJpcCAuanMgZnJvbSBlbmRcclxuICAgICAgICAgICAgLy8gb2YgSURzLiBIYXZlIHRvIGRvIHRoaXMgaGVyZSwgYW5kIG5vdCBpbiBuYW1lVG9VcmxcclxuICAgICAgICAgICAgLy8gYmVjYXVzZSBub2RlIGFsbG93cyBlaXRoZXIgLmpzIG9yIG5vbiAuanMgdG8gbWFwXHJcbiAgICAgICAgICAgIC8vIHRvIHNhbWUgZmlsZS5cclxuICAgICAgICAgICAgaWYgKGNvbmZpZy5ub2RlSWRDb21wYXQgJiYganNTdWZmaXhSZWdFeHAudGVzdChuYW1lW2xhc3RJbmRleF0pKSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lW2xhc3RJbmRleF0gPSBuYW1lW2xhc3RJbmRleF0ucmVwbGFjZShqc1N1ZmZpeFJlZ0V4cCwgJycpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTdGFydHMgd2l0aCBhICcuJyBzbyBuZWVkIHRoZSBiYXNlTmFtZVxyXG4gICAgICAgICAgICBpZiAobmFtZVswXS5jaGFyQXQoMCkgPT09ICcuJyAmJiBiYXNlUGFydHMpIHtcclxuICAgICAgICAgICAgICAgIC8vQ29udmVydCBiYXNlTmFtZSB0byBhcnJheSwgYW5kIGxvcCBvZmYgdGhlIGxhc3QgcGFydCxcclxuICAgICAgICAgICAgICAgIC8vc28gdGhhdCAuIG1hdGNoZXMgdGhhdCAnZGlyZWN0b3J5JyBhbmQgbm90IG5hbWUgb2YgdGhlIGJhc2VOYW1lJ3NcclxuICAgICAgICAgICAgICAgIC8vbW9kdWxlLiBGb3IgaW5zdGFuY2UsIGJhc2VOYW1lIG9mICdvbmUvdHdvL3RocmVlJywgbWFwcyB0b1xyXG4gICAgICAgICAgICAgICAgLy8nb25lL3R3by90aHJlZS5qcycsIGJ1dCB3ZSB3YW50IHRoZSBkaXJlY3RvcnksICdvbmUvdHdvJyBmb3JcclxuICAgICAgICAgICAgICAgIC8vdGhpcyBub3JtYWxpemF0aW9uLlxyXG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZEJhc2VQYXJ0cyA9IGJhc2VQYXJ0cy5zbGljZSgwLCBiYXNlUGFydHMubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgICAgICBuYW1lID0gbm9ybWFsaXplZEJhc2VQYXJ0cy5jb25jYXQobmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vc3RhcnQgdHJpbURvdHNcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHBhcnQgPSBuYW1lW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcnQgPT09ICcuJykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGkgLT0gMTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJy4uJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGF0IHRoZSBzdGFydCwgb3IgcHJldmlvdXMgdmFsdWUgaXMgc3RpbGwgLi4sXHJcbiAgICAgICAgICAgICAgICAgICAgLy8ga2VlcCB0aGVtIHNvIHRoYXQgd2hlbiBjb252ZXJ0ZWQgdG8gYSBwYXRoIGl0IG1heVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0aWxsIHdvcmsgd2hlbiBjb252ZXJ0ZWQgdG8gYSBwYXRoLCBldmVuIHRob3VnaFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzIGFuIElEIGl0IGlzIGxlc3MgdGhhbiBpZGVhbC4gSW4gbGFyZ2VyIHBvaW50XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVsZWFzZXMsIG1heSBiZSBiZXR0ZXIgdG8ganVzdCBraWNrIG91dCBhbiBlcnJvci5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCB8fCAoaSA9PT0gMSAmJiBuYW1lWzJdID09PSAnLi4nKSB8fCBuYW1lW2kgLSAxXSA9PT0gJy4uJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUuc3BsaWNlKGkgLSAxLCAyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaSAtPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL2VuZCB0cmltRG90c1xyXG5cclxuICAgICAgICAgICAgbmFtZSA9IG5hbWUuam9pbignLycpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9BcHBseSBtYXAgY29uZmlnIGlmIGF2YWlsYWJsZS5cclxuICAgICAgICBpZiAoKGJhc2VQYXJ0cyB8fCBzdGFyTWFwKSAmJiBtYXApIHtcclxuICAgICAgICAgICAgbmFtZVBhcnRzID0gbmFtZS5zcGxpdCgnLycpO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpID0gbmFtZVBhcnRzLmxlbmd0aDsgaSA+IDA7IGkgLT0gMSkge1xyXG4gICAgICAgICAgICAgICAgbmFtZVNlZ21lbnQgPSBuYW1lUGFydHMuc2xpY2UoMCwgaSkuam9pbihcIi9cIik7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGJhc2VQYXJ0cykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vRmluZCB0aGUgbG9uZ2VzdCBiYXNlTmFtZSBzZWdtZW50IG1hdGNoIGluIHRoZSBjb25maWcuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9TbywgZG8gam9pbnMgb24gdGhlIGJpZ2dlc3QgdG8gc21hbGxlc3QgbGVuZ3RocyBvZiBiYXNlUGFydHMuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gYmFzZVBhcnRzLmxlbmd0aDsgaiA+IDA7IGogLT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBWYWx1ZSA9IG1hcFtiYXNlUGFydHMuc2xpY2UoMCwgaikuam9pbignLycpXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYmFzZU5hbWUgc2VnbWVudCBoYXMgIGNvbmZpZywgZmluZCBpZiBpdCBoYXMgb25lIGZvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RoaXMgbmFtZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hcFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBWYWx1ZSA9IG1hcFZhbHVlW25hbWVTZWdtZW50XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXBWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vTWF0Y2gsIHVwZGF0ZSBuYW1lIHRvIHRoZSBuZXcgdmFsdWUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRNYXAgPSBtYXBWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZEkgPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChmb3VuZE1hcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vQ2hlY2sgZm9yIGEgc3RhciBtYXAgbWF0Y2gsIGJ1dCBqdXN0IGhvbGQgb24gdG8gaXQsXHJcbiAgICAgICAgICAgICAgICAvL2lmIHRoZXJlIGlzIGEgc2hvcnRlciBzZWdtZW50IG1hdGNoIGxhdGVyIGluIGEgbWF0Y2hpbmdcclxuICAgICAgICAgICAgICAgIC8vY29uZmlnLCB0aGVuIGZhdm9yIG92ZXIgdGhpcyBzdGFyIG1hcC5cclxuICAgICAgICAgICAgICAgIGlmICghZm91bmRTdGFyTWFwICYmIHN0YXJNYXAgJiYgc3Rhck1hcFtuYW1lU2VnbWVudF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3VuZFN0YXJNYXAgPSBzdGFyTWFwW25hbWVTZWdtZW50XTtcclxuICAgICAgICAgICAgICAgICAgICBzdGFySSA9IGk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghZm91bmRNYXAgJiYgZm91bmRTdGFyTWFwKSB7XHJcbiAgICAgICAgICAgICAgICBmb3VuZE1hcCA9IGZvdW5kU3Rhck1hcDtcclxuICAgICAgICAgICAgICAgIGZvdW5kSSA9IHN0YXJJO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZm91bmRNYXApIHtcclxuICAgICAgICAgICAgICAgIG5hbWVQYXJ0cy5zcGxpY2UoMCwgZm91bmRJLCBmb3VuZE1hcCk7XHJcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZVBhcnRzLmpvaW4oJy8nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG5hbWU7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbWFrZVJlcXVpcmUocmVsTmFtZSwgZm9yY2VTeW5jKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy9BIHZlcnNpb24gb2YgYSByZXF1aXJlIGZ1bmN0aW9uIHRoYXQgcGFzc2VzIGEgbW9kdWxlTmFtZVxyXG4gICAgICAgICAgICAvL3ZhbHVlIGZvciBpdGVtcyB0aGF0IG1heSBuZWVkIHRvXHJcbiAgICAgICAgICAgIC8vbG9vayB1cCBwYXRocyByZWxhdGl2ZSB0byB0aGUgbW9kdWxlTmFtZVxyXG4gICAgICAgICAgICB2YXIgYXJncyA9IGFwcy5jYWxsKGFyZ3VtZW50cywgMCk7XHJcblxyXG4gICAgICAgICAgICAvL0lmIGZpcnN0IGFyZyBpcyBub3QgcmVxdWlyZSgnc3RyaW5nJyksIGFuZCB0aGVyZSBpcyBvbmx5XHJcbiAgICAgICAgICAgIC8vb25lIGFyZywgaXQgaXMgdGhlIGFycmF5IGZvcm0gd2l0aG91dCBhIGNhbGxiYWNrLiBJbnNlcnRcclxuICAgICAgICAgICAgLy9hIG51bGwgc28gdGhhdCB0aGUgZm9sbG93aW5nIGNvbmNhdCBpcyBjb3JyZWN0LlxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3NbMF0gIT09ICdzdHJpbmcnICYmIGFyZ3MubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2gobnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlcS5hcHBseSh1bmRlZiwgYXJncy5jb25jYXQoW3JlbE5hbWUsIGZvcmNlU3luY10pKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1ha2VOb3JtYWxpemUocmVsTmFtZSkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplKG5hbWUsIHJlbE5hbWUpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbWFrZUxvYWQoZGVwTmFtZSkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgZGVmaW5lZFtkZXBOYW1lXSA9IHZhbHVlO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2FsbERlcChuYW1lKSB7XHJcbiAgICAgICAgaWYgKGhhc1Byb3Aod2FpdGluZywgbmFtZSkpIHtcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSB3YWl0aW5nW25hbWVdO1xyXG4gICAgICAgICAgICBkZWxldGUgd2FpdGluZ1tuYW1lXTtcclxuICAgICAgICAgICAgZGVmaW5pbmdbbmFtZV0gPSB0cnVlO1xyXG4gICAgICAgICAgICBtYWluLmFwcGx5KHVuZGVmLCBhcmdzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaGFzUHJvcChkZWZpbmVkLCBuYW1lKSAmJiAhaGFzUHJvcChkZWZpbmluZywgbmFtZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyAnICsgbmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZWZpbmVkW25hbWVdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vVHVybnMgYSBwbHVnaW4hcmVzb3VyY2UgdG8gW3BsdWdpbiwgcmVzb3VyY2VdXHJcbiAgICAvL3dpdGggdGhlIHBsdWdpbiBiZWluZyB1bmRlZmluZWQgaWYgdGhlIG5hbWVcclxuICAgIC8vZGlkIG5vdCBoYXZlIGEgcGx1Z2luIHByZWZpeC5cclxuICAgIGZ1bmN0aW9uIHNwbGl0UHJlZml4KG5hbWUpIHtcclxuICAgICAgICB2YXIgcHJlZml4LFxyXG4gICAgICAgICAgICBpbmRleCA9IG5hbWUgPyBuYW1lLmluZGV4T2YoJyEnKSA6IC0xO1xyXG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgIHByZWZpeCA9IG5hbWUuc3Vic3RyaW5nKDAsIGluZGV4KTtcclxuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKGluZGV4ICsgMSwgbmFtZS5sZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW3ByZWZpeCwgbmFtZV07XHJcbiAgICB9XHJcblxyXG4gICAgLy9DcmVhdGVzIGEgcGFydHMgYXJyYXkgZm9yIGEgcmVsTmFtZSB3aGVyZSBmaXJzdCBwYXJ0IGlzIHBsdWdpbiBJRCxcclxuICAgIC8vc2Vjb25kIHBhcnQgaXMgcmVzb3VyY2UgSUQuIEFzc3VtZXMgcmVsTmFtZSBoYXMgYWxyZWFkeSBiZWVuIG5vcm1hbGl6ZWQuXHJcbiAgICBmdW5jdGlvbiBtYWtlUmVsUGFydHMocmVsTmFtZSkge1xyXG4gICAgICAgIHJldHVybiByZWxOYW1lID8gc3BsaXRQcmVmaXgocmVsTmFtZSkgOiBbXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1ha2VzIGEgbmFtZSBtYXAsIG5vcm1hbGl6aW5nIHRoZSBuYW1lLCBhbmQgdXNpbmcgYSBwbHVnaW5cclxuICAgICAqIGZvciBub3JtYWxpemF0aW9uIGlmIG5lY2Vzc2FyeS4gR3JhYnMgYSByZWYgdG8gcGx1Z2luXHJcbiAgICAgKiB0b28sIGFzIGFuIG9wdGltaXphdGlvbi5cclxuICAgICAqL1xyXG4gICAgbWFrZU1hcCA9IGZ1bmN0aW9uIChuYW1lLCByZWxQYXJ0cykge1xyXG4gICAgICAgIHZhciBwbHVnaW4sXHJcbiAgICAgICAgICAgIHBhcnRzID0gc3BsaXRQcmVmaXgobmFtZSksXHJcbiAgICAgICAgICAgIHByZWZpeCA9IHBhcnRzWzBdLFxyXG4gICAgICAgICAgICByZWxSZXNvdXJjZU5hbWUgPSByZWxQYXJ0c1sxXTtcclxuXHJcbiAgICAgICAgbmFtZSA9IHBhcnRzWzFdO1xyXG5cclxuICAgICAgICBpZiAocHJlZml4KSB7XHJcbiAgICAgICAgICAgIHByZWZpeCA9IG5vcm1hbGl6ZShwcmVmaXgsIHJlbFJlc291cmNlTmFtZSk7XHJcbiAgICAgICAgICAgIHBsdWdpbiA9IGNhbGxEZXAocHJlZml4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vTm9ybWFsaXplIGFjY29yZGluZ1xyXG4gICAgICAgIGlmIChwcmVmaXgpIHtcclxuICAgICAgICAgICAgaWYgKHBsdWdpbiAmJiBwbHVnaW4ubm9ybWFsaXplKSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lID0gcGx1Z2luLm5vcm1hbGl6ZShuYW1lLCBtYWtlTm9ybWFsaXplKHJlbFJlc291cmNlTmFtZSkpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbmFtZSA9IG5vcm1hbGl6ZShuYW1lLCByZWxSZXNvdXJjZU5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbmFtZSA9IG5vcm1hbGl6ZShuYW1lLCByZWxSZXNvdXJjZU5hbWUpO1xyXG4gICAgICAgICAgICBwYXJ0cyA9IHNwbGl0UHJlZml4KG5hbWUpO1xyXG4gICAgICAgICAgICBwcmVmaXggPSBwYXJ0c1swXTtcclxuICAgICAgICAgICAgbmFtZSA9IHBhcnRzWzFdO1xyXG4gICAgICAgICAgICBpZiAocHJlZml4KSB7XHJcbiAgICAgICAgICAgICAgICBwbHVnaW4gPSBjYWxsRGVwKHByZWZpeCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vVXNpbmcgcmlkaWN1bG91cyBwcm9wZXJ0eSBuYW1lcyBmb3Igc3BhY2UgcmVhc29uc1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGY6IHByZWZpeCA/IHByZWZpeCArICchJyArIG5hbWUgOiBuYW1lLCAvL2Z1bGxOYW1lXHJcbiAgICAgICAgICAgIG46IG5hbWUsXHJcbiAgICAgICAgICAgIHByOiBwcmVmaXgsXHJcbiAgICAgICAgICAgIHA6IHBsdWdpblxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIG1ha2VDb25maWcobmFtZSkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoY29uZmlnICYmIGNvbmZpZy5jb25maWcgJiYgY29uZmlnLmNvbmZpZ1tuYW1lXSkgfHwge307XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBoYW5kbGVycyA9IHtcclxuICAgICAgICByZXF1aXJlOiBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbWFrZVJlcXVpcmUobmFtZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBleHBvcnRzOiBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICB2YXIgZSA9IGRlZmluZWRbbmFtZV07XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChkZWZpbmVkW25hbWVdID0ge30pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtb2R1bGU6IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBpZDogbmFtZSxcclxuICAgICAgICAgICAgICAgIHVyaTogJycsXHJcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBkZWZpbmVkW25hbWVdLFxyXG4gICAgICAgICAgICAgICAgY29uZmlnOiBtYWtlQ29uZmlnKG5hbWUpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBtYWluID0gZnVuY3Rpb24gKG5hbWUsIGRlcHMsIGNhbGxiYWNrLCByZWxOYW1lKSB7XHJcbiAgICAgICAgdmFyIGNqc01vZHVsZSwgZGVwTmFtZSwgcmV0LCBtYXAsIGksIHJlbFBhcnRzLFxyXG4gICAgICAgICAgICBhcmdzID0gW10sXHJcbiAgICAgICAgICAgIGNhbGxiYWNrVHlwZSA9IHR5cGVvZiBjYWxsYmFjayxcclxuICAgICAgICAgICAgdXNpbmdFeHBvcnRzO1xyXG5cclxuICAgICAgICAvL1VzZSBuYW1lIGlmIG5vIHJlbE5hbWVcclxuICAgICAgICByZWxOYW1lID0gcmVsTmFtZSB8fCBuYW1lO1xyXG4gICAgICAgIHJlbFBhcnRzID0gbWFrZVJlbFBhcnRzKHJlbE5hbWUpO1xyXG5cclxuICAgICAgICAvL0NhbGwgdGhlIGNhbGxiYWNrIHRvIGRlZmluZSB0aGUgbW9kdWxlLCBpZiBuZWNlc3NhcnkuXHJcbiAgICAgICAgaWYgKGNhbGxiYWNrVHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgY2FsbGJhY2tUeXBlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIC8vUHVsbCBvdXQgdGhlIGRlZmluZWQgZGVwZW5kZW5jaWVzIGFuZCBwYXNzIHRoZSBvcmRlcmVkXHJcbiAgICAgICAgICAgIC8vdmFsdWVzIHRvIHRoZSBjYWxsYmFjay5cclxuICAgICAgICAgICAgLy9EZWZhdWx0IHRvIFtyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGVdIGlmIG5vIGRlcHNcclxuICAgICAgICAgICAgZGVwcyA9ICFkZXBzLmxlbmd0aCAmJiBjYWxsYmFjay5sZW5ndGggPyBbJ3JlcXVpcmUnLCAnZXhwb3J0cycsICdtb2R1bGUnXSA6IGRlcHM7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBkZXBzLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBtYXAgPSBtYWtlTWFwKGRlcHNbaV0sIHJlbFBhcnRzKTtcclxuICAgICAgICAgICAgICAgIGRlcE5hbWUgPSBtYXAuZjtcclxuXHJcbiAgICAgICAgICAgICAgICAvL0Zhc3QgcGF0aCBDb21tb25KUyBzdGFuZGFyZCBkZXBlbmRlbmNpZXMuXHJcbiAgICAgICAgICAgICAgICBpZiAoZGVwTmFtZSA9PT0gXCJyZXF1aXJlXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBhcmdzW2ldID0gaGFuZGxlcnMucmVxdWlyZShuYW1lKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVwTmFtZSA9PT0gXCJleHBvcnRzXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL0NvbW1vbkpTIG1vZHVsZSBzcGVjIDEuMVxyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbaV0gPSBoYW5kbGVycy5leHBvcnRzKG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHVzaW5nRXhwb3J0cyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRlcE5hbWUgPT09IFwibW9kdWxlXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL0NvbW1vbkpTIG1vZHVsZSBzcGVjIDEuMVxyXG4gICAgICAgICAgICAgICAgICAgIGNqc01vZHVsZSA9IGFyZ3NbaV0gPSBoYW5kbGVycy5tb2R1bGUobmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhhc1Byb3AoZGVmaW5lZCwgZGVwTmFtZSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzUHJvcCh3YWl0aW5nLCBkZXBOYW1lKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNQcm9wKGRlZmluaW5nLCBkZXBOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbaV0gPSBjYWxsRGVwKGRlcE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXAucCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcC5wLmxvYWQobWFwLm4sIG1ha2VSZXF1aXJlKHJlbE5hbWUsIHRydWUpLCBtYWtlTG9hZChkZXBOYW1lKSwge30pO1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbaV0gPSBkZWZpbmVkW2RlcE5hbWVdO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobmFtZSArICcgbWlzc2luZyAnICsgZGVwTmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldCA9IGNhbGxiYWNrID8gY2FsbGJhY2suYXBwbHkoZGVmaW5lZFtuYW1lXSwgYXJncykgOiB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgICBpZiAobmFtZSkge1xyXG4gICAgICAgICAgICAgICAgLy9JZiBzZXR0aW5nIGV4cG9ydHMgdmlhIFwibW9kdWxlXCIgaXMgaW4gcGxheSxcclxuICAgICAgICAgICAgICAgIC8vZmF2b3IgdGhhdCBvdmVyIHJldHVybiB2YWx1ZSBhbmQgZXhwb3J0cy4gQWZ0ZXIgdGhhdCxcclxuICAgICAgICAgICAgICAgIC8vZmF2b3IgYSBub24tdW5kZWZpbmVkIHJldHVybiB2YWx1ZSBvdmVyIGV4cG9ydHMgdXNlLlxyXG4gICAgICAgICAgICAgICAgaWYgKGNqc01vZHVsZSAmJiBjanNNb2R1bGUuZXhwb3J0cyAhPT0gdW5kZWYgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2pzTW9kdWxlLmV4cG9ydHMgIT09IGRlZmluZWRbbmFtZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWZpbmVkW25hbWVdID0gY2pzTW9kdWxlLmV4cG9ydHM7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJldCAhPT0gdW5kZWYgfHwgIXVzaW5nRXhwb3J0cykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vVXNlIHRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgZnVuY3Rpb24uXHJcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lZFtuYW1lXSA9IHJldDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAobmFtZSkge1xyXG4gICAgICAgICAgICAvL01heSBqdXN0IGJlIGFuIG9iamVjdCBkZWZpbml0aW9uIGZvciB0aGUgbW9kdWxlLiBPbmx5XHJcbiAgICAgICAgICAgIC8vd29ycnkgYWJvdXQgZGVmaW5pbmcgaWYgaGF2ZSBhIG1vZHVsZSBuYW1lLlxyXG4gICAgICAgICAgICBkZWZpbmVkW25hbWVdID0gY2FsbGJhY2s7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXF1aXJlanMgPSByZXF1aXJlID0gcmVxID0gZnVuY3Rpb24gKGRlcHMsIGNhbGxiYWNrLCByZWxOYW1lLCBmb3JjZVN5bmMsIGFsdCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZGVwcyA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICBpZiAoaGFuZGxlcnNbZGVwc10pIHtcclxuICAgICAgICAgICAgICAgIC8vY2FsbGJhY2sgaW4gdGhpcyBjYXNlIGlzIHJlYWxseSByZWxOYW1lXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlcnNbZGVwc10oY2FsbGJhY2spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vSnVzdCByZXR1cm4gdGhlIG1vZHVsZSB3YW50ZWQuIEluIHRoaXMgc2NlbmFyaW8sIHRoZVxyXG4gICAgICAgICAgICAvL2RlcHMgYXJnIGlzIHRoZSBtb2R1bGUgbmFtZSwgYW5kIHNlY29uZCBhcmcgKGlmIHBhc3NlZClcclxuICAgICAgICAgICAgLy9pcyBqdXN0IHRoZSByZWxOYW1lLlxyXG4gICAgICAgICAgICAvL05vcm1hbGl6ZSBtb2R1bGUgbmFtZSwgaWYgaXQgY29udGFpbnMgLiBvciAuLlxyXG4gICAgICAgICAgICByZXR1cm4gY2FsbERlcChtYWtlTWFwKGRlcHMsIG1ha2VSZWxQYXJ0cyhjYWxsYmFjaykpLmYpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIWRlcHMuc3BsaWNlKSB7XHJcbiAgICAgICAgICAgIC8vZGVwcyBpcyBhIGNvbmZpZyBvYmplY3QsIG5vdCBhbiBhcnJheS5cclxuICAgICAgICAgICAgY29uZmlnID0gZGVwcztcclxuICAgICAgICAgICAgaWYgKGNvbmZpZy5kZXBzKSB7XHJcbiAgICAgICAgICAgICAgICByZXEoY29uZmlnLmRlcHMsIGNvbmZpZy5jYWxsYmFjayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2suc3BsaWNlKSB7XHJcbiAgICAgICAgICAgICAgICAvL2NhbGxiYWNrIGlzIGFuIGFycmF5LCB3aGljaCBtZWFucyBpdCBpcyBhIGRlcGVuZGVuY3kgbGlzdC5cclxuICAgICAgICAgICAgICAgIC8vQWRqdXN0IGFyZ3MgaWYgdGhlcmUgYXJlIGRlcGVuZGVuY2llc1xyXG4gICAgICAgICAgICAgICAgZGVwcyA9IGNhbGxiYWNrO1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSByZWxOYW1lO1xyXG4gICAgICAgICAgICAgICAgcmVsTmFtZSA9IG51bGw7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkZXBzID0gdW5kZWY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vU3VwcG9ydCByZXF1aXJlKFsnYSddKVxyXG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XHJcblxyXG4gICAgICAgIC8vSWYgcmVsTmFtZSBpcyBhIGZ1bmN0aW9uLCBpdCBpcyBhbiBlcnJiYWNrIGhhbmRsZXIsXHJcbiAgICAgICAgLy9zbyByZW1vdmUgaXQuXHJcbiAgICAgICAgaWYgKHR5cGVvZiByZWxOYW1lID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJlbE5hbWUgPSBmb3JjZVN5bmM7XHJcbiAgICAgICAgICAgIGZvcmNlU3luYyA9IGFsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vU2ltdWxhdGUgYXN5bmMgY2FsbGJhY2s7XHJcbiAgICAgICAgaWYgKGZvcmNlU3luYykge1xyXG4gICAgICAgICAgICBtYWluKHVuZGVmLCBkZXBzLCBjYWxsYmFjaywgcmVsTmFtZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy9Vc2luZyBhIG5vbi16ZXJvIHZhbHVlIGJlY2F1c2Ugb2YgY29uY2VybiBmb3Igd2hhdCBvbGQgYnJvd3NlcnNcclxuICAgICAgICAgICAgLy9kbywgYW5kIGxhdGVzdCBicm93c2VycyBcInVwZ3JhZGVcIiB0byA0IGlmIGxvd2VyIHZhbHVlIGlzIHVzZWQ6XHJcbiAgICAgICAgICAgIC8vaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGltZXJzLmh0bWwjZG9tLXdpbmRvd3RpbWVycy1zZXR0aW1lb3V0OlxyXG4gICAgICAgICAgICAvL0lmIHdhbnQgYSB2YWx1ZSBpbW1lZGlhdGVseSwgdXNlIHJlcXVpcmUoJ2lkJykgaW5zdGVhZCAtLSBzb21ldGhpbmdcclxuICAgICAgICAgICAgLy90aGF0IHdvcmtzIGluIGFsbW9uZCBvbiB0aGUgZ2xvYmFsIGxldmVsLCBidXQgbm90IGd1YXJhbnRlZWQgYW5kXHJcbiAgICAgICAgICAgIC8vdW5saWtlbHkgdG8gd29yayBpbiBvdGhlciBBTUQgaW1wbGVtZW50YXRpb25zLlxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIG1haW4odW5kZWYsIGRlcHMsIGNhbGxiYWNrLCByZWxOYW1lKTtcclxuICAgICAgICAgICAgfSwgNCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVxO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEp1c3QgZHJvcHMgdGhlIGNvbmZpZyBvbiB0aGUgZmxvb3IsIGJ1dCByZXR1cm5zIHJlcSBpbiBjYXNlXHJcbiAgICAgKiB0aGUgY29uZmlnIHJldHVybiB2YWx1ZSBpcyB1c2VkLlxyXG4gICAgICovXHJcbiAgICByZXEuY29uZmlnID0gZnVuY3Rpb24gKGNmZykge1xyXG4gICAgICAgIHJldHVybiByZXEoY2ZnKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHBvc2UgbW9kdWxlIHJlZ2lzdHJ5IGZvciBkZWJ1Z2dpbmcgYW5kIHRvb2xpbmdcclxuICAgICAqL1xyXG4gICAgcmVxdWlyZWpzLl9kZWZpbmVkID0gZGVmaW5lZDtcclxuXHJcbiAgICBkZWZpbmUgPSBmdW5jdGlvbiAobmFtZSwgZGVwcywgY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2VlIGFsbW9uZCBSRUFETUU6IGluY29ycmVjdCBtb2R1bGUgYnVpbGQsIG5vIG1vZHVsZSBuYW1lJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL1RoaXMgbW9kdWxlIG1heSBub3QgaGF2ZSBkZXBlbmRlbmNpZXNcclxuICAgICAgICBpZiAoIWRlcHMuc3BsaWNlKSB7XHJcbiAgICAgICAgICAgIC8vZGVwcyBpcyBub3QgYW4gYXJyYXksIHNvIHByb2JhYmx5IG1lYW5zXHJcbiAgICAgICAgICAgIC8vYW4gb2JqZWN0IGxpdGVyYWwgb3IgZmFjdG9yeSBmdW5jdGlvbiBmb3JcclxuICAgICAgICAgICAgLy90aGUgdmFsdWUuIEFkanVzdCBhcmdzLlxyXG4gICAgICAgICAgICBjYWxsYmFjayA9IGRlcHM7XHJcbiAgICAgICAgICAgIGRlcHMgPSBbXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaGFzUHJvcChkZWZpbmVkLCBuYW1lKSAmJiAhaGFzUHJvcCh3YWl0aW5nLCBuYW1lKSkge1xyXG4gICAgICAgICAgICB3YWl0aW5nW25hbWVdID0gW25hbWUsIGRlcHMsIGNhbGxiYWNrXTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGRlZmluZS5hbWQgPSB7XHJcbiAgICAgICAgalF1ZXJ5OiB0cnVlXHJcbiAgICB9O1xyXG59KCkpO1xyXG4vKiEgZXhjYWxpYnVyIC0gdjAuMTUuMCAtIDIwMTgtMDItMTdcclxuKiBodHRwczovL2dpdGh1Yi5jb20vZXhjYWxpYnVyanMvRXhjYWxpYnVyXHJcbiogQ29weXJpZ2h0IChjKSAyMDE4IEV4Y2FsaWJ1ci5qcyA8aHR0cHM6Ly9naXRodWIuY29tL2V4Y2FsaWJ1cmpzL0V4Y2FsaWJ1ci9ncmFwaHMvY29udHJpYnV0b3JzPjsgTGljZW5zZWQgQlNELTItQ2xhdXNlXHJcbiogQHByZXNlcnZlICovXHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5kZWZpbmUoXCJBY3Rpb25zL1JvdGF0aW9uVHlwZVwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBlbnVtIHRoYXQgZGVzY3JpYmVzIHRoZSBzdHJhdGVnaWVzIHRoYXQgcm90YXRpb24gYWN0aW9ucyBjYW4gdXNlXHJcbiAgICAgKi9cclxuICAgIHZhciBSb3RhdGlvblR5cGU7XHJcbiAgICAoZnVuY3Rpb24gKFJvdGF0aW9uVHlwZSkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJvdGF0aW9uIHZpYSBgU2hvcnRlc3RQYXRoYCB3aWxsIHVzZSB0aGUgc21hbGxlc3QgYW5nbGVcclxuICAgICAgICAgKiBiZXR3ZWVuIHRoZSBzdGFydGluZyBhbmQgZW5kaW5nIHBvaW50cy4gVGhpcyBzdHJhdGVneSBpcyB0aGUgZGVmYXVsdCBiZWhhdmlvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBSb3RhdGlvblR5cGVbUm90YXRpb25UeXBlW1wiU2hvcnRlc3RQYXRoXCJdID0gMF0gPSBcIlNob3J0ZXN0UGF0aFwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJvdGF0aW9uIHZpYSBgTG9uZ2VzdFBhdGhgIHdpbGwgdXNlIHRoZSBsYXJnZXN0IGFuZ2xlXHJcbiAgICAgICAgICogYmV0d2VlbiB0aGUgc3RhcnRpbmcgYW5kIGVuZGluZyBwb2ludHMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUm90YXRpb25UeXBlW1JvdGF0aW9uVHlwZVtcIkxvbmdlc3RQYXRoXCJdID0gMV0gPSBcIkxvbmdlc3RQYXRoXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUm90YXRpb24gdmlhIGBDbG9ja3dpc2VgIHdpbGwgdHJhdmVsIGluIGEgY2xvY2t3aXNlIGRpcmVjdGlvbixcclxuICAgICAgICAgKiByZWdhcmRsZXNzIG9mIHRoZSBzdGFydGluZyBhbmQgZW5kaW5nIHBvaW50cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBSb3RhdGlvblR5cGVbUm90YXRpb25UeXBlW1wiQ2xvY2t3aXNlXCJdID0gMl0gPSBcIkNsb2Nrd2lzZVwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJvdGF0aW9uIHZpYSBgQ291bnRlckNsb2Nrd2lzZWAgd2lsbCB0cmF2ZWwgaW4gYSBjb3VudGVyY2xvY2t3aXNlIGRpcmVjdGlvbixcclxuICAgICAgICAgKiByZWdhcmRsZXNzIG9mIHRoZSBzdGFydGluZyBhbmQgZW5kaW5nIHBvaW50cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBSb3RhdGlvblR5cGVbUm90YXRpb25UeXBlW1wiQ291bnRlckNsb2Nrd2lzZVwiXSA9IDNdID0gXCJDb3VudGVyQ2xvY2t3aXNlXCI7XHJcbiAgICB9KShSb3RhdGlvblR5cGUgPSBleHBvcnRzLlJvdGF0aW9uVHlwZSB8fCAoZXhwb3J0cy5Sb3RhdGlvblR5cGUgPSB7fSkpO1xyXG59KTtcclxuZGVmaW5lKFwiQWxnZWJyYVwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIDJEIHZlY3RvciBvbiBhIHBsYW5lLlxyXG4gICAgICovXHJcbiAgICB2YXIgVmVjdG9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0geCAgWCBjb21wb25lbnQgb2YgdGhlIFZlY3RvclxyXG4gICAgICAgICAqIEBwYXJhbSB5ICBZIGNvbXBvbmVudCBvZiB0aGUgVmVjdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gVmVjdG9yKHgsIHkpIHtcclxuICAgICAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIHZlY3RvciBvZiB1bml0IGxlbmd0aCBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBzcGVjaWZpZWQgYW5nbGUgaW4gUmFkaWFucy5cclxuICAgICAgICAgKiBAcGFyYW0gYW5nbGUgVGhlIGFuZ2xlIHRvIGdlbmVyYXRlIHRoZSB2ZWN0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBWZWN0b3IuZnJvbUFuZ2xlID0gZnVuY3Rpb24gKGFuZ2xlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKE1hdGguY29zKGFuZ2xlKSwgTWF0aC5zaW4oYW5nbGUpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrcyBpZiB2ZWN0b3IgaXMgbm90IG51bGwsIHVuZGVmaW5lZCwgb3IgaWYgYW55IG9mIGl0cyBjb21wb25lbnRzIGFyZSBOYU4gb3IgSW5maW5pdHkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVmVjdG9yLmlzVmFsaWQgPSBmdW5jdGlvbiAodmVjKSB7XHJcbiAgICAgICAgICAgIGlmICh2ZWMgPT09IG51bGwgfHwgdmVjID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNOYU4odmVjLngpIHx8IGlzTmFOKHZlYy55KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2ZWMueCA9PT0gSW5maW5pdHkgfHxcclxuICAgICAgICAgICAgICAgIHZlYy55ID09PSBJbmZpbml0eSB8fFxyXG4gICAgICAgICAgICAgICAgdmVjLnggPT09IC1JbmZpbml0eSB8fFxyXG4gICAgICAgICAgICAgICAgdmVjLnkgPT09IEluZmluaXR5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxjdWxhdGVzIGRpc3RhbmNlIGJldHdlZW4gdHdvIFZlY3RvcnNcclxuICAgICAgICAgKiBAcGFyYW0gdmVjMVxyXG4gICAgICAgICAqIEBwYXJhbSB2ZWMyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVmVjdG9yLmRpc3RhbmNlID0gZnVuY3Rpb24gKHZlYzEsIHZlYzIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh2ZWMxLnggLSB2ZWMyLngsIDIpICsgTWF0aC5wb3codmVjMS55IC0gdmVjMi55LCAyKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSB4IGFuZCB5IGNvbXBvbmVudHMgYXQgb25jZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUuc2V0VG8gPSBmdW5jdGlvbiAoeCwgeSkge1xyXG4gICAgICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29tcGFyZXMgdGhpcyBwb2ludCBhZ2FpbnN0IGFub3RoZXIgYW5kIHRlc3RzIGZvciBlcXVhbGl0eVxyXG4gICAgICAgICAqIEBwYXJhbSBwb2ludCAgVGhlIG90aGVyIHBvaW50IHRvIGNvbXBhcmUgdG9cclxuICAgICAgICAgKi9cclxuICAgICAgICBWZWN0b3IucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uICh2ZWN0b3IsIHRvbGVyYW5jZSkge1xyXG4gICAgICAgICAgICBpZiAodG9sZXJhbmNlID09PSB2b2lkIDApIHsgdG9sZXJhbmNlID0gLjAwMTsgfVxyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnModGhpcy54IC0gdmVjdG9yLngpIDw9IHRvbGVyYW5jZSAmJiBNYXRoLmFicyh0aGlzLnkgLSB2ZWN0b3IueSkgPD0gdG9sZXJhbmNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGRpc3RhbmNlIHRvIGFub3RoZXIgdmVjdG9yLiBJZiBubyBvdGhlciBWZWN0b3IgaXMgc3BlY2lmaWVkLCB0aGlzIHdpbGwgcmV0dXJuIHRoZSBbW21hZ25pdHVkZV1dLlxyXG4gICAgICAgICAqIEBwYXJhbSB2ICBUaGUgb3RoZXIgdmVjdG9yLiBMZWF2ZSBibGFuayB0byB1c2Ugb3JpZ2luIHZlY3Rvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBWZWN0b3IucHJvdG90eXBlLmRpc3RhbmNlID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgaWYgKCF2KSB7XHJcbiAgICAgICAgICAgICAgICB2ID0gVmVjdG9yLlplcm87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh0aGlzLnggLSB2LngsIDIpICsgTWF0aC5wb3codGhpcy55IC0gdi55LCAyKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbWFnbml0dWRlIChzaXplKSBvZiB0aGUgVmVjdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS5tYWduaXR1ZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpc3RhbmNlKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBOb3JtYWxpemVzIGEgdmVjdG9yIHRvIGhhdmUgYSBtYWduaXR1ZGUgb2YgMS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBWZWN0b3IucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGQgPSB0aGlzLmRpc3RhbmNlKCk7XHJcbiAgICAgICAgICAgIGlmIChkID4gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy54IC8gZCwgdGhpcy55IC8gZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvcigwLCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgYXZlcmFnZSAobWlkcG9pbnQpIGJldHdlZW4gdGhlIGN1cnJlbnQgcG9pbnQgYW5kIHRoZSBzcGVjaWZpZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBWZWN0b3IucHJvdG90eXBlLmF2ZXJhZ2UgPSBmdW5jdGlvbiAodmVjKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZCh2ZWMpLnNjYWxlKC41KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNjYWxlcyBhIHZlY3RvcidzIGJ5IGEgZmFjdG9yIG9mIHNpemVcclxuICAgICAgICAgKiBAcGFyYW0gc2l6ZSAgVGhlIGZhY3RvciB0byBzY2FsZSB0aGUgbWFnbml0dWRlIGJ5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uIChzaXplKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMueCAqIHNpemUsIHRoaXMueSAqIHNpemUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBvbmUgdmVjdG9yIHRvIGFub3RoZXJcclxuICAgICAgICAgKiBAcGFyYW0gdiBUaGUgdmVjdG9yIHRvIGFkZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy54ICsgdi54LCB0aGlzLnkgKyB2LnkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3VidHJhY3RzIGEgdmVjdG9yIGZyb20gYW5vdGhlciwgaWYgeW91IHN1YnJhY3QgdmVjdG9yIGBCLnN1YihBKWAgdGhlIHJlc3VsdGluZyB2ZWN0b3IgcG9pbnRzIGZyb20gQSAtPiBCXHJcbiAgICAgICAgICogQHBhcmFtIHYgVGhlIHZlY3RvciB0byBzdWJ0cmFjdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy54IC0gdi54LCB0aGlzLnkgLSB2LnkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBvbmUgdmVjdG9yIHRvIHRoaXMgb25lIG1vZGlmeWluZyB0aGUgb3JpZ2luYWxcclxuICAgICAgICAgKiBAcGFyYW0gdiBUaGUgdmVjdG9yIHRvIGFkZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUuYWRkRXF1YWwgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICB0aGlzLnggKz0gdi54O1xyXG4gICAgICAgICAgICB0aGlzLnkgKz0gdi55O1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN1YnRyYWN0cyBhIHZlY3RvciBmcm9tIHRoaXMgb25lIG1vZGlmeWluZyB0aGUgb3JpZ2luYWxcclxuICAgICAgICAgKiBAcGFyYWxsZWwgdiBUaGUgdmVjdG9yIHRvIHN1YnRyYWN0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS5zdWJFcXVhbCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIHRoaXMueCAtPSB2Lng7XHJcbiAgICAgICAgICAgIHRoaXMueSAtPSB2Lnk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2NhbGVzIHRoaXMgdmVjdG9yIGJ5IGEgZmFjdG9yIG9mIHNpemUgYW5kIG1vZGlmaWVzIHRoZSBvcmlnaW5hbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUuc2NhbGVFcXVhbCA9IGZ1bmN0aW9uIChzaXplKSB7XHJcbiAgICAgICAgICAgIHRoaXMueCAqPSBzaXplO1xyXG4gICAgICAgICAgICB0aGlzLnkgKj0gc2l6ZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQZXJmb3JtcyBhIGRvdCBwcm9kdWN0IHdpdGggYW5vdGhlciB2ZWN0b3JcclxuICAgICAgICAgKiBAcGFyYW0gdiAgVGhlIHZlY3RvciB0byBkb3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBWZWN0b3IucHJvdG90eXBlLmRvdCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2Lnk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBWZWN0b3IucHJvdG90eXBlLmNyb3NzID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgaWYgKHYgaW5zdGFuY2VvZiBWZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnggKiB2LnkgLSB0aGlzLnkgKiB2Lng7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHYgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih2ICogdGhpcy55LCAtdiAqIHRoaXMueCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIHBlcnBlbmRpY3VsYXIgdmVjdG9yIHRvIHRoaXMgb25lXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS5wZXJwZW5kaWN1bGFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLnksIC10aGlzLngpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgbm9ybWFsIHZlY3RvciB0byB0aGlzIG9uZSwgc2FtZSBhcyB0aGUgcGVycGVuZGljdWxhciBvZiBsZW5ndGggMVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUubm9ybWFsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wZXJwZW5kaWN1bGFyKCkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBOZWdhdGUgdGhlIGN1cnJlbnQgdmVjdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYWxlKC0xKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIGFuZ2xlIG9mIHRoaXMgdmVjdG9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUudG9BbmdsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIodGhpcy55LCB0aGlzLngpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUm90YXRlcyB0aGUgY3VycmVudCB2ZWN0b3IgYXJvdW5kIGEgcG9pbnQgYnkgYSBjZXJ0YWluIG51bWJlciBvZlxyXG4gICAgICAgICAqIGRlZ3JlZXMgaW4gcmFkaWFuc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUucm90YXRlID0gZnVuY3Rpb24gKGFuZ2xlLCBhbmNob3IpIHtcclxuICAgICAgICAgICAgaWYgKCFhbmNob3IpIHtcclxuICAgICAgICAgICAgICAgIGFuY2hvciA9IG5ldyBWZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHNpbkFuZ2xlID0gTWF0aC5zaW4oYW5nbGUpO1xyXG4gICAgICAgICAgICB2YXIgY29zQW5nbGUgPSBNYXRoLmNvcyhhbmdsZSk7XHJcbiAgICAgICAgICAgIHZhciB4ID0gY29zQW5nbGUgKiAodGhpcy54IC0gYW5jaG9yLngpIC0gc2luQW5nbGUgKiAodGhpcy55IC0gYW5jaG9yLnkpICsgYW5jaG9yLng7XHJcbiAgICAgICAgICAgIHZhciB5ID0gc2luQW5nbGUgKiAodGhpcy54IC0gYW5jaG9yLngpICsgY29zQW5nbGUgKiAodGhpcy55IC0gYW5jaG9yLnkpICsgYW5jaG9yLnk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHgsIHkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBuZXcgdmVjdG9yIHRoYXQgaGFzIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGUgcHJldmlvdXMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy54LCB0aGlzLnkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIHN0cmluZyByZXBlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiKFwiICsgdGhpcy54ICsgXCIsIFwiICsgdGhpcy55ICsgXCIpXCI7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gVmVjdG9yO1xyXG4gICAgfSgpKTtcclxuICAgIC8qKlxyXG4gICAgICogQSAoMCwgMCkgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIFZlY3Rvci5aZXJvID0gbmV3IFZlY3RvcigwLCAwKTtcclxuICAgIC8qKlxyXG4gICAgICogQSAoMSwgMSkgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIFZlY3Rvci5PbmUgPSBuZXcgVmVjdG9yKDEsIDEpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBICgwLjUsIDAuNSkgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIFZlY3Rvci5IYWxmID0gbmV3IFZlY3RvcigwLjUsIDAuNSk7XHJcbiAgICAvKipcclxuICAgICAqIEEgdW5pdCB2ZWN0b3IgcG9pbnRpbmcgdXAgKDAsIC0xKVxyXG4gICAgICovXHJcbiAgICBWZWN0b3IuVXAgPSBuZXcgVmVjdG9yKDAsIC0xKTtcclxuICAgIC8qKlxyXG4gICAgICogQSB1bml0IHZlY3RvciBwb2ludGluZyBkb3duICgwLCAxKVxyXG4gICAgICovXHJcbiAgICBWZWN0b3IuRG93biA9IG5ldyBWZWN0b3IoMCwgMSk7XHJcbiAgICAvKipcclxuICAgICAqIEEgdW5pdCB2ZWN0b3IgcG9pbnRpbmcgbGVmdCAoLTEsIDApXHJcbiAgICAgKi9cclxuICAgIFZlY3Rvci5MZWZ0ID0gbmV3IFZlY3RvcigtMSwgMCk7XHJcbiAgICAvKipcclxuICAgICAqIEEgdW5pdCB2ZWN0b3IgcG9pbnRpbmcgcmlnaHQgKDEsIDApXHJcbiAgICAgKi9cclxuICAgIFZlY3Rvci5SaWdodCA9IG5ldyBWZWN0b3IoMSwgMCk7XHJcbiAgICBleHBvcnRzLlZlY3RvciA9IFZlY3RvcjtcclxuICAgIC8qKlxyXG4gICAgICogQSAyRCByYXkgdGhhdCBjYW4gYmUgY2FzdCBpbnRvIHRoZSBzY2VuZSB0byBkbyBjb2xsaXNpb24gZGV0ZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIHZhciBSYXkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBwb3MgVGhlIHN0YXJ0aW5nIHBvc2l0aW9uIGZvciB0aGUgcmF5XHJcbiAgICAgICAgICogQHBhcmFtIGRpciBUaGUgdmVjdG9yIGluZGljYXRpbmcgdGhlIGRpcmVjdGlvbiBvZiB0aGUgcmF5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gUmF5KHBvcywgZGlyKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9zID0gcG9zO1xyXG4gICAgICAgICAgICB0aGlzLmRpciA9IGRpci5ub3JtYWxpemUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVzdHMgYSB3aGV0aGVyIHRoaXMgcmF5IGludGVyc2VjdHMgd2l0aCBhIGxpbmUgc2VnbWVudC4gUmV0dXJucyBhIG51bWJlciBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCBvbiBzdWNjZXNzLlxyXG4gICAgICAgICAqIFRoaXMgbnVtYmVyIGluZGljYXRlcyB0aGUgbWF0aGVtYXRpY2FsIGludGVyc2VjdGlvbiB0aW1lLlxyXG4gICAgICAgICAqIEBwYXJhbSBsaW5lICBUaGUgbGluZSB0byB0ZXN0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmF5LnByb3RvdHlwZS5pbnRlcnNlY3QgPSBmdW5jdGlvbiAobGluZSkge1xyXG4gICAgICAgICAgICB2YXIgbnVtZXJhdG9yID0gbGluZS5iZWdpbi5zdWIodGhpcy5wb3MpO1xyXG4gICAgICAgICAgICAvLyBUZXN0IGlzIGxpbmUgYW5kIHJheSBhcmUgcGFyYWxsZWwgYW5kIG5vbiBpbnRlcnNlY3RpbmdcclxuICAgICAgICAgICAgaWYgKHRoaXMuZGlyLmNyb3NzKGxpbmUuZ2V0U2xvcGUoKSkgPT09IDAgJiYgbnVtZXJhdG9yLmNyb3NzKHRoaXMuZGlyKSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIExpbmVzIGFyZSBwYXJhbGxlbFxyXG4gICAgICAgICAgICB2YXIgZGl2aXNvciA9ICh0aGlzLmRpci5jcm9zcyhsaW5lLmdldFNsb3BlKCkpKTtcclxuICAgICAgICAgICAgaWYgKGRpdmlzb3IgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdCA9IG51bWVyYXRvci5jcm9zcyhsaW5lLmdldFNsb3BlKCkpIC8gZGl2aXNvcjtcclxuICAgICAgICAgICAgaWYgKHQgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHUgPSAobnVtZXJhdG9yLmNyb3NzKHRoaXMuZGlyKSAvIGRpdmlzb3IpIC8gbGluZS5nZXRMZW5ndGgoKTtcclxuICAgICAgICAgICAgICAgIGlmICh1ID49IDAgJiYgdSA8PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgcG9pbnQgb2YgaW50ZXJzZWN0aW9uIGdpdmVuIHRoZSBpbnRlcnNlY3Rpb24gdGltZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJheS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAodGltZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3MuYWRkKHRoaXMuZGlyLnNjYWxlKHRpbWUpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBSYXk7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5SYXkgPSBSYXk7XHJcbiAgICAvKipcclxuICAgICAqIEEgMkQgbGluZSBzZWdtZW50XHJcbiAgICAgKi9cclxuICAgIHZhciBMaW5lID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gYmVnaW4gIFRoZSBzdGFydGluZyBwb2ludCBvZiB0aGUgbGluZSBzZWdtZW50XHJcbiAgICAgICAgICogQHBhcmFtIGVuZCAgVGhlIGVuZGluZyBwb2ludCBvZiB0aGUgbGluZSBzZWdtZW50XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gTGluZShiZWdpbiwgZW5kKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmVnaW4gPSBiZWdpbjtcclxuICAgICAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMaW5lLnByb3RvdHlwZSwgXCJzbG9wZVwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSByYXcgc2xvcGUgKG0pIG9mIHRoZSBsaW5lLiBXaWxsIHJldHVybiAoKy8tKUluZmluaXR5IGZvciB2ZXJ0aWNhbCBsaW5lcy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmVuZC55IC0gdGhpcy5iZWdpbi55KSAvICh0aGlzLmVuZC54IC0gdGhpcy5iZWdpbi54KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExpbmUucHJvdG90eXBlLCBcImludGVyY2VwdFwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBZLWludGVyY2VwdCAoYikgb2YgdGhlIGxpbmUuIFdpbGwgcmV0dXJuICgrLy0pSW5maW5pdHkgaWYgdGhlcmUgaXMgbm8gaW50ZXJjZXB0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5iZWdpbi55IC0gKHRoaXMuc2xvcGUgKiB0aGlzLmJlZ2luLngpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBub3JtYWwgb2YgdGhlIGxpbmVcclxuICAgICAgICAgKi9cclxuICAgICAgICBMaW5lLnByb3RvdHlwZS5ub3JtYWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuZC5zdWIodGhpcy5iZWdpbikubm9ybWFsKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBzbG9wZSBvZiB0aGUgbGluZSBpbiB0aGUgZm9ybSBvZiBhIHZlY3RvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpbmUucHJvdG90eXBlLmdldFNsb3BlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYmVnaW4gPSB0aGlzLmJlZ2luO1xyXG4gICAgICAgICAgICB2YXIgZW5kID0gdGhpcy5lbmQ7XHJcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IGJlZ2luLmRpc3RhbmNlKGVuZCk7XHJcbiAgICAgICAgICAgIHJldHVybiBlbmQuc3ViKGJlZ2luKS5zY2FsZSgxIC8gZGlzdGFuY2UpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSBsaW5lIHNlZ21lbnQgaW4gcGl4ZWxzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGluZS5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYmVnaW4gPSB0aGlzLmJlZ2luO1xyXG4gICAgICAgICAgICB2YXIgZW5kID0gdGhpcy5lbmQ7XHJcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IGJlZ2luLmRpc3RhbmNlKGVuZCk7XHJcbiAgICAgICAgICAgIHJldHVybiBkaXN0YW5jZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZpbmQgdGhlIHBlcnBlbmRpY3VsYXIgZGlzdGFuY2UgZnJvbSB0aGUgbGluZSB0byBhIHBvaW50XHJcbiAgICAgICAgICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGlzdGFuY2VfZnJvbV9hX3BvaW50X3RvX2FfbGluZVxyXG4gICAgICAgICAqIEBwYXJhbSBwb2ludFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpbmUucHJvdG90eXBlLmRpc3RhbmNlVG9Qb2ludCA9IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gICAgICAgICAgICB2YXIgeDAgPSBwb2ludC54O1xyXG4gICAgICAgICAgICB2YXIgeTAgPSBwb2ludC55O1xyXG4gICAgICAgICAgICB2YXIgbCA9IHRoaXMuZ2V0TGVuZ3RoKCk7XHJcbiAgICAgICAgICAgIHZhciBkeSA9IHRoaXMuZW5kLnkgLSB0aGlzLmJlZ2luLnk7XHJcbiAgICAgICAgICAgIHZhciBkeCA9IHRoaXMuZW5kLnggLSB0aGlzLmJlZ2luLng7XHJcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguYWJzKGR5ICogeDAgLSBkeCAqIHkwICsgdGhpcy5lbmQueCAqIHRoaXMuYmVnaW4ueSAtIHRoaXMuZW5kLnkgKiB0aGlzLmJlZ2luLngpIC8gbDtcclxuICAgICAgICAgICAgcmV0dXJuIGRpc3RhbmNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmluZHMgYSBwb2ludCBvbiB0aGUgbGluZSBnaXZlbiBvbmx5IGFuIFggb3IgYSBZIHZhbHVlLiBHaXZlbiBhbiBYIHZhbHVlLCB0aGUgZnVuY3Rpb24gcmV0dXJuc1xyXG4gICAgICAgICAqIGEgbmV3IHBvaW50IHdpdGggdGhlIGNhbGN1bGF0ZWQgWSB2YWx1ZSBhbmQgdmljZS12ZXJzYS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB4IFRoZSBrbm93biBYIHZhbHVlIG9mIHRoZSB0YXJnZXQgcG9pbnRcclxuICAgICAgICAgKiBAcGFyYW0geSBUaGUga25vd24gWSB2YWx1ZSBvZiB0aGUgdGFyZ2V0IHBvaW50XHJcbiAgICAgICAgICogQHJldHVybnMgQSBuZXcgcG9pbnQgd2l0aCB0aGUgb3RoZXIgY2FsY3VsYXRlZCBheGlzIHZhbHVlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGluZS5wcm90b3R5cGUuZmluZFBvaW50ID0gZnVuY3Rpb24gKHgsIHkpIHtcclxuICAgICAgICAgICAgaWYgKHggPT09IHZvaWQgMCkgeyB4ID0gbnVsbDsgfVxyXG4gICAgICAgICAgICBpZiAoeSA9PT0gdm9pZCAwKSB7IHkgPSBudWxsOyB9XHJcbiAgICAgICAgICAgIHZhciBtID0gdGhpcy5zbG9wZTtcclxuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLmludGVyY2VwdDtcclxuICAgICAgICAgICAgaWYgKHggIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHgsIChtICogeCkgKyBiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh5ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvcigoeSAtIGIpIC8gbSwgeSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgYW4gWCBvciBhIFkgdmFsdWUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMTkwODE1OC8xMDk0NThcclxuICAgICAgICAgKi9cclxuICAgICAgICBMaW5lLnByb3RvdHlwZS5oYXNQb2ludCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGN1cnJQb2ludDtcclxuICAgICAgICAgICAgdmFyIHRocmVzaG9sZCA9IDA7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnbnVtYmVyJyAmJlxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJQb2ludCA9IG5ldyBWZWN0b3IoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0pO1xyXG4gICAgICAgICAgICAgICAgdGhyZXNob2xkID0gYXJndW1lbnRzWzJdIHx8IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgVmVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyUG9pbnQgPSBhcmd1bWVudHNbMF07XHJcbiAgICAgICAgICAgICAgICB0aHJlc2hvbGQgPSBhcmd1bWVudHNbMV0gfHwgMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93ICdDb3VsZCBub3QgZGV0ZXJtaW5lIHRoZSBhcmd1bWVudHMgZm9yIFZlY3Rvci5oYXNQb2ludCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGR4YyA9IGN1cnJQb2ludC54IC0gdGhpcy5iZWdpbi54O1xyXG4gICAgICAgICAgICB2YXIgZHljID0gY3VyclBvaW50LnkgLSB0aGlzLmJlZ2luLnk7XHJcbiAgICAgICAgICAgIHZhciBkeDEgPSB0aGlzLmVuZC54IC0gdGhpcy5iZWdpbi54O1xyXG4gICAgICAgICAgICB2YXIgZHkxID0gdGhpcy5lbmQueSAtIHRoaXMuYmVnaW4ueTtcclxuICAgICAgICAgICAgdmFyIGNyb3NzID0gZHhjICogZHkxIC0gZHljICogZHgxO1xyXG4gICAgICAgICAgICAvLyBjaGVjayB3aGV0aGVyIHBvaW50IGxpbmVzIG9uIHRoZSBsaW5lXHJcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhjcm9zcykgPiB0aHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjaGVjayB3aGV0aGVyIHBvaW50IGxpZXMgaW4tYmV0d2VlbiBzdGFydCBhbmQgZW5kXHJcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhkeDEpID49IE1hdGguYWJzKGR5MSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkeDEgPiAwXHJcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmJlZ2luLnggPD0gY3VyclBvaW50LnggJiYgY3VyclBvaW50LnggPD0gdGhpcy5lbmQueFxyXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5lbmQueCA8PSBjdXJyUG9pbnQueCAmJiBjdXJyUG9pbnQueCA8PSB0aGlzLmJlZ2luLng7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZHkxID4gMFxyXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5iZWdpbi55IDw9IGN1cnJQb2ludC55ICYmIGN1cnJQb2ludC55IDw9IHRoaXMuZW5kLnlcclxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuZW5kLnkgPD0gY3VyclBvaW50LnkgJiYgY3VyclBvaW50LnkgPD0gdGhpcy5iZWdpbi55O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gTGluZTtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkxpbmUgPSBMaW5lO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIDEgZGltZW5zaW9uYWwgcHJvamVjdGlvbiBvbiBhbiBheGlzLCB1c2VkIHRvIHRlc3Qgb3ZlcmxhcHNcclxuICAgICAqL1xyXG4gICAgdmFyIFByb2plY3Rpb24gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIFByb2plY3Rpb24obWluLCBtYXgpIHtcclxuICAgICAgICAgICAgdGhpcy5taW4gPSBtaW47XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gbWF4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBQcm9qZWN0aW9uLnByb3RvdHlwZS5vdmVybGFwcyA9IGZ1bmN0aW9uIChwcm9qZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1heCA+IHByb2plY3Rpb24ubWluICYmIHByb2plY3Rpb24ubWF4ID4gdGhpcy5taW47XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQcm9qZWN0aW9uLnByb3RvdHlwZS5nZXRPdmVybGFwID0gZnVuY3Rpb24gKHByb2plY3Rpb24pIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMub3ZlcmxhcHMocHJvamVjdGlvbikpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1heCA+IHByb2plY3Rpb24ubWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb2plY3Rpb24ubWF4IC0gdGhpcy5taW47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYXggLSBwcm9qZWN0aW9uLm1pbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBQcm9qZWN0aW9uO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuUHJvamVjdGlvbiA9IFByb2plY3Rpb247XHJcbn0pO1xyXG5kZWZpbmUoXCJQaHlzaWNzXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiQWxnZWJyYVwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIEFsZ2VicmFfMSkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIFBvc3NpYmxlIGNvbGxpc2lvbiByZXNvbHV0aW9uIHN0cmF0ZWdpZXNcclxuICAgICAqXHJcbiAgICAgKiBUaGUgZGVmYXVsdCBpcyBbW0NvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneS5Cb3hdXSB3aGljaCBwZXJmb3JtcyBzaW1wbGUgYXhpcyBhbGlnbmVkIGFyY2FkZSBzdHlsZSBwaHlzaWNzLlxyXG4gICAgICpcclxuICAgICAqIE1vcmUgYWR2YW5jZWQgcmlnaWQgYm9keSBwaHlzaWNzIGFyZSBlbmFibGVkIGJ5IHNldHRpbmcgW1tDb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kuUmlnaWRCb2R5XV0gd2hpY2ggYWxsb3dzIGZvciBjb21wbGljYXRlZFxyXG4gICAgICogc2ltdWxhdGVkIHBoeXNpY2FsIGludGVyYWN0aW9ucy5cclxuICAgICAqL1xyXG4gICAgdmFyIENvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneTtcclxuICAgIChmdW5jdGlvbiAoQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5KSB7XHJcbiAgICAgICAgQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5W0NvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneVtcIkJveFwiXSA9IDBdID0gXCJCb3hcIjtcclxuICAgICAgICBDb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3lbQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5W1wiUmlnaWRCb2R5XCJdID0gMV0gPSBcIlJpZ2lkQm9keVwiO1xyXG4gICAgfSkoQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5ID0gZXhwb3J0cy5Db2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kgfHwgKGV4cG9ydHMuQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5ID0ge30pKTtcclxuICAgIC8qKlxyXG4gICAgICogUG9zc2libGUgYnJvYWRwaGFzZSBjb2xsaXNpb24gcGFpciBpZGVudGlmaWNhdGlvbiBzdHJhdGVnaWVzXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGRlZmF1bHQgc3RyYXRlZ3kgaXMgW1tCcm9hZHBoYXNlU3RyYXRlZ3kuRHluYW1pY0FBQkJUcmVlXV0gd2hpY2ggdXNlcyBhIGJpbmFyeSB0cmVlIG9mIGF4aXMtYWxpZ25lZCBib3VuZGluZyBib3hlcyB0byBpZGVudGlmeVxyXG4gICAgICogcG90ZW50aWFsIGNvbGxpc2lvbiBwYWlycyB3aGljaCBpcyBPKG5sb2cobikpIGZhc3Rlci4gVGhlIG90aGVyIHBvc3NpYmxlIHN0cmF0ZWd5IGlzIHRoZSBbW0Jyb2FkcGhhc2VTdHJhdGVneS5OYWl2ZV1dIHN0cmF0ZWd5XHJcbiAgICAgKiB3aGljaCBsb29wcyBvdmVyIGV2ZXJ5IG9iamVjdCBmb3IgZXZlcnkgb2JqZWN0IGluIHRoZSBzY2VuZSB0byBpZGVudGlmeSBjb2xsaXNpb24gcGFpcnMgd2hpY2ggaXMgTyhuXjIpIHNsb3dlci5cclxuICAgICAqL1xyXG4gICAgdmFyIEJyb2FkcGhhc2VTdHJhdGVneTtcclxuICAgIChmdW5jdGlvbiAoQnJvYWRwaGFzZVN0cmF0ZWd5KSB7XHJcbiAgICAgICAgQnJvYWRwaGFzZVN0cmF0ZWd5W0Jyb2FkcGhhc2VTdHJhdGVneVtcIk5haXZlXCJdID0gMF0gPSBcIk5haXZlXCI7XHJcbiAgICAgICAgQnJvYWRwaGFzZVN0cmF0ZWd5W0Jyb2FkcGhhc2VTdHJhdGVneVtcIkR5bmFtaWNBQUJCVHJlZVwiXSA9IDFdID0gXCJEeW5hbWljQUFCQlRyZWVcIjtcclxuICAgIH0pKEJyb2FkcGhhc2VTdHJhdGVneSA9IGV4cG9ydHMuQnJvYWRwaGFzZVN0cmF0ZWd5IHx8IChleHBvcnRzLkJyb2FkcGhhc2VTdHJhdGVneSA9IHt9KSk7XHJcbiAgICAvKipcclxuICAgICAqIFBvc3NpYmxlIG51bWVyaWNhbCBpbnRlZ3JhdG9ycyBmb3IgcG9zaXRpb24gYW5kIHZlbG9jaXR5XHJcbiAgICAgKi9cclxuICAgIHZhciBJbnRlZ3JhdG9yO1xyXG4gICAgKGZ1bmN0aW9uIChJbnRlZ3JhdG9yKSB7XHJcbiAgICAgICAgSW50ZWdyYXRvcltJbnRlZ3JhdG9yW1wiRXVsZXJcIl0gPSAwXSA9IFwiRXVsZXJcIjtcclxuICAgIH0pKEludGVncmF0b3IgPSBleHBvcnRzLkludGVncmF0b3IgfHwgKGV4cG9ydHMuSW50ZWdyYXRvciA9IHt9KSk7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBbW1BoeXNpY3NdXSBvYmplY3QgaXMgdGhlIGdsb2JhbCBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgYWxsIEV4Y2FsaWJ1ciBwaHlzaWNzLlxyXG4gICAgICpcclxuICAgICAqIFtbaW5jbHVkZTpQaHlzaWNzLm1kXV1cclxuICAgICAqL1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIHZhciBQaHlzaWNzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBQaHlzaWNzKCkge1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25maWd1cmVzIEV4Y2FsaWJ1ciB0byB1c2UgYm94IHBoeXNpY3MuIEJveCBwaHlzaWNzIHdoaWNoIHBlcmZvcm1zIHNpbXBsZSBheGlzIGFsaWduZWQgYXJjYWRlIHN0eWxlIHBoeXNpY3MuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUGh5c2ljcy51c2VCb3hQaHlzaWNzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBQaHlzaWNzLmNvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneSA9IENvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneS5Cb3g7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25maWd1cmVzIEV4Y2FsaWJ1ciB0byB1c2UgcmlnaWQgYm9keSBwaHlzaWNzLiBSaWdpZCBib2R5IHBoeXNpY3MgYWxsb3dzIGZvciBjb21wbGljYXRlZFxyXG4gICAgICAgICAqIHNpbXVsYXRlZCBwaHlzaWNhbCBpbnRlcmFjdGlvbnMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUGh5c2ljcy51c2VSaWdpZEJvZHlQaHlzaWNzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBQaHlzaWNzLmNvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneSA9IENvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneS5SaWdpZEJvZHk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gUGh5c2ljcztcclxuICAgIH0oKSk7XHJcbiAgICAvKipcclxuICAgICAqIEdsb2JhbCBhY2NlbGVyYXRpb24gdGhhdCBpcyBhcHBsaWVkIHRvIGFsbCB2YW5pbGxhIGFjdG9ycyAoaXQgd29udCBlZmZlY3QgW1tMYWJlbHxsYWJlbHNdXSwgW1tVSUFjdG9yfHVpIGFjdG9yc11dLCBvclxyXG4gICAgICogW1tUcmlnZ2VyfHRyaWdnZXJzXV0gaW4gRXhjYWxpYnVyIHRoYXQgaGF2ZSBhbiBbW0NvbGxpc2lvblR5cGUuQWN0aXZlfGFjdGl2ZV1dIGNvbGxpc2lvbiB0eXBlKS5cclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBpcyBhIGdyZWF0IHdheSB0byBnbG9iYWxseSBzaW11bGF0ZSBlZmZlY3RzIGxpa2UgZ3Jhdml0eS5cclxuICAgICAqL1xyXG4gICAgUGh5c2ljcy5hY2MgPSBuZXcgQWxnZWJyYV8xLlZlY3RvcigwLCAwKTtcclxuICAgIC8qKlxyXG4gICAgICogR2xvYmFsbHkgc3dpdGNoZXMgYWxsIEV4Y2FsaWJ1ciBwaHlzaWNzIGJlaGF2aW9yIG9uIG9yIG9mZi5cclxuICAgICAqL1xyXG4gICAgUGh5c2ljcy5lbmFibGVkID0gdHJ1ZTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBudW1iZXIgb2YgY29sbGlzaW9uIHBhc3NlcyBmb3IgRXhjYWxpYnVyIHRvIHBlcmZvcm0gb24gcGh5c2ljcyBib2RpZXMuXHJcbiAgICAgKlxyXG4gICAgICogUmVkdWNpbmcgY29sbGlzaW9uIHBhc3NlcyBtYXkgY2F1c2UgdGhpbmdzIG5vdCB0byBjb2xsaWRlIGFzIGV4cGVjdGVkIGluIHlvdXIgZ2FtZSwgYnV0IG1heSBpbmNyZWFzZSBwZXJmb3JtYW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBNb3JlIHBhc3NlcyBjYW4gaW1wcm92ZSB0aGUgdmlzdWFsIHF1YWxpdHkgb2YgY29sbGlzaW9ucyB3aGVuIG1hbnkgb2JqZWN0cyBhcmUgb24gdGhlIHNjcmVlbi4gVGhpcyBjYW4gcmVkdWNlIGppdHRlciwgaW1wcm92ZSB0aGVcclxuICAgICAqIGNvbGxpc2lvbiByZXNvbHV0aW9uIG9mIGZhc3QgbW92ZSBvYmplY3RzLCBvciB0aGUgc3RhYmlsaXR5IG9mIGxhcmdlIG51bWJlcnMgb2Ygb2JqZWN0cyBzdGFja2VkIHRvZ2V0aGVyLlxyXG4gICAgICpcclxuICAgICAqIEZld2VyIHBhc3NlcyB3aWxsIGltcHJvdmUgdGhlIHBlcmZvcm1hbmNlIG9mIHRoZSBnYW1lIGF0IHRoZSBjb3N0IG9mIGNvbGxpc2lvbiBxdWFsaXR5LCBtb3JlIHBhc3NlcyB3aWxsIGltcHJvdmUgcXVhbGl0eSBhdCB0aGVcclxuICAgICAqIGNvc3Qgb2YgcGVyZm9ybWFuY2UuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGRlZmF1bHQgaXMgc2V0IHRvIDUgcGFzc2VzIHdoaWNoIGlzIGEgZ29vZCBzdGFydC5cclxuICAgICAqL1xyXG4gICAgUGh5c2ljcy5jb2xsaXNpb25QYXNzZXMgPSA1O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGJyb2FkcGhhc2UgcGFpciBpZGVudGlmaWNhdGlvbiBzdHJhdGVneS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgZGVmYXVsdCBzdHJhdGVneSBpcyBbW0Jyb2FkcGhhc2VTdHJhdGVneS5EeW5hbWljQUFCQlRyZWVdXSB3aGljaCB1c2VzIGEgYmluYXJ5IHRyZWUgb2YgYXhpcy1hbGlnbmVkIGJvdW5kaW5nIGJveGVzIHRvIGlkZW50aWZ5XHJcbiAgICAgKiBwb3RlbnRpYWwgY29sbGlzaW9uIHBhaXJzIHdoaWNoIGlzIE8obmxvZyhuKSkgZmFzdGVyLiBUaGUgb3RoZXIgcG9zc2libGUgc3RyYXRlZ3kgaXMgdGhlIFtbQnJvYWRwaGFzZVN0cmF0ZWd5Lk5haXZlXV0gc3RyYXRlZ3lcclxuICAgICAqIHdoaWNoIGxvb3BzIG92ZXIgZXZlcnkgb2JqZWN0IGZvciBldmVyeSBvYmplY3QgaW4gdGhlIHNjZW5lIHRvIGlkZW50aWZ5IGNvbGxpc2lvbiBwYWlycyB3aGljaCBpcyBPKG5eMikgc2xvd2VyLlxyXG4gICAgICovXHJcbiAgICBQaHlzaWNzLmJyb2FkcGhhc2VTdHJhdGVneSA9IEJyb2FkcGhhc2VTdHJhdGVneS5EeW5hbWljQUFCQlRyZWU7XHJcbiAgICAvKipcclxuICAgICAqIEdsb2JhbGx5IHN3aXRjaGVzIHRoZSBkZWJ1ZyBpbmZvcm1hdGlvbiBmb3IgdGhlIGJyb2FkcGhhc2Ugc3RyYXRlZ3lcclxuICAgICAqL1xyXG4gICAgUGh5c2ljcy5icm9hZHBoYXNlRGVidWcgPSBmYWxzZTtcclxuICAgIC8qKlxyXG4gICAgICogU2hvdyB0aGUgbm9ybWFscyBhcyBhIHJlc3VsdCBvZiBjb2xsaXNpb24gb24gdGhlIHNjcmVlbi5cclxuICAgICAqL1xyXG4gICAgUGh5c2ljcy5zaG93Q29sbGlzaW9uTm9ybWFscyA9IGZhbHNlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93IHRoZSBwb3NpdGlvbiwgdmVsb2NpdHksIGFuZCBhY2NlbGVyYXRpb24gYXMgZ3JhcGhpY2FsIHZlY3RvcnMuXHJcbiAgICAgKi9cclxuICAgIFBoeXNpY3Muc2hvd01vdGlvblZlY3RvcnMgPSBmYWxzZTtcclxuICAgIC8qKlxyXG4gICAgICogU2hvdyB0aGUgYXhpcy1hbGlnbmVkIGJvdW5kaW5nIGJveGVzIG9mIHRoZSBjb2xsaXNpb24gYm9kaWVzIG9uIHRoZSBzY3JlZW4uXHJcbiAgICAgKi9cclxuICAgIFBoeXNpY3Muc2hvd0JvdW5kcyA9IGZhbHNlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93IHRoZSBib3VuZGluZyBjb2xsaXNpb24gYXJlYSBzaGFwZXNcclxuICAgICAqL1xyXG4gICAgUGh5c2ljcy5zaG93QXJlYSA9IGZhbHNlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93IHBvaW50cyBvZiBjb2xsaXNpb24gaW50ZXJwcmV0ZWQgYnkgZXhjYWxpYnVyIGFzIGEgcmVzdWx0IG9mIGNvbGxpc2lvbi5cclxuICAgICAqL1xyXG4gICAgUGh5c2ljcy5zaG93Q29udGFjdHMgPSBmYWxzZTtcclxuICAgIC8qKlxyXG4gICAgICogU2hvdyB0aGUgc3VyZmFjZSBub3JtYWxzIG9mIHRoZSBjb2xsaXNpb24gYXJlYXMuXHJcbiAgICAgKi9cclxuICAgIFBoeXNpY3Muc2hvd05vcm1hbHMgPSBmYWxzZTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBnbG9iYWwgY29sbGlzaW9uIHJlc29sdXRpb24gc3RyYXRlZ3kgKG5hcnJvd3BoYXNlKS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgZGVmYXVsdCBpcyBbW0NvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneS5Cb3hdXSB3aGljaCBwZXJmb3JtcyBzaW1wbGUgYXhpcyBhbGlnbmVkIGFyY2FkZSBzdHlsZSBwaHlzaWNzLlxyXG4gICAgICpcclxuICAgICAqIE1vcmUgYWR2YW5jZWQgcmlnaWQgYm9keSBwaHlzaWNzIGFyZSBlbmFibGVkIGJ5IHNldHRpbmcgW1tDb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kuUmlnaWRCb2R5XV0gd2hpY2ggYWxsb3dzIGZvciBjb21wbGljYXRlZFxyXG4gICAgICogc2ltdWxhdGVkIHBoeXNpY2FsIGludGVyYWN0aW9ucy5cclxuICAgICAqL1xyXG4gICAgUGh5c2ljcy5jb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kgPSBDb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kuQm94O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZGVmYXVsdCBtYXNzIHRvIHVzZSBpZiBub25lIGlzIHNwZWNpZmllZFxyXG4gICAgICovXHJcbiAgICBQaHlzaWNzLmRlZmF1bHRNYXNzID0gMTA7XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgcG9zaXRpb24gYW5kIHZlbG9jaXR5IHBvc2l0aW9uYWwgaW50ZWdyYXRvciwgY3VycmVudGx5IG9ubHkgRXVsZXIgaXMgc3VwcG9ydGVkLlxyXG4gICAgICovXHJcbiAgICBQaHlzaWNzLmludGVncmF0b3IgPSBJbnRlZ3JhdG9yLkV1bGVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBOdW1iZXIgb2Ygc3RlcHMgdG8gdXNlIGluIGludGVncmF0aW9uLiBBIGhpZ2hlciBudW1iZXIgaW1wcm92ZXMgdGhlIHBvc2l0aW9uYWwgYWNjdXJhY3kgb3ZlciB0aW1lLiBUaGlzIGNhbiBiZSB1c2VmdWwgdG8gaW5jcmVhc2VcclxuICAgICAqIGlmIHlvdSBoYXZlIGZhc3QgbW92aW5nIG9iamVjdHMgaW4geW91ciBzaW11bGF0aW9uIG9yIHlvdSBoYXZlIGEgbGFyZ2UgbnVtYmVyIG9mIG9iamVjdHMgYW5kIG5lZWQgdG8gaW5jcmVhc2Ugc3RhYmlsaXR5LlxyXG4gICAgICovXHJcbiAgICBQaHlzaWNzLmludGVncmF0aW9uU3RlcHMgPSAxO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgd2hldGhlciByb3RhdGlvbiBpcyBhbGxvd2VkIGluIGEgUmlnaWRCb2R5IGNvbGxpc2lvbiByZXNvbHV0aW9uXHJcbiAgICAgKi9cclxuICAgIFBoeXNpY3MuYWxsb3dSaWdpZEJvZHlSb3RhdGlvbiA9IHRydWU7XHJcbiAgICAvKipcclxuICAgICAqIFNtYWxsIHZhbHVlIHRvIGhlbHAgY29sbGlzaW9uIHBhc3NlcyBzZXR0bGUgdGhlbXNlbHZlcyBhZnRlciB0aGUgbmFycm93cGhhc2UuXHJcbiAgICAgKi9cclxuICAgIFBoeXNpY3MuY29sbGlzaW9uU2hpZnQgPSAuMDAxO1xyXG4gICAgLyoqXHJcbiAgICAgKiBGYWN0b3IgdG8gYWRkIHRvIHRoZSBSaWdpZEJvZHkgQm91bmRpbmdCb3gsIGJvdW5kaW5nIGJveCAoZGltZW5zaW9ucyArPSB2ZWwgKiBkeW5hbWljVHJlZVZlbG9jaXR5TXVsdGlwbHllcik7XHJcbiAgICAgKi9cclxuICAgIFBoeXNpY3MuZHluYW1pY1RyZWVWZWxvY2l0eU11bHRpcGx5ZXIgPSAyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQYWQgUmlnaWRCb2R5IEJvdW5kaW5nQm94IGJ5IGEgY29uc3RhbnQgYW1vdW50XHJcbiAgICAgKi9cclxuICAgIFBoeXNpY3MuYm91bmRzUGFkZGluZyA9IDU7XHJcbiAgICAvKipcclxuICAgICAqIFN1cmZhY2UgZXBzaWxvbiBpcyB1c2VkIHRvIGhlbHAgZGVhbCB3aXRoIHN1cmZhY2UgcGVuYXRyYXRpb25cclxuICAgICAqL1xyXG4gICAgUGh5c2ljcy5zdXJmYWNlRXBzaWxvbiA9IC4xO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFbmFibGUgZmFzdCBtb3ZpbmcgYm9keSBjaGVja2luZywgdGhpcyBlbmFibGVzIGNoZWNraW5nIGZvciBjb2xsaXNpb24gcGFpcnMgdmlhIHJheWNhc3QgZm9yIGZhc3QgbW92aW5nIG9iamVjdHMgdG8gcHJldmVudFxyXG4gICAgICogYm9kaWVzIGZyb20gdHVubmVsaW5nIHRocm91Z2ggb25lIGFub3RoZXIuXHJcbiAgICAgKi9cclxuICAgIFBoeXNpY3MuY2hlY2tGb3JGYXN0Qm9kaWVzID0gdHJ1ZTtcclxuICAgIC8qKlxyXG4gICAgICogRGlzYWJsZSBtaW5pbXVtIGZhc3QgbW92aW5nIGJvZHkgcmF5Y2FzdCwgYnkgZGVmYXVsdCBpZiBleC5QaHlzaWNzLmNoZWNrRm9yRmFzdEJvZGllcyA9IHRydWUgRXhjYWxpYnVyIHdpbGwgb25seSBjaGVjayBpZiB0aGVcclxuICAgICAqIGJvZHkgaXMgbW92aW5nIGF0IGxlYXN0IGhhbGYgb2YgaXRzIG1pbmltdW0gZGltaW5lbnNpb24gaW4gYW4gdXBkYXRlLiBJZiBleC5QaHlzaWNzLmRpc2FibGVNaW5pbXVtU3BlZWRGb3JGYXN0Qm9keSBpcyBzZXQgdG8gdHJ1ZSxcclxuICAgICAqIEV4Y2FsaWJ1ciB3aWxsIGFsd2F5cyBwZXJmb3JtIHRoZSBmYXN0IGJvZHkgcmF5Y2FzdCByZWdhcmRsZXNzIG9mIHNwZWVkLlxyXG4gICAgICovXHJcbiAgICBQaHlzaWNzLmRpc2FibGVNaW5pbXVtU3BlZWRGb3JGYXN0Qm9keSA9IGZhbHNlO1xyXG4gICAgZXhwb3J0cy5QaHlzaWNzID0gUGh5c2ljcztcclxufSk7XHJcbmRlZmluZShcIlV0aWwvRWFzaW5nRnVuY3Rpb25zXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIFN0YW5kYXJkIGVhc2luZyBmdW5jdGlvbnMgZm9yIG1vdGlvbiBpbiBFeGNhbGlidXIsIGRlZmluZWQgb24gYSBkb21haW4gb2YgWzAsIGR1cmF0aW9uXSBhbmQgYSByYW5nZSBmcm9tIFsrc3RhcnRWYWx1ZSwrZW5kVmFsdWVdXHJcbiAgICAgKiBHaXZlbiBhIHRpbWUsIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiBhIHZhbHVlIGZyb20gcG9zaXRpdmUgc3RhcnRWYWx1ZSB0byBwb3NpdGl2ZSBlbmRWYWx1ZS5cclxuICAgICAqXHJcbiAgICAgKiBgYGBqc1xyXG4gICAgICogZnVuY3Rpb24gTGluZWFyICh0KSB7XHJcbiAgICAgKiAgICByZXR1cm4gdCAqIHQ7XHJcbiAgICAgKiB9XHJcbiAgICAgKlxyXG4gICAgICogLy8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxyXG4gICAgICogZnVuY3Rpb24gRWFzZUluUXVhZCAodCkge1xyXG4gICAgICogICAgcmV0dXJuIHQgKiB0O1xyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIC8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XHJcbiAgICAgKiBmdW5jdGlvbiBFYXNlT3V0UXVhZCAodCkge1xyXG4gICAgICogICAgcmV0dXJuIHQgKiAoMiAtIHQpO1xyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIC8vIGFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxyXG4gICAgICogZnVuY3Rpb24gRWFzZUluT3V0UXVhZCAodCkge1xyXG4gICAgICogICAgcmV0dXJuIHQgPCAuNSA/IDIgKiB0ICogdCA6IC0xICsgKDQgLSAyICogdCkgKiB0O1xyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIC8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcclxuICAgICAqIGZ1bmN0aW9uIEVhc2VJbkN1YmljICh0KSB7XHJcbiAgICAgKiAgICByZXR1cm4gdCAqIHQgKiB0O1xyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIC8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XHJcbiAgICAgKiBmdW5jdGlvbiBFYXNlT3V0Q3ViaWMgKHQpIHtcclxuICAgICAqICAgIHJldHVybiAoLS10KSAqIHQgKiB0ICsgMTtcclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiAvLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cclxuICAgICAqIGZ1bmN0aW9uIEVhc2VJbk91dEN1YmljICh0KSB7XHJcbiAgICAgKiAgICByZXR1cm4gdCA8IC41ID8gNCAqIHQgKiB0ICogdCA6ICh0IC0gMSkgKiAoMiAqIHQgLSAyKSAqICgyICogdCAtIDIpICsgMTtcclxuICAgICAqIH1cclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICB2YXIgRWFzaW5nRnVuY3Rpb25zID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBFYXNpbmdGdW5jdGlvbnMoKSB7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBFYXNpbmdGdW5jdGlvbnM7XHJcbiAgICB9KCkpO1xyXG4gICAgRWFzaW5nRnVuY3Rpb25zLkxpbmVhciA9IGZ1bmN0aW9uIChjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGR1cmF0aW9uKSB7XHJcbiAgICAgICAgZW5kVmFsdWUgPSAoZW5kVmFsdWUgLSBzdGFydFZhbHVlKTtcclxuICAgICAgICByZXR1cm4gZW5kVmFsdWUgKiBjdXJyZW50VGltZSAvIGR1cmF0aW9uICsgc3RhcnRWYWx1ZTtcclxuICAgIH07XHJcbiAgICBFYXNpbmdGdW5jdGlvbnMuRWFzZUluUXVhZCA9IGZ1bmN0aW9uIChjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGR1cmF0aW9uKSB7XHJcbiAgICAgICAgZW5kVmFsdWUgPSAoZW5kVmFsdWUgLSBzdGFydFZhbHVlKTtcclxuICAgICAgICBjdXJyZW50VGltZSAvPSBkdXJhdGlvbjtcclxuICAgICAgICByZXR1cm4gZW5kVmFsdWUgKiBjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICsgc3RhcnRWYWx1ZTtcclxuICAgIH07XHJcbiAgICBFYXNpbmdGdW5jdGlvbnMuRWFzZU91dFF1YWQgPSBmdW5jdGlvbiAoY3VycmVudFRpbWUsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBkdXJhdGlvbikge1xyXG4gICAgICAgIGVuZFZhbHVlID0gKGVuZFZhbHVlIC0gc3RhcnRWYWx1ZSk7XHJcbiAgICAgICAgY3VycmVudFRpbWUgLz0gZHVyYXRpb247XHJcbiAgICAgICAgcmV0dXJuIC1lbmRWYWx1ZSAqIGN1cnJlbnRUaW1lICogKGN1cnJlbnRUaW1lIC0gMikgKyBzdGFydFZhbHVlO1xyXG4gICAgfTtcclxuICAgIEVhc2luZ0Z1bmN0aW9ucy5FYXNlSW5PdXRRdWFkID0gZnVuY3Rpb24gKGN1cnJlbnRUaW1lLCBzdGFydFZhbHVlLCBlbmRWYWx1ZSwgZHVyYXRpb24pIHtcclxuICAgICAgICBlbmRWYWx1ZSA9IChlbmRWYWx1ZSAtIHN0YXJ0VmFsdWUpO1xyXG4gICAgICAgIGN1cnJlbnRUaW1lIC89IGR1cmF0aW9uIC8gMjtcclxuICAgICAgICBpZiAoY3VycmVudFRpbWUgPCAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbmRWYWx1ZSAvIDIgKiBjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICsgc3RhcnRWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudFRpbWUtLTtcclxuICAgICAgICByZXR1cm4gLWVuZFZhbHVlIC8gMiAqIChjdXJyZW50VGltZSAqIChjdXJyZW50VGltZSAtIDIpIC0gMSkgKyBzdGFydFZhbHVlO1xyXG4gICAgfTtcclxuICAgIEVhc2luZ0Z1bmN0aW9ucy5FYXNlSW5DdWJpYyA9IGZ1bmN0aW9uIChjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGR1cmF0aW9uKSB7XHJcbiAgICAgICAgZW5kVmFsdWUgPSAoZW5kVmFsdWUgLSBzdGFydFZhbHVlKTtcclxuICAgICAgICBjdXJyZW50VGltZSAvPSBkdXJhdGlvbjtcclxuICAgICAgICByZXR1cm4gZW5kVmFsdWUgKiBjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKyBzdGFydFZhbHVlO1xyXG4gICAgfTtcclxuICAgIEVhc2luZ0Z1bmN0aW9ucy5FYXNlT3V0Q3ViaWMgPSBmdW5jdGlvbiAoY3VycmVudFRpbWUsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBkdXJhdGlvbikge1xyXG4gICAgICAgIGVuZFZhbHVlID0gKGVuZFZhbHVlIC0gc3RhcnRWYWx1ZSk7XHJcbiAgICAgICAgY3VycmVudFRpbWUgLz0gZHVyYXRpb247XHJcbiAgICAgICAgY3VycmVudFRpbWUtLTtcclxuICAgICAgICByZXR1cm4gZW5kVmFsdWUgKiAoY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICsgMSkgKyBzdGFydFZhbHVlO1xyXG4gICAgfTtcclxuICAgIEVhc2luZ0Z1bmN0aW9ucy5FYXNlSW5PdXRDdWJpYyA9IGZ1bmN0aW9uIChjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGR1cmF0aW9uKSB7XHJcbiAgICAgICAgZW5kVmFsdWUgPSAoZW5kVmFsdWUgLSBzdGFydFZhbHVlKTtcclxuICAgICAgICBjdXJyZW50VGltZSAvPSBkdXJhdGlvbiAvIDI7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lIDwgMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZW5kVmFsdWUgLyAyICogY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICsgc3RhcnRWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudFRpbWUgLT0gMjtcclxuICAgICAgICByZXR1cm4gZW5kVmFsdWUgLyAyICogKGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSArIDIpICsgc3RhcnRWYWx1ZTtcclxuICAgIH07XHJcbiAgICBleHBvcnRzLkVhc2luZ0Z1bmN0aW9ucyA9IEVhc2luZ0Z1bmN0aW9ucztcclxufSk7XHJcbi8vIFByb21pc2VzL0ErIFNwZWMgaHR0cDovL3Byb21pc2VzLWFwbHVzLmdpdGh1Yi5pby9wcm9taXNlcy1zcGVjL1xyXG5kZWZpbmUoXCJQcm9taXNlc1wiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBWYWxpZCBzdGF0ZXMgZm9yIGEgcHJvbWlzZSB0byBiZSBpblxyXG4gICAgICovXHJcbiAgICB2YXIgUHJvbWlzZVN0YXRlO1xyXG4gICAgKGZ1bmN0aW9uIChQcm9taXNlU3RhdGUpIHtcclxuICAgICAgICBQcm9taXNlU3RhdGVbUHJvbWlzZVN0YXRlW1wiUmVzb2x2ZWRcIl0gPSAwXSA9IFwiUmVzb2x2ZWRcIjtcclxuICAgICAgICBQcm9taXNlU3RhdGVbUHJvbWlzZVN0YXRlW1wiUmVqZWN0ZWRcIl0gPSAxXSA9IFwiUmVqZWN0ZWRcIjtcclxuICAgICAgICBQcm9taXNlU3RhdGVbUHJvbWlzZVN0YXRlW1wiUGVuZGluZ1wiXSA9IDJdID0gXCJQZW5kaW5nXCI7XHJcbiAgICB9KShQcm9taXNlU3RhdGUgPSBleHBvcnRzLlByb21pc2VTdGF0ZSB8fCAoZXhwb3J0cy5Qcm9taXNlU3RhdGUgPSB7fSkpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9taXNlcyBhcmUgdXNlZCB0byBkbyBhc3luY2hyb25vdXMgd29yayBhbmQgdGhleSBhcmUgdXNlZnVsIGZvclxyXG4gICAgICogY3JlYXRpbmcgYSBjaGFpbiBvZiBhY3Rpb25zLiBJbiBFeGNhbGlidXIgdGhleSBhcmUgdXNlZCBmb3IgbG9hZGluZyxcclxuICAgICAqIHNvdW5kcywgYW5pbWF0aW9uLCBhY3Rpb25zLCBhbmQgbW9yZS5cclxuICAgICAqXHJcbiAgICAgKiBbW2luY2x1ZGU6UHJvbWlzZXMubWRdXVxyXG4gICAgICovXHJcbiAgICB2YXIgUHJvbWlzZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gUHJvbWlzZSgpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBQcm9taXNlU3RhdGUuUGVuZGluZztcclxuICAgICAgICAgICAgdGhpcy5fc3VjY2Vzc0NhbGxiYWNrcyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLl9yZWplY3RDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuOyB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGUgYW5kIHJlc29sdmUgYSBQcm9taXNlIHdpdGggYW4gb3B0aW9uYWwgdmFsdWVcclxuICAgICAgICAgKiBAcGFyYW0gdmFsdWUgIEFuIG9wdGlvbmFsIHZhbHVlIHRvIHdyYXAgaW4gYSByZXNvbHZlZCBwcm9taXNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gKG5ldyBQcm9taXNlKCkpLnJlc29sdmUodmFsdWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZSBhbmQgcmVqZWN0IGEgUHJvbWlzZSB3aXRoIGFuIG9wdGlvbmFsIHZhbHVlXHJcbiAgICAgICAgICogQHBhcmFtIHZhbHVlICBBbiBvcHRpb25hbCB2YWx1ZSB0byB3cmFwIGluIGEgcmVqZWN0ZWQgcHJvbWlzZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb21pc2UucmVqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gKG5ldyBQcm9taXNlKCkpLnJlamVjdCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUHJvbWlzZS5qb2luID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcclxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwICYmICFBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSkpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSkpIHtcclxuICAgICAgICAgICAgICAgIHByb21pc2VzID0gYXJndW1lbnRzWzBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBqb2luZWRQcm9taXNlID0gbmV3IFByb21pc2UoKTtcclxuICAgICAgICAgICAgaWYgKCFwcm9taXNlcyB8fCAhcHJvbWlzZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gam9pbmVkUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHRvdGFsID0gcHJvbWlzZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgc3VjY2Vzc2VzID0gMDtcclxuICAgICAgICAgICAgdmFyIHJlamVjdHMgPSAwO1xyXG4gICAgICAgICAgICB2YXIgZXJyb3JzID0gW107XHJcbiAgICAgICAgICAgIHByb21pc2VzLmZvckVhY2goZnVuY3Rpb24gKHApIHtcclxuICAgICAgICAgICAgICAgIHAudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc2VzICs9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1Y2Nlc3NlcyA9PT0gdG90YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgam9pbmVkUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN1Y2Nlc3NlcyArIHJlamVjdHMgKyBlcnJvcnMubGVuZ3RoID09PSB0b3RhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqb2luZWRQcm9taXNlLnJlamVjdChlcnJvcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3RzICs9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1Y2Nlc3NlcyArIHJlamVjdHMgKyBlcnJvcnMubGVuZ3RoID09PSB0b3RhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqb2luZWRQcm9taXNlLnJlamVjdChlcnJvcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pLmVycm9yKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChlcnJvcnMubGVuZ3RoICsgc3VjY2Vzc2VzICsgcmVqZWN0cykgPT09IHRvdGFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpvaW5lZFByb21pc2UucmVqZWN0KGVycm9ycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gam9pbmVkUHJvbWlzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoYWluIHN1Y2Nlc3MgYW5kIHJlamVjdCBjYWxsYmFja3MgYWZ0ZXIgdGhlIHByb21pc2UgaXMgcmVzb2x2ZWRcclxuICAgICAgICAgKiBAcGFyYW0gc3VjY2Vzc0NhbGxiYWNrICBDYWxsIG9uIHJlc29sdXRpb24gb2YgcHJvbWlzZVxyXG4gICAgICAgICAqIEBwYXJhbSByZWplY3RDYWxsYmFjayAgIENhbGwgb24gcmVqZWN0aW9uIG9mIHByb21pc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKHN1Y2Nlc3NDYWxsYmFjaywgcmVqZWN0Q2FsbGJhY2spIHtcclxuICAgICAgICAgICAgaWYgKHN1Y2Nlc3NDYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3VjY2Vzc0NhbGxiYWNrcy5wdXNoKHN1Y2Nlc3NDYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcHJvbWlzZSBpcyBhbHJlYWR5IHJlc292bGVkIGNhbGwgaW1tZWRpYXRlbHlcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlKCkgPT09IFByb21pc2VTdGF0ZS5SZXNvbHZlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NDYWxsYmFjay5jYWxsKHRoaXMsIHRoaXMuX3ZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlRXJyb3IoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyZWplY3RDYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVqZWN0Q2FsbGJhY2sgPSByZWplY3RDYWxsYmFjaztcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBwcm9taXNlIGlzIGFscmVhZHkgcmVqZWN0ZWQgY2FsbCBpbW1lZGlhdGVseVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUoKSA9PT0gUHJvbWlzZVN0YXRlLlJlamVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0Q2FsbGJhY2suY2FsbCh0aGlzLCB0aGlzLl92YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZUVycm9yKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZCBhbiBlcnJvciBjYWxsYmFjayB0byB0aGUgcHJvbWlzZVxyXG4gICAgICAgICAqIEBwYXJhbSBlcnJvckNhbGxiYWNrICBDYWxsIGlmIHRoZXJlIHdhcyBhbiBlcnJvciBpbiBhIGNhbGxiYWNrXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3JDYWxsYmFjaykge1xyXG4gICAgICAgICAgICBpZiAoZXJyb3JDYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZXJyb3JDYWxsYmFjayA9IGVycm9yQ2FsbGJhY2s7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXNvbHZlIHRoZSBwcm9taXNlIGFuZCBwYXNzIGFuIG9wdGlvbiB2YWx1ZSB0byB0aGUgc3VjY2VzcyBjYWxsYmFja3NcclxuICAgICAgICAgKiBAcGFyYW0gdmFsdWUgIFZhbHVlIHRvIHBhc3MgdG8gdGhlIHN1Y2Nlc3MgY2FsbGJhY2tzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IFByb21pc2VTdGF0ZS5QZW5kaW5nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IFByb21pc2VTdGF0ZS5SZXNvbHZlZDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdWNjZXNzQ2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiLmNhbGwoX3RoaXMsIF90aGlzLl92YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZUVycm9yKGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVzb2x2ZSBhIHByb21pc2UgdGhhdCBpcyBub3QgaW4gYSBwZW5kaW5nIHN0YXRlIScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVqZWN0IHRoZSBwcm9taXNlIGFuZCBwYXNzIGFuIG9wdGlvbiB2YWx1ZSB0byB0aGUgcmVqZWN0IGNhbGxiYWNrc1xyXG4gICAgICAgICAqIEBwYXJhbSB2YWx1ZSAgVmFsdWUgdG8gcGFzcyB0byB0aGUgcmVqZWN0IGNhbGxiYWNrc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IFByb21pc2VTdGF0ZS5QZW5kaW5nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IFByb21pc2VTdGF0ZS5SZWplY3RlZDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWplY3RDYWxsYmFjay5jYWxsKHRoaXMsIHRoaXMuX3ZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlRXJyb3IoZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWplY3QgYSBwcm9taXNlIHRoYXQgaXMgbm90IGluIGEgcGVuZGluZyBzdGF0ZSEnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluc3BlY3QgdGhlIGN1cnJlbnQgc3RhdGUgb2YgYSBwcm9taXNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuc3RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9oYW5kbGVFcnJvciA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9lcnJvckNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJvckNhbGxiYWNrLmNhbGwodGhpcywgZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZXRocm93IGVycm9yXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZTtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLlByb21pc2UgPSBQcm9taXNlO1xyXG59KTtcclxuLyoqXHJcbiAqIFBzZXVkby1SYW5kb20gVXRpbGl0eVxyXG4gKlxyXG4gKiBBIHBzZXVkby1yYW5kb20gdXRpbGl0eSB0byBhZGQgc2VlZGVkIHJhbmRvbSBzdXBwb3J0IGZvciBoZWxwIGluXHJcbiAqIGdlbmVyYXRpbmcgdGhpbmdzIGxpa2UgdGVycmFpbiBvciByZXByb2R1Y2libGUgcmFuZG9tbmVzcy4gVXNlcyB0aGVcclxuICogW01lcnNlbm5lIFR3aXN0ZXJdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01lcnNlbm5lX1R3aXN0ZXIpIGFsZ29yaXRobS5cclxuICpcclxuICogW1tpbmNsdWRlOlJhbmRvbS5tZF1dXHJcbiAqL1xyXG5kZWZpbmUoXCJNYXRoL1JhbmRvbVwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiAzMi1iaXQgbWFza1xyXG4gICAgICovXHJcbiAgICB2YXIgQklUTUFTSzMyID0gMHhGRkZGRkZGRjtcclxuICAgIC8qKlxyXG4gICAgICogUHNldWRvLXJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIGZvbGxvd2luZyB0aGUgTWVyc2VubmVfVHdpc3RlciBhbGdvcml0aG0uIEdpdmVuIGEgc2VlZCB0aGlzIGdlbmVyYXRvciB3aWxsIHByb2R1Y2UgdGhlIHNhbWUgc2VxdWVuY2VcclxuICAgICAqIG9mIG51bWJlcnMgZWFjaCB0aW1lIGl0IGlzIGNhbGxlZC5cclxuICAgICAqIFNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NZXJzZW5uZV9Ud2lzdGVyIGZvciBtb3JlIGRldGFpbHMuXHJcbiAgICAgKiBVc2VzIHRoZSBNVDE5OTM3LTMyICgyMDAyKSBpbXBsZW1lbnRhdGlvbiBkb2N1bWVudGVkIGhlcmUgaHR0cDovL3d3dy5tYXRoLnNjaS5oaXJvc2hpbWEtdS5hYy5qcC9+bS1tYXQvTVQvTVQyMDAyL2VtdDE5OTM3YXIuaHRtbFxyXG4gICAgICpcclxuICAgICAqIEFwaSBpbnNwaXJlZCBieSBodHRwOi8vY2hhbmNlanMuY29tLyMgaHR0cHM6Ly9naXRodWIuY29tL2NoYW5jZWpzL2NoYW5jZWpzXHJcbiAgICAgKi9cclxuICAgIHZhciBSYW5kb20gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIG5vIHNlZWQgaXMgc3BlY2lmaWVkLCB0aGUgRGF0ZS5ub3coKSBpcyB1c2VkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gUmFuZG9tKHNlZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5zZWVkID0gc2VlZDtcclxuICAgICAgICAgICAgLy8gU2VwYXJhdGlvbiBwb2ludCBvZiBvbmUgb25lIHdvcmQsIHRoZSBudW1iZXIgb2YgYml0cyBpbiB0aGUgbG93ZXIgYml0bWFzayAwIDw9IHIgPD0gdy0xXHJcbiAgICAgICAgICAgIHRoaXMuX2xvd2VyTWFzayA9IDB4N0ZGRkZGRkY7IC8vIDMxIGJpdHMgc2FtZSBhcyBfclxyXG4gICAgICAgICAgICB0aGlzLl91cHBlck1hc2sgPSAweDgwMDAwMDAwOyAvLyAzNCBoaWdoIGJpdHNcclxuICAgICAgICAgICAgLy8gV29yZCBzaXplLCA2NCBiaXRzXHJcbiAgICAgICAgICAgIHRoaXMuX3cgPSAzMjtcclxuICAgICAgICAgICAgLy8gRGVncmVlIG9mIHJlY3VycmFuY2VcclxuICAgICAgICAgICAgdGhpcy5fbiA9IDYyNDtcclxuICAgICAgICAgICAgLy8gTWlkZGxlIHdvcmQsIGFuIG9mZnNldCB1c2VkIGluIHRoZSByZWN1cnJhbmNlIGRlZmluaW5nIHRoZSBzZXJpZXMgeCwgMTw9bTxuXHJcbiAgICAgICAgICAgIHRoaXMuX20gPSAzOTc7XHJcbiAgICAgICAgICAgIC8vIGNvZWZmaWNpZW50cyBvZiB0ZWggcmF0aW9uYWwgbm9ybWFsIGZvcm0gdHdpc3QgbWF0cml4XHJcbiAgICAgICAgICAgIHRoaXMuX2EgPSAweDk5MDhCMERGO1xyXG4gICAgICAgICAgICAvLyB0ZW1wZXJpbmcgYml0IHNoaWZ0cyBhbmQgbWFza3NcclxuICAgICAgICAgICAgdGhpcy5fdSA9IDExO1xyXG4gICAgICAgICAgICB0aGlzLl9zID0gNztcclxuICAgICAgICAgICAgdGhpcy5fYiA9IDB4OWQyYzU2ODA7XHJcbiAgICAgICAgICAgIHRoaXMuX3QgPSAxNTtcclxuICAgICAgICAgICAgdGhpcy5fYyA9IDB4ZWZjNjAwMDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2wgPSAxODtcclxuICAgICAgICAgICAgdGhpcy5fZiA9IDE4MTI0MzMyNTM7XHJcbiAgICAgICAgICAgIHRoaXMuX210ID0gbmV3IEFycmF5KHRoaXMuX24pO1xyXG4gICAgICAgICAgICAvLyBuZWVkIHRvIG1hc2sgdG8gc3VwcG9ydCBoaWdoZXIgYml0IG1hY2hpbmVzXHJcbiAgICAgICAgICAgIHRoaXMuX210WzBdID0gKHNlZWQgfHwgRGF0ZS5ub3coKSkgPj4+IDA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5fbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcyA9IHRoaXMuX210W2kgLSAxXSBeICh0aGlzLl9tdFtpIC0gMV0gPj4+ICh0aGlzLl93IC0gMikpO1xyXG4gICAgICAgICAgICAgICAgLy8gbnVtYmVycyBhcmUgYmlnZ2VyIHRoYW4gdGhlIEpTIG1heCBzYWZlIGludCwgYWRkIGluIDE2LWJpdCBjaHVua3MgdG8gcHJldmVudCBJRUVFIHJvdW5kaW5nIGVycm9ycyBvbiBoaWdoIGJpdHMgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHRoaXMuX210W2ldID0gKCgodGhpcy5fZiAqICgocyAmIDB4RkZGRjAwMDApID4+PiAxNikpIDw8IDE2KSArICh0aGlzLl9mICogKHMgJiAweEZGRkYpKSArIGkpID4+PiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2luZGV4ID0gdGhpcy5fbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXBwbHkgdGhlIHR3aXN0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFuZG9tLnByb3RvdHlwZS5fdHdpc3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBtYWcwMSA9IFsweDAsIHRoaXMuX2FdO1xyXG4gICAgICAgICAgICB2YXIgeSA9IDA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbiAtIHRoaXMuX207IGkrKykge1xyXG4gICAgICAgICAgICAgICAgeSA9ICh0aGlzLl9tdFtpXSAmIHRoaXMuX3VwcGVyTWFzaykgfCAodGhpcy5fbXRbaSArIDFdICYgdGhpcy5fbG93ZXJNYXNrKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX210W2ldID0gdGhpcy5fbXRbaSArIHRoaXMuX21dIF4gKHkgPj4+IDEpIF4gbWFnMDFbeSAmIDB4MV0gJiBCSVRNQVNLMzI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICg7IGkgPCB0aGlzLl9uIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB5ID0gKHRoaXMuX210W2ldICYgdGhpcy5fdXBwZXJNYXNrKSB8ICh0aGlzLl9tdFtpICsgMV0gJiB0aGlzLl9sb3dlck1hc2spO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbXRbaV0gPSB0aGlzLl9tdFtpICsgKHRoaXMuX20gLSB0aGlzLl9uKV0gXiAoeSA+Pj4gMSkgXiBtYWcwMVt5ICYgMHgxXSAmIEJJVE1BU0szMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB5ID0gKHRoaXMuX210W3RoaXMuX24gLSAxXSAmIHRoaXMuX3VwcGVyTWFzaykgfCAodGhpcy5fbXRbMF0gJiB0aGlzLl9sb3dlck1hc2spO1xyXG4gICAgICAgICAgICB0aGlzLl9tdFt0aGlzLl9uIC0gMV0gPSB0aGlzLl9tdFt0aGlzLl9tIC0gMV0gXiAoeSA+Pj4gMSkgXiBtYWcwMVt5ICYgMHgxXSAmIEJJVE1BU0szMjtcclxuICAgICAgICAgICAgdGhpcy5faW5kZXggPSAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJuIG5leHQgMzIgYml0IGludGVnZXIgbnVtYmVyIGluIHNlcXVlbmNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFuZG9tLnByb3RvdHlwZS5uZXh0SW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faW5kZXggPj0gdGhpcy5fbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdHdpc3QoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgeSA9IHRoaXMuX210W3RoaXMuX2luZGV4KytdO1xyXG4gICAgICAgICAgICB5IF49IHkgPj4+IHRoaXMuX3U7XHJcbiAgICAgICAgICAgIHkgXj0gKCh5IDw8IHRoaXMuX3MpICYgdGhpcy5fYik7XHJcbiAgICAgICAgICAgIHkgXj0gKCh5IDw8IHRoaXMuX3QpICYgdGhpcy5fYyk7XHJcbiAgICAgICAgICAgIHkgXj0gKHkgPj4+IHRoaXMuX2wpO1xyXG4gICAgICAgICAgICByZXR1cm4geSA+Pj4gMDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybiBhIHJhbmRvbSBmbG9hdGluZyBwb2ludCBudW1iZXIgYmV0d2VlbiBbMCwgMSlcclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5kb20ucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHRJbnQoKSAqICgxLjAgLyA0Mjk0OTY3Mjk2LjApOyAvLyBkaXZpZGVkIGJ5IDJeMzJcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybiBhIHJhbmRvbSBmbG9hdGluZyBwb2ludCBpbiByYW5nZSBbbWluLCBtYXgpIG1pbiBpcyBpbmNsdWRlZCwgbWF4IGlzIG5vdCBpbmNsdWRlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmRvbS5wcm90b3R5cGUuZmxvYXRpbmcgPSBmdW5jdGlvbiAobWluLCBtYXgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChtYXggLSBtaW4pICogdGhpcy5uZXh0KCkgKyBtaW47XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm4gYSByYW5kb20gaW50ZWdlciBpbiByYW5nZSBbbWluLCBtYXhdIG1pbiBpcyBpbmNsdWRlZCwgbWF4IGlzIGluY2x1ZGVkLlxyXG4gICAgICAgICAqIEltcGxlbWVudGVkIHdpdGggcmVqZWN0aW9uIHNhbXBsaW5nLCBzZWUgaHR0cHM6Ly9tZWRpdW0uY29tL0BiZXRhYmxlL3RpZnUtYnktdXNpbmctbWF0aC1yYW5kb20tZjFjMzA4YzRmZDlkIy5pMTN0ZGl1NWFcclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5kb20ucHJvdG90eXBlLmludGVnZXIgPSBmdW5jdGlvbiAobWluLCBtYXgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKG1heCAtIG1pbiArIDEpICogdGhpcy5uZXh0KCkgKyBtaW4pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0cnVlIG9yIGZhbHNlIHJhbmRvbWx5IHdpdGggNTAvNTAgb2RkcyBieSBkZWZhdWx0LlxyXG4gICAgICAgICAqIEJ5IGRlZmF1bHQgdGhlIGxpa2VsaWhvb2Qgb2YgcmV0dXJuaW5nIGEgdHJ1ZSBpcyAuNSAoNTAlKS5cclxuICAgICAgICAgKiBAcGFyYW0gbGlrZWxpaG9vZCB0YWtlcyB2YWx1ZXMgYmV0d2VlbiBbMCwgMV1cclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5kb20ucHJvdG90eXBlLmJvb2wgPSBmdW5jdGlvbiAobGlrZWxpaG9vZCkge1xyXG4gICAgICAgICAgICBpZiAobGlrZWxpaG9vZCA9PT0gdm9pZCAwKSB7IGxpa2VsaWhvb2QgPSAuNTsgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uZXh0KCkgPD0gbGlrZWxpaG9vZDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgb25lIGVsZW1lbnQgZnJvbSBhbiBhcnJheSBhdCByYW5kb21cclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5kb20ucHJvdG90eXBlLnBpY2tPbmUgPSBmdW5jdGlvbiAoYXJyYXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFycmF5W3RoaXMuaW50ZWdlcigwLCBhcnJheS5sZW5ndGggLSAxKV07XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgbmV3IGFycmF5IHJhbmRvbSBwaWNraW5nIGVsZW1lbnRzIGZyb20gdGhlIG9yaWdpbmFsXHJcbiAgICAgICAgICogQHBhcmFtIGFycmF5IE9yaWdpbmFsIGFycmF5IHRvIHBpY2sgZnJvbVxyXG4gICAgICAgICAqIEBwYXJhbSBudW1QaWNrcyBjYW4gYmUgYW55IHBvc2l0aXZlIG51bWJlclxyXG4gICAgICAgICAqIEBwYXJhbSBhbGxvd0R1cGxpY2F0ZXMgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIHJldHVybmVkIHNldCBpcyBhbGxvd2VkIGR1cGxpY2F0ZXMgKGl0IGRvZXMgbm90IG1lYW4gdGhlcmUgd2lsbCBhbHdheXMgYmUgZHVwbGljYXRlc1xyXG4gICAgICAgICAqIGp1c3QgdGhhdCBpdCBpcyBwb3NzaWJsZSlcclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5kb20ucHJvdG90eXBlLnBpY2tTZXQgPSBmdW5jdGlvbiAoYXJyYXksIG51bVBpY2tzLCBhbGxvd0R1cGxpY2F0ZXMpIHtcclxuICAgICAgICAgICAgaWYgKGFsbG93RHVwbGljYXRlcyA9PT0gdm9pZCAwKSB7IGFsbG93RHVwbGljYXRlcyA9IGZhbHNlOyB9XHJcbiAgICAgICAgICAgIGlmIChhbGxvd0R1cGxpY2F0ZXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9waWNrU2V0V2l0aER1cGxpY2F0ZXMoYXJyYXksIG51bVBpY2tzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9waWNrU2V0V2l0aG91dER1cGxpY2F0ZXMoYXJyYXksIG51bVBpY2tzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIG5ldyBhcnJheSByYW5kb21seSBwaWNraW5nIGVsZW1lbnRzIGluIHRoZSBvcmlnaW5hbCAobm90IHJldXNlZClcclxuICAgICAgICAgKiBAcGFyYW0gbnVtUGlja3MgbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgYXJyYXkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFuZG9tLnByb3RvdHlwZS5fcGlja1NldFdpdGhvdXREdXBsaWNhdGVzID0gZnVuY3Rpb24gKGFycmF5LCBudW1QaWNrcykge1xyXG4gICAgICAgICAgICBpZiAobnVtUGlja3MgPiBhcnJheS5sZW5ndGggfHwgbnVtUGlja3MgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHBpY2ssIG11c3QgcGljayBhIHZhbHVlIDAgPCBuIDw9IGxlbmd0aCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChudW1QaWNrcyA9PT0gYXJyYXkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShudW1QaWNrcyk7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50UGljayA9IDA7XHJcbiAgICAgICAgICAgIHZhciB0ZW1wQXJyYXkgPSBhcnJheS5zbGljZSgwKTtcclxuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnRQaWNrIDwgbnVtUGlja3MpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW50ZWdlcigwLCB0ZW1wQXJyYXkubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbY3VycmVudFBpY2srK10gPSB0ZW1wQXJyYXlbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgdGVtcEFycmF5LnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBuZXcgYXJyYXkgcmFuZG9tIHBpY2tpbmcgZWxlbWVudHMgZnJvbSB0aGUgb3JpZ2luYWwgYWxsb3dpbmcgZHVwbGljYXRlc1xyXG4gICAgICAgICAqIEBwYXJhbSBudW1QaWNrcyBjYW4gYmUgYW55IHBvc2l0aXZlIG51bWJlclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmRvbS5wcm90b3R5cGUuX3BpY2tTZXRXaXRoRHVwbGljYXRlcyA9IGZ1bmN0aW9uIChhcnJheSwgbnVtUGlja3MpIHtcclxuICAgICAgICAgICAgLy8gVHlwZXNjcmlwdCBudW1iZXJzIGFyZSBhbGwgZmxvYXRpbmcgcG9pbnQsIHNvIGRvIHdlIGFkZCBjaGVjayBmb3IgaW50PyAob3IgZmxvb3IgdGhlIGlucHV0PylcclxuICAgICAgICAgICAgaWYgKG51bVBpY2tzIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG51bWJlciBvZiBlbGVtZW50cyB0byBwaWNrLCBtdXN0IHBpY2sgYSB2YWx1ZSAwIDw9IG4gPCBNQVhfSU5UJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShudW1QaWNrcyk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtUGlja3M7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5waWNrT25lKGFycmF5KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBuZXcgYXJyYXkgdGhhdCBoYXMgaXRzIGVsZW1lbnRzIHNodWZmbGVkLiBVc2luZyB0aGUgRmlzaGVyL1lhdGVzIG1ldGhvZFxyXG4gICAgICAgICAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlciVFMiU4MCU5M1lhdGVzX3NodWZmbGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5kb20ucHJvdG90eXBlLnNodWZmbGUgPSBmdW5jdGlvbiAoYXJyYXkpIHtcclxuICAgICAgICAgICAgdmFyIHRlbXBBcnJheSA9IGFycmF5LnNsaWNlKDApO1xyXG4gICAgICAgICAgICB2YXIgc3dhcCA9IG51bGw7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGVtcEFycmF5Lmxlbmd0aCAtIDI7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJhbmRvbUluZGV4ID0gdGhpcy5pbnRlZ2VyKGksIHRlbXBBcnJheS5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgICAgIHN3YXAgPSB0ZW1wQXJyYXlbaV07XHJcbiAgICAgICAgICAgICAgICB0ZW1wQXJyYXlbaV0gPSB0ZW1wQXJyYXlbcmFuZG9tSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgdGVtcEFycmF5W3JhbmRvbUluZGV4XSA9IHN3YXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRlbXBBcnJheTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdlbmVyYXRlIGEgbGlzdCBvZiByYW5kb20gaW50ZWdlciBudW1iZXJzXHJcbiAgICAgICAgICogQHBhcmFtIGxlbmd0aCB0aGUgbGVuZ3RoIG9mIHRoZSBmaW5hbCBhcnJheVxyXG4gICAgICAgICAqIEBwYXJhbSBtaW4gdGhlIG1pbmltdW0gaW50ZWdlciBudW1iZXIgdG8gZ2VuZXJhdGUgaW5jbHVzaXZlXHJcbiAgICAgICAgICogQHBhcmFtIG1heCB0aGUgbWF4aW11bSBpbnRlZ2VyIG51bWJlciB0byBnZW5lcmF0ZSBpbmNsdXNpdmVcclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5kb20ucHJvdG90eXBlLnJhbmdlID0gZnVuY3Rpb24gKGxlbmd0aCwgbWluLCBtYXgpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShsZW5ndGgpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSB0aGlzLmludGVnZXIobWluLCBtYXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYSBkNCBkaWNlIHJvbGxcclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5kb20ucHJvdG90eXBlLmQ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlZ2VyKDEsIDQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIGEgZDYgZGljZSByb2xsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFuZG9tLnByb3RvdHlwZS5kNiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZWdlcigxLCA2KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiBhIGQ4IGRpY2Ugcm9sbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmRvbS5wcm90b3R5cGUuZDggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVnZXIoMSwgOCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYSBkMTAgZGljZSByb2xsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFuZG9tLnByb3RvdHlwZS5kMTAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVnZXIoMSwgMTApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIGEgZDEyIGRpY2Ugcm9sbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmRvbS5wcm90b3R5cGUuZDEyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlZ2VyKDEsIDEyKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiBhIGQyMCBkaWNlIHJvbGxcclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5kb20ucHJvdG90eXBlLmQyMCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZWdlcigxLCAyMCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gUmFuZG9tO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuUmFuZG9tID0gUmFuZG9tO1xyXG59KTtcclxuZGVmaW5lKFwiQ29sbGlzaW9uL1NpZGVcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogQW4gZW51bSB0aGF0IGRlc2NyaWJlcyB0aGUgc2lkZXMgb2YgYW4gQWN0b3IgZm9yIGNvbGxpc2lvblxyXG4gICAgICovXHJcbiAgICB2YXIgU2lkZTtcclxuICAgIChmdW5jdGlvbiAoU2lkZSkge1xyXG4gICAgICAgIFNpZGVbU2lkZVtcIk5vbmVcIl0gPSAwXSA9IFwiTm9uZVwiO1xyXG4gICAgICAgIFNpZGVbU2lkZVtcIlRvcFwiXSA9IDFdID0gXCJUb3BcIjtcclxuICAgICAgICBTaWRlW1NpZGVbXCJCb3R0b21cIl0gPSAyXSA9IFwiQm90dG9tXCI7XHJcbiAgICAgICAgU2lkZVtTaWRlW1wiTGVmdFwiXSA9IDNdID0gXCJMZWZ0XCI7XHJcbiAgICAgICAgU2lkZVtTaWRlW1wiUmlnaHRcIl0gPSA0XSA9IFwiUmlnaHRcIjtcclxuICAgIH0pKFNpZGUgPSBleHBvcnRzLlNpZGUgfHwgKGV4cG9ydHMuU2lkZSA9IHt9KSk7XHJcbn0pO1xyXG5kZWZpbmUoXCJVdGlsL1V0aWxcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJBbGdlYnJhXCIsIFwiTWF0aC9SYW5kb21cIiwgXCJDb2xsaXNpb24vU2lkZVwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIEFsZ2VicmFfMiwgUmFuZG9tXzEsIFNpZGVfMSkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIFR3byBQSSBjb25zdGFudFxyXG4gICAgICovXHJcbiAgICBleHBvcnRzLlR3b1BJID0gTWF0aC5QSSAqIDI7XHJcbiAgICAvKipcclxuICAgICAqIE1lcmdlcyBvbmUgb3IgbW9yZSBvYmplY3RzIGludG8gYSBzaW5nbGUgdGFyZ2V0IG9iamVjdFxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIE1lcmdlZCBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIGZyb20gb3RoZXIgb2JqZWN0c1xyXG4gICAgICogQGNyZWRpdCBodHRwczovL2dvbWFrZXRoaW5ncy5jb20vdmFuaWxsYS1qYXZhc2NyaXB0LXZlcnNpb24tb2YtanF1ZXJ5LWV4dGVuZC9cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZXh0ZW5kKCkge1xyXG4gICAgICAgIHZhciBleHRlbmRlZCA9IHt9O1xyXG4gICAgICAgIHZhciBkZWVwID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xyXG4gICAgICAgIC8vIENoZWNrIGlmIGEgZGVlcCBtZXJnZVxyXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJndW1lbnRzWzBdKSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nKSB7XHJcbiAgICAgICAgICAgIGRlZXAgPSBhcmd1bWVudHNbMF07XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTWVyZ2UgdGhlIG9iamVjdCBpbnRvIHRoZSBleHRlbmRlZCBvYmplY3RcclxuICAgICAgICB2YXIgYXNzaWduRXhpc3RzID0gdHlwZW9mIE9iamVjdC5hc3NpZ24gPT09ICdmdW5jdGlvbic7XHJcbiAgICAgICAgdmFyIG1lcmdlID0gbnVsbDtcclxuICAgICAgICBpZiAoIWFzc2lnbkV4aXN0cykge1xyXG4gICAgICAgICAgICBtZXJnZSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGRlZXAgbWVyZ2UgYW5kIHByb3BlcnR5IGlzIGFuIG9iamVjdCwgbWVyZ2UgcHJvcGVydGllc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVlcCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqW3Byb3BdKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuZGVkW3Byb3BdID0gZXh0ZW5kKHRydWUsIGV4dGVuZGVkW3Byb3BdLCBvYmpbcHJvcF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kZWRbcHJvcF0gPSBvYmpbcHJvcF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBtZXJnZSA9IE9iamVjdC5hc3NpZ247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIExvb3AgdGhyb3VnaCBlYWNoIG9iamVjdCBhbmQgY29uZHVjdCBhIG1lcmdlXHJcbiAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgb2JqID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBpZiAoIWFzc2lnbkV4aXN0cykge1xyXG4gICAgICAgICAgICAgICAgbWVyZ2Uob2JqKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG1lcmdlKGV4dGVuZGVkLCBvYmopO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBleHRlbmRlZDtcclxuICAgIH1cclxuICAgIGV4cG9ydHMuZXh0ZW5kID0gZXh0ZW5kO1xyXG4gICAgZnVuY3Rpb24gYmFzZTY0RW5jb2RlKGlucHV0U3RyKSB7XHJcbiAgICAgICAgdmFyIGI2NCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XHJcbiAgICAgICAgdmFyIG91dHB1dFN0ciA9ICcnO1xyXG4gICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICB3aGlsZSAoaSA8IGlucHV0U3RyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAvL2FsbCB0aHJlZSBcIiYgMHhmZlwiIGFkZGVkIGJlbG93IGFyZSB0aGVyZSB0byBmaXggYSBrbm93biBidWdcclxuICAgICAgICAgICAgLy93aXRoIGJ5dGVzIHJldHVybmVkIGJ5IHhoci5yZXNwb25zZVRleHRcclxuICAgICAgICAgICAgdmFyIGJ5dGUxID0gaW5wdXRTdHIuY2hhckNvZGVBdChpKyspICYgMHhmZjtcclxuICAgICAgICAgICAgdmFyIGJ5dGUyID0gaW5wdXRTdHIuY2hhckNvZGVBdChpKyspICYgMHhmZjtcclxuICAgICAgICAgICAgdmFyIGJ5dGUzID0gaW5wdXRTdHIuY2hhckNvZGVBdChpKyspICYgMHhmZjtcclxuICAgICAgICAgICAgdmFyIGVuYzEgPSBieXRlMSA+PiAyO1xyXG4gICAgICAgICAgICB2YXIgZW5jMiA9ICgoYnl0ZTEgJiAzKSA8PCA0KSB8IChieXRlMiA+PiA0KTtcclxuICAgICAgICAgICAgdmFyIGVuYzMsIGVuYzQ7XHJcbiAgICAgICAgICAgIGlmIChpc05hTihieXRlMikpIHtcclxuICAgICAgICAgICAgICAgIGVuYzMgPSBlbmM0ID0gNjQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBlbmMzID0gKChieXRlMiAmIDE1KSA8PCAyKSB8IChieXRlMyA+PiA2KTtcclxuICAgICAgICAgICAgICAgIGlmIChpc05hTihieXRlMykpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbmM0ID0gNjQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBlbmM0ID0gYnl0ZTMgJiA2MztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvdXRwdXRTdHIgKz0gYjY0LmNoYXJBdChlbmMxKSArIGI2NC5jaGFyQXQoZW5jMikgKyBiNjQuY2hhckF0KGVuYzMpICsgYjY0LmNoYXJBdChlbmM0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dHB1dFN0cjtcclxuICAgIH1cclxuICAgIGV4cG9ydHMuYmFzZTY0RW5jb2RlID0gYmFzZTY0RW5jb2RlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDbGFtcHMgYSB2YWx1ZSBiZXR3ZWVuIGEgbWluIGFuZCBtYXggaW5jbHVzaXZlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNsYW1wKHZhbCwgbWluLCBtYXgpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobWluLCB2YWwpLCBtYXgpO1xyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5jbGFtcCA9IGNsYW1wO1xyXG4gICAgZnVuY3Rpb24gcmFuZG9tSW5SYW5nZShtaW4sIG1heCwgcmFuZG9tKSB7XHJcbiAgICAgICAgaWYgKHJhbmRvbSA9PT0gdm9pZCAwKSB7IHJhbmRvbSA9IG5ldyBSYW5kb21fMS5SYW5kb20oKTsgfVxyXG4gICAgICAgIHJldHVybiByYW5kb20gPyByYW5kb20uZmxvYXRpbmcobWluLCBtYXgpIDogbWluICsgTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pO1xyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5yYW5kb21JblJhbmdlID0gcmFuZG9tSW5SYW5nZTtcclxuICAgIGZ1bmN0aW9uIHJhbmRvbUludEluUmFuZ2UobWluLCBtYXgsIHJhbmRvbSkge1xyXG4gICAgICAgIGlmIChyYW5kb20gPT09IHZvaWQgMCkgeyByYW5kb20gPSBuZXcgUmFuZG9tXzEuUmFuZG9tKCk7IH1cclxuICAgICAgICByZXR1cm4gcmFuZG9tID8gcmFuZG9tLmludGVnZXIobWluLCBtYXgpIDogTWF0aC5yb3VuZChyYW5kb21JblJhbmdlKG1pbiwgbWF4KSk7XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLnJhbmRvbUludEluUmFuZ2UgPSByYW5kb21JbnRJblJhbmdlO1xyXG4gICAgZnVuY3Rpb24gY2Fub25pY2FsaXplQW5nbGUoYW5nbGUpIHtcclxuICAgICAgICB2YXIgdG1wQW5nbGUgPSBhbmdsZTtcclxuICAgICAgICBpZiAoYW5nbGUgPiBleHBvcnRzLlR3b1BJKSB7XHJcbiAgICAgICAgICAgIHdoaWxlICh0bXBBbmdsZSA+IGV4cG9ydHMuVHdvUEkpIHtcclxuICAgICAgICAgICAgICAgIHRtcEFuZ2xlIC09IGV4cG9ydHMuVHdvUEk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFuZ2xlIDwgMCkge1xyXG4gICAgICAgICAgICB3aGlsZSAodG1wQW5nbGUgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICB0bXBBbmdsZSArPSBleHBvcnRzLlR3b1BJO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0bXBBbmdsZTtcclxuICAgIH1cclxuICAgIGV4cG9ydHMuY2Fub25pY2FsaXplQW5nbGUgPSBjYW5vbmljYWxpemVBbmdsZTtcclxuICAgIGZ1bmN0aW9uIHRvRGVncmVlcyhyYWRpYW5zKSB7XHJcbiAgICAgICAgcmV0dXJuIDE4MCAvIE1hdGguUEkgKiByYWRpYW5zO1xyXG4gICAgfVxyXG4gICAgZXhwb3J0cy50b0RlZ3JlZXMgPSB0b0RlZ3JlZXM7XHJcbiAgICBmdW5jdGlvbiB0b1JhZGlhbnMoZGVncmVlcykge1xyXG4gICAgICAgIHJldHVybiBkZWdyZWVzIC8gMTgwICogTWF0aC5QSTtcclxuICAgIH1cclxuICAgIGV4cG9ydHMudG9SYWRpYW5zID0gdG9SYWRpYW5zO1xyXG4gICAgZnVuY3Rpb24gZ2V0UG9zaXRpb24oZWwpIHtcclxuICAgICAgICB2YXIgb0xlZnQgPSAwLCBvVG9wID0gMDtcclxuICAgICAgICB2YXIgY2FsY09mZnNldExlZnQgPSBmdW5jdGlvbiAocGFyZW50KSB7XHJcbiAgICAgICAgICAgIG9MZWZ0ICs9IHBhcmVudC5vZmZzZXRMZWZ0O1xyXG4gICAgICAgICAgICBpZiAocGFyZW50Lm9mZnNldFBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgY2FsY09mZnNldExlZnQocGFyZW50Lm9mZnNldFBhcmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBjYWxjT2Zmc2V0VG9wID0gZnVuY3Rpb24gKHBhcmVudCkge1xyXG4gICAgICAgICAgICBvVG9wICs9IHBhcmVudC5vZmZzZXRUb3A7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnQub2Zmc2V0UGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBjYWxjT2Zmc2V0VG9wKHBhcmVudC5vZmZzZXRQYXJlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjYWxjT2Zmc2V0TGVmdChlbCk7XHJcbiAgICAgICAgY2FsY09mZnNldFRvcChlbCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBBbGdlYnJhXzIuVmVjdG9yKG9MZWZ0LCBvVG9wKTtcclxuICAgIH1cclxuICAgIGV4cG9ydHMuZ2V0UG9zaXRpb24gPSBnZXRQb3NpdGlvbjtcclxuICAgIGZ1bmN0aW9uIGFkZEl0ZW1Ub0FycmF5KGl0ZW0sIGFycmF5KSB7XHJcbiAgICAgICAgaWYgKGFycmF5LmluZGV4T2YoaXRlbSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIGFycmF5LnB1c2goaXRlbSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLmFkZEl0ZW1Ub0FycmF5ID0gYWRkSXRlbVRvQXJyYXk7XHJcbiAgICBmdW5jdGlvbiByZW1vdmVJdGVtRnJvbUFycmF5KGl0ZW0sIGFycmF5KSB7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gLTE7XHJcbiAgICAgICAgaWYgKChpbmRleCA9IGFycmF5LmluZGV4T2YoaXRlbSkpID4gLTEpIHtcclxuICAgICAgICAgICAgYXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGV4cG9ydHMucmVtb3ZlSXRlbUZyb21BcnJheSA9IHJlbW92ZUl0ZW1Gcm9tQXJyYXk7XHJcbiAgICBmdW5jdGlvbiBjb250YWlucyhhcnJheSwgb2JqKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoYXJyYXlbaV0gPT09IG9iaikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5jb250YWlucyA9IGNvbnRhaW5zO1xyXG4gICAgZnVuY3Rpb24gZ2V0T3Bwb3NpdGVTaWRlKHNpZGUpIHtcclxuICAgICAgICBpZiAoc2lkZSA9PT0gU2lkZV8xLlNpZGUuVG9wKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTaWRlXzEuU2lkZS5Cb3R0b207XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaWRlID09PSBTaWRlXzEuU2lkZS5Cb3R0b20pIHtcclxuICAgICAgICAgICAgcmV0dXJuIFNpZGVfMS5TaWRlLlRvcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNpZGUgPT09IFNpZGVfMS5TaWRlLkxlZnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFNpZGVfMS5TaWRlLlJpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2lkZSA9PT0gU2lkZV8xLlNpZGUuUmlnaHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFNpZGVfMS5TaWRlLkxlZnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBTaWRlXzEuU2lkZS5Ob25lO1xyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5nZXRPcHBvc2l0ZVNpZGUgPSBnZXRPcHBvc2l0ZVNpZGU7XHJcbiAgICBmdW5jdGlvbiBnZXRTaWRlRnJvbVZlY3RvcihkaXJlY3Rpb24pIHtcclxuICAgICAgICB2YXIgZGlyZWN0aW9ucyA9IFtBbGdlYnJhXzIuVmVjdG9yLkxlZnQsIEFsZ2VicmFfMi5WZWN0b3IuUmlnaHQsIEFsZ2VicmFfMi5WZWN0b3IuVXAsIEFsZ2VicmFfMi5WZWN0b3IuRG93bl07XHJcbiAgICAgICAgdmFyIGRpcmVjdGlvbkVudW0gPSBbU2lkZV8xLlNpZGUuTGVmdCwgU2lkZV8xLlNpZGUuUmlnaHQsIFNpZGVfMS5TaWRlLlRvcCwgU2lkZV8xLlNpZGUuQm90dG9tXTtcclxuICAgICAgICB2YXIgbWF4ID0gLU51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgdmFyIG1heEluZGV4ID0gLTE7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb25zW2ldLmRvdChkaXJlY3Rpb24pID4gbWF4KSB7XHJcbiAgICAgICAgICAgICAgICBtYXggPSBkaXJlY3Rpb25zW2ldLmRvdChkaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgbWF4SW5kZXggPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkaXJlY3Rpb25FbnVtW21heEluZGV4XTtcclxuICAgIH1cclxuICAgIGV4cG9ydHMuZ2V0U2lkZUZyb21WZWN0b3IgPSBnZXRTaWRlRnJvbVZlY3RvcjtcclxuICAgIC8qKlxyXG4gICAgICogRXhjYWxpYnVyJ3MgZHluYW1pY2FsbHkgcmVzaXppbmcgY29sbGVjdGlvblxyXG4gICAgICovXHJcbiAgICB2YXIgQ29sbGVjdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIGluaXRpYWxTaXplICBJbml0aWFsIHNpemUgb2YgdGhlIGludGVybmFsIGJhY2tpbmcgYXJyYXlcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBDb2xsZWN0aW9uKGluaXRpYWxTaXplKSB7XHJcbiAgICAgICAgICAgIGlmIChpbml0aWFsU2l6ZSA9PT0gdm9pZCAwKSB7IGluaXRpYWxTaXplID0gQ29sbGVjdGlvbi5EZWZhdWx0U2l6ZTsgfVxyXG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbEFycmF5ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5fZW5kUG9pbnRlciA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsQXJyYXkgPSBuZXcgQXJyYXkoaW5pdGlhbFNpemUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5fcmVzaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbmV3U2l6ZSA9IHRoaXMuX2ludGVybmFsQXJyYXkubGVuZ3RoICogMjtcclxuICAgICAgICAgICAgdmFyIG5ld0FycmF5ID0gbmV3IEFycmF5KG5ld1NpemUpO1xyXG4gICAgICAgICAgICB2YXIgY291bnQgPSB0aGlzLmNvdW50KCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbmV3QXJyYXlbaV0gPSB0aGlzLl9pbnRlcm5hbEFycmF5W2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9pbnRlcm5hbEFycmF5O1xyXG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbEFycmF5ID0gbmV3QXJyYXk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQdXNoIGVsZW1lbnRzIHRvIHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2VuZFBvaW50ZXIgPT09IHRoaXMuX2ludGVybmFsQXJyYXkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNpemUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxBcnJheVt0aGlzLl9lbmRQb2ludGVyKytdID0gZWxlbWVudDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgZWxlbWVudHMgZnJvbSB0aGUgZW5kIG9mIHRoZSBjb2xsZWN0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9lbmRQb2ludGVyID0gdGhpcy5fZW5kUG9pbnRlciAtIDEgPCAwID8gMCA6IHRoaXMuX2VuZFBvaW50ZXIgLSAxO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxBcnJheVt0aGlzLl9lbmRQb2ludGVyXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIGNvdW50IG9mIHRoZSBjb2xsZWN0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbmRQb2ludGVyO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW1wdGllcyB0aGUgY29sbGVjdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9lbmRQb2ludGVyID0gMDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIHNpemUgb2YgdGhlIGludGVybmFsIGJhY2tpbmcgYXJyYXlcclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5pbnRlcm5hbFNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbEFycmF5Lmxlbmd0aDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYW4gZWxlbWVudCBhdCBhIHNwZWNpZmljIGluZGV4XHJcbiAgICAgICAgICogQHBhcmFtIGluZGV4ICBJbmRleCBvZiBlbGVtZW50IHRvIHJldHJpZXZlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuZWxlbWVudEF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSB0aGlzLmNvdW50KCkpIHtcclxuICAgICAgICAgICAgICAgIC8vTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoJ0ludmFsaWQgcGFyYW1ldGVyOiAnICsgaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGluZGV4ICcgKyBpbmRleCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsQXJyYXlbaW5kZXhdO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5zZXJ0cyBhbiBlbGVtZW50IGF0IGEgc3BlY2lmaWMgaW5kZXhcclxuICAgICAgICAgKiBAcGFyYW0gaW5kZXggIEluZGV4IHRvIGluc2VydCB0aGUgZWxlbWVudFxyXG4gICAgICAgICAqIEBwYXJhbSB2YWx1ZSAgRWxlbWVudCB0byBpbnNlcnRcclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSB0aGlzLmNvdW50KCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbEFycmF5W2luZGV4XSA9IHZhbHVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlcyBhbiBlbGVtZW50IGF0IGEgc3BlY2lmaWMgaW5kZXhcclxuICAgICAgICAgKiBAcGFyYW0gaW5kZXggIEluZGV4IG9mIGVsZW1lbnQgdG8gcmVtb3ZlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgICAgIHZhciBjb3VudCA9IHRoaXMuY291bnQoKTtcclxuICAgICAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvL0xvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKCdJbnZhbGlkIHBhcmFtZXRlcjogJyArIGluZGV4KTtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYXJhbWV0ZXIgJyArIGluZGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBPKG4pIFNoaWZ0XHJcbiAgICAgICAgICAgIHZhciByZW1vdmVkID0gdGhpcy5faW50ZXJuYWxBcnJheVtpbmRleF07XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBpbmRleDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ludGVybmFsQXJyYXlbaV0gPSB0aGlzLl9pbnRlcm5hbEFycmF5W2kgKyAxXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9lbmRQb2ludGVyLS07XHJcbiAgICAgICAgICAgIHJldHVybiByZW1vdmVkO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlcyBhbiBlbGVtZW50IGJ5IHJlZmVyZW5jZVxyXG4gICAgICAgICAqIEBwYXJhbSBlbGVtZW50ICBFbGVtZW50IHRvIHJldHJpZXZlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUucmVtb3ZlRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX2ludGVybmFsQXJyYXkuaW5kZXhPZihlbGVtZW50KTtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmUoaW5kZXgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIGFycmF5IHJlcHJlc2VudGluZyB0aGUgY29sbGVjdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbEFycmF5LnNsaWNlKDAsIHRoaXMuX2VuZFBvaW50ZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSXRlcmF0ZSBvdmVyIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIGNvbGxlY3Rpb25cclxuICAgICAgICAgKiBAcGFyYW0gZnVuYyAgQ2FsbGJhY2sgdG8gY2FsbCBmb3IgZWFjaCBlbGVtZW50IHBhc3NpbmcgYSByZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQgYW5kIGl0cyBpbmRleCwgcmV0dXJuZWQgdmFsdWVzIGFyZSBpZ25vcmVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmdW5jKSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gMCwgY291bnQgPSB0aGlzLmNvdW50KCk7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGZ1bmMuY2FsbCh0aGlzLCB0aGlzLl9pbnRlcm5hbEFycmF5W2ldLCBpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTXV0YXRlIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIGNvbGxlY3Rpb25cclxuICAgICAgICAgKiBAcGFyYW0gZnVuYyAgQ2FsbGJhY2sgdG8gY2FsbCBmb3IgZWFjaCBlbGVtZW50IHBhc3NpbmcgYSByZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQgYW5kIGl0cyBpbmRleCwgYW55IHZhbHVlcyByZXR1cm5lZCBtdXRhdGVcclxuICAgICAgICAgKiB0aGUgY29sbGVjdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmdW5jKSB7XHJcbiAgICAgICAgICAgIHZhciBjb3VudCA9IHRoaXMuY291bnQoKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcm5hbEFycmF5W2ldID0gZnVuYy5jYWxsKHRoaXMsIHRoaXMuX2ludGVybmFsQXJyYXlbaV0sIGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gQ29sbGVjdGlvbjtcclxuICAgIH0oKSk7XHJcbiAgICAvKipcclxuICAgICAqIERlZmF1bHQgY29sbGVjdGlvbiBzaXplXHJcbiAgICAgKi9cclxuICAgIENvbGxlY3Rpb24uRGVmYXVsdFNpemUgPSAyMDA7XHJcbiAgICBleHBvcnRzLkNvbGxlY3Rpb24gPSBDb2xsZWN0aW9uO1xyXG59KTtcclxuZGVmaW5lKFwiQ2FtZXJhXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiVXRpbC9FYXNpbmdGdW5jdGlvbnNcIiwgXCJQcm9taXNlc1wiLCBcIkFsZ2VicmFcIiwgXCJVdGlsL1V0aWxcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBFYXNpbmdGdW5jdGlvbnNfMSwgUHJvbWlzZXNfMSwgQWxnZWJyYV8zLCBVdGlsXzEpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb250YWluZXIgdG8gaG91c2UgY29udmVuaWVuY2Ugc3RyYXRlZ3kgbWV0aG9kc1xyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHZhciBTdHJhdGVneUNvbnRhaW5lciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gU3RyYXRlZ3lDb250YWluZXIoY2FtZXJhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGFuZCBhZGRzIHRoZSBbW0xvY2tDYW1lcmFUb0FjdG9yU3RyYXRlZ3ldXSBvbiB0aGUgY3VycmVudCBjYW1lcmEuXHJcbiAgICAgICAgICogQHBhcmFtIGFjdG9yIFRoZSBhY3RvciB0byBsb2NrIHRoZSBjYW1lcmEgdG9cclxuICAgICAgICAgKi9cclxuICAgICAgICBTdHJhdGVneUNvbnRhaW5lci5wcm90b3R5cGUubG9ja1RvQWN0b3IgPSBmdW5jdGlvbiAoYWN0b3IpIHtcclxuICAgICAgICAgICAgdGhpcy5jYW1lcmEuYWRkU3RyYXRlZ3kobmV3IExvY2tDYW1lcmFUb0FjdG9yU3RyYXRlZ3koYWN0b3IpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYW5kIGFkZHMgdGhlIFtbTG9ja0NhbWVyYVRvQWN0b3JBeGlzU3RyYXRlZ3ldXSBvbiB0aGUgY3VycmVudCBjYW1lcmFcclxuICAgICAgICAgKiBAcGFyYW0gYWN0b3IgVGhlIGFjdG9yIHRvIGxvY2sgdGhlIGNhbWVyYSB0b1xyXG4gICAgICAgICAqIEBwYXJhbSBheGlzIFRoZSBheGlzIHRvIGZvbGxvdyB0aGUgYWN0b3Igb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBTdHJhdGVneUNvbnRhaW5lci5wcm90b3R5cGUubG9ja1RvQWN0b3JBeGlzID0gZnVuY3Rpb24gKGFjdG9yLCBheGlzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhLmFkZFN0cmF0ZWd5KG5ldyBMb2NrQ2FtZXJhVG9BY3RvckF4aXNTdHJhdGVneShhY3RvciwgYXhpcykpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhbmQgYWRkcyB0aGUgW1tFbGFzdGljVG9BY3RvclN0cmF0ZWd5XV0gb24gdGhlIGN1cnJlbnQgY2FtZXJhXHJcbiAgICAgICAgICogSWYgY2FtZXJhRWxhc3RpY2l0eSA8IGNhbWVyYUZyaWN0aW9uIDwgMS4wLCB0aGUgYmVoYXZpb3Igd2lsbCBiZSBhIGRhbXBlbmVkIHNwcmluZyB0aGF0IHdpbGwgc2xvd2x5IGVuZCBhdCB0aGUgdGFyZ2V0IHdpdGhvdXQgYm91bmNpbmdcclxuICAgICAgICAgKiBJZiBjYW1lcmFGcmljdGlvbiA8IGNhbWVyYUVsYXN0aWNpdHkgPCAxLjAsIHRoZSBiZWhhdmlvciB3aWxsIGJlIGFuIG9zY2lsbGF0aW9uZyBzcHJpbmcgdGhhdCB3aWxsIG92ZXJcclxuICAgICAgICAgKiBjb3JyZWN0IGFuZCBib3VuY2UgYXJvdW5kIHRoZSB0YXJnZXRcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB0YXJnZXQgVGFyZ2V0IGFjdG9yIHRvIGVsYXN0aWNhbGx5IGZvbGxvd1xyXG4gICAgICAgICAqIEBwYXJhbSBjYW1lcmFFbGFzdGljaXR5IFswIC0gMS4wXSBUaGUgaGlnaGVyIHRoZSBlbGFzdGljaXR5IHRoZSBtb3JlIGZvcmNlIHRoYXQgd2lsbCBkcml2ZSB0aGUgY2FtZXJhIHRvd2FyZHMgdGhlIHRhcmdldFxyXG4gICAgICAgICAqIEBwYXJhbSBjYW1lcmFGcmljdGlvbiBbMCAtIDEuMF0gVGhlIGhpZ2hlciB0aGUgZnJpY3Rpb24gdGhlIG1vcmUgdGhhdCB0aGUgY2FtZXJhIHdpbGwgcmVzaXN0IG1vdGlvbiB0b3dhcmRzIHRoZSB0YXJnZXRcclxuICAgICAgICAgKi9cclxuICAgICAgICBTdHJhdGVneUNvbnRhaW5lci5wcm90b3R5cGUuZWxhc3RpY1RvQWN0b3IgPSBmdW5jdGlvbiAoYWN0b3IsIGNhbWVyYUVsYXN0aWNpdHksIGNhbWVyYUZyaWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhLmFkZFN0cmF0ZWd5KG5ldyBFbGFzdGljVG9BY3RvclN0cmF0ZWd5KGFjdG9yLCBjYW1lcmFFbGFzdGljaXR5LCBjYW1lcmFGcmljdGlvbikpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhbmQgYWRkcyB0aGUgW1tSYWRpdXNBcm91bmRBY3RvclN0cmF0ZWd5XV0gb24gdGhlIGN1cnJlbnQgY2FtZXJhXHJcbiAgICAgICAgICogQHBhcmFtIHRhcmdldCBUYXJnZXQgYWN0b3IgdG8gZm9sbG93IHdoZW4gaXQgaXMgXCJyYWRpdXNcIiBwaXhlbHMgYXdheVxyXG4gICAgICAgICAqIEBwYXJhbSByYWRpdXMgTnVtYmVyIG9mIHBpeGVscyBhd2F5IGJlZm9yZSB0aGUgY2FtZXJhIHdpbGwgZm9sbG93XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU3RyYXRlZ3lDb250YWluZXIucHJvdG90eXBlLnJhZGl1c0Fyb3VuZEFjdG9yID0gZnVuY3Rpb24gKGFjdG9yLCByYWRpdXMpIHtcclxuICAgICAgICAgICAgdGhpcy5jYW1lcmEuYWRkU3RyYXRlZ3kobmV3IFJhZGl1c0Fyb3VuZEFjdG9yU3RyYXRlZ3koYWN0b3IsIHJhZGl1cykpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFN0cmF0ZWd5Q29udGFpbmVyO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuU3RyYXRlZ3lDb250YWluZXIgPSBTdHJhdGVneUNvbnRhaW5lcjtcclxuICAgIC8qKlxyXG4gICAgICogQ2FtZXJhIGF4aXMgZW51bVxyXG4gICAgICovXHJcbiAgICB2YXIgQXhpcztcclxuICAgIChmdW5jdGlvbiAoQXhpcykge1xyXG4gICAgICAgIEF4aXNbQXhpc1tcIlhcIl0gPSAwXSA9IFwiWFwiO1xyXG4gICAgICAgIEF4aXNbQXhpc1tcIllcIl0gPSAxXSA9IFwiWVwiO1xyXG4gICAgfSkoQXhpcyA9IGV4cG9ydHMuQXhpcyB8fCAoZXhwb3J0cy5BeGlzID0ge30pKTtcclxuICAgIC8qKlxyXG4gICAgICogTG9jayBhIGNhbWVyYSB0byB0aGUgZXhhY3QgeC95IHBvc3RpdGlvbiBvZiBhbiBhY3Rvci5cclxuICAgICAqL1xyXG4gICAgdmFyIExvY2tDYW1lcmFUb0FjdG9yU3RyYXRlZ3kgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIExvY2tDYW1lcmFUb0FjdG9yU3RyYXRlZ3kodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICB0aGlzLmFjdGlvbiA9IGZ1bmN0aW9uICh0YXJnZXQsIF9jYW0sIF9lbmcsIF9kZWx0YSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNlbnRlciA9IHRhcmdldC5nZXRDZW50ZXIoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjZW50ZXI7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBMb2NrQ2FtZXJhVG9BY3RvclN0cmF0ZWd5O1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuTG9ja0NhbWVyYVRvQWN0b3JTdHJhdGVneSA9IExvY2tDYW1lcmFUb0FjdG9yU3RyYXRlZ3k7XHJcbiAgICAvKipcclxuICAgICAqIExvY2sgYSBjYW1lcmEgdG8gYSBzcGVjaWZpYyBheGlzIGFyb3VuZCBhbiBhY3Rvci5cclxuICAgICAqL1xyXG4gICAgdmFyIExvY2tDYW1lcmFUb0FjdG9yQXhpc1N0cmF0ZWd5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBMb2NrQ2FtZXJhVG9BY3RvckF4aXNTdHJhdGVneSh0YXJnZXQsIGF4aXMpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIHRoaXMuYXhpcyA9IGF4aXM7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uID0gZnVuY3Rpb24gKHRhcmdldCwgY2FtLCBfZW5nLCBfZGVsdGEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjZW50ZXIgPSB0YXJnZXQuZ2V0Q2VudGVyKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudEZvY3VzID0gY2FtLmdldEZvY3VzKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuYXhpcyA9PT0gQXhpcy5YKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBbGdlYnJhXzMuVmVjdG9yKGNlbnRlci54LCBjdXJyZW50Rm9jdXMueSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFsZ2VicmFfMy5WZWN0b3IoY3VycmVudEZvY3VzLngsIGNlbnRlci55KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIExvY2tDYW1lcmFUb0FjdG9yQXhpc1N0cmF0ZWd5O1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuTG9ja0NhbWVyYVRvQWN0b3JBeGlzU3RyYXRlZ3kgPSBMb2NrQ2FtZXJhVG9BY3RvckF4aXNTdHJhdGVneTtcclxuICAgIC8qKlxyXG4gICAgICogVXNpbmcgW0hvb2sncyBsYXddKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hvb2tlJ3NfbGF3KSwgZWxhc3RpY2FsbHkgbW92ZSB0aGUgY2FtZXJhIHRvd2FyZHMgdGhlIHRhcmdldCBhY3Rvci5cclxuICAgICAqL1xyXG4gICAgdmFyIEVsYXN0aWNUb0FjdG9yU3RyYXRlZ3kgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIGNhbWVyYUVsYXN0aWNpdHkgPCBjYW1lcmFGcmljdGlvbiA8IDEuMCwgdGhlIGJlaGF2aW9yIHdpbGwgYmUgYSBkYW1wZW5lZCBzcHJpbmcgdGhhdCB3aWxsIHNsb3dseSBlbmQgYXQgdGhlIHRhcmdldCB3aXRob3V0IGJvdW5jaW5nXHJcbiAgICAgICAgICogSWYgY2FtZXJhRnJpY3Rpb24gPCBjYW1lcmFFbGFzdGljaXR5IDwgMS4wLCB0aGUgYmVoYXZpb3Igd2lsbCBiZSBhbiBvc2NpbGxhdGlvbmcgc3ByaW5nIHRoYXQgd2lsbCBvdmVyXHJcbiAgICAgICAgICogY29ycmVjdCBhbmQgYm91bmNlIGFyb3VuZCB0aGUgdGFyZ2V0XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRhcmdldCBhY3RvciB0byBlbGFzdGljYWxseSBmb2xsb3dcclxuICAgICAgICAgKiBAcGFyYW0gY2FtZXJhRWxhc3RpY2l0eSBbMCAtIDEuMF0gVGhlIGhpZ2hlciB0aGUgZWxhc3RpY2l0eSB0aGUgbW9yZSBmb3JjZSB0aGF0IHdpbGwgZHJpdmUgdGhlIGNhbWVyYSB0b3dhcmRzIHRoZSB0YXJnZXRcclxuICAgICAgICAgKiBAcGFyYW0gY2FtZXJhRnJpY3Rpb24gWzAgLSAxLjBdIFRoZSBoaWdoZXIgdGhlIGZyaWN0aW9uIHRoZSBtb3JlIHRoYXQgdGhlIGNhbWVyYSB3aWxsIHJlc2lzdCBtb3Rpb24gdG93YXJkcyB0aGUgdGFyZ2V0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gRWxhc3RpY1RvQWN0b3JTdHJhdGVneSh0YXJnZXQsIGNhbWVyYUVsYXN0aWNpdHksIGNhbWVyYUZyaWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICB0aGlzLmNhbWVyYUVsYXN0aWNpdHkgPSBjYW1lcmFFbGFzdGljaXR5O1xyXG4gICAgICAgICAgICB0aGlzLmNhbWVyYUZyaWN0aW9uID0gY2FtZXJhRnJpY3Rpb247XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uID0gZnVuY3Rpb24gKHRhcmdldCwgY2FtLCBfZW5nLCBfZGVsdGEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHRhcmdldC5nZXRDZW50ZXIoKTtcclxuICAgICAgICAgICAgICAgIHZhciBmb2N1cyA9IGNhbS5nZXRGb2N1cygpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNhbWVyYVZlbCA9IG5ldyBBbGdlYnJhXzMuVmVjdG9yKGNhbS5keCwgY2FtLmR5KTtcclxuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgc3RyZWNoIHZlY3RvciwgdXNpbmcgdGhlIHNwcmluZyBlcXVhdGlvblxyXG4gICAgICAgICAgICAgICAgLy8gRiA9IGtYXHJcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ib29rZSdzX2xhd1xyXG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgdG8gdGhlIGN1cnJlbnQgY2FtZXJhIHZlbG9jaXR5XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RyZXRjaCA9IHBvc2l0aW9uLnN1Yihmb2N1cykuc2NhbGUoX3RoaXMuY2FtZXJhRWxhc3RpY2l0eSk7IC8vIHN0cmV0Y2ggaXMgWFxyXG4gICAgICAgICAgICAgICAgY2FtZXJhVmVsID0gY2FtZXJhVmVsLmFkZChzdHJldGNoKTtcclxuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZnJpY3Rpb24gKC0xIHRvIGFwcGx5IGEgZm9yY2UgaW4gdGhlIG9wcG9zaXRpb24gb2YgbW90aW9uKVxyXG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgdG8gdGhlIGN1cnJlbnQgY2FtZXJhIHZlbG9jaXR5XHJcbiAgICAgICAgICAgICAgICB2YXIgZnJpY3Rpb24gPSBjYW1lcmFWZWwuc2NhbGUoLTEpLnNjYWxlKF90aGlzLmNhbWVyYUZyaWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIGNhbWVyYVZlbCA9IGNhbWVyYVZlbC5hZGQoZnJpY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHBvc2l0aW9uIGJ5IHZlbG9jaXR5IGRlbHRhc1xyXG4gICAgICAgICAgICAgICAgZm9jdXMgPSBmb2N1cy5hZGQoY2FtZXJhVmVsKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmb2N1cztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEVsYXN0aWNUb0FjdG9yU3RyYXRlZ3k7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5FbGFzdGljVG9BY3RvclN0cmF0ZWd5ID0gRWxhc3RpY1RvQWN0b3JTdHJhdGVneTtcclxuICAgIHZhciBSYWRpdXNBcm91bmRBY3RvclN0cmF0ZWd5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB0YXJnZXQgVGFyZ2V0IGFjdG9yIHRvIGZvbGxvdyB3aGVuIGl0IGlzIFwicmFkaXVzXCIgcGl4ZWxzIGF3YXlcclxuICAgICAgICAgKiBAcGFyYW0gcmFkaXVzIE51bWJlciBvZiBwaXhlbHMgYXdheSBiZWZvcmUgdGhlIGNhbWVyYSB3aWxsIGZvbGxvd1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIFJhZGl1c0Fyb3VuZEFjdG9yU3RyYXRlZ3kodGFyZ2V0LCByYWRpdXMpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIHRoaXMucmFkaXVzID0gcmFkaXVzO1xyXG4gICAgICAgICAgICB0aGlzLmFjdGlvbiA9IGZ1bmN0aW9uICh0YXJnZXQsIGNhbSwgX2VuZywgX2RlbHRhKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSB0YXJnZXQuZ2V0Q2VudGVyKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZm9jdXMgPSBjYW0uZ2V0Rm9jdXMoKTtcclxuICAgICAgICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSBwb3NpdGlvbi5zdWIoZm9jdXMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gZGlyZWN0aW9uLm1hZ25pdHVkZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlID49IF90aGlzLnJhZGl1cykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBkaXN0YW5jZSAtIF90aGlzLnJhZGl1cztcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm9jdXMuYWRkKGRpcmVjdGlvbi5ub3JtYWxpemUoKS5zY2FsZShvZmZzZXQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmb2N1cztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFJhZGl1c0Fyb3VuZEFjdG9yU3RyYXRlZ3k7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5SYWRpdXNBcm91bmRBY3RvclN0cmF0ZWd5ID0gUmFkaXVzQXJvdW5kQWN0b3JTdHJhdGVneTtcclxuICAgIC8qKlxyXG4gICAgICogQ2FtZXJhc1xyXG4gICAgICpcclxuICAgICAqIFtbQmFzZUNhbWVyYV1dIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBhbGwgRXhjYWxpYnVyIGNhbWVyYXMuIENhbWVyYXMgYXJlIHVzZWRcclxuICAgICAqIHRvIG1vdmUgYXJvdW5kIHlvdXIgZ2FtZSBhbmQgc2V0IGZvY3VzLiBUaGV5IGFyZSB1c2VkIHRvIGRldGVybWluZVxyXG4gICAgICogd2hhdCBpcyBcIm9mZiBzY3JlZW5cIiBhbmQgY2FuIGJlIHVzZWQgdG8gc2NhbGUgdGhlIGdhbWUuXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOkNhbWVyYXMubWRdXVxyXG4gICAgICovXHJcbiAgICB2YXIgQmFzZUNhbWVyYSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gQmFzZUNhbWVyYSgpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2FtZXJhU3RyYXRlZ2llcyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLnN0cmF0ZWd5ID0gbmV3IFN0cmF0ZWd5Q29udGFpbmVyKHRoaXMpO1xyXG4gICAgICAgICAgICAvLyBjYW1lcmEgcGh5c2ljYWwgcXVhbnRpdGllc1xyXG4gICAgICAgICAgICB0aGlzLnogPSAxO1xyXG4gICAgICAgICAgICB0aGlzLmR4ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5keSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuZHogPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmF4ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5heSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuYXogPSAwO1xyXG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uID0gMDtcclxuICAgICAgICAgICAgdGhpcy5yeCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3ggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl95ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fY2FtZXJhTW92aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRMZXJwVGltZSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2xlcnBEdXJhdGlvbiA9IDEwMDA7IC8vIDEgc2Vjb25kICAgXHJcbiAgICAgICAgICAgIHRoaXMuX2xlcnBTdGFydCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuX2xlcnBFbmQgPSBudWxsO1xyXG4gICAgICAgICAgICAvL2NhbWVyYSBlZmZlY3RzXHJcbiAgICAgICAgICAgIHRoaXMuX2lzU2hha2luZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9zaGFrZU1hZ25pdHVkZVggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9zaGFrZU1hZ25pdHVkZVkgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9zaGFrZUR1cmF0aW9uID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fZWxhcHNlZFNoYWtlVGltZSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3hTaGFrZSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3lTaGFrZSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzWm9vbWluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9tYXhab29tU2NhbGUgPSAxO1xyXG4gICAgICAgICAgICB0aGlzLl96b29tSW5jcmVtZW50ID0gMC4wMTtcclxuICAgICAgICAgICAgdGhpcy5fZWFzaW5nID0gRWFzaW5nRnVuY3Rpb25zXzEuRWFzaW5nRnVuY3Rpb25zLkVhc2VJbk91dEN1YmljO1xyXG4gICAgICAgIH1cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZUNhbWVyYS5wcm90b3R5cGUsIFwieFwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXQgdGhlIGNhbWVyYSdzIHggcG9zaXRpb25cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3g7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXQgdGhlIGNhbWVyYSdzIHggcG9zaXRpb24gKGNhbm5vdCBiZSBzZXQgd2hlbiBmb2xsb3dpbmcgYW4gW1tBY3Rvcl1dIG9yIHdoZW4gbW92aW5nKVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fZm9sbG93ICYmICF0aGlzLl9jYW1lcmFNb3ZpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl94ID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlQ2FtZXJhLnByb3RvdHlwZSwgXCJ5XCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldCB0aGUgY2FtZXJhJ3MgeSBwb3NpdGlvblxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5feTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldCB0aGUgY2FtZXJhJ3MgeSBwb3NpdGlvbiAoY2Fubm90IGJlIHNldCB3aGVuIGZvbGxvd2luZyBhbiBbW0FjdG9yXV0gb3Igd2hlbiBtb3ZpbmcpXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9mb2xsb3cgJiYgIXRoaXMuX2NhbWVyYU1vdmluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3kgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VDYW1lcmEucHJvdG90eXBlLCBcInBvc1wiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXQgdGhlIGNhbWVyYSdzIHBvc2l0aW9uIGFzIGEgdmVjdG9yXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWxnZWJyYV8zLlZlY3Rvcih0aGlzLngsIHRoaXMueSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXQgdGhlIGNhbWVyYXMgcG9zaXRpb25cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnggPSB2YWx1ZS54O1xyXG4gICAgICAgICAgICAgICAgdGhpcy55ID0gdmFsdWUueTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VDYW1lcmEucHJvdG90eXBlLCBcInZlbFwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXQgdGhlIGNhbWVyYSdzIHZlbG9jaXR5IGFzIGEgdmVjdG9yXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWxnZWJyYV8zLlZlY3Rvcih0aGlzLmR4LCB0aGlzLmR5KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldCB0aGUgY2FtZXJhJ3MgdmVsb2NpdHlcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmR4ID0gdmFsdWUueDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZHkgPSB2YWx1ZS55O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBmb2NhbCBwb2ludCBvZiB0aGUgY2FtZXJhLCBhIG5ldyBwb2ludCBnaXZpbmcgdGhlIHggYW5kIHkgcG9zaXRpb24gb2YgdGhlIGNhbWVyYVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJhc2VDYW1lcmEucHJvdG90eXBlLmdldEZvY3VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFsZ2VicmFfMy5WZWN0b3IodGhpcy54LCB0aGlzLnkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBtb3ZlcyB0aGUgY2FtZXJhIGZvY2FsIHBvaW50IHRvIHRoZSBzcGVjaWZpZWQgcG9zaXRpb24gdXNpbmcgc3BlY2lmaWVkIGVhc2luZyBmdW5jdGlvbi4gQ2Fubm90IG1vdmUgd2hlbiBmb2xsb3dpbmcgYW4gQWN0b3IuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gcG9zIFRoZSB0YXJnZXQgcG9zaXRpb24gdG8gbW92ZSB0b1xyXG4gICAgICAgICAqIEBwYXJhbSBkdXJhdGlvbiBUaGUgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzIHRoZSBtb3ZlIHNob3VsZCBsYXN0XHJcbiAgICAgICAgICogQHBhcmFtIFtlYXNpbmdGbl0gQW4gb3B0aW9uYWwgZWFzaW5nIGZ1bmN0aW9uIChbW2V4LkVhc2luZ0Z1bmN0aW9ucy5FYXNlSW5PdXRDdWJpY11dIGJ5IGRlZmF1bHQpXHJcbiAgICAgICAgICogQHJldHVybnMgQSBbW1Byb21pc2VdXSB0aGF0IHJlc29sdmVzIHdoZW4gbW92ZW1lbnQgaXMgZmluaXNoZWQsIGluY2x1ZGluZyBpZiBpdCdzIGludGVycnVwdGVkLlxyXG4gICAgICAgICAqICAgICAgICAgIFRoZSBbW1Byb21pc2VdXSB2YWx1ZSBpcyB0aGUgW1tWZWN0b3JdXSBvZiB0aGUgdGFyZ2V0IHBvc2l0aW9uLiBJdCB3aWxsIGJlIHJlamVjdGVkIGlmIGEgbW92ZSBjYW5ub3QgYmUgbWFkZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBCYXNlQ2FtZXJhLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24gKHBvcywgZHVyYXRpb24sIGVhc2luZ0ZuKSB7XHJcbiAgICAgICAgICAgIGlmIChlYXNpbmdGbiA9PT0gdm9pZCAwKSB7IGVhc2luZ0ZuID0gRWFzaW5nRnVuY3Rpb25zXzEuRWFzaW5nRnVuY3Rpb25zLkVhc2VJbk91dEN1YmljOyB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZWFzaW5nRm4gIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHRocm93ICdQbGVhc2Ugc3BlY2lmeSBhbiBFYXNpbmdGdW5jdGlvbic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gY2Fubm90IG1vdmUgd2hlbiBmb2xsb3dpbmcgYW4gYWN0b3JcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2ZvbGxvdykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlc18xLlByb21pc2UoKS5yZWplY3QocG9zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyByZXNvbHZlIGV4aXN0aW5nIHByb21pc2UsIGlmIGFueVxyXG4gICAgICAgICAgICBpZiAodGhpcy5fbGVycFByb21pc2UgJiYgdGhpcy5fbGVycFByb21pc2Uuc3RhdGUoKSA9PT0gUHJvbWlzZXNfMS5Qcm9taXNlU3RhdGUuUGVuZGluZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGVycFByb21pc2UucmVzb2x2ZShwb3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2xlcnBQcm9taXNlID0gbmV3IFByb21pc2VzXzEuUHJvbWlzZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9sZXJwU3RhcnQgPSB0aGlzLmdldEZvY3VzKCkuY2xvbmUoKTtcclxuICAgICAgICAgICAgdGhpcy5fbGVycER1cmF0aW9uID0gZHVyYXRpb247XHJcbiAgICAgICAgICAgIHRoaXMuX2xlcnBFbmQgPSBwb3M7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRMZXJwVGltZSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbWVyYU1vdmluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2Vhc2luZyA9IGVhc2luZ0ZuO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGVycFByb21pc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBjYW1lcmEgdG8gc2hha2UgYXQgdGhlIHNwZWNpZmllZCBtYWduaXR1ZGVzIGZvciB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIG1hZ25pdHVkZVggIFRoZSB4IG1hZ25pdHVkZSBvZiB0aGUgc2hha2VcclxuICAgICAgICAgKiBAcGFyYW0gbWFnbml0dWRlWSAgVGhlIHkgbWFnbml0dWRlIG9mIHRoZSBzaGFrZVxyXG4gICAgICAgICAqIEBwYXJhbSBkdXJhdGlvbiAgICBUaGUgZHVyYXRpb24gb2YgdGhlIHNoYWtlIGluIG1pbGxpc2Vjb25kc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJhc2VDYW1lcmEucHJvdG90eXBlLnNoYWtlID0gZnVuY3Rpb24gKG1hZ25pdHVkZVgsIG1hZ25pdHVkZVksIGR1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzU2hha2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX3NoYWtlTWFnbml0dWRlWCA9IG1hZ25pdHVkZVg7XHJcbiAgICAgICAgICAgIHRoaXMuX3NoYWtlTWFnbml0dWRlWSA9IG1hZ25pdHVkZVk7XHJcbiAgICAgICAgICAgIHRoaXMuX3NoYWtlRHVyYXRpb24gPSBkdXJhdGlvbjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFpvb21zIHRoZSBjYW1lcmEgaW4gb3Igb3V0IGJ5IHRoZSBzcGVjaWZpZWQgc2NhbGUgb3ZlciB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uLlxyXG4gICAgICAgICAqIElmIG5vIGR1cmF0aW9uIGlzIHNwZWNpZmllZCwgaXQgdGFrZSBlZmZlY3QgaW1tZWRpYXRlbHkuXHJcbiAgICAgICAgICogQHBhcmFtIHNjYWxlICAgIFRoZSBzY2FsZSBvZiB0aGUgem9vbVxyXG4gICAgICAgICAqIEBwYXJhbSBkdXJhdGlvbiBUaGUgZHVyYXRpb24gb2YgdGhlIHpvb20gaW4gbWlsbGlzZWNvbmRzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQmFzZUNhbWVyYS5wcm90b3R5cGUuem9vbSA9IGZ1bmN0aW9uIChzY2FsZSwgZHVyYXRpb24pIHtcclxuICAgICAgICAgICAgaWYgKGR1cmF0aW9uID09PSB2b2lkIDApIHsgZHVyYXRpb24gPSAwOyB9XHJcbiAgICAgICAgICAgIHRoaXMuX3pvb21Qcm9taXNlID0gbmV3IFByb21pc2VzXzEuUHJvbWlzZSgpO1xyXG4gICAgICAgICAgICBpZiAoZHVyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2lzWm9vbWluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXhab29tU2NhbGUgPSBzY2FsZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3pvb21JbmNyZW1lbnQgPSAoc2NhbGUgLSB0aGlzLnopIC8gZHVyYXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1pvb21pbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMueiA9IHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fem9vbVByb21pc2UucmVzb2x2ZSh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fem9vbVByb21pc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHpvb20gc2NhbGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBCYXNlQ2FtZXJhLnByb3RvdHlwZS5nZXRab29tID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy56O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhIG5ldyBjYW1lcmEgc3RyYXRlZ3kgdG8gdGhpcyBjYW1lcmFcclxuICAgICAgICAgKiBAcGFyYW0gY2FtZXJhU3RyYXRlZ3kgSW5zdGFuY2Ugb2YgYW4gW1tJQ2FtZXJhU3RyYXRlZ3ldXVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJhc2VDYW1lcmEucHJvdG90eXBlLmFkZFN0cmF0ZWd5ID0gZnVuY3Rpb24gKGNhbWVyYVN0cmF0ZWd5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbWVyYVN0cmF0ZWdpZXMucHVzaChjYW1lcmFTdHJhdGVneSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGEgY2FtZXJhIHN0cmF0ZWd5IGJ5IHJlZmVyZW5jZVxyXG4gICAgICAgICAqIEBwYXJhbSBjYW1lcmFTdHJhdGVneSBJbnN0YW5jZSBvZiBhbiBbW0lDYW1lcmFTdHJhdGVneV1dXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQmFzZUNhbWVyYS5wcm90b3R5cGUucmVtb3ZlU3RyYXRlZ3kgPSBmdW5jdGlvbiAoY2FtZXJhU3RyYXRlZ3kpIHtcclxuICAgICAgICAgICAgVXRpbF8xLnJlbW92ZUl0ZW1Gcm9tQXJyYXkoY2FtZXJhU3RyYXRlZ3ksIHRoaXMuX2NhbWVyYVN0cmF0ZWdpZXMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2xlYXJzIGFsbCBjYW1lcmEgc3RyYXRlZ2llcyBmcm9tIHRoZSBjYW1lcmFcclxuICAgICAgICAgKi9cclxuICAgICAgICBCYXNlQ2FtZXJhLnByb3RvdHlwZS5jbGVhckFsbFN0cmF0ZWdpZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbWVyYVN0cmF0ZWdpZXMubGVuZ3RoID0gMDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEJhc2VDYW1lcmEucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChfZW5naW5lLCBkZWx0YSkge1xyXG4gICAgICAgICAgICAvLyBVcGRhdGUgcGxhY2VtZW50cyBiYXNlZCBvbiBsaW5lYXIgYWxnZWJyYVxyXG4gICAgICAgICAgICB0aGlzLl94ICs9IHRoaXMuZHggKiBkZWx0YSAvIDEwMDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3kgKz0gdGhpcy5keSAqIGRlbHRhIC8gMTAwMDtcclxuICAgICAgICAgICAgdGhpcy56ICs9IHRoaXMuZHogKiBkZWx0YSAvIDEwMDA7XHJcbiAgICAgICAgICAgIHRoaXMuZHggKz0gdGhpcy5heCAqIGRlbHRhIC8gMTAwMDtcclxuICAgICAgICAgICAgdGhpcy5keSArPSB0aGlzLmF5ICogZGVsdGEgLyAxMDAwO1xyXG4gICAgICAgICAgICB0aGlzLmR6ICs9IHRoaXMuYXogKiBkZWx0YSAvIDEwMDA7XHJcbiAgICAgICAgICAgIHRoaXMucm90YXRpb24gKz0gdGhpcy5yeCAqIGRlbHRhIC8gMTAwMDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzWm9vbWluZykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld1pvb20gPSB0aGlzLnogKyB0aGlzLl96b29tSW5jcmVtZW50ICogZGVsdGE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnogPSBuZXdab29tO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3pvb21JbmNyZW1lbnQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1pvb20gPj0gdGhpcy5fbWF4Wm9vbVNjYWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzWm9vbWluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnogPSB0aGlzLl9tYXhab29tU2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3pvb21Qcm9taXNlLnJlc29sdmUodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1pvb20gPD0gdGhpcy5fbWF4Wm9vbVNjYWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzWm9vbWluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnogPSB0aGlzLl9tYXhab29tU2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3pvb21Qcm9taXNlLnJlc29sdmUodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jYW1lcmFNb3ZpbmcpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50TGVycFRpbWUgPCB0aGlzLl9sZXJwRHVyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbGVycEVuZC54IDwgdGhpcy5fbGVycFN0YXJ0LngpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5feCA9IHRoaXMuX2xlcnBTdGFydC54IC0gKHRoaXMuX2Vhc2luZyh0aGlzLl9jdXJyZW50TGVycFRpbWUsIHRoaXMuX2xlcnBFbmQueCwgdGhpcy5fbGVycFN0YXJ0LngsIHRoaXMuX2xlcnBEdXJhdGlvbikgLSB0aGlzLl9sZXJwRW5kLngpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5feCA9IHRoaXMuX2Vhc2luZyh0aGlzLl9jdXJyZW50TGVycFRpbWUsIHRoaXMuX2xlcnBTdGFydC54LCB0aGlzLl9sZXJwRW5kLngsIHRoaXMuX2xlcnBEdXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sZXJwRW5kLnkgPCB0aGlzLl9sZXJwU3RhcnQueSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl95ID0gdGhpcy5fbGVycFN0YXJ0LnkgLSAodGhpcy5fZWFzaW5nKHRoaXMuX2N1cnJlbnRMZXJwVGltZSwgdGhpcy5fbGVycEVuZC55LCB0aGlzLl9sZXJwU3RhcnQueSwgdGhpcy5fbGVycER1cmF0aW9uKSAtIHRoaXMuX2xlcnBFbmQueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl95ID0gdGhpcy5fZWFzaW5nKHRoaXMuX2N1cnJlbnRMZXJwVGltZSwgdGhpcy5fbGVycFN0YXJ0LnksIHRoaXMuX2xlcnBFbmQueSwgdGhpcy5fbGVycER1cmF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudExlcnBUaW1lICs9IGRlbHRhO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5feCA9IHRoaXMuX2xlcnBFbmQueDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl95ID0gdGhpcy5fbGVycEVuZC55O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xlcnBQcm9taXNlLnJlc29sdmUodGhpcy5fbGVycEVuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGVycFN0YXJ0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sZXJwRW5kID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50TGVycFRpbWUgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbWVyYU1vdmluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0RvbmVTaGFraW5nKCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2lzU2hha2luZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZWxhcHNlZFNoYWtlVGltZSA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zaGFrZU1hZ25pdHVkZVggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2hha2VNYWduaXR1ZGVZID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NoYWtlRHVyYXRpb24gPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5feFNoYWtlID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3lTaGFrZSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lbGFwc2VkU2hha2VUaW1lICs9IGRlbHRhO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5feFNoYWtlID0gKE1hdGgucmFuZG9tKCkgKiB0aGlzLl9zaGFrZU1hZ25pdHVkZVggfCAwKSArIDE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl95U2hha2UgPSAoTWF0aC5yYW5kb20oKSAqIHRoaXMuX3NoYWtlTWFnbml0dWRlWSB8IDApICsgMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5fY2FtZXJhU3RyYXRlZ2llczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBzID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSBzLmFjdGlvbi5jYWxsKHMsIHMudGFyZ2V0LCB0aGlzLCBfZW5naW5lLCBkZWx0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFwcGxpZXMgdGhlIHJlbGV2YW50IHRyYW5zZm9ybWF0aW9ucyB0byB0aGUgZ2FtZSBjYW52YXMgdG8gXCJtb3ZlXCIgb3IgYXBwbHkgZWZmZWN0cyB0byB0aGUgQ2FtZXJhXHJcbiAgICAgICAgICogQHBhcmFtIGN0eCAgICBDYW52YXMgY29udGV4dCB0byBhcHBseSB0cmFuc2Zvcm1hdGlvbnNcclxuICAgICAgICAgKiBAcGFyYW0gZGVsdGEgIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBsYXN0IHVwZGF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJhc2VDYW1lcmEucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgICAgICAgICAgIHZhciBmb2N1cyA9IHRoaXMuZ2V0Rm9jdXMoKTtcclxuICAgICAgICAgICAgdmFyIGNhbnZhc1dpZHRoID0gY3R4LmNhbnZhcy53aWR0aDtcclxuICAgICAgICAgICAgdmFyIGNhbnZhc0hlaWdodCA9IGN0eC5jYW52YXMuaGVpZ2h0O1xyXG4gICAgICAgICAgICB2YXIgcGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xyXG4gICAgICAgICAgICB2YXIgem9vbSA9IHRoaXMuZ2V0Wm9vbSgpO1xyXG4gICAgICAgICAgICB2YXIgbmV3Q2FudmFzV2lkdGggPSAoY2FudmFzV2lkdGggLyB6b29tKSAvIHBpeGVsUmF0aW87XHJcbiAgICAgICAgICAgIHZhciBuZXdDYW52YXNIZWlnaHQgPSAoY2FudmFzSGVpZ2h0IC8gem9vbSkgLyBwaXhlbFJhdGlvO1xyXG4gICAgICAgICAgICBjdHguc2NhbGUoem9vbSwgem9vbSk7XHJcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLWZvY3VzLnggKyBuZXdDYW52YXNXaWR0aCAvIDIgKyB0aGlzLl94U2hha2UsIC1mb2N1cy55ICsgbmV3Q2FudmFzSGVpZ2h0IC8gMiArIHRoaXMuX3lTaGFrZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBCYXNlQ2FtZXJhLnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgICAgICAgICAgIHZhciBmb2N1cyA9IHRoaXMuZ2V0Rm9jdXMoKTtcclxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICdyZWQnO1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnd2hpdGUnO1xyXG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMztcclxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHguYXJjKGZvY3VzLngsIGZvY3VzLnksIDE1LCAwLCBNYXRoLlBJICogMik7XHJcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5hcmMoZm9jdXMueCwgZm9jdXMueSwgNSwgMCwgTWF0aC5QSSAqIDIpO1xyXG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEJhc2VDYW1lcmEucHJvdG90eXBlLl9pc0RvbmVTaGFraW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gISh0aGlzLl9pc1NoYWtpbmcpIHx8ICh0aGlzLl9lbGFwc2VkU2hha2VUaW1lID49IHRoaXMuX3NoYWtlRHVyYXRpb24pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEJhc2VDYW1lcmE7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5CYXNlQ2FtZXJhID0gQmFzZUNhbWVyYTtcclxufSk7XHJcbmRlZmluZShcIkNvbmZpZ3VyYWJsZVwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgZnVuY3Rpb24gQ29uZmlndXJhYmxlKGJhc2UpIHtcclxuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKGNsYXNzXzEsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNsYXNzXzEoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgYXJncykgfHwgdGhpcztcclxuICAgICAgICAgICAgICAgIC8vZ2V0IHRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHRoYXQgYXJlbid0IHVuZGVmaW5lZC4gVFMgcGFzc2VzIGEgdmFsdWUgdG8gYWxsIHBhcmFtZXRlcnNcclxuICAgICAgICAgICAgICAgIC8vb2Ygd2hhdGV2ZXIgY3RvciBpcyB0aGUgaW1wbGVtZW50YXRpb24sIHNvIGFyZ3MubGVuZ3RoIGRvZXNuJ3Qgd29yayBoZXJlLlxyXG4gICAgICAgICAgICAgICAgdmFyIHNpemUgPSBhcmdzLmZpbHRlcihmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQ7IH0pLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGlmIChzaXplID09PSAxICYmIGFyZ3NbMF0gJiYgdHlwZW9mIGFyZ3NbMF0gPT09ICdvYmplY3QnICYmICEoYXJnc1swXSBpbnN0YW5jZW9mIEFycmF5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFzc2lnbihhcmdzWzBdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5hc3NpZ24gPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIC8vc2V0IHRoZSB2YWx1ZSBvZiBldmVyeSBwcm9wZXJ0eSB0aGF0IHdhcyBwYXNzZWQgaW4sXHJcbiAgICAgICAgICAgICAgICAvL2lmIHRoZSBjb25zdHJ1Y3RvciBwcmV2aW91c2x5IHNldCB0aGlzIHZhbHVlLCBpdCB3aWxsIGJlIG92ZXJyaWRkZW4gaGVyZVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiBwcm9wcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpc1trXSAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tdID0gcHJvcHNba107XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gY2xhc3NfMTtcclxuICAgICAgICB9KGJhc2UpKTtcclxuICAgIH1cclxuICAgIGV4cG9ydHMuQ29uZmlndXJhYmxlID0gQ29uZmlndXJhYmxlO1xyXG59KTtcclxuZGVmaW5lKFwiRGVidWdGbGFnc1wiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG59KTtcclxuZGVmaW5lKFwiRHJhd2luZy9Db2xvclwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQcm92aWRlcyBzdGFuZGFyZCBjb2xvcnMgKGUuZy4gW1tDb2xvci5CbGFja11dKVxyXG4gICAgICogYnV0IHlvdSBjYW4gYWxzbyBjcmVhdGUgY3VzdG9tIGNvbG9ycyB1c2luZyBSR0IsIEhTTCwgb3IgSGV4LiBBbHNvIHByb3ZpZGVzXHJcbiAgICAgKiB1c2VmdWwgY29sb3Igb3BlcmF0aW9ucyBsaWtlIFtbQ29sb3IubGlnaHRlbl1dLCBbW0NvbG9yLmRhcmtlbl1dLCBhbmQgbW9yZS5cclxuICAgICAqXHJcbiAgICAgKiBbW2luY2x1ZGU6Q29sb3JzLm1kXV1cclxuICAgICAqL1xyXG4gICAgdmFyIENvbG9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIENvbG9yIGZyb20gYW4gciwgZywgYiwgYVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHIgIFRoZSByZWQgY29tcG9uZW50IG9mIGNvbG9yICgwLTI1NSlcclxuICAgICAgICAgKiBAcGFyYW0gZyAgVGhlIGdyZWVuIGNvbXBvbmVudCBvZiBjb2xvciAoMC0yNTUpXHJcbiAgICAgICAgICogQHBhcmFtIGIgIFRoZSBibHVlIGNvbXBvbmVudCBvZiBjb2xvciAoMC0yNTUpXHJcbiAgICAgICAgICogQHBhcmFtIGEgIFRoZSBhbHBoYSBjb21wb25lbnQgb2YgY29sb3IgKDAtMS4wKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIENvbG9yKHIsIGcsIGIsIGEpIHtcclxuICAgICAgICAgICAgdGhpcy5yID0gcjtcclxuICAgICAgICAgICAgdGhpcy5nID0gZztcclxuICAgICAgICAgICAgdGhpcy5iID0gYjtcclxuICAgICAgICAgICAgdGhpcy5hID0gKGEgIT0gbnVsbCA/IGEgOiAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBDb2xvciBmcm9tIGFuIHIsIGcsIGIsIGFcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSByICBUaGUgcmVkIGNvbXBvbmVudCBvZiBjb2xvciAoMC0yNTUpXHJcbiAgICAgICAgICogQHBhcmFtIGcgIFRoZSBncmVlbiBjb21wb25lbnQgb2YgY29sb3IgKDAtMjU1KVxyXG4gICAgICAgICAqIEBwYXJhbSBiICBUaGUgYmx1ZSBjb21wb25lbnQgb2YgY29sb3IgKDAtMjU1KVxyXG4gICAgICAgICAqIEBwYXJhbSBhICBUaGUgYWxwaGEgY29tcG9uZW50IG9mIGNvbG9yICgwLTEuMClcclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xvci5mcm9tUkdCID0gZnVuY3Rpb24gKHIsIGcsIGIsIGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihyLCBnLCBiLCBhKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zY2FuY2Ugb2YgQ29sb3IgZnJvbSBhIGhleCBzdHJpbmdcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBoZXggIENTUyBjb2xvciBzdHJpbmcgb2YgdGhlIGZvcm0gI2ZmZmZmZiwgdGhlIGFscGhhIGNvbXBvbmVudCBpcyBvcHRpb25hbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbG9yLmZyb21IZXggPSBmdW5jdGlvbiAoaGV4KSB7XHJcbiAgICAgICAgICAgIHZhciBoZXhSZWdFeCA9IC9eIz8oWzAtOWEtZl17Mn0pKFswLTlhLWZdezJ9KShbMC05YS1mXXsyfSkoWzAtOWEtZl17Mn0pPyQvaTtcclxuICAgICAgICAgICAgdmFyIG1hdGNoID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKG1hdGNoID0gaGV4Lm1hdGNoKGhleFJlZ0V4KSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHIgPSBwYXJzZUludChtYXRjaFsxXSwgMTYpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGcgPSBwYXJzZUludChtYXRjaFsyXSwgMTYpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGIgPSBwYXJzZUludChtYXRjaFszXSwgMTYpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGEgPSAxO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoWzRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYSA9IHBhcnNlSW50KG1hdGNoWzRdLCAxNikgLyAyNTU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKHIsIGcsIGIsIGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmc6ICcgKyBoZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdHMgYSBuZXcgaW5zdGFuY2Ugb2YgQ29sb3IgZnJvbSBoc2xhIHZhbHVlc1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGggIEh1ZSBpcyByZXByZXNlbnRlZCBbMC0xXVxyXG4gICAgICAgICAqIEBwYXJhbSBzICBTYXR1cmF0aW9uIGlzIHJlcHJlc2VudGVkIFswLTFdXHJcbiAgICAgICAgICogQHBhcmFtIGwgIEx1bWluYW5jZSBpcyByZXByZXNlbnRlZCBbMC0xXVxyXG4gICAgICAgICAqIEBwYXJhbSBhICBBbHBoYSBpcyByZXByZXNlbnRlZCBbMC0xXVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbG9yLmZyb21IU0wgPSBmdW5jdGlvbiAoaCwgcywgbCwgYSkge1xyXG4gICAgICAgICAgICBpZiAoYSA9PT0gdm9pZCAwKSB7IGEgPSAxLjA7IH1cclxuICAgICAgICAgICAgdmFyIHRlbXAgPSBuZXcgSFNMQ29sb3IoaCwgcywgbCwgYSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0ZW1wLnRvUkdCQSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTGlnaHRlbnMgdGhlIGN1cnJlbnQgY29sb3IgYnkgYSBzcGVjaWZpZWQgYW1vdW50XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gZmFjdG9yICBUaGUgYW1vdW50IHRvIGxpZ2h0ZW4gYnkgWzAtMV1cclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xvci5wcm90b3R5cGUubGlnaHRlbiA9IGZ1bmN0aW9uIChmYWN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKGZhY3RvciA9PT0gdm9pZCAwKSB7IGZhY3RvciA9IDAuMTsgfVxyXG4gICAgICAgICAgICB2YXIgdGVtcCA9IEhTTENvbG9yLmZyb21SR0JBKHRoaXMuciwgdGhpcy5nLCB0aGlzLmIsIHRoaXMuYSk7XHJcbiAgICAgICAgICAgIHRlbXAubCArPSAodGVtcC5sICogZmFjdG9yKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRlbXAudG9SR0JBKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEYXJrZW5zIHRoZSBjdXJyZW50IGNvbG9yIGJ5IGEgc3BlY2lmaWVkIGFtb3VudFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGZhY3RvciAgVGhlIGFtb3VudCB0byBkYXJrZW4gYnkgWzAtMV1cclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xvci5wcm90b3R5cGUuZGFya2VuID0gZnVuY3Rpb24gKGZhY3Rvcikge1xyXG4gICAgICAgICAgICBpZiAoZmFjdG9yID09PSB2b2lkIDApIHsgZmFjdG9yID0gMC4xOyB9XHJcbiAgICAgICAgICAgIHZhciB0ZW1wID0gSFNMQ29sb3IuZnJvbVJHQkEodGhpcy5yLCB0aGlzLmcsIHRoaXMuYiwgdGhpcy5hKTtcclxuICAgICAgICAgICAgdGVtcC5sIC09ICh0ZW1wLmwgKiBmYWN0b3IpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGVtcC50b1JHQkEoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNhdHVyYXRlcyB0aGUgY3VycmVudCBjb2xvciBieSBhIHNwZWNpZmllZCBhbW91bnRcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBmYWN0b3IgIFRoZSBhbW91bnQgdG8gc2F0dXJhdGUgYnkgWzAtMV1cclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xvci5wcm90b3R5cGUuc2F0dXJhdGUgPSBmdW5jdGlvbiAoZmFjdG9yKSB7XHJcbiAgICAgICAgICAgIGlmIChmYWN0b3IgPT09IHZvaWQgMCkgeyBmYWN0b3IgPSAwLjE7IH1cclxuICAgICAgICAgICAgdmFyIHRlbXAgPSBIU0xDb2xvci5mcm9tUkdCQSh0aGlzLnIsIHRoaXMuZywgdGhpcy5iLCB0aGlzLmEpO1xyXG4gICAgICAgICAgICB0ZW1wLnMgKz0gKHRlbXAucyAqIGZhY3Rvcik7XHJcbiAgICAgICAgICAgIHJldHVybiB0ZW1wLnRvUkdCQSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVzYXR1cmF0ZXMgdGhlIGN1cnJlbnQgY29sb3IgYnkgYSBzcGVjaWZpZWQgYW1vdW50XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gZmFjdG9yICBUaGUgYW1vdW50IHRvIGRlc2F0dXJhdGUgYnkgWzAtMV1cclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xvci5wcm90b3R5cGUuZGVzYXR1cmF0ZSA9IGZ1bmN0aW9uIChmYWN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKGZhY3RvciA9PT0gdm9pZCAwKSB7IGZhY3RvciA9IDAuMTsgfVxyXG4gICAgICAgICAgICB2YXIgdGVtcCA9IEhTTENvbG9yLmZyb21SR0JBKHRoaXMuciwgdGhpcy5nLCB0aGlzLmIsIHRoaXMuYSk7XHJcbiAgICAgICAgICAgIHRlbXAucyAtPSAodGVtcC5zICogZmFjdG9yKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRlbXAudG9SR0JBKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNdWx0aXBsaWVzIGEgY29sb3IgYnkgYW5vdGhlciwgcmVzdWx0cyBpbiBhIGRhcmtlciBjb2xvclxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGNvbG9yICBUaGUgb3RoZXIgY29sb3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xvci5wcm90b3R5cGUubXVsaXRpcGx5ID0gZnVuY3Rpb24gKGNvbG9yKSB7XHJcbiAgICAgICAgICAgIHZhciBuZXdSID0gKChjb2xvci5yIC8gMjU1ICogdGhpcy5yIC8gMjU1KSAqIDI1NSk7XHJcbiAgICAgICAgICAgIHZhciBuZXdHID0gKChjb2xvci5nIC8gMjU1ICogdGhpcy5nIC8gMjU1KSAqIDI1NSk7XHJcbiAgICAgICAgICAgIHZhciBuZXdCID0gKChjb2xvci5iIC8gMjU1ICogdGhpcy5iIC8gMjU1KSAqIDI1NSk7XHJcbiAgICAgICAgICAgIHZhciBuZXdBID0gKGNvbG9yLmEgKiB0aGlzLmEpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKG5ld1IsIG5ld0csIG5ld0IsIG5ld0EpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2NyZWVucyBhIGNvbG9yIGJ5IGFub3RoZXIsIHJlc3VsdHMgaW4gYSBsaWdodGVyIGNvbG9yXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gY29sb3IgIFRoZSBvdGhlciBjb2xvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbG9yLnByb3RvdHlwZS5zY3JlZW4gPSBmdW5jdGlvbiAoY29sb3IpIHtcclxuICAgICAgICAgICAgdmFyIGNvbG9yMSA9IGNvbG9yLmludmVydCgpO1xyXG4gICAgICAgICAgICB2YXIgY29sb3IyID0gY29sb3IuaW52ZXJ0KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBjb2xvcjEubXVsaXRpcGx5KGNvbG9yMikuaW52ZXJ0KCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbnZlcnRzIHRoZSBjdXJyZW50IGNvbG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sb3IucHJvdG90eXBlLmludmVydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcigyNTUgLSB0aGlzLnIsIDI1NSAtIHRoaXMuZywgMjU1IC0gdGhpcy5iLCAxLjAgLSB0aGlzLmEpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXZlcmFnZXMgdGhlIGN1cnJlbnQgY29sb3Igd2l0aCBhbm90aGVyXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gY29sb3IgIFRoZSBvdGhlciBjb2xvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbG9yLnByb3RvdHlwZS5hdmVyYWdlID0gZnVuY3Rpb24gKGNvbG9yKSB7XHJcbiAgICAgICAgICAgIHZhciBuZXdSID0gKGNvbG9yLnIgKyB0aGlzLnIpIC8gMjtcclxuICAgICAgICAgICAgdmFyIG5ld0cgPSAoY29sb3IuZyArIHRoaXMuZykgLyAyO1xyXG4gICAgICAgICAgICB2YXIgbmV3QiA9IChjb2xvci5iICsgdGhpcy5iKSAvIDI7XHJcbiAgICAgICAgICAgIHZhciBuZXdBID0gKGNvbG9yLmEgKyB0aGlzLmEpIC8gMjtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihuZXdSLCBuZXdHLCBuZXdCLCBuZXdBKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBDU1Mgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgY29sb3IuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gZm9ybWF0IENvbG9yIHJlcHJlc2VudGF0aW9uLCBhY2NlcHRzOiByZ2IsIGhzbCwgb3IgaGV4XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKGZvcm1hdCkge1xyXG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSB2b2lkIDApIHsgZm9ybWF0ID0gJ3JnYic7IH1cclxuICAgICAgICAgICAgc3dpdGNoIChmb3JtYXQpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3JnYic6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9SR0JBKCk7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdoc2wnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvSFNMQSgpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnaGV4JzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0hleCgpO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgQ29sb3IgZm9ybWF0Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgSGV4IFZhbHVlIG9mIGEgY29sb3IgY29tcG9uZW50XHJcbiAgICAgICAgICogQHBhcmFtIGMgY29sb3IgY29tcG9uZW50XHJcbiAgICAgICAgICogQHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81NjIzODM4L3JnYi10by1oZXgtYW5kLWhleC10by1yZ2JcclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xvci5wcm90b3R5cGUuX2NvbXBvbmVudFRvSGV4ID0gZnVuY3Rpb24gKGMpIHtcclxuICAgICAgICAgICAgdmFyIGhleCA9IGMudG9TdHJpbmcoMTYpO1xyXG4gICAgICAgICAgICByZXR1cm4gaGV4Lmxlbmd0aCA9PT0gMSA/ICcwJyArIGhleCA6IGhleDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybiBIZXggcmVwcmVzZW50YXRpb24gb2YgYSBjb2xvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xvci5wcm90b3R5cGUudG9IZXggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnIycgKyB0aGlzLl9jb21wb25lbnRUb0hleCh0aGlzLnIpICsgdGhpcy5fY29tcG9uZW50VG9IZXgodGhpcy5nKSArIHRoaXMuX2NvbXBvbmVudFRvSGV4KHRoaXMuYik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm4gUkdCQSByZXByZXNlbnRhdGlvbiBvZiBhIGNvbG9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbG9yLnByb3RvdHlwZS50b1JHQkEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBTdHJpbmcodGhpcy5yLnRvRml4ZWQoMCkpICsgJywgJyArIFN0cmluZyh0aGlzLmcudG9GaXhlZCgwKSkgKyAnLCAnICsgU3RyaW5nKHRoaXMuYi50b0ZpeGVkKDApKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYSAhPT0gdW5kZWZpbmVkIHx8IHRoaXMuYSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdyZ2JhKCcgKyByZXN1bHQgKyAnLCAnICsgU3RyaW5nKHRoaXMuYSkgKyAnKSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICdyZ2IoJyArIHJlc3VsdCArICcpJztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybiBIU0xBIHJlcHJlc2VudGF0aW9uIG9mIGEgY29sb3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sb3IucHJvdG90eXBlLnRvSFNMQSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEhTTENvbG9yLmZyb21SR0JBKHRoaXMuciwgdGhpcy5nLCB0aGlzLmIsIHRoaXMuYSkudG9TdHJpbmcoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBDU1Mgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgY29sb3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sb3IucHJvdG90eXBlLmZpbGxTdHlsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgY3VycmVudCBjb2xvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xvci5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IodGhpcy5yLCB0aGlzLmcsIHRoaXMuYiwgdGhpcy5hKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBDb2xvcjtcclxuICAgIH0oKSk7XHJcbiAgICAvKipcclxuICAgICAqIEJsYWNrICgjMDAwMDAwKVxyXG4gICAgICovXHJcbiAgICBDb2xvci5CbGFjayA9IENvbG9yLmZyb21IZXgoJyMwMDAwMDAnKTtcclxuICAgIC8qKlxyXG4gICAgICogV2hpdGUgKCNGRkZGRkYpXHJcbiAgICAgKi9cclxuICAgIENvbG9yLldoaXRlID0gQ29sb3IuZnJvbUhleCgnI0ZGRkZGRicpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHcmF5ICgjODA4MDgwKVxyXG4gICAgICovXHJcbiAgICBDb2xvci5HcmF5ID0gQ29sb3IuZnJvbUhleCgnIzgwODA4MCcpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBMaWdodCBncmF5ICgjRDNEM0QzKVxyXG4gICAgICovXHJcbiAgICBDb2xvci5MaWdodEdyYXkgPSBDb2xvci5mcm9tSGV4KCcjRDNEM0QzJyk7XHJcbiAgICAvKipcclxuICAgICAqIERhcmsgZ3JheSAoI0E5QTlBOSlcclxuICAgICAqL1xyXG4gICAgQ29sb3IuRGFya0dyYXkgPSBDb2xvci5mcm9tSGV4KCcjQTlBOUE5Jyk7XHJcbiAgICAvKipcclxuICAgICAqIFllbGxvdyAoI0ZGRkYwMClcclxuICAgICAqL1xyXG4gICAgQ29sb3IuWWVsbG93ID0gQ29sb3IuZnJvbUhleCgnI0ZGRkYwMCcpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBPcmFuZ2UgKCNGRkE1MDApXHJcbiAgICAgKi9cclxuICAgIENvbG9yLk9yYW5nZSA9IENvbG9yLmZyb21IZXgoJyNGRkE1MDAnKTtcclxuICAgIC8qKlxyXG4gICAgICogUmVkICgjRkYwMDAwKVxyXG4gICAgICovXHJcbiAgICBDb2xvci5SZWQgPSBDb2xvci5mcm9tSGV4KCcjRkYwMDAwJyk7XHJcbiAgICAvKipcclxuICAgICAqIFZlcm1pbGxpb24gKCNGRjVCMzEpXHJcbiAgICAgKi9cclxuICAgIENvbG9yLlZlcm1pbGxpb24gPSBDb2xvci5mcm9tSGV4KCcjRkY1QjMxJyk7XHJcbiAgICAvKipcclxuICAgICAqIFJvc2UgKCNGRjAwN0YpXHJcbiAgICAgKi9cclxuICAgIENvbG9yLlJvc2UgPSBDb2xvci5mcm9tSGV4KCcjRkYwMDdGJyk7XHJcbiAgICAvKipcclxuICAgICAqIE1hZ2VudGEgKCNGRjAwRkYpXHJcbiAgICAgKi9cclxuICAgIENvbG9yLk1hZ2VudGEgPSBDb2xvci5mcm9tSGV4KCcjRkYwMEZGJyk7XHJcbiAgICAvKipcclxuICAgICAqIFZpb2xldCAoIzdGMDBGRilcclxuICAgICAqL1xyXG4gICAgQ29sb3IuVmlvbGV0ID0gQ29sb3IuZnJvbUhleCgnIzdGMDBGRicpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBCbHVlICgjMDAwMEZGKVxyXG4gICAgICovXHJcbiAgICBDb2xvci5CbHVlID0gQ29sb3IuZnJvbUhleCgnIzAwMDBGRicpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBenVyZSAoIzAwN0ZGRilcclxuICAgICAqL1xyXG4gICAgQ29sb3IuQXp1cmUgPSBDb2xvci5mcm9tSGV4KCcjMDA3RkZGJyk7XHJcbiAgICAvKipcclxuICAgICAqIEN5YW4gKCMwMEZGRkYpXHJcbiAgICAgKi9cclxuICAgIENvbG9yLkN5YW4gPSBDb2xvci5mcm9tSGV4KCcjMDBGRkZGJyk7XHJcbiAgICAvKipcclxuICAgICAqIFZpcmlkaWFuICgjNTk5NzhGKVxyXG4gICAgICovXHJcbiAgICBDb2xvci5WaXJpZGlhbiA9IENvbG9yLmZyb21IZXgoJyM1OTk3OEYnKTtcclxuICAgIC8qKlxyXG4gICAgICogR3JlZW4gKCMwMEZGMDApXHJcbiAgICAgKi9cclxuICAgIENvbG9yLkdyZWVuID0gQ29sb3IuZnJvbUhleCgnIzAwRkYwMCcpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFydHJldXNlICgjN0ZGRjAwKVxyXG4gICAgICovXHJcbiAgICBDb2xvci5DaGFydHJldXNlID0gQ29sb3IuZnJvbUhleCgnIzdGRkYwMCcpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc3BhcmVudCAoI0ZGRkZGRjAwKVxyXG4gICAgICovXHJcbiAgICBDb2xvci5UcmFuc3BhcmVudCA9IENvbG9yLmZyb21IZXgoJyNGRkZGRkYwMCcpO1xyXG4gICAgZXhwb3J0cy5Db2xvciA9IENvbG9yO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcm5hbCBIU0wgQ29sb3IgcmVwcmVzZW50YXRpb25cclxuICAgICAqXHJcbiAgICAgKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hTTF9hbmRfSFNWXHJcbiAgICAgKiBodHRwOi8vYXhvbmZsdXguY29tL2hhbmR5LXJnYi10by1oc2wtYW5kLXJnYi10by1oc3YtY29sb3ItbW9kZWwtY1xyXG4gICAgICovXHJcbiAgICB2YXIgSFNMQ29sb3IgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIEhTTENvbG9yKGgsIHMsIGwsIGEpIHtcclxuICAgICAgICAgICAgdGhpcy5oID0gaDtcclxuICAgICAgICAgICAgdGhpcy5zID0gcztcclxuICAgICAgICAgICAgdGhpcy5sID0gbDtcclxuICAgICAgICAgICAgdGhpcy5hID0gYTtcclxuICAgICAgICB9XHJcbiAgICAgICAgSFNMQ29sb3IuaHVlMnJnYiA9IGZ1bmN0aW9uIChwLCBxLCB0KSB7XHJcbiAgICAgICAgICAgIGlmICh0IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgdCArPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0ID4gMSkge1xyXG4gICAgICAgICAgICAgICAgdCAtPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0IDwgMSAvIDYpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0IDwgMSAvIDIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0IDwgMiAvIDMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwICsgKHEgLSBwKSAqICgyIC8gMyAtIHQpICogNjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEhTTENvbG9yLmZyb21SR0JBID0gZnVuY3Rpb24gKHIsIGcsIGIsIGEpIHtcclxuICAgICAgICAgICAgciAvPSAyNTU7XHJcbiAgICAgICAgICAgIGcgLz0gMjU1O1xyXG4gICAgICAgICAgICBiIC89IDI1NTtcclxuICAgICAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLCBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcclxuICAgICAgICAgICAgdmFyIGgsIHMsIGwgPSAobWF4ICsgbWluKSAvIDI7XHJcbiAgICAgICAgICAgIGlmIChtYXggPT09IG1pbikge1xyXG4gICAgICAgICAgICAgICAgaCA9IHMgPSAwOyAvLyBhY2hyb21hdGljXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IG1heCAtIG1pbjtcclxuICAgICAgICAgICAgICAgIHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAobWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSByOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoID0gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgZzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaCA9IChiIC0gcikgLyBkICsgMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoID0gKHIgLSBnKSAvIGQgKyA0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGggLz0gNjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEhTTENvbG9yKGgsIHMsIGwsIGEpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgSFNMQ29sb3IucHJvdG90eXBlLnRvUkdCQSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHIsIGcsIGI7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnMgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHIgPSBnID0gYiA9IHRoaXMubDsgLy8gYWNocm9tYXRpY1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHEgPSB0aGlzLmwgPCAwLjUgPyB0aGlzLmwgKiAoMSArIHRoaXMucykgOiB0aGlzLmwgKyB0aGlzLnMgLSB0aGlzLmwgKiB0aGlzLnM7XHJcbiAgICAgICAgICAgICAgICB2YXIgcCA9IDIgKiB0aGlzLmwgLSBxO1xyXG4gICAgICAgICAgICAgICAgciA9IEhTTENvbG9yLmh1ZTJyZ2IocCwgcSwgdGhpcy5oICsgMSAvIDMpO1xyXG4gICAgICAgICAgICAgICAgZyA9IEhTTENvbG9yLmh1ZTJyZ2IocCwgcSwgdGhpcy5oKTtcclxuICAgICAgICAgICAgICAgIGIgPSBIU0xDb2xvci5odWUycmdiKHAsIHEsIHRoaXMuaCAtIDEgLyAzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKHIgKiAyNTUsIGcgKiAyNTUsIGIgKiAyNTUsIHRoaXMuYSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBIU0xDb2xvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBoID0gdGhpcy5oLnRvRml4ZWQoMCksIHMgPSB0aGlzLnMudG9GaXhlZCgwKSwgbCA9IHRoaXMubC50b0ZpeGVkKDApLCBhID0gdGhpcy5hLnRvRml4ZWQoMCk7XHJcbiAgICAgICAgICAgIHJldHVybiBcImhzbGEoXCIgKyBoICsgXCIsIFwiICsgcyArIFwiLCBcIiArIGwgKyBcIiwgXCIgKyBhICsgXCIpXCI7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gSFNMQ29sb3I7XHJcbiAgICB9KCkpO1xyXG59KTtcclxuZGVmaW5lKFwiQ29sbGlzaW9uL0NvbGxpc2lvbkNvbnRhY3RcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJBY3RvclwiLCBcIkFsZ2VicmFcIiwgXCJQaHlzaWNzXCIsIFwiRXZlbnRzXCIsIFwiVXRpbC9VdGlsXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgQWN0b3JfMSwgQWxnZWJyYV80LCBQaHlzaWNzXzEsIEV2ZW50c18xLCBVdGlsKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogQ29sbGlzaW9uIGNvbnRhY3RzIGFyZSB1c2VkIGludGVybmFsbHkgYnkgRXhjYWxpYnVyIHRvIHJlc29sdmUgY29sbGlzaW9uIGJldHdlZW4gYWN0b3JzLiBUaGlzXHJcbiAgICAgKiBQYWlyIHByZXZlbnRzIGNvbGxpc2lvbnMgZnJvbSBiZWluZyBldmFsdWF0ZWQgbW9yZSB0aGFuIG9uZSB0aW1lXHJcbiAgICAgKi9cclxuICAgIHZhciBDb2xsaXNpb25Db250YWN0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBDb2xsaXNpb25Db250YWN0KGJvZHlBLCBib2R5QiwgbXR2LCBwb2ludCwgbm9ybWFsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYm9keUEgPSBib2R5QTtcclxuICAgICAgICAgICAgdGhpcy5ib2R5QiA9IGJvZHlCO1xyXG4gICAgICAgICAgICB0aGlzLm10diA9IG10djtcclxuICAgICAgICAgICAgdGhpcy5wb2ludCA9IHBvaW50O1xyXG4gICAgICAgICAgICB0aGlzLm5vcm1hbCA9IG5vcm1hbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgQ29sbGlzaW9uQ29udGFjdC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIChzdHJhdGVneSkge1xyXG4gICAgICAgICAgICBpZiAoc3RyYXRlZ3kgPT09IFBoeXNpY3NfMS5Db2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kuUmlnaWRCb2R5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNvbHZlUmlnaWRCb2R5Q29sbGlzaW9uKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc3RyYXRlZ3kgPT09IFBoeXNpY3NfMS5Db2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kuQm94KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNvbHZlQm94Q29sbGlzaW9uKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gY29sbGlzaW9uIHJlc29sdXRpb24gc3RyYXRlZ3knKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgQ29sbGlzaW9uQ29udGFjdC5wcm90b3R5cGUuX2FwcGx5Qm94SW1wdWxzZSA9IGZ1bmN0aW9uIChib2R5QSwgYm9keUIsIG10dikge1xyXG4gICAgICAgICAgICBpZiAoYm9keUEuY29sbGlzaW9uVHlwZSA9PT0gQWN0b3JfMS5Db2xsaXNpb25UeXBlLkFjdGl2ZSAmJlxyXG4gICAgICAgICAgICAgICAgYm9keUIuY29sbGlzaW9uVHlwZSAhPT0gQWN0b3JfMS5Db2xsaXNpb25UeXBlLlBhc3NpdmUpIHtcclxuICAgICAgICAgICAgICAgIC8vIFJlc29sdmUgb3ZlcmxhcHNcclxuICAgICAgICAgICAgICAgIGlmIChib2R5QS5jb2xsaXNpb25UeXBlID09PSBBY3Rvcl8xLkNvbGxpc2lvblR5cGUuQWN0aXZlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgYm9keUIuY29sbGlzaW9uVHlwZSA9PT0gQWN0b3JfMS5Db2xsaXNpb25UeXBlLkFjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNwbGl0IG92ZXJsYXBzIGlmIGJvdGggYXJlIEFjdGl2ZVxyXG4gICAgICAgICAgICAgICAgICAgIG10diA9IG10di5zY2FsZSguNSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBBcHBseSBtdHZcclxuICAgICAgICAgICAgICAgIGJvZHlBLnBvcy55ICs9IG10di55O1xyXG4gICAgICAgICAgICAgICAgYm9keUEucG9zLnggKz0gbXR2Lng7XHJcbiAgICAgICAgICAgICAgICAvLyBub24temVybyBpbnRlcnNlY3Rpb24gb24gdGhlIHkgYXhpc1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubXR2LnggIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmVsWCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYm90aCBib2RpZXMgYXJlIHRyYXZlbGluZyBpbiB0aGUgc2FtZSBkaXJlY3Rpb24gKG5lZ2F0aXZlIG9yIHBvc2l0aXZlKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChib2R5QS52ZWwueCA8IDAgJiYgYm9keUIudmVsLnggPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlbFggPSBNYXRoLm1pbihib2R5QS52ZWwueCwgYm9keUIudmVsLngpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChib2R5QS52ZWwueCA+IDAgJiYgYm9keUIudmVsLnggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlbFggPSBNYXRoLm1heChib2R5QS52ZWwueCwgYm9keUIudmVsLngpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChib2R5Qi5jb2xsaXNpb25UeXBlID09PSBBY3Rvcl8xLkNvbGxpc2lvblR5cGUuRml4ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYm9kaWVzIGFyZSB0cmF2ZWxpbmcgaW4gb3Bwb3NpdGUgZGlyZWN0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYm9keUEucG9zLnN1Yihib2R5Qi5wb3MpLmRvdChib2R5QS52ZWwpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVsWCA9IGJvZHlBLnZlbC54O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYm9keUEgaXMgaGVhZGluZyB0b3dhcmRzIGJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlbFggPSBib2R5Qi52ZWwueDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBib2R5QS52ZWwueCA9IHZlbFg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tdHYueSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2ZWxZID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAvLyBib3RoIGJvZGllcyBhcmUgdHJhdmVsaW5nIGluIHRoZSBzYW1lIGRpcmVjdGlvbiAobmVnYXRpdmUgb3IgcG9zaXRpdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvZHlBLnZlbC55IDwgMCAmJiBib2R5Qi52ZWwueSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVsWSA9IE1hdGgubWluKGJvZHlBLnZlbC55LCBib2R5Qi52ZWwueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJvZHlBLnZlbC55ID4gMCAmJiBib2R5Qi52ZWwueSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVsWSA9IE1hdGgubWF4KGJvZHlBLnZlbC55LCBib2R5Qi52ZWwueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJvZHlCLmNvbGxpc2lvblR5cGUgPT09IEFjdG9yXzEuQ29sbGlzaW9uVHlwZS5GaXhlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBib2RpZXMgYXJlIHRyYXZlbGluZyBpbiBvcHBvc2l0ZSBkaXJlY3Rpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChib2R5QS5wb3Muc3ViKGJvZHlCLnBvcykuZG90KGJvZHlBLnZlbCkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWxZID0gYm9keUEudmVsLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBib2R5QSBpcyBoZWFkaW5nIHRvd2FyZHMgYlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVsWSA9IGJvZHlCLnZlbC55O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlBLnZlbC55ID0gdmVsWTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJvZHlBLmVtaXQoJ3Bvc3Rjb2xsaXNpb24nLCBuZXcgRXZlbnRzXzEuUG9zdENvbGxpc2lvbkV2ZW50KGJvZHlBLCBib2R5QiwgVXRpbC5nZXRTaWRlRnJvbVZlY3RvcihtdHYpLCBtdHYpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgQ29sbGlzaW9uQ29udGFjdC5wcm90b3R5cGUuX3Jlc29sdmVCb3hDb2xsaXNpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBib2R5QSA9IHRoaXMuYm9keUEuYm9keS5hY3RvcjtcclxuICAgICAgICAgICAgdmFyIGJvZHlCID0gdGhpcy5ib2R5Qi5ib2R5LmFjdG9yO1xyXG4gICAgICAgICAgICB2YXIgc2lkZSA9IFV0aWwuZ2V0U2lkZUZyb21WZWN0b3IodGhpcy5tdHYpO1xyXG4gICAgICAgICAgICB2YXIgbXR2ID0gdGhpcy5tdHYubmVnYXRlKCk7XHJcbiAgICAgICAgICAgIC8vIFB1Ymxpc2ggY29sbGlzaW9uIGV2ZW50cyBvbiBib3RoIHBhcnRpY2lwYW50c1xyXG4gICAgICAgICAgICBib2R5QS5lbWl0KCdwcmVjb2xsaXNpb24nLCBuZXcgRXZlbnRzXzEuUHJlQ29sbGlzaW9uRXZlbnQoYm9keUEsIGJvZHlCLCBzaWRlLCBtdHYpKTtcclxuICAgICAgICAgICAgYm9keUIuZW1pdCgncHJlY29sbGlzaW9uJywgbmV3IEV2ZW50c18xLlByZUNvbGxpc2lvbkV2ZW50KGJvZHlCLCBib2R5QSwgVXRpbC5nZXRPcHBvc2l0ZVNpZGUoc2lkZSksIG10di5uZWdhdGUoKSkpO1xyXG4gICAgICAgICAgICB0aGlzLl9hcHBseUJveEltcHVsc2UoYm9keUEsIGJvZHlCLCBtdHYpO1xyXG4gICAgICAgICAgICB0aGlzLl9hcHBseUJveEltcHVsc2UoYm9keUIsIGJvZHlBLCBtdHYubmVnYXRlKCkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQ29sbGlzaW9uQ29udGFjdC5wcm90b3R5cGUuX3Jlc29sdmVSaWdpZEJvZHlDb2xsaXNpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIHBlcmZvcm0gY29sbGlzb24gb24gYm91bmRpbmcgYXJlYXNcclxuICAgICAgICAgICAgdmFyIGJvZHlBID0gdGhpcy5ib2R5QS5ib2R5O1xyXG4gICAgICAgICAgICB2YXIgYm9keUIgPSB0aGlzLmJvZHlCLmJvZHk7XHJcbiAgICAgICAgICAgIHZhciBtdHYgPSB0aGlzLm10djsgLy8gbm9ybWFsIHBvaW50aW5nIGF3YXkgZnJvbSBib2R5QVxyXG4gICAgICAgICAgICB2YXIgbm9ybWFsID0gdGhpcy5ub3JtYWw7IC8vIG5vcm1hbCBwb2ludGluZyBhd2F5IGZyb20gYm9keUFcclxuICAgICAgICAgICAgaWYgKGJvZHlBLmFjdG9yID09PSBib2R5Qi5hY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFB1Ymxpc2ggY29sbGlzaW9uIGV2ZW50cyBvbiBib3RoIHBhcnRpY2lwYW50c1xyXG4gICAgICAgICAgICB2YXIgc2lkZSA9IFV0aWwuZ2V0U2lkZUZyb21WZWN0b3IodGhpcy5tdHYpO1xyXG4gICAgICAgICAgICBib2R5QS5hY3Rvci5lbWl0KCdwcmVjb2xsaXNpb24nLCBuZXcgRXZlbnRzXzEuUHJlQ29sbGlzaW9uRXZlbnQodGhpcy5ib2R5QS5ib2R5LmFjdG9yLCB0aGlzLmJvZHlCLmJvZHkuYWN0b3IsIHNpZGUsIHRoaXMubXR2KSk7XHJcbiAgICAgICAgICAgIGJvZHlCLmFjdG9yLmVtaXQoJ3ByZWNvbGxpc2lvbicsIG5ldyBFdmVudHNfMS5QcmVDb2xsaXNpb25FdmVudCh0aGlzLmJvZHlCLmJvZHkuYWN0b3IsIHRoaXMuYm9keUEuYm9keS5hY3RvciwgVXRpbC5nZXRPcHBvc2l0ZVNpZGUoc2lkZSksIHRoaXMubXR2Lm5lZ2F0ZSgpKSk7XHJcbiAgICAgICAgICAgIC8vIElmIGFueSBvZiB0aGUgcGFydGljaXBhbnRzIGFyZSBwYXNzaXZlIHRoZW4gc2hvcnQgY2lyY3VpdFxyXG4gICAgICAgICAgICBpZiAoYm9keUEuYWN0b3IuY29sbGlzaW9uVHlwZSA9PT0gQWN0b3JfMS5Db2xsaXNpb25UeXBlLlBhc3NpdmUgfHxcclxuICAgICAgICAgICAgICAgIGJvZHlCLmFjdG9yLmNvbGxpc2lvblR5cGUgPT09IEFjdG9yXzEuQ29sbGlzaW9uVHlwZS5QYXNzaXZlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGludk1hc3NBID0gYm9keUEuYWN0b3IuY29sbGlzaW9uVHlwZSA9PT0gQWN0b3JfMS5Db2xsaXNpb25UeXBlLkZpeGVkID8gMCA6IDEgLyBib2R5QS5tYXNzO1xyXG4gICAgICAgICAgICB2YXIgaW52TWFzc0IgPSBib2R5Qi5hY3Rvci5jb2xsaXNpb25UeXBlID09PSBBY3Rvcl8xLkNvbGxpc2lvblR5cGUuRml4ZWQgPyAwIDogMSAvIGJvZHlCLm1hc3M7XHJcbiAgICAgICAgICAgIHZhciBpbnZNb2lBID0gYm9keUEuYWN0b3IuY29sbGlzaW9uVHlwZSA9PT0gQWN0b3JfMS5Db2xsaXNpb25UeXBlLkZpeGVkID8gMCA6IDEgLyBib2R5QS5tb2k7XHJcbiAgICAgICAgICAgIHZhciBpbnZNb2lCID0gYm9keUIuYWN0b3IuY29sbGlzaW9uVHlwZSA9PT0gQWN0b3JfMS5Db2xsaXNpb25UeXBlLkZpeGVkID8gMCA6IDEgLyBib2R5Qi5tb2k7XHJcbiAgICAgICAgICAgIC8vIGF2ZXJhZ2UgcmVzdGl0dXRpb24gbW9yZSByZWxpc3RpY1xyXG4gICAgICAgICAgICB2YXIgY29lZlJlc3RpdHV0aW9uID0gTWF0aC5taW4oYm9keUEucmVzdGl0dXRpb24sIGJvZHlCLnJlc3RpdHV0aW9uKTtcclxuICAgICAgICAgICAgdmFyIGNvZWZGcmljdGlvbiA9IE1hdGgubWluKGJvZHlBLmZyaWN0aW9uLCBib2R5Qi5mcmljdGlvbik7XHJcbiAgICAgICAgICAgIG5vcm1hbCA9IG5vcm1hbC5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgdmFyIHRhbmdlbnQgPSBub3JtYWwubm9ybWFsKCkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgIHZhciByYSA9IHRoaXMucG9pbnQuc3ViKHRoaXMuYm9keUEuZ2V0Q2VudGVyKCkpOyAvLyBwb2ludCByZWxhdGl2ZSB0byBib2R5QSBwb3NpdGlvblxyXG4gICAgICAgICAgICB2YXIgcmIgPSB0aGlzLnBvaW50LnN1Yih0aGlzLmJvZHlCLmdldENlbnRlcigpKTsgLy8vIHBvaW50IHJlbGF0aXZlIHRvIGJvZHlCXHJcbiAgICAgICAgICAgIC8vIFJlbGF0aXZlIHZlbG9jaXR5IGluIGxpbmVhciB0ZXJtc1xyXG4gICAgICAgICAgICAvLyBBbmd1bGFyIHRvIGxpbmVhciB2ZWxvY2l0eSBmb3JtdWxhIC0+IG9tZWdhID0gdi9yXHJcbiAgICAgICAgICAgIHZhciBydiA9IGJvZHlCLnZlbC5hZGQocmIuY3Jvc3MoLWJvZHlCLnJ4KSkuc3ViKGJvZHlBLnZlbC5zdWIocmEuY3Jvc3MoYm9keUEucngpKSk7XHJcbiAgICAgICAgICAgIHZhciBydk5vcm1hbCA9IHJ2LmRvdChub3JtYWwpO1xyXG4gICAgICAgICAgICB2YXIgcnZUYW5nZW50ID0gcnYuZG90KHRhbmdlbnQpO1xyXG4gICAgICAgICAgICB2YXIgcmFUYW5nZW50ID0gcmEuZG90KHRhbmdlbnQpO1xyXG4gICAgICAgICAgICB2YXIgcmFOb3JtYWwgPSByYS5kb3Qobm9ybWFsKTtcclxuICAgICAgICAgICAgdmFyIHJiVGFuZ2VudCA9IHJiLmRvdCh0YW5nZW50KTtcclxuICAgICAgICAgICAgdmFyIHJiTm9ybWFsID0gcmIuZG90KG5vcm1hbCk7XHJcbiAgICAgICAgICAgIC8vIElmIG9iamVjdHMgYXJlIG1vdmluZyBhd2F5IGlnbm9yZVxyXG4gICAgICAgICAgICBpZiAocnZOb3JtYWwgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQ29sbGlzaW9uIGltcHVsc2UgZm9ybXVsYSBmcm9tIENocmlzIEhlY2tlclxyXG4gICAgICAgICAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db2xsaXNpb25fcmVzcG9uc2VcclxuICAgICAgICAgICAgdmFyIGltcHVsc2UgPSAtKCgxICsgY29lZlJlc3RpdHV0aW9uKSAqIHJ2Tm9ybWFsKSAvXHJcbiAgICAgICAgICAgICAgICAoKGludk1hc3NBICsgaW52TWFzc0IpICsgaW52TW9pQSAqIHJhVGFuZ2VudCAqIHJhVGFuZ2VudCArIGludk1vaUIgKiByYlRhbmdlbnQgKiByYlRhbmdlbnQpO1xyXG4gICAgICAgICAgICBpZiAoYm9keUEuYWN0b3IuY29sbGlzaW9uVHlwZSA9PT0gQWN0b3JfMS5Db2xsaXNpb25UeXBlLkZpeGVkKSB7XHJcbiAgICAgICAgICAgICAgICBib2R5Qi52ZWwgPSBib2R5Qi52ZWwuYWRkKG5vcm1hbC5zY2FsZShpbXB1bHNlICogaW52TWFzc0IpKTtcclxuICAgICAgICAgICAgICAgIGlmIChQaHlzaWNzXzEuUGh5c2ljcy5hbGxvd1JpZ2lkQm9keVJvdGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keUIucnggLT0gaW1wdWxzZSAqIGludk1vaUIgKiAtcmIuY3Jvc3Mobm9ybWFsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJvZHlCLmFkZE10dihtdHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGJvZHlCLmFjdG9yLmNvbGxpc2lvblR5cGUgPT09IEFjdG9yXzEuQ29sbGlzaW9uVHlwZS5GaXhlZCkge1xyXG4gICAgICAgICAgICAgICAgYm9keUEudmVsID0gYm9keUEudmVsLnN1Yihub3JtYWwuc2NhbGUoaW1wdWxzZSAqIGludk1hc3NBKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoUGh5c2ljc18xLlBoeXNpY3MuYWxsb3dSaWdpZEJvZHlSb3RhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlBLnJ4ICs9IGltcHVsc2UgKiBpbnZNb2lBICogLXJhLmNyb3NzKG5vcm1hbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBib2R5QS5hZGRNdHYobXR2Lm5lZ2F0ZSgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJvZHlCLnZlbCA9IGJvZHlCLnZlbC5hZGQobm9ybWFsLnNjYWxlKGltcHVsc2UgKiBpbnZNYXNzQikpO1xyXG4gICAgICAgICAgICAgICAgYm9keUEudmVsID0gYm9keUEudmVsLnN1Yihub3JtYWwuc2NhbGUoaW1wdWxzZSAqIGludk1hc3NBKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoUGh5c2ljc18xLlBoeXNpY3MuYWxsb3dSaWdpZEJvZHlSb3RhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlCLnJ4IC09IGltcHVsc2UgKiBpbnZNb2lCICogLXJiLmNyb3NzKG5vcm1hbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keUEucnggKz0gaW1wdWxzZSAqIGludk1vaUEgKiAtcmEuY3Jvc3Mobm9ybWFsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFNwbGl0IHRoZSBtdHYgaW4gaGFsZiBmb3IgdGhlIHR3byBib2RpZXMsIHBvdGVudGlhbGx5IHdlIGNvdWxkIGRvIHNvbWV0aGluZyBzbWFydGVyIGhlcmVcclxuICAgICAgICAgICAgICAgIGJvZHlCLmFkZE10dihtdHYuc2NhbGUoLjUpKTtcclxuICAgICAgICAgICAgICAgIGJvZHlBLmFkZE10dihtdHYuc2NhbGUoLS41KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gRnJpY3Rpb24gcG9ydGlvbiBvZiBpbXB1bHNlXHJcbiAgICAgICAgICAgIGlmIChjb2VmRnJpY3Rpb24gJiYgcnZUYW5nZW50KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDb2x1bWIgbW9kZWwgb2YgZnJpY3Rpb24sIGZvcm11bGEgZm9yIGltcHVsc2UgZHVlIHRvIGZyaWN0aW9uIGZyb20gIFxyXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29sbGlzaW9uX3Jlc3BvbnNlXHJcbiAgICAgICAgICAgICAgICAvLyB0YW5nZW50IGZvcmNlIGV4ZXJ0ZWQgYnkgYm9keSBvbiBhbm90aGVyIGluIGNvbnRhY3RcclxuICAgICAgICAgICAgICAgIHZhciB0ID0gcnYuc3ViKG5vcm1hbC5zY2FsZShydi5kb3Qobm9ybWFsKSkpLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICAgICAgLy8gaW1wdWxzZSBpbiB0aGUgZGlyZWN0aW9uIG9mIHRhbmdlbnQgZm9yY2VcclxuICAgICAgICAgICAgICAgIHZhciBqdCA9IHJ2LmRvdCh0KSAvIChpbnZNYXNzQSArIGludk1hc3NCICsgcmFOb3JtYWwgKiByYU5vcm1hbCAqIGludk1vaUEgKyByYk5vcm1hbCAqIHJiTm9ybWFsICogaW52TW9pQik7XHJcbiAgICAgICAgICAgICAgICB2YXIgZnJpY3Rpb25JbXB1bHNlID0gbmV3IEFsZ2VicmFfNC5WZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoanQpIDw9IGltcHVsc2UgKiBjb2VmRnJpY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBmcmljdGlvbkltcHVsc2UgPSB0LnNjYWxlKGp0KS5uZWdhdGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGZyaWN0aW9uSW1wdWxzZSA9IHQuc2NhbGUoLWltcHVsc2UgKiBjb2VmRnJpY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGJvZHlBLmFjdG9yLmNvbGxpc2lvblR5cGUgPT09IEFjdG9yXzEuQ29sbGlzaW9uVHlwZS5GaXhlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFwcGx5IGZyaWN0aW9uYWwgaW1wdWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlCLnZlbCA9IGJvZHlCLnZlbC5hZGQoZnJpY3Rpb25JbXB1bHNlLnNjYWxlKGludk1hc3NCKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFBoeXNpY3NfMS5QaHlzaWNzLmFsbG93UmlnaWRCb2R5Um90YXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keUIucnggKz0gZnJpY3Rpb25JbXB1bHNlLmRvdCh0KSAqIGludk1vaUIgKiByYi5jcm9zcyh0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChib2R5Qi5hY3Rvci5jb2xsaXNpb25UeXBlID09PSBBY3Rvcl8xLkNvbGxpc2lvblR5cGUuRml4ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhcHBseSBmcmljdGlvbmFsIGltcHVsc2VcclxuICAgICAgICAgICAgICAgICAgICBib2R5QS52ZWwgPSBib2R5QS52ZWwuc3ViKGZyaWN0aW9uSW1wdWxzZS5zY2FsZShpbnZNYXNzQSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChQaHlzaWNzXzEuUGh5c2ljcy5hbGxvd1JpZ2lkQm9keVJvdGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlBLnJ4IC09IGZyaWN0aW9uSW1wdWxzZS5kb3QodCkgKiBpbnZNb2lBICogcmEuY3Jvc3ModCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXBwbHkgZnJpY3Rpb25hbCBpbXB1bHNlXHJcbiAgICAgICAgICAgICAgICAgICAgYm9keUIudmVsID0gYm9keUIudmVsLmFkZChmcmljdGlvbkltcHVsc2Uuc2NhbGUoaW52TWFzc0IpKTtcclxuICAgICAgICAgICAgICAgICAgICBib2R5QS52ZWwgPSBib2R5QS52ZWwuc3ViKGZyaWN0aW9uSW1wdWxzZS5zY2FsZShpbnZNYXNzQSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFwcGx5IGZyaWN0aW9uYWwgaW1wdWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChQaHlzaWNzXzEuUGh5c2ljcy5hbGxvd1JpZ2lkQm9keVJvdGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlCLnJ4ICs9IGZyaWN0aW9uSW1wdWxzZS5kb3QodCkgKiBpbnZNb2lCICogcmIuY3Jvc3ModCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlBLnJ4IC09IGZyaWN0aW9uSW1wdWxzZS5kb3QodCkgKiBpbnZNb2lBICogcmEuY3Jvc3ModCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJvZHlBLmFjdG9yLmVtaXQoJ3Bvc3Rjb2xsaXNpb24nLCBuZXcgRXZlbnRzXzEuUG9zdENvbGxpc2lvbkV2ZW50KHRoaXMuYm9keUEuYm9keS5hY3RvciwgdGhpcy5ib2R5Qi5ib2R5LmFjdG9yLCBzaWRlLCB0aGlzLm10dikpO1xyXG4gICAgICAgICAgICBib2R5Qi5hY3Rvci5lbWl0KCdwb3N0Y29sbGlzaW9uJywgbmV3IEV2ZW50c18xLlBvc3RDb2xsaXNpb25FdmVudCh0aGlzLmJvZHlCLmJvZHkuYWN0b3IsIHRoaXMuYm9keUEuYm9keS5hY3RvciwgVXRpbC5nZXRPcHBvc2l0ZVNpZGUoc2lkZSksIHRoaXMubXR2Lm5lZ2F0ZSgpKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gQ29sbGlzaW9uQ29udGFjdDtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkNvbGxpc2lvbkNvbnRhY3QgPSBDb2xsaXNpb25Db250YWN0O1xyXG59KTtcclxuZGVmaW5lKFwiQ29sbGlzaW9uL0lDb2xsaXNpb25BcmVhXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbn0pO1xyXG5kZWZpbmUoXCJDb2xsaXNpb24vQ2lyY2xlQXJlYVwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkNvbGxpc2lvbi9Cb3VuZGluZ0JveFwiLCBcIkNvbGxpc2lvbi9Qb2x5Z29uQXJlYVwiLCBcIkNvbGxpc2lvbi9FZGdlQXJlYVwiLCBcIkNvbGxpc2lvbi9Db2xsaXNpb25KdW1wVGFibGVcIiwgXCJBbGdlYnJhXCIsIFwiUGh5c2ljc1wiLCBcIkRyYXdpbmcvQ29sb3JcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBCb3VuZGluZ0JveF8xLCBQb2x5Z29uQXJlYV8xLCBFZGdlQXJlYV8xLCBDb2xsaXNpb25KdW1wVGFibGVfMSwgQWxnZWJyYV81LCBQaHlzaWNzXzIsIENvbG9yXzEpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGlzIGEgY2lyY2xlIGNvbGxpc2lvbiBhcmVhIGZvciB0aGUgZXhjYWxpYnVyIHJpZ2lkIGJvZHkgcGh5c2ljcyBzaW11bGF0aW9uXHJcbiAgICAgKi9cclxuICAgIHZhciBDaXJjbGVBcmVhID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBDaXJjbGVBcmVhKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoaXMgaXMgdGhlIGNlbnRlciBwb3NpdGlvbiBvZiB0aGUgY2lyY2xlLCByZWxhdGl2ZSB0byB0aGUgYm9keSBwb3NpdGlvblxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5wb3MgPSBBbGdlYnJhXzUuVmVjdG9yLlplcm8uY2xvbmUoKTtcclxuICAgICAgICAgICAgdGhpcy5wb3MgPSBvcHRpb25zLnBvcyB8fCBBbGdlYnJhXzUuVmVjdG9yLlplcm8uY2xvbmUoKTtcclxuICAgICAgICAgICAgdGhpcy5yYWRpdXMgPSBvcHRpb25zLnJhZGl1cyB8fCAwO1xyXG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBvcHRpb25zLmJvZHkgfHwgbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IHRoZSBjZW50ZXIgb2YgdGhlIGNvbGxpc2lvbiBhcmVhIGluIHdvcmxkIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2lyY2xlQXJlYS5wcm90b3R5cGUuZ2V0Q2VudGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5ib2R5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wb3MuYWRkKHRoaXMuYm9keS5wb3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRlc3RzIGlmIGEgcG9pbnQgaXMgY29udGFpbmVkIGluIHRoaXMgY29sbGlzaW9uIGFyZWFcclxuICAgICAgICAgKi9cclxuICAgICAgICBDaXJjbGVBcmVhLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSB0aGlzLmJvZHkucG9zLmRpc3RhbmNlKHBvaW50KTtcclxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDw9IHRoaXMucmFkaXVzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYXN0cyBhIHJheSBhdCB0aGUgQ2lyY2xlQXJlYSBhbmQgcmV0dXJucyB0aGUgbmVhcmVzdCBwb2ludCBvZiBjb2xsaXNpb25cclxuICAgICAgICAgKiBAcGFyYW0gcmF5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2lyY2xlQXJlYS5wcm90b3R5cGUucmF5Q2FzdCA9IGZ1bmN0aW9uIChyYXksIG1heCkge1xyXG4gICAgICAgICAgICBpZiAobWF4ID09PSB2b2lkIDApIHsgbWF4ID0gSW5maW5pdHk7IH1cclxuICAgICAgICAgICAgLy9odHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaW5lJUUyJTgwJTkzc3BoZXJlX2ludGVyc2VjdGlvblxyXG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuZ2V0Q2VudGVyKCk7XHJcbiAgICAgICAgICAgIHZhciBkaXIgPSByYXkuZGlyO1xyXG4gICAgICAgICAgICB2YXIgb3JpZyA9IHJheS5wb3M7XHJcbiAgICAgICAgICAgIHZhciBkaXNjcmltaW5hbnQgPSBNYXRoLnNxcnQoTWF0aC5wb3coZGlyLmRvdChvcmlnLnN1YihjKSksIDIpIC1cclxuICAgICAgICAgICAgICAgIE1hdGgucG93KG9yaWcuc3ViKGMpLmRpc3RhbmNlKCksIDIpICtcclxuICAgICAgICAgICAgICAgIE1hdGgucG93KHRoaXMucmFkaXVzLCAyKSk7XHJcbiAgICAgICAgICAgIGlmIChkaXNjcmltaW5hbnQgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBubyBpbnRlcnNlY3Rpb25cclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRvaSA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlzY3JpbWluYW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9pID0gLWRpci5kb3Qob3JpZy5zdWIoYykpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2kgPiAwICYmIHRvaSA8IG1heCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmF5LmdldFBvaW50KHRvaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvaTEgPSAtZGlyLmRvdChvcmlnLnN1YihjKSkgKyBkaXNjcmltaW5hbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvaTIgPSAtZGlyLmRvdChvcmlnLnN1YihjKSkgLSBkaXNjcmltaW5hbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pbnRvaSA9IE1hdGgubWluKHRvaTEsIHRvaTIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtaW50b2kgPD0gbWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByYXkuZ2V0UG9pbnQobWludG9pKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBpbmhlcml0ZG9jXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2lyY2xlQXJlYS5wcm90b3R5cGUuY29sbGlkZSA9IGZ1bmN0aW9uIChhcmVhKSB7XHJcbiAgICAgICAgICAgIGlmIChhcmVhIGluc3RhbmNlb2YgQ2lyY2xlQXJlYSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbGxpc2lvbkp1bXBUYWJsZV8xLkNvbGxpc2lvbkp1bXBUYWJsZS5Db2xsaWRlQ2lyY2xlQ2lyY2xlKHRoaXMsIGFyZWEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGFyZWEgaW5zdGFuY2VvZiBQb2x5Z29uQXJlYV8xLlBvbHlnb25BcmVhKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29sbGlzaW9uSnVtcFRhYmxlXzEuQ29sbGlzaW9uSnVtcFRhYmxlLkNvbGxpZGVDaXJjbGVQb2x5Z29uKHRoaXMsIGFyZWEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGFyZWEgaW5zdGFuY2VvZiBFZGdlQXJlYV8xLkVkZ2VBcmVhKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29sbGlzaW9uSnVtcFRhYmxlXzEuQ29sbGlzaW9uSnVtcFRhYmxlLkNvbGxpZGVDaXJjbGVFZGdlKHRoaXMsIGFyZWEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2lyY2xlIGNvdWxkIG5vdCBjb2xsaWRlIHdpdGggdW5rbm93biBJQ29sbGlzaW9uQXJlYSBcIiArIHR5cGVvZiBhcmVhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmluZCB0aGUgcG9pbnQgb24gdGhlIHNoYXBlIGZ1cnRoZXN0IGluIHRoZSBkaXJlY3Rpb24gc3BlY2lmaWVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2lyY2xlQXJlYS5wcm90b3R5cGUuZ2V0RnVydGhlc3RQb2ludCA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2VudGVyKCkuYWRkKGRpcmVjdGlvbi5ub3JtYWxpemUoKS5zY2FsZSh0aGlzLnJhZGl1cykpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IHRoZSBheGlzIGFsaWduZWQgYm91bmRpbmcgYm94IGZvciB0aGUgY2lyY2xlIGFyZWFcclxuICAgICAgICAgKi9cclxuICAgICAgICBDaXJjbGVBcmVhLnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3hfMS5Cb3VuZGluZ0JveCh0aGlzLnBvcy54ICsgdGhpcy5ib2R5LnBvcy54IC0gdGhpcy5yYWRpdXMsIHRoaXMucG9zLnkgKyB0aGlzLmJvZHkucG9zLnkgLSB0aGlzLnJhZGl1cywgdGhpcy5wb3MueCArIHRoaXMuYm9keS5wb3MueCArIHRoaXMucmFkaXVzLCB0aGlzLnBvcy55ICsgdGhpcy5ib2R5LnBvcy55ICsgdGhpcy5yYWRpdXMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IGF4aXMgbm90IGltcGxlbWVudGVkIG9uIGNpcmNsZXMsIHNpbmNlIHRoZXJlIGFyZSBpbmZpbml0ZSBheGlzIGluIGEgY2lyY2xlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2lyY2xlQXJlYS5wcm90b3R5cGUuZ2V0QXhlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBtb21lbnQgb2YgaW5lcnRpYSBvZiBhIGNpcmNsZSBnaXZlbiBpdCdzIG1hc3NcclxuICAgICAgICAgKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaXN0X29mX21vbWVudHNfb2ZfaW5lcnRpYVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENpcmNsZUFyZWEucHJvdG90eXBlLmdldE1vbWVudE9mSW5lcnRpYSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG1hc3MgPSB0aGlzLmJvZHkgPyB0aGlzLmJvZHkubWFzcyA6IFBoeXNpY3NfMi5QaHlzaWNzLmRlZmF1bHRNYXNzO1xyXG4gICAgICAgICAgICByZXR1cm4gKG1hc3MgKiB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzKSAvIDI7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZXN0cyB0aGUgc2VwYXJhdGluZyBheGlzIHRoZW9yZW0gZm9yIGNpcmNsZXMgYWdhaW5zdCBwb2x5Z29uc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENpcmNsZUFyZWEucHJvdG90eXBlLnRlc3RTZXBhcmF0aW5nQXhpc1RoZW9yZW0gPSBmdW5jdGlvbiAocG9seWdvbikge1xyXG4gICAgICAgICAgICB2YXIgYXhlcyA9IHBvbHlnb24uZ2V0QXhlcygpO1xyXG4gICAgICAgICAgICB2YXIgcGMgPSBwb2x5Z29uLmdldENlbnRlcigpO1xyXG4gICAgICAgICAgICAvLyBTcGVjaWFsIFNBVCB3aXRoIGNpcmNsZXNcclxuICAgICAgICAgICAgdmFyIGNsb3Nlc3RQb2ludE9uUG9seSA9IHBvbHlnb24uZ2V0RnVydGhlc3RQb2ludCh0aGlzLnBvcy5zdWIocGMpKTtcclxuICAgICAgICAgICAgYXhlcy5wdXNoKHRoaXMucG9zLnN1YihjbG9zZXN0UG9pbnRPblBvbHkpLm5vcm1hbGl6ZSgpKTtcclxuICAgICAgICAgICAgdmFyIG1pbk92ZXJsYXAgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgICAgICB2YXIgbWluQXhpcyA9IG51bGw7XHJcbiAgICAgICAgICAgIHZhciBtaW5JbmRleCA9IC0xO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF4ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBwcm9qMSA9IHBvbHlnb24ucHJvamVjdChheGVzW2ldKTtcclxuICAgICAgICAgICAgICAgIHZhciBwcm9qMiA9IHRoaXMucHJvamVjdChheGVzW2ldKTtcclxuICAgICAgICAgICAgICAgIHZhciBvdmVybGFwID0gcHJvajEuZ2V0T3ZlcmxhcChwcm9qMik7XHJcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxhcCA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcmxhcCA8IG1pbk92ZXJsYXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluT3ZlcmxhcCA9IG92ZXJsYXA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbkF4aXMgPSBheGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5JbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtaW5JbmRleCA8IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBtaW5BeGlzLm5vcm1hbGl6ZSgpLnNjYWxlKG1pbk92ZXJsYXApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBDaXJjbGVBcmVhLnByb3RvdHlwZS5yZWNhbGMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIGNpcmNsZXMgZG9uJ3QgY2FjaGVcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByb2plY3QgdGhlIGNpcmNsZSBhbG9uZyBhIHNwZWNpZmllZCBheGlzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2lyY2xlQXJlYS5wcm90b3R5cGUucHJvamVjdCA9IGZ1bmN0aW9uIChheGlzKSB7XHJcbiAgICAgICAgICAgIHZhciBzY2FsYXJzID0gW107XHJcbiAgICAgICAgICAgIHZhciBwb2ludCA9IHRoaXMuZ2V0Q2VudGVyKCk7XHJcbiAgICAgICAgICAgIHZhciBkb3RQcm9kdWN0ID0gcG9pbnQuZG90KGF4aXMpO1xyXG4gICAgICAgICAgICBzY2FsYXJzLnB1c2goZG90UHJvZHVjdCk7XHJcbiAgICAgICAgICAgIHNjYWxhcnMucHVzaChkb3RQcm9kdWN0ICsgdGhpcy5yYWRpdXMpO1xyXG4gICAgICAgICAgICBzY2FsYXJzLnB1c2goZG90UHJvZHVjdCAtIHRoaXMucmFkaXVzKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbGdlYnJhXzUuUHJvamVjdGlvbihNYXRoLm1pbi5hcHBseShNYXRoLCBzY2FsYXJzKSwgTWF0aC5tYXguYXBwbHkoTWF0aCwgc2NhbGFycykpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBDaXJjbGVBcmVhLnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY3R4LCBjb2xvcikge1xyXG4gICAgICAgICAgICBpZiAoY29sb3IgPT09IHZvaWQgMCkgeyBjb2xvciA9IENvbG9yXzEuQ29sb3IuR3JlZW4uY2xvbmUoKTsgfVxyXG4gICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5ib2R5ID8gdGhpcy5ib2R5LnBvcy5hZGQodGhpcy5wb3MpIDogdGhpcy5wb3M7XHJcbiAgICAgICAgICAgIHZhciByb3RhdGlvbiA9IHRoaXMuYm9keSA/IHRoaXMuYm9keS5yb3RhdGlvbiA6IDA7XHJcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3IudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgY3R4LmFyYyhwb3MueCwgcG9zLnksIHRoaXMucmFkaXVzLCAwLCBNYXRoLlBJICogMik7XHJcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8ocG9zLngsIHBvcy55KTtcclxuICAgICAgICAgICAgY3R4LmxpbmVUbyhNYXRoLmNvcyhyb3RhdGlvbikgKiB0aGlzLnJhZGl1cyArIHBvcy54LCBNYXRoLnNpbihyb3RhdGlvbikgKiB0aGlzLnJhZGl1cyArIHBvcy55KTtcclxuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gQ2lyY2xlQXJlYTtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkNpcmNsZUFyZWEgPSBDaXJjbGVBcmVhO1xyXG59KTtcclxuZGVmaW5lKFwiQ29sbGlzaW9uL0NvbGxpc2lvbkp1bXBUYWJsZVwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkNvbGxpc2lvbi9Db2xsaXNpb25Db250YWN0XCIsIFwiQ29sbGlzaW9uL1BvbHlnb25BcmVhXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgQ29sbGlzaW9uQ29udGFjdF8xLCBQb2x5Z29uQXJlYV8yKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIGV4cG9ydHMuQ29sbGlzaW9uSnVtcFRhYmxlID0ge1xyXG4gICAgICAgIENvbGxpZGVDaXJjbGVDaXJjbGU6IGZ1bmN0aW9uIChjaXJjbGVBLCBjaXJjbGVCKSB7XHJcbiAgICAgICAgICAgIHZhciByYWRpdXMgPSBjaXJjbGVBLnJhZGl1cyArIGNpcmNsZUIucmFkaXVzO1xyXG4gICAgICAgICAgICB2YXIgY2lyY2xlQVBvcyA9IGNpcmNsZUEuYm9keS5wb3MuYWRkKGNpcmNsZUEucG9zKTtcclxuICAgICAgICAgICAgdmFyIGNpcmNsZUJQb3MgPSBjaXJjbGVCLmJvZHkucG9zLmFkZChjaXJjbGVCLnBvcyk7XHJcbiAgICAgICAgICAgIGlmIChjaXJjbGVBUG9zLmRpc3RhbmNlKGNpcmNsZUJQb3MpID4gcmFkaXVzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYXhpc09mQ29sbGlzaW9uID0gY2lyY2xlQlBvcy5zdWIoY2lyY2xlQVBvcykubm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgIHZhciBtdnQgPSBheGlzT2ZDb2xsaXNpb24uc2NhbGUocmFkaXVzIC0gY2lyY2xlQlBvcy5kaXN0YW5jZShjaXJjbGVBUG9zKSk7XHJcbiAgICAgICAgICAgIHZhciBwb2ludE9mQ29sbGlzaW9uID0gY2lyY2xlQS5nZXRGdXJ0aGVzdFBvaW50KGF4aXNPZkNvbGxpc2lvbik7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sbGlzaW9uQ29udGFjdF8xLkNvbGxpc2lvbkNvbnRhY3QoY2lyY2xlQSwgY2lyY2xlQiwgbXZ0LCBwb2ludE9mQ29sbGlzaW9uLCBheGlzT2ZDb2xsaXNpb24pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgQ29sbGlkZUNpcmNsZVBvbHlnb246IGZ1bmN0aW9uIChjaXJjbGUsIHBvbHlnb24pIHtcclxuICAgICAgICAgICAgdmFyIG1pbkF4aXMgPSBjaXJjbGUudGVzdFNlcGFyYXRpbmdBeGlzVGhlb3JlbShwb2x5Z29uKTtcclxuICAgICAgICAgICAgaWYgKCFtaW5BeGlzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhhdCB0aGUgbWluQXhpcyBpcyBwb2ludGluZyBhd2F5IGZyb20gY2lyY2xlXHJcbiAgICAgICAgICAgIHZhciBzYW1lZGlyID0gbWluQXhpcy5kb3QocG9seWdvbi5nZXRDZW50ZXIoKS5zdWIoY2lyY2xlLmdldENlbnRlcigpKSk7XHJcbiAgICAgICAgICAgIG1pbkF4aXMgPSBzYW1lZGlyIDwgMCA/IG1pbkF4aXMubmVnYXRlKCkgOiBtaW5BeGlzO1xyXG4gICAgICAgICAgICB2YXIgdmVydHMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIHBvaW50MSA9IHBvbHlnb24uZ2V0RnVydGhlc3RQb2ludChtaW5BeGlzLm5lZ2F0ZSgpKTtcclxuICAgICAgICAgICAgdmFyIHBvaW50MiA9IGNpcmNsZS5nZXRGdXJ0aGVzdFBvaW50KG1pbkF4aXMpOyAvLy5hZGQoY2MpO1xyXG4gICAgICAgICAgICBpZiAoY2lyY2xlLmNvbnRhaW5zKHBvaW50MSkpIHtcclxuICAgICAgICAgICAgICAgIHZlcnRzLnB1c2gocG9pbnQxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocG9seWdvbi5jb250YWlucyhwb2ludDIpKSB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0cy5wdXNoKHBvaW50Mik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZlcnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xsaXNpb25Db250YWN0XzEuQ29sbGlzaW9uQ29udGFjdChjaXJjbGUsIHBvbHlnb24sIG1pbkF4aXMsIHZlcnRzLmxlbmd0aCA9PT0gMiA/IHZlcnRzWzBdLmF2ZXJhZ2UodmVydHNbMV0pIDogdmVydHNbMF0sIG1pbkF4aXMubm9ybWFsaXplKCkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgQ29sbGlkZUNpcmNsZUVkZ2U6IGZ1bmN0aW9uIChjaXJjbGUsIGVkZ2UpIHtcclxuICAgICAgICAgICAgLy8gY2VudGVyIG9mIHRoZSBjaXJjbGVcclxuICAgICAgICAgICAgdmFyIGNjID0gY2lyY2xlLmdldENlbnRlcigpO1xyXG4gICAgICAgICAgICAvLyB2ZWN0b3IgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgZWRnZVxyXG4gICAgICAgICAgICB2YXIgZSA9IGVkZ2UuZW5kLnN1YihlZGdlLmJlZ2luKTtcclxuICAgICAgICAgICAgLy8gYW1vdW50IG9mIG92ZXJsYXAgd2l0aCB0aGUgY2lyY2xlJ3MgY2VudGVyIGFsb25nIHRoZSBlZGdlIGRpcmVjdGlvblxyXG4gICAgICAgICAgICB2YXIgdSA9IGUuZG90KGVkZ2UuZW5kLnN1YihjYykpO1xyXG4gICAgICAgICAgICB2YXIgdiA9IGUuZG90KGNjLnN1YihlZGdlLmJlZ2luKSk7XHJcbiAgICAgICAgICAgIC8vIFBvdGVudGlhbCByZWdpb24gQSBjb2xsaXNpb24gKGNpcmNsZSBpcyBvbiB0aGUgbGVmdCBzaWRlIG9mIHRoZSBlZGdlLCBiZWZvcmUgdGhlIGJlZ2lubmluZylcclxuICAgICAgICAgICAgaWYgKHYgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhID0gZWRnZS5iZWdpbi5zdWIoY2MpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRkYSA9IGRhLmRvdChkYSk7IC8vIHF1aWNrIGFuZCBkaXJ0eSB3YXkgb2YgY2FsYyduIGRpc3RhbmNlIGluIHJeMiB0ZXJtcyBzYXZlcyBzb21lIHNxcnRzXHJcbiAgICAgICAgICAgICAgICAvLyBzYXZlIHNvbWUgc3FydHNcclxuICAgICAgICAgICAgICAgIGlmIChkZGEgPiBjaXJjbGUucmFkaXVzICogY2lyY2xlLnJhZGl1cykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyBubyBjb2xsaXNpb25cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29sbGlzaW9uQ29udGFjdF8xLkNvbGxpc2lvbkNvbnRhY3QoY2lyY2xlLCBlZGdlLCBkYS5ub3JtYWxpemUoKS5zY2FsZShjaXJjbGUucmFkaXVzIC0gTWF0aC5zcXJ0KGRkYSkpLCBlZGdlLmJlZ2luLCBkYS5ub3JtYWxpemUoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUG90ZW50aWFsIHJlZ2lvbiBCIGNvbGxpc2lvbiAoY2lyY2xlIGlzIG9uIHRoZSByaWdodCBzaWRlIG9mIHRoZSBlZGdlLCBhZnRlciB0aGUgZW5kKVxyXG4gICAgICAgICAgICBpZiAodSA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGIgPSBlZGdlLmVuZC5zdWIoY2MpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRkYiA9IGRiLmRvdChkYik7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGRiID4gY2lyY2xlLnJhZGl1cyAqIGNpcmNsZS5yYWRpdXMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29sbGlzaW9uQ29udGFjdF8xLkNvbGxpc2lvbkNvbnRhY3QoY2lyY2xlLCBlZGdlLCBkYi5ub3JtYWxpemUoKS5zY2FsZShjaXJjbGUucmFkaXVzIC0gTWF0aC5zcXJ0KGRkYikpLCBlZGdlLmVuZCwgZGIubm9ybWFsaXplKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBwb3RlbnRpYWwgcmVnaW9uIEFCIGNvbGxpc2lvbiAoY2lyY2xlIGlzIGluIHRoZSBtaWRkbGUgb2YgdGhlIGVkZ2UgYmV0d2VlbiB0aGUgYmVnaW5uaW5nIGFuZCBlbmQpXHJcbiAgICAgICAgICAgIHZhciBkZW4gPSBlLmRvdChlKTtcclxuICAgICAgICAgICAgdmFyIHBvaW50T25FZGdlID0gKGVkZ2UuYmVnaW4uc2NhbGUodSkuYWRkKGVkZ2UuZW5kLnNjYWxlKHYpKSkuc2NhbGUoMSAvIGRlbik7XHJcbiAgICAgICAgICAgIHZhciBkID0gY2Muc3ViKHBvaW50T25FZGdlKTtcclxuICAgICAgICAgICAgdmFyIGRkID0gZC5kb3QoZCk7XHJcbiAgICAgICAgICAgIGlmIChkZCA+IGNpcmNsZS5yYWRpdXMgKiBjaXJjbGUucmFkaXVzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gbm8gY29sbGlzaW9uXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG4gPSBlLnBlcnBlbmRpY3VsYXIoKTtcclxuICAgICAgICAgICAgLy8gZmxpcCBjb3JyZWN0IGRpcmVjdGlvblxyXG4gICAgICAgICAgICBpZiAobi5kb3QoY2Muc3ViKGVkZ2UuYmVnaW4pKSA8IDApIHtcclxuICAgICAgICAgICAgICAgIG4ueCA9IC1uLng7XHJcbiAgICAgICAgICAgICAgICBuLnkgPSAtbi55O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG4gPSBuLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICB2YXIgbXZ0ID0gbi5zY2FsZShNYXRoLmFicyhjaXJjbGUucmFkaXVzIC0gTWF0aC5zcXJ0KGRkKSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbGxpc2lvbkNvbnRhY3RfMS5Db2xsaXNpb25Db250YWN0KGNpcmNsZSwgZWRnZSwgbXZ0Lm5lZ2F0ZSgpLCBwb2ludE9uRWRnZSwgbi5uZWdhdGUoKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBDb2xsaWRlRWRnZUVkZ2U6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gRWRnZS1lZGdlIGNvbGxpc2lvbiBkb2Vzbid0IG1ha2Ugc2Vuc2VcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBDb2xsaWRlUG9seWdvbkVkZ2U6IGZ1bmN0aW9uIChwb2x5Z29uLCBlZGdlKSB7XHJcbiAgICAgICAgICAgIC8vIDMgY2FzZXM6XHJcbiAgICAgICAgICAgIC8vICgxKSBQb2x5Z29uIGxhbmRzIG9uIHRoZSBmdWxsIGZhY2VcclxuICAgICAgICAgICAgLy8gKDIpIFBvbHlnb24gbGFuZHMgb24gdGhlIHJpZ2h0IHBvaW50XHJcbiAgICAgICAgICAgIC8vICgzKSBQb2x5Z29uIGxhbmRzIG9uIHRoZSBsZWZ0IHBvaW50XHJcbiAgICAgICAgICAgIHZhciBlID0gZWRnZS5lbmQuc3ViKGVkZ2UuYmVnaW4pO1xyXG4gICAgICAgICAgICB2YXIgZWRnZU5vcm1hbCA9IGUubm9ybWFsKCk7XHJcbiAgICAgICAgICAgIGlmIChwb2x5Z29uLmNvbnRhaW5zKGVkZ2UuYmVnaW4pKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBwb2x5Z29uLmdldENsb3Nlc3RGYWNlKGVkZ2UuYmVnaW4pLCBtdHYgPSBfYS5kaXN0YW5jZSwgZmFjZSA9IF9hLmZhY2U7XHJcbiAgICAgICAgICAgICAgICBpZiAobXR2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xsaXNpb25Db250YWN0XzEuQ29sbGlzaW9uQ29udGFjdChwb2x5Z29uLCBlZGdlLCBtdHYubmVnYXRlKCksIGVkZ2UuYmVnaW4uYWRkKG10di5uZWdhdGUoKSksIGZhY2Uubm9ybWFsKCkubmVnYXRlKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwb2x5Z29uLmNvbnRhaW5zKGVkZ2UuZW5kKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9iID0gcG9seWdvbi5nZXRDbG9zZXN0RmFjZShlZGdlLmVuZCksIG10diA9IF9iLmRpc3RhbmNlLCBmYWNlID0gX2IuZmFjZTtcclxuICAgICAgICAgICAgICAgIGlmIChtdHYpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbGxpc2lvbkNvbnRhY3RfMS5Db2xsaXNpb25Db250YWN0KHBvbHlnb24sIGVkZ2UsIG10di5uZWdhdGUoKSwgZWRnZS5lbmQuYWRkKG10di5uZWdhdGUoKSksIGZhY2Uubm9ybWFsKCkubmVnYXRlKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBwYyA9IHBvbHlnb24uZ2V0Q2VudGVyKCk7XHJcbiAgICAgICAgICAgIHZhciBlYyA9IGVkZ2UuZ2V0Q2VudGVyKCk7XHJcbiAgICAgICAgICAgIHZhciBkaXIgPSBlYy5zdWIocGMpLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICAvLyBidWlsZCBhIHRlbXBvcmFyeSBwb2x5Z29uIGZyb20gdGhlIGVkZ2UgdG8gdXNlIFNBVFxyXG4gICAgICAgICAgICB2YXIgbGluZVBvbHkgPSBuZXcgUG9seWdvbkFyZWFfMi5Qb2x5Z29uQXJlYSh7XHJcbiAgICAgICAgICAgICAgICBwb2ludHM6IFtcclxuICAgICAgICAgICAgICAgICAgICBlZGdlLmJlZ2luLFxyXG4gICAgICAgICAgICAgICAgICAgIGVkZ2UuZW5kLFxyXG4gICAgICAgICAgICAgICAgICAgIGVkZ2UuZW5kLmFkZChkaXIuc2NhbGUoMzApKSxcclxuICAgICAgICAgICAgICAgICAgICBlZGdlLmJlZ2luLmFkZChkaXIuc2NhbGUoMzApKVxyXG4gICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmFyIG1pbkF4aXMgPSBwb2x5Z29uLnRlc3RTZXBhcmF0aW5nQXhpc1RoZW9yZW0obGluZVBvbHkpO1xyXG4gICAgICAgICAgICAvLyBubyBtaW5BeGlzLCBubyBvdmVybGFwLCBubyBjb2xsaXNpb25cclxuICAgICAgICAgICAgaWYgKCFtaW5BeGlzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBmbGlwIHRoZSBub3JtYWwgYW5kIGF4aXMgdG8gYWx3YXlzIGhhdmUgcG9zaXRpdmUgY29sbGlzaW9uc1xyXG4gICAgICAgICAgICBlZGdlTm9ybWFsID0gZWRnZU5vcm1hbC5kb3QoZGlyKSA8IDAgPyBlZGdlTm9ybWFsLm5lZ2F0ZSgpIDogZWRnZU5vcm1hbDtcclxuICAgICAgICAgICAgbWluQXhpcyA9IG1pbkF4aXMuZG90KGRpcikgPCAwID8gbWluQXhpcy5uZWdhdGUoKSA6IG1pbkF4aXM7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sbGlzaW9uQ29udGFjdF8xLkNvbGxpc2lvbkNvbnRhY3QocG9seWdvbiwgZWRnZSwgbWluQXhpcywgcG9seWdvbi5nZXRGdXJ0aGVzdFBvaW50KGVkZ2VOb3JtYWwpLCBlZGdlTm9ybWFsKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIENvbGxpZGVQb2x5Z29uUG9seWdvbjogZnVuY3Rpb24gKHBvbHlBLCBwb2x5Qikge1xyXG4gICAgICAgICAgICAvLyBkbyBhIFNBVCB0ZXN0IHRvIGZpbmQgYSBtaW4gYXhpcyBpZiBpdCBleGlzdHNcclxuICAgICAgICAgICAgdmFyIG1pbkF4aXMgPSBwb2x5QS50ZXN0U2VwYXJhdGluZ0F4aXNUaGVvcmVtKHBvbHlCKTtcclxuICAgICAgICAgICAgLy8gbm8gb3ZlcmxhcCwgbm8gY29sbGlzaW9uIHJldHVybiBudWxsXHJcbiAgICAgICAgICAgIGlmICghbWluQXhpcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoYXQgbWluQXhpcyBpcyBwb2ludGluZyBmcm9tIEEgLT4gQlxyXG4gICAgICAgICAgICB2YXIgc2FtZURpciA9IG1pbkF4aXMuZG90KHBvbHlCLmdldENlbnRlcigpLnN1Yihwb2x5QS5nZXRDZW50ZXIoKSkpO1xyXG4gICAgICAgICAgICBtaW5BeGlzID0gc2FtZURpciA8IDAgPyBtaW5BeGlzLm5lZ2F0ZSgpIDogbWluQXhpcztcclxuICAgICAgICAgICAgLy8gZmluZCByb3VnaCBwb2ludCBvZiBjb2xsaXNpb25cclxuICAgICAgICAgICAgLy8gdG9kbyB0aGlzIGNvdWxkIGJlIGJldHRlclxyXG4gICAgICAgICAgICB2YXIgdmVydHMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIHBvaW50QSA9IHBvbHlBLmdldEZ1cnRoZXN0UG9pbnQobWluQXhpcyk7XHJcbiAgICAgICAgICAgIHZhciBwb2ludEIgPSBwb2x5Qi5nZXRGdXJ0aGVzdFBvaW50KG1pbkF4aXMubmVnYXRlKCkpO1xyXG4gICAgICAgICAgICBpZiAocG9seUIuY29udGFpbnMocG9pbnRBKSkge1xyXG4gICAgICAgICAgICAgICAgdmVydHMucHVzaChwb2ludEEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwb2x5QS5jb250YWlucyhwb2ludEIpKSB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0cy5wdXNoKHBvaW50Qik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gbm8gY2FuZGlkYXRlcywgcGljayBzb21ldGhpbmdcclxuICAgICAgICAgICAgaWYgKHZlcnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdmVydHMucHVzaChwb2ludEIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjb250YWN0ID0gdmVydHMubGVuZ3RoID09PSAyID8gdmVydHNbMF0uYWRkKHZlcnRzWzFdKS5zY2FsZSguNSkgOiB2ZXJ0c1swXTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xsaXNpb25Db250YWN0XzEuQ29sbGlzaW9uQ29udGFjdChwb2x5QSwgcG9seUIsIG1pbkF4aXMsIGNvbnRhY3QsIG1pbkF4aXMubm9ybWFsaXplKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn0pO1xyXG5kZWZpbmUoXCJDb2xsaXNpb24vUG9seWdvbkFyZWFcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJEcmF3aW5nL0NvbG9yXCIsIFwiUGh5c2ljc1wiLCBcIkNvbGxpc2lvbi9Cb3VuZGluZ0JveFwiLCBcIkNvbGxpc2lvbi9FZGdlQXJlYVwiLCBcIkNvbGxpc2lvbi9Db2xsaXNpb25KdW1wVGFibGVcIiwgXCJDb2xsaXNpb24vQ2lyY2xlQXJlYVwiLCBcIkFsZ2VicmFcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBDb2xvcl8yLCBQaHlzaWNzXzMsIEJvdW5kaW5nQm94XzIsIEVkZ2VBcmVhXzIsIENvbGxpc2lvbkp1bXBUYWJsZV8yLCBDaXJjbGVBcmVhXzEsIEFsZ2VicmFfNikge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIFBvbHlnb24gY29sbGlzaW9uIGFyZWEgZm9yIGRldGVjdGluZyBjb2xsaXNpb25zIGZvciBhY3RvcnMsIG9yIGluZGVwZW5kZW50bHlcclxuICAgICAqL1xyXG4gICAgdmFyIFBvbHlnb25BcmVhID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBQb2x5Z29uQXJlYShvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybWVkUG9pbnRzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuX2F4ZXMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5fc2lkZXMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5wb3MgPSBvcHRpb25zLnBvcyB8fCBBbGdlYnJhXzYuVmVjdG9yLlplcm8uY2xvbmUoKTtcclxuICAgICAgICAgICAgdmFyIHdpbmRpbmcgPSAhIW9wdGlvbnMuY2xvY2t3aXNlV2luZGluZztcclxuICAgICAgICAgICAgdGhpcy5wb2ludHMgPSAod2luZGluZyA/IG9wdGlvbnMucG9pbnRzLnJldmVyc2UoKSA6IG9wdGlvbnMucG9pbnRzKSB8fCBbXTtcclxuICAgICAgICAgICAgdGhpcy5ib2R5ID0gb3B0aW9ucy5ib2R5IHx8IG51bGw7XHJcbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBpbml0aWFsIHRyYW5zZm9ybWF0aW9uXHJcbiAgICAgICAgICAgIHRoaXMuX2NhbGN1bGF0ZVRyYW5zZm9ybWF0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCB0aGUgY2VudGVyIG9mIHRoZSBjb2xsaXNpb24gYXJlYSBpbiB3b3JsZCBjb29yZGluYXRlc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBvbHlnb25BcmVhLnByb3RvdHlwZS5nZXRDZW50ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmJvZHkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJvZHkucG9zLmFkZCh0aGlzLnBvcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgdW5kZXJseWluZyB0cmFuc2Zvcm1hdGlvbiBmcm9tIHRoZSBib2R5IHJlbGF0aXZlIHNwYWNlIHRvIHdvcmxkIHNwYWNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUG9seWdvbkFyZWEucHJvdG90eXBlLl9jYWxjdWxhdGVUcmFuc2Zvcm1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHBvcyA9IHRoaXMuYm9keSA/IHRoaXMuYm9keS5wb3MuYWRkKHRoaXMucG9zKSA6IHRoaXMucG9zO1xyXG4gICAgICAgICAgICB2YXIgYW5nbGUgPSB0aGlzLmJvZHkgPyB0aGlzLmJvZHkucm90YXRpb24gOiAwO1xyXG4gICAgICAgICAgICB2YXIgbGVuID0gdGhpcy5wb2ludHMubGVuZ3RoO1xyXG4gICAgICAgICAgICB0aGlzLl90cmFuc2Zvcm1lZFBvaW50cy5sZW5ndGggPSAwOyAvLyBjbGVhciBvdXQgb2xkIHRyYW5zZm9ybVxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2Zvcm1lZFBvaW50c1tpXSA9IHRoaXMucG9pbnRzW2ldLnJvdGF0ZShhbmdsZSkuYWRkKHBvcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIHBvaW50cyB0aGF0IG1ha2UgdXAgdGhlIHBvbHlnb24gaW4gd29ybGQgc3BhY2UsIGZyb20gYWN0b3IgcmVsYXRpdmUgc3BhY2UgKGlmIHNwZWNpZmllZClcclxuICAgICAgICAgKi9cclxuICAgICAgICBQb2x5Z29uQXJlYS5wcm90b3R5cGUuZ2V0VHJhbnNmb3JtZWRQb2ludHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fdHJhbnNmb3JtZWRQb2ludHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVUcmFuc2Zvcm1hdGlvbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybWVkUG9pbnRzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgc2lkZXMgb2YgdGhlIHBvbHlnb24gaW4gd29ybGQgc3BhY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBQb2x5Z29uQXJlYS5wcm90b3R5cGUuZ2V0U2lkZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9zaWRlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaWRlcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbGluZXMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludHMoKTtcclxuICAgICAgICAgICAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2gobmV3IEFsZ2VicmFfNi5MaW5lKHBvaW50c1tpXSwgcG9pbnRzWyhpIC0gMSArIGxlbikgJSBsZW5dKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fc2lkZXMgPSBsaW5lcztcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpZGVzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUG9seWdvbkFyZWEucHJvdG90eXBlLnJlY2FsYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fc2lkZXMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fYXhlcy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl90cmFuc2Zvcm1lZFBvaW50cy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnRzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0QXhlcygpO1xyXG4gICAgICAgICAgICB0aGlzLmdldFNpZGVzKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZXN0cyBpZiBhIHBvaW50IGlzIGNvbnRhaW5lZCBpbiB0aGlzIGNvbGxpc2lvbiBhcmVhIGluIHdvcmxkIHNwYWNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUG9seWdvbkFyZWEucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgICAgICAgICAgIC8vIEFsd2F5cyBjYXN0IHRvIHRoZSByaWdodCwgYXMgbG9uZyBhcyB3ZSBjYXN0IGluIGEgY29uc2l0ZW50IGZpeGVkIGRpcmVjdGlvbiB3ZVxyXG4gICAgICAgICAgICAvLyB3aWxsIGJlIGZpbmVcclxuICAgICAgICAgICAgdmFyIHRlc3RSYXkgPSBuZXcgQWxnZWJyYV82LlJheShwb2ludCwgbmV3IEFsZ2VicmFfNi5WZWN0b3IoMSwgMCkpO1xyXG4gICAgICAgICAgICB2YXIgaW50ZXJzZWN0Q291bnQgPSB0aGlzLmdldFNpZGVzKCkucmVkdWNlKGZ1bmN0aW9uIChhY2N1bSwgc2lkZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRlc3RSYXkuaW50ZXJzZWN0KHNpZGUpID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW0gKyAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xyXG4gICAgICAgICAgICB9LCAwKTtcclxuICAgICAgICAgICAgaWYgKGludGVyc2VjdENvdW50ICUgMiA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIGNvbGxpc2lvbiBjb250YWN0IGlmIHRoZSAyIGNvbGxpc2lvbiBhcmVhcyBjb2xsaWRlLCBvdGhlcndpc2UgY29sbGlkZSB3aWxsXHJcbiAgICAgICAgICogcmV0dXJuIG51bGwuXHJcbiAgICAgICAgICogQHBhcmFtIGFyZWFcclxuICAgICAgICAgKi9cclxuICAgICAgICBQb2x5Z29uQXJlYS5wcm90b3R5cGUuY29sbGlkZSA9IGZ1bmN0aW9uIChhcmVhKSB7XHJcbiAgICAgICAgICAgIGlmIChhcmVhIGluc3RhbmNlb2YgQ2lyY2xlQXJlYV8xLkNpcmNsZUFyZWEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDb2xsaXNpb25KdW1wVGFibGVfMi5Db2xsaXNpb25KdW1wVGFibGUuQ29sbGlkZUNpcmNsZVBvbHlnb24oYXJlYSwgdGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYXJlYSBpbnN0YW5jZW9mIFBvbHlnb25BcmVhKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29sbGlzaW9uSnVtcFRhYmxlXzIuQ29sbGlzaW9uSnVtcFRhYmxlLkNvbGxpZGVQb2x5Z29uUG9seWdvbih0aGlzLCBhcmVhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChhcmVhIGluc3RhbmNlb2YgRWRnZUFyZWFfMi5FZGdlQXJlYSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbGxpc2lvbkp1bXBUYWJsZV8yLkNvbGxpc2lvbkp1bXBUYWJsZS5Db2xsaWRlUG9seWdvbkVkZ2UodGhpcywgYXJlYSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb2x5Z29uIGNvdWxkIG5vdCBjb2xsaWRlIHdpdGggdW5rbm93biBJQ29sbGlzaW9uQXJlYSBcIiArIHR5cGVvZiBhcmVhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmluZCB0aGUgcG9pbnQgb24gdGhlIHNoYXBlIGZ1cnRoZXN0IGluIHRoZSBkaXJlY3Rpb24gc3BlY2lmaWVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUG9seWdvbkFyZWEucHJvdG90eXBlLmdldEZ1cnRoZXN0UG9pbnQgPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBwdHMgPSB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnRzKCk7XHJcbiAgICAgICAgICAgIHZhciBmdXJ0aGVzdFBvaW50ID0gbnVsbDtcclxuICAgICAgICAgICAgdmFyIG1heERpc3RhbmNlID0gLU51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBkaXJlY3Rpb24uZG90KHB0c1tpXSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiBtYXhEaXN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1heERpc3RhbmNlID0gZGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVydGhlc3RQb2ludCA9IHB0c1tpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZnVydGhlc3RQb2ludDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZpbmRzIHRoZSBjbG9zZXMgZmFjZSB0byB0aGUgcG9pbnQgdXNpbmcgcGVycGVuZGljdWxhciBkaXN0YW5jZVxyXG4gICAgICAgICAqIEBwYXJhbSBwb2ludCBwb2ludCB0byB0ZXN0IGFnYWluc3QgcG9seWdvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBvbHlnb25BcmVhLnByb3RvdHlwZS5nZXRDbG9zZXN0RmFjZSA9IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gICAgICAgICAgICB2YXIgc2lkZXMgPSB0aGlzLmdldFNpZGVzKCk7XHJcbiAgICAgICAgICAgIHZhciBtaW4gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XHJcbiAgICAgICAgICAgIHZhciBmYWNlSW5kZXggPSAtMTtcclxuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gLTE7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lkZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBkaXN0ID0gc2lkZXNbaV0uZGlzdGFuY2VUb1BvaW50KHBvaW50KTtcclxuICAgICAgICAgICAgICAgIGlmIChkaXN0IDwgbWluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluID0gZGlzdDtcclxuICAgICAgICAgICAgICAgICAgICBmYWNlSW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gZGlzdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZmFjZUluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZTogc2lkZXNbZmFjZUluZGV4XS5ub3JtYWwoKS5zY2FsZShkaXN0YW5jZSksXHJcbiAgICAgICAgICAgICAgICAgICAgZmFjZTogc2lkZXNbZmFjZUluZGV4XVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCB0aGUgYXhpcyBhbGlnbmVkIGJvdW5kaW5nIGJveCBmb3IgdGhlIHBvbHlnb24gYXJlYVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBvbHlnb25BcmVhLnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIHRvZG8gdGhlcmUgaXMgYSBmYXN0ZXIgd2F5IHRvIGRvIHRoaXNcclxuICAgICAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludHMoKTtcclxuICAgICAgICAgICAgdmFyIG1pblggPSBwb2ludHMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5taW4ocHJldiwgY3Vyci54KTtcclxuICAgICAgICAgICAgfSwgOTk5OTk5OTk5KTtcclxuICAgICAgICAgICAgdmFyIG1heFggPSBwb2ludHMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgocHJldiwgY3Vyci54KTtcclxuICAgICAgICAgICAgfSwgLTk5OTk5OTk5KTtcclxuICAgICAgICAgICAgdmFyIG1pblkgPSBwb2ludHMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5taW4ocHJldiwgY3Vyci55KTtcclxuICAgICAgICAgICAgfSwgOTk5OTk5OTk5OSk7XHJcbiAgICAgICAgICAgIHZhciBtYXhZID0gcG9pbnRzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3Vycikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHByZXYsIGN1cnIueSk7XHJcbiAgICAgICAgICAgIH0sIC05OTk5OTk5OTk5KTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveF8yLkJvdW5kaW5nQm94KG1pblgsIG1pblksIG1heFgsIG1heFkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IHRoZSBtb21lbnQgb2YgaW5lcnRpYSBmb3IgYW4gYXJiaXRyYXJ5IHBvbHlnb25cclxuICAgICAgICAgKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaXN0X29mX21vbWVudHNfb2ZfaW5lcnRpYVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBvbHlnb25BcmVhLnByb3RvdHlwZS5nZXRNb21lbnRPZkluZXJ0aWEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBtYXNzID0gdGhpcy5ib2R5ID8gdGhpcy5ib2R5Lm1hc3MgOiBQaHlzaWNzXzMuUGh5c2ljcy5kZWZhdWx0TWFzcztcclxuICAgICAgICAgICAgdmFyIG51bWVyYXRvciA9IDA7XHJcbiAgICAgICAgICAgIHZhciBkZW5vbWluYXRvciA9IDA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wb2ludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBpcGx1c29uZSA9IChpICsgMSkgJSB0aGlzLnBvaW50cy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3Jvc3NUZXJtID0gdGhpcy5wb2ludHNbaXBsdXNvbmVdLmNyb3NzKHRoaXMucG9pbnRzW2ldKTtcclxuICAgICAgICAgICAgICAgIG51bWVyYXRvciArPSBjcm9zc1Rlcm0gKiAodGhpcy5wb2ludHNbaV0uZG90KHRoaXMucG9pbnRzW2ldKSArXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2ludHNbaV0uZG90KHRoaXMucG9pbnRzW2lwbHVzb25lXSkgK1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnRzW2lwbHVzb25lXS5kb3QodGhpcy5wb2ludHNbaXBsdXNvbmVdKSk7XHJcbiAgICAgICAgICAgICAgICBkZW5vbWluYXRvciArPSBjcm9zc1Rlcm07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIChtYXNzIC8gNikgKiAobnVtZXJhdG9yIC8gZGVub21pbmF0b3IpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FzdHMgYSByYXkgaW50byB0aGUgcG9seWdvbiBhbmQgcmV0dXJucyBhIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIHBvaW50IG9mIGNvbnRhY3QgKGluIHdvcmxkIHNwYWNlKSBvciBudWxsIGlmIG5vIGNvbGxpc2lvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQb2x5Z29uQXJlYS5wcm90b3R5cGUucmF5Q2FzdCA9IGZ1bmN0aW9uIChyYXksIG1heCkge1xyXG4gICAgICAgICAgICBpZiAobWF4ID09PSB2b2lkIDApIHsgbWF4ID0gSW5maW5pdHk7IH1cclxuICAgICAgICAgICAgLy8gZmluZCB0aGUgbWluaW11bSBjb250YWN0IHRpbWUgZ3JlYXRlciB0aGFuIDBcclxuICAgICAgICAgICAgLy8gY29udGFjdCB0aW1lcyBsZXNzIHRoYW4gMCBhcmUgYmVoaW5kIHRoZSByYXkgYW5kIHdlIGRvbid0IHdhbnQgdGhvc2VcclxuICAgICAgICAgICAgdmFyIHNpZGVzID0gdGhpcy5nZXRTaWRlcygpO1xyXG4gICAgICAgICAgICB2YXIgbGVuID0gc2lkZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgbWluQ29udGFjdFRpbWUgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgICAgICB2YXIgY29udGFjdEluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb250YWN0VGltZSA9IHJheS5pbnRlcnNlY3Qoc2lkZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhY3RUaW1lID49IDAgJiYgY29udGFjdFRpbWUgPCBtaW5Db250YWN0VGltZSAmJiBjb250YWN0VGltZSA8PSBtYXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBtaW5Db250YWN0VGltZSA9IGNvbnRhY3RUaW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhY3RJbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gY29udGFjdCB3YXMgZm91bmRcclxuICAgICAgICAgICAgaWYgKGNvbnRhY3RJbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmF5LmdldFBvaW50KG1pbkNvbnRhY3RUaW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBubyBjb250YWN0IGZvdW5kXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IHRoZSBheGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZWRnZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBvbHlnb25BcmVhLnByb3RvdHlwZS5nZXRBeGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fYXhlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9heGVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBheGVzID0gW107XHJcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnRzKCk7XHJcbiAgICAgICAgICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBheGVzLnB1c2gocG9pbnRzW2ldLnN1Yihwb2ludHNbKGkgKyAxKSAlIGxlbl0pLm5vcm1hbCgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9heGVzID0gYXhlcztcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2F4ZXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQZXJmb3JtIFNlcGFyYXRpbmcgQXhpcyB0ZXN0IGFnYWluc3QgYW5vdGhlciBwb2x5Z29uLCByZXR1cm5zIG51bGwgaWYgbm8gb3ZlcmxhcCBpbiBwb2x5c1xyXG4gICAgICAgICAqIFJlZmVyZW5jZSBodHRwOi8vd3d3LmR5bjRqLm9yZy8yMDEwLzAxL3NhdC9cclxuICAgICAgICAgKi9cclxuICAgICAgICBQb2x5Z29uQXJlYS5wcm90b3R5cGUudGVzdFNlcGFyYXRpbmdBeGlzVGhlb3JlbSA9IGZ1bmN0aW9uIChvdGhlcikge1xyXG4gICAgICAgICAgICB2YXIgcG9seTEgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgcG9seTIgPSBvdGhlcjtcclxuICAgICAgICAgICAgdmFyIGF4ZXMgPSBwb2x5MS5nZXRBeGVzKCkuY29uY2F0KHBvbHkyLmdldEF4ZXMoKSk7XHJcbiAgICAgICAgICAgIHZhciBtaW5PdmVybGFwID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICAgICAgdmFyIG1pbkF4aXMgPSBudWxsO1xyXG4gICAgICAgICAgICB2YXIgbWluSW5kZXggPSAtMTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBheGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJvajEgPSBwb2x5MS5wcm9qZWN0KGF4ZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIHByb2oyID0gcG9seTIucHJvamVjdChheGVzW2ldKTtcclxuICAgICAgICAgICAgICAgIHZhciBvdmVybGFwID0gcHJvajEuZ2V0T3ZlcmxhcChwcm9qMik7XHJcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxhcCA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcmxhcCA8IG1pbk92ZXJsYXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluT3ZlcmxhcCA9IG92ZXJsYXA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbkF4aXMgPSBheGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5JbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFNhbml0eSBjaGVja1xyXG4gICAgICAgICAgICBpZiAobWluSW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbWluQXhpcy5ub3JtYWxpemUoKS5zY2FsZShtaW5PdmVybGFwKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByb2plY3QgdGhlIGVkZ2VzIG9mIHRoZSBwb2x5Z29uIGFsb25nIGEgc3BlY2lmaWVkIGF4aXNcclxuICAgICAgICAgKi9cclxuICAgICAgICBQb2x5Z29uQXJlYS5wcm90b3R5cGUucHJvamVjdCA9IGZ1bmN0aW9uIChheGlzKSB7XHJcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnRzKCk7XHJcbiAgICAgICAgICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgbWluID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICAgICAgdmFyIG1heCA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2NhbGFyID0gcG9pbnRzW2ldLmRvdChheGlzKTtcclxuICAgICAgICAgICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgc2NhbGFyKTtcclxuICAgICAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgc2NhbGFyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFsZ2VicmFfNi5Qcm9qZWN0aW9uKG1pbiwgbWF4KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgUG9seWdvbkFyZWEucHJvdG90eXBlLmRlYnVnRHJhdyA9IGZ1bmN0aW9uIChjdHgsIGNvbG9yKSB7XHJcbiAgICAgICAgICAgIGlmIChjb2xvciA9PT0gdm9pZCAwKSB7IGNvbG9yID0gQ29sb3JfMi5Db2xvci5SZWQuY2xvbmUoKTsgfVxyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgc3VwcGxpZWQgcG9pbnRzIGFuZCBjb25zdHJ1Y3QgYSAncG9seWdvbidcclxuICAgICAgICAgICAgdmFyIGZpcnN0UG9pbnQgPSB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnRzKClbMF07XHJcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oZmlyc3RQb2ludC54LCBmaXJzdFBvaW50LnkpO1xyXG4gICAgICAgICAgICB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnRzKCkuZm9yRWFjaChmdW5jdGlvbiAocG9pbnQpIHtcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8ocG9pbnQueCwgcG9pbnQueSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjdHgubGluZVRvKGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55KTtcclxuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gUG9seWdvbkFyZWE7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5Qb2x5Z29uQXJlYSA9IFBvbHlnb25BcmVhO1xyXG59KTtcclxuZGVmaW5lKFwiQ29sbGlzaW9uL0JvdW5kaW5nQm94XCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiQ29sbGlzaW9uL1BvbHlnb25BcmVhXCIsIFwiQWxnZWJyYVwiLCBcIkRyYXdpbmcvQ29sb3JcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBQb2x5Z29uQXJlYV8zLCBBbGdlYnJhXzcsIENvbG9yXzMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBeGlzIEFsaWduZWQgY29sbGlzaW9uIHByaW1pdGl2ZSBmb3IgRXhjYWxpYnVyLlxyXG4gICAgICovXHJcbiAgICB2YXIgQm91bmRpbmdCb3ggPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBsZWZ0ICAgIHggY29vcmRpbmF0ZSBvZiB0aGUgbGVmdCBlZGdlXHJcbiAgICAgICAgICogQHBhcmFtIHRvcCAgICAgeSBjb29yZGluYXRlIG9mIHRoZSB0b3AgZWRnZVxyXG4gICAgICAgICAqIEBwYXJhbSByaWdodCAgIHggY29vcmRpbmF0ZSBvZiB0aGUgcmlnaHQgZWRnZVxyXG4gICAgICAgICAqIEBwYXJhbSBib3R0b20gIHkgY29vcmRpbmF0ZSBvZiB0aGUgYm90dG9tIGVkZ2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBCb3VuZGluZ0JveChsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b20pIHtcclxuICAgICAgICAgICAgaWYgKGxlZnQgPT09IHZvaWQgMCkgeyBsZWZ0ID0gMDsgfVxyXG4gICAgICAgICAgICBpZiAodG9wID09PSB2b2lkIDApIHsgdG9wID0gMDsgfVxyXG4gICAgICAgICAgICBpZiAocmlnaHQgPT09IHZvaWQgMCkgeyByaWdodCA9IDA7IH1cclxuICAgICAgICAgICAgaWYgKGJvdHRvbSA9PT0gdm9pZCAwKSB7IGJvdHRvbSA9IDA7IH1cclxuICAgICAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcclxuICAgICAgICAgICAgdGhpcy50b3AgPSB0b3A7XHJcbiAgICAgICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcclxuICAgICAgICAgICAgdGhpcy5ib3R0b20gPSBib3R0b207XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEJvdW5kaW5nQm94LmZyb21Qb2ludHMgPSBmdW5jdGlvbiAocG9pbnRzKSB7XHJcbiAgICAgICAgICAgIHZhciBtaW5YID0gSW5maW5pdHk7XHJcbiAgICAgICAgICAgIHZhciBtaW5ZID0gSW5maW5pdHk7XHJcbiAgICAgICAgICAgIHZhciBtYXhYID0gLUluZmluaXR5O1xyXG4gICAgICAgICAgICB2YXIgbWF4WSA9IC1JbmZpbml0eTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChwb2ludHNbaV0ueCA8IG1pblgpIHtcclxuICAgICAgICAgICAgICAgICAgICBtaW5YID0gcG9pbnRzW2ldLng7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocG9pbnRzW2ldLnggPiBtYXhYKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4WCA9IHBvaW50c1tpXS54O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHBvaW50c1tpXS55IDwgbWluWSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pblkgPSBwb2ludHNbaV0ueTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChwb2ludHNbaV0ueSA+IG1heFkpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXhZID0gcG9pbnRzW2ldLnk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveChtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIGNhbGN1bGF0ZWQgd2lkdGggb2YgdGhlIGJvdW5kaW5nIGJveFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJvdW5kaW5nQm94LnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmlnaHQgLSB0aGlzLmxlZnQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjYWxjdWxhdGVkIGhlaWdodCBvZiB0aGUgYm91bmRpbmcgYm94XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQm91bmRpbmdCb3gucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm90dG9tIC0gdGhpcy50b3A7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSb3RhdGVzIGEgYm91bmRpbmcgYm94IGJ5IGFuZCBhbmdsZSBhbmQgYXJvdW5kIGEgcG9pbnQsIGlmIG5vIHBvaW50IGlzIHNwZWNpZmllZCAoMCwgMCkgaXMgdXNlZCBieSBkZWZhdWx0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQm91bmRpbmdCb3gucHJvdG90eXBlLnJvdGF0ZSA9IGZ1bmN0aW9uIChhbmdsZSwgcG9pbnQpIHtcclxuICAgICAgICAgICAgaWYgKHBvaW50ID09PSB2b2lkIDApIHsgcG9pbnQgPSBBbGdlYnJhXzcuVmVjdG9yLlplcm8uY2xvbmUoKTsgfVxyXG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5nZXRQb2ludHMoKS5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAucm90YXRlKGFuZ2xlLCBwb2ludCk7IH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gQm91bmRpbmdCb3guZnJvbVBvaW50cyhwb2ludHMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgcGVyaW1ldGVyIG9mIHRoZSBib3VuZGluZyBib3hcclxuICAgICAgICAgKi9cclxuICAgICAgICBCb3VuZGluZ0JveC5wcm90b3R5cGUuZ2V0UGVyaW1ldGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgd3ggPSB0aGlzLmdldFdpZHRoKCk7XHJcbiAgICAgICAgICAgIHZhciB3eSA9IHRoaXMuZ2V0SGVpZ2h0KCk7XHJcbiAgICAgICAgICAgIHJldHVybiAyICogKHd4ICsgd3kpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQm91bmRpbmdCb3gucHJvdG90eXBlLmdldFBvaW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcclxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKG5ldyBBbGdlYnJhXzcuVmVjdG9yKHRoaXMubGVmdCwgdGhpcy50b3ApKTtcclxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKG5ldyBBbGdlYnJhXzcuVmVjdG9yKHRoaXMucmlnaHQsIHRoaXMudG9wKSk7XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChuZXcgQWxnZWJyYV83LlZlY3Rvcih0aGlzLnJpZ2h0LCB0aGlzLmJvdHRvbSkpO1xyXG4gICAgICAgICAgICByZXN1bHRzLnB1c2gobmV3IEFsZ2VicmFfNy5WZWN0b3IodGhpcy5sZWZ0LCB0aGlzLmJvdHRvbSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBQb2x5Z29uIGNvbGxpc2lvbiBhcmVhIGZyb20gdGhlIHBvaW50cyBvZiB0aGUgYm91bmRpbmcgYm94XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQm91bmRpbmdCb3gucHJvdG90eXBlLnRvUG9seWdvbiA9IGZ1bmN0aW9uIChhY3Rvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvbHlnb25BcmVhXzMuUG9seWdvbkFyZWEoe1xyXG4gICAgICAgICAgICAgICAgYm9keTogYWN0b3IgPyBhY3Rvci5ib2R5IDogbnVsbCxcclxuICAgICAgICAgICAgICAgIHBvaW50czogdGhpcy5nZXRQb2ludHMoKSxcclxuICAgICAgICAgICAgICAgIHBvczogQWxnZWJyYV83LlZlY3Rvci5aZXJvLmNsb25lKClcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSByYXkgaW50ZXJzZWN0cyB3aXRoIGEgYm91bmRpbmcgYm94XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQm91bmRpbmdCb3gucHJvdG90eXBlLnJheUNhc3QgPSBmdW5jdGlvbiAocmF5LCBmYXJDbGlwRGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgaWYgKGZhckNsaXBEaXN0YW5jZSA9PT0gdm9pZCAwKSB7IGZhckNsaXBEaXN0YW5jZSA9IEluZmluaXR5OyB9XHJcbiAgICAgICAgICAgIC8vIGFsZ29yaXRobSBmcm9tIGh0dHBzOi8vdGF2aWFuYXRvci5jb20vZmFzdC1icmFuY2hsZXNzLXJheWJvdW5kaW5nLWJveC1pbnRlcnNlY3Rpb25zLyBcclxuICAgICAgICAgICAgdmFyIHRtaW4gPSAtSW5maW5pdHk7XHJcbiAgICAgICAgICAgIHZhciB0bWF4ID0gK0luZmluaXR5O1xyXG4gICAgICAgICAgICB2YXIgeGludiA9IHJheS5kaXIueCA9PT0gMCA/IE51bWJlci5NQVhfVkFMVUUgOiAoMSAvIHJheS5kaXIueCk7XHJcbiAgICAgICAgICAgIHZhciB5aW52ID0gcmF5LmRpci55ID09PSAwID8gTnVtYmVyLk1BWF9WQUxVRSA6ICgxIC8gcmF5LmRpci55KTtcclxuICAgICAgICAgICAgdmFyIHR4MSA9ICh0aGlzLmxlZnQgLSByYXkucG9zLngpICogeGludjtcclxuICAgICAgICAgICAgdmFyIHR4MiA9ICh0aGlzLnJpZ2h0IC0gcmF5LnBvcy54KSAqIHhpbnY7XHJcbiAgICAgICAgICAgIHRtaW4gPSBNYXRoLm1pbih0eDEsIHR4Mik7XHJcbiAgICAgICAgICAgIHRtYXggPSBNYXRoLm1heCh0eDEsIHR4Mik7XHJcbiAgICAgICAgICAgIHZhciB0eTEgPSAodGhpcy50b3AgLSByYXkucG9zLnkpICogeWludjtcclxuICAgICAgICAgICAgdmFyIHR5MiA9ICh0aGlzLmJvdHRvbSAtIHJheS5wb3MueSkgKiB5aW52O1xyXG4gICAgICAgICAgICB0bWluID0gTWF0aC5tYXgodG1pbiwgTWF0aC5taW4odHkxLCB0eTIpKTtcclxuICAgICAgICAgICAgdG1heCA9IE1hdGgubWluKHRtYXgsIE1hdGgubWF4KHR5MSwgdHkyKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0bWF4ID49IE1hdGgubWF4KDAsIHRtaW4pICYmIHRtaW4gPCBmYXJDbGlwRGlzdGFuY2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBCb3VuZGluZ0JveC5wcm90b3R5cGUucmF5Q2FzdFRpbWUgPSBmdW5jdGlvbiAocmF5LCBmYXJDbGlwRGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgaWYgKGZhckNsaXBEaXN0YW5jZSA9PT0gdm9pZCAwKSB7IGZhckNsaXBEaXN0YW5jZSA9IEluZmluaXR5OyB9XHJcbiAgICAgICAgICAgIC8vIGFsZ29yaXRobSBmcm9tIGh0dHBzOi8vdGF2aWFuYXRvci5jb20vZmFzdC1icmFuY2hsZXNzLXJheWJvdW5kaW5nLWJveC1pbnRlcnNlY3Rpb25zLyBcclxuICAgICAgICAgICAgdmFyIHRtaW4gPSAtSW5maW5pdHk7XHJcbiAgICAgICAgICAgIHZhciB0bWF4ID0gK0luZmluaXR5O1xyXG4gICAgICAgICAgICB2YXIgeGludiA9IHJheS5kaXIueCA9PT0gMCA/IE51bWJlci5NQVhfVkFMVUUgOiAoMSAvIHJheS5kaXIueCk7XHJcbiAgICAgICAgICAgIHZhciB5aW52ID0gcmF5LmRpci55ID09PSAwID8gTnVtYmVyLk1BWF9WQUxVRSA6ICgxIC8gcmF5LmRpci55KTtcclxuICAgICAgICAgICAgdmFyIHR4MSA9ICh0aGlzLmxlZnQgLSByYXkucG9zLngpICogeGludjtcclxuICAgICAgICAgICAgdmFyIHR4MiA9ICh0aGlzLnJpZ2h0IC0gcmF5LnBvcy54KSAqIHhpbnY7XHJcbiAgICAgICAgICAgIHRtaW4gPSBNYXRoLm1pbih0eDEsIHR4Mik7XHJcbiAgICAgICAgICAgIHRtYXggPSBNYXRoLm1heCh0eDEsIHR4Mik7XHJcbiAgICAgICAgICAgIHZhciB0eTEgPSAodGhpcy50b3AgLSByYXkucG9zLnkpICogeWludjtcclxuICAgICAgICAgICAgdmFyIHR5MiA9ICh0aGlzLmJvdHRvbSAtIHJheS5wb3MueSkgKiB5aW52O1xyXG4gICAgICAgICAgICB0bWluID0gTWF0aC5tYXgodG1pbiwgTWF0aC5taW4odHkxLCB0eTIpKTtcclxuICAgICAgICAgICAgdG1heCA9IE1hdGgubWluKHRtYXgsIE1hdGgubWF4KHR5MSwgdHkyKSk7XHJcbiAgICAgICAgICAgIGlmICh0bWF4ID49IE1hdGgubWF4KDAsIHRtaW4pICYmIHRtaW4gPCBmYXJDbGlwRGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0bWluO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEJvdW5kaW5nQm94LnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIEFsZ2VicmFfNy5WZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5sZWZ0IDw9IHZhbC54ICYmIHRoaXMudG9wIDw9IHZhbC55ICYmIHRoaXMuYm90dG9tID49IHZhbC55ICYmIHRoaXMucmlnaHQgPj0gdmFsLngpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIEJvdW5kaW5nQm94KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sZWZ0IDwgdmFsLmxlZnQgJiZcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvcCA8IHZhbC50b3AgJiZcclxuICAgICAgICAgICAgICAgICAgICB2YWwuYm90dG9tIDwgdGhpcy5ib3R0b20gJiZcclxuICAgICAgICAgICAgICAgICAgICB2YWwucmlnaHQgPCB0aGlzLnJpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29tYmluZXMgdGhpcyBib3VuZGluZyBib3ggYW5kIGFub3RoZXIgdG9nZXRoZXIgcmV0dXJuaW5nIGEgbmV3IGJvdW5kaW5nIGJveFxyXG4gICAgICAgICAqIEBwYXJhbSBvdGhlciAgVGhlIGJvdW5kaW5nIGJveCB0byBjb21iaW5lXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQm91bmRpbmdCb3gucHJvdG90eXBlLmNvbWJpbmUgPSBmdW5jdGlvbiAob3RoZXIpIHtcclxuICAgICAgICAgICAgdmFyIGNvbXBvc2l0ZUJCID0gbmV3IEJvdW5kaW5nQm94KE1hdGgubWluKHRoaXMubGVmdCwgb3RoZXIubGVmdCksIE1hdGgubWluKHRoaXMudG9wLCBvdGhlci50b3ApLCBNYXRoLm1heCh0aGlzLnJpZ2h0LCBvdGhlci5yaWdodCksIE1hdGgubWF4KHRoaXMuYm90dG9tLCBvdGhlci5ib3R0b20pKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZUJCO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVzdCB3ZXRoZXIgdGhpcyBib3VuZGluZyBib3ggY29sbGlkZXMgd2l0aCBhbm90aGVyIHJldHVybmluZyxcclxuICAgICAgICAgKiB0aGUgaW50ZXJzZWN0aW9uIHZlY3RvciB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlc29sdmUgdGhlIGNvbGxpc2lvbi4gSWYgdGhlcmVcclxuICAgICAgICAgKiBpcyBubyBjb2xsaXNpb24gbnVsbCBpcyByZXR1cm5lZC5cclxuICAgICAgICAgKiBAcGFyYW0gY29sbGlkYWJsZSAgT3RoZXIgY29sbGlkYWJsZSB0byB0ZXN0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQm91bmRpbmdCb3gucHJvdG90eXBlLmNvbGxpZGVzID0gZnVuY3Rpb24gKGNvbGxpZGFibGUpIHtcclxuICAgICAgICAgICAgaWYgKGNvbGxpZGFibGUgaW5zdGFuY2VvZiBCb3VuZGluZ0JveCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG90aGVyID0gY29sbGlkYWJsZTtcclxuICAgICAgICAgICAgICAgIHZhciB0b3RhbEJvdW5kaW5nQm94ID0gdGhpcy5jb21iaW5lKG90aGVyKTtcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSB0b3RhbCBib3VuZGluZyBib3ggaXMgbGVzcyB0aGFuIHRoZSBzdW0gb2YgdGhlIDIgYm91bmRzIHRoZW4gdGhlcmUgaXMgY29sbGlzaW9uXHJcbiAgICAgICAgICAgICAgICBpZiAodG90YWxCb3VuZGluZ0JveC5nZXRXaWR0aCgpIDwgb3RoZXIuZ2V0V2lkdGgoKSArIHRoaXMuZ2V0V2lkdGgoKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsQm91bmRpbmdCb3guZ2V0SGVpZ2h0KCkgPCBvdGhlci5nZXRIZWlnaHQoKSArIHRoaXMuZ2V0SGVpZ2h0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb2xsaXNpb25cclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3ZlcmxhcFggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJpZ2h0ID49IG90aGVyLmxlZnQgJiYgdGhpcy5yaWdodCA8PSBvdGhlci5yaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGFwWCA9IG90aGVyLmxlZnQgLSB0aGlzLnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcFggPSBvdGhlci5yaWdodCAtIHRoaXMubGVmdDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG92ZXJsYXBZID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50b3AgPD0gb3RoZXIuYm90dG9tICYmIHRoaXMudG9wID49IG90aGVyLnRvcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGFwWSA9IG90aGVyLmJvdHRvbSAtIHRoaXMudG9wO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcFkgPSBvdGhlci50b3AgLSB0aGlzLmJvdHRvbTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKG92ZXJsYXBYKSA8IE1hdGguYWJzKG92ZXJsYXBZKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFsZ2VicmFfNy5WZWN0b3Iob3ZlcmxhcFgsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBbGdlYnJhXzcuVmVjdG9yKDAsIG92ZXJsYXBZKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgQm91bmRpbmdCb3gucHJvdG90eXBlLmRlYnVnRHJhdyA9IGZ1bmN0aW9uIChjdHgsIGNvbG9yKSB7XHJcbiAgICAgICAgICAgIGlmIChjb2xvciA9PT0gdm9pZCAwKSB7IGNvbG9yID0gQ29sb3JfMy5Db2xvci5ZZWxsb3c7IH1cclxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3IudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZVJlY3QodGhpcy5sZWZ0LCB0aGlzLnRvcCwgdGhpcy5nZXRXaWR0aCgpLCB0aGlzLmdldEhlaWdodCgpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBCb3VuZGluZ0JveDtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkJvdW5kaW5nQm94ID0gQm91bmRpbmdCb3g7XHJcbn0pO1xyXG5kZWZpbmUoXCJDb2xsaXNpb24vRWRnZUFyZWFcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJDb2xsaXNpb24vQm91bmRpbmdCb3hcIiwgXCJDb2xsaXNpb24vQ29sbGlzaW9uSnVtcFRhYmxlXCIsIFwiQ29sbGlzaW9uL0NpcmNsZUFyZWFcIiwgXCJDb2xsaXNpb24vUG9seWdvbkFyZWFcIiwgXCJBbGdlYnJhXCIsIFwiUGh5c2ljc1wiLCBcIkRyYXdpbmcvQ29sb3JcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBCb3VuZGluZ0JveF8zLCBDb2xsaXNpb25KdW1wVGFibGVfMywgQ2lyY2xlQXJlYV8yLCBQb2x5Z29uQXJlYV80LCBBbGdlYnJhXzgsIFBoeXNpY3NfNCwgQ29sb3JfNCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICB2YXIgRWRnZUFyZWEgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIEVkZ2VBcmVhKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdGhpcy5iZWdpbiA9IG9wdGlvbnMuYmVnaW4gfHwgQWxnZWJyYV84LlZlY3Rvci5aZXJvLmNsb25lKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kID0gb3B0aW9ucy5lbmQgfHwgQWxnZWJyYV84LlZlY3Rvci5aZXJvLmNsb25lKCk7XHJcbiAgICAgICAgICAgIHRoaXMuYm9keSA9IG9wdGlvbnMuYm9keSB8fCBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLnBvcyA9IHRoaXMuZ2V0Q2VudGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCB0aGUgY2VudGVyIG9mIHRoZSBjb2xsaXNpb24gYXJlYSBpbiB3b3JsZCBjb29yZGluYXRlc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVkZ2VBcmVhLnByb3RvdHlwZS5nZXRDZW50ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLmJlZ2luLmF2ZXJhZ2UodGhpcy5lbmQpLmFkZCh0aGlzLl9nZXRCb2R5UG9zKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gcG9zO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRWRnZUFyZWEucHJvdG90eXBlLl9nZXRCb2R5UG9zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYm9keVBvcyA9IEFsZ2VicmFfOC5WZWN0b3IuWmVyby5jbG9uZSgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5ib2R5LnBvcykge1xyXG4gICAgICAgICAgICAgICAgYm9keVBvcyA9IHRoaXMuYm9keS5wb3M7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGJvZHlQb3M7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBFZGdlQXJlYS5wcm90b3R5cGUuX2dldFRyYW5zZm9ybWVkQmVnaW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhbmdsZSA9IHRoaXMuYm9keSA/IHRoaXMuYm9keS5yb3RhdGlvbiA6IDA7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJlZ2luLnJvdGF0ZShhbmdsZSkuYWRkKHRoaXMuX2dldEJvZHlQb3MoKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBFZGdlQXJlYS5wcm90b3R5cGUuX2dldFRyYW5zZm9ybWVkRW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYW5nbGUgPSB0aGlzLmJvZHkgPyB0aGlzLmJvZHkucm90YXRpb24gOiAwO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmQucm90YXRlKGFuZ2xlKS5hZGQodGhpcy5fZ2V0Qm9keVBvcygpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIHNsb3BlIG9mIHRoZSBsaW5lIGluIHRoZSBmb3JtIG9mIGEgdmVjdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRWRnZUFyZWEucHJvdG90eXBlLmdldFNsb3BlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYmVnaW4gPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZEJlZ2luKCk7XHJcbiAgICAgICAgICAgIHZhciBlbmQgPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZEVuZCgpO1xyXG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBiZWdpbi5kaXN0YW5jZShlbmQpO1xyXG4gICAgICAgICAgICByZXR1cm4gZW5kLnN1YihiZWdpbikuc2NhbGUoMSAvIGRpc3RhbmNlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgbGluZSBzZWdtZW50IGluIHBpeGVsc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVkZ2VBcmVhLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBiZWdpbiA9IHRoaXMuX2dldFRyYW5zZm9ybWVkQmVnaW4oKTtcclxuICAgICAgICAgICAgdmFyIGVuZCA9IHRoaXMuX2dldFRyYW5zZm9ybWVkRW5kKCk7XHJcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IGJlZ2luLmRpc3RhbmNlKGVuZCk7XHJcbiAgICAgICAgICAgIHJldHVybiBkaXN0YW5jZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRlc3RzIGlmIGEgcG9pbnQgaXMgY29udGFpbmVkIGluIHRoaXMgY29sbGlzaW9uIGFyZWFcclxuICAgICAgICAgKi9cclxuICAgICAgICBFZGdlQXJlYS5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBpbmhlcml0ZG9jXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRWRnZUFyZWEucHJvdG90eXBlLnJheUNhc3QgPSBmdW5jdGlvbiAocmF5LCBtYXgpIHtcclxuICAgICAgICAgICAgaWYgKG1heCA9PT0gdm9pZCAwKSB7IG1heCA9IEluZmluaXR5OyB9XHJcbiAgICAgICAgICAgIHZhciBudW1lcmF0b3IgPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZEJlZ2luKCkuc3ViKHJheS5wb3MpO1xyXG4gICAgICAgICAgICAvLyBUZXN0IGlzIGxpbmUgYW5kIHJheSBhcmUgcGFyYWxsZWwgYW5kIG5vbiBpbnRlcnNlY3RpbmdcclxuICAgICAgICAgICAgaWYgKHJheS5kaXIuY3Jvc3ModGhpcy5nZXRTbG9wZSgpKSA9PT0gMCAmJiBudW1lcmF0b3IuY3Jvc3MocmF5LmRpcikgIT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIExpbmVzIGFyZSBwYXJhbGxlbFxyXG4gICAgICAgICAgICB2YXIgZGl2aXNvciA9IChyYXkuZGlyLmNyb3NzKHRoaXMuZ2V0U2xvcGUoKSkpO1xyXG4gICAgICAgICAgICBpZiAoZGl2aXNvciA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHQgPSBudW1lcmF0b3IuY3Jvc3ModGhpcy5nZXRTbG9wZSgpKSAvIGRpdmlzb3I7XHJcbiAgICAgICAgICAgIGlmICh0ID49IDAgJiYgdCA8PSBtYXgpIHtcclxuICAgICAgICAgICAgICAgIHZhciB1ID0gKG51bWVyYXRvci5jcm9zcyhyYXkuZGlyKSAvIGRpdmlzb3IpIC8gdGhpcy5nZXRMZW5ndGgoKTtcclxuICAgICAgICAgICAgICAgIGlmICh1ID49IDAgJiYgdSA8PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJheS5nZXRQb2ludCh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBpbmhlcml0ZG9jXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRWRnZUFyZWEucHJvdG90eXBlLmNvbGxpZGUgPSBmdW5jdGlvbiAoYXJlYSkge1xyXG4gICAgICAgICAgICBpZiAoYXJlYSBpbnN0YW5jZW9mIENpcmNsZUFyZWFfMi5DaXJjbGVBcmVhKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29sbGlzaW9uSnVtcFRhYmxlXzMuQ29sbGlzaW9uSnVtcFRhYmxlLkNvbGxpZGVDaXJjbGVFZGdlKGFyZWEsIHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGFyZWEgaW5zdGFuY2VvZiBQb2x5Z29uQXJlYV80LlBvbHlnb25BcmVhKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29sbGlzaW9uSnVtcFRhYmxlXzMuQ29sbGlzaW9uSnVtcFRhYmxlLkNvbGxpZGVQb2x5Z29uRWRnZShhcmVhLCB0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChhcmVhIGluc3RhbmNlb2YgRWRnZUFyZWEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDb2xsaXNpb25KdW1wVGFibGVfMy5Db2xsaXNpb25KdW1wVGFibGUuQ29sbGlkZUVkZ2VFZGdlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFZGdlIGNvdWxkIG5vdCBjb2xsaWRlIHdpdGggdW5rbm93biBJQ29sbGlzaW9uQXJlYSBcIiArIHR5cGVvZiBhcmVhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmluZCB0aGUgcG9pbnQgb24gdGhlIHNoYXBlIGZ1cnRoZXN0IGluIHRoZSBkaXJlY3Rpb24gc3BlY2lmaWVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRWRnZUFyZWEucHJvdG90eXBlLmdldEZ1cnRoZXN0UG9pbnQgPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZEJlZ2luID0gdGhpcy5fZ2V0VHJhbnNmb3JtZWRCZWdpbigpO1xyXG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWRFbmQgPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZEVuZCgpO1xyXG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uLmRvdCh0cmFuc2Zvcm1lZEJlZ2luKSA+IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZEJlZ2luO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkRW5kO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgdGhlIGF4aXMgYWxpZ25lZCBib3VuZGluZyBib3ggZm9yIHRoZSBjaXJjbGUgYXJlYVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVkZ2VBcmVhLnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZEJlZ2luID0gdGhpcy5fZ2V0VHJhbnNmb3JtZWRCZWdpbigpO1xyXG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWRFbmQgPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZEVuZCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJvdW5kaW5nQm94XzMuQm91bmRpbmdCb3goTWF0aC5taW4odHJhbnNmb3JtZWRCZWdpbi54LCB0cmFuc2Zvcm1lZEVuZC54KSwgTWF0aC5taW4odHJhbnNmb3JtZWRCZWdpbi55LCB0cmFuc2Zvcm1lZEVuZC55KSwgTWF0aC5tYXgodHJhbnNmb3JtZWRCZWdpbi54LCB0cmFuc2Zvcm1lZEVuZC54KSwgTWF0aC5tYXgodHJhbnNmb3JtZWRCZWdpbi55LCB0cmFuc2Zvcm1lZEVuZC55KSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgdGhlIGF4aXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBlZGdlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRWRnZUFyZWEucHJvdG90eXBlLmdldEF4ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5fZ2V0VHJhbnNmb3JtZWRFbmQoKS5zdWIodGhpcy5fZ2V0VHJhbnNmb3JtZWRCZWdpbigpKTtcclxuICAgICAgICAgICAgdmFyIGVkZ2VOb3JtYWwgPSBlLm5vcm1hbCgpO1xyXG4gICAgICAgICAgICB2YXIgYXhlcyA9IFtdO1xyXG4gICAgICAgICAgICBheGVzLnB1c2goZWRnZU5vcm1hbCk7XHJcbiAgICAgICAgICAgIGF4ZXMucHVzaChlZGdlTm9ybWFsLm5lZ2F0ZSgpKTtcclxuICAgICAgICAgICAgYXhlcy5wdXNoKGVkZ2VOb3JtYWwubm9ybWFsKCkpO1xyXG4gICAgICAgICAgICBheGVzLnB1c2goZWRnZU5vcm1hbC5ub3JtYWwoKS5uZWdhdGUoKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBheGVzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IHRoZSBtb21lbnQgb2YgaW5lcnRpYSBmb3IgYW4gZWRnZVxyXG4gICAgICAgICAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpc3Rfb2ZfbW9tZW50c19vZl9pbmVydGlhXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRWRnZUFyZWEucHJvdG90eXBlLmdldE1vbWVudE9mSW5lcnRpYSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG1hc3MgPSB0aGlzLmJvZHkgPyB0aGlzLmJvZHkubWFzcyA6IFBoeXNpY3NfNC5QaHlzaWNzLmRlZmF1bHRNYXNzO1xyXG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5lbmQuc3ViKHRoaXMuYmVnaW4pLmRpc3RhbmNlKCkgLyAyO1xyXG4gICAgICAgICAgICByZXR1cm4gbWFzcyAqIGxlbmd0aCAqIGxlbmd0aDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBpbmhlcml0ZG9jXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRWRnZUFyZWEucHJvdG90eXBlLnJlY2FsYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gZWRnZXMgZG9uJ3QgaGF2ZSBhbnkgY2FjaGVkIGRhdGFcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByb2plY3QgdGhlIGVkZ2UgYWxvbmcgYSBzcGVjaWZpZWQgYXhpc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVkZ2VBcmVhLnByb3RvdHlwZS5wcm9qZWN0ID0gZnVuY3Rpb24gKGF4aXMpIHtcclxuICAgICAgICAgICAgdmFyIHNjYWxhcnMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIHBvaW50cyA9IFt0aGlzLl9nZXRUcmFuc2Zvcm1lZEJlZ2luKCksIHRoaXMuX2dldFRyYW5zZm9ybWVkRW5kKCldO1xyXG4gICAgICAgICAgICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgc2NhbGFycy5wdXNoKHBvaW50c1tpXS5kb3QoYXhpcykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWxnZWJyYV84LlByb2plY3Rpb24oTWF0aC5taW4uYXBwbHkoTWF0aCwgc2NhbGFycyksIE1hdGgubWF4LmFwcGx5KE1hdGgsIHNjYWxhcnMpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgRWRnZUFyZWEucHJvdG90eXBlLmRlYnVnRHJhdyA9IGZ1bmN0aW9uIChjdHgsIGNvbG9yKSB7XHJcbiAgICAgICAgICAgIGlmIChjb2xvciA9PT0gdm9pZCAwKSB7IGNvbG9yID0gQ29sb3JfNC5Db2xvci5SZWQuY2xvbmUoKTsgfVxyXG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvci50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8odGhpcy5iZWdpbi54LCB0aGlzLmJlZ2luLnkpO1xyXG4gICAgICAgICAgICBjdHgubGluZVRvKHRoaXMuZW5kLngsIHRoaXMuZW5kLnkpO1xyXG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBFZGdlQXJlYTtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkVkZ2VBcmVhID0gRWRnZUFyZWE7XHJcbn0pO1xyXG5kZWZpbmUoXCJVdGlsL0RyYXdVdGlsXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiRHJhd2luZy9Db2xvclwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIENvbG9yXzUpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IGEgbGluZSBvbiBjYW52YXMgY29udGV4dFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggVGhlIGNhbnZhcyBjb250ZXh0XHJcbiAgICAgKiBAcGFyYW0gY29sb3IgVGhlIGNvbG9yIG9mIHRoZSBsaW5lXHJcbiAgICAgKiBAcGFyYW0geDEgVGhlIHN0YXJ0IHggY29vcmRpbmF0ZVxyXG4gICAgICogQHBhcmFtIHkxIFRoZSBzdGFydCB5IGNvb3JkaW5hdGVcclxuICAgICAqIEBwYXJhbSB4MiBUaGUgZW5kaW5nIHggY29vcmRpbmF0ZVxyXG4gICAgICogQHBhcmFtIHkyIFRoZSBlbmRpbmcgeSBjb29yZGluYXRlXHJcbiAgICAgKiBAcGFyYW0gdGhpY2tuZXNzIFRoZSBsaW5lIHRoaWNrbmVzc1xyXG4gICAgICogQHBhcmFtIGNhcCBUaGUgW1tMaW5lQ2FwU3R5bGVdXSAoYnV0dCwgcm91bmQsIG9yIHNxdWFyZSlcclxuICAgICAqL1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIGZ1bmN0aW9uIGxpbmUoY3R4LCBjb2xvciwgeDEsIHkxLCB4MiwgeTIsIHRoaWNrbmVzcywgY2FwKSB7XHJcbiAgICAgICAgaWYgKGNvbG9yID09PSB2b2lkIDApIHsgY29sb3IgPSBDb2xvcl81LkNvbG9yLlJlZC5jbG9uZSgpOyB9XHJcbiAgICAgICAgaWYgKHRoaWNrbmVzcyA9PT0gdm9pZCAwKSB7IHRoaWNrbmVzcyA9IDE7IH1cclxuICAgICAgICBpZiAoY2FwID09PSB2b2lkIDApIHsgY2FwID0gJ2J1dHQnOyB9XHJcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlja25lc3M7XHJcbiAgICAgICAgY3R4LmxpbmVDYXAgPSBjYXA7XHJcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3IudG9TdHJpbmcoKTtcclxuICAgICAgICBjdHgubW92ZVRvKHgxLCB5MSk7XHJcbiAgICAgICAgY3R4LmxpbmVUbyh4MiwgeTIpO1xyXG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLmxpbmUgPSBsaW5lO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IHRoZSB2ZWN0b3IgYXMgYSBwb2ludCBvbnRvIHRoZSBjYW52YXMuXHJcbiAgICAgKi9cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICBmdW5jdGlvbiBwb2ludChjdHgsIGNvbG9yLCBwb2ludCkge1xyXG4gICAgICAgIGlmIChjb2xvciA9PT0gdm9pZCAwKSB7IGNvbG9yID0gQ29sb3JfNS5Db2xvci5SZWQuY2xvbmUoKTsgfVxyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvci50b1N0cmluZygpO1xyXG4gICAgICAgIGN0eC5hcmMocG9pbnQueCwgcG9pbnQueSwgNSwgMCwgTWF0aC5QSSAqIDIpO1xyXG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLnBvaW50ID0gcG9pbnQ7XHJcbiAgICAvKipcclxuICAgICAqIERyYXcgdGhlIHZlY3RvciBhcyBhIGxpbmUgb250byB0aGUgY2FudmFzIHN0YXJ0aW5nIGEgb3JpZ2luIHBvaW50LlxyXG4gICAgICovXHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgZnVuY3Rpb24gdmVjdG9yKGN0eCwgY29sb3IsIG9yaWdpbiwgdmVjdG9yLCBzY2FsZSkge1xyXG4gICAgICAgIGlmIChzY2FsZSA9PT0gdm9pZCAwKSB7IHNjYWxlID0gMS4wOyB9XHJcbiAgICAgICAgdmFyIGMgPSBjb2xvciA/IGNvbG9yLnRvU3RyaW5nKCkgOiAnYmx1ZSc7XHJcbiAgICAgICAgdmFyIHYgPSB2ZWN0b3Iuc2NhbGUoc2NhbGUpO1xyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjO1xyXG4gICAgICAgIGN0eC5tb3ZlVG8ob3JpZ2luLngsIG9yaWdpbi55KTtcclxuICAgICAgICBjdHgubGluZVRvKG9yaWdpbi54ICsgdi54LCBvcmlnaW4ueSArIHYueSk7XHJcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgIH1cclxuICAgIGV4cG9ydHMudmVjdG9yID0gdmVjdG9yO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IGEgcm91bmQgcmVjdGFuZ2xlIG9uIGEgY2FudmFzIGNvbnRleHRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IFRoZSBjYW52YXMgY29udGV4dFxyXG4gICAgICogQHBhcmFtIHggVGhlIHRvcC1sZWZ0IHggY29vcmRpbmF0ZVxyXG4gICAgICogQHBhcmFtIHkgVGhlIHRvcC1sZWZ0IHkgY29vcmRpbmF0ZVxyXG4gICAgICogQHBhcmFtIHdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlXHJcbiAgICAgKiBAcGFyYW0gaGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxyXG4gICAgICogQHBhcmFtIHJhZGl1cyBUaGUgYm9yZGVyIHJhZGl1cyBvZiB0aGUgcmVjdGFuZ2xlXHJcbiAgICAgKiBAcGFyYW0gZmlsbCBUaGUgW1tDb2xvcl1dIHRvIGZpbGwgcmVjdGFuZ2xlIHdpdGhcclxuICAgICAqIEBwYXJhbSBzdHJva2UgVGhlIFtbQ29sb3JdXSB0byBzdHJva2UgcmVjdGFuZ2xlIHdpdGhcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcm91bmRSZWN0KGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzLCBzdHJva2UsIGZpbGwpIHtcclxuICAgICAgICBpZiAocmFkaXVzID09PSB2b2lkIDApIHsgcmFkaXVzID0gNTsgfVxyXG4gICAgICAgIGlmIChzdHJva2UgPT09IHZvaWQgMCkgeyBzdHJva2UgPSBDb2xvcl81LkNvbG9yLldoaXRlOyB9XHJcbiAgICAgICAgaWYgKGZpbGwgPT09IHZvaWQgMCkgeyBmaWxsID0gbnVsbDsgfVxyXG4gICAgICAgIHZhciBicjtcclxuICAgICAgICBpZiAodHlwZW9mIHJhZGl1cyA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgYnIgPSB7IHRsOiByYWRpdXMsIHRyOiByYWRpdXMsIGJyOiByYWRpdXMsIGJsOiByYWRpdXMgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBkZWZhdWx0UmFkaXVzID0geyB0bDogMCwgdHI6IDAsIGJyOiAwLCBibDogMCB9O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIGRlZmF1bHRSYWRpdXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0UmFkaXVzLmhhc093blByb3BlcnR5KHByb3ApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpZGUgPSBwcm9wO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyW3NpZGVdID0gcmFkaXVzW3NpZGVdIHx8IGRlZmF1bHRSYWRpdXNbc2lkZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIGN0eC5tb3ZlVG8oeCArIGJyLnRsLCB5KTtcclxuICAgICAgICBjdHgubGluZVRvKHggKyB3aWR0aCAtIGJyLnRyLCB5KTtcclxuICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIGJyLnRyKTtcclxuICAgICAgICBjdHgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIGJyLmJyKTtcclxuICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIGJyLmJyLCB5ICsgaGVpZ2h0KTtcclxuICAgICAgICBjdHgubGluZVRvKHggKyBici5ibCwgeSArIGhlaWdodCk7XHJcbiAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIGJyLmJsKTtcclxuICAgICAgICBjdHgubGluZVRvKHgsIHkgKyBici50bCk7XHJcbiAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIGJyLnRsLCB5KTtcclxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgaWYgKGZpbGwpIHtcclxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGwudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgY3R4LmZpbGwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0cm9rZSkge1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2UudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGV4cG9ydHMucm91bmRSZWN0ID0gcm91bmRSZWN0O1xyXG4gICAgZnVuY3Rpb24gY2lyY2xlKGN0eCwgeCwgeSwgcmFkaXVzLCBzdHJva2UsIGZpbGwpIHtcclxuICAgICAgICBpZiAoc3Ryb2tlID09PSB2b2lkIDApIHsgc3Ryb2tlID0gQ29sb3JfNS5Db2xvci5XaGl0ZTsgfVxyXG4gICAgICAgIGlmIChmaWxsID09PSB2b2lkIDApIHsgZmlsbCA9IG51bGw7IH1cclxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcclxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgaWYgKGZpbGwpIHtcclxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGwudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgY3R4LmZpbGwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0cm9rZSkge1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2UudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGV4cG9ydHMuY2lyY2xlID0gY2lyY2xlO1xyXG59KTtcclxuZGVmaW5lKFwiQ29sbGlzaW9uL0JvZHlcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJQaHlzaWNzXCIsIFwiQ29sbGlzaW9uL0VkZ2VBcmVhXCIsIFwiQ29sbGlzaW9uL0NpcmNsZUFyZWFcIiwgXCJDb2xsaXNpb24vUG9seWdvbkFyZWFcIiwgXCJDb2xsaXNpb24vUGFpclwiLCBcIkFsZ2VicmFcIiwgXCJEcmF3aW5nL0NvbG9yXCIsIFwiVXRpbC9EcmF3VXRpbFwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIFBoeXNpY3NfNSwgRWRnZUFyZWFfMywgQ2lyY2xlQXJlYV8zLCBQb2x5Z29uQXJlYV81LCBQYWlyXzEsIEFsZ2VicmFfOSwgQ29sb3JfNiwgRHJhd1V0aWwpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgdmFyIEJvZHkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgcGh5c2ljcyBib2R5IGFzc29jaWF0ZWQgd2l0aCBhbiBhY3RvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIEJvZHkoYWN0b3IpIHtcclxuICAgICAgICAgICAgdGhpcy5hY3RvciA9IGFjdG9yO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogW1tJQ29sbGlzaW9uQXJlYXxDb2xsaXNpb24gYXJlYV1dIG9mIHRoaXMgcGh5c2ljcyBib2R5LCBkZWZpbmVzIHRoZSBzaGFwZSBmb3IgcmlnaWQgYm9keSBjb2xsaXNpb25cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uQXJlYSA9IG51bGw7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgKHgsIHkpIHBvc2l0aW9uIG9mIHRoZSBhY3RvciB0aGlzIHdpbGwgYmUgaW4gdGhlIG1pZGRsZSBvZiB0aGUgYWN0b3IgaWYgdGhlXHJcbiAgICAgICAgICAgICAqIFtbQWN0b3IuYW5jaG9yXV0gaXMgc2V0IHRvICgwLjUsIDAuNSkgd2hpY2ggaXMgZGVmYXVsdC5cclxuICAgICAgICAgICAgICogSWYgeW91IHdhbnQgdGhlICh4LCB5KSBwb3NpdGlvbiB0byBiZSB0aGUgdG9wIGxlZnQgb2YgdGhlIGFjdG9yIHNwZWNpZnkgYW4gYW5jaG9yIG9mICgwLCAwKS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMucG9zID0gbmV3IEFsZ2VicmFfOS5WZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgcG9zaXRpb24gb2YgdGhlIGFjdG9yIGxhc3QgZnJhbWUgKHgsIHkpIGluIHBpeGVsc1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5vbGRQb3MgPSBuZXcgQWxnZWJyYV85LlZlY3RvcigwLCAwKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBjdXJyZW50IHZlbG9jaXR5IHZlY3RvciAodngsIHZ5KSBvZiB0aGUgYWN0b3IgaW4gcGl4ZWxzL3NlY29uZFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy52ZWwgPSBuZXcgQWxnZWJyYV85LlZlY3RvcigwLCAwKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSB2ZWxvY2l0eSBvZiB0aGUgYWN0b3IgbGFzdCBmcmFtZSAodngsIHZ5KSBpbiBwaXhlbHMvc2Vjb25kXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLm9sZFZlbCA9IG5ldyBBbGdlYnJhXzkuVmVjdG9yKDAsIDApO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGN1cnJldCBhY2NlbGVyYXRpb24gdmVjdG9yIChheCwgYXkpIG9mIHRoZSBhY3RvciBpbiBwaXhlbHMvc2Vjb25kL3NlY29uZC4gQW4gYWNjZWxlcmF0aW9uIHBvaW50aW5nIGRvd24gc3VjaCBhcyAoMCwgMTAwKSBtYXlcclxuICAgICAgICAgICAgICogYmUgdXNlZnVsIHRvIHNpbXVsYXRlIGEgZ3Jhdml0YXRpb25hbCBlZmZlY3QuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmFjYyA9IG5ldyBBbGdlYnJhXzkuVmVjdG9yKDAsIDApO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGN1cnJlbnQgdG9ycXVlIGFwcGxpZWQgdG8gdGhlIGFjdG9yXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnRvcnF1ZSA9IDA7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgY3VycmVudCBtYXNzIG9mIHRoZSBhY3RvciwgbWFzcyBjYW4gYmUgdGhvdWdodCBvZiBhcyB0aGUgcmVzaXN0YW5jZSB0byBhY2NlbGVyYXRpb24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLm1hc3MgPSAxLjA7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgY3VycmVudCBtb21lbnQgb2YgaW5lcnRpYSwgbW9pIGNhbiBiZSB0aG91Z2h0IG9mIGFzIHRoZSByZXNpc3RhbmNlIHRvIHJvdGF0aW9uLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5tb2kgPSAxMDAwO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGN1cnJlbnQgXCJtb3Rpb25cIiBvZiB0aGUgYWN0b3IsIHVzZWQgdG8gY2FsY3VsYXRlZCBzbGVlcCBpbiB0aGUgcGh5c2ljcyBzaW11bGF0aW9uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLm1vdGlvbiA9IDEwO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGNvZWZmaWNpZW50IG9mIGZyaWN0aW9uIG9uIHRoaXMgYWN0b3JcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuZnJpY3Rpb24gPSAuOTk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgY29lZmZpY2llbnQgb2YgcmVzdGl0dXRpb24gb2YgdGhpcyBhY3RvciwgcmVwcmVzZW50cyB0aGUgYW1vdW50IG9mIGVuZXJneSBwcmVzZXJ2ZWQgYWZ0ZXIgY29sbGlzaW9uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnJlc3RpdHV0aW9uID0gLjI7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgcm90YXRpb24gb2YgdGhlIGFjdG9yIGluIHJhZGlhbnNcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMucm90YXRpb24gPSAwOyAvLyByYWRpYW5zXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgcm90YXRpb25hbCB2ZWxvY2l0eSBvZiB0aGUgYWN0b3IgaW4gcmFkaWFucy9zZWNvbmRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMucnggPSAwOyAvL3JhZGlhbnMvc2VjXHJcbiAgICAgICAgICAgIHRoaXMuX3RvdGFsTXR2ID0gQWxnZWJyYV85LlZlY3Rvci5aZXJvLmNsb25lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZCBtaW5pbXVtIHRyYW5zbGF0aW9uIHZlY3RvcnMgYWNjdW11bGF0ZWQgZHVyaW5nIHRoZSBjdXJyZW50IGZyYW1lIHRvIHJlc29sdmUgY29sbGlzaW9ucy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBCb2R5LnByb3RvdHlwZS5hZGRNdHYgPSBmdW5jdGlvbiAobXR2KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RvdGFsTXR2LmFkZEVxdWFsKG10dik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcHBsaWVzIHRoZSBhY2N1bXVsYXRlZCB0cmFuc2xhdGlvbiB2ZWN0b3JzIHRvIHRoZSBhY3RvcnMgcG9zaXRpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBCb2R5LnByb3RvdHlwZS5hcHBseU10diA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5wb3MuYWRkRXF1YWwodGhpcy5fdG90YWxNdHYpO1xyXG4gICAgICAgICAgICB0aGlzLl90b3RhbE10di5zZXRUbygwLCAwKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIGJvZHkncyBbW0JvdW5kaW5nQm94XV0gY2FsY3VsYXRlZCBmb3IgdGhpcyBpbnN0YW50IGluIHdvcmxkIHNwYWNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJvZHkucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKFBoeXNpY3NfNS5QaHlzaWNzLmNvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneSA9PT0gUGh5c2ljc181LkNvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneS5Cb3gpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdG9yLmdldEJvdW5kcygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sbGlzaW9uQXJlYS5nZXRCb3VuZHMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgYWN0b3IncyBbW0JvdW5kaW5nQm94XV0gcmVsYXRpdmUgdG8gdGhlIGFjdG9ycyBwb3NpdGlvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBCb2R5LnByb3RvdHlwZS5nZXRSZWxhdGl2ZUJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKFBoeXNpY3NfNS5QaHlzaWNzLmNvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneSA9PT0gUGh5c2ljc181LkNvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneS5Cb3gpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdG9yLmdldFJlbGF0aXZlQm91bmRzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hY3Rvci5nZXRSZWxhdGl2ZUJvdW5kcygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGVzIHRoZSBjb2xsaXNpb24gYXJlYSBnZW9tZXRyeSBhbmQgaW50ZXJuYWwgY2FjaGVzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQm9keS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb2xsaXNpb25BcmVhKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbGxpc2lvbkFyZWEucmVjYWxjKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdXAgYSBib3ggY29sbGlzaW9uIGFyZWEgYmFzZWQgb24gdGhlIGN1cnJlbnQgYm91bmRzIG9mIHRoZSBhc3NvY2lhdGVkIGFjdG9yIG9mIHRoaXMgcGh5c2ljcyBib2R5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQnkgZGVmYXVsdCwgdGhlIGJveCBpcyBjZW50ZXIgaXMgYXQgKDAsIDApIHdoaWNoIG1lYW5zIGl0IGlzIGNlbnRlcmVkIGFyb3VuZCB0aGUgYWN0b3JzIGFuY2hvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBCb2R5LnByb3RvdHlwZS51c2VCb3hDb2xsaXNpb24gPSBmdW5jdGlvbiAoY2VudGVyKSB7XHJcbiAgICAgICAgICAgIGlmIChjZW50ZXIgPT09IHZvaWQgMCkgeyBjZW50ZXIgPSBBbGdlYnJhXzkuVmVjdG9yLlplcm8uY2xvbmUoKTsgfVxyXG4gICAgICAgICAgICB0aGlzLmNvbGxpc2lvbkFyZWEgPSBuZXcgUG9seWdvbkFyZWFfNS5Qb2x5Z29uQXJlYSh7XHJcbiAgICAgICAgICAgICAgICBib2R5OiB0aGlzLFxyXG4gICAgICAgICAgICAgICAgcG9pbnRzOiB0aGlzLmFjdG9yLmdldFJlbGF0aXZlQm91bmRzKCkuZ2V0UG9pbnRzKCksXHJcbiAgICAgICAgICAgICAgICBwb3M6IGNlbnRlciAvLyBwb3NpdGlvbiByZWxhdGl2ZSB0byBhY3RvclxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gaW4gY2FzZSBvZiBhIG5hbiBtb2ksIGNvYWxlc2NlIHRvIGEgc2FmZSBkZWZhdWx0XHJcbiAgICAgICAgICAgIHRoaXMubW9pID0gdGhpcy5jb2xsaXNpb25BcmVhLmdldE1vbWVudE9mSW5lcnRpYSgpIHx8IHRoaXMubW9pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB1cCBhIHBvbHlnb24gY29sbGlzaW9uIGFyZWEgYmFzZWQgb24gYSBsaXN0IG9mIG9mIHBvaW50cyByZWxhdGl2ZSB0byB0aGUgYW5jaG9yIG9mIHRoZSBhc3NvY2lhdGVkIGFjdG9yIG9mIHRoaXMgcGh5c2ljcyBib2R5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogT25seSBbY29udmV4IHBvbHlnb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbnZleF9wb2x5Z29uKSBkZWZpbml0aW9ucyBhcmUgc3VwcG9ydGVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQnkgZGVmYXVsdCwgdGhlIGJveCBpcyBjZW50ZXIgaXMgYXQgKDAsIDApIHdoaWNoIG1lYW5zIGl0IGlzIGNlbnRlcmVkIGFyb3VuZCB0aGUgYWN0b3JzIGFuY2hvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBCb2R5LnByb3RvdHlwZS51c2VQb2x5Z29uQ29sbGlzaW9uID0gZnVuY3Rpb24gKHBvaW50cywgY2VudGVyKSB7XHJcbiAgICAgICAgICAgIGlmIChjZW50ZXIgPT09IHZvaWQgMCkgeyBjZW50ZXIgPSBBbGdlYnJhXzkuVmVjdG9yLlplcm8uY2xvbmUoKTsgfVxyXG4gICAgICAgICAgICB0aGlzLmNvbGxpc2lvbkFyZWEgPSBuZXcgUG9seWdvbkFyZWFfNS5Qb2x5Z29uQXJlYSh7XHJcbiAgICAgICAgICAgICAgICBib2R5OiB0aGlzLFxyXG4gICAgICAgICAgICAgICAgcG9pbnRzOiBwb2ludHMsXHJcbiAgICAgICAgICAgICAgICBwb3M6IGNlbnRlciAvLyBwb3NpdGlvbiByZWxhdGl2ZSB0byBhY3RvclxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gaW4gY2FzZSBvZiBhIG5hbiBtb2ksIGNvbGxlc2NlIHRvIGEgc2FmZSBkZWZhdWx0XHJcbiAgICAgICAgICAgIHRoaXMubW9pID0gdGhpcy5jb2xsaXNpb25BcmVhLmdldE1vbWVudE9mSW5lcnRpYSgpIHx8IHRoaXMubW9pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB1cCBhIFtbQ2lyY2xlQXJlYXxjaXJjbGUgY29sbGlzaW9uIGFyZWFdXSB3aXRoIGEgc3BlY2lmaWVkIHJhZGl1cyBpbiBwaXhlbHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBCeSBkZWZhdWx0LCB0aGUgYm94IGlzIGNlbnRlciBpcyBhdCAoMCwgMCkgd2hpY2ggbWVhbnMgaXQgaXMgY2VudGVyZWQgYXJvdW5kIHRoZSBhY3RvcnMgYW5jaG9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJvZHkucHJvdG90eXBlLnVzZUNpcmNsZUNvbGxpc2lvbiA9IGZ1bmN0aW9uIChyYWRpdXMsIGNlbnRlcikge1xyXG4gICAgICAgICAgICBpZiAoY2VudGVyID09PSB2b2lkIDApIHsgY2VudGVyID0gQWxnZWJyYV85LlZlY3Rvci5aZXJvLmNsb25lKCk7IH1cclxuICAgICAgICAgICAgaWYgKCFyYWRpdXMpIHtcclxuICAgICAgICAgICAgICAgIHJhZGl1cyA9IHRoaXMuYWN0b3IuZ2V0V2lkdGgoKSAvIDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25BcmVhID0gbmV3IENpcmNsZUFyZWFfMy5DaXJjbGVBcmVhKHtcclxuICAgICAgICAgICAgICAgIGJvZHk6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICByYWRpdXM6IHJhZGl1cyxcclxuICAgICAgICAgICAgICAgIHBvczogY2VudGVyXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLm1vaSA9IHRoaXMuY29sbGlzaW9uQXJlYS5nZXRNb21lbnRPZkluZXJ0aWEoKSB8fCB0aGlzLm1vaTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdXAgYW4gW1tFZGdlQXJlYXxlZGdlIGNvbGxpc2lvbl1dIHdpdGggYSBzdGFydCBwb2ludCBhbmQgYW4gZW5kIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBhbmNob3Igb2YgdGhlIGFzc29jaWF0ZWQgYWN0b3JcclxuICAgICAgICAgKiBvZiB0aGlzIHBoeXNpY3MgYm9keS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEJ5IGRlZmF1bHQsIHRoZSBib3ggaXMgY2VudGVyIGlzIGF0ICgwLCAwKSB3aGljaCBtZWFucyBpdCBpcyBjZW50ZXJlZCBhcm91bmQgdGhlIGFjdG9ycyBhbmNob3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQm9keS5wcm90b3R5cGUudXNlRWRnZUNvbGxpc2lvbiA9IGZ1bmN0aW9uIChiZWdpbiwgZW5kKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uQXJlYSA9IG5ldyBFZGdlQXJlYV8zLkVkZ2VBcmVhKHtcclxuICAgICAgICAgICAgICAgIGJlZ2luOiBiZWdpbixcclxuICAgICAgICAgICAgICAgIGVuZDogZW5kLFxyXG4gICAgICAgICAgICAgICAgYm9keTogdGhpc1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5tb2kgPSB0aGlzLmNvbGxpc2lvbkFyZWEuZ2V0TW9tZW50T2ZJbmVydGlhKCkgfHwgdGhpcy5tb2k7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIEJvZHkucHJvdG90eXBlLmRlYnVnRHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICAgICAgICAgICAgLy8gRHJhdyBtb3Rpb24gdmVjdG9yc1xyXG4gICAgICAgICAgICBpZiAoUGh5c2ljc181LlBoeXNpY3Muc2hvd01vdGlvblZlY3RvcnMpIHtcclxuICAgICAgICAgICAgICAgIERyYXdVdGlsLnZlY3RvcihjdHgsIENvbG9yXzYuQ29sb3IuWWVsbG93LCB0aGlzLnBvcywgKHRoaXMuYWNjLmFkZChQaHlzaWNzXzUuUGh5c2ljcy5hY2MpKSk7XHJcbiAgICAgICAgICAgICAgICBEcmF3VXRpbC52ZWN0b3IoY3R4LCBDb2xvcl82LkNvbG9yLlJlZCwgdGhpcy5wb3MsICh0aGlzLnZlbCkpO1xyXG4gICAgICAgICAgICAgICAgRHJhd1V0aWwucG9pbnQoY3R4LCBDb2xvcl82LkNvbG9yLlJlZCwgdGhpcy5wb3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChQaHlzaWNzXzUuUGh5c2ljcy5zaG93Qm91bmRzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdldEJvdW5kcygpLmRlYnVnRHJhdyhjdHgsIENvbG9yXzYuQ29sb3IuWWVsbG93KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoUGh5c2ljc181LlBoeXNpY3Muc2hvd0FyZWEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uQXJlYS5kZWJ1Z0RyYXcoY3R4LCBDb2xvcl82LkNvbG9yLkdyZWVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoaXMgYm9keSBjb2xsaWRlZCB3aXRoXHJcbiAgICAgICAgICogb3Igd2FzIGluIHN0YXRpb25hcnkgY29udGFjdCB3aXRoXHJcbiAgICAgICAgICogdGhlIGJvZHkgb2YgdGhlIG90aGVyIFtbQWN0b3JdXVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJvZHkucHJvdG90eXBlLnRvdWNoaW5nID0gZnVuY3Rpb24gKG90aGVyKSB7XHJcbiAgICAgICAgICAgIHZhciBwYWlyID0gbmV3IFBhaXJfMS5QYWlyKHRoaXMsIG90aGVyLmJvZHkpO1xyXG4gICAgICAgICAgICBwYWlyLmNvbGxpZGUoKTtcclxuICAgICAgICAgICAgaWYgKHBhaXIuY29sbGlzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gQm9keTtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkJvZHkgPSBCb2R5O1xyXG59KTtcclxuZGVmaW5lKFwiQ29sbGlzaW9uL1BhaXJcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJQaHlzaWNzXCIsIFwiRHJhd2luZy9Db2xvclwiLCBcIkFjdG9yXCIsIFwiVXRpbC9EcmF3VXRpbFwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIFBoeXNpY3NfNiwgQ29sb3JfNywgQWN0b3JfMiwgRHJhd1V0aWwpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBNb2RlbHMgYSBwb3RlbnRpYWwgY29sbGlzaW9uIGJldHdlZW4gMiBib2RpZXNcclxuICAgICAqL1xyXG4gICAgdmFyIFBhaXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIFBhaXIoYm9keUEsIGJvZHlCKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYm9keUEgPSBib2R5QTtcclxuICAgICAgICAgICAgdGhpcy5ib2R5QiA9IGJvZHlCO1xyXG4gICAgICAgICAgICB0aGlzLmlkID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5jb2xsaXNpb24gPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmlkID0gUGFpci5jYWxjdWxhdGVQYWlySGFzaChib2R5QSwgYm9keUIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGFpci5wcm90b3R5cGUsIFwiY2FuQ29sbGlkZVwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGl0IGlzIHBvc3NpYmxlIGZvciB0aGUgcGFpcnMgdG8gY29sbGlkZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWN0b3JBID0gdGhpcy5ib2R5QS5hY3RvcjtcclxuICAgICAgICAgICAgICAgIHZhciBhY3RvckIgPSB0aGlzLmJvZHlCLmFjdG9yO1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgYm90aCBhcmUgZml4ZWQgc2hvcnQgY2lyY3VpdFxyXG4gICAgICAgICAgICAgICAgaWYgKGFjdG9yQS5jb2xsaXNpb25UeXBlID09PSBBY3Rvcl8yLkNvbGxpc2lvblR5cGUuRml4ZWQgJiYgYWN0b3JCLmNvbGxpc2lvblR5cGUgPT09IEFjdG9yXzIuQ29sbGlzaW9uVHlwZS5GaXhlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBvdGhlciBpcyBwcmV2ZW50IGNvbGxpc2lvbiBvciBpcyBkZWFkIHNob3J0IGNpcmN1aXRcclxuICAgICAgICAgICAgICAgIGlmIChhY3RvckIuY29sbGlzaW9uVHlwZSA9PT0gQWN0b3JfMi5Db2xsaXNpb25UeXBlLlByZXZlbnRDb2xsaXNpb24gfHwgYWN0b3JCLmlzS2lsbGVkKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUnVucyB0aGUgY29sbGlzb24gaW50ZXJzZWN0aW9uIGxvZ2ljIG9uIHRoZSBtZW1iZXJzIG9mIHRoaXMgcGFpclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBhaXIucHJvdG90eXBlLmNvbGxpZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uID0gdGhpcy5ib2R5QS5jb2xsaXNpb25BcmVhLmNvbGxpZGUodGhpcy5ib2R5Qi5jb2xsaXNpb25BcmVhKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlc292bGVzIHRoZSBjb2xsaXNpb24gYm9keSBwb3NpdGlvbiBhbmQgdmVsb2NpdHkgaWYgYSBjb2xsaXNpb24gb2NjdXJlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBhaXIucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAoc3RyYXRlZ3kpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29sbGlzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbGxpc2lvbi5yZXNvbHZlKHN0cmF0ZWd5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgdW5pcXVlIHBhaXIgaGFzaCBpZCBmb3IgdGhpcyBjb2xsaXNpb24gcGFpclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBhaXIuY2FsY3VsYXRlUGFpckhhc2ggPSBmdW5jdGlvbiAoYm9keUEsIGJvZHlCKSB7XHJcbiAgICAgICAgICAgIGlmIChib2R5QS5hY3Rvci5pZCA8IGJvZHlCLmFjdG9yLmlkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCIjXCIgKyBib2R5QS5hY3Rvci5pZCArIFwiK1wiICsgYm9keUIuYWN0b3IuaWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCIjXCIgKyBib2R5Qi5hY3Rvci5pZCArIFwiK1wiICsgYm9keUEuYWN0b3IuaWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgUGFpci5wcm90b3R5cGUuZGVidWdEcmF3ID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb2xsaXNpb24pIHtcclxuICAgICAgICAgICAgICAgIGlmIChQaHlzaWNzXzYuUGh5c2ljcy5zaG93Q29udGFjdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBEcmF3VXRpbC5wb2ludChjdHgsIENvbG9yXzcuQ29sb3IuUmVkLCB0aGlzLmNvbGxpc2lvbi5wb2ludCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoUGh5c2ljc182LlBoeXNpY3Muc2hvd0NvbGxpc2lvbk5vcm1hbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBEcmF3VXRpbC52ZWN0b3IoY3R4LCBDb2xvcl83LkNvbG9yLkN5YW4sIHRoaXMuY29sbGlzaW9uLnBvaW50LCB0aGlzLmNvbGxpc2lvbi5ub3JtYWwsIDMwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFBhaXI7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5QYWlyID0gUGFpcjtcclxufSk7XHJcbmRlZmluZShcIkRlYnVnXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIERlYnVnIHN0YXRpc3RpY3MgYW5kIGZsYWdzIGZvciBFeGNhbGlidXIuIElmIHBvbGxpbmcgdGhlc2UgdmFsdWVzLCBpdCB3b3VsZCBiZVxyXG4gICAgICogYmVzdCB0byBkbyBzbyBvbiB0aGUgYHBvc3R1cGRhdGVgIGV2ZW50IGZvciBbW0VuZ2luZV1dLCBhZnRlciBhbGwgdmFsdWVzIGhhdmUgYmVlblxyXG4gICAgICogdXBkYXRlZCBkdXJpbmcgYSBmcmFtZS5cclxuICAgICAqL1xyXG4gICAgdmFyIERlYnVnID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBEZWJ1ZygpIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFBlcmZvcm1hbmNlIHN0YXRpc3RpY3NcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuc3RhdHMgPSB7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEN1cnJlbnQgZnJhbWUgc3RhdGlzdGljcy4gRW5naW5lIHJldXNlcyB0aGlzIGluc3RhbmNlLCB1c2UgW1tGcmFtZVN0YXRzLmNsb25lXV0gdG8gY29weSBmcmFtZSBzdGF0cy5cclxuICAgICAgICAgICAgICAgICAqIEJlc3QgYWNjZXNzZWQgb24gW1twb3N0ZnJhbWVdXSBldmVudC4gU2VlIFtbSUZyYW1lU3RhdHNdXVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBjdXJyRnJhbWU6IG5ldyBGcmFtZVN0YXRzKCksXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFByZXZpb3VzIGZyYW1lIHN0YXRpc3RpY3MuIEVuZ2luZSByZXVzZXMgdGhpcyBpbnN0YW5jZSwgdXNlIFtbRnJhbWVTdGF0cy5jbG9uZV1dIHRvIGNvcHkgZnJhbWUgc3RhdHMuXHJcbiAgICAgICAgICAgICAgICAgKiBCZXN0IGFjY2Vzc2VkIG9uIFtbcHJlZnJhbWVdXSBldmVudC4gQmVzdCBpbnNwZWN0ZWQgb24gZW5naW5lIGV2ZW50IGBwcmVmcmFtZWAuIFNlZSBbW0lGcmFtZVN0YXRzXV1cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgcHJldkZyYW1lOiBuZXcgRnJhbWVTdGF0cygpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBEZWJ1ZztcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkRlYnVnID0gRGVidWc7XHJcbiAgICAvKipcclxuICAgICAqIEltcGxlbWVudGF0aW9uIG9mIGEgZnJhbWUncyBzdGF0cy4gTWVhbnQgdG8gaGF2ZSB2YWx1ZXMgY29waWVkIHZpYSBbW0ZyYW1lU3RhdHMucmVzZXRdXSwgYXZvaWRcclxuICAgICAqIGNyZWF0aW5nIGluc3RhbmNlcyBvZiB0aGlzIGV2ZXJ5IGZyYW1lLlxyXG4gICAgICovXHJcbiAgICB2YXIgRnJhbWVTdGF0cyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gRnJhbWVTdGF0cygpIHtcclxuICAgICAgICAgICAgdGhpcy5faWQgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9kZWx0YSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZwcyA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yU3RhdHMgPSB7XHJcbiAgICAgICAgICAgICAgICBhbGl2ZTogMCxcclxuICAgICAgICAgICAgICAgIGtpbGxlZDogMCxcclxuICAgICAgICAgICAgICAgIHVpOiAwLFxyXG4gICAgICAgICAgICAgICAgZ2V0IHJlbWFpbmluZygpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hbGl2ZSAtIHRoaXMua2lsbGVkO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGdldCB0b3RhbCgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1haW5pbmcgKyB0aGlzLnVpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLl9kdXJhdGlvblN0YXRzID0ge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlOiAwLFxyXG4gICAgICAgICAgICAgICAgZHJhdzogMCxcclxuICAgICAgICAgICAgICAgIGdldCB0b3RhbCgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUgKyB0aGlzLmRyYXc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuX3BoeXNpY3NTdGF0cyA9IG5ldyBQaHlzaWNzU3RhdHMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogWmVybyBvdXQgdmFsdWVzIG9yIGNsb25lIG90aGVyIElGcmFtZVN0YXQgc3RhdHMuIEFsbG93cyBpbnN0YW5jZSByZXVzZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBbb3RoZXJTdGF0c10gT3B0aW9uYWwgc3RhdHMgdG8gY2xvbmVcclxuICAgICAgICAgKi9cclxuICAgICAgICBGcmFtZVN0YXRzLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIChvdGhlclN0YXRzKSB7XHJcbiAgICAgICAgICAgIGlmIChvdGhlclN0YXRzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlkID0gb3RoZXJTdGF0cy5pZDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVsdGEgPSBvdGhlclN0YXRzLmRlbHRhO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcHMgPSBvdGhlclN0YXRzLmZwcztcclxuICAgICAgICAgICAgICAgIHRoaXMuYWN0b3JzLmFsaXZlID0gb3RoZXJTdGF0cy5hY3RvcnMuYWxpdmU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFjdG9ycy5raWxsZWQgPSBvdGhlclN0YXRzLmFjdG9ycy5raWxsZWQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFjdG9ycy51aSA9IG90aGVyU3RhdHMuYWN0b3JzLnVpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kdXJhdGlvbi51cGRhdGUgPSBvdGhlclN0YXRzLmR1cmF0aW9uLnVwZGF0ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZHVyYXRpb24uZHJhdyA9IG90aGVyU3RhdHMuZHVyYXRpb24uZHJhdztcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BoeXNpY3NTdGF0cy5yZXNldChvdGhlclN0YXRzLnBoeXNpY3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pZCA9IHRoaXMuZGVsdGEgPSB0aGlzLmZwcyA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFjdG9ycy5hbGl2ZSA9IHRoaXMuYWN0b3JzLmtpbGxlZCA9IHRoaXMuYWN0b3JzLnVpID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZHVyYXRpb24udXBkYXRlID0gdGhpcy5kdXJhdGlvbi5kcmF3ID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BoeXNpY3NTdGF0cy5yZXNldCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcm92aWRlcyBhIGNsb25lIG9mIHRoaXMgaW5zdGFuY2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRnJhbWVTdGF0cy5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBmcyA9IG5ldyBGcmFtZVN0YXRzKCk7XHJcbiAgICAgICAgICAgIGZzLnJlc2V0KHRoaXMpO1xyXG4gICAgICAgICAgICByZXR1cm4gZnM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnJhbWVTdGF0cy5wcm90b3R5cGUsIFwiaWRcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgZnJhbWUncyBpZFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faWQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXRzIHRoZSBmcmFtZSdzIGlkXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faWQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZyYW1lU3RhdHMucHJvdG90eXBlLCBcImRlbHRhXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIGZyYW1lJ3MgZGVsdGEgKHRpbWUgc2luY2UgbGFzdCBmcmFtZSlcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlbHRhO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0cyB0aGUgZnJhbWUncyBkZWx0YSAodGltZSBzaW5jZSBsYXN0IGZyYW1lKS4gSW50ZXJuYWwgdXNlIG9ubHkuXHJcbiAgICAgICAgICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RlbHRhID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGcmFtZVN0YXRzLnByb3RvdHlwZSwgXCJmcHNcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgZnJhbWUncyBmcmFtZXMtcGVyLXNlY29uZCAoRlBTKVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZnBzO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0cyB0aGUgZnJhbWUncyBmcmFtZXMtcGVyLXNlY29uZCAoRlBTKS4gSW50ZXJuYWwgdXNlIG9ubHkuXHJcbiAgICAgICAgICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZwcyA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnJhbWVTdGF0cy5wcm90b3R5cGUsIFwiYWN0b3JzXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIGZyYW1lJ3MgYWN0b3Igc3RhdGlzdGljc1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYWN0b3JTdGF0cztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZyYW1lU3RhdHMucHJvdG90eXBlLCBcImR1cmF0aW9uXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIGZyYW1lJ3MgZHVyYXRpb24gc3RhdGlzdGljc1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZHVyYXRpb25TdGF0cztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZyYW1lU3RhdHMucHJvdG90eXBlLCBcInBoeXNpY3NcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgZnJhbWUncyBwaHlzaWNzIHN0YXRpc3RpY3NcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BoeXNpY3NTdGF0cztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIEZyYW1lU3RhdHM7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5GcmFtZVN0YXRzID0gRnJhbWVTdGF0cztcclxuICAgIHZhciBQaHlzaWNzU3RhdHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIFBoeXNpY3NTdGF0cygpIHtcclxuICAgICAgICAgICAgdGhpcy5fcGFpcnMgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9jb2xsaXNpb25zID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fY29sbGlkZXJzSGFzaCA9IHt9O1xyXG4gICAgICAgICAgICB0aGlzLl9mYXN0Qm9kaWVzID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fZmFzdEJvZHlDb2xsaXNpb25zID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fYnJvYWRwaGFzZSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX25hcnJvd3BoYXNlID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogWmVybyBvdXQgdmFsdWVzIG9yIGNsb25lIG90aGVyIElQaHlzaWNzU3RhdHMgc3RhdHMuIEFsbG93cyBpbnN0YW5jZSByZXVzZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBbb3RoZXJTdGF0c10gT3B0aW9uYWwgc3RhdHMgdG8gY2xvbmVcclxuICAgICAgICAgKi9cclxuICAgICAgICBQaHlzaWNzU3RhdHMucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKG90aGVyU3RhdHMpIHtcclxuICAgICAgICAgICAgaWYgKG90aGVyU3RhdHMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFpcnMgPSBvdGhlclN0YXRzLnBhaXJzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25zID0gb3RoZXJTdGF0cy5jb2xsaXNpb25zO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsaWRlcnNIYXNoID0gb3RoZXJTdGF0cy5jb2xsaWRlcnNIYXNoO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mYXN0Qm9kaWVzID0gb3RoZXJTdGF0cy5mYXN0Qm9kaWVzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mYXN0Qm9keUNvbGxpc2lvbnMgPSBvdGhlclN0YXRzLmZhc3RCb2R5Q29sbGlzaW9ucztcclxuICAgICAgICAgICAgICAgIHRoaXMuYnJvYWRwaGFzZSA9IG90aGVyU3RhdHMuYnJvYWRwaGFzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMubmFycm93cGhhc2UgPSBvdGhlclN0YXRzLm5hcnJvd3BoYXNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYWlycyA9IHRoaXMuY29sbGlzaW9ucyA9IHRoaXMuZmFzdEJvZGllcyA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZhc3RCb2R5Q29sbGlzaW9ucyA9IHRoaXMuYnJvYWRwaGFzZSA9IHRoaXMubmFycm93cGhhc2UgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsaWRlcnNIYXNoID0ge307XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByb3ZpZGVzIGEgY2xvbmUgb2YgdGhpcyBpbnN0YW5jZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQaHlzaWNzU3RhdHMucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcHMgPSBuZXcgUGh5c2ljc1N0YXRzKCk7XHJcbiAgICAgICAgICAgIHBzLnJlc2V0KHRoaXMpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGh5c2ljc1N0YXRzLnByb3RvdHlwZSwgXCJwYWlyc1wiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhaXJzO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGFpcnMgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBoeXNpY3NTdGF0cy5wcm90b3R5cGUsIFwiY29sbGlzaW9uc1wiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbGxpc2lvbnM7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xsaXNpb25zID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQaHlzaWNzU3RhdHMucHJvdG90eXBlLCBcImNvbGxpZGVyc0hhc2hcIiwge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2xsaWRlcnNIYXNoO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChjb2xsaWRlcnMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxpZGVyc0hhc2ggPSBjb2xsaWRlcnM7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQaHlzaWNzU3RhdHMucHJvdG90eXBlLCBcImZhc3RCb2RpZXNcIiwge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9mYXN0Qm9kaWVzO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZmFzdEJvZGllcyA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGh5c2ljc1N0YXRzLnByb3RvdHlwZSwgXCJmYXN0Qm9keUNvbGxpc2lvbnNcIiwge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9mYXN0Qm9keUNvbGxpc2lvbnM7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mYXN0Qm9keUNvbGxpc2lvbnMgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBoeXNpY3NTdGF0cy5wcm90b3R5cGUsIFwiYnJvYWRwaGFzZVwiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Jyb2FkcGhhc2U7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9icm9hZHBoYXNlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQaHlzaWNzU3RhdHMucHJvdG90eXBlLCBcIm5hcnJvd3BoYXNlXCIsIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbmFycm93cGhhc2U7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9uYXJyb3dwaGFzZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gUGh5c2ljc1N0YXRzO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuUGh5c2ljc1N0YXRzID0gUGh5c2ljc1N0YXRzO1xyXG59KTtcclxuZGVmaW5lKFwiSW50ZXJmYWNlcy9JRXZlbnRlZFwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG59KTtcclxuZGVmaW5lKFwiRXZlbnREaXNwYXRjaGVyXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiRXZlbnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgRXZlbnRzXzIpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFeGNhbGlidXIncyBpbnRlcm5hbCBldmVudCBkaXNwYXRjaGVyIGltcGxlbWVudGF0aW9uLlxyXG4gICAgICogQ2FsbGJhY2tzIGFyZSBmaXJlZCBpbW1lZGlhdGVseSBhZnRlciBhbiBldmVudCBpcyBwdWJsaXNoZWQuXHJcbiAgICAgKiBUeXBpY2FsbHkgeW91IHdpbGwgdXNlIFtbQ2xhc3MuZXZlbnREaXNwYXRjaGVyXV0gc2luY2UgbW9zdCBjbGFzc2VzIGluXHJcbiAgICAgKiBFeGNhbGlidXIgaW5oZXJpdCBmcm9tIFtbQ2xhc3NdXS4gWW91IHdpbGwgcmFyZWx5IGNyZWF0ZSBhbiBgRXZlbnREaXNwYXRjaGVyYFxyXG4gICAgICogeW91cnNlbGYuXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOkV2ZW50cy5tZF1dXHJcbiAgICAgKi9cclxuICAgIHZhciBFdmVudERpc3BhdGNoZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB0YXJnZXQgIFRoZSBvYmplY3QgdGhhdCB3aWxsIGJlIHRoZSByZWNpcGllbnQgb2YgZXZlbnRzIGZyb20gdGhpcyBldmVudCBkaXNwYXRjaGVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gRXZlbnREaXNwYXRjaGVyKHRhcmdldCkge1xyXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVycyA9IHt9O1xyXG4gICAgICAgICAgICB0aGlzLl93aXJlZEV2ZW50RGlzcGF0Y2hlcnMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbWl0cyBhbiBldmVudCBmb3IgdGFyZ2V0XHJcbiAgICAgICAgICogQHBhcmFtIGV2ZW50TmFtZSAgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHB1Ymxpc2hcclxuICAgICAgICAgKiBAcGFyYW0gZXZlbnQgICAgICBPcHRpb25hbGx5IHBhc3MgYW4gZXZlbnQgZGF0YSBvYmplY3QgdG8gdGhlIGhhbmRsZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudCkge1xyXG4gICAgICAgICAgICBpZiAoIWV2ZW50TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgLy8ga2V5IG5vdCBtYXBwZWRcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBldmVudE5hbWUgPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuX3RhcmdldDtcclxuICAgICAgICAgICAgaWYgKCFldmVudCkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnQgPSBuZXcgRXZlbnRzXzIuR2FtZUV2ZW50KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZXZlbnQudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICB2YXIgaSwgbGVuO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICBsZW4gPSB0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXVtpXS5jYWxsKHRhcmdldCwgZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgICAgICBsZW4gPSB0aGlzLl93aXJlZEV2ZW50RGlzcGF0Y2hlcnMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fd2lyZWRFdmVudERpc3BhdGNoZXJzW2ldLmVtaXQoZXZlbnROYW1lLCBldmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN1YnNjcmliZSBhbiBldmVudCBoYW5kbGVyIHRvIGEgcGFydGljdWxhciBldmVudCBuYW1lLCBtdWx0aXBsZSBoYW5kbGVycyBwZXIgZXZlbnQgbmFtZSBhcmUgYWxsb3dlZC5cclxuICAgICAgICAgKiBAcGFyYW0gZXZlbnROYW1lICBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gc3Vic2NyaWJlIHRvXHJcbiAgICAgICAgICogQHBhcmFtIGhhbmRsZXIgICAgVGhlIGhhbmRsZXIgY2FsbGJhY2sgdG8gZmlyZSBvbiB0aGlzIGV2ZW50XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgZXZlbnROYW1lID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXSA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV0ucHVzaChoYW5kbGVyKTtcclxuICAgICAgICAgICAgLy8gbWV0YSBldmVudCBoYW5kbGVyc1xyXG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lICE9PSAndW5zdWJzY3JpYmUnICYmIGV2ZW50TmFtZSAhPT0gJ3N1YnNjcmliZScpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnc3Vic2NyaWJlJywgbmV3IEV2ZW50c18yLlN1YnNjcmliZUV2ZW50KGV2ZW50TmFtZSwgaGFuZGxlcikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVbnN1YnNjcmliZSBhbiBldmVudCBoYW5kbGVyKHMpIGZyb20gYW4gZXZlbnQuIElmIGEgc3BlY2lmaWMgaGFuZGxlclxyXG4gICAgICAgICAqIGlzIHNwZWNpZmllZCBmb3IgYW4gZXZlbnQsIG9ubHkgdGhhdCBoYW5kbGVyIHdpbGwgYmUgdW5zdWJzY3JpYmVkLlxyXG4gICAgICAgICAqIE90aGVyd2lzZSBhbGwgaGFuZGxlcnMgd2lsbCBiZSB1bnN1YnNjcmliZWQgZm9yIHRoYXQgZXZlbnQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gZXZlbnROYW1lICBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gdW5zdWJzY3JpYmVcclxuICAgICAgICAgKiBAcGFyYW0gaGFuZGxlciAgICBPcHRpb25hbGx5IHRoZSBzcGVjaWZpYyBoYW5kbGVyIHRvIHVuc3Vic2NyaWJlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgZXZlbnROYW1lID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIHZhciBldmVudEhhbmRsZXJzID0gdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXTtcclxuICAgICAgICAgICAgaWYgKGV2ZW50SGFuZGxlcnMpIHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIG5vIGV4cGxpY2l0IGhhbmRsZXIgaXMgZ2l2ZSB3aXRoIHRoZSBldmVudCBuYW1lIGNsZWFyIGFsbCBoYW5kbGVyc1xyXG4gICAgICAgICAgICAgICAgaWYgKCFoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXS5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gZXZlbnRIYW5kbGVycy5pbmRleE9mKGhhbmRsZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV0uc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBtZXRhIGV2ZW50IGhhbmRsZXJzXHJcbiAgICAgICAgICAgIGlmIChldmVudE5hbWUgIT09ICd1bnN1YnNjcmliZScgJiYgZXZlbnROYW1lICE9PSAnc3Vic2NyaWJlJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCd1bnN1YnNjcmliZScsIG5ldyBFdmVudHNfMi5VbnN1YnNjcmliZUV2ZW50KGV2ZW50TmFtZSwgaGFuZGxlcikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBPbmNlIGxpc3RlbnMgdG8gYW4gZXZlbnQgb25lIHRpbWUsIHRoZW4gdW5zdWJzY3JpYmVzIGZyb20gdGhhdCBldmVudFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGV2ZW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gc3Vic2NyaWJlIHRvIG9uY2VcclxuICAgICAgICAgKiBAcGFyYW0gaGFuZGxlciAgIFRoZSBoYW5kbGVyIG9mIHRoZSBldmVudCB0aGF0IHdpbGwgYmUgYXV0byB1bnN1YnNjcmliZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBtZXRhSGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV2ID0gZXZlbnQgfHwgbmV3IEV2ZW50c18yLkdhbWVFdmVudCgpO1xyXG4gICAgICAgICAgICAgICAgZXYudGFyZ2V0ID0gZXYudGFyZ2V0IHx8IF90aGlzLl90YXJnZXQ7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5vZmYoZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIuY2FsbChldi50YXJnZXQsIGV2KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5vbihldmVudE5hbWUsIG1ldGFIYW5kbGVyKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdpcmVzIHRoaXMgZXZlbnQgZGlzcGF0Y2hlciB0byBhbHNvIHJlY2lldmUgZXZlbnRzIGZyb20gYW5vdGhlclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUud2lyZSA9IGZ1bmN0aW9uIChldmVudERpc3BhdGNoZXIpIHtcclxuICAgICAgICAgICAgZXZlbnREaXNwYXRjaGVyLl93aXJlZEV2ZW50RGlzcGF0Y2hlcnMucHVzaCh0aGlzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVud2lyZXMgdGhpcyBldmVudCBkaXNwYXRjaGVyIGZyb20gYW5vdGhlclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUudW53aXJlID0gZnVuY3Rpb24gKGV2ZW50RGlzcGF0Y2hlcikge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBldmVudERpc3BhdGNoZXIuX3dpcmVkRXZlbnREaXNwYXRjaGVycy5pbmRleE9mKHRoaXMpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnREaXNwYXRjaGVyLl93aXJlZEV2ZW50RGlzcGF0Y2hlcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEV2ZW50RGlzcGF0Y2hlcjtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkV2ZW50RGlzcGF0Y2hlciA9IEV2ZW50RGlzcGF0Y2hlcjtcclxufSk7XHJcbmRlZmluZShcIkFjdGlvbnMvQWN0aW9uQ29udGV4dFwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkFjdGlvbnMvQWN0aW9uXCIsIFwiUHJvbWlzZXNcIiwgXCJVdGlsL0Vhc2luZ0Z1bmN0aW9uc1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIEFjdGlvbnMsIFByb21pc2VzXzIsIEVhc2luZ0Z1bmN0aW9uc18yKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZsdWVudCBBY3Rpb24gQVBJIGFsbG93cyB5b3UgdG8gcGVyZm9ybSBcImFjdGlvbnNcIiBvblxyXG4gICAgICogW1tBY3RvcnxBY3RvcnNdXSBzdWNoIGFzIGZvbGxvd2luZywgbW92aW5nLCByb3RhdGluZywgYW5kXHJcbiAgICAgKiBtb3JlLiBZb3UgY2FuIGltcGxlbWVudCB5b3VyIG93biBhY3Rpb25zIGJ5IGltcGxlbWVudGluZ1xyXG4gICAgICogdGhlIFtbSUFjdGlvbl1dIGludGVyZmFjZS5cclxuICAgICAqXHJcbiAgICAgKiBbW2luY2x1ZGU6QWN0aW9ucy5tZF1dXHJcbiAgICAgKi9cclxuICAgIHZhciBBY3Rpb25Db250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBBY3Rpb25Db250ZXh0KCkge1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RvcnMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5fcXVldWVzID0gW107XHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9ycyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZXMgPSB0aGlzLl9hY3RvcnMubWFwKGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuYWN0aW9uUXVldWU7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDbGVhcnMgYWxsIHF1ZXVlZCBhY3Rpb25zIGZyb20gdGhlIEFjdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0aW9uQ29udGV4dC5wcm90b3R5cGUuY2xlYXJBY3Rpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3F1ZXVlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZXNbaV0uY2xlYXJBY3Rpb25zKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEFjdGlvbkNvbnRleHQucHJvdG90eXBlLmFkZEFjdG9yVG9Db250ZXh0ID0gZnVuY3Rpb24gKGFjdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9ycy5wdXNoKGFjdG9yKTtcclxuICAgICAgICAgICAgLy8gaWYgd2UgcnVuIGludG8gcHJvYmxlbXMgcmVwbGFjZSB0aGUgbGluZSBiZWxvdyB3aXRoOlxyXG4gICAgICAgICAgICB0aGlzLl9xdWV1ZXMucHVzaChhY3Rvci5hY3Rpb25RdWV1ZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBY3Rpb25Db250ZXh0LnByb3RvdHlwZS5yZW1vdmVBY3RvckZyb21Db250ZXh0ID0gZnVuY3Rpb24gKGFjdG9yKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX2FjdG9ycy5pbmRleE9mKGFjdG9yKTtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9ycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWVzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgbW92ZSBhbiBhY3RvciB0byB0aGUgc3BlY2lmaWVkIGB4YCBhbmQgYHlgIHBvc2l0aW9uIG92ZXIgdGhlXHJcbiAgICAgICAgICogc3BlY2lmaWVkIGR1cmF0aW9uIHVzaW5nIGEgZ2l2ZW4gW1tFYXNpbmdGdW5jdGlvbnNdXSBhbmQgcmV0dXJuIGJhY2sgdGhlIGFjdG9yLiBUaGlzXHJcbiAgICAgICAgICogbWV0aG9kIGlzIHBhcnQgb2YgdGhlIGFjdG9yICdBY3Rpb24nIGZsdWVudCBBUEkgYWxsb3dpbmcgYWN0aW9uIGNoYWluaW5nLlxyXG4gICAgICAgICAqIEBwYXJhbSB4ICAgICAgICAgVGhlIHggbG9jYXRpb24gdG8gbW92ZSB0aGUgYWN0b3IgdG9cclxuICAgICAgICAgKiBAcGFyYW0geSAgICAgICAgIFRoZSB5IGxvY2F0aW9uIHRvIG1vdmUgdGhlIGFjdG9yIHRvXHJcbiAgICAgICAgICogQHBhcmFtIGR1cmF0aW9uICBUaGUgdGltZSBpdCBzaG91bGQgdGFrZSB0aGUgYWN0b3IgdG8gbW92ZSB0byB0aGUgbmV3IGxvY2F0aW9uIGluIG1pbGxpc2Vjb25kc1xyXG4gICAgICAgICAqIEBwYXJhbSBlYXNpbmdGY24gVXNlIFtbRWFzaW5nRnVuY3Rpb25zXV0gb3IgYSBjdXN0b20gZnVuY3Rpb24gdG8gdXNlIHRvIGNhbGN1bGF0ZSBwb3NpdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdGlvbkNvbnRleHQucHJvdG90eXBlLmVhc2VUbyA9IGZ1bmN0aW9uICh4LCB5LCBkdXJhdGlvbiwgZWFzaW5nRmNuKSB7XHJcbiAgICAgICAgICAgIGlmIChlYXNpbmdGY24gPT09IHZvaWQgMCkgeyBlYXNpbmdGY24gPSBFYXNpbmdGdW5jdGlvbnNfMi5FYXNpbmdGdW5jdGlvbnMuTGluZWFyOyB9XHJcbiAgICAgICAgICAgIHZhciBpID0gMCwgbGVuID0gdGhpcy5fcXVldWVzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlc1tpXS5hZGQobmV3IEFjdGlvbnMuRWFzZVRvKHRoaXMuX2FjdG9yc1tpXSwgeCwgeSwgZHVyYXRpb24sIGVhc2luZ0ZjbikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCBtb3ZlIGFuIGFjdG9yIHRvIHRoZSBzcGVjaWZpZWQgeCBhbmQgeSBwb3NpdGlvbiBhdCB0aGVcclxuICAgICAgICAgKiBzcGVlZCBzcGVjaWZpZWQgKGluIHBpeGVscyBwZXIgc2Vjb25kKSBhbmQgcmV0dXJuIGJhY2sgdGhlIGFjdG9yLiBUaGlzXHJcbiAgICAgICAgICogbWV0aG9kIGlzIHBhcnQgb2YgdGhlIGFjdG9yICdBY3Rpb24nIGZsdWVudCBBUEkgYWxsb3dpbmcgYWN0aW9uIGNoYWluaW5nLlxyXG4gICAgICAgICAqIEBwYXJhbSB4ICAgICAgVGhlIHggbG9jYXRpb24gdG8gbW92ZSB0aGUgYWN0b3IgdG9cclxuICAgICAgICAgKiBAcGFyYW0geSAgICAgIFRoZSB5IGxvY2F0aW9uIHRvIG1vdmUgdGhlIGFjdG9yIHRvXHJcbiAgICAgICAgICogQHBhcmFtIHNwZWVkICBUaGUgc3BlZWQgaW4gcGl4ZWxzIHBlciBzZWNvbmQgdG8gbW92ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdGlvbkNvbnRleHQucHJvdG90eXBlLm1vdmVUbyA9IGZ1bmN0aW9uICh4LCB5LCBzcGVlZCkge1xyXG4gICAgICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3F1ZXVlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZXNbaV0uYWRkKG5ldyBBY3Rpb25zLk1vdmVUbyh0aGlzLl9hY3RvcnNbaV0sIHgsIHksIHNwZWVkKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIG1vdmUgYW4gYWN0b3IgdG8gdGhlIHNwZWNpZmllZCB4IGFuZCB5IHBvc2l0aW9uIGJ5IGFcclxuICAgICAgICAgKiBjZXJ0YWluIHRpbWUgKGluIG1pbGxpc2Vjb25kcykuIFRoaXMgbWV0aG9kIGlzIHBhcnQgb2YgdGhlIGFjdG9yXHJcbiAgICAgICAgICogJ0FjdGlvbicgZmx1ZW50IEFQSSBhbGxvd2luZyBhY3Rpb24gY2hhaW5pbmcuXHJcbiAgICAgICAgICogQHBhcmFtIHggICAgIFRoZSB4IGxvY2F0aW9uIHRvIG1vdmUgdGhlIGFjdG9yIHRvXHJcbiAgICAgICAgICogQHBhcmFtIHkgICAgIFRoZSB5IGxvY2F0aW9uIHRvIG1vdmUgdGhlIGFjdG9yIHRvXHJcbiAgICAgICAgICogQHBhcmFtIHRpbWUgIFRoZSB0aW1lIGl0IHNob3VsZCB0YWtlIHRoZSBhY3RvciB0byBtb3ZlIHRvIHRoZSBuZXcgbG9jYXRpb24gaW4gbWlsbGlzZWNvbmRzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0aW9uQ29udGV4dC5wcm90b3R5cGUubW92ZUJ5ID0gZnVuY3Rpb24gKHgsIHksIHRpbWUpIHtcclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9xdWV1ZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWVzW2ldLmFkZChuZXcgQWN0aW9ucy5Nb3ZlQnkodGhpcy5fYWN0b3JzW2ldLCB4LCB5LCB0aW1lKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHJvdGF0ZSBhbiBhY3RvciB0byB0aGUgc3BlY2lmaWVkIGFuZ2xlIGF0IHRoZSBzcGVlZFxyXG4gICAgICAgICAqIHNwZWNpZmllZCAoaW4gcmFkaWFucyBwZXIgc2Vjb25kKSBhbmQgcmV0dXJuIGJhY2sgdGhlIGFjdG9yLiBUaGlzXHJcbiAgICAgICAgICogbWV0aG9kIGlzIHBhcnQgb2YgdGhlIGFjdG9yICdBY3Rpb24nIGZsdWVudCBBUEkgYWxsb3dpbmcgYWN0aW9uIGNoYWluaW5nLlxyXG4gICAgICAgICAqIEBwYXJhbSBhbmdsZVJhZGlhbnMgIFRoZSBhbmdsZSB0byByb3RhdGUgdG8gaW4gcmFkaWFuc1xyXG4gICAgICAgICAqIEBwYXJhbSBzcGVlZCAgICAgICAgIFRoZSBhbmd1bGFyIHZlbG9jaXR5IG9mIHRoZSByb3RhdGlvbiBzcGVjaWZpZWQgaW4gcmFkaWFucyBwZXIgc2Vjb25kXHJcbiAgICAgICAgICogQHBhcmFtIHJvdGF0aW9uVHlwZSAgVGhlIFtbUm90YXRpb25UeXBlXV0gdG8gdXNlIGZvciB0aGlzIHJvdGF0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0aW9uQ29udGV4dC5wcm90b3R5cGUucm90YXRlVG8gPSBmdW5jdGlvbiAoYW5nbGVSYWRpYW5zLCBzcGVlZCwgcm90YXRpb25UeXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gMCwgbGVuID0gdGhpcy5fcXVldWVzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlc1tpXS5hZGQobmV3IEFjdGlvbnMuUm90YXRlVG8odGhpcy5fYWN0b3JzW2ldLCBhbmdsZVJhZGlhbnMsIHNwZWVkLCByb3RhdGlvblR5cGUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgcm90YXRlIGFuIGFjdG9yIHRvIHRoZSBzcGVjaWZpZWQgYW5nbGUgYnkgYSBjZXJ0YWluXHJcbiAgICAgICAgICogdGltZSAoaW4gbWlsbGlzZWNvbmRzKSBhbmQgcmV0dXJuIGJhY2sgdGhlIGFjdG9yLiBUaGlzIG1ldGhvZCBpcyBwYXJ0XHJcbiAgICAgICAgICogb2YgdGhlIGFjdG9yICdBY3Rpb24nIGZsdWVudCBBUEkgYWxsb3dpbmcgYWN0aW9uIGNoYWluaW5nLlxyXG4gICAgICAgICAqIEBwYXJhbSBhbmdsZVJhZGlhbnMgIFRoZSBhbmdsZSB0byByb3RhdGUgdG8gaW4gcmFkaWFuc1xyXG4gICAgICAgICAqIEBwYXJhbSB0aW1lICAgICAgICAgIFRoZSB0aW1lIGl0IHNob3VsZCB0YWtlIHRoZSBhY3RvciB0byBjb21wbGV0ZSB0aGUgcm90YXRpb24gaW4gbWlsbGlzZWNvbmRzXHJcbiAgICAgICAgICogQHBhcmFtIHJvdGF0aW9uVHlwZSAgVGhlIFtbUm90YXRpb25UeXBlXV0gdG8gdXNlIGZvciB0aGlzIHJvdGF0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0aW9uQ29udGV4dC5wcm90b3R5cGUucm90YXRlQnkgPSBmdW5jdGlvbiAoYW5nbGVSYWRpYW5zLCB0aW1lLCByb3RhdGlvblR5cGUpIHtcclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9xdWV1ZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWVzW2ldLmFkZChuZXcgQWN0aW9ucy5Sb3RhdGVCeSh0aGlzLl9hY3RvcnNbaV0sIGFuZ2xlUmFkaWFucywgdGltZSwgcm90YXRpb25UeXBlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHNjYWxlIGFuIGFjdG9yIHRvIHRoZSBzcGVjaWZpZWQgc2l6ZSBhdCB0aGUgc3BlZWRcclxuICAgICAgICAgKiBzcGVjaWZpZWQgKGluIG1hZ25pdHVkZSBpbmNyZWFzZSBwZXIgc2Vjb25kKSBhbmQgcmV0dXJuIGJhY2sgdGhlXHJcbiAgICAgICAgICogYWN0b3IuIFRoaXMgbWV0aG9kIGlzIHBhcnQgb2YgdGhlIGFjdG9yICdBY3Rpb24nIGZsdWVudCBBUEkgYWxsb3dpbmdcclxuICAgICAgICAgKiBhY3Rpb24gY2hhaW5pbmcuXHJcbiAgICAgICAgICogQHBhcmFtIHNpemVYICAgVGhlIHNjYWxpbmcgZmFjdG9yIHRvIGFwcGx5IG9uIFggYXhpc1xyXG4gICAgICAgICAqIEBwYXJhbSBzaXplWSAgIFRoZSBzY2FsaW5nIGZhY3RvciB0byBhcHBseSBvbiBZIGF4aXNcclxuICAgICAgICAgKiBAcGFyYW0gc3BlZWRYICBUaGUgc3BlZWQgb2Ygc2NhbGluZyBzcGVjaWZpZWQgaW4gbWFnbml0dWRlIGluY3JlYXNlIHBlciBzZWNvbmQgb24gWCBheGlzXHJcbiAgICAgICAgICogQHBhcmFtIHNwZWVkWSAgVGhlIHNwZWVkIG9mIHNjYWxpbmcgc3BlY2lmaWVkIGluIG1hZ25pdHVkZSBpbmNyZWFzZSBwZXIgc2Vjb25kIG9uIFkgYXhpc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdGlvbkNvbnRleHQucHJvdG90eXBlLnNjYWxlVG8gPSBmdW5jdGlvbiAoc2l6ZVgsIHNpemVZLCBzcGVlZFgsIHNwZWVkWSkge1xyXG4gICAgICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3F1ZXVlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZXNbaV0uYWRkKG5ldyBBY3Rpb25zLlNjYWxlVG8odGhpcy5fYWN0b3JzW2ldLCBzaXplWCwgc2l6ZVksIHNwZWVkWCwgc3BlZWRZKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHNjYWxlIGFuIGFjdG9yIHRvIHRoZSBzcGVjaWZpZWQgc2l6ZSBieSBhIGNlcnRhaW4gdGltZVxyXG4gICAgICAgICAqIChpbiBtaWxsaXNlY29uZHMpIGFuZCByZXR1cm4gYmFjayB0aGUgYWN0b3IuIFRoaXMgbWV0aG9kIGlzIHBhcnQgb2YgdGhlXHJcbiAgICAgICAgICogYWN0b3IgJ0FjdGlvbicgZmx1ZW50IEFQSSBhbGxvd2luZyBhY3Rpb24gY2hhaW5pbmcuXHJcbiAgICAgICAgICogQHBhcmFtIHNpemVYICAgVGhlIHNjYWxpbmcgZmFjdG9yIHRvIGFwcGx5IG9uIFggYXhpc1xyXG4gICAgICAgICAqIEBwYXJhbSBzaXplWSAgIFRoZSBzY2FsaW5nIGZhY3RvciB0byBhcHBseSBvbiBZIGF4aXNcclxuICAgICAgICAgKiBAcGFyYW0gdGltZSAgICBUaGUgdGltZSBpdCBzaG91bGQgdGFrZSB0byBjb21wbGV0ZSB0aGUgc2NhbGluZyBpbiBtaWxsaXNlY29uZHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3Rpb25Db250ZXh0LnByb3RvdHlwZS5zY2FsZUJ5ID0gZnVuY3Rpb24gKHNpemVYLCBzaXplWSwgdGltZSkge1xyXG4gICAgICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3F1ZXVlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZXNbaV0uYWRkKG5ldyBBY3Rpb25zLlNjYWxlQnkodGhpcy5fYWN0b3JzW2ldLCBzaXplWCwgc2l6ZVksIHRpbWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgY2F1c2UgYW4gYWN0b3IgdG8gYmxpbmsgKGJlY29tZSB2aXNpYmxlIGFuZCBub3RcclxuICAgICAgICAgKiB2aXNpYmxlKS4gT3B0aW9uYWxseSwgeW91IG1heSBzcGVjaWZ5IHRoZSBudW1iZXIgb2YgYmxpbmtzLiBTcGVjaWZ5IHRoZSBhbW91bnQgb2YgdGltZVxyXG4gICAgICAgICAqIHRoZSBhY3RvciBzaG91bGQgYmUgdmlzaWJsZSBwZXIgYmxpbmssIGFuZCB0aGUgYW1vdW50IG9mIHRpbWUgbm90IHZpc2libGUuXHJcbiAgICAgICAgICogVGhpcyBtZXRob2QgaXMgcGFydCBvZiB0aGUgYWN0b3IgJ0FjdGlvbicgZmx1ZW50IEFQSSBhbGxvd2luZyBhY3Rpb24gY2hhaW5pbmcuXHJcbiAgICAgICAgICogQHBhcmFtIHRpbWVWaXNpYmxlICAgICBUaGUgYW1vdW50IG9mIHRpbWUgdG8gc3RheSB2aXNpYmxlIHBlciBibGluayBpbiBtaWxsaXNlY29uZHNcclxuICAgICAgICAgKiBAcGFyYW0gdGltZU5vdFZpc2libGUgIFRoZSBhbW91bnQgb2YgdGltZSB0byBzdGF5IG5vdCB2aXNpYmxlIHBlciBibGluayBpbiBtaWxsaXNlY29uZHNcclxuICAgICAgICAgKiBAcGFyYW0gbnVtQmxpbmtzICAgICAgIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gYmxpbmtcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3Rpb25Db250ZXh0LnByb3RvdHlwZS5ibGluayA9IGZ1bmN0aW9uICh0aW1lVmlzaWJsZSwgdGltZU5vdFZpc2libGUsIG51bUJsaW5rcykge1xyXG4gICAgICAgICAgICBpZiAobnVtQmxpbmtzID09PSB2b2lkIDApIHsgbnVtQmxpbmtzID0gMTsgfVxyXG4gICAgICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3F1ZXVlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZXNbaV0uYWRkKG5ldyBBY3Rpb25zLkJsaW5rKHRoaXMuX2FjdG9yc1tpXSwgdGltZVZpc2libGUsIHRpbWVOb3RWaXNpYmxlLCBudW1CbGlua3MpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgY2F1c2UgYW4gYWN0b3IncyBvcGFjaXR5IHRvIGNoYW5nZSBmcm9tIGl0cyBjdXJyZW50IHZhbHVlXHJcbiAgICAgICAgICogdG8gdGhlIHByb3ZpZGVkIHZhbHVlIGJ5IGEgc3BlY2lmaWVkIHRpbWUgKGluIG1pbGxpc2Vjb25kcykuIFRoaXMgbWV0aG9kIGlzXHJcbiAgICAgICAgICogcGFydCBvZiB0aGUgYWN0b3IgJ0FjdGlvbicgZmx1ZW50IEFQSSBhbGxvd2luZyBhY3Rpb24gY2hhaW5pbmcuXHJcbiAgICAgICAgICogQHBhcmFtIG9wYWNpdHkgIFRoZSBlbmRpbmcgb3BhY2l0eVxyXG4gICAgICAgICAqIEBwYXJhbSB0aW1lICAgICBUaGUgdGltZSBpdCBzaG91bGQgdGFrZSB0byBmYWRlIHRoZSBhY3RvciAoaW4gbWlsbGlzZWNvbmRzKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdGlvbkNvbnRleHQucHJvdG90eXBlLmZhZGUgPSBmdW5jdGlvbiAob3BhY2l0eSwgdGltZSkge1xyXG4gICAgICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3F1ZXVlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZXNbaV0uYWRkKG5ldyBBY3Rpb25zLkZhZGUodGhpcy5fYWN0b3JzW2ldLCBvcGFjaXR5LCB0aW1lKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGRlbGF5IHRoZSBuZXh0IGFjdGlvbiBmcm9tIGV4ZWN1dGluZyBmb3IgYSBjZXJ0YWluXHJcbiAgICAgICAgICogYW1vdW50IG9mIHRpbWUgKGluIG1pbGxpc2Vjb25kcykuIFRoaXMgbWV0aG9kIGlzIHBhcnQgb2YgdGhlIGFjdG9yXHJcbiAgICAgICAgICogJ0FjdGlvbicgZmx1ZW50IEFQSSBhbGxvd2luZyBhY3Rpb24gY2hhaW5pbmcuXHJcbiAgICAgICAgICogQHBhcmFtIHRpbWUgIFRoZSBhbW91bnQgb2YgdGltZSB0byBkZWxheSB0aGUgbmV4dCBhY3Rpb24gaW4gdGhlIHF1ZXVlIGZyb20gZXhlY3V0aW5nIGluIG1pbGxpc2Vjb25kc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdGlvbkNvbnRleHQucHJvdG90eXBlLmRlbGF5ID0gZnVuY3Rpb24gKHRpbWUpIHtcclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9xdWV1ZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWVzW2ldLmFkZChuZXcgQWN0aW9ucy5EZWxheSh0aGlzLl9hY3RvcnNbaV0sIHRpbWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgYWRkIGFuIGFjdGlvbiB0byB0aGUgcXVldWUgdGhhdCB3aWxsIHJlbW92ZSB0aGUgYWN0b3IgZnJvbSB0aGVcclxuICAgICAgICAgKiBzY2VuZSBvbmNlIGl0IGhhcyBjb21wbGV0ZWQgaXRzIHByZXZpb3VzIGFjdGlvbnMuIEFueSBhY3Rpb25zIG9uIHRoZVxyXG4gICAgICAgICAqIGFjdGlvbiBxdWV1ZSBhZnRlciB0aGlzIGFjdGlvbiB3aWxsIG5vdCBiZSBleGVjdXRlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3Rpb25Db250ZXh0LnByb3RvdHlwZS5kaWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gMCwgbGVuID0gdGhpcy5fcXVldWVzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlc1tpXS5hZGQobmV3IEFjdGlvbnMuRGllKHRoaXMuX2FjdG9yc1tpXSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2QgYWxsb3dzIHlvdSB0byBjYWxsIGFuIGFyYml0cmFyeSBtZXRob2QgYXMgdGhlIG5leHQgYWN0aW9uIGluIHRoZVxyXG4gICAgICAgICAqIGFjdGlvbiBxdWV1ZS4gVGhpcyBpcyB1c2VmdWwgaWYgeW91IHdhbnQgdG8gZXhlY3V0ZSBjb2RlIGluIGFmdGVyIGEgc3BlY2lmaWNcclxuICAgICAgICAgKiBhY3Rpb24sIGkuZSBBbiBhY3RvciBhcnJpdmVzIGF0IGEgZGVzdGluYXRpb24gYWZ0ZXIgdHJhdmVyc2luZyBhIHBhdGhcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3Rpb25Db250ZXh0LnByb3RvdHlwZS5jYWxsTWV0aG9kID0gZnVuY3Rpb24gKG1ldGhvZCkge1xyXG4gICAgICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3F1ZXVlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZXNbaV0uYWRkKG5ldyBBY3Rpb25zLkNhbGxNZXRob2QodGhpcy5fYWN0b3JzW2ldLCBtZXRob2QpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgY2F1c2UgdGhlIGFjdG9yIHRvIHJlcGVhdCBhbGwgb2YgdGhlIHByZXZpb3VzbHlcclxuICAgICAgICAgKiBjYWxsZWQgYWN0aW9ucyBhIGNlcnRhaW4gbnVtYmVyIG9mIHRpbWVzLiBJZiB0aGUgbnVtYmVyIG9mIHJlcGVhdHNcclxuICAgICAgICAgKiBpcyBub3Qgc3BlY2lmaWVkIGl0IHdpbGwgcmVwZWF0IGZvcmV2ZXIuIFRoaXMgbWV0aG9kIGlzIHBhcnQgb2ZcclxuICAgICAgICAgKiB0aGUgYWN0b3IgJ0FjdGlvbicgZmx1ZW50IEFQSSBhbGxvd2luZyBhY3Rpb24gY2hhaW5pbmdcclxuICAgICAgICAgKiBAcGFyYW0gdGltZXMgIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IGFsbCB0aGUgcHJldmlvdXMgYWN0aW9ucyBpbiB0aGUgYWN0aW9uIHF1ZXVlLiBJZiBub3RoaW5nIGlzIHNwZWNpZmllZCB0aGUgYWN0aW9uc1xyXG4gICAgICAgICAqIHdpbGwgcmVwZWF0IGZvcmV2ZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3Rpb25Db250ZXh0LnByb3RvdHlwZS5yZXBlYXQgPSBmdW5jdGlvbiAodGltZXMpIHtcclxuICAgICAgICAgICAgaWYgKCF0aW1lcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXBlYXRGb3JldmVyKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3F1ZXVlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZXNbaV0uYWRkKG5ldyBBY3Rpb25zLlJlcGVhdCh0aGlzLl9hY3RvcnNbaV0sIHRpbWVzLCB0aGlzLl9hY3RvcnNbaV0uYWN0aW9uUXVldWUuZ2V0QWN0aW9ucygpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGNhdXNlIHRoZSBhY3RvciB0byByZXBlYXQgYWxsIG9mIHRoZSBwcmV2aW91c2x5XHJcbiAgICAgICAgICogY2FsbGVkIGFjdGlvbnMgZm9yZXZlci4gVGhpcyBtZXRob2QgaXMgcGFydCBvZiB0aGUgYWN0b3IgJ0FjdGlvbidcclxuICAgICAgICAgKiBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3Rpb25Db250ZXh0LnByb3RvdHlwZS5yZXBlYXRGb3JldmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3F1ZXVlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZXNbaV0uYWRkKG5ldyBBY3Rpb25zLlJlcGVhdEZvcmV2ZXIodGhpcy5fYWN0b3JzW2ldLCB0aGlzLl9hY3RvcnNbaV0uYWN0aW9uUXVldWUuZ2V0QWN0aW9ucygpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGNhdXNlIHRoZSBhY3RvciB0byBmb2xsb3cgYW5vdGhlciBhdCBhIHNwZWNpZmllZCBkaXN0YW5jZVxyXG4gICAgICAgICAqIEBwYXJhbSBhY3RvciAgICAgICAgICAgVGhlIGFjdG9yIHRvIGZvbGxvd1xyXG4gICAgICAgICAqIEBwYXJhbSBmb2xsb3dEaXN0YW5jZSAgVGhlIGRpc3RhbmNlIHRvIG1haW50YWluIHdoZW4gZm9sbG93aW5nLCBpZiBub3Qgc3BlY2lmaWVkIHRoZSBhY3RvciB3aWxsIGZvbGxvdyBhdCB0aGUgY3VycmVudCBkaXN0YW5jZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3Rpb25Db250ZXh0LnByb3RvdHlwZS5mb2xsb3cgPSBmdW5jdGlvbiAoYWN0b3IsIGZvbGxvd0Rpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gMCwgbGVuID0gdGhpcy5fcXVldWVzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChmb2xsb3dEaXN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcXVldWVzW2ldLmFkZChuZXcgQWN0aW9ucy5Gb2xsb3codGhpcy5fYWN0b3JzW2ldLCBhY3RvcikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcXVldWVzW2ldLmFkZChuZXcgQWN0aW9ucy5Gb2xsb3codGhpcy5fYWN0b3JzW2ldLCBhY3RvciwgZm9sbG93RGlzdGFuY2UpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgY2F1c2UgdGhlIGFjdG9yIHRvIG1vdmUgdG93YXJkcyBhbm90aGVyIHVudGlsIHRoZXlcclxuICAgICAgICAgKiBjb2xsaWRlIFwibWVldFwiIGF0IGEgc3BlY2lmaWVkIHNwZWVkLlxyXG4gICAgICAgICAqIEBwYXJhbSBhY3RvciAgVGhlIGFjdG9yIHRvIG1lZXRcclxuICAgICAgICAgKiBAcGFyYW0gc3BlZWQgIFRoZSBzcGVlZCBpbiBwaXhlbHMgcGVyIHNlY29uZCB0byBtb3ZlLCBpZiBub3Qgc3BlY2lmaWVkIGl0IHdpbGwgbWF0Y2ggdGhlIHNwZWVkIG9mIHRoZSBvdGhlciBhY3RvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdGlvbkNvbnRleHQucHJvdG90eXBlLm1lZXQgPSBmdW5jdGlvbiAoYWN0b3IsIHNwZWVkKSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gMCwgbGVuID0gdGhpcy5fcXVldWVzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChzcGVlZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcXVldWVzW2ldLmFkZChuZXcgQWN0aW9ucy5NZWV0KHRoaXMuX2FjdG9yc1tpXSwgYWN0b3IpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlc1tpXS5hZGQobmV3IEFjdGlvbnMuTWVldCh0aGlzLl9hY3RvcnNbaV0sIGFjdG9yLCBzcGVlZCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBjdXJyZW50IGFjdGlvbiBxdWV1ZSB1cCB0byBub3dcclxuICAgICAgICAgKiBpcyBmaW5pc2hlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3Rpb25Db250ZXh0LnByb3RvdHlwZS5hc1Byb21pc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IHRoaXMuX3F1ZXVlcy5tYXAoZnVuY3Rpb24gKHEsIGkpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0ZW1wID0gbmV3IFByb21pc2VzXzIuUHJvbWlzZSgpO1xyXG4gICAgICAgICAgICAgICAgcS5hZGQobmV3IEFjdGlvbnMuQ2FsbE1ldGhvZChfdGhpcy5fYWN0b3JzW2ldLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcC5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGVtcDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlc18yLlByb21pc2Uuam9pbi5hcHBseSh0aGlzLCBwcm9taXNlcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gQWN0aW9uQ29udGV4dDtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkFjdGlvbkNvbnRleHQgPSBBY3Rpb25Db250ZXh0O1xyXG59KTtcclxuZGVmaW5lKFwiVXRpbC9Mb2dcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogTG9nZ2luZyBsZXZlbCB0aGF0IEV4Y2FsaWJ1ciB3aWxsIHRhZ1xyXG4gICAgICovXHJcbiAgICB2YXIgTG9nTGV2ZWw7XHJcbiAgICAoZnVuY3Rpb24gKExvZ0xldmVsKSB7XHJcbiAgICAgICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJEZWJ1Z1wiXSA9IDBdID0gXCJEZWJ1Z1wiO1xyXG4gICAgICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiSW5mb1wiXSA9IDFdID0gXCJJbmZvXCI7XHJcbiAgICAgICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJXYXJuXCJdID0gMl0gPSBcIldhcm5cIjtcclxuICAgICAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkVycm9yXCJdID0gM10gPSBcIkVycm9yXCI7XHJcbiAgICAgICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJGYXRhbFwiXSA9IDRdID0gXCJGYXRhbFwiO1xyXG4gICAgfSkoTG9nTGV2ZWwgPSBleHBvcnRzLkxvZ0xldmVsIHx8IChleHBvcnRzLkxvZ0xldmVsID0ge30pKTtcclxuICAgIC8qKlxyXG4gICAgICogU3RhdGljIHNpbmdsZXRvbiB0aGF0IHJlcHJlc2VudHMgdGhlIGxvZ2dpbmcgZmFjaWxpdHkgZm9yIEV4Y2FsaWJ1ci5cclxuICAgICAqIEV4Y2FsaWJ1ciBjb21lcyBidWlsdC1pbiB3aXRoIGEgW1tDb25zb2xlQXBwZW5kZXJdXSBhbmQgW1tTY3JlZW5BcHBlbmRlcl1dLlxyXG4gICAgICogRGVyaXZlIGZyb20gW1tJQXBwZW5kZXJdXSB0byBjcmVhdGUgeW91ciBvd24gbG9nZ2luZyBhcHBlbmRlcnMuXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOkxvZ2dlci5tZF1dXHJcbiAgICAgKi9cclxuICAgIHZhciBMb2dnZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIExvZ2dlcigpIHtcclxuICAgICAgICAgICAgdGhpcy5fYXBwZW5kZXJzID0gW107XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGRlZmF1bHQgbG9nZ2luZyBsZXZlbC4gRXhjYWxpYnVyIHdpbGwgb25seSBsb2dcclxuICAgICAgICAgICAgICogbWVzc2FnZXMgaWYgZXF1YWwgdG8gb3IgYWJvdmUgdGhpcyBsZXZlbC4gRGVmYXVsdDogW1tMb2dMZXZlbC5JbmZvXV1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdExldmVsID0gTG9nTGV2ZWwuSW5mbztcclxuICAgICAgICAgICAgaWYgKExvZ2dlci5faW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTG9nZ2VyIGlzIGEgc2luZ2xldG9uJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgTG9nZ2VyLl9pbnN0YW5jZSA9IHRoaXM7XHJcbiAgICAgICAgICAgIC8vIERlZmF1bHQgY29uc29sZSBhcHBlbmRlclxyXG4gICAgICAgICAgICBMb2dnZXIuX2luc3RhbmNlLmFkZEFwcGVuZGVyKG5ldyBDb25zb2xlQXBwZW5kZXIoKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBMb2dnZXIuX2luc3RhbmNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHN0YXRpYyBpbnN0YW5jZSBvZiBMb2dnZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChMb2dnZXIuX2luc3RhbmNlID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIExvZ2dlci5faW5zdGFuY2UgPSBuZXcgTG9nZ2VyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIExvZ2dlci5faW5zdGFuY2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgbmV3IFtbSUFwcGVuZGVyXV0gdG8gdGhlIGxpc3Qgb2YgYXBwZW5kZXJzIHRvIHdyaXRlIHRvXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTG9nZ2VyLnByb3RvdHlwZS5hZGRBcHBlbmRlciA9IGZ1bmN0aW9uIChhcHBlbmRlcikge1xyXG4gICAgICAgICAgICB0aGlzLl9hcHBlbmRlcnMucHVzaChhcHBlbmRlcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDbGVhcnMgYWxsIGFwcGVuZGVycyBmcm9tIHRoZSBsb2dnZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBMb2dnZXIucHJvdG90eXBlLmNsZWFyQXBwZW5kZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9hcHBlbmRlcnMubGVuZ3RoID0gMDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExvZ3MgYSBtZXNzYWdlIGF0IGEgZ2l2ZW4gTG9nTGV2ZWxcclxuICAgICAgICAgKiBAcGFyYW0gbGV2ZWwgIFRoZSBMb2dMZXZlbGB0byBsb2cgdGhlIG1lc3NhZ2UgYXRcclxuICAgICAgICAgKiBAcGFyYW0gYXJncyAgIEFuIGFycmF5IG9mIGFyZ3VtZW50cyB0byB3cml0ZSB0byBhbiBhcHBlbmRlclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExvZ2dlci5wcm90b3R5cGUuX2xvZyA9IGZ1bmN0aW9uIChsZXZlbCwgYXJncykge1xyXG4gICAgICAgICAgICBpZiAobGV2ZWwgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgbGV2ZWwgPSB0aGlzLmRlZmF1bHRMZXZlbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX2FwcGVuZGVycy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGV2ZWwgPj0gdGhpcy5kZWZhdWx0TGV2ZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hcHBlbmRlcnNbaV0ubG9nKGxldmVsLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV3JpdGVzIGEgbG9nIG1lc3NhZ2UgYXQgdGhlIFtbTG9nTGV2ZWwuRGVidWddXSBsZXZlbFxyXG4gICAgICAgICAqIEBwYXJhbSBhcmdzICBBY2NlcHRzIGFueSBudW1iZXIgb2YgYXJndW1lbnRzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTG9nZ2VyLnByb3RvdHlwZS5kZWJ1ZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9sb2coTG9nTGV2ZWwuRGVidWcsIGFyZ3MpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV3JpdGVzIGEgbG9nIG1lc3NhZ2UgYXQgdGhlIFtbTG9nTGV2ZWwuSW5mb11dIGxldmVsXHJcbiAgICAgICAgICogQHBhcmFtIGFyZ3MgIEFjY2VwdHMgYW55IG51bWJlciBvZiBhcmd1bWVudHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBMb2dnZXIucHJvdG90eXBlLmluZm8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbG9nKExvZ0xldmVsLkluZm8sIGFyZ3MpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV3JpdGVzIGEgbG9nIG1lc3NhZ2UgYXQgdGhlIFtbTG9nTGV2ZWwuV2Fybl1dIGxldmVsXHJcbiAgICAgICAgICogQHBhcmFtIGFyZ3MgIEFjY2VwdHMgYW55IG51bWJlciBvZiBhcmd1bWVudHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBMb2dnZXIucHJvdG90eXBlLndhcm4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbG9nKExvZ0xldmVsLldhcm4sIGFyZ3MpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV3JpdGVzIGEgbG9nIG1lc3NhZ2UgYXQgdGhlIFtbTG9nTGV2ZWwuRXJyb3JdXSBsZXZlbFxyXG4gICAgICAgICAqIEBwYXJhbSBhcmdzICBBY2NlcHRzIGFueSBudW1iZXIgb2YgYXJndW1lbnRzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTG9nZ2VyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9sb2coTG9nTGV2ZWwuRXJyb3IsIGFyZ3MpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV3JpdGVzIGEgbG9nIG1lc3NhZ2UgYXQgdGhlIFtbTG9nTGV2ZWwuRmF0YWxdXSBsZXZlbFxyXG4gICAgICAgICAqIEBwYXJhbSBhcmdzICBBY2NlcHRzIGFueSBudW1iZXIgb2YgYXJndW1lbnRzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTG9nZ2VyLnByb3RvdHlwZS5mYXRhbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9sb2coTG9nTGV2ZWwuRmF0YWwsIGFyZ3MpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIExvZ2dlcjtcclxuICAgIH0oKSk7XHJcbiAgICBMb2dnZXIuX2luc3RhbmNlID0gbnVsbDtcclxuICAgIGV4cG9ydHMuTG9nZ2VyID0gTG9nZ2VyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zb2xlIGFwcGVuZGVyIGZvciBicm93c2VycyAoaS5lLiBgY29uc29sZS5sb2dgKVxyXG4gICAgICovXHJcbiAgICB2YXIgQ29uc29sZUFwcGVuZGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBDb25zb2xlQXBwZW5kZXIoKSB7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExvZ3MgYSBtZXNzYWdlIGF0IHRoZSBnaXZlbiBbW0xvZ0xldmVsXV1cclxuICAgICAgICAgKiBAcGFyYW0gbGV2ZWwgIExldmVsIHRvIGxvZyBhdFxyXG4gICAgICAgICAqIEBwYXJhbSBhcmdzICAgQXJndW1lbnRzIHRvIGxvZ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbnNvbGVBcHBlbmRlci5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKGxldmVsLCBhcmdzKSB7XHJcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBjb25zb2xlIHN1cHBvcnRcclxuICAgICAgICAgICAgaWYgKCFjb25zb2xlICYmICFjb25zb2xlLmxvZyAmJiBjb25zb2xlLndhcm4gJiYgY29uc29sZS5lcnJvcikge1xyXG4gICAgICAgICAgICAgICAgLy8gdG9kbyBtYXliZSBkbyBzb21ldGhpbmcgYmV0dGVyIHRoYW4gbm90aGluZ1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBjb25zb2xlIGFyZ3MgYXJyYXlcclxuICAgICAgICAgICAgdmFyIGNvbnNvbGVBcmdzID0gW107XHJcbiAgICAgICAgICAgIGNvbnNvbGVBcmdzLnVuc2hpZnQuYXBwbHkoY29uc29sZUFyZ3MsIGFyZ3MpO1xyXG4gICAgICAgICAgICBjb25zb2xlQXJncy51bnNoaWZ0KCdbJyArIExvZ0xldmVsW2xldmVsXSArICddIDogJyk7XHJcbiAgICAgICAgICAgIGlmIChsZXZlbCA8IExvZ0xldmVsLldhcm4pIHtcclxuICAgICAgICAgICAgICAgIC8vIENhbGwgLmxvZyBmb3IgRGVidWcvSW5mb1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnNvbGUubG9nLmFwcGx5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyByZXF1aXJlZCBvbiBzb21lIG9sZGVyIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBhcHBseSBvbiBjb25zb2xlLmxvZyA6KFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGNvbnNvbGVBcmdzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGNvbnNvbGVBcmdzLmpvaW4oJyAnKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobGV2ZWwgPCBMb2dMZXZlbC5FcnJvcikge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2FsbCAud2FybiBmb3IgV2FyblxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnNvbGUud2Fybi5hcHBseSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybi5hcHBseShjb25zb2xlLCBjb25zb2xlQXJncyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oY29uc29sZUFyZ3Muam9pbignICcpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIENhbGwgLmVycm9yIGZvciBFcnJvci9GYXRhbFxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnNvbGUuZXJyb3IuYXBwbHkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yLmFwcGx5KGNvbnNvbGUsIGNvbnNvbGVBcmdzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoY29uc29sZUFyZ3Muam9pbignICcpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIENvbnNvbGVBcHBlbmRlcjtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkNvbnNvbGVBcHBlbmRlciA9IENvbnNvbGVBcHBlbmRlcjtcclxuICAgIC8qKlxyXG4gICAgICogT24tc2NyZWVuIChjYW52YXMpIGFwcGVuZGVyXHJcbiAgICAgKi9cclxuICAgIHZhciBTY3JlZW5BcHBlbmRlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHdpZHRoICAgV2lkdGggb2YgdGhlIHNjcmVlbiBhcHBlbmRlciBpbiBwaXhlbHNcclxuICAgICAgICAgKiBAcGFyYW0gaGVpZ2h0ICBIZWlnaHQgb2YgdGhlIHNjcmVlbiBhcHBlbmRlciBpbiBwaXhlbHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBTY3JlZW5BcHBlbmRlcih3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIC8vIEB0b2RvIENsZWFuIHRoaXMgdXBcclxuICAgICAgICAgICAgdGhpcy5fbWVzc2FnZXMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5fY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy53aWR0aCA9IHdpZHRoIHx8IHdpbmRvdy5pbm5lcldpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLl9jYW52YXMuaGVpZ2h0ID0gaGVpZ2h0IHx8IHdpbmRvdy5pbm5lckhlaWdodDtcclxuICAgICAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuICAgICAgICAgICAgdGhpcy5fY3R4ID0gdGhpcy5fY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5fY2FudmFzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTG9ncyBhIG1lc3NhZ2UgYXQgdGhlIGdpdmVuIFtbTG9nTGV2ZWxdXVxyXG4gICAgICAgICAqIEBwYXJhbSBsZXZlbCAgTGV2ZWwgdG8gbG9nIGF0XHJcbiAgICAgICAgICogQHBhcmFtIGFyZ3MgICBBcmd1bWVudHMgdG8gbG9nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2NyZWVuQXBwZW5kZXIucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uIChsZXZlbCwgYXJncykge1xyXG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IGFyZ3Muam9pbignLCcpO1xyXG4gICAgICAgICAgICB0aGlzLl9jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuX2NhbnZhcy53aWR0aCwgdGhpcy5fY2FudmFzLmhlaWdodCk7XHJcbiAgICAgICAgICAgIHRoaXMuX21lc3NhZ2VzLnVuc2hpZnQoJ1snICsgTG9nTGV2ZWxbbGV2ZWxdICsgJ10gOiAnICsgbWVzc2FnZSk7XHJcbiAgICAgICAgICAgIHZhciBwb3MgPSAxMDtcclxuICAgICAgICAgICAgdmFyIG9wYWNpdHkgPSAxLjA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2N0eC5maWxsU3R5bGUgPSAncmdiYSgyNTUsMjU1LDI1NSwnICsgb3BhY2l0eS50b0ZpeGVkKDIpICsgJyknO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3R4LmZpbGxUZXh0KHRoaXMuX21lc3NhZ2VzW2ldLCAyMDAsIHBvcyk7XHJcbiAgICAgICAgICAgICAgICBwb3MgKz0gMTA7XHJcbiAgICAgICAgICAgICAgICBvcGFjaXR5ID0gb3BhY2l0eSA+IDAgPyBvcGFjaXR5IC0gLjA1IDogMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFNjcmVlbkFwcGVuZGVyO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuU2NyZWVuQXBwZW5kZXIgPSBTY3JlZW5BcHBlbmRlcjtcclxufSk7XHJcbmRlZmluZShcIkFjdGlvbnMvSUFjdGlvbmFibGVcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxufSk7XHJcbmRlZmluZShcIkdyb3VwXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiQWxnZWJyYVwiLCBcIkFjdGlvbnMvQWN0aW9uQ29udGV4dFwiLCBcIkFjdG9yXCIsIFwiVXRpbC9Mb2dcIiwgXCJDbGFzc1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIEFsZ2VicmFfMTAsIEFjdGlvbkNvbnRleHRfMSwgQWN0b3JfMywgTG9nXzEsIENsYXNzXzEpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHcm91cHMgYXJlIHVzZWQgZm9yIGxvZ2ljYWxseSBncm91cGluZyBBY3RvcnMgc28gdGhleSBjYW4gYmUgYWN0ZWQgdXBvblxyXG4gICAgICogaW4gYnVsay5cclxuICAgICAqXHJcbiAgICAgKiBbW2luY2x1ZGU6R3JvdXBzLm1kXV1cclxuICAgICAqL1xyXG4gICAgdmFyIEdyb3VwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoR3JvdXAsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gR3JvdXAobmFtZSwgc2NlbmUpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgICAgIF90aGlzLnNjZW5lID0gc2NlbmU7XHJcbiAgICAgICAgICAgIF90aGlzLl9sb2dnZXIgPSBMb2dfMS5Mb2dnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgX3RoaXMuX21lbWJlcnMgPSBbXTtcclxuICAgICAgICAgICAgX3RoaXMuYWN0aW9ucyA9IG5ldyBBY3Rpb25Db250ZXh0XzEuQWN0aW9uQ29udGV4dCgpO1xyXG4gICAgICAgICAgICBpZiAoc2NlbmUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci5lcnJvcignSW52YWxpZCBjb25zdHJ1Y3RvciBhcmd1bWVudHMgcGFzc2VkIHRvIEdyb3VwOiAnLCBuYW1lLCAnLCBzY2VuZSBtdXN0IG5vdCBiZSBudWxsIScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nR3JvdXAgPSBzY2VuZS5ncm91cHNbbmFtZV07XHJcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdHcm91cCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIud2FybignR3JvdXAgd2l0aCBuYW1lJywgbmFtZSwgJ2FscmVhZHkgZXhpc3RzLiBUaGlzIG5ldyBncm91cCB3aWxsIHJlcGxhY2UgaXQuJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzY2VuZS5ncm91cHNbbmFtZV0gPSBfdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEdyb3VwLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoYWN0b3JPckFjdG9ycykge1xyXG4gICAgICAgICAgICBpZiAoYWN0b3JPckFjdG9ycyBpbnN0YW5jZW9mIEFjdG9yXzMuQWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIGFjdG9yT3JBY3RvcnMgPSBbXS5jb25jYXQoYWN0b3JPckFjdG9ycyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSBhY3Rvck9yQWN0b3JzLmxlbmd0aCwgZ3JvdXBJZHg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBncm91cElkeCA9IHRoaXMuZ2V0TWVtYmVycygpLmluZGV4T2YoYWN0b3JPckFjdG9yc1tpXSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBJZHggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVtYmVycy5wdXNoKGFjdG9yT3JBY3RvcnNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUuYWRkKGFjdG9yT3JBY3RvcnNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5hZGRBY3RvclRvQ29udGV4dChhY3Rvck9yQWN0b3JzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci53aXJlKGFjdG9yT3JBY3RvcnNbaV0uZXZlbnREaXNwYXRjaGVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgR3JvdXAucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChhY3Rvcikge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9tZW1iZXJzLmluZGV4T2YoYWN0b3IpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWVtYmVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25zLnJlbW92ZUFjdG9yRnJvbUNvbnRleHQoYWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIudW53aXJlKGFjdG9yLmV2ZW50RGlzcGF0Y2hlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEdyb3VwLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24gKGFyZ3MpIHtcclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBtZW1iZXJzID0gdGhpcy5nZXRNZW1iZXJzKCksIGxlbiA9IG1lbWJlcnMubGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBhcmdzIGluc3RhbmNlb2YgQWxnZWJyYV8xMC5WZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVtYmVyc1tpXS5wb3MueCArPSBhcmdzLng7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVtYmVyc1tpXS5wb3MueSArPSBhcmdzLnk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgIHZhciB4ID0gYXJndW1lbnRzWzBdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHkgPSBhcmd1bWVudHNbMV07XHJcbiAgICAgICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIG1lbWJlcnNbaV0ucG9zLnggKz0geDtcclxuICAgICAgICAgICAgICAgICAgICBtZW1iZXJzW2ldLnBvcy55ICs9IHk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzIHBhc3NlZCB0byBncm91cCBtb3ZlJywgdGhpcy5uYW1lLCAnYXJnczonLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBHcm91cC5wcm90b3R5cGUucm90YXRlID0gZnVuY3Rpb24gKGFuZ2xlKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYW5nbGUgIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzIHBhc3NlZCB0byBncm91cCByb3RhdGUnLCB0aGlzLm5hbWUsICdhcmdzOicsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuZ2V0TWVtYmVycygpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1lbWJlciA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgIG1lbWJlci5yb3RhdGlvbiArPSBhbmdsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgR3JvdXAucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5vbihldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgR3JvdXAucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIub2ZmKGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBHcm91cC5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uICh0b3BpYywgZXZlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIuZW1pdCh0b3BpYywgZXZlbnQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgR3JvdXAucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKGFjdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE1lbWJlcnMoKS5pbmRleE9mKGFjdG9yKSA+IC0xO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgR3JvdXAucHJvdG90eXBlLmdldE1lbWJlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tZW1iZXJzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgR3JvdXAucHJvdG90eXBlLmdldFJhbmRvbU1lbWJlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21lbWJlcnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdGhpcy5fbWVtYmVycy5sZW5ndGgpXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEdyb3VwLnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE1lbWJlcnMoKS5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEuZ2V0Qm91bmRzKCk7IH0pLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3Vycikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXYuY29tYmluZShjdXJyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gR3JvdXA7XHJcbiAgICB9KENsYXNzXzEuQ2xhc3MpKTtcclxuICAgIGV4cG9ydHMuR3JvdXAgPSBHcm91cDtcclxufSk7XHJcbi8qKlxyXG4gKiBUaGVzZSBlZmZlY3RzIGNhbiBiZSBhcHBsaWVkIHRvIGFueSBiaXRtYXAgaW1hZ2UgYnV0IGFyZSBtYWlubHkgdXNlZFxyXG4gKiBmb3IgW1tTcHJpdGVdXSBlZmZlY3RzIG9yIFtbQW5pbWF0aW9uXV0gZWZmZWN0cy5cclxuICpcclxuICogW1tpbmNsdWRlOlNwcml0ZUVmZmVjdHMubWRdXVxyXG4gKi9cclxuZGVmaW5lKFwiRHJhd2luZy9TcHJpdGVFZmZlY3RzXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiRHJhd2luZy9Db2xvclwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIENvbG9yXzgpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBcIkdyYXlzY2FsZVwiIGVmZmVjdCB0byBhIHNwcml0ZSwgcmVtb3ZpbmcgY29sb3IgaW5mb3JtYXRpb24uXHJcbiAgICAgKi9cclxuICAgIHZhciBHcmF5c2NhbGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIEdyYXlzY2FsZSgpIHtcclxuICAgICAgICB9XHJcbiAgICAgICAgR3JheXNjYWxlLnByb3RvdHlwZS51cGRhdGVQaXhlbCA9IGZ1bmN0aW9uICh4LCB5LCBpbWFnZURhdGEpIHtcclxuICAgICAgICAgICAgdmFyIGZpcnN0UGl4ZWwgPSAoeCArIHkgKiBpbWFnZURhdGEud2lkdGgpICogNDtcclxuICAgICAgICAgICAgdmFyIHBpeGVsID0gaW1hZ2VEYXRhLmRhdGE7XHJcbiAgICAgICAgICAgIHZhciBhdmcgPSAocGl4ZWxbZmlyc3RQaXhlbCArIDBdICsgcGl4ZWxbZmlyc3RQaXhlbCArIDFdICsgcGl4ZWxbZmlyc3RQaXhlbCArIDJdKSAvIDM7XHJcbiAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAwXSA9IGF2ZztcclxuICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDFdID0gYXZnO1xyXG4gICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMl0gPSBhdmc7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gR3JheXNjYWxlO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuR3JheXNjYWxlID0gR3JheXNjYWxlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBcIkludmVydFwiIGVmZmVjdCB0byBhIHNwcml0ZSwgaW52ZXJ0aW5nIHRoZSBwaXhlbCBjb2xvcnMuXHJcbiAgICAgKi9cclxuICAgIHZhciBJbnZlcnQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIEludmVydCgpIHtcclxuICAgICAgICB9XHJcbiAgICAgICAgSW52ZXJ0LnByb3RvdHlwZS51cGRhdGVQaXhlbCA9IGZ1bmN0aW9uICh4LCB5LCBpbWFnZURhdGEpIHtcclxuICAgICAgICAgICAgdmFyIGZpcnN0UGl4ZWwgPSAoeCArIHkgKiBpbWFnZURhdGEud2lkdGgpICogNDtcclxuICAgICAgICAgICAgdmFyIHBpeGVsID0gaW1hZ2VEYXRhLmRhdGE7XHJcbiAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAwXSA9IDI1NSAtIHBpeGVsW2ZpcnN0UGl4ZWwgKyAwXTtcclxuICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDFdID0gMjU1IC0gcGl4ZWxbZmlyc3RQaXhlbCArIDFdO1xyXG4gICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMl0gPSAyNTUgLSBwaXhlbFtmaXJzdFBpeGVsICsgMl07XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gSW52ZXJ0O1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuSW52ZXJ0ID0gSW52ZXJ0O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBcIk9wYWNpdHlcIiBlZmZlY3QgdG8gYSBzcHJpdGUsIHNldHRpbmcgdGhlIGFscGhhIG9mIGFsbCBwaXhlbHMgdG8gYSBnaXZlbiB2YWx1ZS5cclxuICAgICAqL1xyXG4gICAgdmFyIE9wYWNpdHkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBvcGFjaXR5ICBUaGUgbmV3IG9wYWNpdHkgb2YgdGhlIHNwcml0ZSBmcm9tIDAtMS4wXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gT3BhY2l0eShvcGFjaXR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMub3BhY2l0eSA9IG9wYWNpdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9wYWNpdHkucHJvdG90eXBlLnVwZGF0ZVBpeGVsID0gZnVuY3Rpb24gKHgsIHksIGltYWdlRGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgZmlyc3RQaXhlbCA9ICh4ICsgeSAqIGltYWdlRGF0YS53aWR0aCkgKiA0O1xyXG4gICAgICAgICAgICB2YXIgcGl4ZWwgPSBpbWFnZURhdGEuZGF0YTtcclxuICAgICAgICAgICAgaWYgKHBpeGVsW2ZpcnN0UGl4ZWwgKyAzXSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDNdID0gTWF0aC5yb3VuZCh0aGlzLm9wYWNpdHkgKiBwaXhlbFtmaXJzdFBpeGVsICsgM10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gT3BhY2l0eTtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLk9wYWNpdHkgPSBPcGFjaXR5O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBcIkNvbG9yaXplXCIgZWZmZWN0IHRvIGEgc3ByaXRlLCBjaGFuZ2luZyB0aGUgY29sb3IgY2hhbm5lbHMgb2YgYWxsIHRoZSBwaXhlbHMgdG8gYW5cclxuICAgICAqIGF2ZXJhZ2Ugb2YgdGhlIG9yaWdpbmFsIGNvbG9yIGFuZCB0aGUgcHJvdmlkZWQgY29sb3JcclxuICAgICAqL1xyXG4gICAgdmFyIENvbG9yaXplID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gY29sb3IgIFRoZSBjb2xvciB0byBhcHBseSB0byB0aGUgc3ByaXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gQ29sb3JpemUoY29sb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBDb2xvcml6ZS5wcm90b3R5cGUudXBkYXRlUGl4ZWwgPSBmdW5jdGlvbiAoeCwgeSwgaW1hZ2VEYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciBmaXJzdFBpeGVsID0gKHggKyB5ICogaW1hZ2VEYXRhLndpZHRoKSAqIDQ7XHJcbiAgICAgICAgICAgIHZhciBwaXhlbCA9IGltYWdlRGF0YS5kYXRhO1xyXG4gICAgICAgICAgICBpZiAocGl4ZWxbZmlyc3RQaXhlbCArIDNdICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMF0gPSAocGl4ZWxbZmlyc3RQaXhlbCArIDBdICsgdGhpcy5jb2xvci5yKSAvIDI7XHJcbiAgICAgICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMV0gPSAocGl4ZWxbZmlyc3RQaXhlbCArIDFdICsgdGhpcy5jb2xvci5nKSAvIDI7XHJcbiAgICAgICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMl0gPSAocGl4ZWxbZmlyc3RQaXhlbCArIDJdICsgdGhpcy5jb2xvci5iKSAvIDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBDb2xvcml6ZTtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkNvbG9yaXplID0gQ29sb3JpemU7XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIFwiTGlnaHRlblwiIGVmZmVjdCB0byBhIHNwcml0ZSwgY2hhbmdlcyB0aGUgbGlnaHRuZXNzIG9mIHRoZSBjb2xvciBhY2NvcmRpbmcgdG8gSFNMXHJcbiAgICAgKi9cclxuICAgIHZhciBMaWdodGVuID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gZmFjdG9yICBUaGUgZmFjdG9yIG9mIHRoZSBlZmZlY3QgYmV0d2VlbiAwLTFcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBMaWdodGVuKGZhY3Rvcikge1xyXG4gICAgICAgICAgICBpZiAoZmFjdG9yID09PSB2b2lkIDApIHsgZmFjdG9yID0gMC4xOyB9XHJcbiAgICAgICAgICAgIHRoaXMuZmFjdG9yID0gZmFjdG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBMaWdodGVuLnByb3RvdHlwZS51cGRhdGVQaXhlbCA9IGZ1bmN0aW9uICh4LCB5LCBpbWFnZURhdGEpIHtcclxuICAgICAgICAgICAgdmFyIGZpcnN0UGl4ZWwgPSAoeCArIHkgKiBpbWFnZURhdGEud2lkdGgpICogNDtcclxuICAgICAgICAgICAgdmFyIHBpeGVsID0gaW1hZ2VEYXRhLmRhdGE7XHJcbiAgICAgICAgICAgIHZhciBjb2xvciA9IENvbG9yXzguQ29sb3IuZnJvbVJHQihwaXhlbFtmaXJzdFBpeGVsICsgMF0sIHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXSwgcGl4ZWxbZmlyc3RQaXhlbCArIDJdLCBwaXhlbFtmaXJzdFBpeGVsICsgM10pLmxpZ2h0ZW4odGhpcy5mYWN0b3IpO1xyXG4gICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMF0gPSBjb2xvci5yO1xyXG4gICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMV0gPSBjb2xvci5nO1xyXG4gICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMl0gPSBjb2xvci5iO1xyXG4gICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgM10gPSBjb2xvci5hO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIExpZ2h0ZW47XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5MaWdodGVuID0gTGlnaHRlbjtcclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgXCJEYXJrZW5cIiBlZmZlY3QgdG8gYSBzcHJpdGUsIGNoYW5nZXMgdGhlIGRhcmtuZXNzIG9mIHRoZSBjb2xvciBhY2NvcmRpbmcgdG8gSFNMXHJcbiAgICAgKi9cclxuICAgIHZhciBEYXJrZW4gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBmYWN0b3IgIFRoZSBmYWN0b3Igb2YgdGhlIGVmZmVjdCBiZXR3ZWVuIDAtMVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIERhcmtlbihmYWN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKGZhY3RvciA9PT0gdm9pZCAwKSB7IGZhY3RvciA9IDAuMTsgfVxyXG4gICAgICAgICAgICB0aGlzLmZhY3RvciA9IGZhY3RvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgRGFya2VuLnByb3RvdHlwZS51cGRhdGVQaXhlbCA9IGZ1bmN0aW9uICh4LCB5LCBpbWFnZURhdGEpIHtcclxuICAgICAgICAgICAgdmFyIGZpcnN0UGl4ZWwgPSAoeCArIHkgKiBpbWFnZURhdGEud2lkdGgpICogNDtcclxuICAgICAgICAgICAgdmFyIHBpeGVsID0gaW1hZ2VEYXRhLmRhdGE7XHJcbiAgICAgICAgICAgIHZhciBjb2xvciA9IENvbG9yXzguQ29sb3IuZnJvbVJHQihwaXhlbFtmaXJzdFBpeGVsICsgMF0sIHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXSwgcGl4ZWxbZmlyc3RQaXhlbCArIDJdLCBwaXhlbFtmaXJzdFBpeGVsICsgM10pLmRhcmtlbih0aGlzLmZhY3Rvcik7XHJcbiAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAwXSA9IGNvbG9yLnI7XHJcbiAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXSA9IGNvbG9yLmc7XHJcbiAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAyXSA9IGNvbG9yLmI7XHJcbiAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAzXSA9IGNvbG9yLmE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gRGFya2VuO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuRGFya2VuID0gRGFya2VuO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBcIlNhdHVyYXRlXCIgZWZmZWN0IHRvIGEgc3ByaXRlLCBzYXR1cmF0ZXMgdGhlIGNvbG9yIGFjY29yZGluZyB0byBIU0xcclxuICAgICAqL1xyXG4gICAgdmFyIFNhdHVyYXRlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gZmFjdG9yICBUaGUgZmFjdG9yIG9mIHRoZSBlZmZlY3QgYmV0d2VlbiAwLTFcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBTYXR1cmF0ZShmYWN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKGZhY3RvciA9PT0gdm9pZCAwKSB7IGZhY3RvciA9IDAuMTsgfVxyXG4gICAgICAgICAgICB0aGlzLmZhY3RvciA9IGZhY3RvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgU2F0dXJhdGUucHJvdG90eXBlLnVwZGF0ZVBpeGVsID0gZnVuY3Rpb24gKHgsIHksIGltYWdlRGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgZmlyc3RQaXhlbCA9ICh4ICsgeSAqIGltYWdlRGF0YS53aWR0aCkgKiA0O1xyXG4gICAgICAgICAgICB2YXIgcGl4ZWwgPSBpbWFnZURhdGEuZGF0YTtcclxuICAgICAgICAgICAgdmFyIGNvbG9yID0gQ29sb3JfOC5Db2xvci5mcm9tUkdCKHBpeGVsW2ZpcnN0UGl4ZWwgKyAwXSwgcGl4ZWxbZmlyc3RQaXhlbCArIDFdLCBwaXhlbFtmaXJzdFBpeGVsICsgMl0sIHBpeGVsW2ZpcnN0UGl4ZWwgKyAzXSkuc2F0dXJhdGUodGhpcy5mYWN0b3IpO1xyXG4gICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMF0gPSBjb2xvci5yO1xyXG4gICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMV0gPSBjb2xvci5nO1xyXG4gICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMl0gPSBjb2xvci5iO1xyXG4gICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgM10gPSBjb2xvci5hO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFNhdHVyYXRlO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuU2F0dXJhdGUgPSBTYXR1cmF0ZTtcclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgXCJEZXNhdHVyYXRlXCIgZWZmZWN0IHRvIGEgc3ByaXRlLCBkZXNhdHVyYXRlcyB0aGUgY29sb3IgYWNjb3JkaW5nIHRvIEhTTFxyXG4gICAgICovXHJcbiAgICB2YXIgRGVzYXR1cmF0ZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIGZhY3RvciAgVGhlIGZhY3RvciBvZiB0aGUgZWZmZWN0IGJldHdlZW4gMC0xXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gRGVzYXR1cmF0ZShmYWN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKGZhY3RvciA9PT0gdm9pZCAwKSB7IGZhY3RvciA9IDAuMTsgfVxyXG4gICAgICAgICAgICB0aGlzLmZhY3RvciA9IGZhY3RvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgRGVzYXR1cmF0ZS5wcm90b3R5cGUudXBkYXRlUGl4ZWwgPSBmdW5jdGlvbiAoeCwgeSwgaW1hZ2VEYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciBmaXJzdFBpeGVsID0gKHggKyB5ICogaW1hZ2VEYXRhLndpZHRoKSAqIDQ7XHJcbiAgICAgICAgICAgIHZhciBwaXhlbCA9IGltYWdlRGF0YS5kYXRhO1xyXG4gICAgICAgICAgICB2YXIgY29sb3IgPSBDb2xvcl84LkNvbG9yLmZyb21SR0IocGl4ZWxbZmlyc3RQaXhlbCArIDBdLCBwaXhlbFtmaXJzdFBpeGVsICsgMV0sIHBpeGVsW2ZpcnN0UGl4ZWwgKyAyXSwgcGl4ZWxbZmlyc3RQaXhlbCArIDNdKS5kZXNhdHVyYXRlKHRoaXMuZmFjdG9yKTtcclxuICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDBdID0gY29sb3IucjtcclxuICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDFdID0gY29sb3IuZztcclxuICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDJdID0gY29sb3IuYjtcclxuICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDNdID0gY29sb3IuYTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBEZXNhdHVyYXRlO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuRGVzYXR1cmF0ZSA9IERlc2F0dXJhdGU7XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIFwiRmlsbFwiIGVmZmVjdCB0byBhIHNwcml0ZSwgY2hhbmdpbmcgdGhlIGNvbG9yIGNoYW5uZWxzIG9mIGFsbCBub24tdHJhbnNwYXJlbnQgcGl4ZWxzIHRvIG1hdGNoXHJcbiAgICAgKiBhIGdpdmVuIGNvbG9yXHJcbiAgICAgKi9cclxuICAgIHZhciBGaWxsID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gY29sb3IgIFRoZSBjb2xvciB0byBhcHBseSB0byB0aGUgc3ByaXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gRmlsbChjb2xvcikge1xyXG4gICAgICAgICAgICB0aGlzLmNvbG9yID0gY29sb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEZpbGwucHJvdG90eXBlLnVwZGF0ZVBpeGVsID0gZnVuY3Rpb24gKHgsIHksIGltYWdlRGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgZmlyc3RQaXhlbCA9ICh4ICsgeSAqIGltYWdlRGF0YS53aWR0aCkgKiA0O1xyXG4gICAgICAgICAgICB2YXIgcGl4ZWwgPSBpbWFnZURhdGEuZGF0YTtcclxuICAgICAgICAgICAgaWYgKHBpeGVsW2ZpcnN0UGl4ZWwgKyAzXSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDBdID0gdGhpcy5jb2xvci5yO1xyXG4gICAgICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDFdID0gdGhpcy5jb2xvci5nO1xyXG4gICAgICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDJdID0gdGhpcy5jb2xvci5iO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gRmlsbDtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkZpbGwgPSBGaWxsO1xyXG59KTtcclxuZGVmaW5lKFwiSW50ZXJmYWNlcy9JRHJhd2FibGVcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxufSk7XHJcbmRlZmluZShcIkludGVyZmFjZXMvSUxvYWRhYmxlXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbn0pO1xyXG5kZWZpbmUoXCJSZXNvdXJjZXMvUmVzb3VyY2VcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJDbGFzc1wiLCBcIlByb21pc2VzXCIsIFwiVXRpbC9Mb2dcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBDbGFzc18yLCBQcm9taXNlc18zLCBMb2dfMikge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBbW1Jlc291cmNlXV0gdHlwZSBhbGxvd3MgZ2FtZXMgYnVpbHQgaW4gRXhjYWxpYnVyIHRvIGxvYWQgZ2VuZXJpYyByZXNvdXJjZXMuXHJcbiAgICAgKiBGb3IgYW55IHR5cGUgb2YgcmVtb3RlIHJlc291cmNlIGl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSBbW1Jlc291cmNlXV0gZm9yIHByZWxvYWRpbmcuXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOlJlc291cmNlcy5tZF1dXHJcbiAgICAgKi9cclxuICAgIHZhciBSZXNvdXJjZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFJlc291cmNlLCBfc3VwZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBwYXRoICAgICAgICAgIFBhdGggdG8gdGhlIHJlbW90ZSByZXNvdXJjZVxyXG4gICAgICAgICAqIEBwYXJhbSByZXNwb25zZVR5cGUgIFRoZSB0eXBlIHRvIGV4cGVjdCBhcyBhIHJlc3BvbnNlOiBcIlwiIHwgXCJhcnJheWJ1ZmZlclwiIHwgXCJibG9iXCIgfCBcImRvY3VtZW50XCIgfCBcImpzb25cIiB8IFwidGV4dFwiO1xyXG4gICAgICAgICAqIEBwYXJhbSBidXN0Q2FjaGUgICAgIFdoZXRoZXIgb3Igbm90IHRvIGNhY2hlLWJ1c3QgcmVxdWVzdHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBSZXNvdXJjZShwYXRoLCByZXNwb25zZVR5cGUsIGJ1c3RDYWNoZSkge1xyXG4gICAgICAgICAgICBpZiAoYnVzdENhY2hlID09PSB2b2lkIDApIHsgYnVzdENhY2hlID0gdHJ1ZTsgfVxyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5wYXRoID0gcGF0aDtcclxuICAgICAgICAgICAgX3RoaXMucmVzcG9uc2VUeXBlID0gcmVzcG9uc2VUeXBlO1xyXG4gICAgICAgICAgICBfdGhpcy5idXN0Q2FjaGUgPSBidXN0Q2FjaGU7XHJcbiAgICAgICAgICAgIF90aGlzLmRhdGEgPSBudWxsO1xyXG4gICAgICAgICAgICBfdGhpcy5sb2dnZXIgPSBMb2dfMi5Mb2dnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgX3RoaXMub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuOyB9O1xyXG4gICAgICAgICAgICBfdGhpcy5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XHJcbiAgICAgICAgICAgIF90aGlzLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7IHJldHVybjsgfTtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIFJlc291cmNlIGlzIGNvbXBsZXRlbHkgbG9hZGVkIGFuZCBpcyByZWFkeVxyXG4gICAgICAgICAqIHRvIGJlIGRyYXduLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlc291cmNlLnByb3RvdHlwZS5pc0xvYWRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YSAhPT0gbnVsbDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFJlc291cmNlLnByb3RvdHlwZS53aXJlRW5naW5lID0gZnVuY3Rpb24gKF9lbmdpbmUpIHtcclxuICAgICAgICAgICAgLy8gb3ZlcnJpZGUgbWVcclxuICAgICAgICB9O1xyXG4gICAgICAgIFJlc291cmNlLnByb3RvdHlwZS5fY2FjaGVCdXN0ID0gZnVuY3Rpb24gKHVyaSkge1xyXG4gICAgICAgICAgICB2YXIgcXVlcnkgPSAvXFw/XFx3Kj1cXHcqLztcclxuICAgICAgICAgICAgaWYgKHF1ZXJ5LnRlc3QodXJpKSkge1xyXG4gICAgICAgICAgICAgICAgdXJpICs9ICgnJl9fPScgKyBEYXRlLm5vdygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHVyaSArPSAoJz9fXz0nICsgRGF0ZS5ub3coKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHVyaTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFJlc291cmNlLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdTdGFydGVkIGxvYWRpbmcgcmVzb3VyY2UgJyArIHRoaXMucGF0aCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCZWdpbiBsb2FkaW5nIHRoZSByZXNvdXJjZSBhbmQgcmV0dXJucyBhIHByb21pc2UgdG8gYmUgcmVzb2x2ZWQgb24gY29tcGxldGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlc291cmNlLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgY29tcGxldGUgPSBuZXcgUHJvbWlzZXNfMy5Qcm9taXNlKCk7XHJcbiAgICAgICAgICAgIC8vIEV4aXQgZWFybHkgaWYgd2UgYWxyZWFkeSBoYXZlIGRhdGFcclxuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ0FscmVhZHkgaGF2ZSBkYXRhIGZvciByZXNvdXJjZScsIHRoaXMucGF0aCk7XHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZS5yZXNvbHZlKHRoaXMuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uY29tcGxldGUoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgICAgICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIHRoaXMuYnVzdENhY2hlID8gdGhpcy5fY2FjaGVCdXN0KHRoaXMucGF0aCkgOiB0aGlzLnBhdGgsIHRydWUpO1xyXG4gICAgICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IHRoaXMucmVzcG9uc2VUeXBlO1xyXG4gICAgICAgICAgICByZXF1ZXN0Lm9ubG9hZHN0YXJ0ID0gZnVuY3Rpb24gKCkgeyBfdGhpcy5fc3RhcnQoKTsgfTtcclxuICAgICAgICAgICAgcmVxdWVzdC5vbnByb2dyZXNzID0gdGhpcy5vbnByb2dyZXNzO1xyXG4gICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSB0aGlzLm9uZXJyb3I7XHJcbiAgICAgICAgICAgIHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgLy8gWEhSIG9uIGZpbGU6Ly8gc3VjY2VzcyBzdGF0dXMgaXMgMCwgc3VjaCBhcyB3aXRoIFBoYW50b21KU1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzICE9PSAwICYmIHJlcXVlc3Quc3RhdHVzICE9PSAyMDApIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBsb2FkIHJlc291cmNlICcsIF90aGlzLnBhdGgsICcgc2VydmVyIHJlc3BvbmRlZCB3aXRoIGVycm9yIGNvZGUnLCByZXF1ZXN0LnN0YXR1cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub25lcnJvcihyZXF1ZXN0LnJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZS5yZXNvbHZlKHJlcXVlc3QucmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF90aGlzLmRhdGEgPSBfdGhpcy5wcm9jZXNzRGF0YShyZXF1ZXN0LnJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLm9uY29tcGxldGUoKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5kZWJ1ZygnQ29tcGxldGVkIGxvYWRpbmcgcmVzb3VyY2UnLCBfdGhpcy5wYXRoKTtcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlLnJlc29sdmUoX3RoaXMuZGF0YSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJlcXVlc3Quc2VuZCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gY29tcGxldGU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBsb2FkZWQgZGF0YSBvbmNlIHRoZSByZXNvdXJjZSBpcyBsb2FkZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBSZXNvdXJjZS5wcm90b3R5cGUuZ2V0RGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIGRhdGEgZm9yIHRoaXMgcmVzb3VyY2UgZGlyZWN0bHlcclxuICAgICAgICAgKi9cclxuICAgICAgICBSZXNvdXJjZS5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IHRoaXMucHJvY2Vzc0RhdGEoZGF0YSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBpcyBtZWFudCB0byBiZSBvdmVycmlkZW4gdG8gaGFuZGxlIGFueSBhZGRpdGlvbmFsXHJcbiAgICAgICAgICogcHJvY2Vzc2luZy4gU3VjaCBhcyBkZWNvZGluZyBkb3dubG9hZGVkIGF1ZGlvIGJpdHMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVzb3VyY2UucHJvdG90eXBlLnByb2Nlc3NEYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1hNTEh0dHBSZXF1ZXN0L3Jlc3BvbnNlVHlwZVxyXG4gICAgICAgICAgICAvLyBCbG9iIHJlcXVpcmVzIGFuIG9iamVjdCB1cmxcclxuICAgICAgICAgICAgaWYgKHRoaXMucmVzcG9uc2VUeXBlID09PSAnYmxvYicpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKGRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFJlc291cmNlO1xyXG4gICAgfShDbGFzc18yLkNsYXNzKSk7XHJcbiAgICBleHBvcnRzLlJlc291cmNlID0gUmVzb3VyY2U7XHJcbn0pO1xyXG5kZWZpbmUoXCJSZXNvdXJjZXMvVGV4dHVyZVwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIlJlc291cmNlcy9SZXNvdXJjZVwiLCBcIlByb21pc2VzXCIsIFwiRHJhd2luZy9TcHJpdGVcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBSZXNvdXJjZV8xLCBQcm9taXNlc180LCBTcHJpdGVfMSkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBbW1RleHR1cmVdXSBvYmplY3QgYWxsb3dzIGdhbWVzIGJ1aWx0IGluIEV4Y2FsaWJ1ciB0byBsb2FkIGltYWdlIHJlc291cmNlcy5cclxuICAgICAqIFtbVGV4dHVyZV1dIGlzIGFuIFtbSUxvYWRhYmxlXV0gd2hpY2ggbWVhbnMgaXQgY2FuIGJlIHBhc3NlZCB0byBhIFtbTG9hZGVyXV1cclxuICAgICAqIHRvIHByZS1sb2FkIGJlZm9yZSBzdGFydGluZyBhIGxldmVsIG9yIGdhbWUuXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOlRleHR1cmVzLm1kXV1cclxuICAgICAqL1xyXG4gICAgdmFyIFRleHR1cmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhUZXh0dXJlLCBfc3VwZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBwYXRoICAgICAgIFBhdGggdG8gdGhlIGltYWdlIHJlc291cmNlXHJcbiAgICAgICAgICogQHBhcmFtIGJ1c3RDYWNoZSAgT3B0aW9uYWxseSBsb2FkIHRleHR1cmUgd2l0aCBjYWNoZSBidXN0aW5nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gVGV4dHVyZShwYXRoLCBidXN0Q2FjaGUpIHtcclxuICAgICAgICAgICAgaWYgKGJ1c3RDYWNoZSA9PT0gdm9pZCAwKSB7IGJ1c3RDYWNoZSA9IHRydWU7IH1cclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcGF0aCwgJ2Jsb2InLCBidXN0Q2FjaGUpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLnBhdGggPSBwYXRoO1xyXG4gICAgICAgICAgICBfdGhpcy5idXN0Q2FjaGUgPSBidXN0Q2FjaGU7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIFtbUHJvbWlzZV1dIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgVGV4dHVyZSBpcyBsb2FkZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5sb2FkZWQgPSBuZXcgUHJvbWlzZXNfNC5Qcm9taXNlKCk7XHJcbiAgICAgICAgICAgIF90aGlzLl9pc0xvYWRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBfdGhpcy5fc3ByaXRlID0gbnVsbDtcclxuICAgICAgICAgICAgX3RoaXMuX3Nwcml0ZSA9IG5ldyBTcHJpdGVfMS5TcHJpdGUoX3RoaXMsIDAsIDAsIDAsIDApO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgVGV4dHVyZSBpcyBjb21wbGV0ZWx5IGxvYWRlZCBhbmQgaXMgcmVhZHlcclxuICAgICAgICAgKiB0byBiZSBkcmF3bi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBUZXh0dXJlLnByb3RvdHlwZS5pc0xvYWRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzTG9hZGVkO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQmVnaW5zIGxvYWRpbmcgdGhlIHRleHR1cmUgYW5kIHJldHVybnMgYSBwcm9taXNlIHRvIGJlIHJlc29sdmVkIG9uIGNvbXBsZXRpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBUZXh0dXJlLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgY29tcGxldGUgPSBuZXcgUHJvbWlzZXNfNC5Qcm9taXNlKCk7XHJcbiAgICAgICAgICAgIHZhciBsb2FkZWQgPSBfc3VwZXIucHJvdG90eXBlLmxvYWQuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgbG9hZGVkLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2lzTG9hZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy53aWR0aCA9IF90aGlzLl9zcHJpdGUuc3dpZHRoID0gX3RoaXMuX3Nwcml0ZS5uYXR1cmFsV2lkdGggPSBfdGhpcy5fc3ByaXRlLndpZHRoID0gX3RoaXMuaW1hZ2UubmF0dXJhbFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmhlaWdodCA9IF90aGlzLl9zcHJpdGUuc2hlaWdodCA9IF90aGlzLl9zcHJpdGUubmF0dXJhbEhlaWdodCA9IF90aGlzLl9zcHJpdGUuaGVpZ2h0ID0gX3RoaXMuaW1hZ2UubmF0dXJhbEhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2FkZWQucmVzb2x2ZShfdGhpcy5pbWFnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGUucmVzb2x2ZShfdGhpcy5pbWFnZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmltYWdlLnNyYyA9IF9zdXBlci5wcm90b3R5cGUuZ2V0RGF0YS5jYWxsKF90aGlzKTtcclxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29tcGxldGUucmVqZWN0KCdFcnJvciBsb2FkaW5nIHRleHR1cmUuJyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gY29tcGxldGU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBUZXh0dXJlLnByb3RvdHlwZS5hc1Nwcml0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Nwcml0ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBUZXh0dXJlO1xyXG4gICAgfShSZXNvdXJjZV8xLlJlc291cmNlKSk7XHJcbiAgICBleHBvcnRzLlRleHR1cmUgPSBUZXh0dXJlO1xyXG59KTtcclxuZGVmaW5lKFwiRHJhd2luZy9TcHJpdGVcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJEcmF3aW5nL1Nwcml0ZUVmZmVjdHNcIiwgXCJEcmF3aW5nL0NvbG9yXCIsIFwiUmVzb3VyY2VzL1RleHR1cmVcIiwgXCJBbGdlYnJhXCIsIFwiVXRpbC9Mb2dcIiwgXCJVdGlsL1V0aWxcIiwgXCJDb25maWd1cmFibGVcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBFZmZlY3RzLCBDb2xvcl85LCBUZXh0dXJlXzEsIEFsZ2VicmFfMTEsIExvZ18zLCBVdGlsXzIsIENvbmZpZ3VyYWJsZV8xKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogQGhpZGRlblxyXG4gICAgICovXHJcbiAgICB2YXIgU3ByaXRlSW1wbCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIGltYWdlICAgVGhlIGJhY2tpbmcgaW1hZ2UgdGV4dHVyZSB0byBidWlsZCB0aGUgU3ByaXRlXHJcbiAgICAgICAgICogQHBhcmFtIHN4ICAgICAgVGhlIHggcG9zaXRpb24gb2YgdGhlIHNwcml0ZVxyXG4gICAgICAgICAqIEBwYXJhbSBzeSAgICAgIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBzcHJpdGVcclxuICAgICAgICAgKiBAcGFyYW0gc3dpZHRoICBUaGUgd2lkdGggb2YgdGhlIHNwcml0ZSBpbiBwaXhlbHNcclxuICAgICAgICAgKiBAcGFyYW0gc2hlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSBzcHJpdGUgaW4gcGl4ZWxzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gU3ByaXRlSW1wbChpbWFnZU9yQ29uZmlnLCBzeCwgc3ksIHN3aWR0aCwgc2hlaWdodCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uID0gMC4wO1xyXG4gICAgICAgICAgICB0aGlzLmFuY2hvciA9IG5ldyBBbGdlYnJhXzExLlZlY3RvcigwLjAsIDAuMCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2NhbGUgPSBuZXcgQWxnZWJyYV8xMS5WZWN0b3IoMSwgMSk7XHJcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyID0gTG9nXzMuTG9nZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBEcmF3cyB0aGUgc3ByaXRlIGZsaXBwZWQgdmVydGljYWxseVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5mbGlwVmVydGljYWwgPSBmYWxzZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERyYXdzIHRoZSBzcHJpdGUgZmxpcHBlZCBob3Jpem9udGFsbHlcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuZmxpcEhvcml6b250YWwgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy53aWR0aCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5lZmZlY3RzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuc3ggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLnN5ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5zd2lkdGggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLnNoZWlnaHQgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLm5hdHVyYWxXaWR0aCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMubmF0dXJhbEhlaWdodCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3Nwcml0ZUNhbnZhcyA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuX3Nwcml0ZUN0eCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuX3BpeGVsRGF0YSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuX3BpeGVsc0xvYWRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9kaXJ0eUVmZmVjdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoc3ggPCAwIHx8IHN5IDwgMCB8fCBzd2lkdGggPCAwIHx8IHNoZWlnaHQgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcignU3ByaXRlIGNhbm5vdCBoYXZlIGFueSBuZWdhdGl2ZSBkaW1lbnNpb25zIHg6Jywgc3gsICd5OicsIHN5LCAnd2lkdGg6Jywgc3dpZHRoLCAnaGVpZ2h0OicsIHNoZWlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpbWFnZSA9IGltYWdlT3JDb25maWc7XHJcbiAgICAgICAgICAgIGlmIChpbWFnZU9yQ29uZmlnICYmICEoaW1hZ2VPckNvbmZpZyBpbnN0YW5jZW9mIFRleHR1cmVfMS5UZXh0dXJlKSkge1xyXG4gICAgICAgICAgICAgICAgc3ggPSBpbWFnZU9yQ29uZmlnLnN4O1xyXG4gICAgICAgICAgICAgICAgc3kgPSBpbWFnZU9yQ29uZmlnLnN5O1xyXG4gICAgICAgICAgICAgICAgc3dpZHRoID0gaW1hZ2VPckNvbmZpZy5zd2lkdGg7XHJcbiAgICAgICAgICAgICAgICBzaGVpZ2h0ID0gaW1hZ2VPckNvbmZpZy5zaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgaW1hZ2UgPSBpbWFnZU9yQ29uZmlnLmltYWdlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc3ggPSBzeCB8fCAwO1xyXG4gICAgICAgICAgICB0aGlzLnN5ID0gc3kgfHwgMDtcclxuICAgICAgICAgICAgdGhpcy5zd2lkdGggPSBzd2lkdGggfHwgMDtcclxuICAgICAgICAgICAgdGhpcy5zaGVpZ2h0ID0gc2hlaWdodCB8fCAwO1xyXG4gICAgICAgICAgICB0aGlzLl90ZXh0dXJlID0gaW1hZ2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3Nwcml0ZUNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgICAgICB0aGlzLl9zcHJpdGVDYW52YXMud2lkdGggPSBzd2lkdGg7XHJcbiAgICAgICAgICAgIHRoaXMuX3Nwcml0ZUNhbnZhcy5oZWlnaHQgPSBzaGVpZ2h0O1xyXG4gICAgICAgICAgICB0aGlzLl9zcHJpdGVDdHggPSB0aGlzLl9zcHJpdGVDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICAgICAgdGhpcy5fdGV4dHVyZS5sb2FkZWQudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fc3ByaXRlQ2FudmFzLndpZHRoID0gX3RoaXMuX3Nwcml0ZUNhbnZhcy53aWR0aCB8fCBfdGhpcy5fdGV4dHVyZS5pbWFnZS5uYXR1cmFsV2lkdGg7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fc3ByaXRlQ2FudmFzLmhlaWdodCA9IF90aGlzLl9zcHJpdGVDYW52YXMuaGVpZ2h0IHx8IF90aGlzLl90ZXh0dXJlLmltYWdlLm5hdHVyYWxIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9hZFBpeGVscygpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2RpcnR5RWZmZWN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSkuZXJyb3IoZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5lcnJvcignRXJyb3IgbG9hZGluZyB0ZXh0dXJlICcsIF90aGlzLl90ZXh0dXJlLnBhdGgsIGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHN3aWR0aDtcclxuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBzaGVpZ2h0O1xyXG4gICAgICAgICAgICB0aGlzLm5hdHVyYWxXaWR0aCA9IHN3aWR0aDtcclxuICAgICAgICAgICAgdGhpcy5uYXR1cmFsSGVpZ2h0ID0gc2hlaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgU3ByaXRlSW1wbC5wcm90b3R5cGUuX2xvYWRQaXhlbHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl90ZXh0dXJlLmlzTG9hZGVkKCkgJiYgIXRoaXMuX3BpeGVsc0xvYWRlZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5hdHVyYWxXaWR0aCA9IHRoaXMuX3RleHR1cmUuaW1hZ2UubmF0dXJhbFdpZHRoIHx8IDA7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmF0dXJhbEhlaWdodCA9IHRoaXMuX3RleHR1cmUuaW1hZ2UubmF0dXJhbEhlaWdodCB8fCAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3dpZHRoID4gbmF0dXJhbFdpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybignVGhlIHNwcml0ZSB3aWR0aCcsIHRoaXMuc3dpZHRoLCAnZXhjZWVkcyB0aGUgd2lkdGgnLCBuYXR1cmFsV2lkdGgsICdvZiB0aGUgYmFja2luZyB0ZXh0dXJlJywgdGhpcy5fdGV4dHVyZS5wYXRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNoZWlnaHQgPiBuYXR1cmFsSGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybignVGhlIHNwcml0ZSBoZWlnaHQnLCB0aGlzLnNoZWlnaHQsICdleGNlZWRzIHRoZSBoZWlnaHQnLCBuYXR1cmFsSGVpZ2h0LCAnb2YgdGhlIGJhY2tpbmcgdGV4dHVyZScsIHRoaXMuX3RleHR1cmUucGF0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zcHJpdGVDdHguZHJhd0ltYWdlKHRoaXMuX3RleHR1cmUuaW1hZ2UsIFV0aWxfMi5jbGFtcCh0aGlzLnN4LCAwLCBuYXR1cmFsV2lkdGgpLCBVdGlsXzIuY2xhbXAodGhpcy5zeSwgMCwgbmF0dXJhbEhlaWdodCksIFV0aWxfMi5jbGFtcCh0aGlzLnN3aWR0aCwgMCwgbmF0dXJhbFdpZHRoKSwgVXRpbF8yLmNsYW1wKHRoaXMuc2hlaWdodCwgMCwgbmF0dXJhbEhlaWdodCksIDAsIDAsIHRoaXMuc3dpZHRoLCB0aGlzLnNoZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGl4ZWxzTG9hZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXBwbGllcyB0aGUgW1tPcGFjaXR5XV0gZWZmZWN0IHRvIGEgc3ByaXRlLCBzZXR0aW5nIHRoZSBhbHBoYSBvZiBhbGwgcGl4ZWxzIHRvIGEgZ2l2ZW4gdmFsdWVcclxuICAgICAgICAgKi9cclxuICAgICAgICBTcHJpdGVJbXBsLnByb3RvdHlwZS5vcGFjaXR5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRWZmZWN0KG5ldyBFZmZlY3RzLk9wYWNpdHkodmFsdWUpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFwcGxpZXMgdGhlIFtbR3JheXNjYWxlXV0gZWZmZWN0IHRvIGEgc3ByaXRlLCByZW1vdmluZyBjb2xvciBpbmZvcm1hdGlvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBTcHJpdGVJbXBsLnByb3RvdHlwZS5ncmF5c2NhbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRWZmZWN0KG5ldyBFZmZlY3RzLkdyYXlzY2FsZSgpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFwcGxpZXMgdGhlIFtbSW52ZXJ0XV0gZWZmZWN0IHRvIGEgc3ByaXRlLCBpbnZlcnRpbmcgdGhlIHBpeGVsIGNvbG9ycy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBTcHJpdGVJbXBsLnByb3RvdHlwZS5pbnZlcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRWZmZWN0KG5ldyBFZmZlY3RzLkludmVydCgpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFwcGxpZXMgdGhlIFtbRmlsbF1dIGVmZmVjdCB0byBhIHNwcml0ZSwgY2hhbmdpbmcgdGhlIGNvbG9yIGNoYW5uZWxzIG9mIGFsbCBub24tdHJhbnNwYXJlbnQgcGl4ZWxzIHRvIG1hdGNoIGEgZ2l2ZW4gY29sb3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBTcHJpdGVJbXBsLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKGNvbG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRWZmZWN0KG5ldyBFZmZlY3RzLkZpbGwoY29sb3IpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFwcGxpZXMgdGhlIFtbQ29sb3JpemVdXSBlZmZlY3QgdG8gYSBzcHJpdGUsIGNoYW5naW5nIHRoZSBjb2xvciBjaGFubmVscyBvZiBhbGwgcGl4ZWxzIHRvIGJlIHRoZSBhdmVyYWdlIG9mIHRoZSBvcmlnaW5hbCBjb2xvclxyXG4gICAgICAgICAqIGFuZCB0aGUgcHJvdmlkZWQgY29sb3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU3ByaXRlSW1wbC5wcm90b3R5cGUuY29sb3JpemUgPSBmdW5jdGlvbiAoY29sb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRFZmZlY3QobmV3IEVmZmVjdHMuQ29sb3JpemUoY29sb3IpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFwcGxpZXMgdGhlIFtbTGlnaHRlbl1dIGVmZmVjdCB0byBhIHNwcml0ZSwgY2hhbmdlcyB0aGUgbGlnaHRuZXNzIG9mIHRoZSBjb2xvciBhY2NvcmRpbmcgdG8gSFNMXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU3ByaXRlSW1wbC5wcm90b3R5cGUubGlnaHRlbiA9IGZ1bmN0aW9uIChmYWN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKGZhY3RvciA9PT0gdm9pZCAwKSB7IGZhY3RvciA9IDAuMTsgfVxyXG4gICAgICAgICAgICB0aGlzLmFkZEVmZmVjdChuZXcgRWZmZWN0cy5MaWdodGVuKGZhY3RvcikpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXBwbGllcyB0aGUgW1tEYXJrZW5dXSBlZmZlY3QgdG8gYSBzcHJpdGUsIGNoYW5nZXMgdGhlIGRhcmtuZXNzIG9mIHRoZSBjb2xvciBhY2NvcmRpbmcgdG8gSFNMXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU3ByaXRlSW1wbC5wcm90b3R5cGUuZGFya2VuID0gZnVuY3Rpb24gKGZhY3Rvcikge1xyXG4gICAgICAgICAgICBpZiAoZmFjdG9yID09PSB2b2lkIDApIHsgZmFjdG9yID0gMC4xOyB9XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRWZmZWN0KG5ldyBFZmZlY3RzLkRhcmtlbihmYWN0b3IpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFwcGxpZXMgdGhlIFtbU2F0dXJhdGVdXSBlZmZlY3QgdG8gYSBzcHJpdGUsIHNhdHVyYXRlcyB0aGUgY29sb3IgYWNjb3JkaW5nIHRvIEhTTFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNwcml0ZUltcGwucHJvdG90eXBlLnNhdHVyYXRlID0gZnVuY3Rpb24gKGZhY3Rvcikge1xyXG4gICAgICAgICAgICBpZiAoZmFjdG9yID09PSB2b2lkIDApIHsgZmFjdG9yID0gMC4xOyB9XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRWZmZWN0KG5ldyBFZmZlY3RzLlNhdHVyYXRlKGZhY3RvcikpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXBwbGllcyB0aGUgW1tEZXNhdHVyYXRlXV0gZWZmZWN0IHRvIGEgc3ByaXRlLCBkZXNhdHVyYXRlcyB0aGUgY29sb3IgYWNjb3JkaW5nIHRvIEhTTFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNwcml0ZUltcGwucHJvdG90eXBlLmRlc2F0dXJhdGUgPSBmdW5jdGlvbiAoZmFjdG9yKSB7XHJcbiAgICAgICAgICAgIGlmIChmYWN0b3IgPT09IHZvaWQgMCkgeyBmYWN0b3IgPSAwLjE7IH1cclxuICAgICAgICAgICAgdGhpcy5hZGRFZmZlY3QobmV3IEVmZmVjdHMuRGVzYXR1cmF0ZShmYWN0b3IpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYSBuZXcgW1tJU3ByaXRlRWZmZWN0XV0gdG8gdGhpcyBkcmF3aW5nLlxyXG4gICAgICAgICAqIEBwYXJhbSBlZmZlY3QgIEVmZmVjdCB0byBhZGQgdG8gdGhlIHRoaXMgZHJhd2luZ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNwcml0ZUltcGwucHJvdG90eXBlLmFkZEVmZmVjdCA9IGZ1bmN0aW9uIChlZmZlY3QpIHtcclxuICAgICAgICAgICAgdGhpcy5lZmZlY3RzLnB1c2goZWZmZWN0KTtcclxuICAgICAgICAgICAgLy8gV2UgbXVzdCBjaGVjayBpZiB0aGUgdGV4dHVyZSBhbmQgdGhlIGJhY2tpbmcgc3ByaXRlIHBpeGVscyBhcmUgbG9hZGVkIGFzIHdlbGwgYmVmb3JlIFxyXG4gICAgICAgICAgICAvLyBhbiBlZmZlY3QgY2FuIGJlIGFwcGxpZWRcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl90ZXh0dXJlLmlzTG9hZGVkKCkgfHwgIXRoaXMuX3BpeGVsc0xvYWRlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlydHlFZmZlY3QgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYXBwbHlFZmZlY3RzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFNwcml0ZUltcGwucHJvdG90eXBlLnJlbW92ZUVmZmVjdCA9IGZ1bmN0aW9uIChwYXJhbSkge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXhUb1JlbW92ZSA9IC0xO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcmFtID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgaW5kZXhUb1JlbW92ZSA9IHBhcmFtO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaW5kZXhUb1JlbW92ZSA9IHRoaXMuZWZmZWN0cy5pbmRleE9mKHBhcmFtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBib3VuZHMgY2hlY2tcclxuICAgICAgICAgICAgaWYgKGluZGV4VG9SZW1vdmUgPCAwIHx8IGluZGV4VG9SZW1vdmUgPj0gdGhpcy5lZmZlY3RzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZWZmZWN0cy5zcGxpY2UoaW5kZXhUb1JlbW92ZSwgMSk7XHJcbiAgICAgICAgICAgIC8vIFdlIG11c3QgY2hlY2sgaWYgdGhlIHRleHR1cmUgYW5kIHRoZSBiYWNraW5nIHNwcml0ZSBwaXhlbHMgYXJlIGxvYWRlZCBhcyB3ZWxsIGJlZm9yZSBcclxuICAgICAgICAgICAgLy8gYW4gZWZmZWN0IGNhbiBiZSBhcHBsaWVkXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fdGV4dHVyZS5pc0xvYWRlZCgpIHx8ICF0aGlzLl9waXhlbHNMb2FkZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RpcnR5RWZmZWN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5RWZmZWN0cygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTcHJpdGVJbXBsLnByb3RvdHlwZS5fYXBwbHlFZmZlY3RzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbmF0dXJhbFdpZHRoID0gdGhpcy5fdGV4dHVyZS5pbWFnZS5uYXR1cmFsV2lkdGggfHwgMDtcclxuICAgICAgICAgICAgdmFyIG5hdHVyYWxIZWlnaHQgPSB0aGlzLl90ZXh0dXJlLmltYWdlLm5hdHVyYWxIZWlnaHQgfHwgMDtcclxuICAgICAgICAgICAgdGhpcy5fc3ByaXRlQ3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLnN3aWR0aCwgdGhpcy5zaGVpZ2h0KTtcclxuICAgICAgICAgICAgdGhpcy5fc3ByaXRlQ3R4LmRyYXdJbWFnZSh0aGlzLl90ZXh0dXJlLmltYWdlLCBVdGlsXzIuY2xhbXAodGhpcy5zeCwgMCwgbmF0dXJhbFdpZHRoKSwgVXRpbF8yLmNsYW1wKHRoaXMuc3ksIDAsIG5hdHVyYWxIZWlnaHQpLCBVdGlsXzIuY2xhbXAodGhpcy5zd2lkdGgsIDAsIG5hdHVyYWxXaWR0aCksIFV0aWxfMi5jbGFtcCh0aGlzLnNoZWlnaHQsIDAsIG5hdHVyYWxIZWlnaHQpLCAwLCAwLCB0aGlzLnN3aWR0aCwgdGhpcy5zaGVpZ2h0KTtcclxuICAgICAgICAgICAgdGhpcy5fcGl4ZWxEYXRhID0gdGhpcy5fc3ByaXRlQ3R4LmdldEltYWdlRGF0YSgwLCAwLCB0aGlzLnN3aWR0aCwgdGhpcy5zaGVpZ2h0KTtcclxuICAgICAgICAgICAgdmFyIGkgPSAwLCB4ID0gMCwgeSA9IDAsIGxlbiA9IHRoaXMuZWZmZWN0cy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB5ID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoeTsgeSA8IHRoaXMuc2hlaWdodDsgeSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh4OyB4IDwgdGhpcy5zd2lkdGg7IHgrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVmZmVjdHNbaV0udXBkYXRlUGl4ZWwoeCwgeSwgdGhpcy5fcGl4ZWxEYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fc3ByaXRlQ3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLnN3aWR0aCwgdGhpcy5zaGVpZ2h0KTtcclxuICAgICAgICAgICAgdGhpcy5fc3ByaXRlQ3R4LnB1dEltYWdlRGF0YSh0aGlzLl9waXhlbERhdGEsIDAsIDApO1xyXG4gICAgICAgICAgICB0aGlzLl9kaXJ0eUVmZmVjdCA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2xlYXJzIGFsbCBlZmZlY3RzIGZyb20gdGhlIGRyYXdpbmcgYW5kIHJldHVybiBpdCB0byBpdHMgb3JpZ2luYWwgc3RhdGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU3ByaXRlSW1wbC5wcm90b3R5cGUuY2xlYXJFZmZlY3RzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmVmZmVjdHMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fYXBwbHlFZmZlY3RzKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXNldHMgdGhlIGludGVybmFsIHN0YXRlIG9mIHRoZSBkcmF3aW5nIChpZiBhbnkpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU3ByaXRlSW1wbC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNwcml0ZUltcGwucHJvdG90eXBlLmRlYnVnRHJhdyA9IGZ1bmN0aW9uIChjdHgsIHgsIHkpIHtcclxuICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcclxuICAgICAgICAgICAgY3R4LnJvdGF0ZSh0aGlzLnJvdGF0aW9uKTtcclxuICAgICAgICAgICAgdmFyIHNjYWxlZFNXaWR0aCA9IHRoaXMud2lkdGggKiB0aGlzLnNjYWxlLng7XHJcbiAgICAgICAgICAgIHZhciBzY2FsZWRTSGVpZ2h0ID0gdGhpcy5oZWlnaHQgKiB0aGlzLnNjYWxlLnk7XHJcbiAgICAgICAgICAgIHZhciB4cG9pbnQgPSAoc2NhbGVkU1dpZHRoKSAqIHRoaXMuYW5jaG9yLng7XHJcbiAgICAgICAgICAgIHZhciB5cG9pbnQgPSAoc2NhbGVkU0hlaWdodCkgKiB0aGlzLmFuY2hvci55O1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBDb2xvcl85LkNvbG9yLkJsYWNrLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2VSZWN0KC14cG9pbnQsIC15cG9pbnQsIHNjYWxlZFNXaWR0aCwgc2NhbGVkU0hlaWdodCk7XHJcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEcmF3cyB0aGUgc3ByaXRlIGFwcHJvcHJpYXRlbHkgdG8gdGhlIDJEIHJlbmRlcmluZyBjb250ZXh0LCBhdCBhbiB4IGFuZCB5IGNvb3JkaW5hdGUuXHJcbiAgICAgICAgICogQHBhcmFtIGN0eCAgVGhlIDJEIHJlbmRlcmluZyBjb250ZXh0XHJcbiAgICAgICAgICogQHBhcmFtIHggICAgVGhlIHggY29vcmRpbmF0ZSBvZiB3aGVyZSB0byBkcmF3XHJcbiAgICAgICAgICogQHBhcmFtIHkgICAgVGhlIHkgY29vcmRpbmF0ZSBvZiB3aGVyZSB0byBkcmF3XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU3ByaXRlSW1wbC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjdHgsIHgsIHkpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2RpcnR5RWZmZWN0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hcHBseUVmZmVjdHMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjYWxjdWxhdGluZyBjdXJyZW50IGRpbWVuc2lvbnNcclxuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMubmF0dXJhbFdpZHRoICogdGhpcy5zY2FsZS54O1xyXG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMubmF0dXJhbEhlaWdodCAqIHRoaXMuc2NhbGUueTtcclxuICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgdmFyIHhwb2ludCA9IHRoaXMud2lkdGggKiB0aGlzLmFuY2hvci54O1xyXG4gICAgICAgICAgICB2YXIgeXBvaW50ID0gdGhpcy5oZWlnaHQgKiB0aGlzLmFuY2hvci55O1xyXG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xyXG4gICAgICAgICAgICBjdHgucm90YXRlKHRoaXMucm90YXRpb24pO1xyXG4gICAgICAgICAgICB2YXIgc2NhbGVkU1dpZHRoID0gdGhpcy5zd2lkdGggKiB0aGlzLnNjYWxlLng7XHJcbiAgICAgICAgICAgIHZhciBzY2FsZWRTSGVpZ2h0ID0gdGhpcy5zaGVpZ2h0ICogdGhpcy5zY2FsZS55O1xyXG4gICAgICAgICAgICAvLyB0b2RvIGNhY2hlIGZsaXBwZWQgc3ByaXRlc1xyXG4gICAgICAgICAgICBpZiAodGhpcy5mbGlwSG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShzY2FsZWRTV2lkdGgsIDApO1xyXG4gICAgICAgICAgICAgICAgY3R4LnNjYWxlKC0xLCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5mbGlwVmVydGljYWwpIHtcclxuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoMCwgc2NhbGVkU0hlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBjdHguc2NhbGUoMSwgLTEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5fc3ByaXRlQ2FudmFzLCAwLCAwLCB0aGlzLnN3aWR0aCwgdGhpcy5zaGVpZ2h0LCAteHBvaW50LCAteXBvaW50LCBzY2FsZWRTV2lkdGgsIHNjYWxlZFNIZWlnaHQpO1xyXG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJvZHVjZXMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHNwcml0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNwcml0ZUltcGwucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFNwcml0ZSh0aGlzLl90ZXh0dXJlLCB0aGlzLnN4LCB0aGlzLnN5LCB0aGlzLnN3aWR0aCwgdGhpcy5zaGVpZ2h0KTtcclxuICAgICAgICAgICAgcmVzdWx0LnNjYWxlID0gdGhpcy5zY2FsZS5jbG9uZSgpO1xyXG4gICAgICAgICAgICByZXN1bHQucm90YXRpb24gPSB0aGlzLnJvdGF0aW9uO1xyXG4gICAgICAgICAgICByZXN1bHQuZmxpcEhvcml6b250YWwgPSB0aGlzLmZsaXBIb3Jpem9udGFsO1xyXG4gICAgICAgICAgICByZXN1bHQuZmxpcFZlcnRpY2FsID0gdGhpcy5mbGlwVmVydGljYWw7XHJcbiAgICAgICAgICAgIHZhciBpID0gMCwgbGVuID0gdGhpcy5lZmZlY3RzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5hZGRFZmZlY3QodGhpcy5lZmZlY3RzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFNwcml0ZUltcGw7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5TcHJpdGVJbXBsID0gU3ByaXRlSW1wbDtcclxuICAgIC8qKlxyXG4gICAgICogQSBbW1Nwcml0ZV1dIGlzIG9uZSBvZiB0aGUgbWFpbiBkcmF3aW5nIHByaW1pdGl2ZXMuIEl0IGlzIHJlc3BvbnNpYmxlIGZvciBkcmF3aW5nXHJcbiAgICAgKiBpbWFnZXMgb3IgcGFydHMgb2YgaW1hZ2VzIGZyb20gYSBbW1RleHR1cmVdXSByZXNvdXJjZSB0byB0aGUgc2NyZWVuLlxyXG4gICAgICpcclxuICAgICAqIFtbaW5jbHVkZTpTcHJpdGVzLm1kXV1cclxuICAgICAqL1xyXG4gICAgdmFyIFNwcml0ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFNwcml0ZSwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBTcHJpdGUoaW1hZ2VPckNvbmZpZywgc3gsIHN5LCBzd2lkdGgsIHNoZWlnaHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGltYWdlT3JDb25maWcsIHN4LCBzeSwgc3dpZHRoLCBzaGVpZ2h0KSB8fCB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gU3ByaXRlO1xyXG4gICAgfShDb25maWd1cmFibGVfMS5Db25maWd1cmFibGUoU3ByaXRlSW1wbCkpKTtcclxuICAgIGV4cG9ydHMuU3ByaXRlID0gU3ByaXRlO1xyXG59KTtcclxuZGVmaW5lKFwiRHJhd2luZy9BbmltYXRpb25cIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJEcmF3aW5nL1Nwcml0ZUVmZmVjdHNcIiwgXCJBbGdlYnJhXCIsIFwiRW5naW5lXCIsIFwiVXRpbC9VdGlsXCIsIFwiQ29uZmlndXJhYmxlXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgRWZmZWN0cywgQWxnZWJyYV8xMiwgRW5naW5lXzEsIFV0aWwsIENvbmZpZ3VyYWJsZV8yKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogQGhpZGRlblxyXG4gICAgICovXHJcbiAgICB2YXIgQW5pbWF0aW9uSW1wbCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVHlwaWNhbGx5IHlvdSB3aWxsIHVzZSBhIFtbU3ByaXRlU2hlZXRdXSB0byBnZW5lcmF0ZSBhbiBbW0FuaW1hdGlvbl1dLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGVuZ2luZSAgUmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGdhbWUgZW5naW5lXHJcbiAgICAgICAgICogQHBhcmFtIGltYWdlcyAgQW4gYXJyYXkgb2Ygc3ByaXRlcyB0byBjcmVhdGUgdGhlIGZyYW1lcyBmb3IgdGhlIGFuaW1hdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSBzcGVlZCAgIFRoZSBudW1iZXIgaW4gbWlsbGlzZWNvbmRzIHRvIGRpc3BsYXkgZWFjaCBmcmFtZSBpbiB0aGUgYW5pbWF0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIGxvb3AgICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGFuaW1hdGlvbiBzaG91bGQgbG9vcCBhZnRlciBpdCBpcyBjb21wbGV0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBBbmltYXRpb25JbXBsKGVuZ2luZU9yQ29uZmlnLCBzcHJpdGVzLCBzcGVlZCwgbG9vcCkge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIHNwcml0ZSBmcmFtZXMgdG8gcGxheSwgaW4gb3JkZXIuIFNlZSBbW1Nwcml0ZVNoZWV0LmdldEFuaW1hdGlvbkZvckFsbF1dIHRvIHF1aWNrbHlcclxuICAgICAgICAgICAgICogZ2VuZXJhdGUgYW4gW1tBbmltYXRpb25dXS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlcyA9IFtdO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ3VycmVudCBmcmFtZSBpbmRleCBiZWluZyBzaG93blxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50RnJhbWUgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9vbGRUaW1lID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgdGhpcy5hbmNob3IgPSBuZXcgQWxnZWJyYV8xMi5WZWN0b3IoMC4wLCAwLjApO1xyXG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uID0gMC4wO1xyXG4gICAgICAgICAgICB0aGlzLnNjYWxlID0gbmV3IEFsZ2VicmFfMTIuVmVjdG9yKDEsIDEpO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGFuaW1hdGlvbiBzaG91bGQgbG9vcCBhZnRlciBpdCBpcyBjb21wbGV0ZWRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMubG9vcCA9IHRydWU7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbmRpY2F0ZXMgdGhlIGZyYW1lIGluZGV4IHRoZSBhbmltYXRpb24gc2hvdWxkIGZyZWV6ZSBvbiBmb3IgYSBub24tbG9vcGluZ1xyXG4gICAgICAgICAgICAgKiBhbmltYXRpb24uIEJ5IGRlZmF1bHQgaXQgaXMgdGhlIGxhc3QgZnJhbWUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmZyZWV6ZUZyYW1lID0gLTE7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBGbGlwIGVhY2ggZnJhbWUgdmVydGljYWxseS4gU2V0cyBbW1Nwcml0ZS5mbGlwVmVydGljYWxdXS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuZmxpcFZlcnRpY2FsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBGbGlwIGVhY2ggZnJhbWUgaG9yaXpvbnRhbGx5LiBTZXRzIFtbU3ByaXRlLmZsaXBIb3Jpem9udGFsXV0uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmZsaXBIb3Jpem9udGFsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMubmF0dXJhbFdpZHRoID0gMDtcclxuICAgICAgICAgICAgdGhpcy5uYXR1cmFsSGVpZ2h0ID0gMDtcclxuICAgICAgICAgICAgdmFyIGVuZ2luZSA9IGVuZ2luZU9yQ29uZmlnO1xyXG4gICAgICAgICAgICBpZiAoZW5naW5lT3JDb25maWcgJiYgIShlbmdpbmVPckNvbmZpZyBpbnN0YW5jZW9mIEVuZ2luZV8xLkVuZ2luZSkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb25maWcgPSBlbmdpbmVPckNvbmZpZztcclxuICAgICAgICAgICAgICAgIGVuZ2luZSA9IGNvbmZpZy5lbmdpbmU7XHJcbiAgICAgICAgICAgICAgICBzcHJpdGVzID0gY29uZmlnLnNwcml0ZXM7XHJcbiAgICAgICAgICAgICAgICBzcGVlZCA9IGNvbmZpZy5zcGVlZDtcclxuICAgICAgICAgICAgICAgIGxvb3AgPSBjb25maWcubG9vcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZXMgPSBzcHJpdGVzO1xyXG4gICAgICAgICAgICB0aGlzLnNwZWVkID0gc3BlZWQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZ2luZSA9IGVuZ2luZTtcclxuICAgICAgICAgICAgaWYgKGxvb3AgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb29wID0gbG9vcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc3ByaXRlcyAmJiBzcHJpdGVzWzBdKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IHNwcml0ZXNbMF0gPyBzcHJpdGVzWzBdLmhlaWdodCA6IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gc3ByaXRlc1swXSA/IHNwcml0ZXNbMF0ud2lkdGggOiAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uYXR1cmFsV2lkdGggPSBzcHJpdGVzWzBdID8gc3ByaXRlc1swXS5uYXR1cmFsV2lkdGggOiAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uYXR1cmFsSGVpZ2h0ID0gc3ByaXRlc1swXSA/IHNwcml0ZXNbMF0ubmF0dXJhbEhlaWdodCA6IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyZWV6ZUZyYW1lID0gc3ByaXRlcy5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFwcGxpZXMgdGhlIG9wYWNpdHkgZWZmZWN0IHRvIGEgc3ByaXRlLCBzZXR0aW5nIHRoZSBhbHBoYSBvZiBhbGwgcGl4ZWxzIHRvIGEgZ2l2ZW4gdmFsdWVcclxuICAgICAgICAgKi9cclxuICAgICAgICBBbmltYXRpb25JbXBsLnByb3RvdHlwZS5vcGFjaXR5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRWZmZWN0KG5ldyBFZmZlY3RzLk9wYWNpdHkodmFsdWUpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFwcGxpZXMgdGhlIGdyYXlzY2FsZSBlZmZlY3QgdG8gYSBzcHJpdGUsIHJlbW92aW5nIGNvbG9yIGluZm9ybWF0aW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFuaW1hdGlvbkltcGwucHJvdG90eXBlLmdyYXlzY2FsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRFZmZlY3QobmV3IEVmZmVjdHMuR3JheXNjYWxlKCkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXBwbGllcyB0aGUgaW52ZXJ0IGVmZmVjdCB0byBhIHNwcml0ZSwgaW52ZXJ0aW5nIHRoZSBwaXhlbCBjb2xvcnMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQW5pbWF0aW9uSW1wbC5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZEVmZmVjdChuZXcgRWZmZWN0cy5JbnZlcnQoKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcHBsaWVzIHRoZSBmaWxsIGVmZmVjdCB0byBhIHNwcml0ZSwgY2hhbmdpbmcgdGhlIGNvbG9yIGNoYW5uZWxzIG9mIGFsbCBub24tdHJhbnNwYXJlbnQgcGl4ZWxzIHRvIG1hdGNoIGEgZ2l2ZW4gY29sb3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBBbmltYXRpb25JbXBsLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKGNvbG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRWZmZWN0KG5ldyBFZmZlY3RzLkZpbGwoY29sb3IpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFwcGxpZXMgdGhlIGNvbG9yaXplIGVmZmVjdCB0byBhIHNwcml0ZSwgY2hhbmdpbmcgdGhlIGNvbG9yIGNoYW5uZWxzIG9mIGFsbCBwaXhlbHMgdG8gYmUgdGhlIGF2ZXJhZ2Ugb2YgdGhlIG9yaWdpbmFsIGNvbG9yIGFuZCB0aGVcclxuICAgICAgICAgKiBwcm92aWRlZCBjb2xvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBBbmltYXRpb25JbXBsLnByb3RvdHlwZS5jb2xvcml6ZSA9IGZ1bmN0aW9uIChjb2xvcikge1xyXG4gICAgICAgICAgICB0aGlzLmFkZEVmZmVjdChuZXcgRWZmZWN0cy5Db2xvcml6ZShjb2xvcikpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXBwbGllcyB0aGUgbGlnaHRlbiBlZmZlY3QgdG8gYSBzcHJpdGUsIGNoYW5nZXMgdGhlIGxpZ2h0bmVzcyBvZiB0aGUgY29sb3IgYWNjb3JkaW5nIHRvIGhzbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFuaW1hdGlvbkltcGwucHJvdG90eXBlLmxpZ2h0ZW4gPSBmdW5jdGlvbiAoZmFjdG9yKSB7XHJcbiAgICAgICAgICAgIGlmIChmYWN0b3IgPT09IHZvaWQgMCkgeyBmYWN0b3IgPSAwLjE7IH1cclxuICAgICAgICAgICAgdGhpcy5hZGRFZmZlY3QobmV3IEVmZmVjdHMuTGlnaHRlbihmYWN0b3IpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFwcGxpZXMgdGhlIGRhcmtlbiBlZmZlY3QgdG8gYSBzcHJpdGUsIGNoYW5nZXMgdGhlIGRhcmtuZXNzIG9mIHRoZSBjb2xvciBhY2NvcmRpbmcgdG8gaHNsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQW5pbWF0aW9uSW1wbC5wcm90b3R5cGUuZGFya2VuID0gZnVuY3Rpb24gKGZhY3Rvcikge1xyXG4gICAgICAgICAgICBpZiAoZmFjdG9yID09PSB2b2lkIDApIHsgZmFjdG9yID0gMC4xOyB9XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRWZmZWN0KG5ldyBFZmZlY3RzLkRhcmtlbihmYWN0b3IpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFwcGxpZXMgdGhlIHNhdHVyYXRlIGVmZmVjdCB0byBhIHNwcml0ZSwgc2F0dXJhdGVzIHRoZSBjb2xvciBhY2NvcmRpbmcgdG8gaHNsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQW5pbWF0aW9uSW1wbC5wcm90b3R5cGUuc2F0dXJhdGUgPSBmdW5jdGlvbiAoZmFjdG9yKSB7XHJcbiAgICAgICAgICAgIGlmIChmYWN0b3IgPT09IHZvaWQgMCkgeyBmYWN0b3IgPSAwLjE7IH1cclxuICAgICAgICAgICAgdGhpcy5hZGRFZmZlY3QobmV3IEVmZmVjdHMuU2F0dXJhdGUoZmFjdG9yKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcHBsaWVzIHRoZSBkZXNhdHVyYXRlIGVmZmVjdCB0byBhIHNwcml0ZSwgZGVzYXR1cmF0ZXMgdGhlIGNvbG9yIGFjY29yZGluZyB0byBoc2xcclxuICAgICAgICAgKi9cclxuICAgICAgICBBbmltYXRpb25JbXBsLnByb3RvdHlwZS5kZXNhdHVyYXRlID0gZnVuY3Rpb24gKGZhY3Rvcikge1xyXG4gICAgICAgICAgICBpZiAoZmFjdG9yID09PSB2b2lkIDApIHsgZmFjdG9yID0gMC4xOyB9XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRWZmZWN0KG5ldyBFZmZlY3RzLkRlc2F0dXJhdGUoZmFjdG9yKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGQgYSBbW0lTcHJpdGVFZmZlY3RdXSBtYW51YWxseVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFuaW1hdGlvbkltcGwucHJvdG90eXBlLmFkZEVmZmVjdCA9IGZ1bmN0aW9uIChlZmZlY3QpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnNwcml0ZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlc1tpXS5hZGRFZmZlY3QoZWZmZWN0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgQW5pbWF0aW9uSW1wbC5wcm90b3R5cGUucmVtb3ZlRWZmZWN0ID0gZnVuY3Rpb24gKHBhcmFtKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5zcHJpdGVzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZXNbaV0ucmVtb3ZlRWZmZWN0KHBhcmFtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2xlYXIgYWxsIHNwcml0ZSBlZmZlY3RzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQW5pbWF0aW9uSW1wbC5wcm90b3R5cGUuY2xlYXJFZmZlY3RzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuc3ByaXRlcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVzW2ldLmNsZWFyRWZmZWN0cygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBbmltYXRpb25JbXBsLnByb3RvdHlwZS5fc2V0QW5jaG9yID0gZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgICAgICAgICAgIC8vaWYgKCF0aGlzLmFuY2hvci5lcXVhbHMocG9pbnQpKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5zcHJpdGVzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZXNbaV0uYW5jaG9yLnNldFRvKHBvaW50LngsIHBvaW50LnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgQW5pbWF0aW9uSW1wbC5wcm90b3R5cGUuX3NldFJvdGF0aW9uID0gZnVuY3Rpb24gKHJhZGlhbnMpIHtcclxuICAgICAgICAgICAgLy9pZiAodGhpcy5yb3RhdGlvbiAhPT0gcmFkaWFucykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuc3ByaXRlcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVzW2ldLnJvdGF0aW9uID0gcmFkaWFucztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL31cclxuICAgICAgICB9O1xyXG4gICAgICAgIEFuaW1hdGlvbkltcGwucHJvdG90eXBlLl9zZXRTY2FsZSA9IGZ1bmN0aW9uIChzY2FsZSkge1xyXG4gICAgICAgICAgICAvL2lmICghdGhpcy5zY2FsZS5lcXVhbHMoc2NhbGUpKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5zcHJpdGVzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZXNbaV0uc2NhbGUgPSBzY2FsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL31cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlc2V0cyB0aGUgYW5pbWF0aW9uIHRvIGZpcnN0IGZyYW1lLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFuaW1hdGlvbkltcGwucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IDA7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgYW5pbWF0aW9uIGlzIGNvbXBsZXRlLCBhbmltYXRpb25zIHRoYXQgbG9vcCBhcmUgbmV2ZXIgY29tcGxldGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQW5pbWF0aW9uSW1wbC5wcm90b3R5cGUuaXNEb25lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKCF0aGlzLmxvb3AgJiYgdGhpcy5jdXJyZW50RnJhbWUgPj0gdGhpcy5zcHJpdGVzLmxlbmd0aCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBOb3QgbWVhbnQgdG8gYmUgY2FsbGVkIGJ5IGdhbWUgZGV2ZWxvcGVycy4gVGlja3MgdGhlIGFuaW1hdGlvbiBmb3J3YXJkIGludGVybmFsbHkgYW5kXHJcbiAgICAgICAgICogY2FsY3VsYXRlcyB3aGV0aGVyIHRvIGNoYW5nZSB0byB0aGUgZnJhbWUuXHJcbiAgICAgICAgICogQGludGVybmFsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQW5pbWF0aW9uSW1wbC5wcm90b3R5cGUudGljayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICBpZiAoKHRpbWUgLSB0aGlzLl9vbGRUaW1lKSA+IHRoaXMuc3BlZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEZyYW1lID0gKHRoaXMubG9vcCA/ICh0aGlzLmN1cnJlbnRGcmFtZSArIDEpICUgdGhpcy5zcHJpdGVzLmxlbmd0aCA6IHRoaXMuY3VycmVudEZyYW1lICsgMSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vbGRUaW1lID0gdGltZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgQW5pbWF0aW9uSW1wbC5wcm90b3R5cGUuX3VwZGF0ZVZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fc2V0QW5jaG9yKHRoaXMuYW5jaG9yKTtcclxuICAgICAgICAgICAgdGhpcy5fc2V0Um90YXRpb24odGhpcy5yb3RhdGlvbik7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldFNjYWxlKHRoaXMuc2NhbGUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2tpcHMgYWhlYWQgYSBzcGVjaWZpZWQgbnVtYmVyIG9mIGZyYW1lcyBpbiB0aGUgYW5pbWF0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIGZyYW1lcyAgRnJhbWVzIHRvIHNraXAgYWhlYWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBBbmltYXRpb25JbXBsLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24gKGZyYW1lcykge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZSA9ICh0aGlzLmN1cnJlbnRGcmFtZSArIGZyYW1lcykgJSB0aGlzLnNwcml0ZXMubGVuZ3RoO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQW5pbWF0aW9uSW1wbC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjdHgsIHgsIHkpIHtcclxuICAgICAgICAgICAgdGhpcy50aWNrKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVZhbHVlcygpO1xyXG4gICAgICAgICAgICB2YXIgY3VyclNwcml0ZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudEZyYW1lIDwgdGhpcy5zcHJpdGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgY3VyclNwcml0ZSA9IHRoaXMuc3ByaXRlc1t0aGlzLmN1cnJlbnRGcmFtZV07XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mbGlwVmVydGljYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyU3ByaXRlLmZsaXBWZXJ0aWNhbCA9IHRoaXMuZmxpcFZlcnRpY2FsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmxpcEhvcml6b250YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyU3ByaXRlLmZsaXBIb3Jpem9udGFsID0gdGhpcy5mbGlwSG9yaXpvbnRhbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGN1cnJTcHJpdGUuZHJhdyhjdHgsIHgsIHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZyZWV6ZUZyYW1lICE9PSAtMSAmJiB0aGlzLmN1cnJlbnRGcmFtZSA+PSB0aGlzLnNwcml0ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyU3ByaXRlID0gdGhpcy5zcHJpdGVzW1V0aWwuY2xhbXAodGhpcy5mcmVlemVGcmFtZSwgMCwgdGhpcy5zcHJpdGVzLmxlbmd0aCAtIDEpXTtcclxuICAgICAgICAgICAgICAgIGN1cnJTcHJpdGUuZHJhdyhjdHgsIHgsIHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGFkZCB0aGUgY2FsY3VsYXRlZCB3aWR0aFxyXG4gICAgICAgICAgICBpZiAoY3VyclNwcml0ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IGN1cnJTcHJpdGUud2lkdGg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IGN1cnJTcHJpdGUuaGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQbGF5cyBhbiBhbmltYXRpb24gYXQgYW4gYXJiaXRyYXJ5IGxvY2F0aW9uIGluIHRoZSBnYW1lLlxyXG4gICAgICAgICAqIEBwYXJhbSB4ICBUaGUgeCBwb3NpdGlvbiBpbiB0aGUgZ2FtZSB0byBwbGF5XHJcbiAgICAgICAgICogQHBhcmFtIHkgIFRoZSB5IHBvc2l0aW9uIGluIHRoZSBnYW1lIHRvIHBsYXlcclxuICAgICAgICAgKi9cclxuICAgICAgICBBbmltYXRpb25JbXBsLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKHgsIHkpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgICAgICAgICB0aGlzLl9lbmdpbmUucGxheUFuaW1hdGlvbih0aGlzLCB4LCB5KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBBbmltYXRpb25JbXBsO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuQW5pbWF0aW9uSW1wbCA9IEFuaW1hdGlvbkltcGw7XHJcbiAgICAvKipcclxuICAgICAqIEFuaW1hdGlvbnMgYWxsb3cgeW91IHRvIGRpc3BsYXkgYSBzZXJpZXMgb2YgaW1hZ2VzIG9uZSBhZnRlciBhbm90aGVyLFxyXG4gICAgICogY3JlYXRpbmcgdGhlIGlsbHVzaW9uIG9mIGNoYW5nZS4gR2VuZXJhbGx5IHRoZXNlIGltYWdlcyB3aWxsIGNvbWUgZnJvbSBhIFtbU3ByaXRlU2hlZXRdXSBzb3VyY2UuXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOkFuaW1hdGlvbnMubWRdXVxyXG4gICAgICovXHJcbiAgICB2YXIgQW5pbWF0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoQW5pbWF0aW9uLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvbihlbmdpbmVPckNvbmZpZywgaW1hZ2VzLCBzcGVlZCwgbG9vcCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgZW5naW5lT3JDb25maWcsIGltYWdlcywgc3BlZWQsIGxvb3ApIHx8IHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBBbmltYXRpb247XHJcbiAgICB9KENvbmZpZ3VyYWJsZV8yLkNvbmZpZ3VyYWJsZShBbmltYXRpb25JbXBsKSkpO1xyXG4gICAgZXhwb3J0cy5BbmltYXRpb24gPSBBbmltYXRpb247XHJcbn0pO1xyXG5kZWZpbmUoXCJEcmF3aW5nL1Nwcml0ZVNoZWV0XCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiRHJhd2luZy9TcHJpdGVcIiwgXCJEcmF3aW5nL0FuaW1hdGlvblwiLCBcIkRyYXdpbmcvQ29sb3JcIiwgXCJEcmF3aW5nL1Nwcml0ZUVmZmVjdHNcIiwgXCJSZXNvdXJjZXMvVGV4dHVyZVwiLCBcIlV0aWwvTG9nXCIsIFwiTGFiZWxcIiwgXCJDb25maWd1cmFibGVcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBTcHJpdGVfMiwgQW5pbWF0aW9uXzEsIENvbG9yXzEwLCBFZmZlY3RzLCBUZXh0dXJlXzIsIExvZ180LCBMYWJlbF8xLCBDb25maWd1cmFibGVfMykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEBoaWRkZW5cclxuICAgICAqL1xyXG4gICAgdmFyIFNwcml0ZVNoZWV0SW1wbCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIGltYWdlICAgICBUaGUgYmFja2luZyBpbWFnZSB0ZXh0dXJlIHRvIGJ1aWxkIHRoZSBTcHJpdGVTaGVldFxyXG4gICAgICAgICAqIEBwYXJhbSBjb2x1bW5zICAgVGhlIG51bWJlciBvZiBjb2x1bW5zIGluIHRoZSBpbWFnZSB0ZXh0dXJlXHJcbiAgICAgICAgICogQHBhcmFtIHJvd3MgICAgICBUaGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIGltYWdlIHRleHR1cmVcclxuICAgICAgICAgKiBAcGFyYW0gc3BXaWR0aCAgIFRoZSB3aWR0aCBvZiBlYWNoIGluZGl2aWR1YWwgc3ByaXRlIGluIHBpeGVsc1xyXG4gICAgICAgICAqIEBwYXJhbSBzcEhlaWdodCAgVGhlIGhlaWdodCBvZiBlYWNoIGluZGl2aWR1YWwgc3ByaXRlIGluIHBpeGVsc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIFNwcml0ZVNoZWV0SW1wbChpbWFnZU9yQ29uZmlnT3JTcHJpdGVzLCBjb2x1bW5zLCByb3dzLCBzcFdpZHRoLCBzcEhlaWdodCkge1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZXMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5pbWFnZSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuY29sdW1ucyA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMucm93cyA9IDA7XHJcbiAgICAgICAgICAgIHZhciBsb2FkRnJvbUltYWdlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChpbWFnZU9yQ29uZmlnT3JTcHJpdGVzIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlcyA9IGltYWdlT3JDb25maWdPclNwcml0ZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW1hZ2VPckNvbmZpZ09yU3ByaXRlcyAmJiAhKGltYWdlT3JDb25maWdPclNwcml0ZXMgaW5zdGFuY2VvZiBUZXh0dXJlXzIuVGV4dHVyZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbnMgPSBpbWFnZU9yQ29uZmlnT3JTcHJpdGVzLmNvbHVtbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3dzID0gaW1hZ2VPckNvbmZpZ09yU3ByaXRlcy5yb3dzO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3BXaWR0aCA9IGltYWdlT3JDb25maWdPclNwcml0ZXMuc3BXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwSGVpZ2h0ID0gaW1hZ2VPckNvbmZpZ09yU3ByaXRlcy5zcEhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmltYWdlID0gaW1hZ2VPckNvbmZpZ09yU3ByaXRlcy5pbWFnZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2UgPSBpbWFnZU9yQ29uZmlnT3JTcHJpdGVzO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1ucyA9IGNvbHVtbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3dzID0gcm93cztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwV2lkdGggPSBzcFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3BIZWlnaHQgPSBzcEhlaWdodDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlcyA9IG5ldyBBcnJheSh0aGlzLmNvbHVtbnMgKiB0aGlzLnJvd3MpO1xyXG4gICAgICAgICAgICAgICAgbG9hZEZyb21JbWFnZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVE9ETzogSW5zcGVjdCBhY3R1YWwgaW1hZ2UgZGltZW5zaW9ucyB3aXRoIHByZWxvYWRpbmdcclxuICAgICAgICAgICAgLyppZihzcFdpZHRoICogY29sdW1ucyA+IHRoaXMuaW50ZXJuYWxJbWFnZS5uYXR1cmFsV2lkdGgpe1xyXG4gICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTcHJpdGVTaGVldCBzcGVjaWZpZWQgaXMgd2lkZXIgdGhhbiBpbWFnZSB3aWR0aFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICBcclxuICAgICAgICAgICAgaWYoc3BIZWlnaHQgKiByb3dzID4gdGhpcy5pbnRlcm5hbEltYWdlLm5hdHVyYWxIZWlnaHQpe1xyXG4gICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTcHJpdGVTaGVldCBzcGVjaWZpZWQgaXMgaGlnaGVyIHRoYW4gaW1hZ2UgaGVpZ2h0XCIpO1xyXG4gICAgICAgICAgICB9Ki9cclxuICAgICAgICAgICAgaWYgKGxvYWRGcm9tSW1hZ2UpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgICAgIHZhciBqID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZXNbaiArIGkgKiB0aGlzLmNvbHVtbnNdID0gbmV3IFNwcml0ZV8yLlNwcml0ZSh0aGlzLmltYWdlLCBqICogdGhpcy5zcFdpZHRoLCBpICogdGhpcy5zcEhlaWdodCwgdGhpcy5zcFdpZHRoLCB0aGlzLnNwSGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlIGFuIGFuaW1hdGlvbiBmcm9tIHRoZSB0aGlzIFNwcml0ZVNoZWV0IGJ5IGxpc3Rpbmcgb3V0IHRoZVxyXG4gICAgICAgICAqIHNwcml0ZSBpbmRpY2VzLiBTcHJpdGVzIGFyZSBvcmdhbml6ZWQgaW4gcm93IG1ham9yIG9yZGVyIGluIHRoZSBTcHJpdGVTaGVldC5cclxuICAgICAgICAgKiBAcGFyYW0gZW5naW5lICAgUmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGdhbWUgW1tFbmdpbmVdXVxyXG4gICAgICAgICAqIEBwYXJhbSBpbmRpY2VzICBBbiBhcnJheSBvZiBzcHJpdGUgaW5kaWNlcyB0byB1c2UgaW4gdGhlIGFuaW1hdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSBzcGVlZCAgICBUaGUgbnVtYmVyIGluIG1pbGxpc2Vjb25kcyB0byBkaXNwbGF5IGVhY2ggZnJhbWUgaW4gdGhlIGFuaW1hdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNwcml0ZVNoZWV0SW1wbC5wcm90b3R5cGUuZ2V0QW5pbWF0aW9uQnlJbmRpY2VzID0gZnVuY3Rpb24gKGVuZ2luZSwgaW5kaWNlcywgc3BlZWQpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGltYWdlcyA9IGluZGljZXMubWFwKGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNwcml0ZXNbaW5kZXhdO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaW1hZ2VzID0gaW1hZ2VzLm1hcChmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGkuY2xvbmUoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uXzEuQW5pbWF0aW9uKGVuZ2luZSwgaW1hZ2VzLCBzcGVlZCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGUgYW4gYW5pbWF0aW9uIGZyb20gdGhlIHRoaXMgU3ByaXRlU2hlZXQgYnkgc3BlY2lmaW5nIHRoZSByYW5nZSBvZlxyXG4gICAgICAgICAqIGltYWdlcyB3aXRoIHRoZSBiZWdpbm5pbmcgKGluY2x1c2l2ZSkgYW5kIGVuZGluZyAoZXhjbHVzaXZlKSBpbmRleFxyXG4gICAgICAgICAqIEZvciBleGFtcGxlIGBnZXRBbmltYXRpb25CZXR3ZWVuKGVuZ2luZSwgMCwgNSwgMjAwKWAgcmV0dXJucyBhbiBhbmltYXRpb24gd2l0aCA1IGZyYW1lcy5cclxuICAgICAgICAgKiBAcGFyYW0gZW5naW5lICAgICAgUmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGdhbWUgRW5naW5lXHJcbiAgICAgICAgICogQHBhcmFtIGJlZ2luSW5kZXggIFRoZSBpbmRleCB0byBzdGFydCB0YWtpbmcgZnJhbWVzIChpbmNsdXNpdmUpXHJcbiAgICAgICAgICogQHBhcmFtIGVuZEluZGV4ICAgIFRoZSBpbmRleCB0byBzdG9wIHRha2luZyBmcmFtZXMgKGV4Y2x1c2l2ZSlcclxuICAgICAgICAgKiBAcGFyYW0gc3BlZWQgICAgICAgVGhlIG51bWJlciBpbiBtaWxsaXNlY29uZHMgdG8gZGlzcGxheSBlYWNoIGZyYW1lIGluIHRoZSBhbmltYXRpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBTcHJpdGVTaGVldEltcGwucHJvdG90eXBlLmdldEFuaW1hdGlvbkJldHdlZW4gPSBmdW5jdGlvbiAoZW5naW5lLCBiZWdpbkluZGV4LCBlbmRJbmRleCwgc3BlZWQpIHtcclxuICAgICAgICAgICAgdmFyIGltYWdlcyA9IHRoaXMuc3ByaXRlcy5zbGljZShiZWdpbkluZGV4LCBlbmRJbmRleCk7XHJcbiAgICAgICAgICAgIGltYWdlcyA9IGltYWdlcy5tYXAoZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpLmNsb25lKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFuaW1hdGlvbl8xLkFuaW1hdGlvbihlbmdpbmUsIGltYWdlcywgc3BlZWQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVHJlYXQgdGhlIGVudGlyZSBTcHJpdGVTaGVldCBhcyBvbmUgYW5pbWF0aW9uLCBvcmdhbml6aW5nIHRoZSBmcmFtZXMgaW5cclxuICAgICAgICAgKiByb3cgbWFqb3Igb3JkZXIuXHJcbiAgICAgICAgICogQHBhcmFtIGVuZ2luZSAgUmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGdhbWUgW1tFbmdpbmVdXVxyXG4gICAgICAgICAqIEBwYXJhbSBzcGVlZCAgIFRoZSBudW1iZXIgaW4gbWlsbGlzZWNvbmRzIHRvIGRpc3BsYXkgZWFjaCBmcmFtZSB0aGUgYW5pbWF0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU3ByaXRlU2hlZXRJbXBsLnByb3RvdHlwZS5nZXRBbmltYXRpb25Gb3JBbGwgPSBmdW5jdGlvbiAoZW5naW5lLCBzcGVlZCkge1xyXG4gICAgICAgICAgICB2YXIgc3ByaXRlcyA9IHRoaXMuc3ByaXRlcy5tYXAoZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpLmNsb25lKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFuaW1hdGlvbl8xLkFuaW1hdGlvbihlbmdpbmUsIHNwcml0ZXMsIHNwZWVkKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHJlaXZlIGEgc3BlY2lmaWMgc3ByaXRlIGZyb20gdGhlIFNwcml0ZVNoZWV0IGJ5IGl0cyBpbmRleC4gU3ByaXRlcyBhcmUgb3JnYW5pemVkXHJcbiAgICAgICAgICogaW4gcm93IG1ham9yIG9yZGVyIGluIHRoZSBTcHJpdGVTaGVldC5cclxuICAgICAgICAgKiBAcGFyYW0gaW5kZXggIFRoZSBpbmRleCBvZiB0aGUgc3ByaXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU3ByaXRlU2hlZXRJbXBsLnByb3RvdHlwZS5nZXRTcHJpdGUgPSBmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLnNwcml0ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zcHJpdGVzW2luZGV4XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbmRleDogJyArIGluZGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFNwcml0ZVNoZWV0SW1wbDtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLlNwcml0ZVNoZWV0SW1wbCA9IFNwcml0ZVNoZWV0SW1wbDtcclxuICAgIC8qKlxyXG4gICAgICogU3ByaXRlIHNoZWV0cyBhcmUgYSB1c2VmdWwgbWVjaGFuaXNtIGZvciBzbGljaW5nIHVwIGltYWdlIHJlc291cmNlcyBpbnRvXHJcbiAgICAgKiBzZXBhcmF0ZSBzcHJpdGVzIG9yIGZvciBnZW5lcmF0aW5nIGluIGdhbWUgYW5pbWF0aW9ucy4gW1tTcHJpdGV8U3ByaXRlc11dIGFyZSBvcmdhbml6ZWRcclxuICAgICAqIGluIHJvdyBtYWpvciBvcmRlciBpbiB0aGUgW1tTcHJpdGVTaGVldF1dLlxyXG4gICAgICpcclxuICAgICAqIFtbaW5jbHVkZTpTcHJpdGVTaGVldHMubWRdXVxyXG4gICAgICovXHJcbiAgICB2YXIgU3ByaXRlU2hlZXQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhTcHJpdGVTaGVldCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBTcHJpdGVTaGVldChpbWFnZU9yQ29uZmlnT3JTcHJpdGVzLCBjb2x1bW5zLCByb3dzLCBzcFdpZHRoLCBzcEhlaWdodCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgaW1hZ2VPckNvbmZpZ09yU3ByaXRlcywgY29sdW1ucywgcm93cywgc3BXaWR0aCwgc3BIZWlnaHQpIHx8IHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBTcHJpdGVTaGVldDtcclxuICAgIH0oQ29uZmlndXJhYmxlXzMuQ29uZmlndXJhYmxlKFNwcml0ZVNoZWV0SW1wbCkpKTtcclxuICAgIGV4cG9ydHMuU3ByaXRlU2hlZXQgPSBTcHJpdGVTaGVldDtcclxuICAgIHZhciBTcHJpdGVGb250SW1wbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFNwcml0ZUZvbnRJbXBsLCBfc3VwZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBpbWFnZSAgICAgICAgICAgVGhlIGJhY2tpbmcgaW1hZ2UgdGV4dHVyZSB0byBidWlsZCB0aGUgU3ByaXRlRm9udFxyXG4gICAgICAgICAqIEBwYXJhbSBhbHBoYWJldCAgICAgICAgQSBzdHJpbmcgcmVwcmVzZW50aW5nIGFsbCB0aGUgY2hhcmFjdGVycyBpbiB0aGUgaW1hZ2UsIGluIHJvdyBtYWpvciBvcmRlci5cclxuICAgICAgICAgKiBAcGFyYW0gY2FzZUluc2Vuc2l0aXZlICBJbmRpY2F0ZSB3aGV0aGVyIHRoaXMgZm9udCB0YWtlcyBjYXNlIGludG8gYWNjb3VudFxyXG4gICAgICAgICAqIEBwYXJhbSBjb2x1bW5zICAgICAgICAgVGhlIG51bWJlciBvZiBjb2x1bW5zIG9mIGNoYXJhY3RlcnMgaW4gdGhlIGltYWdlXHJcbiAgICAgICAgICogQHBhcmFtIHJvd3MgICAgICAgICAgICBUaGUgbnVtYmVyIG9mIHJvd3Mgb2YgY2hhcmFjdGVycyBpbiB0aGUgaW1hZ2VcclxuICAgICAgICAgKiBAcGFyYW0gc3BXaWR0aCAgICAgICAgIFRoZSB3aWR0aCBvZiBlYWNoIGNoYXJhY3RlciBpbiBwaXhlbHNcclxuICAgICAgICAgKiBAcGFyYW0gc3BIZWlnaHQgICAgICAgIFRoZSBoZWlnaHQgb2YgZWFjaCBjaGFyYWN0ZXIgaW4gcGl4ZWxzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gU3ByaXRlRm9udEltcGwoaW1hZ2VPckNvbmZpZywgYWxwaGFiZXQsIGNhc2VJbnNlbnNpdGl2ZSwgY29sdW1ucywgcm93cywgc3BXaWR0aCwgc3BIZWlnaHQpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW1hZ2VPckNvbmZpZyBpbnN0YW5jZW9mIFRleHR1cmVfMi5UZXh0dXJlID8geyBpbWFnZTogaW1hZ2VPckNvbmZpZywgc3BXaWR0aDogc3BXaWR0aCxcclxuICAgICAgICAgICAgICAgIHNwSGVpZ2h0OiBzcEhlaWdodCwgcm93czogcm93cywgY29sdW1uczogY29sdW1ucyB9IDogaW1hZ2VPckNvbmZpZykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuX2N1cnJlbnRDb2xvciA9IENvbG9yXzEwLkNvbG9yLkJsYWNrLmNsb25lKCk7XHJcbiAgICAgICAgICAgIF90aGlzLl9jdXJyZW50T3BhY2l0eSA9IDEuMDtcclxuICAgICAgICAgICAgX3RoaXMuX3Nwcml0ZXMgPSB7fTtcclxuICAgICAgICAgICAgLy8gdGV4dCBzaGFkb3dcclxuICAgICAgICAgICAgX3RoaXMuX3RleHRTaGFkb3dPbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICBfdGhpcy5fdGV4dFNoYWRvd0RpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgX3RoaXMuX3RleHRTaGFkb3dDb2xvciA9IENvbG9yXzEwLkNvbG9yLkJsYWNrLmNsb25lKCk7XHJcbiAgICAgICAgICAgIF90aGlzLl90ZXh0U2hhZG93U3ByaXRlcyA9IHt9O1xyXG4gICAgICAgICAgICBfdGhpcy5fc2hhZG93T2Zmc2V0WCA9IDU7XHJcbiAgICAgICAgICAgIF90aGlzLl9zaGFkb3dPZmZzZXRZID0gNTtcclxuICAgICAgICAgICAgaWYgKGltYWdlT3JDb25maWcgJiYgIShpbWFnZU9yQ29uZmlnIGluc3RhbmNlb2YgVGV4dHVyZV8yLlRleHR1cmUpKSB7XHJcbiAgICAgICAgICAgICAgICBhbHBoYWJldCA9IGltYWdlT3JDb25maWcuYWxwaGFiZXQ7XHJcbiAgICAgICAgICAgICAgICBjYXNlSW5zZW5zaXRpdmUgPSBpbWFnZU9yQ29uZmlnLmNhc2VJbnNlbnNpdGl2ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy5fYWxwaGFiZXQgPSBhbHBoYWJldDtcclxuICAgICAgICAgICAgX3RoaXMuX2Nhc2VJbnNlbnNpdGl2ZSA9IGNhc2VJbnNlbnNpdGl2ZTtcclxuICAgICAgICAgICAgX3RoaXMuX3Nwcml0ZXMgPSBfdGhpcy5nZXRUZXh0U3ByaXRlcygpO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBkaWN0aW9uYXJ5IHRoYXQgbWFwcyBlYWNoIGNoYXJhY3RlciBpbiB0aGUgYWxwaGFiZXQgdG8gdGhlIGFwcHJvcHJpYXRlIFtbU3ByaXRlXV0uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU3ByaXRlRm9udEltcGwucHJvdG90eXBlLmdldFRleHRTcHJpdGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbG9va3VwID0ge307XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fYWxwaGFiZXQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBjaGFyID0gdGhpcy5fYWxwaGFiZXRbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2FzZUluc2Vuc2l0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhciA9IGNoYXIudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxvb2t1cFtjaGFyXSA9IHRoaXMuc3ByaXRlc1tpXS5jbG9uZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBsb29rdXA7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSB0ZXh0IHNoYWRvdyBmb3Igc3ByaXRlIGZvbnRzXHJcbiAgICAgICAgICogQHBhcmFtIG9mZnNldFggICAgICBUaGUgeCBvZmZzZXQgaW4gcGl4ZWxzIHRvIHBsYWNlIHRoZSBzaGFkb3dcclxuICAgICAgICAgKiBAcGFyYW0gb2Zmc2V0WSAgICAgIFRoZSB5IG9mZnNldCBpbiBwaXhlbHMgdG8gcGxhY2UgdGhlIHNoYWRvd1xyXG4gICAgICAgICAqIEBwYXJhbSBzaGFkb3dDb2xvciAgVGhlIGNvbG9yIG9mIHRoZSB0ZXh0IHNoYWRvd1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNwcml0ZUZvbnRJbXBsLnByb3RvdHlwZS5zZXRUZXh0U2hhZG93ID0gZnVuY3Rpb24gKG9mZnNldFgsIG9mZnNldFksIHNoYWRvd0NvbG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RleHRTaGFkb3dPbiA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX3NoYWRvd09mZnNldFggPSBvZmZzZXRYO1xyXG4gICAgICAgICAgICB0aGlzLl9zaGFkb3dPZmZzZXRZID0gb2Zmc2V0WTtcclxuICAgICAgICAgICAgdGhpcy5fdGV4dFNoYWRvd0NvbG9yID0gc2hhZG93Q29sb3IuY2xvbmUoKTtcclxuICAgICAgICAgICAgdGhpcy5fdGV4dFNoYWRvd0RpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgZm9yICh2YXIgY2hhcmFjdGVyIGluIHRoaXMuX3Nwcml0ZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RleHRTaGFkb3dTcHJpdGVzW2NoYXJhY3Rlcl0gPSB0aGlzLl9zcHJpdGVzW2NoYXJhY3Rlcl0uY2xvbmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVG9nZ2xlcyB0ZXh0IHNoYWRvd3Mgb24gb3Igb2ZmXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU3ByaXRlRm9udEltcGwucHJvdG90eXBlLnVzZVRleHRTaGFkb3cgPSBmdW5jdGlvbiAob24pIHtcclxuICAgICAgICAgICAgdGhpcy5fdGV4dFNoYWRvd09uID0gb247XHJcbiAgICAgICAgICAgIGlmIChvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRUZXh0U2hhZG93KDUsIDUsIHRoaXMuX3RleHRTaGFkb3dDb2xvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERyYXdzIHRoZSBjdXJyZW50IHNwcml0ZSBmb250XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU3ByaXRlRm9udEltcGwucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoY3R4LCB0ZXh0LCB4LCB5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLl9wYXJzZU9wdGlvbnMob3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50Q29sb3IudG9TdHJpbmcoKSAhPT0gb3B0aW9ucy5jb2xvci50b1N0cmluZygpIHx8IHRoaXMuX2N1cnJlbnRPcGFjaXR5ICE9PSBvcHRpb25zLm9wYWNpdHkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRPcGFjaXR5ID0gb3B0aW9ucy5vcGFjaXR5O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudENvbG9yID0gb3B0aW9ucy5jb2xvcjtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGNoYXIgaW4gdGhpcy5fc3ByaXRlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Nwcml0ZXNbY2hhcl0uY2xlYXJFZmZlY3RzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3ByaXRlc1tjaGFyXS5maWxsKG9wdGlvbnMuY29sb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Nwcml0ZXNbY2hhcl0ub3BhY2l0eShvcHRpb25zLm9wYWNpdHkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl90ZXh0U2hhZG93T24gJiYgdGhpcy5fdGV4dFNoYWRvd0RpcnR5ICYmIHRoaXMuX3RleHRTaGFkb3dDb2xvcikge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgY2hhcmFjdGVyU2hhZG93IGluIHRoaXMuX3RleHRTaGFkb3dTcHJpdGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGV4dFNoYWRvd1Nwcml0ZXNbY2hhcmFjdGVyU2hhZG93XS5jbGVhckVmZmVjdHMoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0U2hhZG93U3ByaXRlc1tjaGFyYWN0ZXJTaGFkb3ddLmFkZEVmZmVjdChuZXcgRWZmZWN0cy5GaWxsKHRoaXMuX3RleHRTaGFkb3dDb2xvci5jbG9uZSgpKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0U2hhZG93RGlydHkgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBmaW5kIHRoZSBjdXJyZW50IGxlbmd0aCBvZiB0ZXh0IGluIHBpeGVsc1xyXG4gICAgICAgICAgICB2YXIgc3ByaXRlID0gdGhpcy5zcHJpdGVzWzBdO1xyXG4gICAgICAgICAgICAvLyBmaW5kIHRoZSBjdXJyZW50IGhlaWdodCBmbyB0aGUgdGV4dCBpbiBwaXhlbHNcclxuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHNwcml0ZS5zaGVpZ2h0O1xyXG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgYXBwcm9wcmlhdGUgc2NhbGUgZm9yIGZvbnQgc2l6ZVxyXG4gICAgICAgICAgICB2YXIgc2NhbGUgPSBvcHRpb25zLmZvbnRTaXplIC8gaGVpZ2h0O1xyXG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gKHRleHQubGVuZ3RoICogc3ByaXRlLnN3aWR0aCAqIHNjYWxlKSArICh0ZXh0Lmxlbmd0aCAqIG9wdGlvbnMubGV0dGVyU3BhY2luZyk7XHJcbiAgICAgICAgICAgIHZhciBjdXJyWCA9IHg7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnRleHRBbGlnbiA9PT0gTGFiZWxfMS5UZXh0QWxpZ24uTGVmdCB8fCBvcHRpb25zLnRleHRBbGlnbiA9PT0gTGFiZWxfMS5UZXh0QWxpZ24uU3RhcnQpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJYID0geDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLnRleHRBbGlnbiA9PT0gTGFiZWxfMS5UZXh0QWxpZ24uUmlnaHQgfHwgb3B0aW9ucy50ZXh0QWxpZ24gPT09IExhYmVsXzEuVGV4dEFsaWduLkVuZCkge1xyXG4gICAgICAgICAgICAgICAgY3VyclggPSB4IC0gbGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMudGV4dEFsaWduID09PSBMYWJlbF8xLlRleHRBbGlnbi5DZW50ZXIpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJYID0geCAtIGxlbmd0aCAvIDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGN1cnJZID0geSAtIGhlaWdodCAqIHNjYWxlO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5iYXNlQWxpZ24gPT09IExhYmVsXzEuQmFzZUFsaWduLlRvcCB8fCBvcHRpb25zLmJhc2VBbGlnbiA9PT0gTGFiZWxfMS5CYXNlQWxpZ24uSGFuZ2luZykge1xyXG4gICAgICAgICAgICAgICAgY3VyclkgPSB5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuYmFzZUFsaWduID09PSBMYWJlbF8xLkJhc2VBbGlnbi5JZGVvZ3JhcGhpYyB8fFxyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5iYXNlQWxpZ24gPT09IExhYmVsXzEuQmFzZUFsaWduLkJvdHRvbSB8fFxyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5iYXNlQWxpZ24gPT09IExhYmVsXzEuQmFzZUFsaWduLkFscGhhYmV0aWMpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJZID0geSAtIGhlaWdodCAqIHNjYWxlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuYmFzZUFsaWduID09PSBMYWJlbF8xLkJhc2VBbGlnbi5NaWRkbGUpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJZID0geSAtIChoZWlnaHQgKiBzY2FsZSkgLyAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoYXJhY3RlciA9IHRleHRbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2FzZUluc2Vuc2l0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhcmFjdGVyID0gY2hhcmFjdGVyLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRleHQgc2hhZG93XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RleHRTaGFkb3dPbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0U2hhZG93U3ByaXRlc1tjaGFyYWN0ZXJdLnNjYWxlLnggPSBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGV4dFNoYWRvd1Nwcml0ZXNbY2hhcmFjdGVyXS5zY2FsZS55ID0gc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RleHRTaGFkb3dTcHJpdGVzW2NoYXJhY3Rlcl0uZHJhdyhjdHgsIGN1cnJYICsgdGhpcy5fc2hhZG93T2Zmc2V0WCwgY3VyclkgKyB0aGlzLl9zaGFkb3dPZmZzZXRZKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYXJTcHJpdGUgPSB0aGlzLl9zcHJpdGVzW2NoYXJhY3Rlcl07XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhclNwcml0ZS5zY2FsZS54ID0gc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhclNwcml0ZS5zY2FsZS55ID0gc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhclNwcml0ZS5kcmF3KGN0eCwgY3VyclgsIGN1cnJZKTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyWCArPSAoY2hhclNwcml0ZS53aWR0aCArIG9wdGlvbnMubGV0dGVyU3BhY2luZyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIExvZ180LkxvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKFwiU3ByaXRlRm9udCBFcnJvciBkcmF3aW5nIGNoYXIgXCIgKyBjaGFyYWN0ZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTcHJpdGVGb250SW1wbC5wcm90b3R5cGUuX3BhcnNlT3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogb3B0aW9ucy5mb250U2l6ZSB8fCAxMCxcclxuICAgICAgICAgICAgICAgIGxldHRlclNwYWNpbmc6IG9wdGlvbnMubGV0dGVyU3BhY2luZyB8fCAwLFxyXG4gICAgICAgICAgICAgICAgY29sb3I6IG9wdGlvbnMuY29sb3IgfHwgQ29sb3JfMTAuQ29sb3IuQmxhY2suY2xvbmUoKSxcclxuICAgICAgICAgICAgICAgIHRleHRBbGlnbjogdHlwZW9mIG9wdGlvbnMudGV4dEFsaWduID09PSB1bmRlZmluZWQgPyBMYWJlbF8xLlRleHRBbGlnbi5MZWZ0IDogb3B0aW9ucy50ZXh0QWxpZ24sXHJcbiAgICAgICAgICAgICAgICBiYXNlQWxpZ246IHR5cGVvZiBvcHRpb25zLmJhc2VBbGlnbiA9PT0gdW5kZWZpbmVkID8gTGFiZWxfMS5CYXNlQWxpZ24uQm90dG9tIDogb3B0aW9ucy5iYXNlQWxpZ24sXHJcbiAgICAgICAgICAgICAgICBtYXhXaWR0aDogb3B0aW9ucy5tYXhXaWR0aCB8fCAtMSxcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IG9wdGlvbnMub3BhY2l0eSB8fCAwXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gU3ByaXRlRm9udEltcGw7XHJcbiAgICB9KFNwcml0ZVNoZWV0KSk7XHJcbiAgICBleHBvcnRzLlNwcml0ZUZvbnRJbXBsID0gU3ByaXRlRm9udEltcGw7XHJcbiAgICAvKipcclxuICAgICAqIFNwcml0ZSBmb250cyBhcmUgYSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYSBbW0xhYmVsXV0gdG8gc3BlY2lmeVxyXG4gICAgICogYSBwYXJ0aWN1bGFyIGJpdG1hcCBhcyBhIGZvbnQuIE5vdGUgdGhhdCBzb21lIGZvbnQgZmVhdHVyZXMgYXJlIG5vdFxyXG4gICAgICogc3VwcG9ydGVkIGJ5IFNwcml0ZSBmb250cy5cclxuICAgICAqXHJcbiAgICAgKiBbW2luY2x1ZGU6U3ByaXRlRm9udHMubWRdXVxyXG4gICAgICovXHJcbiAgICB2YXIgU3ByaXRlRm9udCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFNwcml0ZUZvbnQsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gU3ByaXRlRm9udChpbWFnZU9yQ29uZmlnLCBhbHBoYWJldCwgY2FzZUluc2Vuc2l0aXZlLCBjb2x1bW5zLCByb3dzLCBzcFdpZHRoLCBzcEhlaWdodCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgaW1hZ2VPckNvbmZpZywgYWxwaGFiZXQsIGNhc2VJbnNlbnNpdGl2ZSwgY29sdW1ucywgcm93cywgc3BXaWR0aCwgc3BIZWlnaHQpIHx8IHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBTcHJpdGVGb250O1xyXG4gICAgfShDb25maWd1cmFibGVfMy5Db25maWd1cmFibGUoU3ByaXRlRm9udEltcGwpKSk7XHJcbiAgICBleHBvcnRzLlNwcml0ZUZvbnQgPSBTcHJpdGVGb250O1xyXG59KTtcclxuZGVmaW5lKFwiTGFiZWxcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJEcmF3aW5nL0NvbG9yXCIsIFwiQWN0b3JcIiwgXCJDb25maWd1cmFibGVcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBDb2xvcl8xMSwgQWN0b3JfNCwgQ29uZmlndXJhYmxlXzQpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFbnVtIHJlcHJlc2VudGluZyB0aGUgZGlmZmVyZW50IGZvbnQgc2l6ZSB1bml0c1xyXG4gICAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2ZvbnQtc2l6ZVxyXG4gICAgICovXHJcbiAgICB2YXIgRm9udFVuaXQ7XHJcbiAgICAoZnVuY3Rpb24gKEZvbnRVbml0KSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW0gaXMgYSBzY2FsYWJsZSB1bml0LCAxIGVtIGlzIGVxdWFsIHRvIHRoZSBjdXJyZW50IGZvbnQgc2l6ZSBvZiB0aGUgY3VycmVudCBlbGVtZW50LCBwYXJlbnQgZWxlbWVudHMgY2FuIGVmZmVjdCBlbSB2YWx1ZXNcclxuICAgICAgICAgKi9cclxuICAgICAgICBGb250VW5pdFtGb250VW5pdFtcIkVtXCJdID0gMF0gPSBcIkVtXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtIGlzIHNpbWlsYXIgdG8gdGhlIEVtLCBpdCBpcyBhIHNjYWxhYmxlIHVuaXQuIDEgcmVtIGlzIGVxYXVsIHRvIHRoZSBmb250IHNpemUgb2YgdGhlIHJvb3QgZWxlbWVudFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEZvbnRVbml0W0ZvbnRVbml0W1wiUmVtXCJdID0gMV0gPSBcIlJlbVwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBpeGVsIGlzIGEgdW5pdCBvZiBsZW5ndGggaW4gc2NyZWVuIHBpeGVsc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEZvbnRVbml0W0ZvbnRVbml0W1wiUHhcIl0gPSAyXSA9IFwiUHhcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQb2ludCBpcyBhIHBoeXNpY2FsIHVuaXQgbGVuZ3RoICgxLzcyIG9mIGFuIGluY2gpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRm9udFVuaXRbRm9udFVuaXRbXCJQdFwiXSA9IDNdID0gXCJQdFwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBlcmNlbnQgaXMgYSBzY2FsYWJsZSB1bml0IHNpbWlsYXIgdG8gRW0sIHRoZSBvbmx5IGRpZmZlcmVuY2UgaXMgdGhlIEVtIHVuaXRzIHNjYWxlIGZhc3RlciB3aGVuIFRleHQtU2l6ZSBzdHVmZlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEZvbnRVbml0W0ZvbnRVbml0W1wiUGVyY2VudFwiXSA9IDRdID0gXCJQZXJjZW50XCI7XHJcbiAgICB9KShGb250VW5pdCA9IGV4cG9ydHMuRm9udFVuaXQgfHwgKGV4cG9ydHMuRm9udFVuaXQgPSB7fSkpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFbnVtIHJlcHJlc2VudGluZyB0aGUgZGlmZmVyZW50IGhvcml6b250YWwgdGV4dCBhbGlnbm1lbnRzXHJcbiAgICAgKi9cclxuICAgIHZhciBUZXh0QWxpZ247XHJcbiAgICAoZnVuY3Rpb24gKFRleHRBbGlnbikge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0ZXh0IGlzIGxlZnQtYWxpZ25lZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBUZXh0QWxpZ25bVGV4dEFsaWduW1wiTGVmdFwiXSA9IDBdID0gXCJMZWZ0XCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHRleHQgaXMgcmlnaHQtYWxpZ25lZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBUZXh0QWxpZ25bVGV4dEFsaWduW1wiUmlnaHRcIl0gPSAxXSA9IFwiUmlnaHRcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdGV4dCBpcyBjZW50ZXJlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBUZXh0QWxpZ25bVGV4dEFsaWduW1wiQ2VudGVyXCJdID0gMl0gPSBcIkNlbnRlclwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0ZXh0IGlzIGFsaWduZWQgYXQgdGhlIG5vcm1hbCBzdGFydCBvZiB0aGUgbGluZSAobGVmdC1hbGlnbmVkIGZvciBsZWZ0LXRvLXJpZ2h0IGxvY2FsZXMsXHJcbiAgICAgICAgICogcmlnaHQtYWxpZ25lZCBmb3IgcmlnaHQtdG8tbGVmdCBsb2NhbGVzKS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBUZXh0QWxpZ25bVGV4dEFsaWduW1wiU3RhcnRcIl0gPSAzXSA9IFwiU3RhcnRcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdGV4dCBpcyBhbGlnbmVkIGF0IHRoZSBub3JtYWwgZW5kIG9mIHRoZSBsaW5lIChyaWdodC1hbGlnbmVkIGZvciBsZWZ0LXRvLXJpZ2h0IGxvY2FsZXMsXHJcbiAgICAgICAgICogbGVmdC1hbGlnbmVkIGZvciByaWdodC10by1sZWZ0IGxvY2FsZXMpLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRleHRBbGlnbltUZXh0QWxpZ25bXCJFbmRcIl0gPSA0XSA9IFwiRW5kXCI7XHJcbiAgICB9KShUZXh0QWxpZ24gPSBleHBvcnRzLlRleHRBbGlnbiB8fCAoZXhwb3J0cy5UZXh0QWxpZ24gPSB7fSkpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFbnVtIHJlcHJlc2VudGluZyB0aGUgZGlmZmVyZW50IGJhc2VsaW5lIHRleHQgYWxpZ25tZW50c1xyXG4gICAgICovXHJcbiAgICB2YXIgQmFzZUFsaWduO1xyXG4gICAgKGZ1bmN0aW9uIChCYXNlQWxpZ24pIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdGV4dCBiYXNlbGluZSBpcyB0aGUgdG9wIG9mIHRoZSBlbSBzcXVhcmUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQmFzZUFsaWduW0Jhc2VBbGlnbltcIlRvcFwiXSA9IDBdID0gXCJUb3BcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdGV4dCBiYXNlbGluZSBpcyB0aGUgaGFuZ2luZyBiYXNlbGluZS4gIEN1cnJlbnRseSB1bnN1cHBvcnRlZDsgdGhpcyB3aWxsIGFjdCBsaWtlXHJcbiAgICAgICAgICogYWxwaGFiZXRpYy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBCYXNlQWxpZ25bQmFzZUFsaWduW1wiSGFuZ2luZ1wiXSA9IDFdID0gXCJIYW5naW5nXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHRleHQgYmFzZWxpbmUgaXMgdGhlIG1pZGRsZSBvZiB0aGUgZW0gc3F1YXJlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJhc2VBbGlnbltCYXNlQWxpZ25bXCJNaWRkbGVcIl0gPSAyXSA9IFwiTWlkZGxlXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHRleHQgYmFzZWxpbmUgaXMgdGhlIG5vcm1hbCBhbHBoYWJldGljIGJhc2VsaW5lLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJhc2VBbGlnbltCYXNlQWxpZ25bXCJBbHBoYWJldGljXCJdID0gM10gPSBcIkFscGhhYmV0aWNcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdGV4dCBiYXNlbGluZSBpcyB0aGUgaWRlb2dyYXBoaWMgYmFzZWxpbmU7IHRoaXMgaXMgdGhlIGJvdHRvbSBvZlxyXG4gICAgICAgICAqIHRoZSBib2R5IG9mIHRoZSBjaGFyYWN0ZXJzLCBpZiB0aGUgbWFpbiBib2R5IG9mIGNoYXJhY3RlcnMgcHJvdHJ1ZGVzXHJcbiAgICAgICAgICogYmVuZWF0aCB0aGUgYWxwaGFiZXRpYyBiYXNlbGluZS4gIEN1cnJlbnRseSB1bnN1cHBvcnRlZDsgdGhpcyB3aWxsXHJcbiAgICAgICAgICogYWN0IGxpa2UgYWxwaGFiZXRpYy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBCYXNlQWxpZ25bQmFzZUFsaWduW1wiSWRlb2dyYXBoaWNcIl0gPSA0XSA9IFwiSWRlb2dyYXBoaWNcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdGV4dCBiYXNlbGluZSBpcyB0aGUgYm90dG9tIG9mIHRoZSBib3VuZGluZyBib3guICBUaGlzIGRpZmZlcnNcclxuICAgICAgICAgKiBmcm9tIHRoZSBpZGVvZ3JhcGhpYyBiYXNlbGluZSBpbiB0aGF0IHRoZSBpZGVvZ3JhcGhpYyBiYXNlbGluZVxyXG4gICAgICAgICAqIGRvZXNuJ3QgY29uc2lkZXIgZGVzY2VuZGVycy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBCYXNlQWxpZ25bQmFzZUFsaWduW1wiQm90dG9tXCJdID0gNV0gPSBcIkJvdHRvbVwiO1xyXG4gICAgfSkoQmFzZUFsaWduID0gZXhwb3J0cy5CYXNlQWxpZ24gfHwgKGV4cG9ydHMuQmFzZUFsaWduID0ge30pKTtcclxuICAgIC8qKlxyXG4gICAgICogRW51bSByZXByZXNlbnRpbmcgdGhlIGRpZmZlcmVudCBwb3NzaWJsZSBmb250IHN0eWxlc1xyXG4gICAgICovXHJcbiAgICB2YXIgRm9udFN0eWxlO1xyXG4gICAgKGZ1bmN0aW9uIChGb250U3R5bGUpIHtcclxuICAgICAgICBGb250U3R5bGVbRm9udFN0eWxlW1wiTm9ybWFsXCJdID0gMF0gPSBcIk5vcm1hbFwiO1xyXG4gICAgICAgIEZvbnRTdHlsZVtGb250U3R5bGVbXCJJdGFsaWNcIl0gPSAxXSA9IFwiSXRhbGljXCI7XHJcbiAgICAgICAgRm9udFN0eWxlW0ZvbnRTdHlsZVtcIk9ibGlxdWVcIl0gPSAyXSA9IFwiT2JsaXF1ZVwiO1xyXG4gICAgfSkoRm9udFN0eWxlID0gZXhwb3J0cy5Gb250U3R5bGUgfHwgKGV4cG9ydHMuRm9udFN0eWxlID0ge30pKTtcclxuICAgIC8qKlxyXG4gICAgICogQGhpZGRlblxyXG4gICAgICovXHJcbiAgICB2YXIgTGFiZWxJbXBsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoTGFiZWxJbXBsLCBfc3VwZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB0ZXh0ICAgICAgICBUaGUgdGV4dCBvZiB0aGUgbGFiZWxcclxuICAgICAgICAgKiBAcGFyYW0geCAgICAgICAgICAgVGhlIHggcG9zaXRpb24gb2YgdGhlIGxhYmVsXHJcbiAgICAgICAgICogQHBhcmFtIHkgICAgICAgICAgIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBsYWJlbFxyXG4gICAgICAgICAqIEBwYXJhbSBmb250RmFtaWx5ICBVc2UgYW55IHZhbGlkIENTUyBmb250IHN0cmluZyBmb3IgdGhlIGxhYmVsJ3MgZm9udC4gV2ViIGZvbnRzIGFyZSBzdXBwb3J0ZWQuIERlZmF1bHQgaXMgYDEwcHggc2Fucy1zZXJpZmAuXHJcbiAgICAgICAgICogQHBhcmFtIHNwcml0ZUZvbnQgIFVzZSBhbiBFeGNhbGlidXIgc3ByaXRlIGZvbnQgZm9yIHRoZSBsYWJlbCdzIGZvbnQsIGlmIGEgU3ByaXRlRm9udCBpcyBwcm92aWRlZCBpdCB3aWxsIHRha2UgcHJlY2VkZW5jZVxyXG4gICAgICAgICAqIG92ZXIgYSBjc3MgZm9udC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBMYWJlbEltcGwodGV4dE9yQ29uZmlnLCB4LCB5LCBmb250RmFtaWx5LCBzcHJpdGVGb250KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHRleHRPckNvbmZpZyAmJiB0eXBlb2YgdGV4dE9yQ29uZmlnID09PSAnb2JqZWN0JyA/IHtcclxuICAgICAgICAgICAgICAgIHg6IHRleHRPckNvbmZpZy54LFxyXG4gICAgICAgICAgICAgICAgeTogdGV4dE9yQ29uZmlnLnlcclxuICAgICAgICAgICAgfSA6IHsgeDogeCwgeTogeSB9KSB8fCB0aGlzO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0cyBvciBnZXRzIHRoZSBib2xkIHByb3BlcnR5IG9mIHRoZSBsYWJlbCdzIHRleHQsIGJ5IGRlZmF1bHQgaXQncyBmYWxzZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuYm9sZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGZvbnQgc2l6ZSBpbiB0aGUgc2VsZWN0ZWQgdW5pdHMsIGRlZmF1bHQgaXMgMTAgKGRlZmF1bHQgdW5pdHMgaXMgcGl4ZWwpXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5mb250U2l6ZSA9IDEwO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGZvbnQgc3R5bGUgZm9yIHRoaXMgbGFiZWwsIHRoZSBkZWZhdWx0IGlzIFtbRm9udFN0eWxlLk5vcm1hbF1dXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5mb250U3R5bGUgPSBGb250U3R5bGUuTm9ybWFsO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGNzcyB1bml0cyBmb3IgYSBmb250IHNpemUgc3VjaCBhcyBweCwgcHQsIGVtIChTcHJpdGVGb250IG9ubHkgc3VwcG9ydCBweCksIGJ5IGRlZmF1bHQgaXMgJ3B4JztcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmZvbnRVbml0ID0gRm9udFVuaXQuUHg7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGhvcml6b250YWwgdGV4dCBhbGlnbm1lbnQgcHJvcGVydHkgZm9yIHRoZSBsYWJlbC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLnRleHRBbGlnbiA9IFRleHRBbGlnbi5MZWZ0O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBiYXNlbGluZSBhbGlnbm1lbnQgcHJvcGVydHkgZm9yIHRoZSBsYWJlbC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmJhc2VBbGlnbiA9IEJhc2VBbGlnbi5Cb3R0b207XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGxldHRlciBzcGFjaW5nIG9uIGEgTGFiZWwuIE9ubHkgc3VwcG9ydGVkIHdpdGggU3ByaXRlIEZvbnRzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMubGV0dGVyU3BhY2luZyA9IDA7IC8vcHhcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBbW1Nwcml0ZUZvbnRdXSB3aWxsIGJlIGNhc2Utc2Vuc2l0aXZlIHdoZW4gbWF0Y2hpbmcgY2hhcmFjdGVycy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmNhc2VJbnNlbnNpdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gJyc7XHJcbiAgICAgICAgICAgIGlmICh0ZXh0T3JDb25maWcgJiYgdHlwZW9mIHRleHRPckNvbmZpZyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHkgPSB0ZXh0T3JDb25maWcuZm9udEZhbWlseTtcclxuICAgICAgICAgICAgICAgIHNwcml0ZUZvbnQgPSB0ZXh0T3JDb25maWcuc3ByaXRlRm9udDtcclxuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0T3JDb25maWcudGV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0T3JDb25maWc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMudGV4dCA9IHRleHQgfHwgJyc7XHJcbiAgICAgICAgICAgIF90aGlzLmNvbG9yID0gQ29sb3JfMTEuQ29sb3IuQmxhY2suY2xvbmUoKTtcclxuICAgICAgICAgICAgX3RoaXMuc3ByaXRlRm9udCA9IHNwcml0ZUZvbnQ7XHJcbiAgICAgICAgICAgIF90aGlzLmNvbGxpc2lvblR5cGUgPSBBY3Rvcl80LkNvbGxpc2lvblR5cGUuUHJldmVudENvbGxpc2lvbjtcclxuICAgICAgICAgICAgX3RoaXMuZm9udEZhbWlseSA9IGZvbnRGYW1pbHkgfHwgJ3NhbnMtc2VyaWYnOyAvLyBjb2FsZXNjZSB0byBkZWZhdWx0IGNhbnZhcyBmb250XHJcbiAgICAgICAgICAgIF90aGlzLl90ZXh0U2hhZG93T24gPSBmYWxzZTtcclxuICAgICAgICAgICAgX3RoaXMuX3NoYWRvd09mZnNldFggPSAwO1xyXG4gICAgICAgICAgICBfdGhpcy5fc2hhZG93T2Zmc2V0WSA9IDA7XHJcbiAgICAgICAgICAgIGlmIChzcHJpdGVGb250KSB7XHJcbiAgICAgICAgICAgICAgICAvL3RoaXMuX3RleHRTcHJpdGVzID0gc3ByaXRlRm9udC5nZXRUZXh0U3ByaXRlcygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIHRleHQgaW4gdGhlIGxhYmVsIChpbiBwaXhlbHMpO1xyXG4gICAgICAgICAqIEBwYXJhbSBjdHggIFJlbmRlcmluZyBjb250ZXh0IHRvIG1lYXN1cmUgdGhlIHN0cmluZyB3aXRoXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGFiZWxJbXBsLnByb3RvdHlwZS5nZXRUZXh0V2lkdGggPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgICAgICAgICAgIHZhciBvbGRGb250ID0gY3R4LmZvbnQ7XHJcbiAgICAgICAgICAgIGN0eC5mb250ID0gdGhpcy5fZm9udFN0cmluZztcclxuICAgICAgICAgICAgdmFyIHdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KHRoaXMudGV4dCkud2lkdGg7XHJcbiAgICAgICAgICAgIGN0eC5mb250ID0gb2xkRm9udDtcclxuICAgICAgICAgICAgcmV0dXJuIHdpZHRoO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gVHlwZVNjcmlwdCBkb2Vzbid0IHN1cHBvcnQgc3RyaW5nIGVudW1zIDooXHJcbiAgICAgICAgTGFiZWxJbXBsLnByb3RvdHlwZS5fbG9va3VwRm9udFVuaXQgPSBmdW5jdGlvbiAoZm9udFVuaXQpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChmb250VW5pdCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBGb250VW5pdC5FbTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2VtJztcclxuICAgICAgICAgICAgICAgIGNhc2UgRm9udFVuaXQuUmVtOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAncmVtJztcclxuICAgICAgICAgICAgICAgIGNhc2UgRm9udFVuaXQuUHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdwdCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEZvbnRVbml0LlB4OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAncHgnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBGb250VW5pdC5QZXJjZW50OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJSc7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAncHgnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBMYWJlbEltcGwucHJvdG90eXBlLl9sb29rdXBUZXh0QWxpZ24gPSBmdW5jdGlvbiAodGV4dEFsaWduKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGV4dEFsaWduKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFRleHRBbGlnbi5MZWZ0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnbGVmdCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFRleHRBbGlnbi5SaWdodDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3JpZ2h0JztcclxuICAgICAgICAgICAgICAgIGNhc2UgVGV4dEFsaWduLkNlbnRlcjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2NlbnRlcic7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFRleHRBbGlnbi5FbmQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdlbmQnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBUZXh0QWxpZ24uU3RhcnQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdzdGFydCc7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnc3RhcnQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBMYWJlbEltcGwucHJvdG90eXBlLl9sb29rdXBCYXNlQWxpZ24gPSBmdW5jdGlvbiAoYmFzZUFsaWduKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoYmFzZUFsaWduKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEJhc2VBbGlnbi5BbHBoYWJldGljOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnYWxwaGFiZXRpYyc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEJhc2VBbGlnbi5Cb3R0b206XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdib3R0b20nO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBCYXNlQWxpZ24uSGFuZ2luZzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hhbmdpbic7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEJhc2VBbGlnbi5JZGVvZ3JhcGhpYzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2lkZW9ncmFwaGljJztcclxuICAgICAgICAgICAgICAgIGNhc2UgQmFzZUFsaWduLk1pZGRsZTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ21pZGRsZSc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEJhc2VBbGlnbi5Ub3A6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0b3AnO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2FscGhhYmV0aWMnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBMYWJlbEltcGwucHJvdG90eXBlLl9sb29rdXBGb250U3R5bGUgPSBmdW5jdGlvbiAoZm9udFN0eWxlKSB7XHJcbiAgICAgICAgICAgIHZhciBib2xkc3RyaW5nID0gdGhpcy5ib2xkID8gJyBib2xkJyA6ICcnO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGZvbnRTdHlsZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBGb250U3R5bGUuSXRhbGljOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnaXRhbGljJyArIGJvbGRzdHJpbmc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEZvbnRTdHlsZS5Ob3JtYWw6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdub3JtYWwnICsgYm9sZHN0cmluZztcclxuICAgICAgICAgICAgICAgIGNhc2UgRm9udFN0eWxlLk9ibGlxdWU6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdvYmxpcXVlJyArIGJvbGRzdHJpbmc7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnbm9ybWFsJyArIGJvbGRzdHJpbmc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIHRleHQgc2hhZG93IGZvciBzcHJpdGUgZm9udHNcclxuICAgICAgICAgKiBAcGFyYW0gb2Zmc2V0WCAgICAgIFRoZSB4IG9mZnNldCBpbiBwaXhlbHMgdG8gcGxhY2UgdGhlIHNoYWRvd1xyXG4gICAgICAgICAqIEBwYXJhbSBvZmZzZXRZICAgICAgVGhlIHkgb2Zmc2V0IGluIHBpeGVscyB0byBwbGFjZSB0aGUgc2hhZG93XHJcbiAgICAgICAgICogQHBhcmFtIHNoYWRvd0NvbG9yICBUaGUgY29sb3Igb2YgdGhlIHRleHQgc2hhZG93XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGFiZWxJbXBsLnByb3RvdHlwZS5zZXRUZXh0U2hhZG93ID0gZnVuY3Rpb24gKG9mZnNldFgsIG9mZnNldFksIHNoYWRvd0NvbG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlRm9udC5zZXRUZXh0U2hhZG93KG9mZnNldFgsIG9mZnNldFksIHNoYWRvd0NvbG9yKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRvZ2dsZXMgdGV4dCBzaGFkb3dzIG9uIG9yIG9mZiwgb25seSBhcHBsaWVzIHdoZW4gdXNpbmcgc3ByaXRlIGZvbnRzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGFiZWxJbXBsLnByb3RvdHlwZS51c2VUZXh0U2hhZG93ID0gZnVuY3Rpb24gKG9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlRm9udC51c2VUZXh0U2hhZG93KG9uKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENsZWFycyB0aGUgY3VycmVudCB0ZXh0IHNoYWRvd1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExhYmVsSW1wbC5wcm90b3R5cGUuY2xlYXJUZXh0U2hhZG93ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl90ZXh0U2hhZG93T24gPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fc2hhZG93T2Zmc2V0WCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3NoYWRvd09mZnNldFkgPSAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgTGFiZWxJbXBsLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZW5naW5lLCBkZWx0YSkge1xyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMsIGVuZ2luZSwgZGVsdGEpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgTGFiZWxJbXBsLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGN0eCwgZGVsdGEpIHtcclxuICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLnBvcy54LCB0aGlzLnBvcy55KTtcclxuICAgICAgICAgICAgY3R4LnNjYWxlKHRoaXMuc2NhbGUueCwgdGhpcy5zY2FsZS55KTtcclxuICAgICAgICAgICAgY3R4LnJvdGF0ZSh0aGlzLnJvdGF0aW9uKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3RleHRTaGFkb3dPbikge1xyXG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUodGhpcy5fc2hhZG93T2Zmc2V0WCwgdGhpcy5fc2hhZG93T2Zmc2V0WSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mb250RHJhdyhjdHgpO1xyXG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9mb250RHJhdyhjdHgpO1xyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRyYXcuY2FsbCh0aGlzLCBjdHgsIGRlbHRhKTtcclxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIExhYmVsSW1wbC5wcm90b3R5cGUuX2ZvbnREcmF3ID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zcHJpdGVGb250KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZUZvbnQuZHJhdyhjdHgsIHRoaXMudGV4dCwgMCwgMCwge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLmNsb25lKCksXHJcbiAgICAgICAgICAgICAgICAgICAgYmFzZUFsaWduOiB0aGlzLmJhc2VBbGlnbixcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IHRoaXMudGV4dEFsaWduLFxyXG4gICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiB0aGlzLmZvbnRTaXplLFxyXG4gICAgICAgICAgICAgICAgICAgIGxldHRlclNwYWNpbmc6IHRoaXMubGV0dGVyU3BhY2luZyxcclxuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiB0aGlzLm9wYWNpdHlcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9sZEFsaWduID0gY3R4LnRleHRBbGlnbjtcclxuICAgICAgICAgICAgICAgIHZhciBvbGRUZXh0QmFzZWxpbmUgPSBjdHgudGV4dEJhc2VsaW5lO1xyXG4gICAgICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IHRoaXMuX2xvb2t1cFRleHRBbGlnbih0aGlzLnRleHRBbGlnbik7XHJcbiAgICAgICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gdGhpcy5fbG9va3VwQmFzZUFsaWduKHRoaXMuYmFzZUFsaWduKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2xvci5hID0gdGhpcy5vcGFjaXR5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuY29sb3IudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIGN0eC5mb250ID0gdGhpcy5fZm9udFN0cmluZztcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1heFdpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KHRoaXMudGV4dCwgMCwgMCwgdGhpcy5tYXhXaWR0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQodGhpcy50ZXh0LCAwLCAwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSBvbGRBbGlnbjtcclxuICAgICAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBvbGRUZXh0QmFzZWxpbmU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMYWJlbEltcGwucHJvdG90eXBlLCBcIl9mb250U3RyaW5nXCIsIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9va3VwRm9udFN0eWxlKHRoaXMuZm9udFN0eWxlKSArIFwiIFwiICsgdGhpcy5mb250U2l6ZSArIHRoaXMuX2xvb2t1cEZvbnRVbml0KHRoaXMuZm9udFVuaXQpICsgXCIgXCIgKyB0aGlzLmZvbnRGYW1pbHk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIExhYmVsSW1wbC5wcm90b3R5cGUuZGVidWdEcmF3ID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRlYnVnRHJhdy5jYWxsKHRoaXMsIGN0eCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gTGFiZWxJbXBsO1xyXG4gICAgfShBY3Rvcl80LkFjdG9yKSk7XHJcbiAgICBleHBvcnRzLkxhYmVsSW1wbCA9IExhYmVsSW1wbDtcclxuICAgIC8qKlxyXG4gICAgICogTGFiZWxzIGFyZSB0aGUgd2F5IHRvIGRyYXcgc21hbGwgYW1vdW50cyBvZiB0ZXh0IHRvIHRoZSBzY3JlZW4uIFRoZXkgYXJlXHJcbiAgICAgKiBhY3RvcnMgYW5kIGluaGVyaXQgYWxsIG9mIHRoZSBiZW5lZml0cyBhbmQgY2FwYWJpbGl0aWVzLlxyXG4gICAgICpcclxuICAgICAqIFtbaW5jbHVkZTpMYWJlbHMubWRdXVxyXG4gICAgICovXHJcbiAgICB2YXIgTGFiZWwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhMYWJlbCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBMYWJlbCh0ZXh0T3JDb25maWcsIHgsIHksIGZvbnRGYW1pbHksIHNwcml0ZUZvbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHRleHRPckNvbmZpZywgeCwgeSwgZm9udEZhbWlseSwgc3ByaXRlRm9udCkgfHwgdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIExhYmVsO1xyXG4gICAgfShDb25maWd1cmFibGVfNC5Db25maWd1cmFibGUoTGFiZWxJbXBsKSkpO1xyXG4gICAgZXhwb3J0cy5MYWJlbCA9IExhYmVsO1xyXG59KTtcclxuZGVmaW5lKFwiSW50ZXJmYWNlcy9JQXVkaW9cIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxufSk7XHJcbmRlZmluZShcIkludGVyZmFjZXMvSUF1ZGlvSW1wbGVtZW50YXRpb25cIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxufSk7XHJcbmRlZmluZShcIlJlc291cmNlcy9Tb3VuZFwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIlV0aWwvTG9nXCIsIFwiVXRpbC9VdGlsXCIsIFwiUHJvbWlzZXNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBMb2dfNSwgVXRpbCwgUHJvbWlzZXNfNSkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvLyBzZXQgdXAgYXVkaW8gY29udGV4dCByZWZlcmVuY2VcclxuICAgIC8vIHdoZW4gd2UgaW50cm9kdWNlIG11bHRpLXRyYWNraW5nLCB3ZSBtYXkgbmVlZCB0byBtb3ZlIHRoaXMgdG8gYSBmYWN0b3J5IG1ldGhvZFxyXG4gICAgaWYgKHdpbmRvdy5BdWRpb0NvbnRleHQpIHtcclxuICAgICAgICB2YXIgYXVkaW9Db250ZXh0ID0gbmV3IHdpbmRvdy5BdWRpb0NvbnRleHQoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQW4gYXVkaW8gaW1wbGVtZW50YXRpb24gZm9yIEhUTUw1IGF1ZGlvLlxyXG4gICAgICovXHJcbiAgICB2YXIgQXVkaW9UYWcgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIEF1ZGlvVGFnKCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlc3BvbnNlVHlwZSA9ICdibG9iJztcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVHJhbnNmb3JtcyByYXcgQmxvYiBkYXRhIGludG8gYSBvYmplY3QgVVJMIGZvciB1c2UgaW4gYXVkaW8gdGFnXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQXVkaW9UYWcucHJvdG90eXBlLnByb2Nlc3NEYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgdmFyIHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoZGF0YSk7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlc181LlByb21pc2UucmVzb2x2ZSh1cmwpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhbiBhdWRpbyB0YWcgcmVmZXJlbmNpbmcgdGhlIHByb3ZpZGVkIGF1ZGlvIFVSTFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEF1ZGlvVGFnLnByb3RvdHlwZS5jcmVhdGVJbnN0YW5jZSA9IGZ1bmN0aW9uICh1cmwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBdWRpb1RhZ0luc3RhbmNlKHVybCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gQXVkaW9UYWc7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5BdWRpb1RhZyA9IEF1ZGlvVGFnO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhdWRpbyBpbXBsZW1lbnRhdGlvbiBmb3IgV2ViIEF1ZGlvIEFQSS5cclxuICAgICAqL1xyXG4gICAgdmFyIFdlYkF1ZGlvID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBXZWJBdWRpbygpIHtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyID0gTG9nXzUuTG9nZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgICAgIHRoaXMucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJvY2Vzc2VzIHJhdyBhcnJheWJ1ZmZlciBkYXRhIGFuZCBkZWNvZGVzIGludG8gV2ViQXVkaW8gYnVmZmVyIChhc3luYykuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgV2ViQXVkaW8ucHJvdG90eXBlLnByb2Nlc3NEYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGNvbXBsZXRlID0gbmV3IFByb21pc2VzXzUuUHJvbWlzZSgpO1xyXG4gICAgICAgICAgICBhdWRpb0NvbnRleHQuZGVjb2RlQXVkaW9EYXRhKGRhdGEsIGZ1bmN0aW9uIChidWZmZXIpIHtcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlLnJlc29sdmUoYnVmZmVyKTtcclxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci5lcnJvcignVW5hYmxlIHRvIGRlY29kZSAnICtcclxuICAgICAgICAgICAgICAgICAgICAnIHRoaXMgYnJvd3NlciBtYXkgbm90IGZ1bGx5IHN1cHBvcnQgdGhpcyBmb3JtYXQsIG9yIHRoZSBmaWxlIG1heSBiZSBjb3JydXB0LCAnICtcclxuICAgICAgICAgICAgICAgICAgICAnaWYgdGhpcyBpcyBhbiBtcDMgdHJ5IHJlbW92aW5nIGlkMyB0YWdzIGFuZCBhbGJ1bSBhcnQgZnJvbSB0aGUgZmlsZS4nKTtcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlLnJlc29sdmUodW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgV2ViQXVkaW8gQXVkaW9CdWZmZXJTb3VyY2VOb2RlIHRvIHBsYXkgYSBzb3VuZCBpbnN0YW5jZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFdlYkF1ZGlvLnByb3RvdHlwZS5jcmVhdGVJbnN0YW5jZSA9IGZ1bmN0aW9uIChidWZmZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBXZWJBdWRpb0luc3RhbmNlKGJ1ZmZlcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQbGF5IGFuIGVtcHR5IHNvdW5kIHRvIHVubG9jayBTYWZhcmkgV2ViQXVkaW8gY29udGV4dC4gQ2FsbCB0aGlzIGZ1bmN0aW9uXHJcbiAgICAgICAgICogcmlnaHQgYWZ0ZXIgYSB1c2VyIGludGVyYWN0aW9uIGV2ZW50LiBUeXBpY2FsbHkgdXNlZCBieSBbW1BhdXNlQWZ0ZXJMb2FkZXJdXVxyXG4gICAgICAgICAqIEBzb3VyY2UgaHR0cHM6Ly9wYXVsYmFrYXVzLmNvbS90dXRvcmlhbHMvaHRtbDUvd2ViLWF1ZGlvLW9uLWlvcy9cclxuICAgICAgICAgKi9cclxuICAgICAgICBXZWJBdWRpby51bmxvY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChXZWJBdWRpby5fdW5sb2NrZWQgfHwgIWF1ZGlvQ29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBlbXB0eSBidWZmZXIgYW5kIHBsYXkgaXRcclxuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IGF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXIoMSwgMSwgMjIwNTApO1xyXG4gICAgICAgICAgICB2YXIgc291cmNlID0gYXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xyXG4gICAgICAgICAgICB2YXIgZW5kZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgc291cmNlLmJ1ZmZlciA9IGJ1ZmZlcjtcclxuICAgICAgICAgICAgc291cmNlLmNvbm5lY3QoYXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uKTtcclxuICAgICAgICAgICAgc291cmNlLm9uZW5kZWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBlbmRlZCA9IHRydWU7IH07XHJcbiAgICAgICAgICAgIGlmIChzb3VyY2Uubm90ZU9uKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBkZXByZWNhdGVkXHJcbiAgICAgICAgICAgICAgICBzb3VyY2Uubm90ZU9uKDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc291cmNlLnN0YXJ0KDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGJ5IGNoZWNraW5nIHRoZSBwbGF5IHN0YXRlIGFmdGVyIHNvbWUgdGltZSwgd2Uga25vdyBpZiB3ZSdyZSByZWFsbHkgdW5sb2NrZWRcclxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLnBsYXliYWNrU3RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGVnYWN5U291cmNlID0gc291cmNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWdhY3lTb3VyY2UucGxheWJhY2tTdGF0ZSA9PT0gbGVnYWN5U291cmNlLlBMQVlJTkdfU1RBVEUgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVnYWN5U291cmNlLnBsYXliYWNrU3RhdGUgPT09IGxlZ2FjeVNvdXJjZS5GSU5JU0hFRF9TVEFURSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBXZWJBdWRpby5fdW5sb2NrZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhdWRpb0NvbnRleHQuY3VycmVudFRpbWUgPiAwIHx8IGVuZGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFdlYkF1ZGlvLl91bmxvY2tlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCAwKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFdlYkF1ZGlvLmlzVW5sb2NrZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl91bmxvY2tlZDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBXZWJBdWRpbztcclxuICAgIH0oKSk7XHJcbiAgICBXZWJBdWRpby5fdW5sb2NrZWQgPSBmYWxzZTtcclxuICAgIGV4cG9ydHMuV2ViQXVkaW8gPSBXZWJBdWRpbztcclxuICAgIC8qKlxyXG4gICAgICogRmFjdG9yeSBtZXRob2QgdGhhdCBnZXRzIHRoZSBhdWRpbyBpbXBsZW1lbnRhdGlvbiB0byB1c2VcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0QXVkaW9JbXBsZW1lbnRhdGlvbigpIHtcclxuICAgICAgICBpZiAod2luZG93LkF1ZGlvQ29udGV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkF1ZGlvKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEF1ZGlvVGFnKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5nZXRBdWRpb0ltcGxlbWVudGF0aW9uID0gZ2V0QXVkaW9JbXBsZW1lbnRhdGlvbjtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIFtbU291bmRdXSBvYmplY3QgYWxsb3dzIGdhbWVzIGJ1aWx0IGluIEV4Y2FsaWJ1ciB0byBsb2FkIGF1ZGlvXHJcbiAgICAgKiBjb21wb25lbnRzLCBmcm9tIHNvdW5kdHJhY2tzIHRvIHNvdW5kIGVmZmVjdHMuIFtbU291bmRdXSBpcyBhbiBbW0lMb2FkYWJsZV1dXHJcbiAgICAgKiB3aGljaCBtZWFucyBpdCBjYW4gYmUgcGFzc2VkIHRvIGEgW1tMb2FkZXJdXSB0byBwcmUtbG9hZCBiZWZvcmUgYSBnYW1lIG9yIGxldmVsLlxyXG4gICAgICpcclxuICAgICAqIFtbaW5jbHVkZTpTb3VuZHMubWRdXVxyXG4gICAgICovXHJcbiAgICB2YXIgU291bmQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBwYXRocyBBIGxpc3Qgb2YgYXVkaW8gc291cmNlcyAoY2xpcC53YXYsIGNsaXAubXAzLCBjbGlwLm9nZykgZm9yIHRoaXMgYXVkaW8gY2xpcC4gVGhpcyBpcyBkb25lIGZvciBicm93c2VyIGNvbXBhdGliaWxpdHkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gU291bmQoKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXRocyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgcGF0aHNbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIgPSBMb2dfNS5Mb2dnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgdGhpcy5fZGF0YSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuX3RyYWNrcyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLl9pc0xvYWRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZvbHVtZSA9IDEuMDtcclxuICAgICAgICAgICAgdGhpcy5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XHJcbiAgICAgICAgICAgIHRoaXMub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuOyB9O1xyXG4gICAgICAgICAgICB0aGlzLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7IHJldHVybjsgfTtcclxuICAgICAgICAgICAgdGhpcy5fd2FzUGxheWluZ09uSGlkZGVuID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8qIENocm9tZSA6IE1QMywgV0FWLCBPZ2dcclxuICAgICAgICAgICAgICAgKiBGaXJlZm94IDogV0FWLCBPZ2csXHJcbiAgICAgICAgICAgICAgICogSUUgOiBNUDMsIFdBViBjb21pbmcgc29vblxyXG4gICAgICAgICAgICAgICAqIFNhZmFyaSBNUDMsIFdBViwgT2dnXHJcbiAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMucGF0aCA9ICcnO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfYSA9IDAsIHBhdGhzXzEgPSBwYXRoczsgX2EgPCBwYXRoc18xLmxlbmd0aDsgX2ErKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhdGggPSBwYXRoc18xW19hXTtcclxuICAgICAgICAgICAgICAgIGlmIChTb3VuZC5jYW5QbGF5RmlsZShwYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF0aGlzLnBhdGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKCdUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBhbnkgb2YgdGhlIGF1ZGlvIGZpbGVzIHNwZWNpZmllZDonLCBwYXRocy5qb2luKCcsICcpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKCdBdHRlbXB0aW5nIHRvIHVzZScsIHBhdGhzWzBdKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGF0aCA9IHBhdGhzWzBdOyAvLyBzZWxlY3QgdGhlIGZpcnN0IHNwZWNpZmllZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc291bmQgPSBnZXRBdWRpb0ltcGxlbWVudGF0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBicm93c2VyIGNhbiBwbGF5IHRoaXMgZmlsZSBhcyBIVE1MNSBBdWRpb1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNvdW5kLmNhblBsYXlGaWxlID0gZnVuY3Rpb24gKGZpbGUpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHZhciBhID0gbmV3IEF1ZGlvKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmlsZXR5cGUgPSAvLipcXC4oW0EtWmEtejAtOV0rKSQvO1xyXG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBmaWxlLm1hdGNoKGZpbGV0eXBlKVsxXTtcclxuICAgICAgICAgICAgICAgIGlmIChhLmNhblBsYXlUeXBlKCdhdWRpby8nICsgdHlwZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgTG9nXzUuTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybignQ2Fubm90IGRldGVybWluZSBhdWRpbyBzdXBwb3J0LCBhc3N1bWluZyBubyBzdXBwb3J0IGZvciB0aGUgQXVkaW8gVGFnJywgZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFNvdW5kLnByb3RvdHlwZS53aXJlRW5naW5lID0gZnVuY3Rpb24gKGVuZ2luZSkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAoZW5naW5lKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmdpbmUgPSBlbmdpbmU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmdpbmUub24oJ2hpZGRlbicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZW5naW5lLnBhdXNlQXVkaW9XaGVuSGlkZGVuICYmIF90aGlzLmlzUGxheWluZygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl93YXNQbGF5aW5nT25IaWRkZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wYXVzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZW5naW5lLm9uKCd2aXNpYmxlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmdpbmUucGF1c2VBdWRpb1doZW5IaWRkZW4gJiYgX3RoaXMuX3dhc1BsYXlpbmdPbkhpZGRlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wbGF5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl93YXNQbGF5aW5nT25IaWRkZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBob3cgbWFueSBpbnN0YW5jZXMgb2YgdGhlIHNvdW5kIGFyZSBjdXJyZW50bHkgcGxheWluZ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNvdW5kLnByb3RvdHlwZS5pbnN0YW5jZUNvdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhY2tzLmxlbmd0aDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIHZvbHVtZSBvZiB0aGUgc291bmQgY2xpcFxyXG4gICAgICAgICAqIEBwYXJhbSB2b2x1bWUgIEEgdm9sdW1lIHZhbHVlIGJldHdlZW4gMC0xLjBcclxuICAgICAgICAgKi9cclxuICAgICAgICBTb3VuZC5wcm90b3R5cGUuc2V0Vm9sdW1lID0gZnVuY3Rpb24gKHZvbHVtZSkge1xyXG4gICAgICAgICAgICB0aGlzLl92b2x1bWUgPSB2b2x1bWU7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl90cmFja3M7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHJhY2sgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICB0cmFjay5zZXRWb2x1bWUodm9sdW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoJ1NldCB2b2x1bWUgZm9yIGFsbCBpbnN0YW5jZXMgb2Ygc291bmQnLCB0aGlzLnBhdGgsICd0bycsIHZvbHVtZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgY2xpcCBzaG91bGQgbG9vcCB3aGVuIGNvbXBsZXRlXHJcbiAgICAgICAgICogQHBhcmFtIGxvb3AgIFNldCB0aGUgbG9vcGluZyBmbGFnXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU291bmQucHJvdG90eXBlLnNldExvb3AgPSBmdW5jdGlvbiAobG9vcCkge1xyXG4gICAgICAgICAgICB0aGlzLl9sb29wID0gbG9vcDtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuX3RyYWNrczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciB0cmFjayA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgIHRyYWNrLnNldExvb3AobG9vcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCdTZXQgbG9vcCBmb3IgYWxsIGluc3RhbmNlcyBvZiBzb3VuZCcsIHRoaXMucGF0aCwgJ3RvJywgbG9vcCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgc291bmQgaXMgcGxheWluZyByaWdodCBub3dcclxuICAgICAgICAgKi9cclxuICAgICAgICBTb3VuZC5wcm90b3R5cGUuaXNQbGF5aW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhY2tzLnNvbWUoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQuaXNQbGF5aW5nKCk7IH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGxheSB0aGUgc291bmQsIHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgc291bmQgaXMgZG9uZSBwbGF5aW5nXHJcbiAgICAgICAgICogQW4gb3B0aW9uYWwgdm9sdW1lIGFyZ3VtZW50IGNhbiBiZSBwYXNzZWQgaW4gdG8gcGxheSB0aGUgc291bmQuIE1heCB2b2x1bWUgaXMgMS4wXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU291bmQucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAodm9sdW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0xvYWRlZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VtZWQgPSBbXTtcclxuICAgICAgICAgICAgICAgIC8vIGVuc3VyZSB3ZSByZXN1bWUgKmN1cnJlbnQqIHRyYWNrcyAoaWYgcGF1c2VkKVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuX3RyYWNrczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhY2sgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdW1lZC5wdXNoKHRyYWNrLnBsYXkoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHBhdXNlZCwgZG9uJ3Qgc3RhcnQgcGxheWluZyBuZXcgdHJhY2tcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc1BhdXNlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCdSZXN1bWluZyBwYXVzZWQgaW5zdGFuY2VzIGZvciBzb3VuZCcsIHRoaXMucGF0aCwgdGhpcy5fdHJhY2tzKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyByZXNvbHZlIHdoZW4gcmVzdW1lZCB0cmFja3MgYXJlIGRvbmVcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZXNfNS5Qcm9taXNlLmpvaW4ocmVzdW1lZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBwdXNoIGEgbmV3IHRyYWNrXHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3VHJhY2sgPSB0aGlzLnNvdW5kLmNyZWF0ZUluc3RhbmNlKHRoaXMuX2RhdGEpO1xyXG4gICAgICAgICAgICAgICAgbmV3VHJhY2suc2V0TG9vcCh0aGlzLl9sb29wKTtcclxuICAgICAgICAgICAgICAgIGlmICh2b2x1bWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdUcmFjay5zZXRWb2x1bWUoVXRpbC5jbGFtcCh2b2x1bWUsIDAuMCwgMS4wKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdUcmFjay5zZXRWb2x1bWUodGhpcy5fdm9sdW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYWNrcy5wdXNoKG5ld1RyYWNrKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZygnUGxheWluZyBuZXcgaW5zdGFuY2UgZm9yIHNvdW5kJywgdGhpcy5wYXRoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdUcmFjay5wbGF5KCkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiBkb25lLCByZW1vdmUgdHJhY2tcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fdHJhY2tzLnNwbGljZShfdGhpcy5fdHJhY2tzLmluZGV4T2YobmV3VHJhY2spLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2VzXzUuUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTdG9wIHRoZSBzb3VuZCwgYW5kIGRvIG5vdCByZXdpbmRcclxuICAgICAgICAgKi9cclxuICAgICAgICBTb3VuZC5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl90cmFja3M7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHJhY2sgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICB0cmFjay5wYXVzZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2lzUGF1c2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCdQYXVzZWQgYWxsIGluc3RhbmNlcyBvZiBzb3VuZCcsIHRoaXMucGF0aCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTdG9wIHRoZSBzb3VuZCBhbmQgcmV3aW5kXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU291bmQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHZhciB0cmFja3MgPSB0aGlzLl90cmFja3MuY29uY2F0KFtdKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCB0cmFja3NfMSA9IHRyYWNrczsgX2kgPCB0cmFja3NfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciB0cmFjayA9IHRyYWNrc18xW19pXTtcclxuICAgICAgICAgICAgICAgIHRyYWNrLnN0b3AoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoJ1N0b3BwZWQgYWxsIGluc3RhbmNlcyBvZiBzb3VuZCcsIHRoaXMucGF0aCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNvdW5kIGlzIGxvYWRlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNvdW5kLnByb3RvdHlwZS5pc0xvYWRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzTG9hZGVkO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQmVnaW5zIGxvYWRpbmcgdGhlIHNvdW5kIGFuZCByZXR1cm5zIGEgcHJvbWlzZSB0byBiZSByZXNvbHZlZCBvbiBjb21wbGV0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU291bmQucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBjb21wbGV0ZSA9IG5ldyBQcm9taXNlc181LlByb21pc2UoKTtcclxuICAgICAgICAgICAgaWYgKCEhdGhpcy5nZXREYXRhKCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZygnQWxyZWFkeSBoYXZlIGRhdGEgZm9yIGF1ZGlvIHJlc291cmNlJywgdGhpcy5wYXRoKTtcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlLnJlc29sdmUodGhpcy5zb3VuZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uY29tcGxldGUoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoJ1N0YXJ0ZWQgbG9hZGluZyBzb3VuZCcsIHRoaXMucGF0aCk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mZXRjaFJlc291cmNlKGZ1bmN0aW9uIChyZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzICE9PSAyMDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci5lcnJvcignRmFpbGVkIHRvIGxvYWQgYXVkaW8gcmVzb3VyY2UgJywgX3RoaXMucGF0aCwgJyBzZXJ2ZXIgcmVzcG9uZGVkIHdpdGggZXJyb3IgY29kZScsIHJlcXVlc3Quc3RhdHVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub25lcnJvcihyZXF1ZXN0LnJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGUucmVzb2x2ZShudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBsb2FkIHNvdW5kXHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0RGF0YShyZXF1ZXN0LnJlc3BvbnNlKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub25jb21wbGV0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmRlYnVnKCdDb21wbGV0ZWQgbG9hZGluZyBzb3VuZCcsIF90aGlzLnBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZS5yZXNvbHZlKF90aGlzLnNvdW5kKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gY29tcGxldGUucmVzb2x2ZShlKTsgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKCdFcnJvciBsb2FkaW5nIHNvdW5kISBJZiB0aGlzIGlzIGEgY3Jvc3Mgb3JpZ2luIGVycm9yLCBcXFxyXG4gICAgICAgICAgICB5b3UgbXVzdCBob3N0IHlvdXIgc291bmQgd2l0aCB5b3VyIGh0bWwgYW5kIGphdmFzY3JpcHQuJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uZXJyb3IoZSk7XHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZS5yZXNvbHZlKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgU291bmQucHJvdG90eXBlLl9mZXRjaFJlc291cmNlID0gZnVuY3Rpb24gKG9ubG9hZCkge1xyXG4gICAgICAgICAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgICAgICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIHRoaXMucGF0aCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gdGhpcy5zb3VuZC5yZXNwb25zZVR5cGU7XHJcbiAgICAgICAgICAgIHJlcXVlc3Qub25wcm9ncmVzcyA9IHRoaXMub25wcm9ncmVzcztcclxuICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gdGhpcy5vbmVycm9yO1xyXG4gICAgICAgICAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9ubG9hZChyZXF1ZXN0KTsgfTtcclxuICAgICAgICAgICAgcmVxdWVzdC5zZW5kKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSByYXcgc291bmQgZGF0YSAoZS5nLiBibG9iIFVSTCBvciBBdWRpb0J1ZmZlcilcclxuICAgICAgICAgKi9cclxuICAgICAgICBTb3VuZC5wcm90b3R5cGUuZ2V0RGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHJhdyBzb3VuZCBkYXRhIGFuZCByZXR1cm5zIGEgUHJvbWlzZSB0aGF0IGlzIHJlc29sdmVkIHdoZW4gc291bmQgZGF0YSBpcyBwcm9jZXNzZWRcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBkYXRhIFRoZSBYSFIgZGF0YSBmb3IgdGhlIHNvdW5kIGltcGxlbWVudGF0aW9uIHRvIHByb2Nlc3MgKEJsb2Igb3IgQXJyYXlCdWZmZXIpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU291bmQucHJvdG90eXBlLnNldERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zb3VuZC5wcm9jZXNzRGF0YShkYXRhKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5faXNMb2FkZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2RhdGEgPSBfdGhpcy5wcm9jZXNzRGF0YShkYXRhKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCB0aGUgcmF3IHNvdW5kIGRhdGEgKGUuZy4gYmxvYiBVUkwgb3IgQXVkaW9CdWZmZXIpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU291bmQucHJvdG90eXBlLnByb2Nlc3NEYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gU291bmQ7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5Tb3VuZCA9IFNvdW5kO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcm5hbCBjbGFzcyByZXByZXNlbnRpbmcgYSBIVE1MNSBhdWRpbyBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgdmFyIEF1ZGlvVGFnSW5zdGFuY2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIEF1ZGlvVGFnSW5zdGFuY2Uoc3JjKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2F1ZGlvRWxlbWVudCA9IG5ldyBBdWRpbyhzcmMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBBdWRpb1RhZ0luc3RhbmNlLnByb3RvdHlwZS5pc1BsYXlpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1BsYXlpbmc7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXVkaW9UYWdJbnN0YW5jZS5wcm90b3R5cGUsIFwibG9vcFwiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvb3A7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIEF1ZGlvVGFnSW5zdGFuY2UucHJvdG90eXBlLnNldExvb3AgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fbG9vcCA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLl9hdWRpb0VsZW1lbnQubG9vcCA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLl93aXJlVXBPbkVuZGVkKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBdWRpb1RhZ0luc3RhbmNlLnByb3RvdHlwZS5zZXRWb2x1bWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fYXVkaW9FbGVtZW50LnZvbHVtZSA9IFV0aWwuY2xhbXAodmFsdWUsIDAsIDEuMCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBdWRpb1RhZ0luc3RhbmNlLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNQYXVzZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3VtZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLl9pc1BsYXlpbmcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BsYXlpbmdQcm9taXNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQXVkaW9UYWdJbnN0YW5jZS5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9hdWRpb0VsZW1lbnQubG9hZCgpO1xyXG4gICAgICAgICAgICB0aGlzLl9hdWRpb0VsZW1lbnQubG9vcCA9IHRoaXMuX2xvb3A7XHJcbiAgICAgICAgICAgIHRoaXMuX2F1ZGlvRWxlbWVudC5wbGF5KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzUGxheWluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3BsYXlpbmdQcm9taXNlID0gbmV3IFByb21pc2VzXzUuUHJvbWlzZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl93aXJlVXBPbkVuZGVkKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBdWRpb1RhZ0luc3RhbmNlLnByb3RvdHlwZS5fcmVzdW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzUGF1c2VkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fYXVkaW9FbGVtZW50LnBsYXkoKTtcclxuICAgICAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fd2lyZVVwT25FbmRlZCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQXVkaW9UYWdJbnN0YW5jZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNQbGF5aW5nKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fYXVkaW9FbGVtZW50LnBhdXNlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzUGF1c2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBdWRpb1RhZ0luc3RhbmNlLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzUGxheWluZykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2F1ZGlvRWxlbWVudC5wYXVzZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9hdWRpb0VsZW1lbnQuY3VycmVudFRpbWUgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVPbkVuZGVkKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBdWRpb1RhZ0luc3RhbmNlLnByb3RvdHlwZS5fd2lyZVVwT25FbmRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9sb29wKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hdWRpb0VsZW1lbnQub25lbmRlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9oYW5kbGVPbkVuZGVkKCk7IH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEF1ZGlvVGFnSW5zdGFuY2UucHJvdG90eXBlLl9oYW5kbGVPbkVuZGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fcGxheWluZ1Byb21pc2UucmVzb2x2ZSh0cnVlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBBdWRpb1RhZ0luc3RhbmNlO1xyXG4gICAgfSgpKTtcclxuICAgIC8qKlxyXG4gICAgICogSW50ZXJuYWwgY2xhc3MgcmVwcmVzZW50aW5nIGEgV2ViIEF1ZGlvIEF1ZGlvQnVmZmVyU291cmNlTm9kZSBpbnN0YW5jZVxyXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2ViX0F1ZGlvX0FQSVxyXG4gICAgICovXHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgdmFyIFdlYkF1ZGlvSW5zdGFuY2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIFdlYkF1ZGlvSW5zdGFuY2UoX2J1ZmZlcikge1xyXG4gICAgICAgICAgICB0aGlzLl9idWZmZXIgPSBfYnVmZmVyO1xyXG4gICAgICAgICAgICB0aGlzLl92b2x1bWVOb2RlID0gYXVkaW9Db250ZXh0LmNyZWF0ZUdhaW4oKTtcclxuICAgICAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEN1cnJlbnQgcGxheWJhY2sgb2Zmc2V0IChpbiBzZWNvbmRzKVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudE9mZnNldCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFdlYkF1ZGlvSW5zdGFuY2UucHJvdG90eXBlLmlzUGxheWluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzUGxheWluZztcclxuICAgICAgICB9O1xyXG4gICAgICAgIFdlYkF1ZGlvSW5zdGFuY2UucHJvdG90eXBlLnNldFZvbHVtZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fdm9sdW1lTm9kZS5nYWluLnNldFRhcmdldEF0VGltZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdm9sdW1lTm9kZS5nYWluLnNldFRhcmdldEF0VGltZShVdGlsLmNsYW1wKHZhbHVlLCAwLCAxLjApLCBhdWRpb0NvbnRleHQuY3VycmVudFRpbWUsIDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdm9sdW1lTm9kZS5nYWluLnZhbHVlID0gVXRpbC5jbGFtcCh2YWx1ZSwgMCwgMS4wKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgV2ViQXVkaW9JbnN0YW5jZS5wcm90b3R5cGUuc2V0TG9vcCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9sb29wID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9idWZmZXJTb3VyY2UpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2J1ZmZlclNvdXJjZS5sb29wID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl93aXJlVXBPbkVuZGVkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFdlYkF1ZGlvSW5zdGFuY2UucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1BhdXNlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzdW1lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuX2lzUGxheWluZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGxheWluZ1Byb21pc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBXZWJBdWRpb0luc3RhbmNlLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZvbHVtZU5vZGUuY29ubmVjdChhdWRpb0NvbnRleHQuZGVzdGluYXRpb24pO1xyXG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVCdWZmZXJTb3VyY2UoKTtcclxuICAgICAgICAgICAgdGhpcy5fYnVmZmVyU291cmNlLnN0YXJ0KDAsIDApO1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudE9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzUGxheWluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3BsYXlpbmdQcm9taXNlID0gbmV3IFByb21pc2VzXzUuUHJvbWlzZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl93aXJlVXBPbkVuZGVkKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBXZWJBdWRpb0luc3RhbmNlLnByb3RvdHlwZS5fcmVzdW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzUGF1c2VkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gYSBidWZmZXIgc291cmNlIGNhbiBvbmx5IGJlIHN0YXJ0ZWQgb25jZVxyXG4gICAgICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIGRpc3Bvc2Ugb2YgdGhlIHByZXZpb3VzIGluc3RhbmNlIGJlZm9yZVxyXG4gICAgICAgICAgICAvLyBcInJlc3VtaW5nXCIgdGhlIG5leHQgb25lXHJcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlclNvdXJjZS5vbmVuZGVkID0gbnVsbDsgLy8gZGlzcG9zZSBvZiBhbnkgcHJldmlvdXMgZXZlbnQgaGFuZGxlclxyXG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVCdWZmZXJTb3VyY2UoKTtcclxuICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gKDEgLyB0aGlzLl9idWZmZXJTb3VyY2UucGxheWJhY2tSYXRlLnZhbHVlKSAqIHRoaXMuX2J1ZmZlci5kdXJhdGlvbjtcclxuICAgICAgICAgICAgdGhpcy5fYnVmZmVyU291cmNlLnN0YXJ0KDAsIHRoaXMuX2N1cnJlbnRPZmZzZXQgJSBkdXJhdGlvbik7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzUGxheWluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX3dpcmVVcE9uRW5kZWQoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFdlYkF1ZGlvSW5zdGFuY2UucHJvdG90eXBlLl9jcmVhdGVCdWZmZXJTb3VyY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlclNvdXJjZSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcclxuICAgICAgICAgICAgdGhpcy5fYnVmZmVyU291cmNlLmJ1ZmZlciA9IHRoaXMuX2J1ZmZlcjtcclxuICAgICAgICAgICAgdGhpcy5fYnVmZmVyU291cmNlLmxvb3AgPSB0aGlzLl9sb29wO1xyXG4gICAgICAgICAgICB0aGlzLl9idWZmZXJTb3VyY2UucGxheWJhY2tSYXRlLnZhbHVlID0gMS4wO1xyXG4gICAgICAgICAgICB0aGlzLl9idWZmZXJTb3VyY2UuY29ubmVjdCh0aGlzLl92b2x1bWVOb2RlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFdlYkF1ZGlvSW5zdGFuY2UucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzUGxheWluZykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlclNvdXJjZS5zdG9wKDApO1xyXG4gICAgICAgICAgICAvLyBQbGF5YmFjayByYXRlIHdpbGwgYmUgYSBzY2FsZSBmYWN0b3Igb2YgaG93IGZhc3Qvc2xvdyB0aGUgYXVkaW8gaXMgYmVpbmcgcGxheWVkXHJcbiAgICAgICAgICAgIC8vIGRlZmF1bHQgaXMgMS4wXHJcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gaW52ZXJ0IGl0IHRvIGdldCB0aGUgdGltZSBzY2FsZVxyXG4gICAgICAgICAgICB2YXIgcGJSYXRlID0gMSAvICh0aGlzLl9idWZmZXJTb3VyY2UucGxheWJhY2tSYXRlLnZhbHVlIHx8IDEuMCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRPZmZzZXQgPSAoKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGhpcy5fc3RhcnRUaW1lKSAqIHBiUmF0ZSkgLyAxMDAwOyAvLyBpbiBzZWNvbmRzXHJcbiAgICAgICAgICAgIHRoaXMuX2lzUGF1c2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBXZWJBdWRpb0luc3RhbmNlLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzUGxheWluZykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlclNvdXJjZS5zdG9wKDApO1xyXG4gICAgICAgICAgICAvLyBoYW5kbGVyIHdpbGwgbm90IGJlIHdpcmVkIHVwIGlmIHdlIHdlcmUgbG9vcGluZ1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2J1ZmZlclNvdXJjZS5vbmVuZGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVPbkVuZGVkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudE9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgV2ViQXVkaW9JbnN0YW5jZS5wcm90b3R5cGUuX3dpcmVVcE9uRW5kZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fbG9vcCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYnVmZmVyU291cmNlLm9uZW5kZWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5faGFuZGxlT25FbmRlZCgpOyB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBXZWJBdWRpb0luc3RhbmNlLnByb3RvdHlwZS5faGFuZGxlT25FbmRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gcGF1c2luZyBjYWxscyBzdG9wKDApIHdoaWNoIHRyaWdnZXJzIG9uZW5kZWQgZXZlbnRcclxuICAgICAgICAgICAgLy8gc28gd2UgZG9uJ3QgXCJyZXNvbHZlXCIgeWV0ICh3aGVuIHdlIHJlc3VtZSB3ZSdsbCB0cnkgYWdhaW4pXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNQYXVzZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGxheWluZ1Byb21pc2UucmVzb2x2ZSh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFdlYkF1ZGlvSW5zdGFuY2U7XHJcbiAgICB9KCkpO1xyXG59KTtcclxuZGVmaW5lKFwiSW50ZXJmYWNlcy9JTG9hZGVyXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbn0pO1xyXG5kZWZpbmUoXCJMb2FkZXJcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJEcmF3aW5nL0NvbG9yXCIsIFwiUmVzb3VyY2VzL1NvdW5kXCIsIFwiVXRpbC9Mb2dcIiwgXCJQcm9taXNlc1wiLCBcIkNsYXNzXCIsIFwiVXRpbC9EcmF3VXRpbFwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIENvbG9yXzEyLCBTb3VuZF8xLCBMb2dfNiwgUHJvbWlzZXNfNiwgQ2xhc3NfMywgRHJhd1V0aWwpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQcmUtbG9hZGluZyBhc3NldHNcclxuICAgICAqXHJcbiAgICAgKiBUaGUgbG9hZGVyIHByb3ZpZGVzIGEgbWVjaGFuaXNtIHRvIHByZWxvYWQgbXVsdGlwbGUgcmVzb3VyY2VzIGF0XHJcbiAgICAgKiBvbmUgdGltZS4gVGhlIGxvYWRlciBtdXN0IGJlIHBhc3NlZCB0byB0aGUgZW5naW5lIGluIG9yZGVyIHRvXHJcbiAgICAgKiB0cmlnZ2VyIHRoZSBsb2FkaW5nIHByb2dyZXNzIGJhci5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgW1tMb2FkZXJdXSBpdHNlbGYgaW1wbGVtZW50cyBbW0lMb2FkYWJsZV1dIHNvIHlvdSBjYW4gbG9hZCBsb2FkZXJzLlxyXG4gICAgICpcclxuICAgICAqICMjIEV4YW1wbGU6IFByZS1sb2FkaW5nIHJlc291cmNlcyBmb3IgYSBnYW1lXHJcbiAgICAgKlxyXG4gICAgICogYGBganNcclxuICAgICAqIC8vIGNyZWF0ZSBhIGxvYWRlclxyXG4gICAgICogdmFyIGxvYWRlciA9IG5ldyBleC5Mb2FkZXIoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBjcmVhdGUgYSByZXNvdXJjZSBkaWN0aW9uYXJ5IChiZXN0IHByYWN0aWNlIGlzIHRvIGtlZXAgYSBzZXBhcmF0ZSBmaWxlKVxyXG4gICAgICogdmFyIHJlc291cmNlcyA9IHtcclxuICAgICAqICAgVGV4dHVyZUdyb3VuZDogbmV3IGV4LlRleHR1cmUoXCIvaW1hZ2VzL3RleHR1cmVzL2dyb3VuZC5wbmdcIiksXHJcbiAgICAgKiAgIFNvdW5kRGVhdGg6IG5ldyBleC5Tb3VuZChcIi9zb3VuZC9kZWF0aC53YXZcIiwgXCIvc291bmQvZGVhdGgubXAzXCIpXHJcbiAgICAgKiB9O1xyXG4gICAgICpcclxuICAgICAqIC8vIGxvb3AgdGhyb3VnaCBkaWN0aW9uYXJ5IGFuZCBhZGQgdG8gbG9hZGVyXHJcbiAgICAgKiBmb3IgKHZhciBsb2FkYWJsZSBpbiByZXNvdXJjZXMpIHtcclxuICAgICAqICAgaWYgKHJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShsb2FkYWJsZSkpIHtcclxuICAgICAqICAgICBsb2FkZXIuYWRkUmVzb3VyY2UocmVzb3VyY2VzW2xvYWRhYmxlXSk7XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiAvLyBzdGFydCBnYW1lXHJcbiAgICAgKiBnYW1lLnN0YXJ0KGxvYWRlcikudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgKiAgIGNvbnNvbGUubG9nKFwiR2FtZSBzdGFydGVkIVwiKTtcclxuICAgICAqIH0pO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIHZhciBMb2FkZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhMb2FkZXIsIF9zdXBlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIGxvYWRhYmxlcyAgT3B0aW9uYWxseSBwcm92aWRlIHRoZSBsaXN0IG9mIHJlc291cmNlcyB5b3Ugd2FudCB0byBsb2FkIGF0IGNvbnN0cnVjdG9yIHRpbWVcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBMb2FkZXIobG9hZGFibGVzKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLl9yZXNvdXJjZUxpc3QgPSBbXTtcclxuICAgICAgICAgICAgX3RoaXMuX2luZGV4ID0gMDtcclxuICAgICAgICAgICAgX3RoaXMuX3Jlc291cmNlQ291bnQgPSAwO1xyXG4gICAgICAgICAgICBfdGhpcy5fbnVtTG9hZGVkID0gMDtcclxuICAgICAgICAgICAgX3RoaXMuX3Byb2dyZXNzQ291bnRzID0ge307XHJcbiAgICAgICAgICAgIF90aGlzLl90b3RhbENvdW50cyA9IHt9O1xyXG4gICAgICAgICAgICAvLyBsb2dvIGRyYXdpbmcgc3R1ZmZcclxuICAgICAgICAgICAgLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXHJcbiAgICAgICAgICAgIC8vIGJhc2U2NCBzdHJpbmcgZW5jb2Rpbmcgb2YgdGhlIGV4Y2FsaWJ1ciBsb2dvIChsb2dvLXdoaXRlLnBuZylcclxuICAgICAgICAgICAgX3RoaXMubG9nbyA9ICdkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQWRRQUFBQjJDQVlBQUFCeGhHSTlBQUFBQ1hCSVdYTUFBQXNTQUFBTEVnSFMzWDc4QUFBS25VbEVRVlI0MnUzZFAyd2pTeDBIOE44aEpJb25JUm1KanNxMFNCUitCUTFkY3FLaGUwbEQ3N1N2U3dwS2tKS0dQdWxwa3RmUklNVWRFcUtJcVY1N3JwQW9rTTRkYlNpeXE3T05QVFA3eDM5aWZ6N1NGYm5FbnAzeGVyNDdPN3V6SDE1Zlh3TUE2T1lIbWdBQUJDb0FDRlFBRUtnQWdFQUZBSUVLQUFJVkFBUXFBQ0JRQVVDZ0FvQkFCUUNCQ2dBSVZBQVFxQUFnVUFGQW9BSUFBaFVBQkNvQUNGUUFFS2dBZ0VDRkxibU9pTmVGZjJQYkF5ejY4UHI2cWhVZ2JSd1I5MnYrL3p3aUpyWUhNRUtGTW1jTi8vL1V0Z2NRcUZCazFQRC85N1U5UXg4VkNGU2d1NEVtQUlFS0FBSVZBQVFxQUNCUTRaMjVqb2pQOGVYKzBXdE5BZ0lWYU9ZK0ltNWorZUtoMjRoNDFqUWdVSUV5WjdGNU5hUFU3d0NCQ2l3WWQvdzljT0IrcUFsZ0ozS0xMb3cwRVYxOTg4MDNSV3ZKZnZmZGR4KzBsaEVxSEt1NUpnQWpWQ0J2bGhtRnpqUVJYVWVrSHo5K1RQNzl5OHVMUmpOQ2hYZnZvZVB2QVlFS3hOdGoxZTQyL081Sm9JSkFCY3JkUk1SVkxNK1gza1RFcGFhQjk4OGNLdXpXZzlFb2JUV2RNeDBPbHk4dU40ZHFoQW9BUnFnbmFOM2FySGZxdTdPeUg4SXRLTFZCL1ArQ0VmTVRIeUdQWTNucHgxbTh6V0dERWVvQmZVay94ZHRpNTdkci9yMVd2Mis2RVBvdzN0WjVyUmRTNzJzMW5ldUY5N3h2V2QrWFRIMC9WK1VNdHREV3FiSS9yMm5yeGZwK2p2MnVTalNPN1MrT1h5L0EvM2xOKzl4WDVUNUh4RVVQWlowdGZCNzErdzU3ZUovSEZ1K3oramt2MXU5MllYOWZiSS9IaFgzSkE5cnA1TVByNjZ0V2FHOVVmVUdickhJemk3Y0xVeVlGZi90cFRhZHkwM0VFZUw4bVVKNmk3TUtZTnZXTnFyNFBlMmpyYWRYTzYwTHJ2UEF6MlBRNVJQWDY4NGFoOGR4RCsyemFudG5DZ1ZpcFNWVittL3RnQjlXMkREcTJTeC92TTk1d2NIaFpoV1ZKbTh5cnY1OGNTZ2ZUZGM3MCsrKy9YL3I1MjIrL3RVS1NFZXBCcW8rb200WkxQZXJNalV3dU5uUUN0eDFHV0p0ZWUxRndkRDV1V2Q4NnhMczhVYVZ0MmFORU8xL3NhWi9aNXJZTVc0enE2djM0ckdWOUJnM3EyZVo5U2tlTm05cXd5VWgzME9QSUhZRkt4NUZHMDNDN3puU09xWUJxK3FXL3pwUTNhbkgwMzdUTkhsdUc2ZjBXUHNQaEh2YWI0UUZ0eTdvZ09ldXhEWWNOeTIvenUyMjE0V05ZV3htQnVyTk84YkduOTdwTkJPTzh4eS85dUNvclpaNEkycjRDN2FKZ083WlY5aUU0OURtNk52T1d4K3BXRTlDVXEzemJkVHA5ZG96MzhUYlh0enFIOVJUNUN5V2U0MjJPYVpvWkdlWkNhYnJoUFFZOUhqd3NqcFR2Q2c0WXRsRTIrVGEvajJiem44ZnFyRHFnbSs2eVVIT21BdldVakF0R2hiTll2c0JrbkRucUgxUWhjN1ZteEhnZWIvTmJ1ZEE1ai9VWGxZd2lmMnA2bHVoQWM5dGV1MW5waUhLbkRzOGlmNnRDbTdKTFgzTktwZ3R0WGU5cnVjOW1ITWQ3YTgzaXdkeEY1dnQ4dHV0QVJhQ2VrbFJuTks5QzhXbk5GN2dlSlE0VDRYRzNKaFNuVmRpbFFyRyt5T25ybFZIZnNFR1l6aE5CbjdMdTZ0UzcrSEphZkpRNEVNaU5sTnFXWFo5V1B2VmduVllIRzVNMUJ5RFhrVDZsZVgyRWdUcUp0eXQ0NXl2N1MycU8zc0VaalpoRExYZVIrWUtkSjBaZGs4UW9jdkg5TjczMktyTnRxK0ZaL3p6SUhBQmNKcllwZCtYdjE0bE9kNWFwNzZTZ3JkdVcvVlRRMXFjUXBxbmJndTRpZlp2VU1OcGQ5WHVvWm12Q3RQYVEyWS9CQ0hWTGdickpUZVJQRGRWZjZwZk1LRFUyZk9rSG1WRkZmWHIzTXNvdUxzbk52VjVrUm9lNStzNDMxUGV1b0tQcVduYXVyWS9aUEJFZXF3Y2VONGw5Nml3TzZIN01qcTR5N1ZHUFZOZTEwVmFaTXpWQ1BWV3BJL1o2RlpiY3Y1Zk1xR0NVK2RMZkZHemo1OGpQOCtiQ2RKQ283eXpLVHdkT0YwYnU5VWc3VjRjK3l6N0ZKZlllR295c1VzczBIc3NJZFZad1lMRHVqTXFsRVNvQ2RUdEdzWnRiSG5KQmVOZERTSlNzMGpUS2RNSk4xSE5YNTRXdjdidnNVOU5rVkpWYTEzZFgrL3d1QXJWMFgvbDVSSHlvL2xuZkY0RzZwNkRyUzBrSGR0WGh5MzVUR0VyRFBZWlVuMldmV3FET28vbFZxZE1EMk8vaEtKaEQ3Uy9vZHVreW1xOXMwMlFONEVFUFIvemJhT3VtWmMrcjE1eksxWnF6bmw5anNmaWVtVE0xUW1WM0hVdVRrZWRsZzlISVF6UmJVRDkzZGZDKzJ0cGoyZklIRUgyK1JxQ0NRSDEzZ1pxN2hXWFROcFZ1MTlPQjFmYzluUTBBS09LVWI1bFUwUDFrRHlPbmVvV2swbE9aOWNJUDB4N3F1OCsyQmhDb1Iyd1l1MStlN0RtYVh6QlNzdTV2YVgxbmUyenJwbVVQVG14ZjdQTTFEbTR5L3ZDN255N05pZjcrei85Wm10TTBaM3BhblBMdFBtcmE5ZjE2YmNLMERwYm53azQzVmQvUkh0dTZ6Zk5RVHkxUUJ5M2FxRzJnOW5WbXhtbCtCT29KeVQzTnBXbW45eGhmRm51NGJ2RGErNDRCWGhxcWZkZjN1VUY5K3l6NzdBVDMxWXVlMm1qZWNZUTYyTkxmZ2tBOWdoSHFMTkVoTmVtNEgxYzZ2ZHlEeGhmL2JwejVtNGNvVy9jMzl3aTZWSDJiUHRIbGNhVjljdlh0cyt6eENlNnJUZXFjMm5kTDd1R2Q5M1F3TTliRmNBek1vWlo3U2dUQmJXeCthc3VpNjFoL2lxMStSbWpxZGJuUVhRM1QxRE5RNjNWL1U5dWNxbS9wTXpQYjFyZVBzay8xaVRPamd2YXRSNFczTGM4VUxCNzhwRUx5cm5BZmVUY2oxTlU1MDkvODZtZkozMy84K01mMDBhMDVVeVBVRXc3VVZDZVdHL1dORWlFeHlIUk10NWx0VzMwaXpVUGsxOHl0dDdsTmZjOGkvL0R2dHZYdG8reVNBNUJqbGpzTFVGOGxQa3FNUEV0VzFKb21Ec2lHQlo5QnliNE5BdlVJVFNOOUd1d3NJajZ0NlVUT3FrN2pKUkVrbXpxbGk4eElzOTZ1ZFNPMjBzWDBIMXZXOTJJTDllMWE5cmdxVnlmOTFnYlBzVHk5VUQ5bjlsT2tUOGsrUmZrRlI1UE1OcXhPY2RTZjMyUEJ2ZzN2aWxPK3pkeEUrb2t4OVdtMHBoMzZYWXNSWkNwTUY5OTNHT2s1cXZxQjNEY3Q2anZzc2I2N0t2dVVOSjNmcnc5MmJocjgvU1RTRjBKZFJQTUxwVUNnbnNnbzlTNzZQWjI0NlpGazF3V3ZLNW0zdlZvWXZXMVN6N25OOTFqZlhiUTFaUWM3VFc2SGVhb09hbHlwRy84L3AvclAxYU5BYzZaSHpTbmZkcVBVUGhkeTJQUXc2Tno5Z1NWaHVoaXF1ZVVIUjN1dTd5N0szcmREWDR1NDZaclBiVWEwSUZCWjBzZUtRM1hRVFJ0MnZtM1cvYTJEYk5LeXMrK3J2bTNlcDYreTF4MlVkUDNiV1U5bHpyYTQ3VTFHbWxjdFgvc1EyM3QrYU9sQnlMVGgvNE5BUGFDUnh0Y2RPNUhMU0ovNnZOdEN3R3g2N1ZQbVBidldkMXE5ZnJLSHRwNGtBcVJKMkhSOWo3NjJKZlgzYlovL2VsUHRqMTNQUER4MStENXRxay9YaTZOTzhTSHo3TW1IMTlkWHJkQk5mVkZQNlQyUFQxVUhOaXQ4Ny90NG01K2FSSCtuUUJkdnF5aFpES0pMZlpzOGg3WFBzcWRWMlpPVit0YW5LQjhhbG4wZHl4ZEFYYlY0ajRndnQ0b01PcmJQNnZiVTczTlc3VE1sYmRUblByV3BmcVhmaDlIS1o5dmtlN0t1VGVaUk50WFJTZTYrMUZWLy9jZS9sbjVlWGZzWGdjcVh6cjYrOTI2MU0zbW9Pb2E3RTZudlRaVGZ5N2lOc21mYjdramZnWEdzdnhlMHZpaHNFdHM5SFRxdVBwdDFxMXZ0YWh1MlRxQWlVQUVFS2owemh3b0FScWdBdS9PblgvNDQyV0grOXhjL1d2cjU4cmUvVHI3ZjQxLytac1JxaEFvQUNGUUFFS2dBY0hqTW9RSnNrSnN6L2VxcnI1Wit2dnI3djVmbVFGZXZBbDVsenRRSUZRQVFxQUFnVUFIZ0lKbERCZGhnZFE0MU4yZUtFU29BSUZBQlFLQUN3RkV3aHdvQVJxZ0FJRkFCUUtBQ0FBSVZBQVFxQUFoVUFCQ29BSUJBQlFDQkNnQUNGUUFFS2dBZ1VBRkFvQUtBUUFVQWdRb0FDRlFBRUtnQUlGQUJRS0FDQUFJVkFBUXFBQWhVQUJDb0FJQkFCUUNCQ2dBQ0ZRQVFxQUFnVUFGQW9BS0FRQVVBbHZ3UGNGRG5zMURzSDRzQUFBQUFTVVZPUks1Q1lJST0nO1xyXG4gICAgICAgICAgICAvKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xyXG4gICAgICAgICAgICBfdGhpcy5sb2dvV2lkdGggPSA0Njg7XHJcbiAgICAgICAgICAgIF90aGlzLmxvZ29IZWlnaHQgPSAxMTg7XHJcbiAgICAgICAgICAgIF90aGlzLmJhY2tncm91bmRDb2xvciA9ICcjMTc2QkFBJztcclxuICAgICAgICAgICAgX3RoaXMuZ2V0RGF0YSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuOyB9O1xyXG4gICAgICAgICAgICBfdGhpcy5zZXREYXRhID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XHJcbiAgICAgICAgICAgIF90aGlzLnByb2Nlc3NEYXRhID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XHJcbiAgICAgICAgICAgIF90aGlzLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgTG9nXzYuTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ1tleC5Mb2FkZXJdIExvYWRpbmcgJyArICgxMDAgKiBlLmxvYWRlZCAvIGUudG90YWwpLnRvRml4ZWQoMCkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBfdGhpcy5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XHJcbiAgICAgICAgICAgIF90aGlzLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7IHJldHVybjsgfTtcclxuICAgICAgICAgICAgaWYgKGxvYWRhYmxlcykge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuYWRkUmVzb3VyY2VzKGxvYWRhYmxlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9hZGVyLnByb3RvdHlwZSwgXCJfaW1hZ2VcIiwge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faW1hZ2VFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW1hZ2VFbGVtZW50ID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW1hZ2VFbGVtZW50LnNyYyA9IHRoaXMubG9nbztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbWFnZUVsZW1lbnQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIDtcclxuICAgICAgICBMb2FkZXIucHJvdG90eXBlLndpcmVFbmdpbmUgPSBmdW5jdGlvbiAoZW5naW5lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZ2luZSA9IGVuZ2luZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZCBhIHJlc291cmNlIHRvIHRoZSBsb2FkZXIgdG8gbG9hZFxyXG4gICAgICAgICAqIEBwYXJhbSBsb2FkYWJsZSAgUmVzb3VyY2UgdG8gYWRkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTG9hZGVyLnByb3RvdHlwZS5hZGRSZXNvdXJjZSA9IGZ1bmN0aW9uIChsb2FkYWJsZSkge1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gdGhpcy5faW5kZXgrKztcclxuICAgICAgICAgICAgdGhpcy5fcmVzb3VyY2VMaXN0LnB1c2gobG9hZGFibGUpO1xyXG4gICAgICAgICAgICB0aGlzLl9wcm9ncmVzc0NvdW50c1trZXldID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fdG90YWxDb3VudHNba2V5XSA9IDE7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jlc291cmNlQ291bnQrKztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZCBhIGxpc3Qgb2YgcmVzb3VyY2VzIHRvIHRoZSBsb2FkZXIgdG8gbG9hZFxyXG4gICAgICAgICAqIEBwYXJhbSBsb2FkYWJsZXMgIFRoZSBsaXN0IG9mIHJlc291cmNlcyB0byBsb2FkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTG9hZGVyLnByb3RvdHlwZS5hZGRSZXNvdXJjZXMgPSBmdW5jdGlvbiAobG9hZGFibGVzKSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gMCwgbGVuID0gbG9hZGFibGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkUmVzb3VyY2UobG9hZGFibGVzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBsb2FkZXIgaGFzIGNvbXBsZXRlbHkgbG9hZGVkIGFsbCByZXNvdXJjZXNcclxuICAgICAgICAgKi9cclxuICAgICAgICBMb2FkZXIucHJvdG90eXBlLmlzTG9hZGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbnVtTG9hZGVkID09PSB0aGlzLl9yZXNvdXJjZUNvdW50O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQmVnaW4gbG9hZGluZyBhbGwgb2YgdGhlIHN1cHBsaWVkIHJlc291cmNlcywgcmV0dXJuaW5nIGEgcHJvbWlzZVxyXG4gICAgICAgICAqIHRoYXQgcmVzb2x2ZXMgd2hlbiBsb2FkaW5nIG9mIGFsbCBpcyBjb21wbGV0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExvYWRlci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGNvbXBsZXRlID0gbmV3IFByb21pc2VzXzYuUHJvbWlzZSgpO1xyXG4gICAgICAgICAgICB2YXIgbWUgPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fcmVzb3VyY2VMaXN0Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgbWUub25jb21wbGV0ZS5jYWxsKG1lKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHByb2dyZXNzQXJyYXkgPSBuZXcgQXJyYXkodGhpcy5fcmVzb3VyY2VMaXN0Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgIHZhciBwcm9ncmVzc0NodW5rcyA9IHRoaXMuX3Jlc291cmNlTGlzdC5sZW5ndGg7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jlc291cmNlTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChyLCBpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2VuZ2luZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHIud2lyZUVuZ2luZShfdGhpcy5fZW5naW5lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvdGFsID0gZS50b3RhbDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbG9hZGVkID0gZS5sb2FkZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NBcnJheVtpXSA9IHsgbG9hZGVkOiAoKGxvYWRlZCAvIHRvdGFsKSAqICgxMDAgLyBwcm9ncmVzc0NodW5rcykpLCB0b3RhbDogMTAwIH07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb2dyZXNzUmVzdWx0ID0gcHJvZ3Jlc3NBcnJheS5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtLCBuZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGxvYWRlZDogKGFjY3VtLmxvYWRlZCArIG5leHQubG9hZGVkKSwgdG90YWw6IDEwMCB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIHsgbG9hZGVkOiAwLCB0b3RhbDogMTAwIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIG1lLm9ucHJvZ3Jlc3MuY2FsbChtZSwgcHJvZ3Jlc3NSZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHIub25jb21wbGV0ZSA9IHIub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBtZS5fbnVtTG9hZGVkKys7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lLl9udW1Mb2FkZWQgPT09IG1lLl9yZXNvdXJjZUNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLm9uY29tcGxldGUuY2FsbChtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gbG9hZE5leHQobGlzdCwgaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIGlmICghbGlzdFtpbmRleF0pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsaXN0W2luZGV4XS5sb2FkKCkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9hZE5leHQobGlzdCwgaW5kZXggKyAxKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxvYWROZXh0KHRoaXMuX3Jlc291cmNlTGlzdCwgMCk7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExvYWRlciBkcmF3IGZ1bmN0aW9uLiBEcmF3cyB0aGUgZGVmYXVsdCBFeGNhbGlidXIgbG9hZGluZyBzY3JlZW4uXHJcbiAgICAgICAgICogT3ZlcnJpZGUgYGxvZ29gLCBgbG9nb1dpZHRoYCwgYGxvZ29IZWlnaHRgIGFuZCBgYmFja2dyb3VuZENvbG9yYCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgICogdG8gY3VzdG9taXplIHRoZSBkcmF3aW5nLCBvciBqdXN0IG92ZXJyaWRlIGVudGlyZSBtZXRob2QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTG9hZGVyLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gICAgICAgICAgICB2YXIgY2FudmFzSGVpZ2h0ID0gdGhpcy5fZW5naW5lLmNhbnZhc0hlaWdodCAvIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xyXG4gICAgICAgICAgICB2YXIgY2FudmFzV2lkdGggPSB0aGlzLl9lbmdpbmUuY2FudmFzV2lkdGggLyB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcclxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuYmFja2dyb3VuZENvbG9yO1xyXG4gICAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XHJcbiAgICAgICAgICAgIHZhciB5ID0gY2FudmFzSGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgdmFyIHdpZHRoID0gTWF0aC5taW4odGhpcy5sb2dvV2lkdGgsIGNhbnZhc1dpZHRoICogMC43NSk7XHJcbiAgICAgICAgICAgIHZhciB4ID0gKGNhbnZhc1dpZHRoIC8gMikgLSAod2lkdGggLyAyKTtcclxuICAgICAgICAgICAgdmFyIGltYWdlSGVpZ2h0ID0gTWF0aC5mbG9vcih3aWR0aCAqICh0aGlzLmxvZ29IZWlnaHQgLyB0aGlzLmxvZ29XaWR0aCkpOyAvLyBPRyBoZWlnaHQvd2lkdGggZmFjdG9yXHJcbiAgICAgICAgICAgIHZhciBvbGRBbnRpYWxpYXMgPSB0aGlzLl9lbmdpbmUuZ2V0QW50aWFsaWFzaW5nKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZ2luZS5zZXRBbnRpYWxpYXNpbmcodHJ1ZSk7XHJcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5faW1hZ2UsIDAsIDAsIHRoaXMubG9nb1dpZHRoLCB0aGlzLmxvZ29IZWlnaHQsIHgsIHkgLSBpbWFnZUhlaWdodCAtIDIwLCB3aWR0aCwgaW1hZ2VIZWlnaHQpO1xyXG4gICAgICAgICAgICAvLyBsb2FkaW5nIGJveFxyXG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMjtcclxuICAgICAgICAgICAgRHJhd1V0aWwucm91bmRSZWN0KGN0eCwgeCwgeSwgd2lkdGgsIDIwLCAxMCk7XHJcbiAgICAgICAgICAgIHZhciBwcm9ncmVzcyA9IHdpZHRoICogKHRoaXMuX251bUxvYWRlZCAvIHRoaXMuX3Jlc291cmNlQ291bnQpO1xyXG4gICAgICAgICAgICB2YXIgbWFyZ2luID0gNTtcclxuICAgICAgICAgICAgdmFyIHByb2dyZXNzV2lkdGggPSBwcm9ncmVzcyAtIG1hcmdpbiAqIDI7XHJcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSAyMCAtIG1hcmdpbiAqIDI7XHJcbiAgICAgICAgICAgIERyYXdVdGlsLnJvdW5kUmVjdChjdHgsIHggKyBtYXJnaW4sIHkgKyBtYXJnaW4sIHByb2dyZXNzV2lkdGggPiAwID8gcHJvZ3Jlc3NXaWR0aCA6IDAsIGhlaWdodCwgNSwgbnVsbCwgQ29sb3JfMTIuQ29sb3IuV2hpdGUpO1xyXG4gICAgICAgICAgICB0aGlzLl9lbmdpbmUuc2V0QW50aWFsaWFzaW5nKG9sZEFudGlhbGlhcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQZXJmb3JtIGFueSBjYWxjdWxhdGlvbnMgb3IgbG9naWMgaW4gdGhlIGB1cGRhdGVgIG1ldGhvZC4gVGhlIGRlZmF1bHQgYExvYWRlcmAgZG9lcyBub3RcclxuICAgICAgICAgKiBkbyBhbnl0aGluZyBpbiB0aGlzIG1ldGhvZCBzbyBpdCBpcyBzYWZlIHRvIG92ZXJyaWRlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExvYWRlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKF9lbmdpbmUsIF9kZWx0YSkge1xyXG4gICAgICAgICAgICAvLyBvdmVycmlkYWJsZSB1cGRhdGVcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBMb2FkZXI7XHJcbiAgICB9KENsYXNzXzMuQ2xhc3MpKTtcclxuICAgIGV4cG9ydHMuTG9hZGVyID0gTG9hZGVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIFtbTG9hZGVyXV0gdGhhdCBwYXVzZXMgYWZ0ZXIgbG9hZGluZyB0byBhbGxvdyB1c2VyXHJcbiAgICAgKiB0byBwcm9jZWVkIHRvIHBsYXkgdGhlIGdhbWUuIFR5cGljYWxseSB5b3Ugd2lsbFxyXG4gICAgICogd2FudCB0byB1c2UgdGhpcyBsb2FkZXIgZm9yIGlPUyB0byBhbGxvdyBzb3VuZHNcclxuICAgICAqIHRvIHBsYXkgYWZ0ZXIgbG9hZGluZyAoQXBwbGUgU2FmYXJpIHJlcXVpcmVzIHVzZXJcclxuICAgICAqIGludGVyYWN0aW9uIHRvIGFsbG93IHNvdW5kcywgZXZlbiBmb3IgZ2FtZXMpXHJcbiAgICAgKlxyXG4gICAgICogKipOb3RlOioqIEJlY2F1c2UgTG9hZGVyIGlzIG5vdCBwYXJ0IG9mIGEgU2NlbmUsIHlvdSBtdXN0XHJcbiAgICAgKiBjYWxsIGB1cGRhdGVgIGFuZCBgZHJhd2AgbWFudWFsbHkgb24gXCJjaGlsZFwiIG9iamVjdHMuXHJcbiAgICAgKlxyXG4gICAgICogIyMgSW1wbGVtZW50aW5nIGEgVHJpZ2dlclxyXG4gICAgICpcclxuICAgICAqIFRoZSBgUGF1c2VBZnRlckxvYWRlcmAgcmVxdWlyZXMgYW4gZWxlbWVudCB0byBhY3QgYXMgdGhlIHRyaWdnZXIgYnV0dG9uXHJcbiAgICAgKiB0byBzdGFydCB0aGUgZ2FtZS5cclxuICAgICAqXHJcbiAgICAgKiBGb3IgZXhhbXBsZSwgbGV0J3MgY3JlYXRlIGFuIGA8YT5gIHRhZyB0byBiZSBvdXIgdHJpZ2dlciBhbmQgY2FsbCBpdCBgdGFwLXRvLXBsYXlgLlxyXG4gICAgICpcclxuICAgICAqIGBgYGh0bWxcclxuICAgICAqIDxkaXYgaWQ9XCJ3cmFwcGVyXCI+XHJcbiAgICAgKiAgICA8Y2FudmFzIGlkPVwiZ2FtZVwiPjwvY2FudmFzPlxyXG4gICAgICogICAgPGEgaWQ9XCJ0YXAtdG8tcGxheVwiIGhyZWY9J2phdmFzY3JpcHQ6dm9pZCgwKTsnPlRhcCB0byBQbGF5PC9hPlxyXG4gICAgICogPC9kaXY+XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBXZSd2ZSBwdXQgaXQgaW5zaWRlIGEgd3JhcHBlciB0byBwb3NpdGlvbiBpdCBwcm9wZXJseSBvdmVyIHRoZSBnYW1lIGNhbnZhcy5cclxuICAgICAqXHJcbiAgICAgKiBOb3cgbGV0J3MgYWRkIHNvbWUgQ1NTIHRvIHN0eWxlIGl0IChpbnNlcnQgaW50byBgPGhlYWQ+YCk6XHJcbiAgICAgKlxyXG4gICAgICogYGBgaHRtbFxyXG4gICAgICogPHN0eWxlPlxyXG4gICAgICogICAgICN3cmFwcGVyIHtcclxuICAgICAqICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG4gICAgICogICAgICAgICB3aWR0aDogNTAwcHg7XHJcbiAgICAgKiAgICAgICAgIGhlaWdodDogNTAwcHg7XHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICAgICN0YXAtdG8tcGxheSB7XHJcbiAgICAgKiAgICAgICAgIGRpc3BsYXk6IG5vbmU7XHJcbiAgICAgKiAgICAgICAgIGZvbnQtc2l6ZTogMjRweDtcclxuICAgICAqICAgICAgICAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XHJcbiAgICAgKiAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcclxuICAgICAqICAgICAgICAgYm9yZGVyOiAzcHggc29saWQgd2hpdGU7XHJcbiAgICAgKiAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgICAqICAgICAgICAgY29sb3I6IHdoaXRlO1xyXG4gICAgICogICAgICAgICB3aWR0aDogMjAwcHg7XHJcbiAgICAgKiAgICAgICAgIGhlaWdodDogNTBweDtcclxuICAgICAqICAgICAgICAgbGluZS1oZWlnaHQ6IDUwcHg7XHJcbiAgICAgKiAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcclxuICAgICAqICAgICAgICAgbGVmdDogMTQ3cHg7XHJcbiAgICAgKiAgICAgICAgIHRvcDogODAlO1xyXG4gICAgICogICAgIH1cclxuICAgICAqIDwvc3R5bGU+XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBOb3cgd2UgY2FuIGNyZWF0ZSBhIGBQYXVzZUFmdGVyTG9hZGVyYCB3aXRoIGEgcmVmZXJlbmNlIHRvIG91ciB0cmlnZ2VyIGJ1dHRvbjpcclxuICAgICAqXHJcbiAgICAgKiBgYGB0c1xyXG4gICAgICogdmFyIGxvYWRlciA9IG5ldyBleC5QYXVzZUFmdGVyTG9hZGVyKCd0YXAtdG8tcGxheScsIFsuLi5dKTtcclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqICMjIFVzZSBQYXVzZUFmdGVyTG9hZGVyIGZvciBpT1NcclxuICAgICAqXHJcbiAgICAgKiBUaGUgcHJpbWFyeSB1c2UgY2FzZSBmb3IgcGF1c2luZyBiZWZvcmUgc3RhcnRpbmcgdGhlIGdhbWUgaXMgdG9cclxuICAgICAqIHBhc3MgQXBwbGUncyByZXF1aXJlbWVudCBvZiB1c2VyIGludGVyYWN0aW9uLiBUaGUgV2ViIEF1ZGlvIGNvbnRleHRcclxuICAgICAqIGluIFNhZmFyaSBpcyBkaXNhYmxlZCBieSBkZWZhdWx0IHVudGlsIHVzZXIgaW50ZXJhY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogVGhlcmVmb3JlLCB5b3UgY2FuIHVzZSB0aGlzIHNuaXBwZXQgdG8gb25seSB1c2UgUGF1c2VBZnRlckxvYWRlciB3aGVuXHJcbiAgICAgKiBpT1MgaXMgZGV0ZWN0ZWQgKHNlZSBbdGhpcyB0aHJlYWRdKGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTAzODYyNS9kZXRlY3QtaWYtZGV2aWNlLWlzLWlvcylcclxuICAgICAqIGZvciBtb3JlIHRlY2huaXF1ZXMpLlxyXG4gICAgICpcclxuICAgICAqIGBgYHRzXHJcbiAgICAgKiB2YXIgaU9TID0gL2lQYWR8aVBob25lfGlQb2QvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgISg8YW55PndpbmRvdykuTVNTdHJlYW07XHJcbiAgICAgKiB2YXIgbG9hZGVyOiBleC5Mb2FkZXIgPSBpT1MgPyBuZXcgZXguUGF1c2VBZnRlckxvYWRlcigndGFwLXRvLXBsYXknKSA6IG5ldyBleC5Mb2FkZXIoKTtcclxuICAgICAqXHJcbiAgICAgKiBsb2FkZXIuYWRkUmVzb3VyY2UoLi4uKTtcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICB2YXIgUGF1c2VBZnRlckxvYWRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFBhdXNlQWZ0ZXJMb2FkZXIsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gUGF1c2VBZnRlckxvYWRlcih0cmlnZ2VyRWxlbWVudElkLCBsb2FkYWJsZXMpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbG9hZGFibGVzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5faGFuZGxlT25UcmlnZ2VyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl93YWl0UHJvbWlzZS5zdGF0ZSgpICE9PSBQcm9taXNlc182LlByb21pc2VTdGF0ZS5QZW5kaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gdW5sb2NrIFNhZmFyaSBXZWJBdWRpbyBjb250ZXh0XHJcbiAgICAgICAgICAgICAgICBTb3VuZF8xLldlYkF1ZGlvLnVubG9jaygpO1xyXG4gICAgICAgICAgICAgICAgLy8gY29udGludWUgdG8gcGxheSBnYW1lXHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fd2FpdFByb21pc2UucmVzb2x2ZShfdGhpcy5fbG9hZGVkVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgLy8gaGlkZSBET00gZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3BsYXlUcmlnZ2VyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIF90aGlzLl9wbGF5VHJpZ2dlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRyaWdnZXJFbGVtZW50SWQpO1xyXG4gICAgICAgICAgICBfdGhpcy5fcGxheVRyaWdnZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBfdGhpcy5faGFuZGxlT25UcmlnZ2VyKTtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBQYXVzZUFmdGVyTG9hZGVyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB0aGlzLl93YWl0UHJvbWlzZSA9IG5ldyBQcm9taXNlc182LlByb21pc2UoKTtcclxuICAgICAgICAgICAgLy8gd2FpdCB1bnRpbCB1c2VyIGluZGljYXRlcyB0byBwcm9jZWVkIGJlZm9yZSBmaW5pc2hpbmcgbG9hZFxyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmxvYWQuY2FsbCh0aGlzKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvYWRlZFZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAvLyBzaG93IGVsZW1lbnRcclxuICAgICAgICAgICAgICAgIF90aGlzLl9wbGF5VHJpZ2dlci5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcclxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fd2FpdFByb21pc2UucmVqZWN0KHZhbHVlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93YWl0UHJvbWlzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBQYXVzZUFmdGVyTG9hZGVyO1xyXG4gICAgfShMb2FkZXIpKTtcclxuICAgIGV4cG9ydHMuUGF1c2VBZnRlckxvYWRlciA9IFBhdXNlQWZ0ZXJMb2FkZXI7XHJcbn0pO1xyXG5kZWZpbmUoXCJJbnRlcmZhY2VzL0lBY3RvclRyYWl0XCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbn0pO1xyXG5kZWZpbmUoXCJUcmFpdHMvQ2FwdHVyZVBvaW50ZXJcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogUHJvcG9nYXRlcyBwb2ludGVyIGV2ZW50cyB0byB0aGUgYWN0b3JcclxuICAgICAqL1xyXG4gICAgdmFyIENhcHR1cmVQb2ludGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBDYXB0dXJlUG9pbnRlcigpIHtcclxuICAgICAgICB9XHJcbiAgICAgICAgQ2FwdHVyZVBvaW50ZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChhY3RvciwgZW5naW5lKSB7XHJcbiAgICAgICAgICAgIGlmICghYWN0b3IuZW5hYmxlQ2FwdHVyZVBvaW50ZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYWN0b3IuaXNLaWxsZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVuZ2luZS5pbnB1dC5wb2ludGVycy5wcm9wb2dhdGUoYWN0b3IpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIENhcHR1cmVQb2ludGVyO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuQ2FwdHVyZVBvaW50ZXIgPSBDYXB0dXJlUG9pbnRlcjtcclxufSk7XHJcbmRlZmluZShcIlRyYWl0cy9FdWxlck1vdmVtZW50XCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiUGh5c2ljc1wiLCBcIkFjdG9yXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgUGh5c2ljc183LCBBY3Rvcl81KSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIHZhciBFdWxlck1vdmVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBFdWxlck1vdmVtZW50KCkge1xyXG4gICAgICAgIH1cclxuICAgICAgICBFdWxlck1vdmVtZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoYWN0b3IsIF9lbmdpbmUsIGRlbHRhKSB7XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBwbGFjZW1lbnRzIGJhc2VkIG9uIGxpbmVhciBhbGdlYnJhXHJcbiAgICAgICAgICAgIHZhciBzZWNvbmRzID0gZGVsdGEgLyAxMDAwO1xyXG4gICAgICAgICAgICB2YXIgdG90YWxBY2MgPSBhY3Rvci5hY2MuY2xvbmUoKTtcclxuICAgICAgICAgICAgLy8gT25seSBhY3RpdmUgdmFuaWxsYSBhY3RvcnMgYXJlIGFmZmVjdGVkIGJ5IGdsb2JhbCBhY2NlbGVyYXRpb25cclxuICAgICAgICAgICAgaWYgKGFjdG9yLmNvbGxpc2lvblR5cGUgPT09IEFjdG9yXzUuQ29sbGlzaW9uVHlwZS5BY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIHRvdGFsQWNjLmFkZEVxdWFsKFBoeXNpY3NfNy5QaHlzaWNzLmFjYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYWN0b3Iub2xkVmVsID0gYWN0b3IudmVsO1xyXG4gICAgICAgICAgICBhY3Rvci52ZWwuYWRkRXF1YWwodG90YWxBY2Muc2NhbGUoc2Vjb25kcykpO1xyXG4gICAgICAgICAgICBhY3Rvci5wb3MuYWRkRXF1YWwoYWN0b3IudmVsLnNjYWxlKHNlY29uZHMpKS5hZGRFcXVhbCh0b3RhbEFjYy5zY2FsZSgwLjUgKiBzZWNvbmRzICogc2Vjb25kcykpO1xyXG4gICAgICAgICAgICBhY3Rvci5yeCArPSBhY3Rvci50b3JxdWUgKiAoMS4wIC8gYWN0b3IubW9pKSAqIHNlY29uZHM7XHJcbiAgICAgICAgICAgIGFjdG9yLnJvdGF0aW9uICs9IGFjdG9yLnJ4ICogc2Vjb25kcztcclxuICAgICAgICAgICAgYWN0b3Iuc2NhbGUueCArPSBhY3Rvci5zeCAqIGRlbHRhIC8gMTAwMDtcclxuICAgICAgICAgICAgYWN0b3Iuc2NhbGUueSArPSBhY3Rvci5zeSAqIGRlbHRhIC8gMTAwMDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBFdWxlck1vdmVtZW50O1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuRXVsZXJNb3ZlbWVudCA9IEV1bGVyTW92ZW1lbnQ7XHJcbn0pO1xyXG5kZWZpbmUoXCJVdGlsL0N1bGxpbmdCb3hcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJBbGdlYnJhXCIsIFwiRHJhd2luZy9Db2xvclwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIEFsZ2VicmFfMTMsIENvbG9yXzEzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIHZhciBDdWxsaW5nQm94ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBDdWxsaW5nQm94KCkge1xyXG4gICAgICAgICAgICB0aGlzLl90b3BMZWZ0ID0gbmV3IEFsZ2VicmFfMTMuVmVjdG9yKDAsIDApO1xyXG4gICAgICAgICAgICB0aGlzLl90b3BSaWdodCA9IG5ldyBBbGdlYnJhXzEzLlZlY3RvcigwLCAwKTtcclxuICAgICAgICAgICAgdGhpcy5fYm90dG9tTGVmdCA9IG5ldyBBbGdlYnJhXzEzLlZlY3RvcigwLCAwKTtcclxuICAgICAgICAgICAgdGhpcy5fYm90dG9tUmlnaHQgPSBuZXcgQWxnZWJyYV8xMy5WZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEN1bGxpbmdCb3gucHJvdG90eXBlLmlzU3ByaXRlT2ZmU2NyZWVuID0gZnVuY3Rpb24gKGFjdG9yLCBlbmdpbmUpIHtcclxuICAgICAgICAgICAgdmFyIGRyYXdpbmdXaWR0aCA9IGFjdG9yLmN1cnJlbnREcmF3aW5nLndpZHRoO1xyXG4gICAgICAgICAgICB2YXIgZHJhd2luZ0hlaWdodCA9IGFjdG9yLmN1cnJlbnREcmF3aW5nLmhlaWdodDtcclxuICAgICAgICAgICAgdmFyIHJvdGF0aW9uID0gYWN0b3Iucm90YXRpb247XHJcbiAgICAgICAgICAgIHZhciBhbmNob3IgPSBhY3Rvci5nZXRDZW50ZXIoKTtcclxuICAgICAgICAgICAgdmFyIHdvcmxkUG9zID0gYWN0b3IuZ2V0V29ybGRQb3MoKTtcclxuICAgICAgICAgICAgdGhpcy5fdG9wTGVmdC54ID0gd29ybGRQb3MueCAtIChkcmF3aW5nV2lkdGggLyAyKTtcclxuICAgICAgICAgICAgdGhpcy5fdG9wTGVmdC55ID0gd29ybGRQb3MueSAtIChkcmF3aW5nSGVpZ2h0IC8gMik7XHJcbiAgICAgICAgICAgIHRoaXMuX3RvcExlZnQgPSB0aGlzLl90b3BMZWZ0LnJvdGF0ZShyb3RhdGlvbiwgYW5jaG9yKTtcclxuICAgICAgICAgICAgdGhpcy5fdG9wUmlnaHQueCA9IHdvcmxkUG9zLnggKyAoZHJhd2luZ1dpZHRoIC8gMik7XHJcbiAgICAgICAgICAgIHRoaXMuX3RvcFJpZ2h0LnkgPSB3b3JsZFBvcy55IC0gKGRyYXdpbmdIZWlnaHQgLyAyKTtcclxuICAgICAgICAgICAgdGhpcy5fdG9wUmlnaHQgPSB0aGlzLl90b3BSaWdodC5yb3RhdGUocm90YXRpb24sIGFuY2hvcik7XHJcbiAgICAgICAgICAgIHRoaXMuX2JvdHRvbUxlZnQueCA9IHdvcmxkUG9zLnggLSAoZHJhd2luZ1dpZHRoIC8gMik7XHJcbiAgICAgICAgICAgIHRoaXMuX2JvdHRvbUxlZnQueSA9IHdvcmxkUG9zLnkgKyAoZHJhd2luZ0hlaWdodCAvIDIpO1xyXG4gICAgICAgICAgICB0aGlzLl9ib3R0b21MZWZ0ID0gdGhpcy5fYm90dG9tTGVmdC5yb3RhdGUocm90YXRpb24sIGFuY2hvcik7XHJcbiAgICAgICAgICAgIHRoaXMuX2JvdHRvbVJpZ2h0LnggPSB3b3JsZFBvcy54ICsgKGRyYXdpbmdXaWR0aCAvIDIpO1xyXG4gICAgICAgICAgICB0aGlzLl9ib3R0b21SaWdodC55ID0gd29ybGRQb3MueSArIChkcmF3aW5nSGVpZ2h0IC8gMik7XHJcbiAgICAgICAgICAgIHRoaXMuX2JvdHRvbVJpZ2h0ID0gdGhpcy5fYm90dG9tUmlnaHQucm90YXRlKHJvdGF0aW9uLCBhbmNob3IpO1xyXG4gICAgICAgICAgICAvLy9cclxuICAgICAgICAgICAgdmFyIHRvcExlZnRTY3JlZW4gPSBlbmdpbmUud29ybGRUb1NjcmVlbkNvb3JkaW5hdGVzKHRoaXMuX3RvcExlZnQpO1xyXG4gICAgICAgICAgICB2YXIgdG9wUmlnaHRTY3JlZW4gPSBlbmdpbmUud29ybGRUb1NjcmVlbkNvb3JkaW5hdGVzKHRoaXMuX3RvcFJpZ2h0KTtcclxuICAgICAgICAgICAgdmFyIGJvdHRvbUxlZnRTY3JlZW4gPSBlbmdpbmUud29ybGRUb1NjcmVlbkNvb3JkaW5hdGVzKHRoaXMuX2JvdHRvbUxlZnQpO1xyXG4gICAgICAgICAgICB2YXIgYm90dG9tUmlnaHRTY3JlZW4gPSBlbmdpbmUud29ybGRUb1NjcmVlbkNvb3JkaW5hdGVzKHRoaXMuX2JvdHRvbVJpZ2h0KTtcclxuICAgICAgICAgICAgdGhpcy5feENvb3JkcyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLl95Q29vcmRzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuX3hDb29yZHMucHVzaCh0b3BMZWZ0U2NyZWVuLngsIHRvcFJpZ2h0U2NyZWVuLngsIGJvdHRvbUxlZnRTY3JlZW4ueCwgYm90dG9tUmlnaHRTY3JlZW4ueCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3lDb29yZHMucHVzaCh0b3BMZWZ0U2NyZWVuLnksIHRvcFJpZ2h0U2NyZWVuLnksIGJvdHRvbUxlZnRTY3JlZW4ueSwgYm90dG9tUmlnaHRTY3JlZW4ueSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3hNaW4gPSBNYXRoLm1pbi5hcHBseShudWxsLCB0aGlzLl94Q29vcmRzKTtcclxuICAgICAgICAgICAgdGhpcy5feU1pbiA9IE1hdGgubWluLmFwcGx5KG51bGwsIHRoaXMuX3lDb29yZHMpO1xyXG4gICAgICAgICAgICB0aGlzLl94TWF4ID0gTWF0aC5tYXguYXBwbHkobnVsbCwgdGhpcy5feENvb3Jkcyk7XHJcbiAgICAgICAgICAgIHRoaXMuX3lNYXggPSBNYXRoLm1heC5hcHBseShudWxsLCB0aGlzLl95Q29vcmRzKTtcclxuICAgICAgICAgICAgdmFyIG1pbldvcmxkID0gZW5naW5lLnNjcmVlblRvV29ybGRDb29yZGluYXRlcyhuZXcgQWxnZWJyYV8xMy5WZWN0b3IodGhpcy5feE1pbiwgdGhpcy5feU1pbikpO1xyXG4gICAgICAgICAgICB2YXIgbWF4V29ybGQgPSBlbmdpbmUuc2NyZWVuVG9Xb3JsZENvb3JkaW5hdGVzKG5ldyBBbGdlYnJhXzEzLlZlY3Rvcih0aGlzLl94TWF4LCB0aGlzLl95TWF4KSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3hNaW5Xb3JsZCA9IG1pbldvcmxkLng7XHJcbiAgICAgICAgICAgIHRoaXMuX3lNaW5Xb3JsZCA9IG1pbldvcmxkLnk7XHJcbiAgICAgICAgICAgIHRoaXMuX3hNYXhXb3JsZCA9IG1heFdvcmxkLng7XHJcbiAgICAgICAgICAgIHRoaXMuX3lNYXhXb3JsZCA9IG1heFdvcmxkLnk7XHJcbiAgICAgICAgICAgIHZhciBib3VuZGluZ1BvaW50cyA9IFtcclxuICAgICAgICAgICAgICAgIG5ldyBBbGdlYnJhXzEzLlZlY3Rvcih0aGlzLl94TWluLCB0aGlzLl95TWluKSxcclxuICAgICAgICAgICAgICAgIG5ldyBBbGdlYnJhXzEzLlZlY3Rvcih0aGlzLl94TWF4LCB0aGlzLl95TWluKSxcclxuICAgICAgICAgICAgICAgIG5ldyBBbGdlYnJhXzEzLlZlY3Rvcih0aGlzLl94TWluLCB0aGlzLl95TWF4KSxcclxuICAgICAgICAgICAgICAgIG5ldyBBbGdlYnJhXzEzLlZlY3Rvcih0aGlzLl94TWF4LCB0aGlzLl95TWF4KVxyXG4gICAgICAgICAgICBdOyAvLyBib3R0b21yaWdodFxyXG4gICAgICAgICAgICAvLyBzcHJpdGUgY2FuIGJlIHdpZGVyIHRoYW4gY2FudmFzIHNjcmVlbiAoYW5kIHN0aWxsIHZpc2libGUgd2l0aGluIGNhbnZhcylcclxuICAgICAgICAgICAgLy8gdG9wIG9yIGJvdHRvbSBvZiBzcHJpdGUgbXVzdCBiZSB3aXRoaW4gY2FudmFzXHJcbiAgICAgICAgICAgIGlmIChib3VuZGluZ1BvaW50c1swXS54IDwgMCAmJiBib3VuZGluZ1BvaW50c1sxXS54ID4gZW5naW5lLmNhbnZhcy5jbGllbnRXaWR0aCAmJlxyXG4gICAgICAgICAgICAgICAgKGJvdW5kaW5nUG9pbnRzWzBdLnkgPiAwIHx8IGJvdW5kaW5nUG9pbnRzWzJdLnkgPCBlbmdpbmUuY2FudmFzLmNsaWVudEhlaWdodCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBzcHJpdGUgY2FuIGJlIHRhbGxlciB0aGFuIGNhbnZhcyBzY3JlZW4gKGFuZCBzdGlsbCB2aXNpYmxlIHdpdGhpbiBjYW52YXMpXHJcbiAgICAgICAgICAgIC8vIGxlZnQgb3IgcmlnaHQgb2Ygc3ByaXRlIG11c3QgYmUgd2l0aGluIGNhbnZhc1xyXG4gICAgICAgICAgICBpZiAoYm91bmRpbmdQb2ludHNbMF0ueSA8IDAgJiYgYm91bmRpbmdQb2ludHNbMl0ueSA+IGVuZ2luZS5jYW52YXMuY2xpZW50SGVpZ2h0ICYmXHJcbiAgICAgICAgICAgICAgICAoYm91bmRpbmdQb2ludHNbMV0ueCA+IDAgfHwgYm91bmRpbmdQb2ludHNbMF0ueCA8IGVuZ2luZS5jYW52YXMuY2xpZW50V2lkdGgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGlmIGFueSBjb3JuZXIgaXMgdmlzaWJsZSwgd2UncmUgbm90IG9mZnNjcmVlblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kaW5nUG9pbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYm91bmRpbmdQb2ludHNbaV0ueCA+IDAgJiZcclxuICAgICAgICAgICAgICAgICAgICBib3VuZGluZ1BvaW50c1tpXS55ID4gMCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kaW5nUG9pbnRzW2ldLnggPCBlbmdpbmUuY2FudmFzLmNsaWVudFdpZHRoICYmXHJcbiAgICAgICAgICAgICAgICAgICAgYm91bmRpbmdQb2ludHNbaV0ueSA8IGVuZ2luZS5jYW52YXMuY2xpZW50SGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQ3VsbGluZ0JveC5wcm90b3R5cGUuZGVidWdEcmF3ID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gICAgICAgICAgICAvLyBib3VuZGluZyByZWN0YW5nbGVcclxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBDb2xvcl8xMy5Db2xvci5XaGl0ZS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBjdHgucmVjdCh0aGlzLl94TWluV29ybGQsIHRoaXMuX3lNaW5Xb3JsZCwgdGhpcy5feE1heFdvcmxkIC0gdGhpcy5feE1pbldvcmxkLCB0aGlzLl95TWF4V29ybGQgLSB0aGlzLl95TWluV29ybGQpO1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBDb2xvcl8xMy5Db2xvci5SZWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHguYXJjKHRoaXMuX3RvcExlZnQueCwgdGhpcy5fdG9wTGVmdC55LCA1LCAwLCBNYXRoLlBJICogMik7XHJcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgY3R4LmZpbGwoKTtcclxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IENvbG9yXzEzLkNvbG9yLkdyZWVuLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgY3R4LmFyYyh0aGlzLl90b3BSaWdodC54LCB0aGlzLl90b3BSaWdodC55LCA1LCAwLCBNYXRoLlBJICogMik7XHJcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgY3R4LmZpbGwoKTtcclxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IENvbG9yXzEzLkNvbG9yLkJsdWUudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHguYXJjKHRoaXMuX2JvdHRvbUxlZnQueCwgdGhpcy5fYm90dG9tTGVmdC55LCA1LCAwLCBNYXRoLlBJICogMik7XHJcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgY3R4LmZpbGwoKTtcclxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IENvbG9yXzEzLkNvbG9yLk1hZ2VudGEudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHguYXJjKHRoaXMuX2JvdHRvbVJpZ2h0LngsIHRoaXMuX2JvdHRvbVJpZ2h0LnksIDUsIDAsIE1hdGguUEkgKiAyKTtcclxuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEN1bGxpbmdCb3g7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5DdWxsaW5nQm94ID0gQ3VsbGluZ0JveDtcclxufSk7XHJcbmRlZmluZShcIlRyYWl0cy9PZmZzY3JlZW5DdWxsaW5nXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiVXRpbC9DdWxsaW5nQm94XCIsIFwiQWxnZWJyYVwiLCBcIkV2ZW50c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIEN1bGxpbmdCb3hfMSwgQWxnZWJyYV8xNCwgRXZlbnRzXzMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgdmFyIE9mZnNjcmVlbkN1bGxpbmcgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIE9mZnNjcmVlbkN1bGxpbmcoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VsbGluZ0JveCA9IG5ldyBDdWxsaW5nQm94XzEuQ3VsbGluZ0JveCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBPZmZzY3JlZW5DdWxsaW5nLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoYWN0b3IsIGVuZ2luZSkge1xyXG4gICAgICAgICAgICB2YXIgZXZlbnREaXNwYXRjaGVyID0gYWN0b3IuZXZlbnREaXNwYXRjaGVyO1xyXG4gICAgICAgICAgICB2YXIgYW5jaG9yID0gYWN0b3IuYW5jaG9yO1xyXG4gICAgICAgICAgICB2YXIgZ2xvYmFsU2NhbGUgPSBhY3Rvci5nZXRHbG9iYWxTY2FsZSgpO1xyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSBnbG9iYWxTY2FsZS54ICogYWN0b3IuZ2V0V2lkdGgoKSAvIGFjdG9yLnNjYWxlLng7XHJcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBnbG9iYWxTY2FsZS55ICogYWN0b3IuZ2V0SGVpZ2h0KCkgLyBhY3Rvci5zY2FsZS55O1xyXG4gICAgICAgICAgICB2YXIgd29ybGRQb3MgPSBhY3Rvci5nZXRXb3JsZFBvcygpO1xyXG4gICAgICAgICAgICB2YXIgYWN0b3JTY3JlZW5Db29yZHMgPSBlbmdpbmUud29ybGRUb1NjcmVlbkNvb3JkaW5hdGVzKG5ldyBBbGdlYnJhXzE0LlZlY3Rvcih3b3JsZFBvcy54IC0gYW5jaG9yLnggKiB3aWR0aCwgd29ybGRQb3MueSAtIGFuY2hvci55ICogaGVpZ2h0KSk7XHJcbiAgICAgICAgICAgIHZhciB6b29tID0gMS4wO1xyXG4gICAgICAgICAgICBpZiAoYWN0b3Iuc2NlbmUgJiYgYWN0b3Iuc2NlbmUuY2FtZXJhKSB7XHJcbiAgICAgICAgICAgICAgICB6b29tID0gTWF0aC5hYnMoYWN0b3Iuc2NlbmUuY2FtZXJhLmdldFpvb20oKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGlzU3ByaXRlT2ZmU2NyZWVuID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKGFjdG9yLmN1cnJlbnREcmF3aW5nICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlzU3ByaXRlT2ZmU2NyZWVuID0gdGhpcy5jdWxsaW5nQm94LmlzU3ByaXRlT2ZmU2NyZWVuKGFjdG9yLCBlbmdpbmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghYWN0b3IuaXNPZmZTY3JlZW4pIHtcclxuICAgICAgICAgICAgICAgIGlmICgoYWN0b3JTY3JlZW5Db29yZHMueCArIHdpZHRoICogem9vbSA8IDAgfHxcclxuICAgICAgICAgICAgICAgICAgICBhY3RvclNjcmVlbkNvb3Jkcy55ICsgaGVpZ2h0ICogem9vbSA8IDAgfHxcclxuICAgICAgICAgICAgICAgICAgICBhY3RvclNjcmVlbkNvb3Jkcy54ID4gZW5naW5lLmNhbnZhc1dpZHRoIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0b3JTY3JlZW5Db29yZHMueSA+IGVuZ2luZS5jYW52YXNIZWlnaHQpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgaXNTcHJpdGVPZmZTY3JlZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBldmVudERpc3BhdGNoZXIuZW1pdCgnZXhpdHZpZXdwb3J0JywgbmV3IEV2ZW50c18zLkV4aXRWaWV3UG9ydEV2ZW50KGFjdG9yKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0b3IuaXNPZmZTY3JlZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKChhY3RvclNjcmVlbkNvb3Jkcy54ICsgd2lkdGggKiB6b29tID4gMCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGFjdG9yU2NyZWVuQ29vcmRzLnkgKyBoZWlnaHQgKiB6b29tID4gMCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGFjdG9yU2NyZWVuQ29vcmRzLnggPCBlbmdpbmUuY2FudmFzV2lkdGggJiZcclxuICAgICAgICAgICAgICAgICAgICBhY3RvclNjcmVlbkNvb3Jkcy55IDwgZW5naW5lLmNhbnZhc0hlaWdodCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAhaXNTcHJpdGVPZmZTY3JlZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBldmVudERpc3BhdGNoZXIuZW1pdCgnZW50ZXJ2aWV3cG9ydCcsIG5ldyBFdmVudHNfMy5FbnRlclZpZXdQb3J0RXZlbnQoYWN0b3IpKTtcclxuICAgICAgICAgICAgICAgICAgICBhY3Rvci5pc09mZlNjcmVlbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gT2Zmc2NyZWVuQ3VsbGluZztcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLk9mZnNjcmVlbkN1bGxpbmcgPSBPZmZzY3JlZW5DdWxsaW5nO1xyXG59KTtcclxuZGVmaW5lKFwiVHJhaXRzL1RpbGVNYXBDb2xsaXNpb25EZXRlY3Rpb25cIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJBY3RvclwiLCBcIkNvbGxpc2lvbi9TaWRlXCIsIFwiRXZlbnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgQWN0b3JfNiwgU2lkZV8yLCBFdmVudHNfNCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICB2YXIgVGlsZU1hcENvbGxpc2lvbkRldGVjdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gVGlsZU1hcENvbGxpc2lvbkRldGVjdGlvbigpIHtcclxuICAgICAgICB9XHJcbiAgICAgICAgVGlsZU1hcENvbGxpc2lvbkRldGVjdGlvbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGFjdG9yLCBlbmdpbmUpIHtcclxuICAgICAgICAgICAgdmFyIGV2ZW50RGlzcGF0Y2hlciA9IGFjdG9yLmV2ZW50RGlzcGF0Y2hlcjtcclxuICAgICAgICAgICAgaWYgKGFjdG9yLmNvbGxpc2lvblR5cGUgIT09IEFjdG9yXzYuQ29sbGlzaW9uVHlwZS5QcmV2ZW50Q29sbGlzaW9uICYmIGVuZ2luZS5jdXJyZW50U2NlbmUgJiYgZW5naW5lLmN1cnJlbnRTY2VuZS50aWxlTWFwcykge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlbmdpbmUuY3VycmVudFNjZW5lLnRpbGVNYXBzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hcCA9IGVuZ2luZS5jdXJyZW50U2NlbmUudGlsZU1hcHNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGludGVyc2VjdE1hcDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2lkZSA9IFNpZGVfMi5TaWRlLk5vbmU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heCA9IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGludGVyc2VjdE1hcCA9IG1hcC5jb2xsaWRlcyhhY3RvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1heC0tIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2lkZSA9IGFjdG9yLmdldFNpZGVGcm9tSW50ZXJzZWN0KGludGVyc2VjdE1hcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50RGlzcGF0Y2hlci5lbWl0KCdwcmVjb2xsaXNpb24nLCBuZXcgRXZlbnRzXzQuUHJlQ29sbGlzaW9uRXZlbnQoYWN0b3IsIG51bGwsIHNpZGUsIGludGVyc2VjdE1hcCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWN0b3IuY29sbGlzaW9uVHlwZSA9PT0gQWN0b3JfNi5Db2xsaXNpb25UeXBlLkFjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0b3IucG9zLnkgKz0gaW50ZXJzZWN0TWFwLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rvci5wb3MueCArPSBpbnRlcnNlY3RNYXAueDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50RGlzcGF0Y2hlci5lbWl0KCdwb3N0Y29sbGlzaW9uJywgbmV3IEV2ZW50c180LlBvc3RDb2xsaXNpb25FdmVudChhY3RvciwgbnVsbCwgc2lkZSwgaW50ZXJzZWN0TWFwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBUaWxlTWFwQ29sbGlzaW9uRGV0ZWN0aW9uO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuVGlsZU1hcENvbGxpc2lvbkRldGVjdGlvbiA9IFRpbGVNYXBDb2xsaXNpb25EZXRlY3Rpb247XHJcbn0pO1xyXG5kZWZpbmUoXCJUcmFpdHMvSW5kZXhcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJUcmFpdHMvQ2FwdHVyZVBvaW50ZXJcIiwgXCJUcmFpdHMvRXVsZXJNb3ZlbWVudFwiLCBcIlRyYWl0cy9PZmZzY3JlZW5DdWxsaW5nXCIsIFwiVHJhaXRzL1RpbGVNYXBDb2xsaXNpb25EZXRlY3Rpb25cIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBDYXB0dXJlUG9pbnRlcl8xLCBFdWxlck1vdmVtZW50XzEsIE9mZnNjcmVlbkN1bGxpbmdfMSwgVGlsZU1hcENvbGxpc2lvbkRldGVjdGlvbl8xKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIGZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcclxuICAgICAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICBfX2V4cG9ydChDYXB0dXJlUG9pbnRlcl8xKTtcclxuICAgIF9fZXhwb3J0KEV1bGVyTW92ZW1lbnRfMSk7XHJcbiAgICBfX2V4cG9ydChPZmZzY3JlZW5DdWxsaW5nXzEpO1xyXG4gICAgX19leHBvcnQoVGlsZU1hcENvbGxpc2lvbkRldGVjdGlvbl8xKTtcclxufSk7XHJcbmRlZmluZShcIlBhcnRpY2xlc1wiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkFjdG9yXCIsIFwiRHJhd2luZy9Db2xvclwiLCBcIkFsZ2VicmFcIiwgXCJVdGlsL1V0aWxcIiwgXCJVdGlsL0RyYXdVdGlsXCIsIFwiVHJhaXRzL0luZGV4XCIsIFwiQ29uZmlndXJhYmxlXCIsIFwiTWF0aC9SYW5kb21cIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBBY3Rvcl83LCBDb2xvcl8xNCwgQWxnZWJyYV8xNSwgVXRpbCwgRHJhd1V0aWwsIFRyYWl0cywgQ29uZmlndXJhYmxlXzUsIFJhbmRvbV8yKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogQW4gZW51bSB0aGF0IHJlcHJlc2VudHMgdGhlIHR5cGVzIG9mIGVtaXR0ZXIgbm96emxlc1xyXG4gICAgICovXHJcbiAgICB2YXIgRW1pdHRlclR5cGU7XHJcbiAgICAoZnVuY3Rpb24gKEVtaXR0ZXJUeXBlKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uc3RhbnQgZm9yIHRoZSBjaXJjdWxhciBlbWl0dGVyIHR5cGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBFbWl0dGVyVHlwZVtFbWl0dGVyVHlwZVtcIkNpcmNsZVwiXSA9IDBdID0gXCJDaXJjbGVcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25zdGFudCBmb3IgdGhlIHJlY3Rhbmd1bGFyIGVtaXR0ZXIgdHlwZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVtaXR0ZXJUeXBlW0VtaXR0ZXJUeXBlW1wiUmVjdGFuZ2xlXCJdID0gMV0gPSBcIlJlY3RhbmdsZVwiO1xyXG4gICAgfSkoRW1pdHRlclR5cGUgPSBleHBvcnRzLkVtaXR0ZXJUeXBlIHx8IChleHBvcnRzLkVtaXR0ZXJUeXBlID0ge30pKTtcclxuICAgIC8qKlxyXG4gICAgICogQGhpZGRlblxyXG4gICAgICovXHJcbiAgICB2YXIgUGFydGljbGVJbXBsID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBQYXJ0aWNsZUltcGwoZW1pdHRlck9yQ29uZmlnLCBsaWZlLCBvcGFjaXR5LCBiZWdpbkNvbG9yLCBlbmRDb2xvciwgcG9zaXRpb24sIHZlbG9jaXR5LCBhY2NlbGVyYXRpb24sIHN0YXJ0U2l6ZSwgZW5kU2l6ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gbmV3IEFsZ2VicmFfMTUuVmVjdG9yKDAsIDApO1xyXG4gICAgICAgICAgICB0aGlzLnZlbG9jaXR5ID0gbmV3IEFsZ2VicmFfMTUuVmVjdG9yKDAsIDApO1xyXG4gICAgICAgICAgICB0aGlzLmFjY2VsZXJhdGlvbiA9IG5ldyBBbGdlYnJhXzE1LlZlY3RvcigwLCAwKTtcclxuICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZVJvdGF0aW9uYWxWZWxvY2l0eSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFJvdGF0aW9uID0gMDtcclxuICAgICAgICAgICAgdGhpcy5mb2N1cyA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuZm9jdXNBY2NlbCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMub3BhY2l0eSA9IDE7XHJcbiAgICAgICAgICAgIHRoaXMuYmVnaW5Db2xvciA9IENvbG9yXzE0LkNvbG9yLldoaXRlLmNsb25lKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kQ29sb3IgPSBDb2xvcl8xNC5Db2xvci5XaGl0ZS5jbG9uZSgpO1xyXG4gICAgICAgICAgICAvLyBMaWZlIGlzIGNvdW50ZWQgaW4gbXNcclxuICAgICAgICAgICAgdGhpcy5saWZlID0gMzAwO1xyXG4gICAgICAgICAgICB0aGlzLmZhZGVGbGFnID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8vIENvbG9yIHRyYW5zaXRpb25zXHJcbiAgICAgICAgICAgIHRoaXMuX3JSYXRlID0gMTtcclxuICAgICAgICAgICAgdGhpcy5fZ1JhdGUgPSAxO1xyXG4gICAgICAgICAgICB0aGlzLl9iUmF0ZSA9IDE7XHJcbiAgICAgICAgICAgIHRoaXMuX2FSYXRlID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudENvbG9yID0gQ29sb3JfMTQuQ29sb3IuV2hpdGUuY2xvbmUoKTtcclxuICAgICAgICAgICAgdGhpcy5lbWl0dGVyID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZVNpemUgPSA1O1xyXG4gICAgICAgICAgICB0aGlzLnBhcnRpY2xlU3ByaXRlID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5zaXplUmF0ZSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuZWxhcHNlZE11bHRpcGxpZXIgPSAwO1xyXG4gICAgICAgICAgICB2YXIgZW1pdHRlciA9IGVtaXR0ZXJPckNvbmZpZztcclxuICAgICAgICAgICAgaWYgKGVtaXR0ZXIgJiYgIShlbWl0dGVyT3JDb25maWcgaW5zdGFuY2VvZiBQYXJ0aWNsZUVtaXR0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29uZmlnID0gZW1pdHRlck9yQ29uZmlnO1xyXG4gICAgICAgICAgICAgICAgZW1pdHRlciA9IGNvbmZpZy5lbWl0dGVyO1xyXG4gICAgICAgICAgICAgICAgbGlmZSA9IGNvbmZpZy5saWZlO1xyXG4gICAgICAgICAgICAgICAgb3BhY2l0eSA9IGNvbmZpZy5vcGFjaXR5O1xyXG4gICAgICAgICAgICAgICAgZW5kQ29sb3IgPSBjb25maWcuZW5kQ29sb3I7XHJcbiAgICAgICAgICAgICAgICBiZWdpbkNvbG9yID0gY29uZmlnLmJlZ2luQ29sb3I7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IGNvbmZpZy5wb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgIHZlbG9jaXR5ID0gY29uZmlnLnZlbG9jaXR5O1xyXG4gICAgICAgICAgICAgICAgYWNjZWxlcmF0aW9uID0gY29uZmlnLmFjY2VsZXJhdGlvbjtcclxuICAgICAgICAgICAgICAgIHN0YXJ0U2l6ZSA9IGNvbmZpZy5zdGFydFNpemU7XHJcbiAgICAgICAgICAgICAgICBlbmRTaXplID0gY29uZmlnLmVuZFNpemU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5lbWl0dGVyID0gZW1pdHRlcjtcclxuICAgICAgICAgICAgdGhpcy5saWZlID0gbGlmZSB8fCB0aGlzLmxpZmU7XHJcbiAgICAgICAgICAgIHRoaXMub3BhY2l0eSA9IG9wYWNpdHkgfHwgdGhpcy5vcGFjaXR5O1xyXG4gICAgICAgICAgICB0aGlzLmVuZENvbG9yID0gZW5kQ29sb3IgfHwgdGhpcy5lbmRDb2xvci5jbG9uZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmJlZ2luQ29sb3IgPSBiZWdpbkNvbG9yIHx8IHRoaXMuYmVnaW5Db2xvci5jbG9uZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50Q29sb3IgPSB0aGlzLmJlZ2luQ29sb3IuY2xvbmUoKTtcclxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uIHx8IHRoaXMucG9zaXRpb247XHJcbiAgICAgICAgICAgIHRoaXMudmVsb2NpdHkgPSB2ZWxvY2l0eSB8fCB0aGlzLnZlbG9jaXR5O1xyXG4gICAgICAgICAgICB0aGlzLmFjY2VsZXJhdGlvbiA9IGFjY2VsZXJhdGlvbiB8fCB0aGlzLmFjY2VsZXJhdGlvbjtcclxuICAgICAgICAgICAgdGhpcy5fclJhdGUgPSAodGhpcy5lbmRDb2xvci5yIC0gdGhpcy5iZWdpbkNvbG9yLnIpIC8gdGhpcy5saWZlO1xyXG4gICAgICAgICAgICB0aGlzLl9nUmF0ZSA9ICh0aGlzLmVuZENvbG9yLmcgLSB0aGlzLmJlZ2luQ29sb3IuZykgLyB0aGlzLmxpZmU7XHJcbiAgICAgICAgICAgIHRoaXMuX2JSYXRlID0gKHRoaXMuZW5kQ29sb3IuYiAtIHRoaXMuYmVnaW5Db2xvci5iKSAvIHRoaXMubGlmZTtcclxuICAgICAgICAgICAgdGhpcy5fYVJhdGUgPSB0aGlzLm9wYWNpdHkgLyB0aGlzLmxpZmU7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRTaXplID0gc3RhcnRTaXplIHx8IDA7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kU2l6ZSA9IGVuZFNpemUgfHwgMDtcclxuICAgICAgICAgICAgaWYgKCh0aGlzLmVuZFNpemUgPiAwKSAmJiAodGhpcy5zdGFydFNpemUgPiAwKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaXplUmF0ZSA9ICh0aGlzLmVuZFNpemUgLSB0aGlzLnN0YXJ0U2l6ZSkgLyB0aGlzLmxpZmU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnRpY2xlU2l6ZSA9IHRoaXMuc3RhcnRTaXplO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFBhcnRpY2xlSW1wbC5wcm90b3R5cGUua2lsbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnJlbW92ZVBhcnRpY2xlKHRoaXMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUGFydGljbGVJbXBsLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcclxuICAgICAgICAgICAgdGhpcy5saWZlID0gdGhpcy5saWZlIC0gZGVsdGE7XHJcbiAgICAgICAgICAgIHRoaXMuZWxhcHNlZE11bHRpcGxpZXIgPSB0aGlzLmVsYXBzZWRNdWx0aXBsaWVyICsgZGVsdGE7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxpZmUgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmtpbGwoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5mYWRlRmxhZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcGFjaXR5ID0gVXRpbC5jbGFtcCh0aGlzLl9hUmF0ZSAqIHRoaXMubGlmZSwgMC4wMDAxLCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKHRoaXMuc3RhcnRTaXplID4gMCkgJiYgKHRoaXMuZW5kU2l6ZSA+IDApKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnRpY2xlU2l6ZSA9IFV0aWwuY2xhbXAodGhpcy5zaXplUmF0ZSAqIGRlbHRhICsgdGhpcy5wYXJ0aWNsZVNpemUsIE1hdGgubWluKHRoaXMuc3RhcnRTaXplLCB0aGlzLmVuZFNpemUpLCBNYXRoLm1heCh0aGlzLnN0YXJ0U2l6ZSwgdGhpcy5lbmRTaXplKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudENvbG9yLnIgPSBVdGlsLmNsYW1wKHRoaXMuX2N1cnJlbnRDb2xvci5yICsgdGhpcy5fclJhdGUgKiBkZWx0YSwgMCwgMjU1KTtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudENvbG9yLmcgPSBVdGlsLmNsYW1wKHRoaXMuX2N1cnJlbnRDb2xvci5nICsgdGhpcy5fZ1JhdGUgKiBkZWx0YSwgMCwgMjU1KTtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudENvbG9yLmIgPSBVdGlsLmNsYW1wKHRoaXMuX2N1cnJlbnRDb2xvci5iICsgdGhpcy5fYlJhdGUgKiBkZWx0YSwgMCwgMjU1KTtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudENvbG9yLmEgPSBVdGlsLmNsYW1wKHRoaXMub3BhY2l0eSwgMC4wMDAxLCAxKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZm9jdXMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhY2NlbCA9IHRoaXMuZm9jdXMuc3ViKHRoaXMucG9zaXRpb24pLm5vcm1hbGl6ZSgpLnNjYWxlKHRoaXMuZm9jdXNBY2NlbCkuc2NhbGUoZGVsdGEgLyAxMDAwKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudmVsb2NpdHkgPSB0aGlzLnZlbG9jaXR5LmFkZChhY2NlbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZlbG9jaXR5ID0gdGhpcy52ZWxvY2l0eS5hZGQodGhpcy5hY2NlbGVyYXRpb24uc2NhbGUoZGVsdGEgLyAxMDAwKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHRoaXMucG9zaXRpb24uYWRkKHRoaXMudmVsb2NpdHkuc2NhbGUoZGVsdGEgLyAxMDAwKSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnRpY2xlUm90YXRpb25hbFZlbG9jaXR5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRSb3RhdGlvbiA9ICh0aGlzLmN1cnJlbnRSb3RhdGlvbiArIHRoaXMucGFydGljbGVSb3RhdGlvbmFsVmVsb2NpdHkgKiBkZWx0YSAvIDEwMDApICUgKDIgKiBNYXRoLlBJKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgUGFydGljbGVJbXBsLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wYXJ0aWNsZVNwcml0ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZVNwcml0ZS5yb3RhdGlvbiA9IHRoaXMuY3VycmVudFJvdGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZVNwcml0ZS5zY2FsZS5zZXRUbyh0aGlzLnBhcnRpY2xlU2l6ZSwgdGhpcy5wYXJ0aWNsZVNpemUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZVNwcml0ZS5kcmF3KGN0eCwgdGhpcy5wb3NpdGlvbi54LCB0aGlzLnBvc2l0aW9uLnkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRDb2xvci5hID0gVXRpbC5jbGFtcCh0aGlzLm9wYWNpdHksIDAuMDAwMSwgMSk7XHJcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLl9jdXJyZW50Q29sb3IudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHguYXJjKHRoaXMucG9zaXRpb24ueCwgdGhpcy5wb3NpdGlvbi55LCB0aGlzLnBhcnRpY2xlU2l6ZSwgMCwgTWF0aC5QSSAqIDIpO1xyXG4gICAgICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gUGFydGljbGVJbXBsO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuUGFydGljbGVJbXBsID0gUGFydGljbGVJbXBsO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJ0aWNsZSBpcyB1c2VkIGluIGEgW1tQYXJ0aWNsZUVtaXR0ZXJdXVxyXG4gICAgICovXHJcbiAgICB2YXIgUGFydGljbGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhQYXJ0aWNsZSwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBQYXJ0aWNsZShlbWl0dGVyT3JDb25maWcsIGxpZmUsIG9wYWNpdHksIGJlZ2luQ29sb3IsIGVuZENvbG9yLCBwb3NpdGlvbiwgdmVsb2NpdHksIGFjY2VsZXJhdGlvbiwgc3RhcnRTaXplLCBlbmRTaXplKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBlbWl0dGVyT3JDb25maWcsIGxpZmUsIG9wYWNpdHksIGJlZ2luQ29sb3IsIGVuZENvbG9yLCBwb3NpdGlvbiwgdmVsb2NpdHksIGFjY2VsZXJhdGlvbiwgc3RhcnRTaXplLCBlbmRTaXplKSB8fCB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUGFydGljbGU7XHJcbiAgICB9KENvbmZpZ3VyYWJsZV81LkNvbmZpZ3VyYWJsZShQYXJ0aWNsZUltcGwpKSk7XHJcbiAgICBleHBvcnRzLlBhcnRpY2xlID0gUGFydGljbGU7XHJcbiAgICAvKipcclxuICAgICAqIEBoaWRkZW5cclxuICAgICAqL1xyXG4gICAgdmFyIFBhcnRpY2xlRW1pdHRlckltcGwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhQYXJ0aWNsZUVtaXR0ZXJJbXBsLCBfc3VwZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB4ICAgICAgIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBlbWl0dGVyXHJcbiAgICAgICAgICogQHBhcmFtIHkgICAgICAgVGhlIHkgcG9zaXRpb24gb2YgdGhlIGVtaXR0ZXJcclxuICAgICAgICAgKiBAcGFyYW0gd2lkdGggICBUaGUgd2lkdGggb2YgdGhlIGVtaXR0ZXJcclxuICAgICAgICAgKiBAcGFyYW0gaGVpZ2h0ICBUaGUgaGVpZ2h0IG9mIHRoZSBlbWl0dGVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gUGFydGljbGVFbWl0dGVySW1wbCh4T3JDb25maWcsIHksIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZW9mIHhPckNvbmZpZyA9PT0gJ251bWJlcicgPyB7IHg6IHhPckNvbmZpZywgeTogeSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9IDogeE9yQ29uZmlnKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5udW1QYXJ0aWNsZXMgPSAwO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBpc0VtaXR0aW5nIGZsYWdcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmlzRW1pdHRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBiYWNraW5nIHBhcnRpY2xlIGNvbGxlY3Rpb25cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLnBhcnRpY2xlcyA9IG51bGw7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGJhY2tpbmcgZGVhZFBhcnRpY2xlIGNvbGxlY3Rpb25cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmRlYWRQYXJ0aWNsZXMgPSBudWxsO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBtaW5pbXVtIHBhcnRpY2xlIHZlbG9jaXR5XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5taW5WZWwgPSAwO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBtYXhpbXVtIHBhcnRpY2xlIHZlbG9jaXR5XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5tYXhWZWwgPSAwO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBhY2NlbGVyYXRpb24gdmVjdG9yIGZvciBhbGwgcGFydGljbGVzXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5hY2NlbGVyYXRpb24gPSBuZXcgQWxnZWJyYV8xNS5WZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG1pbmltdW0gYW5nbGUgaW4gcmFkaWFuc1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMubWluQW5nbGUgPSAwO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBtYXhpbXVtIGFuZ2xlIGluIHJhZGlhbnNcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLm1heEFuZ2xlID0gMDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgZW1pc3Npb24gcmF0ZSBmb3IgcGFydGljbGVzIChwYXJ0aWNsZXMvc2VjKVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuZW1pdFJhdGUgPSAxOyAvL3BhcnRpY2xlcy9zZWNcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbGlmZSBvZiBlYWNoIHBhcnRpY2xlIGluIG1pbGxpc2Vjb25kc1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMucGFydGljbGVMaWZlID0gMjAwMDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgb3BhY2l0eSBvZiBlYWNoIHBhcnRpY2xlIGZyb20gMCB0byAxLjBcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLm9wYWNpdHkgPSAxO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBmYWRlIGZsYWcgd2hpY2ggY2F1c2VzIHBhcnRpY2xlcyB0byBncmFkdWFsbHkgZmFkZSBvdXQgb3ZlciB0aGUgY291cnNlIG9mIHRoZWlyIGxpZmUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5mYWRlRmxhZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBvcHRpb25hbCBmb2N1cyB3aGVyZSBhbGwgcGFydGljbGVzIHNob3VsZCBhY2NlbGVyYXRlIHRvd2FyZHNcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmZvY3VzID0gbnVsbDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgYWNjZWxlcmF0aW9uIGZvciBmb2N1c2luZyBwYXJ0aWNsZXMgaWYgYSBmb2N1cyBoYXMgYmVlbiBzcGVjaWZpZWRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmZvY3VzQWNjZWwgPSAxO1xyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG9wdGlvbmFsIHN0YXJ0aW5nIHNpemUgZm9yIHRoZSBwYXJ0aWNsZXNcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLnN0YXJ0U2l6ZSA9IG51bGw7XHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgb3B0aW9uYWwgZW5kaW5nIHNpemUgZm9yIHRoZSBwYXJ0aWNsZXNcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmVuZFNpemUgPSBudWxsO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBtaW5pbXVtIHNpemUgb2YgYWxsIHBhcnRpY2xlc1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMubWluU2l6ZSA9IDU7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG1heGltdW0gc2l6ZSBvZiBhbGwgcGFydGljbGVzXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5tYXhTaXplID0gNTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgYmVnaW5uaW5nIGNvbG9yIG9mIGFsbCBwYXJ0aWNsZXNcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmJlZ2luQ29sb3IgPSBDb2xvcl8xNC5Db2xvci5XaGl0ZS5jbG9uZSgpO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBlbmRpbmcgY29sb3Igb2YgYWxsIHBhcnRpY2xlc1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuZW5kQ29sb3IgPSBDb2xvcl8xNC5Db2xvci5XaGl0ZS5jbG9uZSgpO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBzcHJpdGUgdGhhdCBhIHBhcnRpY2xlIHNob3VsZCB1c2VcclxuICAgICAgICAgICAgICogQHdhcm5pbmcgUGVyZm9ybWFuY2UgaW50ZW5zaXZlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5wYXJ0aWNsZVNwcml0ZSA9IG51bGw7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGVtaXR0ZXIgdHlwZSBmb3IgdGhlIHBhcnRpY2xlIGVtaXR0ZXJcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmVtaXR0ZXJUeXBlID0gRW1pdHRlclR5cGUuUmVjdGFuZ2xlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBlbWl0dGVyIHJhZGl1cywgb25seSB0YWtlcyBlZmZlY3Qgd2hlbiB0aGUgW1tlbWl0dGVyVHlwZV1dIGlzIFtbRW1pdHRlclR5cGUuQ2lyY2xlXV1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLnJhZGl1cyA9IDA7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHBhcnRpY2xlIHJvdGF0aW9uYWwgc3BlZWQgdmVsb2NpdHlcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLnBhcnRpY2xlUm90YXRpb25hbFZlbG9jaXR5ID0gMDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHBhcnRpY2xlcyBzaG91bGQgc3RhcnQgd2l0aCBhIHJhbmRvbSByb3RhdGlvblxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMucmFuZG9tUm90YXRpb24gPSBmYWxzZTtcclxuICAgICAgICAgICAgX3RoaXMuX3BhcnRpY2xlc1RvRW1pdCA9IDA7XHJcbiAgICAgICAgICAgIF90aGlzLmNvbGxpc2lvblR5cGUgPSBBY3Rvcl83LkNvbGxpc2lvblR5cGUuUHJldmVudENvbGxpc2lvbjtcclxuICAgICAgICAgICAgX3RoaXMucGFydGljbGVzID0gbmV3IFV0aWwuQ29sbGVjdGlvbigpO1xyXG4gICAgICAgICAgICBfdGhpcy5kZWFkUGFydGljbGVzID0gbmV3IFV0aWwuQ29sbGVjdGlvbigpO1xyXG4gICAgICAgICAgICBfdGhpcy5yYW5kb20gPSBuZXcgUmFuZG9tXzIuUmFuZG9tKCk7XHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSBvZmZzY3JlZW4gY3VsbGluZyBmcm9tIHBhcnRpY2xlIGVtaXR0ZXJzXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMudHJhaXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMudHJhaXRzW2ldIGluc3RhbmNlb2YgVHJhaXRzLk9mZnNjcmVlbkN1bGxpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy50cmFpdHMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgUGFydGljbGVFbWl0dGVySW1wbC5wcm90b3R5cGUucmVtb3ZlUGFydGljbGUgPSBmdW5jdGlvbiAocGFydGljbGUpIHtcclxuICAgICAgICAgICAgdGhpcy5kZWFkUGFydGljbGVzLnB1c2gocGFydGljbGUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2F1c2VzIHRoZSBlbWl0dGVyIHRvIGVtaXQgcGFydGljbGVzXHJcbiAgICAgICAgICogQHBhcmFtIHBhcnRpY2xlQ291bnQgIE51bWJlciBvZiBwYXJ0aWNsZXMgdG8gZW1pdCByaWdodCBub3dcclxuICAgICAgICAgKi9cclxuICAgICAgICBQYXJ0aWNsZUVtaXR0ZXJJbXBsLnByb3RvdHlwZS5lbWl0UGFydGljbGVzID0gZnVuY3Rpb24gKHBhcnRpY2xlQ291bnQpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0aWNsZUNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFydGljbGVzLnB1c2godGhpcy5fY3JlYXRlUGFydGljbGUoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFBhcnRpY2xlRW1pdHRlckltcGwucHJvdG90eXBlLmNsZWFyUGFydGljbGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnBhcnRpY2xlcy5jbGVhcigpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gQ3JlYXRlcyBhIG5ldyBwYXJ0aWNsZSBnaXZlbiB0aGUgY29uc3RyYWludHMgb2YgdGhlIGVtaXR0ZXJcclxuICAgICAgICBQYXJ0aWNsZUVtaXR0ZXJJbXBsLnByb3RvdHlwZS5fY3JlYXRlUGFydGljbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIHRvZG8gaW1wbGVtZW50IGVtaXR0ZXIgY29uc3RyYWludHM7XHJcbiAgICAgICAgICAgIHZhciByYW5YID0gMDtcclxuICAgICAgICAgICAgdmFyIHJhblkgPSAwO1xyXG4gICAgICAgICAgICB2YXIgYW5nbGUgPSBVdGlsLnJhbmRvbUluUmFuZ2UodGhpcy5taW5BbmdsZSwgdGhpcy5tYXhBbmdsZSwgdGhpcy5yYW5kb20pO1xyXG4gICAgICAgICAgICB2YXIgdmVsID0gVXRpbC5yYW5kb21JblJhbmdlKHRoaXMubWluVmVsLCB0aGlzLm1heFZlbCwgdGhpcy5yYW5kb20pO1xyXG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuc3RhcnRTaXplIHx8IFV0aWwucmFuZG9tSW5SYW5nZSh0aGlzLm1pblNpemUsIHRoaXMubWF4U2l6ZSwgdGhpcy5yYW5kb20pO1xyXG4gICAgICAgICAgICB2YXIgZHggPSB2ZWwgKiBNYXRoLmNvcyhhbmdsZSk7XHJcbiAgICAgICAgICAgIHZhciBkeSA9IHZlbCAqIE1hdGguc2luKGFuZ2xlKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZW1pdHRlclR5cGUgPT09IEVtaXR0ZXJUeXBlLlJlY3RhbmdsZSkge1xyXG4gICAgICAgICAgICAgICAgcmFuWCA9IFV0aWwucmFuZG9tSW5SYW5nZSh0aGlzLnBvcy54LCB0aGlzLnBvcy54ICsgdGhpcy5nZXRXaWR0aCgpLCB0aGlzLnJhbmRvbSk7XHJcbiAgICAgICAgICAgICAgICByYW5ZID0gVXRpbC5yYW5kb21JblJhbmdlKHRoaXMucG9zLnksIHRoaXMucG9zLnkgKyB0aGlzLmdldEhlaWdodCgpLCB0aGlzLnJhbmRvbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5lbWl0dGVyVHlwZSA9PT0gRW1pdHRlclR5cGUuQ2lyY2xlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmFkaXVzID0gVXRpbC5yYW5kb21JblJhbmdlKDAsIHRoaXMucmFkaXVzLCB0aGlzLnJhbmRvbSk7XHJcbiAgICAgICAgICAgICAgICByYW5YID0gcmFkaXVzICogTWF0aC5jb3MoYW5nbGUpICsgdGhpcy5wb3MueDtcclxuICAgICAgICAgICAgICAgIHJhblkgPSByYWRpdXMgKiBNYXRoLnNpbihhbmdsZSkgKyB0aGlzLnBvcy55O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBwID0gbmV3IFBhcnRpY2xlKHRoaXMsIHRoaXMucGFydGljbGVMaWZlLCB0aGlzLm9wYWNpdHksIHRoaXMuYmVnaW5Db2xvciwgdGhpcy5lbmRDb2xvciwgbmV3IEFsZ2VicmFfMTUuVmVjdG9yKHJhblgsIHJhblkpLCBuZXcgQWxnZWJyYV8xNS5WZWN0b3IoZHgsIGR5KSwgdGhpcy5hY2NlbGVyYXRpb24sIHRoaXMuc3RhcnRTaXplLCB0aGlzLmVuZFNpemUpO1xyXG4gICAgICAgICAgICBwLmZhZGVGbGFnID0gdGhpcy5mYWRlRmxhZztcclxuICAgICAgICAgICAgcC5wYXJ0aWNsZVNpemUgPSBzaXplO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wYXJ0aWNsZVNwcml0ZSkge1xyXG4gICAgICAgICAgICAgICAgcC5wYXJ0aWNsZVNwcml0ZSA9IHRoaXMucGFydGljbGVTcHJpdGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcC5wYXJ0aWNsZVJvdGF0aW9uYWxWZWxvY2l0eSA9IHRoaXMucGFydGljbGVSb3RhdGlvbmFsVmVsb2NpdHk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJhbmRvbVJvdGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBwLmN1cnJlbnRSb3RhdGlvbiA9IFV0aWwucmFuZG9tSW5SYW5nZSgwLCBNYXRoLlBJICogMiwgdGhpcy5yYW5kb20pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZvY3VzKSB7XHJcbiAgICAgICAgICAgICAgICBwLmZvY3VzID0gdGhpcy5mb2N1cy5hZGQobmV3IEFsZ2VicmFfMTUuVmVjdG9yKHRoaXMucG9zLngsIHRoaXMucG9zLnkpKTtcclxuICAgICAgICAgICAgICAgIHAuZm9jdXNBY2NlbCA9IHRoaXMuZm9jdXNBY2NlbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFBhcnRpY2xlRW1pdHRlckltcGwucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChlbmdpbmUsIGRlbHRhKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcywgZW5naW5lLCBkZWx0YSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRW1pdHRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BhcnRpY2xlc1RvRW1pdCArPSB0aGlzLmVtaXRSYXRlICogKGRlbHRhIC8gMTAwMCk7XHJcbiAgICAgICAgICAgICAgICAvL3ZhciBudW1QYXJ0aWNsZXMgPSBNYXRoLmNlaWwodGhpcy5lbWl0UmF0ZSAqIGRlbHRhIC8gMTAwMCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcGFydGljbGVzVG9FbWl0ID4gMS4wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0UGFydGljbGVzKE1hdGguZmxvb3IodGhpcy5fcGFydGljbGVzVG9FbWl0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFydGljbGVzVG9FbWl0ID0gdGhpcy5fcGFydGljbGVzVG9FbWl0IC0gTWF0aC5mbG9vcih0aGlzLl9wYXJ0aWNsZXNUb0VtaXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucGFydGljbGVzLmZvckVhY2goZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAudXBkYXRlKGRlbHRhKTsgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuZGVhZFBhcnRpY2xlcy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7IHJldHVybiBfdGhpcy5wYXJ0aWNsZXMucmVtb3ZlRWxlbWVudChwKTsgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuZGVhZFBhcnRpY2xlcy5jbGVhcigpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUGFydGljbGVFbWl0dGVySW1wbC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICAgICAgICAgICAgLy8gdG9kbyBpcyB0aGVyZSBhIG1vcmUgZWZmaWNpZW50IHRvIGRyYXcgXHJcbiAgICAgICAgICAgIC8vIHBvc3NpYmx5IHVzZSBhIHdlYmdsIG9mZnNjcmVlbiBjYW52YXMgYW5kIHNoYWRlcnMgdG8gZG8gcGFydGljbGVzP1xyXG4gICAgICAgICAgICB0aGlzLnBhcnRpY2xlcy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLmRyYXcoY3R4KTsgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQYXJ0aWNsZUVtaXR0ZXJJbXBsLnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGVidWdEcmF3LmNhbGwodGhpcywgY3R4KTtcclxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IENvbG9yXzE0LkNvbG9yLkJsYWNrLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dCgnUGFydGljbGVzOiAnICsgdGhpcy5wYXJ0aWNsZXMuY291bnQoKSwgdGhpcy5wb3MueCwgdGhpcy5wb3MueSArIDIwKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZm9jdXMpIHtcclxuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCh0aGlzLmZvY3VzLnggKyB0aGlzLnBvcy54LCB0aGlzLmZvY3VzLnkgKyB0aGlzLnBvcy55LCAzLCAzKTtcclxuICAgICAgICAgICAgICAgIERyYXdVdGlsLmxpbmUoY3R4LCBDb2xvcl8xNC5Db2xvci5ZZWxsb3csIHRoaXMuZm9jdXMueCArIHRoaXMucG9zLngsIHRoaXMuZm9jdXMueSArIHRoaXMucG9zLnksIF9zdXBlci5wcm90b3R5cGUuZ2V0Q2VudGVyLmNhbGwodGhpcykueCwgX3N1cGVyLnByb3RvdHlwZS5nZXRDZW50ZXIuY2FsbCh0aGlzKS55KTtcclxuICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dCgnRm9jdXMnLCB0aGlzLmZvY3VzLnggKyB0aGlzLnBvcy54LCB0aGlzLmZvY3VzLnkgKyB0aGlzLnBvcy55KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFBhcnRpY2xlRW1pdHRlckltcGw7XHJcbiAgICB9KEFjdG9yXzcuQWN0b3IpKTtcclxuICAgIGV4cG9ydHMuUGFydGljbGVFbWl0dGVySW1wbCA9IFBhcnRpY2xlRW1pdHRlckltcGw7XHJcbiAgICAvKipcclxuICAgICAqIFVzaW5nIGEgcGFydGljbGUgZW1pdHRlciBpcyBhIGdyZWF0IHdheSB0byBjcmVhdGUgaW50ZXJlc3RpbmcgZWZmZWN0c1xyXG4gICAgICogaW4geW91ciBnYW1lLCBsaWtlIHNtb2tlLCBmaXJlLCB3YXRlciwgZXhwbG9zaW9ucywgZXRjLiBgUGFydGljbGVFbWl0dGVyYFxyXG4gICAgICogZXh0ZW5kIFtbQWN0b3JdXSBhbGxvd2luZyB5b3UgdG8gdXNlIGFsbCBvZiB0aGUgZmVhdHVyZXMgdGhhdCBjb21lIHdpdGguXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOlBhcnRpY2xlcy5tZF1dXHJcbiAgICAgKi9cclxuICAgIHZhciBQYXJ0aWNsZUVtaXR0ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhQYXJ0aWNsZUVtaXR0ZXIsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gUGFydGljbGVFbWl0dGVyKHhPckNvbmZpZywgeSwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgeE9yQ29uZmlnLCB5LCB3aWR0aCwgaGVpZ2h0KSB8fCB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUGFydGljbGVFbWl0dGVyO1xyXG4gICAgfShDb25maWd1cmFibGVfNS5Db25maWd1cmFibGUoUGFydGljbGVFbWl0dGVySW1wbCkpKTtcclxuICAgIGV4cG9ydHMuUGFydGljbGVFbWl0dGVyID0gUGFydGljbGVFbWl0dGVyO1xyXG59KTtcclxuZGVmaW5lKFwiVGlsZU1hcFwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkNvbGxpc2lvbi9Cb3VuZGluZ0JveFwiLCBcIkRyYXdpbmcvQ29sb3JcIiwgXCJDbGFzc1wiLCBcIkFsZ2VicmFcIiwgXCJVdGlsL0xvZ1wiLCBcIkV2ZW50c1wiLCBcIkNvbmZpZ3VyYWJsZVwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIEJvdW5kaW5nQm94XzQsIENvbG9yXzE1LCBDbGFzc180LCBBbGdlYnJhXzE2LCBMb2dfNywgRXZlbnRzLCBDb25maWd1cmFibGVfNikge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEBoaWRkZW5cclxuICAgICAqL1xyXG4gICAgdmFyIFRpbGVNYXBJbXBsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoVGlsZU1hcEltcGwsIF9zdXBlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHggICAgICAgICAgICAgVGhlIHggY29vcmRpbmF0ZSB0byBhbmNob3IgdGhlIFRpbGVNYXAncyB1cHBlciBsZWZ0IGNvcm5lciAoc2hvdWxkIG5vdCBiZSBjaGFuZ2VkIG9uY2Ugc2V0KVxyXG4gICAgICAgICAqIEBwYXJhbSB5ICAgICAgICAgICAgIFRoZSB5IGNvb3JkaW5hdGUgdG8gYW5jaG9yIHRoZSBUaWxlTWFwJ3MgdXBwZXIgbGVmdCBjb3JuZXIgKHNob3VsZCBub3QgYmUgY2hhbmdlZCBvbmNlIHNldClcclxuICAgICAgICAgKiBAcGFyYW0gY2VsbFdpZHRoICAgICBUaGUgaW5kaXZpZHVhbCB3aWR0aCBvZiBlYWNoIGNlbGwgKGluIHBpeGVscykgKHNob3VsZCBub3QgYmUgY2hhbmdlZCBvbmNlIHNldClcclxuICAgICAgICAgKiBAcGFyYW0gY2VsbEhlaWdodCAgICBUaGUgaW5kaXZpZHVhbCBoZWlnaHQgb2YgZWFjaCBjZWxsIChpbiBwaXhlbHMpIChzaG91bGQgbm90IGJlIGNoYW5nZWQgb25jZSBzZXQpXHJcbiAgICAgICAgICogQHBhcmFtIHJvd3MgICAgICAgICAgVGhlIG51bWJlciBvZiByb3dzIGluIHRoZSBUaWxlTWFwIChzaG91bGQgbm90IGJlIGNoYW5nZWQgb25jZSBzZXQpXHJcbiAgICAgICAgICogQHBhcmFtIGNvbHMgICAgICAgICAgVGhlIG51bWJlciBvZiBjb2xzIGluIHRoZSBUaWxlTWFwIChzaG91bGQgbm90IGJlIGNoYW5nZWQgb25jZSBzZXQpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gVGlsZU1hcEltcGwoeE9yQ29uZmlnLCB5LCBjZWxsV2lkdGgsIGNlbGxIZWlnaHQsIHJvd3MsIGNvbHMpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuX2NvbGxpZGluZ1ggPSAtMTtcclxuICAgICAgICAgICAgX3RoaXMuX2NvbGxpZGluZ1kgPSAtMTtcclxuICAgICAgICAgICAgX3RoaXMuX29uU2NyZWVuWFN0YXJ0ID0gMDtcclxuICAgICAgICAgICAgX3RoaXMuX29uU2NyZWVuWEVuZCA9IDk5OTk7XHJcbiAgICAgICAgICAgIF90aGlzLl9vblNjcmVlbllTdGFydCA9IDA7XHJcbiAgICAgICAgICAgIF90aGlzLl9vblNjcmVlbllFbmQgPSA5OTk5O1xyXG4gICAgICAgICAgICBfdGhpcy5fc3ByaXRlU2hlZXRzID0ge307XHJcbiAgICAgICAgICAgIF90aGlzLmxvZ2dlciA9IExvZ183LkxvZ2dlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgICAgICBfdGhpcy5kYXRhID0gW107XHJcbiAgICAgICAgICAgIGlmICh4T3JDb25maWcgJiYgdHlwZW9mIHhPckNvbmZpZyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb25maWcgPSB4T3JDb25maWc7XHJcbiAgICAgICAgICAgICAgICB4T3JDb25maWcgPSBjb25maWcueDtcclxuICAgICAgICAgICAgICAgIHkgPSBjb25maWcueTtcclxuICAgICAgICAgICAgICAgIGNlbGxXaWR0aCA9IGNvbmZpZy5jZWxsV2lkdGg7XHJcbiAgICAgICAgICAgICAgICBjZWxsSGVpZ2h0ID0gY29uZmlnLmNlbGxIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICByb3dzID0gY29uZmlnLnJvd3M7XHJcbiAgICAgICAgICAgICAgICBjb2xzID0gY29uZmlnLmNvbHM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMuZGF0YSA9IG5ldyBBcnJheShyb3dzICogY29scyk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJvd3M7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjZCA9IG5ldyBDZWxsKGkgKiBjZWxsV2lkdGggKyB4T3JDb25maWcsIGogKiBjZWxsSGVpZ2h0ICsgeSwgY2VsbFdpZHRoLCBjZWxsSGVpZ2h0LCBpICsgaiAqIGNvbHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5kYXRhW2kgKyBqICogY29sc10gPSBjZDtcclxuICAgICAgICAgICAgICAgICAgICB9KSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgVGlsZU1hcEltcGwucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFRpbGVNYXBJbXBsLnByb3RvdHlwZS5yZWdpc3RlclNwcml0ZVNoZWV0ID0gZnVuY3Rpb24gKGtleSwgc3ByaXRlU2hlZXQpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3ByaXRlU2hlZXRzW2tleV0gPSBzcHJpdGVTaGVldDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIGludGVyc2VjdGlvbiB2ZWN0b3IgdGhhdCBjYW4gYmUgdXNlZCB0byByZXNvbHZlIGNvbGxpc2lvbnMgd2l0aCBhY3RvcnMuIElmIHRoZXJlXHJcbiAgICAgICAgICogaXMgbm8gY29sbGlzaW9uIG51bGwgaXMgcmV0dXJuZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVGlsZU1hcEltcGwucHJvdG90eXBlLmNvbGxpZGVzID0gZnVuY3Rpb24gKGFjdG9yKSB7XHJcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGFjdG9yLnBvcy54ICsgYWN0b3IuZ2V0V2lkdGgoKTtcclxuICAgICAgICAgICAgdmFyIGhlaWdodCA9IGFjdG9yLnBvcy55ICsgYWN0b3IuZ2V0SGVpZ2h0KCk7XHJcbiAgICAgICAgICAgIHZhciBhY3RvckJvdW5kcyA9IGFjdG9yLmdldEJvdW5kcygpO1xyXG4gICAgICAgICAgICB2YXIgb3ZlcmxhcHMgPSBbXTtcclxuICAgICAgICAgICAgLy8gdHJhY2UgcG9pbnRzIGZvciBvdmVybGFwXHJcbiAgICAgICAgICAgIGZvciAodmFyIHggPSBhY3RvckJvdW5kcy5sZWZ0OyB4IDw9IHdpZHRoOyB4ICs9IE1hdGgubWluKGFjdG9yLmdldFdpZHRoKCkgLyAyLCB0aGlzLmNlbGxXaWR0aCAvIDIpKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gYWN0b3JCb3VuZHMudG9wOyB5IDw9IGhlaWdodDsgeSArPSBNYXRoLm1pbihhY3Rvci5nZXRIZWlnaHQoKSAvIDIsIHRoaXMuY2VsbEhlaWdodCAvIDIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNlbGwgPSB0aGlzLmdldENlbGxCeVBvaW50KHgsIHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjZWxsICYmIGNlbGwuc29saWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG92ZXJsYXAgPSBhY3RvckJvdW5kcy5jb2xsaWRlcyhjZWxsLmdldEJvdW5kcygpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpciA9IGFjdG9yLmdldENlbnRlcigpLnN1YihjZWxsLmdldENlbnRlcigpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJsYXAgJiYgb3ZlcmxhcC5kb3QoZGlyKSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXBzLnB1c2gob3ZlcmxhcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG92ZXJsYXBzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBzbWFsbGVzdCBjaGFuZ2Ugb3RoZXIgdGhhbiB6ZXJvXHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBvdmVybGFwcy5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtLCBuZXh0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IGFjY3VtLng7XHJcbiAgICAgICAgICAgICAgICB2YXIgeSA9IGFjY3VtLnk7XHJcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoYWNjdW0ueCkgPCBNYXRoLmFicyhuZXh0LngpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IG5leHQueDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhhY2N1bS55KSA8IE1hdGguYWJzKG5leHQueSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB5ID0gbmV4dC55O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBbGdlYnJhXzE2LlZlY3Rvcih4LCB5KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBbW0NlbGxdXSBieSBpbmRleCAocm93IG1ham9yIG9yZGVyKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRpbGVNYXBJbXBsLnByb3RvdHlwZS5nZXRDZWxsQnlJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhW2luZGV4XTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIFtbQ2VsbF1dIGJ5IGl0cyB4IGFuZCB5IGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVGlsZU1hcEltcGwucHJvdG90eXBlLmdldENlbGwgPSBmdW5jdGlvbiAoeCwgeSkge1xyXG4gICAgICAgICAgICBpZiAoeCA8IDAgfHwgeSA8IDAgfHwgeCA+PSB0aGlzLmNvbHMgfHwgeSA+PSB0aGlzLnJvd3MpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFbeCArIHkgKiB0aGlzLmNvbHNdO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgW1tDZWxsXV0gYnkgdGVzdGluZyBhIHBvaW50IGluIGdsb2JhbCBjb29yZGluYXRlcyxcclxuICAgICAgICAgKiByZXR1cm5zIGBudWxsYCBpZiBubyBjZWxsIHdhcyBmb3VuZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBUaWxlTWFwSW1wbC5wcm90b3R5cGUuZ2V0Q2VsbEJ5UG9pbnQgPSBmdW5jdGlvbiAoeCwgeSkge1xyXG4gICAgICAgICAgICB4ID0gTWF0aC5mbG9vcigoeCAtIHRoaXMueCkgLyB0aGlzLmNlbGxXaWR0aCk7XHJcbiAgICAgICAgICAgIHkgPSBNYXRoLmZsb29yKCh5IC0gdGhpcy55KSAvIHRoaXMuY2VsbEhlaWdodCk7XHJcbiAgICAgICAgICAgIHZhciBjZWxsID0gdGhpcy5nZXRDZWxsKHgsIHkpO1xyXG4gICAgICAgICAgICBpZiAoeCA+PSAwICYmIHkgPj0gMCAmJiB4IDwgdGhpcy5jb2xzICYmIHkgPCB0aGlzLnJvd3MgJiYgY2VsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNlbGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBUaWxlTWFwSW1wbC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGVuZ2luZSwgZGVsdGEpIHtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdwcmV1cGRhdGUnLCBuZXcgRXZlbnRzLlByZVVwZGF0ZUV2ZW50KGVuZ2luZSwgZGVsdGEsIHRoaXMpKTtcclxuICAgICAgICAgICAgdmFyIHdvcmxkQ29vcmRzVXBwZXJMZWZ0ID0gZW5naW5lLnNjcmVlblRvV29ybGRDb29yZGluYXRlcyhuZXcgQWxnZWJyYV8xNi5WZWN0b3IoMCwgMCkpO1xyXG4gICAgICAgICAgICB2YXIgd29ybGRDb29yZHNMb3dlclJpZ2h0ID0gZW5naW5lLnNjcmVlblRvV29ybGRDb29yZGluYXRlcyhuZXcgQWxnZWJyYV8xNi5WZWN0b3IoZW5naW5lLmNhbnZhcy5jbGllbnRXaWR0aCwgZW5naW5lLmNhbnZhcy5jbGllbnRIZWlnaHQpKTtcclxuICAgICAgICAgICAgdGhpcy5fb25TY3JlZW5YU3RhcnQgPSBNYXRoLm1heChNYXRoLmZsb29yKHdvcmxkQ29vcmRzVXBwZXJMZWZ0LnggLyB0aGlzLmNlbGxXaWR0aCkgLSAyLCAwKTtcclxuICAgICAgICAgICAgdGhpcy5fb25TY3JlZW5ZU3RhcnQgPSBNYXRoLm1heChNYXRoLmZsb29yKCh3b3JsZENvb3Jkc1VwcGVyTGVmdC55IC0gdGhpcy55KSAvIHRoaXMuY2VsbEhlaWdodCkgLSAyLCAwKTtcclxuICAgICAgICAgICAgdGhpcy5fb25TY3JlZW5YRW5kID0gTWF0aC5tYXgoTWF0aC5mbG9vcih3b3JsZENvb3Jkc0xvd2VyUmlnaHQueCAvIHRoaXMuY2VsbFdpZHRoKSArIDIsIDApO1xyXG4gICAgICAgICAgICB0aGlzLl9vblNjcmVlbllFbmQgPSBNYXRoLm1heChNYXRoLmZsb29yKCh3b3JsZENvb3Jkc0xvd2VyUmlnaHQueSAtIHRoaXMueSkgLyB0aGlzLmNlbGxIZWlnaHQpICsgMiwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncG9zdHVwZGF0ZScsIG5ldyBFdmVudHMuUG9zdFVwZGF0ZUV2ZW50KGVuZ2luZSwgZGVsdGEsIHRoaXMpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERyYXdzIHRoZSB0aWxlIG1hcCB0byB0aGUgc2NyZWVuLiBDYWxsZWQgYnkgdGhlIFtbU2NlbmVdXS5cclxuICAgICAgICAgKiBAcGFyYW0gY3R4ICAgIFRoZSBjdXJyZW50IHJlbmRlcmluZyBjb250ZXh0XHJcbiAgICAgICAgICogQHBhcmFtIGRlbHRhICBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgbGFzdCBkcmF3XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVGlsZU1hcEltcGwucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoY3R4LCBkZWx0YSkge1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3ByZWRyYXcnLCBuZXcgRXZlbnRzLlByZURyYXdFdmVudChjdHgsIGRlbHRhLCB0aGlzKSk7XHJcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUodGhpcy54LCB0aGlzLnkpO1xyXG4gICAgICAgICAgICB2YXIgeCA9IHRoaXMuX29uU2NyZWVuWFN0YXJ0LCB4RW5kID0gTWF0aC5taW4odGhpcy5fb25TY3JlZW5YRW5kLCB0aGlzLmNvbHMpO1xyXG4gICAgICAgICAgICB2YXIgeSA9IHRoaXMuX29uU2NyZWVuWVN0YXJ0LCB5RW5kID0gTWF0aC5taW4odGhpcy5fb25TY3JlZW5ZRW5kLCB0aGlzLnJvd3MpO1xyXG4gICAgICAgICAgICB2YXIgY3MsIGNzaSwgY3NsZW47XHJcbiAgICAgICAgICAgIGZvciAoeDsgeCA8IHhFbmQ7IHgrKykge1xyXG4gICAgICAgICAgICAgICAgZm9yICh5OyB5IDwgeUVuZDsgeSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IG5vbi1uZWdhdGl2ZSB0aWxlIHNwcml0ZXNcclxuICAgICAgICAgICAgICAgICAgICBjcyA9IHRoaXMuZ2V0Q2VsbCh4LCB5KS5zcHJpdGVzLmZpbHRlcihmdW5jdGlvbiAocykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcy5zcHJpdGVJZCA+IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY3NpID0gMCwgY3NsZW4gPSBjcy5sZW5ndGg7IGNzaSA8IGNzbGVuOyBjc2krKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3MgPSB0aGlzLl9zcHJpdGVTaGVldHNbY3NbY3NpXS5zcHJpdGVTaGVldEtleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRyYXcgc3ByaXRlLCB3YXJuaW5nIGlmIHNwcml0ZSBkb2Vzbid0IGV4aXN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNwcml0ZSA9IHNzLmdldFNwcml0ZShjc1tjc2ldLnNwcml0ZUlkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcHJpdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUuZHJhdyhjdHgsIHggKiB0aGlzLmNlbGxXaWR0aCwgeSAqIHRoaXMuY2VsbEhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdTcHJpdGUgZG9lcyBub3QgZXhpc3QgZm9yIGlkJywgY3NbY3NpXS5zcHJpdGVJZCwgJ2luIHNwcml0ZSBzaGVldCcsIGNzW2NzaV0uc3ByaXRlU2hlZXRLZXksIHNwcml0ZSwgc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybignU3ByaXRlIHNoZWV0JywgY3NbY3NpXS5zcHJpdGVTaGVldEtleSwgJ2RvZXMgbm90IGV4aXN0Jywgc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgeSA9IHRoaXMuX29uU2NyZWVuWVN0YXJ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncG9zdGRyYXcnLCBuZXcgRXZlbnRzLlBvc3REcmF3RXZlbnQoY3R4LCBkZWx0YSwgdGhpcykpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRHJhd3MgYWxsIHRoZSB0aWxlIG1hcCdzIGRlYnVnIGluZm8uIENhbGxlZCBieSB0aGUgW1tTY2VuZV1dLlxyXG4gICAgICAgICAqIEBwYXJhbSBjdHggIFRoZSBjdXJyZW50IHJlbmRlcmluZyBjb250ZXh0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVGlsZU1hcEltcGwucHJvdG90eXBlLmRlYnVnRHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5jb2xzICogdGhpcy5jZWxsV2lkdGg7XHJcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLnJvd3MgKiB0aGlzLmNlbGxIZWlnaHQ7XHJcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IENvbG9yXzE1LkNvbG9yLlJlZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHRoaXMuY29scyArIDE7IHgrKykge1xyXG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh0aGlzLnggKyB4ICogdGhpcy5jZWxsV2lkdGgsIHRoaXMueSk7XHJcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHRoaXMueCArIHggKiB0aGlzLmNlbGxXaWR0aCwgdGhpcy55ICsgaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IHRoaXMucm93cyArIDE7IHkrKykge1xyXG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh0aGlzLngsIHRoaXMueSArIHkgKiB0aGlzLmNlbGxIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh0aGlzLnggKyB3aWR0aCwgdGhpcy55ICsgeSAqIHRoaXMuY2VsbEhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHNvbGlkID0gQ29sb3JfMTUuQ29sb3IuUmVkLmNsb25lKCk7XHJcbiAgICAgICAgICAgIHNvbGlkLmEgPSAuMztcclxuICAgICAgICAgICAgdGhpcy5kYXRhLmZpbHRlcihmdW5jdGlvbiAoY2VsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNlbGwuc29saWQ7XHJcbiAgICAgICAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGNlbGwpIHtcclxuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBzb2xpZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KGNlbGwueCwgY2VsbC55LCBjZWxsLndpZHRoLCBjZWxsLmhlaWdodCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fY29sbGlkaW5nWSA+IC0xICYmIHRoaXMuX2NvbGxpZGluZ1ggPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IENvbG9yXzE1LkNvbG9yLkN5YW4udG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCh0aGlzLnggKyB0aGlzLl9jb2xsaWRpbmdYICogdGhpcy5jZWxsV2lkdGgsIHRoaXMueSArIHRoaXMuX2NvbGxpZGluZ1kgKiB0aGlzLmNlbGxIZWlnaHQsIHRoaXMuY2VsbFdpZHRoLCB0aGlzLmNlbGxIZWlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gVGlsZU1hcEltcGw7XHJcbiAgICB9KENsYXNzXzQuQ2xhc3MpKTtcclxuICAgIGV4cG9ydHMuVGlsZU1hcEltcGwgPSBUaWxlTWFwSW1wbDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIFtbVGlsZU1hcF1dIGNsYXNzIHByb3ZpZGVzIGEgbGlnaHR3ZWlnaHQgd2F5IHRvIGRvIGxhcmdlIGNvbXBsZXggc2NlbmVzIHdpdGggY29sbGlzaW9uXHJcbiAgICAgKiB3aXRob3V0IHRoZSBvdmVyaGVhZCBvZiBhY3RvcnMuXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOlRpbGVNYXBzLm1kXV1cclxuICAgICAqL1xyXG4gICAgdmFyIFRpbGVNYXAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhUaWxlTWFwLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFRpbGVNYXAoeE9yQ29uZmlnLCB5LCBjZWxsV2lkdGgsIGNlbGxIZWlnaHQsIHJvd3MsIGNvbHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHhPckNvbmZpZywgeSwgY2VsbFdpZHRoLCBjZWxsSGVpZ2h0LCByb3dzLCBjb2xzKSB8fCB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gVGlsZU1hcDtcclxuICAgIH0oQ29uZmlndXJhYmxlXzYuQ29uZmlndXJhYmxlKFRpbGVNYXBJbXBsKSkpO1xyXG4gICAgZXhwb3J0cy5UaWxlTWFwID0gVGlsZU1hcDtcclxuICAgIC8qKlxyXG4gICAgICogVGlsZSBzcHJpdGVzIGFyZSB1c2VkIHRvIHJlbmRlciBhIHNwZWNpZmljIHNwcml0ZSBmcm9tIGEgW1tUaWxlTWFwXV0ncyBzcHJpdGVzaGVldChzKVxyXG4gICAgICovXHJcbiAgICB2YXIgVGlsZVNwcml0ZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHNwcml0ZVNoZWV0S2V5ICBUaGUga2V5IG9mIHRoZSBzcHJpdGVzaGVldCB0byB1c2VcclxuICAgICAgICAgKiBAcGFyYW0gc3ByaXRlSWQgICAgICAgIFRoZSBpbmRleCBvZiB0aGUgc3ByaXRlIGluIHRoZSBbW1Nwcml0ZVNoZWV0XV1cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBUaWxlU3ByaXRlKHNwcml0ZVNoZWV0S2V5LCBzcHJpdGVJZCkge1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZVNoZWV0S2V5ID0gc3ByaXRlU2hlZXRLZXk7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlSWQgPSBzcHJpdGVJZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFRpbGVTcHJpdGU7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5UaWxlU3ByaXRlID0gVGlsZVNwcml0ZTtcclxuICAgIC8qKlxyXG4gICAgICogQGhpZGRlblxyXG4gICAgICovXHJcbiAgICB2YXIgQ2VsbEltcGwgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB4ICAgICAgIEdldHMgb3Igc2V0cyB4IGNvb3JkaW5hdGUgb2YgdGhlIGNlbGwgaW4gd29ybGQgY29vcmRpbmF0ZXNcclxuICAgICAgICAgKiBAcGFyYW0geSAgICAgICBHZXRzIG9yIHNldHMgeSBjb29yZGluYXRlIG9mIHRoZSBjZWxsIGluIHdvcmxkIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICogQHBhcmFtIHdpZHRoICAgR2V0cyBvciBzZXRzIHRoZSB3aWR0aCBvZiB0aGUgY2VsbFxyXG4gICAgICAgICAqIEBwYXJhbSBoZWlnaHQgIEdldHMgb3Igc2V0cyB0aGUgaGVpZ2h0IG9mIHRoZSBjZWxsXHJcbiAgICAgICAgICogQHBhcmFtIGluZGV4ICAgVGhlIGluZGV4IG9mIHRoZSBjZWxsIGluIHJvdyBtYWpvciBvcmRlclxyXG4gICAgICAgICAqIEBwYXJhbSBzb2xpZCAgIEdldHMgb3Igc2V0cyB3aGV0aGVyIHRoaXMgY2VsbCBpcyBzb2xpZFxyXG4gICAgICAgICAqIEBwYXJhbSBzcHJpdGVzIFRoZSBsaXN0IG9mIHRpbGUgc3ByaXRlcyB0byB1c2UgdG8gZHJhdyBpbiB0aGlzIGNlbGwgKGluIG9yZGVyKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIENlbGxJbXBsKHhPckNvbmZpZywgeSwgd2lkdGgsIGhlaWdodCwgaW5kZXgsIHNvbGlkLCBzcHJpdGVzKSB7XHJcbiAgICAgICAgICAgIGlmIChzb2xpZCA9PT0gdm9pZCAwKSB7IHNvbGlkID0gZmFsc2U7IH1cclxuICAgICAgICAgICAgaWYgKHNwcml0ZXMgPT09IHZvaWQgMCkgeyBzcHJpdGVzID0gW107IH1cclxuICAgICAgICAgICAgdGhpcy5zb2xpZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZXMgPSBbXTtcclxuICAgICAgICAgICAgaWYgKHhPckNvbmZpZyAmJiB0eXBlb2YgeE9yQ29uZmlnID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbmZpZyA9IHhPckNvbmZpZztcclxuICAgICAgICAgICAgICAgIHhPckNvbmZpZyA9IGNvbmZpZy54O1xyXG4gICAgICAgICAgICAgICAgeSA9IGNvbmZpZy55O1xyXG4gICAgICAgICAgICAgICAgd2lkdGggPSBjb25maWcud2lkdGg7XHJcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBjb25maWcuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgaW5kZXggPSBjb25maWcuaW5kZXg7XHJcbiAgICAgICAgICAgICAgICBzb2xpZCA9IGNvbmZpZy5zb2xpZDtcclxuICAgICAgICAgICAgICAgIHNwcml0ZXMgPSBjb25maWcuc3ByaXRlcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnggPSB4T3JDb25maWc7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcclxuICAgICAgICAgICAgdGhpcy5zb2xpZCA9IHNvbGlkO1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZXMgPSBzcHJpdGVzO1xyXG4gICAgICAgICAgICB0aGlzLl9ib3VuZHMgPSBuZXcgQm91bmRpbmdCb3hfNC5Cb3VuZGluZ0JveCh0aGlzLngsIHRoaXMueSwgdGhpcy54ICsgdGhpcy53aWR0aCwgdGhpcy55ICsgdGhpcy5oZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBib3VuZGluZyBib3ggZm9yIHRoaXMgY2VsbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENlbGxJbXBsLnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ib3VuZHM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBjZW50ZXIgY29vcmRpbmF0ZSBvZiB0aGlzIGNlbGxcclxuICAgICAgICAgKi9cclxuICAgICAgICBDZWxsSW1wbC5wcm90b3R5cGUuZ2V0Q2VudGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFsZ2VicmFfMTYuVmVjdG9yKHRoaXMueCArIHRoaXMud2lkdGggLyAyLCB0aGlzLnkgKyB0aGlzLmhlaWdodCAvIDIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkIGFub3RoZXIgW1tUaWxlU3ByaXRlXV0gdG8gdGhpcyBjZWxsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2VsbEltcGwucHJvdG90eXBlLnB1c2hTcHJpdGUgPSBmdW5jdGlvbiAodGlsZVNwcml0ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZXMucHVzaCh0aWxlU3ByaXRlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZSBhbiBpbnN0YW5jZSBvZiBbW1RpbGVTcHJpdGVdXSBmcm9tIHRoaXMgY2VsbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENlbGxJbXBsLnByb3RvdHlwZS5yZW1vdmVTcHJpdGUgPSBmdW5jdGlvbiAodGlsZVNwcml0ZSkge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSAtMTtcclxuICAgICAgICAgICAgaWYgKChpbmRleCA9IHRoaXMuc3ByaXRlcy5pbmRleE9mKHRpbGVTcHJpdGUpKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZXMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2xlYXIgYWxsIHNwcml0ZXMgZnJvbSB0aGlzIGNlbGxcclxuICAgICAgICAgKi9cclxuICAgICAgICBDZWxsSW1wbC5wcm90b3R5cGUuY2xlYXJTcHJpdGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZXMubGVuZ3RoID0gMDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBDZWxsSW1wbDtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkNlbGxJbXBsID0gQ2VsbEltcGw7XHJcbiAgICAvKipcclxuICAgICAqIFRpbGVNYXAgQ2VsbFxyXG4gICAgICpcclxuICAgICAqIEEgbGlnaHQtd2VpZ2h0IG9iamVjdCB0aGF0IG9jY3VwaWVzIGEgc3BhY2UgaW4gYSBjb2xsaXNpb24gbWFwLiBHZW5lcmFsbHlcclxuICAgICAqIGNyZWF0ZWQgYnkgYSBbW1RpbGVNYXBdXS5cclxuICAgICAqXHJcbiAgICAgKiBDZWxscyBjYW4gZHJhdyBtdWx0aXBsZSBzcHJpdGVzLiBOb3RlIHRoYXQgdGhlIG9yZGVyIG9mIGRyYXdpbmcgaXMgdGhlIG9yZGVyXHJcbiAgICAgKiBvZiB0aGUgc3ByaXRlcyBpbiB0aGUgYXJyYXkgc28gdGhlIGxhc3Qgb25lIHdpbGwgYmUgZHJhd24gb24gdG9wLiBZb3UgY2FuXHJcbiAgICAgKiB1c2UgdHJhbnNwYXJlbmN5IHRvIGNyZWF0ZSBsYXllcnMgdGhpcyB3YXkuXHJcbiAgICAgKi9cclxuICAgIHZhciBDZWxsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoQ2VsbCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBDZWxsKHhPckNvbmZpZywgeSwgd2lkdGgsIGhlaWdodCwgaW5kZXgsIHNvbGlkLCBzcHJpdGVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB4T3JDb25maWcsIHksIHdpZHRoLCBoZWlnaHQsIGluZGV4LCBzb2xpZCwgc3ByaXRlcykgfHwgdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIENlbGw7XHJcbiAgICB9KENvbmZpZ3VyYWJsZV82LkNvbmZpZ3VyYWJsZShDZWxsSW1wbCkpKTtcclxuICAgIGV4cG9ydHMuQ2VsbCA9IENlbGw7XHJcbn0pO1xyXG5kZWZpbmUoXCJUaW1lclwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgRXhjYWxpYnVyIHRpbWVyIGhvb2tzIGludG8gdGhlIGludGVybmFsIHRpbWVyIGFuZCBmaXJlcyBjYWxsYmFja3MsXHJcbiAgICAgKiBhZnRlciBhIGNlcnRhaW4gaW50ZXJ2YWwsIG9wdGlvbmFsbHkgcmVwZWF0aW5nLlxyXG4gICAgICovXHJcbiAgICB2YXIgVGltZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBmY24gICAgICAgIFRoZSBjYWxsYmFjayB0byBiZSBmaXJlZCBhZnRlciB0aGUgaW50ZXJ2YWwgaXMgY29tcGxldGUuXHJcbiAgICAgICAgICogQHBhcmFtIGludGVydmFsICAgSW50ZXJ2YWwgbGVuZ3RoXHJcbiAgICAgICAgICogQHBhcmFtIHJlcGVhdHMgICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBjYWxsIGJhY2sgc2hvdWxkIGJlIGZpcmVkIG9ubHkgb25jZSwgb3IgcmVwZWF0IGFmdGVyIGV2ZXJ5IGludGVydmFsIGFzIGNvbXBsZXRlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBUaW1lcihmY24sIGludGVydmFsLCByZXBlYXRzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaWQgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmludGVydmFsID0gMTA7XHJcbiAgICAgICAgICAgIHRoaXMuZmNuID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XHJcbiAgICAgICAgICAgIHRoaXMucmVwZWF0cyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9lbGFwc2VkVGltZSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3RvdGFsVGltZUFsaXZlID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5zY2VuZSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuaWQgPSBUaW1lci5pZCsrO1xyXG4gICAgICAgICAgICB0aGlzLmludGVydmFsID0gaW50ZXJ2YWwgfHwgdGhpcy5pbnRlcnZhbDtcclxuICAgICAgICAgICAgdGhpcy5mY24gPSBmY24gfHwgdGhpcy5mY247XHJcbiAgICAgICAgICAgIHRoaXMucmVwZWF0cyA9IHJlcGVhdHMgfHwgdGhpcy5yZXBlYXRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGVzIHRoZSB0aW1lciBhZnRlciBhIGNlcnRhaW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQuIFRoaXMgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBlbmdpbmUuXHJcbiAgICAgICAgICogQHBhcmFtIGRlbHRhICBOdW1iZXIgb2YgZWxhcHNlZCBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGxhc3QgdXBkYXRlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRpbWVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9wYXVzZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RvdGFsVGltZUFsaXZlICs9IGRlbHRhO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZWxhcHNlZFRpbWUgKz0gZGVsdGE7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29tcGxldGUgJiYgdGhpcy5fZWxhcHNlZFRpbWUgPj0gdGhpcy5pbnRlcnZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmNuLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVwZWF0cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbGFwc2VkVGltZSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlc2V0cyB0aGUgdGltZXIgc28gdGhhdCBpdCBjYW4gYmUgcmV1c2VkLCBhbmQgb3B0aW9uYWxseSByZWNvbmZpZ3VyZSB0aGUgdGltZXJzIGludGVydmFsLlxyXG4gICAgICAgICAqIEBwYXJhbSBuZXdJbnRlcnZhbCBJZiBzcGVjaWZpZWQsIHNldHMgYSBuZXcgbm9uLW5lZ2F0aXZlIGludGVydmFsIGluIG1pbGxpc2Vjb25kcyB0byByZWZpcmUgdGhlIGNhbGxiYWNrXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVGltZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKG5ld0ludGVydmFsKSB7XHJcbiAgICAgICAgICAgIGlmICghIW5ld0ludGVydmFsICYmIG5ld0ludGVydmFsID49IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWwgPSBuZXdJbnRlcnZhbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2VsYXBzZWRUaW1lID0gMDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFRpbWVyLnByb3RvdHlwZS5nZXRUaW1lUnVubmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RvdGFsVGltZUFsaXZlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGF1c2VzIHRoZSB0aW1lciBzbyB0aGF0IG5vIG1vcmUgdGltZSB3aWxsIGJlIGluY3JlbWVudGVkIHRvd2FyZHMgdGhlIG5leHQgY2FsbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRpbWVyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVucGF1c2VzIHRoZSB0aW1lci4gVGltZSB3aWxsIG5vdyBpbmNyZW1lbnQgdG93YXJkcyB0aGUgbmV4dCBjYWxsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVGltZXIucHJvdG90eXBlLnVucGF1c2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FuY2VscyB0aGUgdGltZXIsIHByZXZlbnRpbmcgYW55IGZ1cnRoZXIgZXhlY3V0aW9ucy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBUaW1lci5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zY2VuZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZS5jYW5jZWxUaW1lcih0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFRpbWVyO1xyXG4gICAgfSgpKTtcclxuICAgIFRpbWVyLmlkID0gMDtcclxuICAgIGV4cG9ydHMuVGltZXIgPSBUaW1lcjtcclxufSk7XHJcbmRlZmluZShcIlRyaWdnZXJcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJEcmF3aW5nL0NvbG9yXCIsIFwiQWN0aW9ucy9BY3Rpb25cIiwgXCJFdmVudERpc3BhdGNoZXJcIiwgXCJBY3RvclwiLCBcIkFsZ2VicmFcIiwgXCJFdmVudHNcIiwgXCJVdGlsL1V0aWxcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBDb2xvcl8xNiwgQWN0aW9uXzEsIEV2ZW50RGlzcGF0Y2hlcl8xLCBBY3Rvcl84LCBBbGdlYnJhXzE3LCBFdmVudHNfNSwgVXRpbCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICB2YXIgdHJpZ2dlckRlZmF1bHRzID0ge1xyXG4gICAgICAgIHBvczogQWxnZWJyYV8xNy5WZWN0b3IuWmVyby5jbG9uZSgpLFxyXG4gICAgICAgIHdpZHRoOiAxMCxcclxuICAgICAgICBoZWlnaHQ6IDEwLFxyXG4gICAgICAgIHZpc2libGU6IGZhbHNlLFxyXG4gICAgICAgIGFjdGlvbjogZnVuY3Rpb24gKCkgeyByZXR1cm47IH0sXHJcbiAgICAgICAgZmlsdGVyOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9LFxyXG4gICAgICAgIHJlcGVhdDogLTFcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFRyaWdnZXJzIGFyZSBhIG1ldGhvZCBvZiBmaXJpbmcgYXJiaXRyYXJ5IGNvZGUgb24gY29sbGlzaW9uLiBUaGVzZSBhcmUgdXNlZnVsXHJcbiAgICAgKiBhcyAnYnV0dG9ucycsICdzd2l0Y2hlcycsIG9yIHRvIHRyaWdnZXIgZWZmZWN0cyBpbiBhIGdhbWUuIEJ5IGRlZmF1bHQgdHJpZ2dlcnNcclxuICAgICAqIGFyZSBpbnZpc2libGUsIGFuZCBjYW4gb25seSBiZSBzZWVuIHdoZW4gW1tUcmlnZ2VyLnZpc2libGVdXSBpcyBzZXQgdG8gYHRydWVgLlxyXG4gICAgICpcclxuICAgICAqIFtbaW5jbHVkZTpUcmlnZ2Vycy5tZF1dXHJcbiAgICAgKi9cclxuICAgIHZhciBUcmlnZ2VyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoVHJpZ2dlciwgX3N1cGVyKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBvcHRzIFRyaWdnZXIgb3B0aW9uc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIFRyaWdnZXIob3B0cykge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRzLnBvcy54LCBvcHRzLnBvcy55LCBvcHRzLndpZHRoLCBvcHRzLmhlaWdodCkgfHwgdGhpcztcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFjdGlvbiB0byBmaXJlIHdoZW4gdHJpZ2dlcmVkIGJ5IGNvbGxpc2lvblxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuYWN0aW9uID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBGaWx0ZXIgdG8gYWRkIGFkZGl0aW9uYWwgZ3JhbnVsYXJpdHkgdG8gYWN0aW9uIGRpc3BhdGNoLCBpZiBhIGZpbHRlciBpcyBzcGVjaWZpZWQgdGhlIGFjdGlvbiB3aWxsIG9ubHkgZmlyZSB3aGVuXHJcbiAgICAgICAgICAgICAqIGZpbHRlciByZXR1cm4gdHJ1ZSBmb3IgdGhlIGNvbGxpZGVkIGFjdG9yLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuZmlsdGVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE51bWJlciBvZiB0aW1lcyB0byByZXBlYXQgYmVmb3JlIGtpbGxpbmcgdGhlIHRyaWdnZXIsXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5yZXBlYXQgPSAtMTtcclxuICAgICAgICAgICAgb3B0cyA9IFV0aWwuZXh0ZW5kKHt9LCB0cmlnZ2VyRGVmYXVsdHMsIG9wdHMpO1xyXG4gICAgICAgICAgICBfdGhpcy5maWx0ZXIgPSBvcHRzLmZpbHRlciB8fCBfdGhpcy5maWx0ZXI7XHJcbiAgICAgICAgICAgIF90aGlzLnJlcGVhdCA9IG9wdHMucmVwZWF0IHx8IF90aGlzLnJlcGVhdDtcclxuICAgICAgICAgICAgX3RoaXMuYWN0aW9uID0gb3B0cy5hY3Rpb24gfHwgX3RoaXMuYWN0aW9uO1xyXG4gICAgICAgICAgICBpZiAob3B0cy50YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnRhcmdldCA9IG9wdHMudGFyZ2V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzLnZpc2libGUgPSBvcHRzLnZpc2libGU7XHJcbiAgICAgICAgICAgIF90aGlzLmNvbGxpc2lvblR5cGUgPSBBY3Rvcl84LkNvbGxpc2lvblR5cGUuUGFzc2l2ZTtcclxuICAgICAgICAgICAgX3RoaXMuZXZlbnREaXNwYXRjaGVyID0gbmV3IEV2ZW50RGlzcGF0Y2hlcl8xLkV2ZW50RGlzcGF0Y2hlcihfdGhpcyk7XHJcbiAgICAgICAgICAgIF90aGlzLmFjdGlvblF1ZXVlID0gbmV3IEFjdGlvbl8xLkFjdGlvblF1ZXVlKF90aGlzKTtcclxuICAgICAgICAgICAgX3RoaXMub24oJ2NvbGxpc2lvbnN0YXJ0JywgZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmZpbHRlcihldnQub3RoZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgnZW50ZXInLCBuZXcgRXZlbnRzXzUuRW50ZXJUcmlnZ2VyRXZlbnQoX3RoaXMsIGV2dC5vdGhlcikpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9kaXNwYXRjaEFjdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0cmlnZ2VyIGlmIGl0cyBkb25lLCAtMSByZXBlYXQgZm9yZXZlclxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5yZXBlYXQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMua2lsbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIF90aGlzLm9uKCdjb2xsaXNpb25lbmQnLCBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZmlsdGVyKGV2dC5vdGhlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KCdleGl0JywgbmV3IEV2ZW50c181LkV4aXRUcmlnZ2VyRXZlbnQoX3RoaXMsIGV2dC5vdGhlcikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHJpZ2dlci5wcm90b3R5cGUsIFwidGFyZ2V0XCIsIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyID0gZnVuY3Rpb24gKGFjdG9yKSB7IHJldHVybiBhY3RvciA9PT0gdGFyZ2V0OyB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBUcmlnZ2VyLnByb3RvdHlwZS5faW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChlbmdpbmUpIHtcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5faW5pdGlhbGl6ZS5jYWxsKHRoaXMsIGVuZ2luZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBUcmlnZ2VyLnByb3RvdHlwZS5fZGlzcGF0Y2hBY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMucmVwZWF0LS07XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIFRyaWdnZXIucHJvdG90eXBlLmRlYnVnRHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kZWJ1Z0RyYXcuY2FsbCh0aGlzLCBjdHgpO1xyXG4gICAgICAgICAgICAvLyBNZWFudCB0byBkcmF3IGRlYnVnIGluZm9ybWF0aW9uIGFib3V0IGFjdG9yc1xyXG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKHRoaXMucG9zLngsIHRoaXMucG9zLnkpO1xyXG4gICAgICAgICAgICB2YXIgYmIgPSB0aGlzLmdldEJvdW5kcygpO1xyXG4gICAgICAgICAgICB2YXIgd3AgPSB0aGlzLmdldFdvcmxkUG9zKCk7XHJcbiAgICAgICAgICAgIGJiLmxlZnQgPSBiYi5sZWZ0IC0gd3AueDtcclxuICAgICAgICAgICAgYmIucmlnaHQgPSBiYi5yaWdodCAtIHdwLng7XHJcbiAgICAgICAgICAgIGJiLnRvcCA9IGJiLnRvcCAtIHdwLnk7XHJcbiAgICAgICAgICAgIGJiLmJvdHRvbSA9IGJiLmJvdHRvbSAtIHdwLnk7XHJcbiAgICAgICAgICAgIC8vIEN1cnJlbnRseSBjb2xsaXNpb24gcHJpbWl0aXZlcyBjYW5ub3Qgcm90YXRlIFxyXG4gICAgICAgICAgICAvLyBjdHgucm90YXRlKHRoaXMucm90YXRpb24pO1xyXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gQ29sb3JfMTYuQ29sb3IuVmlvbGV0LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IENvbG9yXzE2LkNvbG9yLlZpb2xldC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBjdHguZmlsbFRleHQoJ1RyaWdnZXInLCAxMCwgMTApO1xyXG4gICAgICAgICAgICBiYi5kZWJ1Z0RyYXcoY3R4KTtcclxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBUcmlnZ2VyO1xyXG4gICAgfShBY3Rvcl84LkFjdG9yKSk7XHJcbiAgICBleHBvcnRzLlRyaWdnZXIgPSBUcmlnZ2VyO1xyXG59KTtcclxuZGVmaW5lKFwiQWN0aW9ucy9JbmRleFwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkFjdGlvbnMvQWN0aW9uQ29udGV4dFwiLCBcIkFjdGlvbnMvUm90YXRpb25UeXBlXCIsIFwiQWN0aW9ucy9BY3Rpb25cIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBBY3Rpb25Db250ZXh0XzIsIFJvdGF0aW9uVHlwZV8xLCBhY3Rpb25zKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIGZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcclxuICAgICAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICBfX2V4cG9ydChBY3Rpb25Db250ZXh0XzIpO1xyXG4gICAgX19leHBvcnQoUm90YXRpb25UeXBlXzEpO1xyXG4gICAgZXhwb3J0cy5BY3Rpb25zID0gYWN0aW9ucztcclxuICAgIC8vIGxlZ2FjeSBJbnRlcm5hbC5BY3Rpb25zIG5hbWVzcGFjZSBzdXBwb3J0XHJcbiAgICBleHBvcnRzLkludGVybmFsID0geyBBY3Rpb25zOiBhY3Rpb25zIH07XHJcbn0pO1xyXG5kZWZpbmUoXCJDb2xsaXNpb24vRHluYW1pY1RyZWVcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJQaHlzaWNzXCIsIFwiQ29sbGlzaW9uL0JvdW5kaW5nQm94XCIsIFwiVXRpbC9Mb2dcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBQaHlzaWNzXzgsIEJvdW5kaW5nQm94XzUsIExvZ184KSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogRHluYW1pYyBUcmVlIE5vZGUgdXNlZCBmb3IgdHJhY2tpbmcgYm91bmRzIHdpdGhpbiB0aGUgdHJlZVxyXG4gICAgICovXHJcbiAgICB2YXIgVHJlZU5vZGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIFRyZWVOb2RlKHBhcmVudCkge1xyXG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQgfHwgbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5ib2R5ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5ib3VuZHMgPSBuZXcgQm91bmRpbmdCb3hfNS5Cb3VuZGluZ0JveCgpO1xyXG4gICAgICAgICAgICB0aGlzLmxlZnQgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLnJpZ2h0ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBUcmVlTm9kZS5wcm90b3R5cGUuaXNMZWFmID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKCF0aGlzLmxlZnQgJiYgIXRoaXMucmlnaHQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFRyZWVOb2RlO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuVHJlZU5vZGUgPSBUcmVlTm9kZTtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIER5bmFtaWNUcmVlcyBwcm92aWRlcyBhIHNwYXRpYWwgcGFydGlpb25pbmcgZGF0YSBzdHJ1Y3R1cmUgZm9yIHF1aWNrbHkgcXVlcnlpbmcgZm9yIG92ZXJsYXBwaW5nIGJvdW5kaW5nIGJveGVzIGZvclxyXG4gICAgICogYWxsIHRyYWNrZWQgYm9kaWVzLiBUaGUgd29yc3QgY2FzZSBwZXJmb3JtYW5jZSBvZiB0aGlzIGlzIE8obipsb2cobikpIHdoZXJlIG4gaXMgdGhlIG51bWJlciBvZiBib2RpZXMgaW4gdGhlIHRyZWUuXHJcbiAgICAgKlxyXG4gICAgICogSW50ZXJuYWxseSB0aGUgYm91bmRpbmcgYm94ZXMgYXJlIG9yZ2FuaXplZCBhcyBhIGJhbGFuY2VkIGJpbmFyeSB0cmVlIG9mIGJvdW5kaW5nIGJveGVzLCB3aGVyZSB0aGUgbGVhZiBub2RlcyBhcmUgdHJhY2tlZCBib2RpZXMuXHJcbiAgICAgKiBFdmVyeSBub24tbGVhZiBub2RlIGlzIGEgYm91bmRpbmcgYm94IHRoYXQgY29udGFpbnMgY2hpbGQgYm91bmRpbmcgYm94ZXMuXHJcbiAgICAgKi9cclxuICAgIHZhciBEeW5hbWljVHJlZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gRHluYW1pY1RyZWUod29ybGRCb3VuZHMpIHtcclxuICAgICAgICAgICAgaWYgKHdvcmxkQm91bmRzID09PSB2b2lkIDApIHsgd29ybGRCb3VuZHMgPSBuZXcgQm91bmRpbmdCb3hfNS5Cb3VuZGluZ0JveCgtTnVtYmVyLk1BWF9WQUxVRSwgLU51bWJlci5NQVhfVkFMVUUsIE51bWJlci5NQVhfVkFMVUUsIE51bWJlci5NQVhfVkFMVUUpOyB9XHJcbiAgICAgICAgICAgIHRoaXMud29ybGRCb3VuZHMgPSB3b3JsZEJvdW5kcztcclxuICAgICAgICAgICAgdGhpcy5yb290ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5ub2RlcyA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbnNlcnRzIGEgbm9kZSBpbnRvIHRoZSBkeW5hbWljIHRyZWVcclxuICAgICAgICAgKi9cclxuICAgICAgICBEeW5hbWljVHJlZS5wcm90b3R5cGUuX2luc2VydCA9IGZ1bmN0aW9uIChsZWFmKSB7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBub2RlcyBpbiB0aGUgdHJlZSwgbWFrZSB0aGlzIHRoZSByb290IGxlYWZcclxuICAgICAgICAgICAgaWYgKHRoaXMucm9vdCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yb290ID0gbGVhZjtcclxuICAgICAgICAgICAgICAgIHRoaXMucm9vdC5wYXJlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFNlYXJjaCB0aGUgdHJlZSBmb3IgYSBub2RlIHRoYXQgaXMgbm90IGEgbGVhZiBhbmQgZmluZCB0aGUgYmVzdCBwbGFjZSB0byBpbnNlcnRcclxuICAgICAgICAgICAgdmFyIGxlYWZBQUJCID0gbGVhZi5ib3VuZHM7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50Um9vdCA9IHRoaXMucm9vdDtcclxuICAgICAgICAgICAgd2hpbGUgKCFjdXJyZW50Um9vdC5pc0xlYWYoKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxlZnQgPSBjdXJyZW50Um9vdC5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgdmFyIHJpZ2h0ID0gY3VycmVudFJvb3QucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJlYSA9IGN1cnJlbnRSb290LmJvdW5kcy5nZXRQZXJpbWV0ZXIoKTtcclxuICAgICAgICAgICAgICAgIHZhciBjb21iaW5lZEFBQkIgPSBjdXJyZW50Um9vdC5ib3VuZHMuY29tYmluZShsZWFmQUFCQik7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29tYmluZWRBcmVhID0gY29tYmluZWRBQUJCLmdldFBlcmltZXRlcigpO1xyXG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGNvc3QgaGV1cmlzdGljIGZvciBjcmVhdGluZyBhIG5ldyBwYXJlbnQgYW5kIGxlYWZcclxuICAgICAgICAgICAgICAgIHZhciBjb3N0ID0gMiAqIGNvbWJpbmVkQXJlYTtcclxuICAgICAgICAgICAgICAgIC8vIE1pbmltdW0gY29zdCBvZiBwdXNoaW5nIHRoZSBsZWFmIGRvd24gdGhlIHRyZWVcclxuICAgICAgICAgICAgICAgIHZhciBpbmhlcml0YW5jZUNvc3QgPSAyICogKGNvbWJpbmVkQXJlYSAtIGFyZWEpO1xyXG4gICAgICAgICAgICAgICAgLy8gQ29zdCBvZiBkZXNjZW5kaW5nXHJcbiAgICAgICAgICAgICAgICB2YXIgbGVmdENvc3QgPSAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIGxlZnRDb21iaW5lZCA9IGxlYWZBQUJCLmNvbWJpbmUobGVmdC5ib3VuZHMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld0FyZWE7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2xkQXJlYTtcclxuICAgICAgICAgICAgICAgIGlmIChsZWZ0LmlzTGVhZigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdENvc3QgPSBsZWZ0Q29tYmluZWQuZ2V0UGVyaW1ldGVyKCkgKyBpbmhlcml0YW5jZUNvc3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvbGRBcmVhID0gbGVmdC5ib3VuZHMuZ2V0UGVyaW1ldGVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3QXJlYSA9IGxlZnRDb21iaW5lZC5nZXRQZXJpbWV0ZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0Q29zdCA9IChuZXdBcmVhIC0gb2xkQXJlYSkgKyBpbmhlcml0YW5jZUNvc3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgcmlnaHRDb3N0ID0gMDtcclxuICAgICAgICAgICAgICAgIHZhciByaWdodENvbWJpbmVkID0gbGVhZkFBQkIuY29tYmluZShyaWdodC5ib3VuZHMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0LmlzTGVhZigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRDb3N0ID0gcmlnaHRDb21iaW5lZC5nZXRQZXJpbWV0ZXIoKSArIGluaGVyaXRhbmNlQ29zdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG9sZEFyZWEgPSByaWdodC5ib3VuZHMuZ2V0UGVyaW1ldGVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3QXJlYSA9IHJpZ2h0Q29tYmluZWQuZ2V0UGVyaW1ldGVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRDb3N0ID0gKG5ld0FyZWEgLSBvbGRBcmVhKSArIGluaGVyaXRhbmNlQ29zdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGNvc3QgaXMgYWNjZXB0YWJsZVxyXG4gICAgICAgICAgICAgICAgaWYgKGNvc3QgPCBsZWZ0Q29zdCAmJiBjb3N0IDwgcmlnaHRDb3N0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBEZXNjZW5kIHRvIHRoZSBkZXB0aHNcclxuICAgICAgICAgICAgICAgIGlmIChsZWZ0Q29zdCA8IHJpZ2h0Q29zdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSb290ID0gbGVmdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSb290ID0gcmlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBuZXcgcGFyZW50IG5vZGUgYW5kIGluc2VydCBpbnRvIHRoZSB0cmVlXHJcbiAgICAgICAgICAgIHZhciBvbGRQYXJlbnQgPSBjdXJyZW50Um9vdC5wYXJlbnQ7XHJcbiAgICAgICAgICAgIHZhciBuZXdQYXJlbnQgPSBuZXcgVHJlZU5vZGUob2xkUGFyZW50KTtcclxuICAgICAgICAgICAgbmV3UGFyZW50LmJvdW5kcyA9IGxlYWZBQUJCLmNvbWJpbmUoY3VycmVudFJvb3QuYm91bmRzKTtcclxuICAgICAgICAgICAgbmV3UGFyZW50LmhlaWdodCA9IGN1cnJlbnRSb290LmhlaWdodCArIDE7XHJcbiAgICAgICAgICAgIGlmIChvbGRQYXJlbnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBzaWJsaW5nIG5vZGUgd2FzIG5vdCB0aGUgcm9vdFxyXG4gICAgICAgICAgICAgICAgaWYgKG9sZFBhcmVudC5sZWZ0ID09PSBjdXJyZW50Um9vdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9sZFBhcmVudC5sZWZ0ID0gbmV3UGFyZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2xkUGFyZW50LnJpZ2h0ID0gbmV3UGFyZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbmV3UGFyZW50LmxlZnQgPSBjdXJyZW50Um9vdDtcclxuICAgICAgICAgICAgICAgIG5ld1BhcmVudC5yaWdodCA9IGxlYWY7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Um9vdC5wYXJlbnQgPSBuZXdQYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICBsZWFmLnBhcmVudCA9IG5ld1BhcmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBzaWJsaW5nIG5vZGUgd2FzIHRoZSByb290XHJcbiAgICAgICAgICAgICAgICBuZXdQYXJlbnQubGVmdCA9IGN1cnJlbnRSb290O1xyXG4gICAgICAgICAgICAgICAgbmV3UGFyZW50LnJpZ2h0ID0gbGVhZjtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRSb290LnBhcmVudCA9IG5ld1BhcmVudDtcclxuICAgICAgICAgICAgICAgIGxlYWYucGFyZW50ID0gbmV3UGFyZW50O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yb290ID0gbmV3UGFyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFdhbGsgdXAgdGhlIHRyZWUgZml4aW5nIGhlaWdodHMgYW5kIEFBQkJzXHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50Tm9kZSA9IGxlYWYucGFyZW50O1xyXG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlID0gdGhpcy5fYmFsYW5jZShjdXJyZW50Tm9kZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnROb2RlLmxlZnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmVudCBvZiBjdXJyZW50IGxlYWYgY2Fubm90IGhhdmUgYSBudWxsIGxlZnQgY2hpbGQnICsgY3VycmVudE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50Tm9kZS5yaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGFyZW50IG9mIGN1cnJlbnQgbGVhZiBjYW5ub3QgaGF2ZSBhIG51bGwgcmlnaHQgY2hpbGQnICsgY3VycmVudE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGUuaGVpZ2h0ID0gMSArIE1hdGgubWF4KGN1cnJlbnROb2RlLmxlZnQuaGVpZ2h0LCBjdXJyZW50Tm9kZS5yaWdodC5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGUuYm91bmRzID0gY3VycmVudE5vZGUubGVmdC5ib3VuZHMuY29tYmluZShjdXJyZW50Tm9kZS5yaWdodC5ib3VuZHMpO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgYSBub2RlIGZyb20gdGhlIGR5bmFtaWMgdHJlZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIER5bmFtaWNUcmVlLnByb3RvdHlwZS5fcmVtb3ZlID0gZnVuY3Rpb24gKGxlYWYpIHtcclxuICAgICAgICAgICAgaWYgKGxlYWYgPT09IHRoaXMucm9vdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yb290ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gbGVhZi5wYXJlbnQ7XHJcbiAgICAgICAgICAgIHZhciBncmFuZFBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XHJcbiAgICAgICAgICAgIHZhciBzaWJsaW5nO1xyXG4gICAgICAgICAgICBpZiAocGFyZW50LmxlZnQgPT09IGxlYWYpIHtcclxuICAgICAgICAgICAgICAgIHNpYmxpbmcgPSBwYXJlbnQucmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzaWJsaW5nID0gcGFyZW50LmxlZnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGdyYW5kUGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ3JhbmRQYXJlbnQubGVmdCA9PT0gcGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JhbmRQYXJlbnQubGVmdCA9IHNpYmxpbmc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBncmFuZFBhcmVudC5yaWdodCA9IHNpYmxpbmc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzaWJsaW5nLnBhcmVudCA9IGdyYW5kUGFyZW50O1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnROb2RlID0gZ3JhbmRQYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoY3VycmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZSA9IHRoaXMuX2JhbGFuY2UoY3VycmVudE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLmJvdW5kcyA9IGN1cnJlbnROb2RlLmxlZnQuYm91bmRzLmNvbWJpbmUoY3VycmVudE5vZGUucmlnaHQuYm91bmRzKTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5oZWlnaHQgPSAxICsgTWF0aC5tYXgoY3VycmVudE5vZGUubGVmdC5oZWlnaHQsIGN1cnJlbnROb2RlLnJpZ2h0LmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3QgPSBzaWJsaW5nO1xyXG4gICAgICAgICAgICAgICAgc2libGluZy5wYXJlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUcmFja3MgYSBib2R5IGluIHRoZSBkeW5hbWljIHRyZWVcclxuICAgICAgICAgKi9cclxuICAgICAgICBEeW5hbWljVHJlZS5wcm90b3R5cGUudHJhY2tCb2R5ID0gZnVuY3Rpb24gKGJvZHkpIHtcclxuICAgICAgICAgICAgdmFyIG5vZGUgPSBuZXcgVHJlZU5vZGUoKTtcclxuICAgICAgICAgICAgbm9kZS5ib2R5ID0gYm9keTtcclxuICAgICAgICAgICAgbm9kZS5ib3VuZHMgPSBib2R5LmdldEJvdW5kcygpO1xyXG4gICAgICAgICAgICBub2RlLmJvdW5kcy5sZWZ0IC09IDI7XHJcbiAgICAgICAgICAgIG5vZGUuYm91bmRzLnRvcCAtPSAyO1xyXG4gICAgICAgICAgICBub2RlLmJvdW5kcy5yaWdodCArPSAyO1xyXG4gICAgICAgICAgICBub2RlLmJvdW5kcy5ib3R0b20gKz0gMjtcclxuICAgICAgICAgICAgdGhpcy5ub2Rlc1tib2R5LmFjdG9yLmlkXSA9IG5vZGU7XHJcbiAgICAgICAgICAgIHRoaXMuX2luc2VydChub2RlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwZGF0ZXMgdGhlIGR5bmFtaWMgdHJlZSBnaXZlbiB0aGUgY3VycmVudCBib3VuZHMgb2YgZWFjaCBib2R5IGJlaW5nIHRyYWNrZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBEeW5hbWljVHJlZS5wcm90b3R5cGUudXBkYXRlQm9keSA9IGZ1bmN0aW9uIChib2R5KSB7XHJcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ub2Rlc1tib2R5LmFjdG9yLmlkXTtcclxuICAgICAgICAgICAgaWYgKCFub2RlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGIgPSBib2R5LmdldEJvdW5kcygpO1xyXG4gICAgICAgICAgICAvLyBpZiB0aGUgYm9keSBpcyBvdXRzaWRlIHRoZSB3b3JsZCBubyBsb25nZXIgdXBkYXRlIGl0XHJcbiAgICAgICAgICAgIGlmICghdGhpcy53b3JsZEJvdW5kcy5jb250YWlucyhiKSkge1xyXG4gICAgICAgICAgICAgICAgTG9nXzguTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybignQWN0b3Igd2l0aCBpZCAnICsgYm9keS5hY3Rvci5pZCArXHJcbiAgICAgICAgICAgICAgICAgICAgJyBpcyBvdXRzaWRlIHRoZSB3b3JsZCBib3VuZHMgYW5kIHdpbGwgbm8gbG9uZ2VyIGJlIHRyYWNrZWQgZm9yIHBoeXNpY3MnKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudW50cmFja0JvZHkoYm9keSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5vZGUuYm91bmRzLmNvbnRhaW5zKGIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlKG5vZGUpO1xyXG4gICAgICAgICAgICBiLmxlZnQgLT0gUGh5c2ljc184LlBoeXNpY3MuYm91bmRzUGFkZGluZztcclxuICAgICAgICAgICAgYi50b3AgLT0gUGh5c2ljc184LlBoeXNpY3MuYm91bmRzUGFkZGluZztcclxuICAgICAgICAgICAgYi5yaWdodCArPSBQaHlzaWNzXzguUGh5c2ljcy5ib3VuZHNQYWRkaW5nO1xyXG4gICAgICAgICAgICBiLmJvdHRvbSArPSBQaHlzaWNzXzguUGh5c2ljcy5ib3VuZHNQYWRkaW5nO1xyXG4gICAgICAgICAgICB2YXIgbXVsdGR4ID0gYm9keS52ZWwueCAqIFBoeXNpY3NfOC5QaHlzaWNzLmR5bmFtaWNUcmVlVmVsb2NpdHlNdWx0aXBseWVyO1xyXG4gICAgICAgICAgICB2YXIgbXVsdGR5ID0gYm9keS52ZWwueSAqIFBoeXNpY3NfOC5QaHlzaWNzLmR5bmFtaWNUcmVlVmVsb2NpdHlNdWx0aXBseWVyO1xyXG4gICAgICAgICAgICBpZiAobXVsdGR4IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgYi5sZWZ0ICs9IG11bHRkeDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGIucmlnaHQgKz0gbXVsdGR4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtdWx0ZHkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBiLnRvcCArPSBtdWx0ZHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBiLmJvdHRvbSArPSBtdWx0ZHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbm9kZS5ib3VuZHMgPSBiO1xyXG4gICAgICAgICAgICB0aGlzLl9pbnNlcnQobm9kZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVW50cmFja3MgYSBib2R5IGZyb20gdGhlIGR5bmFtaWMgdHJlZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIER5bmFtaWNUcmVlLnByb3RvdHlwZS51bnRyYWNrQm9keSA9IGZ1bmN0aW9uIChib2R5KSB7XHJcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ub2Rlc1tib2R5LmFjdG9yLmlkXTtcclxuICAgICAgICAgICAgaWYgKCFub2RlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlKG5vZGUpO1xyXG4gICAgICAgICAgICB0aGlzLm5vZGVzW2JvZHkuYWN0b3IuaWRdID0gbnVsbDtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMubm9kZXNbYm9keS5hY3Rvci5pZF07XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCYWxhbmNlcyB0aGUgdHJlZSBhYm91dCBhIG5vZGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBEeW5hbWljVHJlZS5wcm90b3R5cGUuX2JhbGFuY2UgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICBpZiAobm9kZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYmFsYW5jZSBhdCBudWxsIG5vZGUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobm9kZS5pc0xlYWYoKSB8fCBub2RlLmhlaWdodCA8IDIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gbm9kZS5sZWZ0O1xyXG4gICAgICAgICAgICB2YXIgcmlnaHQgPSBub2RlLnJpZ2h0O1xyXG4gICAgICAgICAgICB2YXIgYSA9IG5vZGU7XHJcbiAgICAgICAgICAgIHZhciBiID0gbGVmdDtcclxuICAgICAgICAgICAgdmFyIGMgPSByaWdodDtcclxuICAgICAgICAgICAgdmFyIGQgPSBsZWZ0LmxlZnQ7XHJcbiAgICAgICAgICAgIHZhciBlID0gbGVmdC5yaWdodDtcclxuICAgICAgICAgICAgdmFyIGYgPSByaWdodC5sZWZ0O1xyXG4gICAgICAgICAgICB2YXIgZyA9IHJpZ2h0LnJpZ2h0O1xyXG4gICAgICAgICAgICB2YXIgYmFsYW5jZSA9IGMuaGVpZ2h0IC0gYi5oZWlnaHQ7XHJcbiAgICAgICAgICAgIC8vIFJvdGF0ZSBjIG5vZGUgdXBcclxuICAgICAgICAgICAgaWYgKGJhbGFuY2UgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTd2FwIHRoZSByaWdodCBub2RlIHdpdGggaXQncyBwYXJlbnRcclxuICAgICAgICAgICAgICAgIGMubGVmdCA9IGE7XHJcbiAgICAgICAgICAgICAgICBjLnBhcmVudCA9IGEucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgYS5wYXJlbnQgPSBjO1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIG9yaWdpbmFsIG5vZGUncyBvbGQgcGFyZW50IHNob3VsZCBwb2ludCB0byB0aGUgcmlnaHQgbm9kZVxyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBtZWdhIGNvbmZ1c2luZ1xyXG4gICAgICAgICAgICAgICAgaWYgKGMucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMucGFyZW50LmxlZnQgPT09IGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYy5wYXJlbnQubGVmdCA9IGM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjLnBhcmVudC5yaWdodCA9IGM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290ID0gYztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFJvdGF0ZVxyXG4gICAgICAgICAgICAgICAgaWYgKGYuaGVpZ2h0ID4gZy5oZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjLnJpZ2h0ID0gZjtcclxuICAgICAgICAgICAgICAgICAgICBhLnJpZ2h0ID0gZztcclxuICAgICAgICAgICAgICAgICAgICBnLnBhcmVudCA9IGE7XHJcbiAgICAgICAgICAgICAgICAgICAgYS5ib3VuZHMgPSBiLmJvdW5kcy5jb21iaW5lKGcuYm91bmRzKTtcclxuICAgICAgICAgICAgICAgICAgICBjLmJvdW5kcyA9IGEuYm91bmRzLmNvbWJpbmUoZi5ib3VuZHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGEuaGVpZ2h0ID0gMSArIE1hdGgubWF4KGIuaGVpZ2h0LCBnLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYy5oZWlnaHQgPSAxICsgTWF0aC5tYXgoYS5oZWlnaHQsIGYuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGMucmlnaHQgPSBnO1xyXG4gICAgICAgICAgICAgICAgICAgIGEucmlnaHQgPSBmO1xyXG4gICAgICAgICAgICAgICAgICAgIGYucGFyZW50ID0gYTtcclxuICAgICAgICAgICAgICAgICAgICBhLmJvdW5kcyA9IGIuYm91bmRzLmNvbWJpbmUoZi5ib3VuZHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGMuYm91bmRzID0gYS5ib3VuZHMuY29tYmluZShnLmJvdW5kcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYS5oZWlnaHQgPSAxICsgTWF0aC5tYXgoYi5oZWlnaHQsIGYuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICBjLmhlaWdodCA9IDEgKyBNYXRoLm1heChhLmhlaWdodCwgZy5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUm90YXRlIGxlZnQgbm9kZSB1cFxyXG4gICAgICAgICAgICBpZiAoYmFsYW5jZSA8IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzd2FwXHJcbiAgICAgICAgICAgICAgICBiLmxlZnQgPSBhO1xyXG4gICAgICAgICAgICAgICAgYi5wYXJlbnQgPSBhLnBhcmVudDtcclxuICAgICAgICAgICAgICAgIGEucGFyZW50ID0gYjtcclxuICAgICAgICAgICAgICAgIC8vIG5vZGUncyBvbGQgcGFyZW50IHNob3VsZCBwb2ludCB0byBiXHJcbiAgICAgICAgICAgICAgICBpZiAoYi5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYi5wYXJlbnQubGVmdCA9PT0gYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiLnBhcmVudC5sZWZ0ID0gYjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiLnBhcmVudC5yaWdodCAhPT0gYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ0Vycm9yIHJvdGF0aW5nIER5bmFtaWMgVHJlZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYi5wYXJlbnQucmlnaHQgPSBiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm9vdCA9IGI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyByb3RhdGVcclxuICAgICAgICAgICAgICAgIGlmIChkLmhlaWdodCA+IGUuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYi5yaWdodCA9IGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgYS5sZWZ0ID0gZTtcclxuICAgICAgICAgICAgICAgICAgICBlLnBhcmVudCA9IGE7XHJcbiAgICAgICAgICAgICAgICAgICAgYS5ib3VuZHMgPSBjLmJvdW5kcy5jb21iaW5lKGUuYm91bmRzKTtcclxuICAgICAgICAgICAgICAgICAgICBiLmJvdW5kcyA9IGEuYm91bmRzLmNvbWJpbmUoZC5ib3VuZHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGEuaGVpZ2h0ID0gMSArIE1hdGgubWF4KGMuaGVpZ2h0LCBlLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYi5oZWlnaHQgPSAxICsgTWF0aC5tYXgoYS5oZWlnaHQsIGQuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGIucmlnaHQgPSBlO1xyXG4gICAgICAgICAgICAgICAgICAgIGEubGVmdCA9IGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZC5wYXJlbnQgPSBhO1xyXG4gICAgICAgICAgICAgICAgICAgIGEuYm91bmRzID0gYy5ib3VuZHMuY29tYmluZShkLmJvdW5kcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYi5ib3VuZHMgPSBhLmJvdW5kcy5jb21iaW5lKGUuYm91bmRzKTtcclxuICAgICAgICAgICAgICAgICAgICBhLmhlaWdodCA9IDEgKyBNYXRoLm1heChjLmhlaWdodCwgZC5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGIuaGVpZ2h0ID0gMSArIE1hdGgubWF4KGEuaGVpZ2h0LCBlLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIGludGVybmFsIGhlaWdodCBvZiB0aGUgdHJlZSwgc2hvcnRlciB0cmVlcyBhcmUgYmV0dGVyLiBQZXJmb3JtYW5jZSBkcm9wcyBhcyB0aGUgdHJlZSBncm93c1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIER5bmFtaWNUcmVlLnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJvb3QgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvb3QuaGVpZ2h0O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUXVlcmllcyB0aGUgRHluYW1pYyBBeGlzIEFsaWduZWQgVHJlZSBmb3IgYm9kaWVzIHRoYXQgY291bGQgYmUgY29sbGlkaW5nIHdpdGggdGhlIHByb3ZpZGVkIGJvZHkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBJbiB0aGUgcXVlcnkgY2FsbGJhY2ssIGl0IHdpbGwgYmUgcGFzc2VkIGEgcG90ZW50aWFsIGNvbGxpZGVyLiBSZXR1cm5pbmcgdHJ1ZSBmcm9tIHRoaXMgY2FsbGJhY2sgaW5kaWNhdGVzXHJcbiAgICAgICAgICogdGhhdCB5b3UgYXJlIGNvbXBsZXRlIHdpdGggeW91ciBxdWVyeSBhbmQgeW91IGRvIG5vdCB3YW50IHRvIGNvbnRpbnVlLiBSZXR1cm5pbmcgZmFsc2Ugd2lsbCBjb250aW51ZSBzZWFyY2hpbmdcclxuICAgICAgICAgKiB0aGUgdHJlZSB1bnRpbCBhbGwgcG9zc2libGUgY29sbGlkZXJzIGhhdmUgYmVlbiByZXR1cm5lZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBEeW5hbWljVHJlZS5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbiAoYm9keSwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgdmFyIGJvdW5kcyA9IGJvZHkuZ2V0Qm91bmRzKCk7XHJcbiAgICAgICAgICAgIHZhciBoZWxwZXIgPSBmdW5jdGlvbiAoY3VycmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZSAmJiBjdXJyZW50Tm9kZS5ib3VuZHMuY29sbGlkZXMoYm91bmRzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZS5pc0xlYWYoKSAmJiBjdXJyZW50Tm9kZS5ib2R5ICE9PSBib2R5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjay5jYWxsKGJvZHksIGN1cnJlbnROb2RlLmJvZHkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcihjdXJyZW50Tm9kZS5sZWZ0KSB8fCBoZWxwZXIoY3VycmVudE5vZGUucmlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaGVscGVyKHRoaXMucm9vdCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBRdWVyaWVzIHRoZSBEeW5hbWljIEF4aXMgQWxpZ25lZCBUcmVlIGZvciBib2RpZXMgdGhhdCBjb3VsZCBiZSBpbnRlcnNlY3RpbmcuIEJ5IGRlZmF1bHQgdGhlIHJheWNhc3QgcXVlcnkgdXNlcyBhbiBpbmZpbml0ZWx5XHJcbiAgICAgICAgICogbG9uZyByYXkgdG8gdGVzdCB0aGUgdHJlZSBzcGVjaWZpZWQgYnkgYG1heGAuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBJbiB0aGUgcXVlcnkgY2FsbGJhY2ssIGl0IHdpbGwgYmUgcGFzc2VkIGEgcG90ZW50aWFsIGJvZHkgdGhhdCBpbnRlcnNlY3RzIHdpdGggdGhlIHJhY2FzdC4gUmV0dXJuaW5nIHRydWUgZnJvbSB0aGlzXHJcbiAgICAgICAgICogY2FsbGJhY2sgaW5kaWNhdGVzIHRoYXQgeW91ciBhcmUgY29tcGxldGUgd2l0aCB5b3VyIHF1ZXJ5IGFuZCBkbyBub3Qgd2FudCB0byBjb250aW51ZS4gUmV0dXJuIGZhbHNlIHdpbGwgY29udGludWUgc2VhcmNoaW5nXHJcbiAgICAgICAgICogdGhlIHRyZWUgdW50aWwgYWxsIHBvc3NpYmxlIGJvZGllcyB0aGF0IHdvdWxkIGludGVyc2VjdCB3aXRoIHRoZSByYXkgaGF2ZSBiZWVuIHJldHVybmVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIER5bmFtaWNUcmVlLnByb3RvdHlwZS5yYXlDYXN0UXVlcnkgPSBmdW5jdGlvbiAocmF5LCBtYXgsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGlmIChtYXggPT09IHZvaWQgMCkgeyBtYXggPSBJbmZpbml0eTsgfVxyXG4gICAgICAgICAgICB2YXIgaGVscGVyID0gZnVuY3Rpb24gKGN1cnJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUgJiYgY3VycmVudE5vZGUuYm91bmRzLnJheUNhc3QocmF5LCBtYXgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLmlzTGVhZigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjay5jYWxsKHJheSwgY3VycmVudE5vZGUuYm9keSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJheSBoaXQgYSBsZWFmISByZXR1cm4gdGhlIGJvZHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByYXkgaGl0IGJ1dCBub3QgYXQgYSBsZWFmLCByZWN1cnNlIGRlZXBlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVyKGN1cnJlbnROb2RlLmxlZnQpIHx8IGhlbHBlcihjdXJyZW50Tm9kZS5yaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyByYXkgbWlzc2VkICAgICAgICAgXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGhlbHBlcih0aGlzLnJvb3QpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLmdldE5vZGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgaGVscGVyID0gZnVuY3Rpb24gKGN1cnJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2N1cnJlbnROb2RlXS5jb25jYXQoaGVscGVyKGN1cnJlbnROb2RlLmxlZnQpLCBoZWxwZXIoY3VycmVudE5vZGUucmlnaHQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIGhlbHBlcih0aGlzLnJvb3QpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLmRlYnVnRHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICAgICAgICAgICAgLy8gZHJhdyBhbGwgdGhlIG5vZGVzIGluIHRoZSBEeW5hbWljIFRyZWVcclxuICAgICAgICAgICAgdmFyIGhlbHBlciA9IGZ1bmN0aW9uIChjdXJyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLmlzTGVhZigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnZ3JlZW4nO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICd3aGl0ZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLmJvdW5kcy5kZWJ1Z0RyYXcoY3R4KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUubGVmdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWxwZXIoY3VycmVudE5vZGUubGVmdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZS5yaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWxwZXIoY3VycmVudE5vZGUucmlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaGVscGVyKHRoaXMucm9vdCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gRHluYW1pY1RyZWU7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5EeW5hbWljVHJlZSA9IER5bmFtaWNUcmVlO1xyXG59KTtcclxuZGVmaW5lKFwiQ29sbGlzaW9uL0lDb2xsaXNpb25SZXNvbHZlclwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG59KTtcclxuZGVmaW5lKFwiQ29sbGlzaW9uL0R5bmFtaWNUcmVlQ29sbGlzaW9uQnJvYWRwaGFzZVwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIlBoeXNpY3NcIiwgXCJDb2xsaXNpb24vRHluYW1pY1RyZWVcIiwgXCJDb2xsaXNpb24vUGFpclwiLCBcIkFsZ2VicmFcIiwgXCJBY3RvclwiLCBcIlV0aWwvTG9nXCIsIFwiRXZlbnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgUGh5c2ljc185LCBEeW5hbWljVHJlZV8xLCBQYWlyXzIsIEFsZ2VicmFfMTgsIEFjdG9yXzksIExvZ185LCBFdmVudHNfNikge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICB2YXIgRHluYW1pY1RyZWVDb2xsaXNpb25Ccm9hZHBoYXNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBEeW5hbWljVHJlZUNvbGxpc2lvbkJyb2FkcGhhc2UoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2R5bmFtaWNDb2xsaXNpb25UcmVlID0gbmV3IER5bmFtaWNUcmVlXzEuRHluYW1pY1RyZWUoKTtcclxuICAgICAgICAgICAgdGhpcy5fY29sbGlzaW9uSGFzaCA9IHt9O1xyXG4gICAgICAgICAgICB0aGlzLl9jb2xsaXNpb25QYWlyQ2FjaGUgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5fbGFzdEZyYW1lUGFpcnMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5fbGFzdEZyYW1lUGFpcnNIYXNoID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRyYWNrcyBhIHBoeXNpY3MgYm9keSBmb3IgY29sbGlzaW9uc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIER5bmFtaWNUcmVlQ29sbGlzaW9uQnJvYWRwaGFzZS5wcm90b3R5cGUudHJhY2sgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICBMb2dfOS5Mb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKCdDYW5ub3QgdHJhY2sgbnVsbCBwaHlzaWNzIGJvZHknKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9keW5hbWljQ29sbGlzaW9uVHJlZS50cmFja0JvZHkodGFyZ2V0KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVudHJhY2tzIGEgcGh5c2ljcyBib2R5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHluYW1pY1RyZWVDb2xsaXNpb25Ccm9hZHBoYXNlLnByb3RvdHlwZS51bnRyYWNrID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgICAgICBpZiAoIXRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgTG9nXzkuTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybignQ2Fubm90IHVudHJhY2sgYSBudWxsIHBoeXNpY3MgYm9keScpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2R5bmFtaWNDb2xsaXNpb25UcmVlLnVudHJhY2tCb2R5KHRhcmdldCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBEeW5hbWljVHJlZUNvbGxpc2lvbkJyb2FkcGhhc2UucHJvdG90eXBlLl9jYW5Db2xsaWRlID0gZnVuY3Rpb24gKGFjdG9yQSwgYWN0b3JCKSB7XHJcbiAgICAgICAgICAgIC8vIGlmIHRoZSBjb2xsaXNpb24gcGFpciBoYXMgYmVlbiBjYWxjdWxhdGVkIGFscmVhZHkgc2hvcnQgY2lyY3VpdFxyXG4gICAgICAgICAgICB2YXIgaGFzaCA9IFBhaXJfMi5QYWlyLmNhbGN1bGF0ZVBhaXJIYXNoKGFjdG9yQS5ib2R5LCBhY3RvckIuYm9keSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb2xsaXNpb25IYXNoW2hhc2hdKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIHBhaXIgZXhpc3RzIGVhc3kgZXhpdCByZXR1cm4gZmFsc2VcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpZiBib3RoIGFyZSBmaXhlZCBzaG9ydCBjaXJjdWl0XHJcbiAgICAgICAgICAgIGlmIChhY3RvckEuY29sbGlzaW9uVHlwZSA9PT0gQWN0b3JfOS5Db2xsaXNpb25UeXBlLkZpeGVkICYmIGFjdG9yQi5jb2xsaXNpb25UeXBlID09PSBBY3Rvcl85LkNvbGxpc2lvblR5cGUuRml4ZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpZiB0aGUgb3RoZXIgaXMgcHJldmVudCBjb2xsaXNpb24gb3IgaXMgZGVhZCBzaG9ydCBjaXJjdWl0XHJcbiAgICAgICAgICAgIGlmIChhY3RvckIuY29sbGlzaW9uVHlwZSA9PT0gQWN0b3JfOS5Db2xsaXNpb25UeXBlLlByZXZlbnRDb2xsaXNpb24gfHwgYWN0b3JCLmlzS2lsbGVkKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB0aGV5IGNhbiBjb2xsaWRlXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGV0ZWN0cyBwb3RlbnRpYWwgY29sbGlzaW9uIHBhaXJzIGluIGEgYnJvYWRwaGFzZSBhcHByb2FjaCB3aXRoIHRoZSBkeW5hbWljIGFhYmIgdHJlZSBzdHJhdGVneVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIER5bmFtaWNUcmVlQ29sbGlzaW9uQnJvYWRwaGFzZS5wcm90b3R5cGUuYnJvYWRwaGFzZSA9IGZ1bmN0aW9uICh0YXJnZXRzLCBkZWx0YSwgc3RhdHMpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIHNlY29uZHMgPSBkZWx0YSAvIDEwMDA7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gb3B0aW1pemF0aW9uIHVzZSBvbmx5IHRoZSBhY3RvcnMgdGhhdCBhcmUgbW92aW5nIHRvIHN0YXJ0IFxyXG4gICAgICAgICAgICAvLyBSZXRyaWV2ZSB0aGUgbGlzdCBvZiBwb3RlbnRpYWwgY29sbGlkZXJzLCBleGNsdWRlIGtpbGxlZCwgcHJldmVudGVkLCBhbmQgc2VsZlxyXG4gICAgICAgICAgICB2YXIgcG90ZW50aWFsQ29sbGlkZXJzID0gdGFyZ2V0cy5maWx0ZXIoZnVuY3Rpb24gKG90aGVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gIW90aGVyLmlzS2lsbGVkKCkgJiYgb3RoZXIuY29sbGlzaW9uVHlwZSAhPT0gQWN0b3JfOS5Db2xsaXNpb25UeXBlLlByZXZlbnRDb2xsaXNpb247XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyBjbGVhciBvbGQgbGlzdCBvZiBjb2xsaXNpb24gcGFpcnNcclxuICAgICAgICAgICAgdGhpcy5fY29sbGlzaW9uUGFpckNhY2hlID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbGxpc2lvbkhhc2ggPSB7fTtcclxuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIG5vcm1hbCBjb2xsaXNpb24gcGFpcnNcclxuICAgICAgICAgICAgdmFyIGFjdG9yO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbCA9IHBvdGVudGlhbENvbGxpZGVycy5sZW5ndGg7IGogPCBsOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGFjdG9yID0gcG90ZW50aWFsQ29sbGlkZXJzW2pdO1xyXG4gICAgICAgICAgICAgICAgLy8gUXVlcnkgdGhlIGNvbGxpc2lvbiB0cmVlIGZvciBwb3RlbnRpYWwgY29sbGlkZXJzXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9keW5hbWljQ29sbGlzaW9uVHJlZS5xdWVyeShhY3Rvci5ib2R5LCBmdW5jdGlvbiAob3RoZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2NhbkNvbGxpZGUoYWN0b3IsIG90aGVyLmFjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFpciA9IG5ldyBQYWlyXzIuUGFpcihhY3Rvci5ib2R5LCBvdGhlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9jb2xsaXNpb25IYXNoW3BhaXIuaWRdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2NvbGxpc2lvblBhaXJDYWNoZS5wdXNoKHBhaXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBBbHdheXMgcmV0dXJuIGZhbHNlLCB0byBxdWVyeSB3aG9sZSB0cmVlLiBSZXR1cm5pbmcgdHJ1ZSBpbiB0aGUgcXVlcnkgbWV0aG9kIHN0b3BzIHNlYXJjaGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzdGF0cykge1xyXG4gICAgICAgICAgICAgICAgc3RhdHMucGh5c2ljcy5wYWlycyA9IHRoaXMuX2NvbGxpc2lvblBhaXJDYWNoZS5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQ2hlY2sgZHluYW1pYyB0cmVlIGZvciBmYXN0IG1vdmluZyBvYmplY3RzXHJcbiAgICAgICAgICAgIC8vIEZhc3QgbW92aW5nIG9iamVjdHMgYXJlIHRob3NlIG1vdmluZyBhdCBsZWFzdCB0aGVyZSBzbWFsbGVzdCBib3VuZCBwZXIgZnJhbWVcclxuICAgICAgICAgICAgaWYgKFBoeXNpY3NfOS5QaHlzaWNzLmNoZWNrRm9yRmFzdEJvZGllcykge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBwb3RlbnRpYWxDb2xsaWRlcnNfMSA9IHBvdGVudGlhbENvbGxpZGVyczsgX2kgPCBwb3RlbnRpYWxDb2xsaWRlcnNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWN0b3IgPSBwb3RlbnRpYWxDb2xsaWRlcnNfMVtfaV07XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBub24tYWN0aXZlIG9iamVjdHMuIERvZXMgbm90IG1ha2Ugc2Vuc2Ugb24gb3RoZXIgY29sbGlzb24gdHlwZXNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0b3IuY29sbGlzaW9uVHlwZSAhPT0gQWN0b3JfOS5Db2xsaXNpb25UeXBlLkFjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1heGltdW0gdHJhdmVsIGRpc3RhbmNlIG5leHQgZnJhbWVcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdXBkYXRlRGlzdGFuY2UgPSAoYWN0b3IudmVsLm1hZ25pdHVkZSgpICogc2Vjb25kcykgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAoYWN0b3IuYWNjLm1hZ25pdHVkZSgpICogLjUgKiBzZWNvbmRzICogc2Vjb25kcyk7IC8vIGFjYyB0ZXJtXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgbWluaW11bSBkaW1lbnNpb25cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWluRGltZW5zaW9uID0gTWF0aC5taW4oYWN0b3IuYm9keS5nZXRCb3VuZHMoKS5nZXRIZWlnaHQoKSwgYWN0b3IuYm9keS5nZXRCb3VuZHMoKS5nZXRXaWR0aCgpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoUGh5c2ljc185LlBoeXNpY3MuZGlzYWJsZU1pbmltdW1TcGVlZEZvckZhc3RCb2R5IHx8IHVwZGF0ZURpc3RhbmNlID4gKG1pbkRpbWVuc2lvbiAvIDIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHMucGh5c2ljcy5mYXN0Qm9kaWVzKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RhcnQgd2l0aCB0aGUgb2xkUG9zIGJlY2F1c2UgdGhlIGludGVncmF0aW9uIGZvciBhY3RvcnMgaGFzIGFscmVhZHkgaGFwcGVuZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2JqZWN0cyByZXN0aW5nIG9uIGEgc3VyZmFjZSBtYXkgYmUgc2xpZ2h0bHkgcGVuYXRyYXRpbmcgaW4gdGhlIGN1cnJlbnQgcG9zaXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVwZGF0ZVZlYyA9IGFjdG9yLnBvcy5zdWIoYWN0b3Iub2xkUG9zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNlbnRlclBvaW50ID0gYWN0b3IuYm9keS5jb2xsaXNpb25BcmVhLmdldENlbnRlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnVydGhlc3RQb2ludCA9IGFjdG9yLmJvZHkuY29sbGlzaW9uQXJlYS5nZXRGdXJ0aGVzdFBvaW50KGFjdG9yLnZlbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcmlnaW4gPSBmdXJ0aGVzdFBvaW50LnN1Yih1cGRhdGVWZWMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmF5ID0gbmV3IEFsZ2VicmFfMTguUmF5KG9yaWdpbiwgYWN0b3IudmVsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmFjayB0aGUgcmF5IHVwIGJ5IC0yeCBzdXJmYWNlRXBzaWxvbiB0byBhY2NvdW50IGZvciBmYXN0IG1vdmluZyBvYmplY3RzIHN0YXJ0aW5nIG9uIHRoZSBzdXJmYWNlIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByYXkucG9zID0gcmF5LnBvcy5hZGQocmF5LmRpci5zY2FsZSgtMiAqIFBoeXNpY3NfOS5QaHlzaWNzLnN1cmZhY2VFcHNpbG9uKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtaW5Cb2R5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWluVHJhbnNsYXRlID0gbmV3IEFsZ2VicmFfMTguVmVjdG9yKEluZmluaXR5LCBJbmZpbml0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2R5bmFtaWNDb2xsaXNpb25UcmVlLnJheUNhc3RRdWVyeShyYXksIHVwZGF0ZURpc3RhbmNlICsgUGh5c2ljc185LlBoeXNpY3Muc3VyZmFjZUVwc2lsb24gKiAyLCBmdW5jdGlvbiAob3RoZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhY3Rvci5ib2R5ICE9PSBvdGhlciAmJiBvdGhlci5jb2xsaXNpb25BcmVhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhpdFBvaW50ID0gb3RoZXIuY29sbGlzaW9uQXJlYS5yYXlDYXN0KHJheSwgdXBkYXRlRGlzdGFuY2UgKyBQaHlzaWNzXzkuUGh5c2ljcy5zdXJmYWNlRXBzaWxvbiAqIDEwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGl0UG9pbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zbGF0ZSA9IGhpdFBvaW50LnN1YihvcmlnaW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNsYXRlLm1hZ25pdHVkZSgpIDwgbWluVHJhbnNsYXRlLm1hZ25pdHVkZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5UcmFuc2xhdGUgPSB0cmFuc2xhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5Cb2R5ID0gb3RoZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWluQm9keSAmJiBBbGdlYnJhXzE4LlZlY3Rvci5pc1ZhbGlkKG1pblRyYW5zbGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYWlyID0gbmV3IFBhaXJfMi5QYWlyKGFjdG9yLmJvZHksIG1pbkJvZHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9jb2xsaXNpb25IYXNoW3BhaXIuaWRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29sbGlzaW9uSGFzaFtwYWlyLmlkXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29sbGlzaW9uUGFpckNhY2hlLnB1c2gocGFpcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlIHRoZSBmYXN0IG1vdmluZyBvYmplY3QgdG8gdGhlIG90aGVyIGJvZHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gcHVzaCBpbnRvIHRoZSBzdXJmYWNlIGJ5IGV4LlBoeXNpY3Muc3VyZmFjZUVwc2lsb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaGlmdCA9IGNlbnRlclBvaW50LnN1YihmdXJ0aGVzdFBvaW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdG9yLnBvcyA9IG9yaWdpbi5hZGQoc2hpZnQpLmFkZChtaW5UcmFuc2xhdGUpLmFkZChyYXkuZGlyLnNjYWxlKDIgKiBQaHlzaWNzXzkuUGh5c2ljcy5zdXJmYWNlRXBzaWxvbikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0b3IuYm9keS5jb2xsaXNpb25BcmVhLnJlY2FsYygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHMucGh5c2ljcy5mYXN0Qm9keUNvbGxpc2lvbnMrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyByZXR1cm4gY2FjaGVcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbGxpc2lvblBhaXJDYWNoZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFwcGxpZXMgbmFycm93IHBoYXNlIG9uIGNvbGxpc2lvbiBwYWlycyB0byBmaW5kIGFjdHVhbCBhcmVhIGludGVyc2VjdGlvbnNcclxuICAgICAgICAgKiBBZGRzIGFjdHVhbCBjb2xsaWRpbmcgcGFpcnMgdG8gc3RhdHMnIEZyYW1lIGRhdGFcclxuICAgICAgICAgKi9cclxuICAgICAgICBEeW5hbWljVHJlZUNvbGxpc2lvbkJyb2FkcGhhc2UucHJvdG90eXBlLm5hcnJvd3BoYXNlID0gZnVuY3Rpb24gKHBhaXJzLCBzdGF0cykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBwYWlyc1tpXS5jb2xsaWRlKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHMgJiYgcGFpcnNbaV0uY29sbGlzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHMucGh5c2ljcy5jb2xsaXNpb25zKys7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHMucGh5c2ljcy5jb2xsaWRlcnNIYXNoW3BhaXJzW2ldLmlkXSA9IHBhaXJzW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwYWlycy5maWx0ZXIoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAuY29sbGlzaW9uOyB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBlcmZvcm0gY29sbGlzaW9uIHJlc29sdXRpb24gZ2l2ZW4gYSBzdHJhdGVneSAocmlnaWQgYm9keSBvciBib3gpIGFuZCBtb3ZlIG9iamVjdHMgb3V0IG9mIGludGVyc2VjdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBEeW5hbWljVHJlZUNvbGxpc2lvbkJyb2FkcGhhc2UucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAocGFpcnMsIGRlbHRhLCBzdHJhdGVneSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHBhaXJzXzEgPSBwYWlyczsgX2kgPCBwYWlyc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhaXIgPSBwYWlyc18xW19pXTtcclxuICAgICAgICAgICAgICAgIHBhaXIucmVzb2x2ZShzdHJhdGVneSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFpci5jb2xsaXNpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBwYWlyLmJvZHlBLmFwcGx5TXR2KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFpci5ib2R5Qi5hcHBseU10digpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvZG8gc3RpbGwgZG9uJ3QgbGlrZSB0aGlzLCB0aGlzIGlzIGEgc21hbGwgaW50ZWdyYXRpb24gc3RlcCB0byByZXNvbHZlIG5hcnJvd3BoYXNlIGNvbGxpc2lvbnNcclxuICAgICAgICAgICAgICAgICAgICBwYWlyLmJvZHlBLmFjdG9yLmludGVncmF0ZShkZWx0YSAqIFBoeXNpY3NfOS5QaHlzaWNzLmNvbGxpc2lvblNoaWZ0KTtcclxuICAgICAgICAgICAgICAgICAgICBwYWlyLmJvZHlCLmFjdG9yLmludGVncmF0ZShkZWx0YSAqIFBoeXNpY3NfOS5QaHlzaWNzLmNvbGxpc2lvblNoaWZ0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcGFpcnMuZmlsdGVyKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLmNhbkNvbGxpZGU7IH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRHluYW1pY1RyZWVDb2xsaXNpb25Ccm9hZHBoYXNlLnByb3RvdHlwZS5ydW5Db2xsaXNpb25TdGFydEVuZCA9IGZ1bmN0aW9uIChwYWlycykge1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudEZyYW1lSGFzaCA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHBhaXJzXzIgPSBwYWlyczsgX2kgPCBwYWlyc18yLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHAgPSBwYWlyc18yW19pXTtcclxuICAgICAgICAgICAgICAgIC8vIGxvYWQgY3VycmVudEZyYW1lSGFzaFxyXG4gICAgICAgICAgICAgICAgY3VycmVudEZyYW1lSGFzaFtwLmlkXSA9IHA7XHJcbiAgICAgICAgICAgICAgICAvLyBmaW5kIGFsbCBuZXcgY29sbGlzaW9uc1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9sYXN0RnJhbWVQYWlyc0hhc2hbcC5pZF0pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWN0b3IxID0gcC5ib2R5QS5hY3RvcjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWN0b3IyID0gcC5ib2R5Qi5hY3RvcjtcclxuICAgICAgICAgICAgICAgICAgICBhY3RvcjEuZW1pdCgnY29sbGlzaW9uc3RhcnQnLCBuZXcgRXZlbnRzXzYuQ29sbGlzaW9uU3RhcnRFdmVudChhY3RvcjEsIGFjdG9yMiwgcCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdG9yMi5lbWl0KCdjb2xsaXNpb25zdGFydCcsIG5ldyBFdmVudHNfNi5Db2xsaXNpb25TdGFydEV2ZW50KGFjdG9yMiwgYWN0b3IxLCBwKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZmluZCBhbGwgb2xkIGNvbGxpc2lvbnNcclxuICAgICAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBfYiA9IHRoaXMuX2xhc3RGcmFtZVBhaXJzOyBfYSA8IF9iLmxlbmd0aDsgX2ErKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHAgPSBfYltfYV07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRGcmFtZUhhc2hbcC5pZF0pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWN0b3IxID0gcC5ib2R5QS5hY3RvcjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWN0b3IyID0gcC5ib2R5Qi5hY3RvcjtcclxuICAgICAgICAgICAgICAgICAgICBhY3RvcjEuZW1pdCgnY29sbGlzaW9uZW5kJywgbmV3IEV2ZW50c182LkNvbGxpc2lvbkVuZEV2ZW50KGFjdG9yMSwgYWN0b3IyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0b3IyLmVtaXQoJ2NvbGxpc2lvbmVuZCcsIG5ldyBFdmVudHNfNi5Db2xsaXNpb25FbmRFdmVudChhY3RvcjIsIGFjdG9yMSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHJlc2V0IHRoZSBsYXN0IGZyYW1lIGNhY2hlXHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3RGcmFtZVBhaXJzID0gcGFpcnM7XHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3RGcmFtZVBhaXJzSGFzaCA9IGN1cnJlbnRGcmFtZUhhc2g7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGUgdGhlIGR5bmFtaWMgdHJlZSBwb3NpdGlvbnNcclxuICAgICAgICAgKi9cclxuICAgICAgICBEeW5hbWljVHJlZUNvbGxpc2lvbkJyb2FkcGhhc2UucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICh0YXJnZXRzKSB7XHJcbiAgICAgICAgICAgIHZhciB1cGRhdGVkID0gMCwgaSA9IDAsIGxlbiA9IHRhcmdldHMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2R5bmFtaWNDb2xsaXNpb25UcmVlLnVwZGF0ZUJvZHkodGFyZ2V0c1tpXS5ib2R5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlZDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgRHluYW1pY1RyZWVDb2xsaXNpb25Ccm9hZHBoYXNlLnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XHJcbiAgICAgICAgICAgIGlmIChQaHlzaWNzXzkuUGh5c2ljcy5icm9hZHBoYXNlRGVidWcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2R5bmFtaWNDb2xsaXNpb25UcmVlLmRlYnVnRHJhdyhjdHgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChQaHlzaWNzXzkuUGh5c2ljcy5zaG93Q29udGFjdHMgfHwgUGh5c2ljc185LlBoeXNpY3Muc2hvd0NvbGxpc2lvbk5vcm1hbHMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl9jb2xsaXNpb25QYWlyQ2FjaGU7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhaXIgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICAgICAgcGFpci5kZWJ1Z0RyYXcoY3R4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIER5bmFtaWNUcmVlQ29sbGlzaW9uQnJvYWRwaGFzZTtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkR5bmFtaWNUcmVlQ29sbGlzaW9uQnJvYWRwaGFzZSA9IER5bmFtaWNUcmVlQ29sbGlzaW9uQnJvYWRwaGFzZTtcclxufSk7XHJcbmRlZmluZShcIkNvbGxpc2lvbi9JUGh5c2ljc1wiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG59KTtcclxuZGVmaW5lKFwiQ29sbGlzaW9uL05haXZlQ29sbGlzaW9uQnJvYWRwaGFzZVwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIlBoeXNpY3NcIiwgXCJDb2xsaXNpb24vQ29sbGlzaW9uQ29udGFjdFwiLCBcIkNvbGxpc2lvbi9QYWlyXCIsIFwiQWN0b3JcIiwgXCJFdmVudHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBQaHlzaWNzXzEwLCBDb2xsaXNpb25Db250YWN0XzIsIFBhaXJfMywgQWN0b3JfMTAsIEV2ZW50c183KSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIHZhciBOYWl2ZUNvbGxpc2lvbkJyb2FkcGhhc2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIE5haXZlQ29sbGlzaW9uQnJvYWRwaGFzZSgpIHtcclxuICAgICAgICAgICAgdGhpcy5fbGFzdEZyYW1lUGFpcnMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5fbGFzdEZyYW1lUGFpcnNIYXNoID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE5haXZlQ29sbGlzaW9uQnJvYWRwaGFzZS5wcm90b3R5cGUudHJhY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIHBhc3NcclxuICAgICAgICB9O1xyXG4gICAgICAgIE5haXZlQ29sbGlzaW9uQnJvYWRwaGFzZS5wcm90b3R5cGUudW50cmFjayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gcGFzc1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGV0ZWN0cyBwb3RlbnRpYWwgY29sbGlzaW9uIHBhaXJzIGluIGEgYnJvYWRwaGFzZSBhcHByb2FjaCB3aXRoIHRoZSBkeW5hbWljIGFhYmIgdHJlZSBzdHJhdGVneVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE5haXZlQ29sbGlzaW9uQnJvYWRwaGFzZS5wcm90b3R5cGUuYnJvYWRwaGFzZSA9IGZ1bmN0aW9uICh0YXJnZXRzKSB7XHJcbiAgICAgICAgICAgIC8vIFJldHJpZXZlIHRoZSBsaXN0IG9mIHBvdGVudGlhbCBjb2xsaWRlcnMsIGV4Y2x1ZGUga2lsbGVkLCBwcmV2ZW50ZWQsIGFuZCBzZWxmXHJcbiAgICAgICAgICAgIHZhciBwb3RlbnRpYWxDb2xsaWRlcnMgPSB0YXJnZXRzLmZpbHRlcihmdW5jdGlvbiAob3RoZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhb3RoZXIuaXNLaWxsZWQoKSAmJiBvdGhlci5jb2xsaXNpb25UeXBlICE9PSBBY3Rvcl8xMC5Db2xsaXNpb25UeXBlLlByZXZlbnRDb2xsaXNpb247XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2YXIgYWN0b3IxO1xyXG4gICAgICAgICAgICB2YXIgYWN0b3IyO1xyXG4gICAgICAgICAgICB2YXIgY29sbGlzaW9uUGFpcnMgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGwgPSBwb3RlbnRpYWxDb2xsaWRlcnMubGVuZ3RoOyBqIDwgbDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBhY3RvcjEgPSBwb3RlbnRpYWxDb2xsaWRlcnNbal07XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gaiArIDE7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBhY3RvcjIgPSBwb3RlbnRpYWxDb2xsaWRlcnNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pbmltdW1UcmFuc2xhdGlvblZlY3RvcjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWluaW11bVRyYW5zbGF0aW9uVmVjdG9yID0gYWN0b3IxLmNvbGxpZGVzKGFjdG9yMikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhaXIgPSBuZXcgUGFpcl8zLlBhaXIoYWN0b3IxLmJvZHksIGFjdG9yMi5ib2R5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFpci5jb2xsaXNpb24gPSBuZXcgQ29sbGlzaW9uQ29udGFjdF8yLkNvbGxpc2lvbkNvbnRhY3QoYWN0b3IxLmNvbGxpc2lvbkFyZWEsIGFjdG9yMi5jb2xsaXNpb25BcmVhLCBtaW5pbXVtVHJhbnNsYXRpb25WZWN0b3IsIGFjdG9yMS5wb3MsIG1pbmltdW1UcmFuc2xhdGlvblZlY3Rvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29sbGlzaW9uUGFpcnMuc29tZShmdW5jdGlvbiAoY3ApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcC5pZCA9PT0gcGFpci5pZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxpc2lvblBhaXJzLnB1c2gocGFpcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNvbGxpc2lvblBhaXJzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWRlbnRpZnkgYWN0dWFsIGNvbGxpc2lvbnMgZnJvbSB0aG9zZSBwYWlycywgYW5kIGNhbGN1bGF0ZSBjb2xsaXNpb24gaW1wdWxzZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE5haXZlQ29sbGlzaW9uQnJvYWRwaGFzZS5wcm90b3R5cGUubmFycm93cGhhc2UgPSBmdW5jdGlvbiAocGFpcnMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhaXJzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgTmFpdmVDb2xsaXNpb25Ccm9hZHBoYXNlLnByb3RvdHlwZS5ydW5Db2xsaXNpb25TdGFydEVuZCA9IGZ1bmN0aW9uIChwYWlycykge1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudEZyYW1lSGFzaCA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHBhaXJzXzMgPSBwYWlyczsgX2kgPCBwYWlyc18zLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHAgPSBwYWlyc18zW19pXTtcclxuICAgICAgICAgICAgICAgIC8vIGxvYWQgY3VycmVudEZyYW1lSGFzaFxyXG4gICAgICAgICAgICAgICAgY3VycmVudEZyYW1lSGFzaFtwLmlkXSA9IHA7XHJcbiAgICAgICAgICAgICAgICAvLyBmaW5kIGFsbCBuZXcgY29sbGlzaW9uc1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9sYXN0RnJhbWVQYWlyc0hhc2hbcC5pZF0pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWN0b3IxID0gcC5ib2R5QS5hY3RvcjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWN0b3IyID0gcC5ib2R5Qi5hY3RvcjtcclxuICAgICAgICAgICAgICAgICAgICBhY3RvcjEuZW1pdCgnY29sbGlzaW9uc3RhcnQnLCBuZXcgRXZlbnRzXzcuQ29sbGlzaW9uU3RhcnRFdmVudChhY3RvcjEsIGFjdG9yMiwgcCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdG9yMi5lbWl0KCdjb2xsaXNpb25zdGFydCcsIG5ldyBFdmVudHNfNy5Db2xsaXNpb25TdGFydEV2ZW50KGFjdG9yMiwgYWN0b3IxLCBwKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZmluZCBhbGwgb2xkIGNvbGxpc2lvbnNcclxuICAgICAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBfYiA9IHRoaXMuX2xhc3RGcmFtZVBhaXJzOyBfYSA8IF9iLmxlbmd0aDsgX2ErKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHAgPSBfYltfYV07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRGcmFtZUhhc2hbcC5pZF0pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWN0b3IxID0gcC5ib2R5QS5hY3RvcjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWN0b3IyID0gcC5ib2R5Qi5hY3RvcjtcclxuICAgICAgICAgICAgICAgICAgICBhY3RvcjEuZW1pdCgnY29sbGlzaW9uZW5kJywgbmV3IEV2ZW50c183LkNvbGxpc2lvbkVuZEV2ZW50KGFjdG9yMSwgYWN0b3IyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0b3IyLmVtaXQoJ2NvbGxpc2lvbmVuZCcsIG5ldyBFdmVudHNfNy5Db2xsaXNpb25FbmRFdmVudChhY3RvcjIsIGFjdG9yMSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHJlc2V0IHRoZSBsYXN0IGZyYW1lIGNhY2hlXHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3RGcmFtZVBhaXJzID0gcGFpcnM7XHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3RGcmFtZVBhaXJzSGFzaCA9IGN1cnJlbnRGcmFtZUhhc2g7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXNvbHZlIHRoZSBwb3NpdGlvbiBhbmQgdmVsb2NpdHkgb2YgdGhlIHBoeXNpY3MgYm9kaWVzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTmFpdmVDb2xsaXNpb25Ccm9hZHBoYXNlLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gKHBhaXJzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgcGFpcnNfNCA9IHBhaXJzOyBfaSA8IHBhaXJzXzQubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFpciA9IHBhaXJzXzRbX2ldO1xyXG4gICAgICAgICAgICAgICAgcGFpci5yZXNvbHZlKFBoeXNpY3NfMTAuUGh5c2ljcy5jb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwYWlycy5maWx0ZXIoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAuY2FuQ29sbGlkZTsgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBOYWl2ZUNvbGxpc2lvbkJyb2FkcGhhc2UucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBOYWl2ZUNvbGxpc2lvbkJyb2FkcGhhc2UucHJvdG90eXBlLmRlYnVnRHJhdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIE5haXZlQ29sbGlzaW9uQnJvYWRwaGFzZTtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLk5haXZlQ29sbGlzaW9uQnJvYWRwaGFzZSA9IE5haXZlQ29sbGlzaW9uQnJvYWRwaGFzZTtcclxufSk7XHJcbmRlZmluZShcIkNvbGxpc2lvbi9JbmRleFwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkNvbGxpc2lvbi9Cb2R5XCIsIFwiQ29sbGlzaW9uL0JvdW5kaW5nQm94XCIsIFwiQ29sbGlzaW9uL0NpcmNsZUFyZWFcIiwgXCJDb2xsaXNpb24vQ29sbGlzaW9uQ29udGFjdFwiLCBcIkNvbGxpc2lvbi9Db2xsaXNpb25KdW1wVGFibGVcIiwgXCJDb2xsaXNpb24vRHluYW1pY1RyZWVcIiwgXCJDb2xsaXNpb24vRHluYW1pY1RyZWVDb2xsaXNpb25Ccm9hZHBoYXNlXCIsIFwiQ29sbGlzaW9uL0VkZ2VBcmVhXCIsIFwiQ29sbGlzaW9uL05haXZlQ29sbGlzaW9uQnJvYWRwaGFzZVwiLCBcIkNvbGxpc2lvbi9QYWlyXCIsIFwiQ29sbGlzaW9uL1BvbHlnb25BcmVhXCIsIFwiQ29sbGlzaW9uL1NpZGVcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBCb2R5XzEsIEJvdW5kaW5nQm94XzYsIENpcmNsZUFyZWFfNCwgQ29sbGlzaW9uQ29udGFjdF8zLCBDb2xsaXNpb25KdW1wVGFibGVfNCwgRHluYW1pY1RyZWVfMiwgRHluYW1pY1RyZWVDb2xsaXNpb25Ccm9hZHBoYXNlXzEsIEVkZ2VBcmVhXzQsIE5haXZlQ29sbGlzaW9uQnJvYWRwaGFzZV8xLCBQYWlyXzQsIFBvbHlnb25BcmVhXzYsIFNpZGVfMykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBmdW5jdGlvbiBfX2V4cG9ydChtKSB7XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgX19leHBvcnQoQm9keV8xKTtcclxuICAgIF9fZXhwb3J0KEJvdW5kaW5nQm94XzYpO1xyXG4gICAgX19leHBvcnQoQ2lyY2xlQXJlYV80KTtcclxuICAgIF9fZXhwb3J0KENvbGxpc2lvbkNvbnRhY3RfMyk7XHJcbiAgICBfX2V4cG9ydChDb2xsaXNpb25KdW1wVGFibGVfNCk7XHJcbiAgICBfX2V4cG9ydChEeW5hbWljVHJlZV8yKTtcclxuICAgIF9fZXhwb3J0KER5bmFtaWNUcmVlQ29sbGlzaW9uQnJvYWRwaGFzZV8xKTtcclxuICAgIF9fZXhwb3J0KEVkZ2VBcmVhXzQpO1xyXG4gICAgX19leHBvcnQoTmFpdmVDb2xsaXNpb25Ccm9hZHBoYXNlXzEpO1xyXG4gICAgX19leHBvcnQoUGFpcl80KTtcclxuICAgIF9fZXhwb3J0KFBvbHlnb25BcmVhXzYpO1xyXG4gICAgX19leHBvcnQoU2lkZV8zKTtcclxufSk7XHJcbmRlZmluZShcIkRyYXdpbmcvUG9seWdvblwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkFsZ2VicmFcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBBbGdlYnJhXzE5KSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGNsb3NlZCBwb2x5Z29uIGRyYXdpbmcgZ2l2ZW4gYSBsaXN0IG9mIFtbVmVjdG9yXV1zLlxyXG4gICAgICpcclxuICAgICAqIEB3YXJuaW5nIFVzZSBzcGFyaW5nbHkgYXMgUG9seWdvbnMgYXJlIHBlcmZvcm1hbmNlIGludGVuc2l2ZVxyXG4gICAgICovXHJcbiAgICB2YXIgUG9seWdvbiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHBvaW50cyAgVGhlIHZlY3RvcnMgdG8gdXNlIHRvIGJ1aWxkIHRoZSBwb2x5Z29uIGluIG9yZGVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gUG9seWdvbihwb2ludHMpIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgbGluZXMgb2YgdGhlIHBvbHlnb25cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMubGluZVdpZHRoID0gNTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBwb2x5Z29uIGlzIGZpbGxlZCBvciBub3QuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmZpbGxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9wb2ludHMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5hbmNob3IgPSBuZXcgQWxnZWJyYV8xOS5WZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMucm90YXRpb24gPSAwO1xyXG4gICAgICAgICAgICB0aGlzLnNjYWxlID0gbmV3IEFsZ2VicmFfMTkuVmVjdG9yKDEsIDEpO1xyXG4gICAgICAgICAgICB0aGlzLl9wb2ludHMgPSBwb2ludHM7XHJcbiAgICAgICAgICAgIHZhciBtaW5YID0gdGhpcy5fcG9pbnRzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3Vycikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKHByZXYsIGN1cnIueCk7XHJcbiAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgICAgICB2YXIgbWF4WCA9IHRoaXMuX3BvaW50cy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cnIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChwcmV2LCBjdXJyLngpO1xyXG4gICAgICAgICAgICB9LCAwKTtcclxuICAgICAgICAgICAgdGhpcy53aWR0aCA9IG1heFggLSBtaW5YO1xyXG4gICAgICAgICAgICB2YXIgbWluWSA9IHRoaXMuX3BvaW50cy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cnIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbihwcmV2LCBjdXJyLnkpO1xyXG4gICAgICAgICAgICB9LCAwKTtcclxuICAgICAgICAgICAgdmFyIG1heFkgPSB0aGlzLl9wb2ludHMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgocHJldiwgY3Vyci55KTtcclxuICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gbWF4WSAtIG1pblk7XHJcbiAgICAgICAgICAgIHRoaXMubmF0dXJhbEhlaWdodCA9IHRoaXMuaGVpZ2h0O1xyXG4gICAgICAgICAgICB0aGlzLm5hdHVyYWxXaWR0aCA9IHRoaXMud2lkdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBub3RpbXBsZW1lbnRlZCBFZmZlY3RzIGFyZSBub3Qgc3VwcG9ydGVkIG9uIGBQb2x5Z29uYFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBvbHlnb24ucHJvdG90eXBlLmFkZEVmZmVjdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBvbiBwb2x5Z29uc1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG5vdGltcGxlbWVudGVkIEVmZmVjdHMgYXJlIG5vdCBzdXBwb3J0ZWQgb24gYFBvbHlnb25gXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUG9seWdvbi5wcm90b3R5cGUucmVtb3ZlRWZmZWN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIG9uIHBvbHlnb25zXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbm90aW1wbGVtZW50ZWQgRWZmZWN0cyBhcmUgbm90IHN1cHBvcnRlZCBvbiBgUG9seWdvbmBcclxuICAgICAgICAgKi9cclxuICAgICAgICBQb2x5Z29uLnByb3RvdHlwZS5jbGVhckVmZmVjdHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgb24gcG9seWdvbnNcclxuICAgICAgICB9O1xyXG4gICAgICAgIFBvbHlnb24ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvL3Bhc3NcclxuICAgICAgICB9O1xyXG4gICAgICAgIFBvbHlnb24ucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoY3R4LCB4LCB5KSB7XHJcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoeCArIHRoaXMuYW5jaG9yLngsIHkgKyB0aGlzLmFuY2hvci55KTtcclxuICAgICAgICAgICAgY3R4LnNjYWxlKHRoaXMuc2NhbGUueCwgdGhpcy5zY2FsZS55KTtcclxuICAgICAgICAgICAgY3R4LnJvdGF0ZSh0aGlzLnJvdGF0aW9uKTtcclxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5saW5lV2lkdGg7XHJcbiAgICAgICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgc3VwcGxpZWQgcG9pbnRzIGFuZCBjb25zdHJ1Y3QgYSAncG9seWdvbidcclxuICAgICAgICAgICAgdmFyIGZpcnN0UG9pbnQgPSB0aGlzLl9wb2ludHNbMF07XHJcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oZmlyc3RQb2ludC54LCBmaXJzdFBvaW50LnkpO1xyXG4gICAgICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3BvaW50cy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHRoaXMuX3BvaW50c1tpXS54LCB0aGlzLl9wb2ludHNbaV0ueSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3R4LmxpbmVUbyhmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSk7XHJcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZmlsbGVkKSB7XHJcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5maWxsQ29sb3IudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5saW5lQ29sb3IudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZmxpcEhvcml6b250YWwpIHtcclxuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUodGhpcy53aWR0aCwgMCk7XHJcbiAgICAgICAgICAgICAgICBjdHguc2NhbGUoLTEsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZsaXBWZXJ0aWNhbCkge1xyXG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgwLCB0aGlzLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBjdHguc2NhbGUoMSwgLTEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBQb2x5Z29uO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuUG9seWdvbiA9IFBvbHlnb247XHJcbn0pO1xyXG5kZWZpbmUoXCJEcmF3aW5nL0luZGV4XCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiRHJhd2luZy9BbmltYXRpb25cIiwgXCJEcmF3aW5nL0NvbG9yXCIsIFwiRHJhd2luZy9Qb2x5Z29uXCIsIFwiRHJhd2luZy9TcHJpdGVcIiwgXCJEcmF3aW5nL1Nwcml0ZVNoZWV0XCIsIFwiRHJhd2luZy9TcHJpdGVFZmZlY3RzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgQW5pbWF0aW9uXzIsIENvbG9yXzE3LCBQb2x5Z29uXzEsIFNwcml0ZV8zLCBTcHJpdGVTaGVldF8xLCBlZmZlY3RzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIGZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcclxuICAgICAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICBleHBvcnRzLkFuaW1hdGlvbiA9IEFuaW1hdGlvbl8yLkFuaW1hdGlvbjtcclxuICAgIF9fZXhwb3J0KENvbG9yXzE3KTtcclxuICAgIF9fZXhwb3J0KFBvbHlnb25fMSk7XHJcbiAgICBleHBvcnRzLlNwcml0ZSA9IFNwcml0ZV8zLlNwcml0ZTtcclxuICAgIGV4cG9ydHMuU3ByaXRlU2hlZXQgPSBTcHJpdGVTaGVldF8xLlNwcml0ZVNoZWV0O1xyXG4gICAgZXhwb3J0cy5TcHJpdGVGb250ID0gU3ByaXRlU2hlZXRfMS5TcHJpdGVGb250O1xyXG4gICAgZXhwb3J0cy5FZmZlY3RzID0gZWZmZWN0cztcclxufSk7XHJcbmRlZmluZShcIkludGVyZmFjZXMvSW5kZXhcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxufSk7XHJcbmRlZmluZShcIk1hdGgvUGVybGluTm9pc2VcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJNYXRoL1JhbmRvbVwiLCBcIkRyYXdpbmcvQ29sb3JcIiwgXCJVdGlsL1V0aWxcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBSYW5kb21fMywgQ29sb3JfMTgsIFV0aWwpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgZnVuY3Rpb24gX2xlcnAodGltZSwgYSwgYikge1xyXG4gICAgICAgIHJldHVybiBhICsgdGltZSAqIChiIC0gYSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBfZmFkZSh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHQgKiB0ICogdCAqICh0ICogKHQgKiA2IC0gMTUpICsgMTApO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgcGVybGluIG5vaXNlIGJhc2VkIG9uIHRoZSAyMDAyIFNpZ2dyYXBoIHBhcGVyIGh0dHA6Ly9tcmwubnl1LmVkdS9+cGVybGluL25vaXNlL1xyXG4gICAgICogQWxzbyBodHRwczovL2ZsYWZsYTIuZ2l0aHViLmlvLzIwMTQvMDgvMDkvcGVybGlubm9pc2UuaHRtbFxyXG4gICAgICovXHJcbiAgICB2YXIgUGVybGluR2VuZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBQZXJsaW5HZW5lcmF0b3Iob3B0aW9ucykge1xyXG4gICAgICAgICAgICB0aGlzLl9wZXJtID0gWzE1MSwgMTYwLCAxMzcsIDkxLCA5MCwgMTUsIDEzMSwgMTMsIDIwMSwgOTUsIDk2LCA1MywgMTk0LCAyMzMsIDcsIDIyNSxcclxuICAgICAgICAgICAgICAgIDE0MCwgMzYsIDEwMywgMzAsIDY5LCAxNDIsIDgsIDk5LCAzNywgMjQwLCAyMSwgMTAsIDIzLCAxOTAsIDYsIDE0OCwgMjQ3LCAxMjAsIDIzNCwgNzUsIDAsIDI2LFxyXG4gICAgICAgICAgICAgICAgMTk3LCA2MiwgOTQsIDI1MiwgMjE5LCAyMDMsIDExNywgMzUsIDExLCAzMiwgNTcsIDE3NywgMzMsIDg4LCAyMzcsIDE0OSwgNTYsIDg3LCAxNzQsIDIwLCAxMjUsIDEzNixcclxuICAgICAgICAgICAgICAgIDE3MSwgMTY4LCA2OCwgMTc1LCA3NCwgMTY1LCA3MSwgMTM0LCAxMzksIDQ4LCAyNywgMTY2LCA3NywgMTQ2LCAxNTgsIDIzMSwgODMsIDExMSwgMjI5LCAxMjIsIDYwLFxyXG4gICAgICAgICAgICAgICAgMjExLCAxMzMsIDIzMCwgMjIwLCAxMDUsIDkyLCA0MSwgNTUsIDQ2LCAyNDUsIDQwLCAyNDQsIDEwMiwgMTQzLCA1NCwgNjUsIDI1LCA2MywgMTYxLCAxLCAyMTYsIDgwLFxyXG4gICAgICAgICAgICAgICAgNzMsIDIwOSwgNzYsIDEzMiwgMTg3LCAyMDgsIDg5LCAxOCwgMTY5LCAyMDAsIDE5NiwgMTM1LCAxMzAsIDExNiwgMTg4LCAxNTksIDg2LCAxNjQsIDEwMCwgMTA5LCAxOTgsXHJcbiAgICAgICAgICAgICAgICAxNzMsIDE4NiwgMywgNjQsIDUyLCAyMTcsIDIyNiwgMjUwLCAxMjQsIDEyMywgNSwgMjAyLCAzOCwgMTQ3LCAxMTgsIDEyNiwgMjU1LCA4MiwgODUsIDIxMiwgMjA3LCAyMDYsXHJcbiAgICAgICAgICAgICAgICA1OSwgMjI3LCA0NywgMTYsIDU4LCAxNywgMTgyLCAxODksIDI4LCA0MiwgMjIzLCAxODMsIDE3MCwgMjEzLCAxMTksIDI0OCwgMTUyLCAyLCA0NCwgMTU0LCAxNjMsIDcwLFxyXG4gICAgICAgICAgICAgICAgMjIxLCAxNTMsIDEwMSwgMTU1LCAxNjcsIDQzLCAxNzIsIDksIDEyOSwgMjIsIDM5LCAyNTMsIDE5LCA5OCwgMTA4LCAxMTAsIDc5LCAxMTMsIDIyNCwgMjMyLCAxNzgsXHJcbiAgICAgICAgICAgICAgICAxODUsIDExMiwgMTA0LCAyMTgsIDI0NiwgOTcsIDIyOCwgMjUxLCAzNCwgMjQyLCAxOTMsIDIzOCwgMjEwLCAxNDQsIDEyLCAxOTEsIDE3OSwgMTYyLCAyNDEsIDgxLFxyXG4gICAgICAgICAgICAgICAgNTEsIDE0NSwgMjM1LCAyNDksIDE0LCAyMzksIDEwNywgNDksIDE5MiwgMjE0LCAzMSwgMTgxLCAxOTksIDEwNiwgMTU3LCAxODQsIDg0LCAyMDQsIDE3NiwgMTE1LFxyXG4gICAgICAgICAgICAgICAgMTIxLCA1MCwgNDUsIDEyNywgNCwgMTUwLCAyNTQsIDEzOCwgMjM2LCAyMDUsIDkzLCAyMjIsIDExNCwgNjcsIDI5LCAyNCwgNzIsIDI0MywgMTQxLCAxMjgsIDE5NSxcclxuICAgICAgICAgICAgICAgIDc4LCA2NiwgMjE1LCA2MSwgMTU2LCAxODBdO1xyXG4gICAgICAgICAgICB0aGlzLl9wID0gbmV3IFVpbnQ4QXJyYXkoNTEyKTtcclxuICAgICAgICAgICAgdGhpcy5fZGVmYXVsdFBlcmxpbk9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICBvY3RhdmVzOiAxLFxyXG4gICAgICAgICAgICAgICAgZnJlcXVlbmN5OiAxLFxyXG4gICAgICAgICAgICAgICAgYW1wbGl0dWRlOiAxLFxyXG4gICAgICAgICAgICAgICAgcGVyc2lzdGFuY2U6IC41XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7fSwgdGhpcy5fZGVmYXVsdFBlcmxpbk9wdGlvbnMsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICB0aGlzLnBlcnNpc3RhbmNlID0gb3B0aW9ucy5wZXJzaXN0YW5jZTtcclxuICAgICAgICAgICAgdGhpcy5hbXBsaXR1ZGUgPSBvcHRpb25zLmFtcGxpdHVkZTtcclxuICAgICAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSBvcHRpb25zLmZyZXF1ZW5jeTtcclxuICAgICAgICAgICAgdGhpcy5vY3RhdmVzID0gb3B0aW9ucy5vY3RhdmVzO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zZWVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yYW5kb20gPSBuZXcgUmFuZG9tXzMuUmFuZG9tKG9wdGlvbnMuc2VlZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yYW5kb20gPSBuZXcgUmFuZG9tXzMuUmFuZG9tKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fcGVybSA9IHRoaXMuX3JhbmRvbS5zaHVmZmxlKHRoaXMuX3Blcm0pO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDUxMjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wW2ldID0gdGhpcy5fcGVybVtpICUgMjU2XSAmIDB4RkY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgUGVybGluR2VuZXJhdG9yLnByb3RvdHlwZS5ub2lzZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGFtcCA9IHRoaXMuYW1wbGl0dWRlO1xyXG4gICAgICAgICAgICB2YXIgZnJlcSA9IHRoaXMuZnJlcXVlbmN5O1xyXG4gICAgICAgICAgICB2YXIgdG90YWwgPSAwO1xyXG4gICAgICAgICAgICB2YXIgbWF4VmFsdWUgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub2N0YXZlczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsICs9IHRoaXMuX25vaXNlMWQoYXJndW1lbnRzWzBdICogZnJlcSkgKiBhbXA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWwgKz0gdGhpcy5fbm9pc2UyZChhcmd1bWVudHNbMF0gKiBmcmVxLCBhcmd1bWVudHNbMV0gKiBmcmVxKSAqIGFtcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbCArPSB0aGlzLl9ub2lzZTNkKGFyZ3VtZW50c1swXSAqIGZyZXEsIGFyZ3VtZW50c1sxXSAqIGZyZXEsIGFyZ3VtZW50c1syXSAqIGZyZXEpICogYW1wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMgZm9yIHBlcmxpbiBub2lzZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbWF4VmFsdWUgKz0gYW1wO1xyXG4gICAgICAgICAgICAgICAgYW1wICo9IHRoaXMucGVyc2lzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICBmcmVxICo9IDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRvdGFsIC8gbWF4VmFsdWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZW5lcmF0ZXMgYSBsaXN0IHN0YXJ0aW5nIGF0IDAgYW5kIGVuZGluZyBhdCAxIG9mIGNvbnRpb3VzIHBlcmxpbiBub2lzZSwgYnkgZGVmYXVsdCB0aGUgc3RlcCBpcyAxL2xlbmd0aDtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBlcmxpbkdlbmVyYXRvci5wcm90b3R5cGUuc2VxdWVuY2UgPSBmdW5jdGlvbiAobGVuZ3RoLCBzdGVwKSB7XHJcbiAgICAgICAgICAgIGlmICghc3RlcCkge1xyXG4gICAgICAgICAgICAgICAgc3RlcCA9IDEgLyBsZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGFycmF5ID0gbmV3IEFycmF5KGxlbmd0aCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gdGhpcy5ub2lzZShpICogc3RlcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2VuZXJhdGVzIGEgMkQgZ3JpZCBvZiBwZXJsaW4gbm9pc2UgZ2l2ZW4gYSBzdGVwIHZhbHVlIHBhY2tlZCBpbnRvIGEgMUQgYXJyYXkgaSA9ICh4ICsgeSp3aWR0aCksXHJcbiAgICAgICAgICogYnkgZGVmYXVsdCB0aGUgc3RlcCB3aWxsIDEvKG1pbihkaW1lbnNpb24pKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBlcmxpbkdlbmVyYXRvci5wcm90b3R5cGUuZ3JpZCA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0LCBzdGVwKSB7XHJcbiAgICAgICAgICAgIGlmICghc3RlcCkge1xyXG4gICAgICAgICAgICAgICAgc3RlcCA9IDEgLyAoTWF0aC5taW4od2lkdGgsIGhlaWdodCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBhcnJheSA9IG5ldyBBcnJheSh3aWR0aCAqIGhlaWdodCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGFycmF5W3ggKyB5ICogd2lkdGhdID0gdGhpcy5ub2lzZSh4ICogc3RlcCwgeSAqIHN0ZXApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBhcnJheTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFBlcmxpbkdlbmVyYXRvci5wcm90b3R5cGUuX2dyYWRpZW50M2QgPSBmdW5jdGlvbiAoaGFzaCwgeCwgeSwgeikge1xyXG4gICAgICAgICAgICB2YXIgaCA9IGhhc2ggJiAweEY7XHJcbiAgICAgICAgICAgIHZhciB1ID0gaCA8IDggPyB4IDogeTtcclxuICAgICAgICAgICAgdmFyIHYgPSBoIDwgNCA/IHkgOiAoKGggPT09IDEyIHx8IGggPT09IDE0KSA/IHggOiB6KTtcclxuICAgICAgICAgICAgcmV0dXJuICgoaCAmIDEpID09PSAwID8gdSA6IC11KSArICgoaCAmIDIpID09PSAwID8gdiA6IC12KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFBlcmxpbkdlbmVyYXRvci5wcm90b3R5cGUuX2dyYWRpZW50MmQgPSBmdW5jdGlvbiAoaGFzaCwgeCwgeSkge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSAoaGFzaCAmIDEpID09PSAwID8geCA6IHk7XHJcbiAgICAgICAgICAgIHJldHVybiAoaGFzaCAmIDIpID09PSAwID8gLXZhbHVlIDogdmFsdWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQZXJsaW5HZW5lcmF0b3IucHJvdG90eXBlLl9ncmFkaWVudDFkID0gZnVuY3Rpb24gKGhhc2gsIHgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChoYXNoICYgMSkgPT09IDAgPyAteCA6IHg7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQZXJsaW5HZW5lcmF0b3IucHJvdG90eXBlLl9ub2lzZTFkID0gZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgdmFyIGludFggPSBNYXRoLmZsb29yKHgpICYgMHhGRjsgLy8gZm9yY2UgMC0yNTUgaW50ZWdlcnMgdG8gbG9va3VwIGluIHBlcm11dGF0aW9uXHJcbiAgICAgICAgICAgIHggLT0gTWF0aC5mbG9vcih4KTtcclxuICAgICAgICAgICAgdmFyIGZhZGVYID0gX2ZhZGUoeCk7XHJcbiAgICAgICAgICAgIHJldHVybiAoX2xlcnAoZmFkZVgsIHRoaXMuX2dyYWRpZW50MWQodGhpcy5fcFtpbnRYXSwgeCksIHRoaXMuX2dyYWRpZW50MWQodGhpcy5fcFtpbnRYICsgMV0sIHggLSAxKSkgKyAxKSAvIDI7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQZXJsaW5HZW5lcmF0b3IucHJvdG90eXBlLl9ub2lzZTJkID0gZnVuY3Rpb24gKHgsIHkpIHtcclxuICAgICAgICAgICAgdmFyIGludFggPSBNYXRoLmZsb29yKHgpICYgMHhGRjtcclxuICAgICAgICAgICAgdmFyIGludFkgPSBNYXRoLmZsb29yKHkpICYgMHhGRjtcclxuICAgICAgICAgICAgeCAtPSBNYXRoLmZsb29yKHgpO1xyXG4gICAgICAgICAgICB5IC09IE1hdGguZmxvb3IoeSk7XHJcbiAgICAgICAgICAgIHZhciBmYWRlWCA9IF9mYWRlKHgpO1xyXG4gICAgICAgICAgICB2YXIgZmFkZVkgPSBfZmFkZSh5KTtcclxuICAgICAgICAgICAgdmFyIGEgPSB0aGlzLl9wW2ludFhdICsgaW50WTtcclxuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLl9wW2ludFggKyAxXSArIGludFk7XHJcbiAgICAgICAgICAgIHJldHVybiAoX2xlcnAoZmFkZVksIF9sZXJwKGZhZGVYLCB0aGlzLl9ncmFkaWVudDJkKHRoaXMuX3BbYV0sIHgsIHkpLCB0aGlzLl9ncmFkaWVudDJkKHRoaXMuX3BbYl0sIHggLSAxLCB5KSksIF9sZXJwKGZhZGVYLCB0aGlzLl9ncmFkaWVudDJkKHRoaXMuX3BbYSArIDFdLCB4LCB5IC0gMSksIHRoaXMuX2dyYWRpZW50MmQodGhpcy5fcFtiICsgMV0sIHggLSAxLCB5IC0gMSkpKSArIDEpIC8gMjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFBlcmxpbkdlbmVyYXRvci5wcm90b3R5cGUuX25vaXNlM2QgPSBmdW5jdGlvbiAoeCwgeSwgeikge1xyXG4gICAgICAgICAgICB2YXIgaW50WCA9IE1hdGguZmxvb3IoeCkgJiAweEZGO1xyXG4gICAgICAgICAgICB2YXIgaW50WSA9IE1hdGguZmxvb3IoeSkgJiAweEZGO1xyXG4gICAgICAgICAgICB2YXIgaW50WiA9IE1hdGguZmxvb3IoeikgJiAweEZGO1xyXG4gICAgICAgICAgICB4IC09IE1hdGguZmxvb3IoeCk7XHJcbiAgICAgICAgICAgIHkgLT0gTWF0aC5mbG9vcih5KTtcclxuICAgICAgICAgICAgeiAtPSBNYXRoLmZsb29yKHopO1xyXG4gICAgICAgICAgICB2YXIgZmFkZVggPSBfZmFkZSh4KTtcclxuICAgICAgICAgICAgdmFyIGZhZGVZID0gX2ZhZGUoeSk7XHJcbiAgICAgICAgICAgIHZhciBmYWRlWiA9IF9mYWRlKHopO1xyXG4gICAgICAgICAgICB2YXIgYSA9IHRoaXMuX3BbaW50WF0gKyBpbnRZO1xyXG4gICAgICAgICAgICB2YXIgYiA9IHRoaXMuX3BbaW50WCArIDFdICsgaW50WTtcclxuICAgICAgICAgICAgdmFyIGFhID0gdGhpcy5fcFthXSArIGludFo7XHJcbiAgICAgICAgICAgIHZhciBiYSA9IHRoaXMuX3BbYl0gKyBpbnRaO1xyXG4gICAgICAgICAgICB2YXIgYWIgPSB0aGlzLl9wW2EgKyAxXSArIGludFo7XHJcbiAgICAgICAgICAgIHZhciBiYiA9IHRoaXMuX3BbYiArIDFdICsgaW50WjtcclxuICAgICAgICAgICAgcmV0dXJuIChfbGVycChmYWRlWiwgX2xlcnAoZmFkZVksIF9sZXJwKGZhZGVYLCB0aGlzLl9ncmFkaWVudDNkKHRoaXMuX3BbYWFdLCB4LCB5LCB6KSwgdGhpcy5fZ3JhZGllbnQzZCh0aGlzLl9wW2JhXSwgeCAtIDEsIHksIHopKSwgX2xlcnAoZmFkZVgsIHRoaXMuX2dyYWRpZW50M2QodGhpcy5fcFthYl0sIHgsIHkgLSAxLCB6KSwgdGhpcy5fZ3JhZGllbnQzZCh0aGlzLl9wW2JiXSwgeCAtIDEsIHkgLSAxLCB6KSkpLCBfbGVycChmYWRlWSwgX2xlcnAoZmFkZVgsIHRoaXMuX2dyYWRpZW50M2QodGhpcy5fcFthYSArIDFdLCB4LCB5LCB6IC0gMSksIHRoaXMuX2dyYWRpZW50M2QodGhpcy5fcFtiYSArIDFdLCB4IC0gMSwgeSwgeiAtIDEpKSwgX2xlcnAoZmFkZVgsIHRoaXMuX2dyYWRpZW50M2QodGhpcy5fcFthYiArIDFdLCB4LCB5IC0gMSwgeiAtIDEpLCB0aGlzLl9ncmFkaWVudDNkKHRoaXMuX3BbYmIgKyAxXSwgeCAtIDEsIHkgLSAxLCB6IC0gMSkpKSkgKyAxKSAvIDI7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gUGVybGluR2VuZXJhdG9yO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuUGVybGluR2VuZXJhdG9yID0gUGVybGluR2VuZXJhdG9yO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIGhlbHBlciB0byBkcmF3IDJEIHBlcmxpbiBtYXBzIGdpdmVuIGEgcGVybGluIGdlbmVyYXRvciBhbmQgYSBmdW5jdGlvblxyXG4gICAgICovXHJcbiAgICB2YXIgUGVybGluRHJhd2VyMkQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBnZW5lcmF0b3IgLSBBbiBleGlzdGluZyBwZXJsaW4gZ2VuZXJhdG9yXHJcbiAgICAgICAgICogQHBhcmFtIGNvbG9yRmNuIC0gQSBjb2xvciBmdW5jdGlvbiB0aGF0IHRha2VzIGEgdmFsdWUgYmV0d2VlbiBbMCwgMjU1XSBkZXJpdmVkIGZyb20gdGhlIHBlcmxpbiBnZW5lcmF0b3IsIGFuZCByZXR1cm5zIGEgY29sb3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBQZXJsaW5EcmF3ZXIyRChnZW5lcmF0b3IsIGNvbG9yRmNuKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdG9yID0gZ2VuZXJhdG9yO1xyXG4gICAgICAgICAgICB0aGlzLmNvbG9yRmNuID0gY29sb3JGY247XHJcbiAgICAgICAgICAgIGlmICghY29sb3JGY24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29sb3JGY24gPSBmdW5jdGlvbiAodmFsKSB7IHJldHVybiB2YWwgPCAxMjUgPyBDb2xvcl8xOC5Db2xvci5CbGFjayA6IENvbG9yXzE4LkNvbG9yLldoaXRlOyB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYW4gaW1hZ2Ugb2YgMkQgcGVybGluIG5vaXNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUGVybGluRHJhd2VyMkQucHJvdG90eXBlLmltYWdlID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICAgICAgdmFyIGltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XHJcbiAgICAgICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICAgICAgdGhpcy5kcmF3KGN0eCwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgICAgIGltYWdlLnNyYyA9IGNhbnZhcy50b0RhdGFVUkwoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGltYWdlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBkcmF3cyBhIDJEIHBlcmxpbiBncmlkIG9uIGEgY2FudmFzIGNvbnRleHQsIG5vdCByZWNvbW1lbmRlZCB0byBiZSBjYWxsZWQgZXZlcnkgZnJhbWUgZHVlIHRvIHBlcmZvcm1hbmNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUGVybGluRHJhd2VyMkQucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHZhciBncmlkID0gdGhpcy5nZW5lcmF0b3IuZ3JpZCh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICAgICAgdmFyIGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoeCwgeSwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaGVpZ2h0OyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd2lkdGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBncmlkW2kgKyB3aWR0aCAqIGpdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gTWF0aC5mbG9vcih2YWwgKiAyNTUpICYgMHhmZjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGl4ZWwgPSAoaSArIGogKiBpbWFnZURhdGEud2lkdGgpICogNDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSB0aGlzLmNvbG9yRmNuKGMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGltYWdlRGF0YS5kYXRhW3BpeGVsXSA9IGNvbG9yLnI7XHJcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VEYXRhLmRhdGFbcGl4ZWwgKyAxXSA9IGNvbG9yLmc7XHJcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VEYXRhLmRhdGFbcGl4ZWwgKyAyXSA9IGNvbG9yLmI7XHJcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VEYXRhLmRhdGFbcGl4ZWwgKyAzXSA9IE1hdGguZmxvb3IoY29sb3IuYSAqIDI1NSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3R4LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIHgsIHkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFBlcmxpbkRyYXdlcjJEO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuUGVybGluRHJhd2VyMkQgPSBQZXJsaW5EcmF3ZXIyRDtcclxufSk7XHJcbmRlZmluZShcIk1hdGgvSW5kZXhcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJNYXRoL1Blcmxpbk5vaXNlXCIsIFwiTWF0aC9SYW5kb21cIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBQZXJsaW5Ob2lzZV8xLCBSYW5kb21fNCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBmdW5jdGlvbiBfX2V4cG9ydChtKSB7XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgX19leHBvcnQoUGVybGluTm9pc2VfMSk7XHJcbiAgICBfX2V4cG9ydChSYW5kb21fNCk7XHJcbn0pO1xyXG5kZWZpbmUoXCJQb3N0UHJvY2Vzc2luZy9JUG9zdFByb2Nlc3NvclwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG59KTtcclxuZGVmaW5lKFwiUG9zdFByb2Nlc3NpbmcvQ29sb3JCbGluZENvcnJlY3RvclwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIlV0aWwvTG9nXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgTG9nXzEwKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIHZhciBDb2xvckJsaW5kbmVzcztcclxuICAgIChmdW5jdGlvbiAoQ29sb3JCbGluZG5lc3MpIHtcclxuICAgICAgICBDb2xvckJsaW5kbmVzc1tDb2xvckJsaW5kbmVzc1tcIlByb3Rhbm9wZVwiXSA9IDBdID0gXCJQcm90YW5vcGVcIjtcclxuICAgICAgICBDb2xvckJsaW5kbmVzc1tDb2xvckJsaW5kbmVzc1tcIkRldXRlcmFub3BlXCJdID0gMV0gPSBcIkRldXRlcmFub3BlXCI7XHJcbiAgICAgICAgQ29sb3JCbGluZG5lc3NbQ29sb3JCbGluZG5lc3NbXCJUcml0YW5vcGVcIl0gPSAyXSA9IFwiVHJpdGFub3BlXCI7XHJcbiAgICB9KShDb2xvckJsaW5kbmVzcyA9IGV4cG9ydHMuQ29sb3JCbGluZG5lc3MgfHwgKGV4cG9ydHMuQ29sb3JCbGluZG5lc3MgPSB7fSkpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIHBvc3QgcHJvY2Vzc29yIGNhbiBjb3JyZWN0IGNvbG9ycyBhbmQgc2ltdWxhdGUgY29sb3IgYmxpbmRuZXNzLlxyXG4gICAgICogSXQgaXMgcG9zc2libGUgdG8gdXNlIHRoaXMgb24gZXZlcnkgZ2FtZSwgYnV0IHRoZSBnYW1lJ3MgcGVyZm9ybWFuY2VcclxuICAgICAqIHdpbGwgc3VmZmVyIG1lYXN1cmFibHkuIEl0J3MgYmV0dGVyIHRvIHVzZSBpdCBhcyBhIGhlbHBmdWwgdG9vbCB3aGlsZSBkZXZlbG9waW5nIHlvdXIgZ2FtZS5cclxuICAgICAqIFJlbWVtYmVyLCB0aGUgYmVzdCBwcmFjdGljZSBpcyB0byBkZXNpZ24gd2l0aCBjb2xvciBibGluZG5lc3MgaW4gbWluZC5cclxuICAgICAqXHJcbiAgICAgKiBbW2luY2x1ZGU6Q29sb3JCbGluZC5tZF1dXHJcbiAgICAgKi9cclxuICAgIHZhciBDb2xvckJsaW5kQ29ycmVjdG9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBDb2xvckJsaW5kQ29ycmVjdG9yKGVuZ2luZSwgc2ltdWxhdGUsIGNvbG9yTW9kZSkge1xyXG4gICAgICAgICAgICBpZiAoc2ltdWxhdGUgPT09IHZvaWQgMCkgeyBzaW11bGF0ZSA9IGZhbHNlOyB9XHJcbiAgICAgICAgICAgIGlmIChjb2xvck1vZGUgPT09IHZvaWQgMCkgeyBjb2xvck1vZGUgPSBDb2xvckJsaW5kbmVzcy5Qcm90YW5vcGU7IH1cclxuICAgICAgICAgICAgdGhpcy5lbmdpbmUgPSBlbmdpbmU7XHJcbiAgICAgICAgICAgIHRoaXMuc2ltdWxhdGUgPSBzaW11bGF0ZTtcclxuICAgICAgICAgICAgdGhpcy5jb2xvck1vZGUgPSBjb2xvck1vZGU7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZlcnRleFNoYWRlciA9ICdhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uOycgK1xyXG4gICAgICAgICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfdGV4Q29vcmQ7JyArXHJcbiAgICAgICAgICAgICAgICAndW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjsnICtcclxuICAgICAgICAgICAgICAgICd2YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDsnICtcclxuICAgICAgICAgICAgICAgICd2b2lkIG1haW4oKSB7JyArXHJcbiAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IHRoZSByZWN0YW5nbGUgZnJvbSBwaXhlbHMgdG8gMC4wIHRvIDEuMFxyXG4gICAgICAgICAgICAgICAgJ3ZlYzIgemVyb1RvT25lID0gYV9wb3NpdGlvbiAvIHVfcmVzb2x1dGlvbjsnICtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgZnJvbSAwLT4xIHRvIDAtPjJcclxuICAgICAgICAgICAgICAgICd2ZWMyIHplcm9Ub1R3byA9IHplcm9Ub09uZSAqIDIuMDsnICtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgZnJvbSAwLT4yIHRvIC0xLT4rMSAoY2xpcHNwYWNlKVxyXG4gICAgICAgICAgICAgICAgJ3ZlYzIgY2xpcFNwYWNlID0gemVyb1RvVHdvIC0gMS4wOycgK1xyXG4gICAgICAgICAgICAgICAgJ2dsX1Bvc2l0aW9uID0gdmVjNChjbGlwU3BhY2UgKiB2ZWMyKDEsIC0xKSwgMCwgMSk7JyArXHJcbiAgICAgICAgICAgICAgICAvLyBwYXNzIHRoZSB0ZXhDb29yZCB0byB0aGUgZnJhZ21lbnQgc2hhZGVyXHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgR1BVIHdpbGwgaW50ZXJwb2xhdGUgdGhpcyB2YWx1ZSBiZXR3ZWVuIHBvaW50cy5cclxuICAgICAgICAgICAgICAgICd2X3RleENvb3JkID0gYV90ZXhDb29yZDsnICtcclxuICAgICAgICAgICAgICAgICd9JztcclxuICAgICAgICAgICAgdGhpcy5fZnJhZ21lbnRTaGFkZXIgPSAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyArXHJcbiAgICAgICAgICAgICAgICAvLyBvdXIgdGV4dHVyZVxyXG4gICAgICAgICAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7JyArXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgdGV4Q29vcmRzIHBhc3NlZCBpbiBmcm9tIHRoZSB2ZXJ0ZXggc2hhZGVyLlxyXG4gICAgICAgICAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2X3RleENvb3JkOycgK1xyXG4gICAgICAgICAgICAgICAgLy8gQ29sb3IgYmxpbmQgY29udmVyc2lvbnNcclxuICAgICAgICAgICAgICAgIC8qJ21hdDMgbVs5XSA9JyArXHJcbiAgICAgICAgICAgICAgICAneycgK1xyXG4gICAgICAgICAgICAgICAgICAgJ21hdDMoMS4wLCAwLjAsIDAuMCwgIDAuMCwgMS4wLCAwLjAsICAwLjAsIDAuMCwgMS4wICApLCcgKyAvLyBub3JtYWxcclxuICAgICAgICAgICAgICAgICAgICdtYXQzKDAuNTY3LCAwLjQzMywgMC4wLCAgMC41NTgsIDAuNDQyLCAwLjAsICAwLjAsIDAuMjQyLCAwLjc1OCksJyArIC8vIHByb3Rhbm9waWFcclxuICAgICAgICAgICAgICAgICAgICdtYXQzKDAuODE3LCAwLjE4MywgMC4wLCAgMC4zMzMsIDAuNjY3LCAwLjAsICAwLjAsIDAuMTI1LDAuODc1KSwnICsgLy8gcHJvdGFub21hbHlcclxuICAgICAgICAgICAgICAgICAgICdtYXQzKDAuNjI1LCAwLjM3NSwgMC4wLCAgMC43LCAwLjMsIDAuMCwgIDAuMCwgMC4zLDAuNyAgKSwnICsgLy8gZGV1dGVyYW5vcGlhXHJcbiAgICAgICAgICAgICAgICAgICAnbWF0MygwLjgsIDAuMiwgMC4wLCAgMC4yNTgsIDAuNzQyLCAwLjAsICAwLjAsIDAuMTQyLDAuODU4KSwnICsgLy8gZGV1dGVyYW5vbWFseVxyXG4gICAgICAgICAgICAgICAgICAgJ21hdDMoMC45NSwgMC4wNSwgMC4wLCAgMC4wLCAwLjQzMywgMC41NjcsICAwLjAsIDAuNDc1LDAuNTI1KSwnICsgLy8gdHJpdGFub3BpYVxyXG4gICAgICAgICAgICAgICAgICAgJ21hdDMoMC45NjcsIDAuMDMzLCAwLjAsICAwLjAsIDAuNzMzLCAwLjI2NywgIDAuMCwgMC4xODMsMC44MTcpLCcgKyAvLyB0cml0YW5vbWFseVxyXG4gICAgICAgICAgICAgICAgICAgJ21hdDMoMC4yOTksIDAuNTg3LCAwLjExNCwgIDAuMjk5LCAwLjU4NywgMC4xMTQsICAwLjI5OSwgMC41ODcsMC4xMTQpLCcgKyAvLyBhY2hyb21hdG9wc2lhXHJcbiAgICAgICAgICAgICAgICAgICAnbWF0MygwLjYxOCwgMC4zMjAsIDAuMDYyLCAgMC4xNjMsIDAuNzc1LCAwLjA2MiwgIDAuMTYzLCAwLjMyMCwwLjUxNiknICsgIC8vIGFjaHJvbWF0b21hbHlcclxuICAgICAgICAgICAgICAgICd9OycgKyovXHJcbiAgICAgICAgICAgICAgICAndm9pZCBtYWluKCkgeycgK1xyXG4gICAgICAgICAgICAgICAgJ3ZlYzQgbyA9ICB0ZXh0dXJlMkQodV9pbWFnZSwgdl90ZXhDb29yZCk7JyArXHJcbiAgICAgICAgICAgICAgICAvLyBSR0IgdG8gTE1TIG1hdHJpeCBjb252ZXJzaW9uXHJcbiAgICAgICAgICAgICAgICAnZmxvYXQgTCA9ICgxNy44ODI0ICogby5yKSArICg0My41MTYxICogby5nKSArICg0LjExOTM1ICogby5iKTsnICtcclxuICAgICAgICAgICAgICAgICdmbG9hdCBNID0gKDMuNDU1NjUgKiBvLnIpICsgKDI3LjE1NTQgKiBvLmcpICsgKDMuODY3MTQgKiBvLmIpOycgK1xyXG4gICAgICAgICAgICAgICAgJ2Zsb2F0IFMgPSAoMC4wMjk5NTY2ICogby5yKSArICgwLjE4NDMwOSAqIG8uZykgKyAoMS40NjcwOSAqIG8uYik7JyArXHJcbiAgICAgICAgICAgICAgICAvLyBTaW11bGF0ZSBjb2xvciBibGluZG5lc3NcclxuICAgICAgICAgICAgICAgICcvL01PREUgQ09ERS8vJyArXHJcbiAgICAgICAgICAgICAgICAvKiBEZXV0ZXJhbm9wZSBmb3IgdGVzdGluZ1xyXG4gICAgICAgICAgICAgICAgJ2Zsb2F0IGwgPSAxLjAgKiBMICsgMC4wICogTSArIDAuMCAqIFM7JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAnZmxvYXQgbSA9IDAuNDk0MjA3ICogTCArIDAuMCAqIE0gKyAxLjI0ODI3ICogUzsnICtcclxuICAgICAgICAgICAgICAgICAgICAgICdmbG9hdCBzID0gMC4wICogTCArIDAuMCAqIE0gKyAxLjAgKiBTOycgKyovXHJcbiAgICAgICAgICAgICAgICAvLyBMTVMgdG8gUkdCIG1hdHJpeCBjb252ZXJzaW9uXHJcbiAgICAgICAgICAgICAgICAndmVjNCBlcnJvcjsnICtcclxuICAgICAgICAgICAgICAgICdlcnJvci5yID0gKDAuMDgwOTQ0NDQ3OSAqIGwpICsgKC0wLjEzMDUwNDQwOSAqIG0pICsgKDAuMTE2NzIxMDY2ICogcyk7JyArXHJcbiAgICAgICAgICAgICAgICAnZXJyb3IuZyA9ICgtMC4wMTAyNDg1MzM1ICogbCkgKyAoMC4wNTQwMTkzMjY2ICogbSkgKyAoLTAuMTEzNjE0NzA4ICogcyk7JyArXHJcbiAgICAgICAgICAgICAgICAnZXJyb3IuYiA9ICgtMC4wMDAzNjUyOTY5MzggKiBsKSArICgtMC4wMDQxMjE2MTQ2OSAqIG0pICsgKDAuNjkzNTExNDA1ICogcyk7JyArXHJcbiAgICAgICAgICAgICAgICAnZXJyb3IuYSA9IDEuMDsnICtcclxuICAgICAgICAgICAgICAgICd2ZWM0IGRpZmYgPSBvIC0gZXJyb3I7JyArXHJcbiAgICAgICAgICAgICAgICAndmVjNCBjb3JyZWN0aW9uOycgK1xyXG4gICAgICAgICAgICAgICAgJ2NvcnJlY3Rpb24uciA9IDAuMDsnICtcclxuICAgICAgICAgICAgICAgICdjb3JyZWN0aW9uLmcgPSAgKGRpZmYuciAqIDAuNykgKyAoZGlmZi5nICogMS4wKTsnICtcclxuICAgICAgICAgICAgICAgICdjb3JyZWN0aW9uLmIgPSAgKGRpZmYuciAqIDAuNykgKyAoZGlmZi5iICogMS4wKTsnICtcclxuICAgICAgICAgICAgICAgICdjb3JyZWN0aW9uID0gbyArIGNvcnJlY3Rpb247JyArXHJcbiAgICAgICAgICAgICAgICAnY29ycmVjdGlvbi5hID0gby5hOycgK1xyXG4gICAgICAgICAgICAgICAgJy8vU0lNVUxBVEUvLycgK1xyXG4gICAgICAgICAgICAgICAgJ30nO1xyXG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbENhbnZhcy53aWR0aCA9IGVuZ2luZS5kcmF3V2lkdGg7XHJcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsQ2FudmFzLmhlaWdodCA9IGVuZ2luZS5kcmF3SGVpZ2h0O1xyXG4gICAgICAgICAgICB0aGlzLl9nbCA9IHRoaXMuX2ludGVybmFsQ2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgeyBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IHRydWUgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Byb2dyYW0gPSB0aGlzLl9nbC5jcmVhdGVQcm9ncmFtKCk7XHJcbiAgICAgICAgICAgIHZhciBmcmFnbWVudFNoYWRlciA9IHRoaXMuX2dldFNoYWRlcignRnJhZ21lbnQnLCB0aGlzLl9nZXRGcmFnbWVudFNoYWRlckJ5TW9kZShjb2xvck1vZGUpKTtcclxuICAgICAgICAgICAgdmFyIHZlcnRleHRTaGFkZXIgPSB0aGlzLl9nZXRTaGFkZXIoJ1ZlcnRleCcsIHRoaXMuX3ZlcnRleFNoYWRlcik7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLmF0dGFjaFNoYWRlcih0aGlzLl9wcm9ncmFtLCB2ZXJ0ZXh0U2hhZGVyKTtcclxuICAgICAgICAgICAgdGhpcy5fZ2wuYXR0YWNoU2hhZGVyKHRoaXMuX3Byb2dyYW0sIGZyYWdtZW50U2hhZGVyKTtcclxuICAgICAgICAgICAgdGhpcy5fZ2wubGlua1Byb2dyYW0odGhpcy5fcHJvZ3JhbSk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcih0aGlzLl9wcm9ncmFtLCB0aGlzLl9nbC5MSU5LX1NUQVRVUykpIHtcclxuICAgICAgICAgICAgICAgIExvZ18xMC5Mb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcignVW5hYmxlIHRvIGxpbmsgc2hhZGVyIHByb2dyYW0hJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fZ2wudXNlUHJvZ3JhbSh0aGlzLl9wcm9ncmFtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgQ29sb3JCbGluZENvcnJlY3Rvci5wcm90b3R5cGUuX2dldEZyYWdtZW50U2hhZGVyQnlNb2RlID0gZnVuY3Rpb24gKGNvbG9yTW9kZSkge1xyXG4gICAgICAgICAgICB2YXIgY29kZSA9ICcnO1xyXG4gICAgICAgICAgICBpZiAoY29sb3JNb2RlID09PSBDb2xvckJsaW5kbmVzcy5Qcm90YW5vcGUpIHtcclxuICAgICAgICAgICAgICAgIGNvZGUgPVxyXG4gICAgICAgICAgICAgICAgICAgICdmbG9hdCBsID0gMC4wICogTCArIDIuMDIzNDQgKiBNICsgLTIuNTI1ODEgKiBTOycgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmxvYXQgbSA9IDAuMCAqIEwgKyAxLjAgKiBNICsgMC4wICogUzsnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Zsb2F0IHMgPSAwLjAgKiBMICsgMC4wICogTSArIDEuMCAqIFM7JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjb2xvck1vZGUgPT09IENvbG9yQmxpbmRuZXNzLkRldXRlcmFub3BlKSB7XHJcbiAgICAgICAgICAgICAgICBjb2RlID1cclxuICAgICAgICAgICAgICAgICAgICAnZmxvYXQgbCA9IDEuMCAqIEwgKyAwLjAgKiBNICsgMC4wICogUzsnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Zsb2F0IG0gPSAwLjQ5NDIwNyAqIEwgKyAwLjAgKiBNICsgMS4yNDgyNyAqIFM7JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdmbG9hdCBzID0gMC4wICogTCArIDAuMCAqIE0gKyAxLjAgKiBTOyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY29sb3JNb2RlID09PSBDb2xvckJsaW5kbmVzcy5Ucml0YW5vcGUpIHtcclxuICAgICAgICAgICAgICAgIGNvZGUgPVxyXG4gICAgICAgICAgICAgICAgICAgICdmbG9hdCBsID0gMS4wICogTCArIDAuMCAqIE0gKyAwLjAgKiBTOycgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmxvYXQgbSA9IDAuMCAqIEwgKyAxLjAgKiBNICsgMC4wICogUzsnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Zsb2F0IHMgPSAtMC4zOTU5MTMgKiBMICsgMC44MDExMDkgKiBNICsgMC4wICogUzsnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNpbXVsYXRlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mcmFnbWVudFNoYWRlciA9IHRoaXMuX2ZyYWdtZW50U2hhZGVyLnJlcGxhY2UoJy8vU0lNVUxBVEUvLycsICdnbF9GcmFnQ29sb3IgPSBlcnJvci5yZ2JhOycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZnJhZ21lbnRTaGFkZXIgPSB0aGlzLl9mcmFnbWVudFNoYWRlci5yZXBsYWNlKCcvL1NJTVVMQVRFLy8nLCAnZ2xfRnJhZ0NvbG9yID0gY29ycmVjdGlvbi5yZ2JhOycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mcmFnbWVudFNoYWRlci5yZXBsYWNlKCcvL01PREUgQ09ERS8vJywgY29kZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDb2xvckJsaW5kQ29ycmVjdG9yLnByb3RvdHlwZS5fc2V0UmVjdGFuZ2xlID0gZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICAgICAgdmFyIHgxID0geDtcclxuICAgICAgICAgICAgdmFyIHgyID0geCArIHdpZHRoO1xyXG4gICAgICAgICAgICB2YXIgeTEgPSB5O1xyXG4gICAgICAgICAgICB2YXIgeTIgPSB5ICsgaGVpZ2h0O1xyXG4gICAgICAgICAgICB0aGlzLl9nbC5idWZmZXJEYXRhKHRoaXMuX2dsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheShbXHJcbiAgICAgICAgICAgICAgICB4MSwgeTEsXHJcbiAgICAgICAgICAgICAgICB4MiwgeTEsXHJcbiAgICAgICAgICAgICAgICB4MSwgeTIsXHJcbiAgICAgICAgICAgICAgICB4MSwgeTIsXHJcbiAgICAgICAgICAgICAgICB4MiwgeTEsXHJcbiAgICAgICAgICAgICAgICB4MiwgeTJcclxuICAgICAgICAgICAgXSksIHRoaXMuX2dsLlNUQVRJQ19EUkFXKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIENvbG9yQmxpbmRDb3JyZWN0b3IucHJvdG90eXBlLl9nZXRTaGFkZXIgPSBmdW5jdGlvbiAodHlwZSwgcHJvZ3JhbSkge1xyXG4gICAgICAgICAgICB2YXIgc2hhZGVyO1xyXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ0ZyYWdtZW50Jykge1xyXG4gICAgICAgICAgICAgICAgc2hhZGVyID0gdGhpcy5fZ2wuY3JlYXRlU2hhZGVyKHRoaXMuX2dsLkZSQUdNRU5UX1NIQURFUik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ1ZlcnRleCcpIHtcclxuICAgICAgICAgICAgICAgIHNoYWRlciA9IHRoaXMuX2dsLmNyZWF0ZVNoYWRlcih0aGlzLl9nbC5WRVJURVhfU0hBREVSKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIExvZ18xMC5Mb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcignRXJyb3IgdW5rbm93biBzaGFkZXIgdHlwZScsIHR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLnNoYWRlclNvdXJjZShzaGFkZXIsIHByb2dyYW0pO1xyXG4gICAgICAgICAgICB0aGlzLl9nbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgdGhpcy5fZ2wuQ09NUElMRV9TVEFUVVMpKSB7XHJcbiAgICAgICAgICAgICAgICBMb2dfMTAuTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoJ1VuYWJsZSB0byBjb21waWxlIHNoYWRlciEnLCB0aGlzLl9nbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcikpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHNoYWRlcjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIENvbG9yQmxpbmRDb3JyZWN0b3IucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoaW1hZ2UsIG91dCkge1xyXG4gICAgICAgICAgICAvLyBsb29rIHVwIHdoZXJlIHRoZSB2ZXJ0ZXggZGF0YSBuZWVkcyB0byBnby5cclxuICAgICAgICAgICAgdmFyIHBvc2l0aW9uTG9jYXRpb24gPSB0aGlzLl9nbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl9wcm9ncmFtLCAnYV9wb3NpdGlvbicpO1xyXG4gICAgICAgICAgICB2YXIgdGV4Q29vcmRMb2NhdGlvbiA9IHRoaXMuX2dsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMuX3Byb2dyYW0sICdhX3RleENvb3JkJyk7XHJcbiAgICAgICAgICAgIHZhciB0ZXhDb29yZEJ1ZmZlciA9IHRoaXMuX2dsLmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAgICAgICAgICB0aGlzLl9nbC5iaW5kQnVmZmVyKHRoaXMuX2dsLkFSUkFZX0JVRkZFUiwgdGV4Q29vcmRCdWZmZXIpO1xyXG4gICAgICAgICAgICB0aGlzLl9nbC5idWZmZXJEYXRhKHRoaXMuX2dsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheShbXHJcbiAgICAgICAgICAgICAgICAwLjAsIDAuMCxcclxuICAgICAgICAgICAgICAgIDEuMCwgMC4wLFxyXG4gICAgICAgICAgICAgICAgMC4wLCAxLjAsXHJcbiAgICAgICAgICAgICAgICAwLjAsIDEuMCxcclxuICAgICAgICAgICAgICAgIDEuMCwgMC4wLFxyXG4gICAgICAgICAgICAgICAgMS4wLCAxLjBcclxuICAgICAgICAgICAgXSksIHRoaXMuX2dsLlNUQVRJQ19EUkFXKTtcclxuICAgICAgICAgICAgdGhpcy5fZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGV4Q29vcmRMb2NhdGlvbik7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLnZlcnRleEF0dHJpYlBvaW50ZXIodGV4Q29vcmRMb2NhdGlvbiwgMiwgdGhpcy5fZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcclxuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgdGV4dHVyZS5cclxuICAgICAgICAgICAgdmFyIHRleHR1cmUgPSB0aGlzLl9nbC5jcmVhdGVUZXh0dXJlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLmJpbmRUZXh0dXJlKHRoaXMuX2dsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xyXG4gICAgICAgICAgICAvLyBTZXQgdGhlIHBhcmFtZXRlcnMgc28gd2UgY2FuIHJlbmRlciBhbnkgc2l6ZSBpbWFnZS5cclxuICAgICAgICAgICAgdGhpcy5fZ2wudGV4UGFyYW1ldGVyaSh0aGlzLl9nbC5URVhUVVJFXzJELCB0aGlzLl9nbC5URVhUVVJFX1dSQVBfUywgdGhpcy5fZ2wuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLnRleFBhcmFtZXRlcmkodGhpcy5fZ2wuVEVYVFVSRV8yRCwgdGhpcy5fZ2wuVEVYVFVSRV9XUkFQX1QsIHRoaXMuX2dsLkNMQU1QX1RPX0VER0UpO1xyXG4gICAgICAgICAgICB0aGlzLl9nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuX2dsLlRFWFRVUkVfMkQsIHRoaXMuX2dsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdGhpcy5fZ2wuTkVBUkVTVCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLnRleFBhcmFtZXRlcmkodGhpcy5fZ2wuVEVYVFVSRV8yRCwgdGhpcy5fZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCB0aGlzLl9nbC5ORUFSRVNUKTtcclxuICAgICAgICAgICAgLy8gRmxpcCB0aGUgdGV4dHVyZSB3aGVuIHVucGFja2luZyBpbnRvIHRoZSBnbCBjb250ZXh0LCBnbCByZWFkcyB0ZXh0dXJlcyBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIgYXMgZXZlcnl0aGluZyBlbHNlIDovXHJcbiAgICAgICAgICAgIHRoaXMuX2dsLnBpeGVsU3RvcmVpKHRoaXMuX2dsLlVOUEFDS19GTElQX1lfV0VCR0wsIDEpO1xyXG4gICAgICAgICAgICAvLyBVcGxvYWQgdGhlIGltYWdlIGludG8gdGhlIHRleHR1cmUuXHJcbiAgICAgICAgICAgIHRoaXMuX2dsLnRleEltYWdlMkQodGhpcy5fZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5fZ2wuUkdCQSwgdGhpcy5fZ2wuUkdCQSwgdGhpcy5fZ2wuVU5TSUdORURfQllURSwgaW1hZ2UpO1xyXG4gICAgICAgICAgICAvLyBsb29rdXAgdW5pZm9ybXNcclxuICAgICAgICAgICAgdmFyIHJlc29sdXRpb25Mb2NhdGlvbiA9IHRoaXMuX2dsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl9wcm9ncmFtLCAndV9yZXNvbHV0aW9uJyk7XHJcbiAgICAgICAgICAgIC8vIHNldCB0aGUgcmVzb2x1dGlvblxyXG4gICAgICAgICAgICB0aGlzLl9nbC51bmlmb3JtMmYocmVzb2x1dGlvbkxvY2F0aW9uLCB0aGlzLl9pbnRlcm5hbENhbnZhcy53aWR0aCwgdGhpcy5faW50ZXJuYWxDYW52YXMuaGVpZ2h0KTtcclxuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgYnVmZmVyIGZvciB0aGUgcG9zaXRpb24gb2YgdGhlIHJlY3RhbmdsZSBjb3JuZXJzLlxyXG4gICAgICAgICAgICB2YXIgcG9zaXRpb25CdWZmZXIgPSB0aGlzLl9nbC5jcmVhdGVCdWZmZXIoKTtcclxuICAgICAgICAgICAgdGhpcy5fZ2wuYmluZEJ1ZmZlcih0aGlzLl9nbC5BUlJBWV9CVUZGRVIsIHBvc2l0aW9uQnVmZmVyKTtcclxuICAgICAgICAgICAgdGhpcy5fZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb25Mb2NhdGlvbik7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLnZlcnRleEF0dHJpYlBvaW50ZXIocG9zaXRpb25Mb2NhdGlvbiwgMiwgdGhpcy5fZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcclxuICAgICAgICAgICAgLy8gU2V0IGEgcmVjdGFuZ2xlIHRoZSBzYW1lIHNpemUgYXMgdGhlIGltYWdlLlxyXG4gICAgICAgICAgICB0aGlzLl9zZXRSZWN0YW5nbGUoMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCk7XHJcbiAgICAgICAgICAgIC8vIERyYXcgdGhlIHJlY3RhbmdsZS5cclxuICAgICAgICAgICAgdGhpcy5fZ2wuZHJhd0FycmF5cyh0aGlzLl9nbC5UUklBTkdMRVMsIDAsIDYpO1xyXG4gICAgICAgICAgICAvLyBHcmFiIHRyYW5mb3JtZWQgaW1hZ2UgZnJvbSBpbnRlcm5hbCBjYW52YXNcclxuICAgICAgICAgICAgdmFyIHBpeGVsRGF0YSA9IG5ldyBVaW50OEFycmF5KGltYWdlLndpZHRoICogaW1hZ2UuaGVpZ2h0ICogNCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLnJlYWRQaXhlbHMoMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgdGhpcy5fZ2wuUkdCQSwgdGhpcy5fZ2wuVU5TSUdORURfQllURSwgcGl4ZWxEYXRhKTtcclxuICAgICAgICAgICAgaW1hZ2UuZGF0YS5zZXQocGl4ZWxEYXRhKTtcclxuICAgICAgICAgICAgb3V0LnB1dEltYWdlRGF0YShpbWFnZSwgMCwgMCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gQ29sb3JCbGluZENvcnJlY3RvcjtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkNvbG9yQmxpbmRDb3JyZWN0b3IgPSBDb2xvckJsaW5kQ29ycmVjdG9yO1xyXG59KTtcclxuZGVmaW5lKFwiUG9zdFByb2Nlc3NpbmcvSW5kZXhcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJQb3N0UHJvY2Vzc2luZy9Db2xvckJsaW5kQ29ycmVjdG9yXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgQ29sb3JCbGluZENvcnJlY3Rvcl8xKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIGZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcclxuICAgICAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICBfX2V4cG9ydChDb2xvckJsaW5kQ29ycmVjdG9yXzEpO1xyXG59KTtcclxuZGVmaW5lKFwiUmVzb3VyY2VzL0luZGV4XCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiUmVzb3VyY2VzL1Jlc291cmNlXCIsIFwiUmVzb3VyY2VzL1NvdW5kXCIsIFwiUmVzb3VyY2VzL1RleHR1cmVcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBSZXNvdXJjZV8yLCBTb3VuZF8yLCBUZXh0dXJlXzMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIF9fZXhwb3J0KFJlc291cmNlXzIpO1xyXG4gICAgX19leHBvcnQoU291bmRfMik7XHJcbiAgICBfX2V4cG9ydChUZXh0dXJlXzMpO1xyXG59KTtcclxuZGVmaW5lKFwiSW5wdXQvR2FtZXBhZFwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkNsYXNzXCIsIFwiRXZlbnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgQ2xhc3NfNSwgRXZlbnRzXzgpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFeGNhbGlidXIgbGV2ZXJhZ2VzIHRoZSBIVE1MNSBHYW1lcGFkIEFQSSBbd2hlcmUgaXQgaXMgc3VwcG9ydGVkXShodHRwOi8vY2FuaXVzZS5jb20vI2ZlYXQ9Z2FtZXBhZClcclxuICAgICAqIHRvIHByb3ZpZGUgY29udHJvbGxlciBzdXBwb3J0IGZvciB5b3VyIGdhbWVzLlxyXG4gICAgICpcclxuICAgICAqIFtbaW5jbHVkZTpHYW1lcGFkcy5tZF1dXHJcbiAgICAgKi9cclxuICAgIHZhciBHYW1lcGFkcyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKEdhbWVwYWRzLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIEdhbWVwYWRzKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdG8gcG9sbCBmb3IgR2FtZXBhZCBpbnB1dCAoZGVmYXVsdDogYGZhbHNlYClcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmVuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IEdhbWVwYWQgQVBJIGlzIHN1cHBvcnRlZFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuc3VwcG9ydGVkID0gISFuYXZpZ2F0b3IuZ2V0R2FtZXBhZHM7XHJcbiAgICAgICAgICAgIF90aGlzLl9nYW1lUGFkVGltZVN0YW1wcyA9IFswLCAwLCAwLCAwXTtcclxuICAgICAgICAgICAgX3RoaXMuX29sZFBhZHMgPSBbXTtcclxuICAgICAgICAgICAgX3RoaXMuX3BhZHMgPSBbXTtcclxuICAgICAgICAgICAgX3RoaXMuX2luaXRTdWNjZXNzID0gZmFsc2U7XHJcbiAgICAgICAgICAgIF90aGlzLl9uYXZpZ2F0b3IgPSBuYXZpZ2F0b3I7XHJcbiAgICAgICAgICAgIF90aGlzLl9taW5pbXVtQ29uZmlndXJhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgR2FtZXBhZHMucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5zdXBwb3J0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5faW5pdFN1Y2Nlc3MpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBJbiBDaHJvbWUsIHRoaXMgd2lsbCByZXR1cm4gNCB1bmRlZmluZWQgaXRlbXMgdW50aWwgYSBidXR0b24gaXMgcHJlc3NlZFxyXG4gICAgICAgICAgICAvLyBJbiBGRiwgdGhpcyB3aWxsIG5vdCByZXR1cm4gYW55IGl0ZW1zIHVudGlsIGEgYnV0dG9uIGlzIHByZXNzZWRcclxuICAgICAgICAgICAgdGhpcy5fb2xkUGFkcyA9IHRoaXMuX2Nsb25lUGFkcyh0aGlzLl9uYXZpZ2F0b3IuZ2V0R2FtZXBhZHMoKSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9vbGRQYWRzLmxlbmd0aCAmJiB0aGlzLl9vbGRQYWRzWzBdKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0U3VjY2VzcyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIG1pbmltdW0gZ2FtZXBhZCBjb25maWd1cmF0aW9uLCBmb3IgZXhhbXBsZSB7YXhpczogNCwgYnV0dG9uczogNH0gbWVhbnNcclxuICAgICAgICAgKiB0aGlzIGdhbWUgcmVxdWlyZXMgYXQgbWluaW11bSA0IGF4aXMgaW5wdXRzIGFuZCA0IGJ1dHRvbnMsIHRoaXMgaXMgbm90IHJlc3RyaWN0aXZlXHJcbiAgICAgICAgICogYWxsIG90aGVyIGNvbnRyb2xsZXJzIHdpdGggbW9yZSBheGlzIG9yIGJ1dHRvbnMgYXJlIHZhbGlkIGFzIHdlbGwuIElmIG5vIG1pbmltdW1cclxuICAgICAgICAgKiBjb25maWd1cmF0aW9uIGlzIHNldCBhbGwgcGFkcyBhcmUgdmFsaWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgR2FtZXBhZHMucHJvdG90eXBlLnNldE1pbmltdW1HYW1lcGFkQ29uZmlndXJhdGlvbiA9IGZ1bmN0aW9uIChjb25maWcpIHtcclxuICAgICAgICAgICAgdGhpcy5fZW5hYmxlQW5kVXBkYXRlKCk7IC8vIGlmIGNvbmZpZyBpcyB1c2VkLCBpbXBsaWNpdGx5IGVuYWJsZVxyXG4gICAgICAgICAgICB0aGlzLl9taW5pbXVtQ29uZmlndXJhdGlvbiA9IGNvbmZpZztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZW4gaW1wbGljaXRseSBlbmFibGVkLCBzZXQgdGhlIGVuYWJsZWQgZmxhZyBhbmQgcnVuIGFuIHVwZGF0ZSBzbyBpbmZvcm1hdGlvbiBpcyB1cGRhdGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgR2FtZXBhZHMucHJvdG90eXBlLl9lbmFibGVBbmRVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5lbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hlY2tzIGEgbmF2aWdhdG9yIGdhbWVwYWQgYWdhaW5zdCB0aGUgbWluaW11bSBjb25maWd1cmF0aW9uIGlmIHByZXNlbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgR2FtZXBhZHMucHJvdG90eXBlLl9pc0dhbWVwYWRWYWxpZCA9IGZ1bmN0aW9uIChwYWQpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9taW5pbXVtQ29uZmlndXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgO1xyXG4gICAgICAgICAgICBpZiAoIXBhZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDtcclxuICAgICAgICAgICAgdmFyIGF4ZXNMZW5ndGggPSBwYWQuYXhlcy5maWx0ZXIoZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSAhPT0gdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgfSkubGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgYnV0dG9uTGVuZ3RoID0gcGFkLmJ1dHRvbnMuZmlsdGVyKGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgIT09IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgIH0pLmxlbmd0aDtcclxuICAgICAgICAgICAgcmV0dXJuIGF4ZXNMZW5ndGggPj0gdGhpcy5fbWluaW11bUNvbmZpZ3VyYXRpb24uYXhpcyAmJlxyXG4gICAgICAgICAgICAgICAgYnV0dG9uTGVuZ3RoID49IHRoaXMuX21pbmltdW1Db25maWd1cmF0aW9uLmJ1dHRvbnMgJiZcclxuICAgICAgICAgICAgICAgIHBhZC5jb25uZWN0ZWQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBHYW1lcGFkcy5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuYWJsZUFuZFVwZGF0ZSgpOyAvLyBpbXBsaWNpdGx5IGVuYWJsZVxyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEdhbWVwYWRzLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuYWJsZUFuZFVwZGF0ZSgpOyAvLyBpbXBsaWNpdGx5IGVuYWJsZVxyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLm9mZi5jYWxsKHRoaXMsIGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGVzIEdhbWVwYWQgc3RhdGUgYW5kIHB1Ymxpc2hlcyBHYW1lcGFkIGV2ZW50c1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEdhbWVwYWRzLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5lbmFibGVkIHx8ICF0aGlzLnN1cHBvcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdCgpO1xyXG4gICAgICAgICAgICB2YXIgZ2FtZXBhZHMgPSB0aGlzLl9uYXZpZ2F0b3IuZ2V0R2FtZXBhZHMoKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnYW1lcGFkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFnYW1lcGFkc1tpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBnYW1lcGFkID0gdGhpcy5hdChpKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3YXMgY29ubmVjdGVkLCBidXQgbm93IGlzbid0IGVtaXQgdGhlIGRpc2Nvbm5lY3QgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZ2FtZXBhZC5jb25uZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIuZW1pdCgnZGlzY29ubmVjdCcsIG5ldyBFdmVudHNfOC5HYW1lcGFkRGlzY29ubmVjdEV2ZW50KGksIGdhbWVwYWQpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgY29ubmVjdGlvbiBzdGF0dXNcclxuICAgICAgICAgICAgICAgICAgICBnYW1lcGFkLmNvbm5lY3RlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmF0KGkpLmNvbm5lY3RlZCAmJiB0aGlzLl9pc0dhbWVwYWRWYWxpZChnYW1lcGFkc1tpXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIuZW1pdCgnY29ubmVjdCcsIG5ldyBFdmVudHNfOC5HYW1lcGFkQ29ubmVjdEV2ZW50KGksIHRoaXMuYXQoaSkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGNvbm5lY3Rpb24gc3RhdHVzXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdChpKS5jb25uZWN0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgO1xyXG4gICAgICAgICAgICAgICAgLy8gT25seSBzdXBwb3J0ZWQgaW4gQ2hyb21lXHJcbiAgICAgICAgICAgICAgICBpZiAoZ2FtZXBhZHNbaV0udGltZXN0YW1wICYmIGdhbWVwYWRzW2ldLnRpbWVzdGFtcCA9PT0gdGhpcy5fZ2FtZVBhZFRpbWVTdGFtcHNbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX2dhbWVQYWRUaW1lU3RhbXBzW2ldID0gZ2FtZXBhZHNbaV0udGltZXN0YW1wO1xyXG4gICAgICAgICAgICAgICAgLy8gQWRkIHJlZmVyZW5jZSB0byBuYXZpZ2F0b3IgZ2FtZXBhZFxyXG4gICAgICAgICAgICAgICAgdGhpcy5hdChpKS5uYXZpZ2F0b3JHYW1lcGFkID0gZ2FtZXBhZHNbaV07XHJcbiAgICAgICAgICAgICAgICAvLyBCdXR0b25zXHJcbiAgICAgICAgICAgICAgICB2YXIgYiwgYmksIGEsIGFpLCB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIGZvciAoYiBpbiBCdXR0b25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmkgPSBCdXR0b25zW2JdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYmkgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnYW1lcGFkc1tpXS5idXR0b25zW2JpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBnYW1lcGFkc1tpXS5idXR0b25zW2JpXS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fb2xkUGFkc1tpXS5nZXRCdXR0b24oYmkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdhbWVwYWRzW2ldLmJ1dHRvbnNbYmldLnByZXNzZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdChpKS51cGRhdGVCdXR0b24oYmksIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdChpKS5ldmVudERpc3BhdGNoZXIuZW1pdCgnYnV0dG9uJywgbmV3IEV2ZW50c184LkdhbWVwYWRCdXR0b25FdmVudChiaSwgdmFsdWUsIHRoaXMuYXQoaSkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXQoaSkudXBkYXRlQnV0dG9uKGJpLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBBeGVzXHJcbiAgICAgICAgICAgICAgICBmb3IgKGEgaW4gQXhlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGFpID0gQXhlc1thXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFpID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGdhbWVwYWRzW2ldLmF4ZXNbYWldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX29sZFBhZHNbaV0uZ2V0QXhlcyhhaSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXQoaSkudXBkYXRlQXhlcyhhaSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdChpKS5ldmVudERpc3BhdGNoZXIuZW1pdCgnYXhpcycsIG5ldyBFdmVudHNfOC5HYW1lcGFkQXhpc0V2ZW50KGFpLCB2YWx1ZSwgdGhpcy5hdChpKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fb2xkUGFkc1tpXSA9IHRoaXMuX2Nsb25lUGFkKGdhbWVwYWRzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2FmZWx5IHJldHJpZXZlcyBhIEdhbWVwYWQgYXQgYSBzcGVjaWZpYyBpbmRleCBhbmQgY3JlYXRlcyBvbmUgaWYgaXQgZG9lc24ndCB5ZXQgZXhpc3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBHYW1lcGFkcy5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICAgICAgdGhpcy5fZW5hYmxlQW5kVXBkYXRlKCk7IC8vIGltcGxpY2l0bHkgZW5hYmxlIGdhbWVwYWRzIHdoZW4gYXQoKSBpcyBjYWxsZWQgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKGluZGV4ID49IHRoaXMuX3BhZHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhlcmUgaXMgYSBwYWQgdG8gcmV0cmlldmVcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9wYWRzLmxlbmd0aCAtIDEsIG1heCA9IGluZGV4OyBpIDwgbWF4OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYWRzLnB1c2gobmV3IEdhbWVwYWQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2xkUGFkcy5wdXNoKG5ldyBHYW1lcGFkKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYWRzW2luZGV4XTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGFsbCB2YWxpZCBnYW1lcGFkcyB0aGF0IG1lZXQgdGhlIG1pbmltdW0gY29uZmlndXJhdGlvbiByZXF1aXJlbWVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBHYW1lcGFkcy5wcm90b3R5cGUuZ2V0VmFsaWRHYW1lcGFkcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fZW5hYmxlQW5kVXBkYXRlKCk7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9wYWRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNHYW1lcGFkVmFsaWQodGhpcy5hdChpKS5uYXZpZ2F0b3JHYW1lcGFkKSAmJiB0aGlzLmF0KGkpLmNvbm5lY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuYXQoaSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgY29ubmVjdGVkIGdhbWVwYWRzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgR2FtZXBhZHMucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFkcy5maWx0ZXIoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAuY29ubmVjdGVkOyB9KS5sZW5ndGg7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBHYW1lcGFkcy5wcm90b3R5cGUuX2Nsb25lUGFkcyA9IGZ1bmN0aW9uIChwYWRzKSB7XHJcbiAgICAgICAgICAgIHZhciBhcnIgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGFyci5wdXNoKHRoaXMuX2Nsb25lUGFkKHBhZHNbaV0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYXJyO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmFzdGVzdCB3YXkgdG8gY2xvbmUgYSBrbm93biBvYmplY3QgaXMgdG8gZG8gaXQgeW91cnNlbGZcclxuICAgICAgICAgKi9cclxuICAgICAgICBHYW1lcGFkcy5wcm90b3R5cGUuX2Nsb25lUGFkID0gZnVuY3Rpb24gKHBhZCkge1xyXG4gICAgICAgICAgICB2YXIgaSwgbGVuO1xyXG4gICAgICAgICAgICB2YXIgY2xvbmVkUGFkID0gbmV3IEdhbWVwYWQoKTtcclxuICAgICAgICAgICAgaWYgKCFwYWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZWRQYWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcGFkLmJ1dHRvbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChwYWQuYnV0dG9uc1tpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsb25lZFBhZC51cGRhdGVCdXR0b24oaSwgcGFkLmJ1dHRvbnNbaV0udmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHBhZC5heGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjbG9uZWRQYWQudXBkYXRlQXhlcyhpLCBwYWQuYXhlc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNsb25lZFBhZDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBHYW1lcGFkcztcclxuICAgIH0oQ2xhc3NfNS5DbGFzcykpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbWluaW11bSB2YWx1ZSBhbiBheGlzIGhhcyB0byBtb3ZlIGJlZm9yZSBjb25zaWRlcmluZyBpdCBhIGNoYW5nZVxyXG4gICAgICovXHJcbiAgICBHYW1lcGFkcy5NaW5BeGlzTW92ZVRocmVzaG9sZCA9IDAuMDU7XHJcbiAgICBleHBvcnRzLkdhbWVwYWRzID0gR2FtZXBhZHM7XHJcbiAgICAvKipcclxuICAgICAqIEdhbWVwYWQgaG9sZHMgc3RhdGUgaW5mb3JtYXRpb24gZm9yIGEgY29ubmVjdGVkIGNvbnRyb2xsZXIuIFNlZSBbW0dhbWVwYWRzXV1cclxuICAgICAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGhhbmRsaW5nIGNvbnRyb2xsZXIgaW5wdXQuXHJcbiAgICAgKi9cclxuICAgIHZhciBHYW1lcGFkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoR2FtZXBhZCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBHYW1lcGFkKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgX3RoaXMuX2J1dHRvbnMgPSBuZXcgQXJyYXkoMTYpO1xyXG4gICAgICAgICAgICBfdGhpcy5fYXhlcyA9IG5ldyBBcnJheSg0KTtcclxuICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBfdGhpcy5fYnV0dG9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2J1dHRvbnNbaV0gPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBfdGhpcy5fYXhlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2F4ZXNbaV0gPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIGdpdmVuIGJ1dHRvbiBpcyBwcmVzc2VkXHJcbiAgICAgICAgICogQHBhcmFtIGJ1dHRvbiAgICAgVGhlIGJ1dHRvbiB0byBxdWVyeVxyXG4gICAgICAgICAqIEBwYXJhbSB0aHJlc2hvbGQgIFRoZSB0aHJlc2hvbGQgb3ZlciB3aGljaCB0aGUgYnV0dG9uIGlzIGNvbnNpZGVyZWQgdG8gYmUgcHJlc3NlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEdhbWVwYWQucHJvdG90eXBlLmlzQnV0dG9uUHJlc3NlZCA9IGZ1bmN0aW9uIChidXR0b24sIHRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICBpZiAodGhyZXNob2xkID09PSB2b2lkIDApIHsgdGhyZXNob2xkID0gMTsgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYnV0dG9uc1tidXR0b25dID49IHRocmVzaG9sZDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGdpdmVuIGJ1dHRvbiB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDFcclxuICAgICAgICAgKi9cclxuICAgICAgICBHYW1lcGFkLnByb3RvdHlwZS5nZXRCdXR0b24gPSBmdW5jdGlvbiAoYnV0dG9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9idXR0b25zW2J1dHRvbl07XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBnaXZlbiBheGlzIHZhbHVlIGJldHdlZW4gLTEgYW5kIDEuIFZhbHVlcyBiZWxvd1xyXG4gICAgICAgICAqIFtbTWluQXhpc01vdmVUaHJlc2hvbGRdXSBhcmUgY29uc2lkZXJlZCAwLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEdhbWVwYWQucHJvdG90eXBlLmdldEF4ZXMgPSBmdW5jdGlvbiAoYXhlcykge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9heGVzW2F4ZXNdO1xyXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModmFsdWUpIDwgR2FtZXBhZHMuTWluQXhpc01vdmVUaHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBHYW1lcGFkLnByb3RvdHlwZS51cGRhdGVCdXR0b24gPSBmdW5jdGlvbiAoYnV0dG9uSW5kZXgsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2J1dHRvbnNbYnV0dG9uSW5kZXhdID0gdmFsdWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBHYW1lcGFkLnByb3RvdHlwZS51cGRhdGVBeGVzID0gZnVuY3Rpb24gKGF4ZXNJbmRleCwgdmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fYXhlc1theGVzSW5kZXhdID0gdmFsdWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gR2FtZXBhZDtcclxuICAgIH0oQ2xhc3NfNS5DbGFzcykpO1xyXG4gICAgZXhwb3J0cy5HYW1lcGFkID0gR2FtZXBhZDtcclxuICAgIC8qKlxyXG4gICAgICogR2FtZXBhZCBCdXR0b25zIGVudW1lcmF0aW9uXHJcbiAgICAgKi9cclxuICAgIHZhciBCdXR0b25zO1xyXG4gICAgKGZ1bmN0aW9uIChCdXR0b25zKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmFjZSAxIGJ1dHRvbiAoZS5nLiBBKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ1dHRvbnNbQnV0dG9uc1tcIkZhY2UxXCJdID0gMF0gPSBcIkZhY2UxXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmFjZSAyIGJ1dHRvbiAoZS5nLiBCKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ1dHRvbnNbQnV0dG9uc1tcIkZhY2UyXCJdID0gMV0gPSBcIkZhY2UyXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmFjZSAzIGJ1dHRvbiAoZS5nLiBYKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ1dHRvbnNbQnV0dG9uc1tcIkZhY2UzXCJdID0gMl0gPSBcIkZhY2UzXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmFjZSA0IGJ1dHRvbiAoZS5nLiBZKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ1dHRvbnNbQnV0dG9uc1tcIkZhY2U0XCJdID0gM10gPSBcIkZhY2U0XCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTGVmdCBidW1wZXIgYnV0dG9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnV0dG9uc1tCdXR0b25zW1wiTGVmdEJ1bXBlclwiXSA9IDRdID0gXCJMZWZ0QnVtcGVyXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmlnaHQgYnVtcGVyIGJ1dHRvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ1dHRvbnNbQnV0dG9uc1tcIlJpZ2h0QnVtcGVyXCJdID0gNV0gPSBcIlJpZ2h0QnVtcGVyXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTGVmdCB0cmlnZ2VyIGJ1dHRvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ1dHRvbnNbQnV0dG9uc1tcIkxlZnRUcmlnZ2VyXCJdID0gNl0gPSBcIkxlZnRUcmlnZ2VyXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmlnaHQgdHJpZ2dlciBidXR0b25cclxuICAgICAgICAgKi9cclxuICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJSaWdodFRyaWdnZXJcIl0gPSA3XSA9IFwiUmlnaHRUcmlnZ2VyXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2VsZWN0IGJ1dHRvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ1dHRvbnNbQnV0dG9uc1tcIlNlbGVjdFwiXSA9IDhdID0gXCJTZWxlY3RcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTdGFydCBidXR0b25cclxuICAgICAgICAgKi9cclxuICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJTdGFydFwiXSA9IDldID0gXCJTdGFydFwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExlZnQgYW5hbG9nIHN0aWNrIHByZXNzIChlLmcuIEwzKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ1dHRvbnNbQnV0dG9uc1tcIkxlZnRTdGlja1wiXSA9IDEwXSA9IFwiTGVmdFN0aWNrXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmlnaHQgYW5hbG9nIHN0aWNrIHByZXNzIChlLmcuIFIzKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ1dHRvbnNbQnV0dG9uc1tcIlJpZ2h0U3RpY2tcIl0gPSAxMV0gPSBcIlJpZ2h0U3RpY2tcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBELXBhZCB1cFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ1dHRvbnNbQnV0dG9uc1tcIkRwYWRVcFwiXSA9IDEyXSA9IFwiRHBhZFVwXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRC1wYWQgZG93blxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ1dHRvbnNbQnV0dG9uc1tcIkRwYWREb3duXCJdID0gMTNdID0gXCJEcGFkRG93blwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEQtcGFkIGxlZnRcclxuICAgICAgICAgKi9cclxuICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJEcGFkTGVmdFwiXSA9IDE0XSA9IFwiRHBhZExlZnRcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBELXBhZCByaWdodFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ1dHRvbnNbQnV0dG9uc1tcIkRwYWRSaWdodFwiXSA9IDE1XSA9IFwiRHBhZFJpZ2h0XCI7XHJcbiAgICB9KShCdXR0b25zID0gZXhwb3J0cy5CdXR0b25zIHx8IChleHBvcnRzLkJ1dHRvbnMgPSB7fSkpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHYW1lcGFkIEF4ZXMgZW51bWVyYXRpb25cclxuICAgICAqL1xyXG4gICAgdmFyIEF4ZXM7XHJcbiAgICAoZnVuY3Rpb24gKEF4ZXMpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMZWZ0IGFuYWxvZ3VlIHN0aWNrIFggZGlyZWN0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQXhlc1tBeGVzW1wiTGVmdFN0aWNrWFwiXSA9IDBdID0gXCJMZWZ0U3RpY2tYXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTGVmdCBhbmFsb2d1ZSBzdGljayBZIGRpcmVjdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEF4ZXNbQXhlc1tcIkxlZnRTdGlja1lcIl0gPSAxXSA9IFwiTGVmdFN0aWNrWVwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJpZ2h0IGFuYWxvZ3VlIHN0aWNrIFggZGlyZWN0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQXhlc1tBeGVzW1wiUmlnaHRTdGlja1hcIl0gPSAyXSA9IFwiUmlnaHRTdGlja1hcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSaWdodCBhbmFsb2d1ZSBzdGljayBZIGRpcmVjdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEF4ZXNbQXhlc1tcIlJpZ2h0U3RpY2tZXCJdID0gM10gPSBcIlJpZ2h0U3RpY2tZXCI7XHJcbiAgICB9KShBeGVzID0gZXhwb3J0cy5BeGVzIHx8IChleHBvcnRzLkF4ZXMgPSB7fSkpO1xyXG59KTtcclxuZGVmaW5lKFwiSW5wdXQvUG9pbnRlclwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkVuZ2luZVwiLCBcIkV2ZW50c1wiLCBcIlVJQWN0b3JcIiwgXCJBbGdlYnJhXCIsIFwiQ2xhc3NcIiwgXCJVdGlsL1V0aWxcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBFbmdpbmVfMiwgRXZlbnRzXzksIFVJQWN0b3JfMSwgQWxnZWJyYV8yMCwgQ2xhc3NfNiwgVXRpbCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0eXBlIG9mIHBvaW50ZXIgZm9yIGEgW1tQb2ludGVyRXZlbnRdXS5cclxuICAgICAqL1xyXG4gICAgdmFyIFBvaW50ZXJUeXBlO1xyXG4gICAgKGZ1bmN0aW9uIChQb2ludGVyVHlwZSkge1xyXG4gICAgICAgIFBvaW50ZXJUeXBlW1BvaW50ZXJUeXBlW1wiVG91Y2hcIl0gPSAwXSA9IFwiVG91Y2hcIjtcclxuICAgICAgICBQb2ludGVyVHlwZVtQb2ludGVyVHlwZVtcIk1vdXNlXCJdID0gMV0gPSBcIk1vdXNlXCI7XHJcbiAgICAgICAgUG9pbnRlclR5cGVbUG9pbnRlclR5cGVbXCJQZW5cIl0gPSAyXSA9IFwiUGVuXCI7XHJcbiAgICAgICAgUG9pbnRlclR5cGVbUG9pbnRlclR5cGVbXCJVbmtub3duXCJdID0gM10gPSBcIlVua25vd25cIjtcclxuICAgIH0pKFBvaW50ZXJUeXBlID0gZXhwb3J0cy5Qb2ludGVyVHlwZSB8fCAoZXhwb3J0cy5Qb2ludGVyVHlwZSA9IHt9KSk7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtb3VzZSBidXR0b24gYmVpbmcgcHJlc3NlZC5cclxuICAgICAqL1xyXG4gICAgdmFyIFBvaW50ZXJCdXR0b247XHJcbiAgICAoZnVuY3Rpb24gKFBvaW50ZXJCdXR0b24pIHtcclxuICAgICAgICBQb2ludGVyQnV0dG9uW1BvaW50ZXJCdXR0b25bXCJMZWZ0XCJdID0gMF0gPSBcIkxlZnRcIjtcclxuICAgICAgICBQb2ludGVyQnV0dG9uW1BvaW50ZXJCdXR0b25bXCJNaWRkbGVcIl0gPSAxXSA9IFwiTWlkZGxlXCI7XHJcbiAgICAgICAgUG9pbnRlckJ1dHRvbltQb2ludGVyQnV0dG9uW1wiUmlnaHRcIl0gPSAyXSA9IFwiUmlnaHRcIjtcclxuICAgICAgICBQb2ludGVyQnV0dG9uW1BvaW50ZXJCdXR0b25bXCJVbmtub3duXCJdID0gM10gPSBcIlVua25vd25cIjtcclxuICAgIH0pKFBvaW50ZXJCdXR0b24gPSBleHBvcnRzLlBvaW50ZXJCdXR0b24gfHwgKGV4cG9ydHMuUG9pbnRlckJ1dHRvbiA9IHt9KSk7XHJcbiAgICB2YXIgV2hlZWxEZWx0YU1vZGU7XHJcbiAgICAoZnVuY3Rpb24gKFdoZWVsRGVsdGFNb2RlKSB7XHJcbiAgICAgICAgV2hlZWxEZWx0YU1vZGVbV2hlZWxEZWx0YU1vZGVbXCJQaXhlbFwiXSA9IDBdID0gXCJQaXhlbFwiO1xyXG4gICAgICAgIFdoZWVsRGVsdGFNb2RlW1doZWVsRGVsdGFNb2RlW1wiTGluZVwiXSA9IDFdID0gXCJMaW5lXCI7XHJcbiAgICAgICAgV2hlZWxEZWx0YU1vZGVbV2hlZWxEZWx0YU1vZGVbXCJQYWdlXCJdID0gMl0gPSBcIlBhZ2VcIjtcclxuICAgIH0pKFdoZWVsRGVsdGFNb2RlID0gZXhwb3J0cy5XaGVlbERlbHRhTW9kZSB8fCAoZXhwb3J0cy5XaGVlbERlbHRhTW9kZSA9IHt9KSk7XHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZXMgdGhlIHNjb3BlIG9mIGhhbmRsaW5nIG1vdXNlL3RvdWNoIGV2ZW50cy4gU2VlIFtbUG9pbnRlcnNdXSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuICAgICAqL1xyXG4gICAgdmFyIFBvaW50ZXJTY29wZTtcclxuICAgIChmdW5jdGlvbiAoUG9pbnRlclNjb3BlKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSGFuZGxlIGV2ZW50cyBvbiB0aGUgYGNhbnZhc2AgZWxlbWVudCBvbmx5LiBFdmVudHMgb3JpZ2luYXRpbmcgb3V0c2lkZSB0aGVcclxuICAgICAgICAgKiBgY2FudmFzYCB3aWxsIG5vdCBiZSBoYW5kbGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBvaW50ZXJTY29wZVtQb2ludGVyU2NvcGVbXCJDYW52YXNcIl0gPSAwXSA9IFwiQ2FudmFzXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSGFuZGxlcyBldmVudHMgb24gdGhlIGVudGlyZSBkb2N1bWVudC4gQWxsIGV2ZW50cyB3aWxsIGJlIGhhbmRsZWQgYnkgRXhjYWxpYnVyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBvaW50ZXJTY29wZVtQb2ludGVyU2NvcGVbXCJEb2N1bWVudFwiXSA9IDFdID0gXCJEb2N1bWVudFwiO1xyXG4gICAgfSkoUG9pbnRlclNjb3BlID0gZXhwb3J0cy5Qb2ludGVyU2NvcGUgfHwgKGV4cG9ydHMuUG9pbnRlclNjb3BlID0ge30pKTtcclxuICAgIC8qKlxyXG4gICAgICogQSBjb25zdGFudCB1c2VkIHRvIG5vcm1hbGl6ZSB3aGVlbCBldmVudHMgYWNyb3NzIGRpZmZlcmVudCBicm93c2Vyc1xyXG4gICAgICpcclxuICAgICAqIFRoaXMgbm9ybWFsaXphdGlvbiBmYWN0b3IgaXMgcHVsbGVkIGZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvRXZlbnRzL3doZWVsI0xpc3RlbmluZ190b190aGlzX2V2ZW50X2Fjcm9zc19icm93c2VyXHJcbiAgICAgKi9cclxuICAgIHZhciBTY3JvbGxXaGVlbE5vcm1hbGl6YXRpb25GYWN0b3IgPSAtMSAvIDQwO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQb2ludGVyIGV2ZW50c1xyXG4gICAgICpcclxuICAgICAqIFJlcHJlc2VudHMgYSBtb3VzZSwgdG91Y2gsIG9yIHN0eWx1cyBldmVudC4gU2VlIFtbUG9pbnRlcnNdXSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvblxyXG4gICAgICogaGFuZGxpbmcgcG9pbnRlciBpbnB1dC5cclxuICAgICAqXHJcbiAgICAgKiBGb3IgbW91c2UtYmFzZWQgZXZlbnRzLCB5b3UgY2FuIGluc3BlY3QgW1tQb2ludGVyRXZlbnQuYnV0dG9uXV0gdG8gc2VlIHdoYXQgYnV0dG9uIHdhcyBwcmVzc2VkLlxyXG4gICAgICovXHJcbiAgICB2YXIgUG9pbnRlckV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoUG9pbnRlckV2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBwYWdlWCAgICAgICAgVGhlIGB4YCBjb29yZGluYXRlIG9mIHRoZSBldmVudCAoaW4gZG9jdW1lbnQgY29vcmRpbmF0ZXMpXHJcbiAgICAgICAgICogQHBhcmFtIHBhZ2VZICAgICAgICBUaGUgYHlgIGNvb3JkaW5hdGUgb2YgdGhlIGV2ZW50IChpbiBkb2N1bWVudCBjb29yZGluYXRlcylcclxuICAgICAgICAgKiBAcGFyYW0gc2NyZWVuWCAgICAgIFRoZSBgeGAgY29vcmRpbmF0ZSBvZiB0aGUgZXZlbnQgKGluIHNjcmVlbiBjb29yZGluYXRlcylcclxuICAgICAgICAgKiBAcGFyYW0gc2NyZWVuWSAgICAgIFRoZSBgeWAgY29vcmRpbmF0ZSBvZiB0aGUgZXZlbnQgKGluIHNjcmVlbiBjb29yZGluYXRlcylcclxuICAgICAgICAgKiBAcGFyYW0gaW5kZXggICAgICAgIFRoZSBpbmRleCBvZiB0aGUgcG9pbnRlciAoemVyby1iYXNlZClcclxuICAgICAgICAgKiBAcGFyYW0gcG9pbnRlclR5cGUgIFRoZSB0eXBlIG9mIHBvaW50ZXJcclxuICAgICAgICAgKiBAcGFyYW0gYnV0dG9uICAgICAgIFRoZSBidXR0b24gcHJlc3NlZCAoaWYgW1tQb2ludGVyVHlwZS5Nb3VzZV1dKVxyXG4gICAgICAgICAqIEBwYXJhbSBldiAgICAgICAgICAgVGhlIHJhdyBET00gZXZlbnQgYmVpbmcgaGFuZGxlZFxyXG4gICAgICAgICAqIEBwYXJhbSBwb3MgICAgICAgICAgKFdpbGwgYmUgYWRkZWQgdG8gc2lnbmF0dXJlIGluIDAuMTQuMCByZWxlYXNlKSBUaGUgcG9zaXRpb24gb2YgdGhlIGV2ZW50IChpbiB3b3JsZCBjb29yZGluYXRlcylcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBQb2ludGVyRXZlbnQoeCwgeSwgcGFnZVgsIHBhZ2VZLCBzY3JlZW5YLCBzY3JlZW5ZLCBpbmRleCwgcG9pbnRlclR5cGUsIGJ1dHRvbiwgZXYpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMueCA9IHg7XHJcbiAgICAgICAgICAgIF90aGlzLnkgPSB5O1xyXG4gICAgICAgICAgICBfdGhpcy5wYWdlWCA9IHBhZ2VYO1xyXG4gICAgICAgICAgICBfdGhpcy5wYWdlWSA9IHBhZ2VZO1xyXG4gICAgICAgICAgICBfdGhpcy5zY3JlZW5YID0gc2NyZWVuWDtcclxuICAgICAgICAgICAgX3RoaXMuc2NyZWVuWSA9IHNjcmVlblk7XHJcbiAgICAgICAgICAgIF90aGlzLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgICAgIF90aGlzLnBvaW50ZXJUeXBlID0gcG9pbnRlclR5cGU7XHJcbiAgICAgICAgICAgIF90aGlzLmJ1dHRvbiA9IGJ1dHRvbjtcclxuICAgICAgICAgICAgX3RoaXMuZXYgPSBldjtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUG9pbnRlckV2ZW50LnByb3RvdHlwZSwgXCJwb3NcIiwge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWxnZWJyYV8yMC5WZWN0b3IodGhpcy54LCB0aGlzLnkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gUG9pbnRlckV2ZW50O1xyXG4gICAgfShFdmVudHNfOS5HYW1lRXZlbnQpKTtcclxuICAgIGV4cG9ydHMuUG9pbnRlckV2ZW50ID0gUG9pbnRlckV2ZW50O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBXaGVlbCBFdmVudHNcclxuICAgICAqXHJcbiAgICAgKiBSZXByZXNlbnRzIGEgbW91c2Ugd2hlZWwgZXZlbnQuIFNlZSBbW1BvaW50ZXJzXV0gZm9yIG1vcmUgaW5mb3JtYXRpb24gb25cclxuICAgICAqIGhhbmRsaW5nIHBvaW50IGlucHV0LlxyXG4gICAgICovXHJcbiAgICB2YXIgV2hlZWxFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFdoZWVsRXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHggICAgICAgICAgICBUaGUgYHhgIGNvb3JkaW5hdGUgb2YgdGhlIGV2ZW50IChpbiB3b3JsZCBjb29yZGluYXRlcylcclxuICAgICAgICAgKiBAcGFyYW0geSAgICAgICAgICAgIFRoZSBgeWAgY29vcmRpbmF0ZSBvZiB0aGUgZXZlbnQgKGluIHdvcmxkIGNvb3JkaW5hdGVzKVxyXG4gICAgICAgICAqIEBwYXJhbSBwYWdlWCAgICAgICAgVGhlIGB4YCBjb29yZGluYXRlIG9mIHRoZSBldmVudCAoaW4gZG9jdW1lbnQgY29vcmRpbmF0ZXMpXHJcbiAgICAgICAgICogQHBhcmFtIHBhZ2VZICAgICAgICBUaGUgYHlgIGNvb3JkaW5hdGUgb2YgdGhlIGV2ZW50IChpbiBkb2N1bWVudCBjb29yZGluYXRlcylcclxuICAgICAgICAgKiBAcGFyYW0gc2NyZWVuWCAgICAgIFRoZSBgeGAgY29vcmRpbmF0ZSBvZiB0aGUgZXZlbnQgKGluIHNjcmVlbiBjb29yZGluYXRlcylcclxuICAgICAgICAgKiBAcGFyYW0gc2NyZWVuWSAgICAgIFRoZSBgeWAgY29vcmRpbmF0ZSBvZiB0aGUgZXZlbnQgKGluIHNjcmVlbiBjb29yZGluYXRlcylcclxuICAgICAgICAgKiBAcGFyYW0gaW5kZXggICAgICAgIFRoZSBpbmRleCBvZiB0aGUgcG9pbnRlciAoemVyby1iYXNlZClcclxuICAgICAgICAgKiBAcGFyYW0gZGVsdGFYICAgICAgIFRoZSB0eXBlIG9mIHBvaW50ZXJcclxuICAgICAgICAgKiBAcGFyYW0gZGVsdGFZICAgICAgIFRoZSB0eXBlIG9mIHBvaW50ZXJcclxuICAgICAgICAgKiBAcGFyYW0gZGVsdGFaICAgICAgIFRoZSB0eXBlIG9mIHBvaW50ZXJcclxuICAgICAgICAgKiBAcGFyYW0gZGVsdGFNb2RlICAgIFRoZSB0eXBlIG9mIG1vdmVtZW50IFtbV2hlZWxEZWx0YU1vZGVdXVxyXG4gICAgICAgICAqIEBwYXJhbSBldiAgICAgICAgICAgVGhlIHJhdyBET00gZXZlbnQgYmVpbmcgaGFuZGxlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIFdoZWVsRXZlbnQoeCwgeSwgcGFnZVgsIHBhZ2VZLCBzY3JlZW5YLCBzY3JlZW5ZLCBpbmRleCwgZGVsdGFYLCBkZWx0YVksIGRlbHRhWiwgZGVsdGFNb2RlLCBldikge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy54ID0geDtcclxuICAgICAgICAgICAgX3RoaXMueSA9IHk7XHJcbiAgICAgICAgICAgIF90aGlzLnBhZ2VYID0gcGFnZVg7XHJcbiAgICAgICAgICAgIF90aGlzLnBhZ2VZID0gcGFnZVk7XHJcbiAgICAgICAgICAgIF90aGlzLnNjcmVlblggPSBzY3JlZW5YO1xyXG4gICAgICAgICAgICBfdGhpcy5zY3JlZW5ZID0gc2NyZWVuWTtcclxuICAgICAgICAgICAgX3RoaXMuaW5kZXggPSBpbmRleDtcclxuICAgICAgICAgICAgX3RoaXMuZGVsdGFYID0gZGVsdGFYO1xyXG4gICAgICAgICAgICBfdGhpcy5kZWx0YVkgPSBkZWx0YVk7XHJcbiAgICAgICAgICAgIF90aGlzLmRlbHRhWiA9IGRlbHRhWjtcclxuICAgICAgICAgICAgX3RoaXMuZGVsdGFNb2RlID0gZGVsdGFNb2RlO1xyXG4gICAgICAgICAgICBfdGhpcy5ldiA9IGV2O1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBXaGVlbEV2ZW50O1xyXG4gICAgfShFdmVudHNfOS5HYW1lRXZlbnQpKTtcclxuICAgIGV4cG9ydHMuV2hlZWxFdmVudCA9IFdoZWVsRXZlbnQ7XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXMgcG9pbnRlciBldmVudHMgKG1vdXNlLCB0b3VjaCwgc3R5bHVzLCBldGMuKSBhbmQgbm9ybWFsaXplcyB0b1xyXG4gICAgICogW1czQyBQb2ludGVyIEV2ZW50c10oaHR0cDovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy8pLlxyXG4gICAgICpcclxuICAgICAqIFtbaW5jbHVkZTpQb2ludGVycy5tZF1dXHJcbiAgICAgKi9cclxuICAgIHZhciBQb2ludGVycyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFBvaW50ZXJzLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFBvaW50ZXJzKGVuZ2luZSkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5fcG9pbnRlckRvd24gPSBbXTtcclxuICAgICAgICAgICAgX3RoaXMuX3BvaW50ZXJVcCA9IFtdO1xyXG4gICAgICAgICAgICBfdGhpcy5fcG9pbnRlck1vdmUgPSBbXTtcclxuICAgICAgICAgICAgX3RoaXMuX3BvaW50ZXJDYW5jZWwgPSBbXTtcclxuICAgICAgICAgICAgX3RoaXMuX3doZWVsID0gW107XHJcbiAgICAgICAgICAgIF90aGlzLl9wb2ludGVycyA9IFtdO1xyXG4gICAgICAgICAgICBfdGhpcy5fYWN0aXZlUG9pbnRlcnMgPSBbXTtcclxuICAgICAgICAgICAgX3RoaXMuX2VuZ2luZSA9IGVuZ2luZTtcclxuICAgICAgICAgICAgX3RoaXMuX3BvaW50ZXJzLnB1c2gobmV3IFBvaW50ZXIoKSk7XHJcbiAgICAgICAgICAgIF90aGlzLl9hY3RpdmVQb2ludGVycyA9IFstMV07XHJcbiAgICAgICAgICAgIF90aGlzLnByaW1hcnkgPSBfdGhpcy5fcG9pbnRlcnNbMF07XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgUG9pbnRlcnMucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluaXRpYWxpemVzIHBvaW50ZXIgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUG9pbnRlcnMucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldCB8fCB0aGlzLl9lbmdpbmUuY2FudmFzO1xyXG4gICAgICAgICAgICAvLyBUb3VjaCBFdmVudHNcclxuICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9oYW5kbGVUb3VjaEV2ZW50KCdkb3duJywgdGhpcy5fcG9pbnRlckRvd24pKTtcclxuICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5faGFuZGxlVG91Y2hFdmVudCgndXAnLCB0aGlzLl9wb2ludGVyVXApKTtcclxuICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX2hhbmRsZVRvdWNoRXZlbnQoJ21vdmUnLCB0aGlzLl9wb2ludGVyTW92ZSkpO1xyXG4gICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzLl9oYW5kbGVUb3VjaEV2ZW50KCdjYW5jZWwnLCB0aGlzLl9wb2ludGVyQ2FuY2VsKSk7XHJcbiAgICAgICAgICAgIC8vIFczQyBQb2ludGVyIEV2ZW50c1xyXG4gICAgICAgICAgICAvLyBDdXJyZW50OiBJRTExLCBJRTEwXHJcbiAgICAgICAgICAgIGlmICh3aW5kb3cuUG9pbnRlckV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJRTExXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmdpbmUuY2FudmFzLnN0eWxlLnRvdWNoQWN0aW9uID0gJ25vbmUnO1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgdGhpcy5faGFuZGxlUG9pbnRlckV2ZW50KCdkb3duJywgdGhpcy5fcG9pbnRlckRvd24pKTtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCB0aGlzLl9oYW5kbGVQb2ludGVyRXZlbnQoJ3VwJywgdGhpcy5fcG9pbnRlclVwKSk7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCB0aGlzLl9oYW5kbGVQb2ludGVyRXZlbnQoJ21vdmUnLCB0aGlzLl9wb2ludGVyTW92ZSkpO1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJjYW5jZWwnLCB0aGlzLl9oYW5kbGVQb2ludGVyRXZlbnQoJ2NhbmNlbCcsIHRoaXMuX3BvaW50ZXJNb3ZlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAod2luZG93Lk1TUG9pbnRlckV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJRTEwXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmdpbmUuY2FudmFzLnN0eWxlLm1zVG91Y2hBY3Rpb24gPSAnbm9uZSc7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignTVNQb2ludGVyRG93bicsIHRoaXMuX2hhbmRsZVBvaW50ZXJFdmVudCgnZG93bicsIHRoaXMuX3BvaW50ZXJEb3duKSk7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignTVNQb2ludGVyVXAnLCB0aGlzLl9oYW5kbGVQb2ludGVyRXZlbnQoJ3VwJywgdGhpcy5fcG9pbnRlclVwKSk7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignTVNQb2ludGVyTW92ZScsIHRoaXMuX2hhbmRsZVBvaW50ZXJFdmVudCgnbW92ZScsIHRoaXMuX3BvaW50ZXJNb3ZlKSk7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignTVNQb2ludGVyQ2FuY2VsJywgdGhpcy5faGFuZGxlUG9pbnRlckV2ZW50KCdjYW5jZWwnLCB0aGlzLl9wb2ludGVyTW92ZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gTW91c2UgRXZlbnRzXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5faGFuZGxlTW91c2VFdmVudCgnZG93bicsIHRoaXMuX3BvaW50ZXJEb3duKSk7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX2hhbmRsZU1vdXNlRXZlbnQoJ3VwJywgdGhpcy5fcG9pbnRlclVwKSk7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5faGFuZGxlTW91c2VFdmVudCgnbW92ZScsIHRoaXMuX3BvaW50ZXJNb3ZlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gTUROIE1vdXNlV2hlZWxFdmVudFxyXG4gICAgICAgICAgICBpZiAoJ29ud2hlZWwnIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBNb2Rlcm4gQnJvd3NlcnNcclxuICAgICAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMuX2hhbmRsZVdoZWVsRXZlbnQoJ3doZWVsJywgdGhpcy5fd2hlZWwpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkb2N1bWVudC5vbm1vdXNld2hlZWwgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2Via2l0IGFuZCBJRVxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCB0aGlzLl9oYW5kbGVXaGVlbEV2ZW50KCd3aGVlbCcsIHRoaXMuX3doZWVsKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZW1haW5pbmcgYnJvd3NlciBhbmQgb2xkZXIgRmlyZWZveFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ01vek1vdXNlUGl4ZWxTY3JvbGwnLCB0aGlzLl9oYW5kbGVXaGVlbEV2ZW50KCd3aGVlbCcsIHRoaXMuX3doZWVsKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFBvaW50ZXJzLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BvaW50ZXJVcC5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9wb2ludGVyRG93bi5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9wb2ludGVyTW92ZS5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9wb2ludGVyQ2FuY2VsLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3doZWVsLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTYWZlbHkgZ2V0cyBhIFBvaW50ZXIgYXQgYSBzcGVjaWZpYyBpbmRleCBhbmQgaW5pdGlhbGl6ZXMgb25lIGlmIGl0IGRvZXNuJ3QgeWV0IGV4aXN0XHJcbiAgICAgICAgICogQHBhcmFtIGluZGV4ICBUaGUgcG9pbnRlciBpbmRleCB0byByZXRyaWV2ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBvaW50ZXJzLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gdGhpcy5fcG9pbnRlcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhlcmUgaXMgYSBwb2ludGVyIHRvIHJldHJpZXZlXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5fcG9pbnRlcnMubGVuZ3RoIC0gMSwgbWF4ID0gaW5kZXg7IGkgPCBtYXg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ZXJzLnB1c2gobmV3IFBvaW50ZXIoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlUG9pbnRlcnMucHVzaCgtMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BvaW50ZXJzW2luZGV4XTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCBudW1iZXIgb2YgcG9pbnRlcnMgYmVpbmcgd2F0Y2hlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBvaW50ZXJzLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BvaW50ZXJzLmxlbmd0aDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByb3BvZ2F0ZXMgZXZlbnRzIHRvIGFjdG9yIGlmIG5lY2Vzc2FyeVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBvaW50ZXJzLnByb3RvdHlwZS5wcm9wb2dhdGUgPSBmdW5jdGlvbiAoYWN0b3IpIHtcclxuICAgICAgICAgICAgdmFyIGlzVUlBY3RvciA9IGFjdG9yIGluc3RhbmNlb2YgVUlBY3Rvcl8xLlVJQWN0b3I7XHJcbiAgICAgICAgICAgIHZhciBpID0gMCwgbGVuID0gdGhpcy5fcG9pbnRlclVwLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChhY3Rvci5jb250YWlucyh0aGlzLl9wb2ludGVyVXBbaV0ueCwgdGhpcy5fcG9pbnRlclVwW2ldLnksICFpc1VJQWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0b3IuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ3BvaW50ZXJ1cCcsIHRoaXMuX3BvaW50ZXJVcFtpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgICAgIGxlbiA9IHRoaXMuX3BvaW50ZXJEb3duLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChhY3Rvci5jb250YWlucyh0aGlzLl9wb2ludGVyRG93bltpXS54LCB0aGlzLl9wb2ludGVyRG93bltpXS55LCAhaXNVSUFjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdG9yLmV2ZW50RGlzcGF0Y2hlci5lbWl0KCdwb2ludGVyZG93bicsIHRoaXMuX3BvaW50ZXJEb3duW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYWN0b3IuY2FwdHVyZVBvaW50ZXIuY2FwdHVyZU1vdmVFdmVudHMpIHtcclxuICAgICAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgbGVuID0gdGhpcy5fcG9pbnRlck1vdmUubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0b3IuY29udGFpbnModGhpcy5fcG9pbnRlck1vdmVbaV0ueCwgdGhpcy5fcG9pbnRlck1vdmVbaV0ueSwgIWlzVUlBY3RvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0b3IuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ3BvaW50ZXJtb3ZlJywgdGhpcy5fcG9pbnRlck1vdmVbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgICAgbGVuID0gdGhpcy5fcG9pbnRlckNhbmNlbC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWN0b3IuY29udGFpbnModGhpcy5fcG9pbnRlckNhbmNlbFtpXS54LCB0aGlzLl9wb2ludGVyQ2FuY2VsW2ldLnksICFpc1VJQWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0b3IuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ3BvaW50ZXJjYW5jZWwnLCB0aGlzLl9wb2ludGVyQ2FuY2VsW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgICAgbGVuID0gdGhpcy5fd2hlZWwubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFjdG9yLmNvbnRhaW5zKHRoaXMuX3doZWVsW2ldLngsIHRoaXMuX3doZWVsW2ldLnksICFpc1VJQWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0b3IuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ3BvaW50ZXJ3aGVlbCcsIHRoaXMuX3doZWVsW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgUG9pbnRlcnMucHJvdG90eXBlLl9oYW5kbGVNb3VzZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgZXZlbnRBcnIpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IGUucGFnZVggLSBVdGlsLmdldFBvc2l0aW9uKF90aGlzLl9lbmdpbmUuY2FudmFzKS54O1xyXG4gICAgICAgICAgICAgICAgdmFyIHkgPSBlLnBhZ2VZIC0gVXRpbC5nZXRQb3NpdGlvbihfdGhpcy5fZW5naW5lLmNhbnZhcykueTtcclxuICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZFBvaW50ID0gX3RoaXMuX2VuZ2luZS5zY3JlZW5Ub1dvcmxkQ29vcmRpbmF0ZXMobmV3IEFsZ2VicmFfMjAuVmVjdG9yKHgsIHkpKTtcclxuICAgICAgICAgICAgICAgIHZhciBwZSA9IG5ldyBQb2ludGVyRXZlbnQodHJhbnNmb3JtZWRQb2ludC54LCB0cmFuc2Zvcm1lZFBvaW50LnksIGUucGFnZVgsIGUucGFnZVksIHgsIHksIDAsIFBvaW50ZXJUeXBlLk1vdXNlLCBlLmJ1dHRvbiwgZSk7XHJcbiAgICAgICAgICAgICAgICBldmVudEFyci5wdXNoKHBlKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmF0KDApLmV2ZW50RGlzcGF0Y2hlci5lbWl0KGV2ZW50TmFtZSwgcGUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUG9pbnRlcnMucHJvdG90eXBlLl9oYW5kbGVUb3VjaEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgZXZlbnRBcnIpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZS5jaGFuZ2VkVG91Y2hlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IF90aGlzLl9wb2ludGVycy5sZW5ndGggPiAxID8gX3RoaXMuX2dldFBvaW50ZXJJbmRleChlLmNoYW5nZWRUb3VjaGVzW2ldLmlkZW50aWZpZXIpIDogMDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IGUuY2hhbmdlZFRvdWNoZXNbaV0ucGFnZVggLSBVdGlsLmdldFBvc2l0aW9uKF90aGlzLl9lbmdpbmUuY2FudmFzKS54O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB5ID0gZS5jaGFuZ2VkVG91Y2hlc1tpXS5wYWdlWSAtIFV0aWwuZ2V0UG9zaXRpb24oX3RoaXMuX2VuZ2luZS5jYW52YXMpLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkUG9pbnQgPSBfdGhpcy5fZW5naW5lLnNjcmVlblRvV29ybGRDb29yZGluYXRlcyhuZXcgQWxnZWJyYV8yMC5WZWN0b3IoeCwgeSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwZSA9IG5ldyBQb2ludGVyRXZlbnQodHJhbnNmb3JtZWRQb2ludC54LCB0cmFuc2Zvcm1lZFBvaW50LnksIGUuY2hhbmdlZFRvdWNoZXNbaV0ucGFnZVgsIGUuY2hhbmdlZFRvdWNoZXNbaV0ucGFnZVksIHgsIHksIGluZGV4LCBQb2ludGVyVHlwZS5Ub3VjaCwgUG9pbnRlckJ1dHRvbi5Vbmtub3duLCBlKTtcclxuICAgICAgICAgICAgICAgICAgICBldmVudEFyci5wdXNoKHBlKTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdChpbmRleCkuZXZlbnREaXNwYXRjaGVyLmVtaXQoZXZlbnROYW1lLCBwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gb25seSB3aXRoIG11bHRpLXBvaW50ZXJcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX3BvaW50ZXJzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gJ3VwJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHBvaW50ZXIgSUQgZnJvbSBwb29sIHdoZW4gcG9pbnRlciBpcyBsaWZ0ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9hY3RpdmVQb2ludGVyc1tpbmRleF0gPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChldmVudE5hbWUgPT09ICdkb3duJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0IHBvaW50ZXIgSUQgdG8gZ2l2ZW4gaW5kZXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9hY3RpdmVQb2ludGVyc1tpbmRleF0gPSBlLmNoYW5nZWRUb3VjaGVzW2ldLmlkZW50aWZpZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQb2ludGVycy5wcm90b3R5cGUuX2hhbmRsZVBvaW50ZXJFdmVudCA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50QXJyKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBpbmRleCBmb3IgdGhpcyBwb2ludGVyIElEIGlmIG11bHRpLXBvaW50ZXIgaXMgYXNrZWQgZm9yXHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBfdGhpcy5fcG9pbnRlcnMubGVuZ3RoID4gMSA/IF90aGlzLl9nZXRQb2ludGVySW5kZXgoZS5wb2ludGVySWQpIDogMDtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IGUucGFnZVggLSBVdGlsLmdldFBvc2l0aW9uKF90aGlzLl9lbmdpbmUuY2FudmFzKS54O1xyXG4gICAgICAgICAgICAgICAgdmFyIHkgPSBlLnBhZ2VZIC0gVXRpbC5nZXRQb3NpdGlvbihfdGhpcy5fZW5naW5lLmNhbnZhcykueTtcclxuICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZFBvaW50ID0gX3RoaXMuX2VuZ2luZS5zY3JlZW5Ub1dvcmxkQ29vcmRpbmF0ZXMobmV3IEFsZ2VicmFfMjAuVmVjdG9yKHgsIHkpKTtcclxuICAgICAgICAgICAgICAgIHZhciBwZSA9IG5ldyBQb2ludGVyRXZlbnQodHJhbnNmb3JtZWRQb2ludC54LCB0cmFuc2Zvcm1lZFBvaW50LnksIGUucGFnZVgsIGUucGFnZVksIHgsIHksIGluZGV4LCBfdGhpcy5fc3RyaW5nVG9Qb2ludGVyVHlwZShlLnBvaW50ZXJUeXBlKSwgZS5idXR0b24sIGUpO1xyXG4gICAgICAgICAgICAgICAgZXZlbnRBcnIucHVzaChwZSk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5hdChpbmRleCkuZXZlbnREaXNwYXRjaGVyLmVtaXQoZXZlbnROYW1lLCBwZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBvbmx5IHdpdGggbXVsdGktcG9pbnRlclxyXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl9wb2ludGVycy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gJ3VwJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgcG9pbnRlciBJRCBmcm9tIHBvb2wgd2hlbiBwb2ludGVyIGlzIGxpZnRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYWN0aXZlUG9pbnRlcnNbaW5kZXhdID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50TmFtZSA9PT0gJ2Rvd24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldCBwb2ludGVyIElEIHRvIGdpdmVuIGluZGV4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9hY3RpdmVQb2ludGVyc1tpbmRleF0gPSBlLnBvaW50ZXJJZDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQb2ludGVycy5wcm90b3R5cGUuX2hhbmRsZVdoZWVsRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudEFycikge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNob3VsZCB3ZSBwcmV2ZW50IHBhZ2Ugc2Nyb2xsIGJlY2F1c2Ugb2YgdGhpcyBldmVudFxyXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl9lbmdpbmUucGFnZVNjcm9sbFByZXZlbnRpb25Nb2RlID09PSBFbmdpbmVfMi5TY3JvbGxQcmV2ZW50aW9uTW9kZS5BbGwgfHxcclxuICAgICAgICAgICAgICAgICAgICAoX3RoaXMuX2VuZ2luZS5wYWdlU2Nyb2xsUHJldmVudGlvbk1vZGUgPT09IEVuZ2luZV8yLlNjcm9sbFByZXZlbnRpb25Nb2RlLkNhbnZhcyAmJiBlLnRhcmdldCA9PT0gX3RoaXMuX2VuZ2luZS5jYW52YXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHggPSBlLnBhZ2VYIC0gVXRpbC5nZXRQb3NpdGlvbihfdGhpcy5fZW5naW5lLmNhbnZhcykueDtcclxuICAgICAgICAgICAgICAgIHZhciB5ID0gZS5wYWdlWSAtIFV0aWwuZ2V0UG9zaXRpb24oX3RoaXMuX2VuZ2luZS5jYW52YXMpLnk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWRQb2ludCA9IF90aGlzLl9lbmdpbmUuc2NyZWVuVG9Xb3JsZENvb3JkaW5hdGVzKG5ldyBBbGdlYnJhXzIwLlZlY3Rvcih4LCB5KSk7XHJcbiAgICAgICAgICAgICAgICAvLyBkZWx0YVgsIGRlbHRhWSwgYW5kIGRlbHRhWiBhcmUgdGhlIHN0YW5kYXJkIG1vZGVybiBwcm9wZXJ0aWVzXHJcbiAgICAgICAgICAgICAgICAvLyB3aGVlbERlbHRhWCwgd2hlZWxEZWx0YVksIGFyZSBsZWdhY3kgcHJvcGVydGllcyBpbiB3ZWJraXQgYnJvd3NlcnMgYW5kIG9sZGVyIElFXHJcbiAgICAgICAgICAgICAgICAvLyBlLmRldGFpbCBpcyBvbmx5IHVzZWQgaW4gb3BlcmFcclxuICAgICAgICAgICAgICAgIHZhciBkZWx0YVggPSBlLmRlbHRhWCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChlLndoZWVsRGVsdGFYICogU2Nyb2xsV2hlZWxOb3JtYWxpemF0aW9uRmFjdG9yKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIDA7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVsdGFZID0gZS5kZWx0YVkgfHxcclxuICAgICAgICAgICAgICAgICAgICAoZS53aGVlbERlbHRhWSAqIFNjcm9sbFdoZWVsTm9ybWFsaXphdGlvbkZhY3RvcikgfHxcclxuICAgICAgICAgICAgICAgICAgICAoZS53aGVlbERlbHRhICogU2Nyb2xsV2hlZWxOb3JtYWxpemF0aW9uRmFjdG9yKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGUuZGV0YWlsIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgMDtcclxuICAgICAgICAgICAgICAgIHZhciBkZWx0YVogPSBlLmRlbHRhWiB8fCAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRlbHRhTW9kZSA9IFdoZWVsRGVsdGFNb2RlLlBpeGVsO1xyXG4gICAgICAgICAgICAgICAgaWYgKGUuZGVsdGFNb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGVsdGFNb2RlID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhTW9kZSA9IFdoZWVsRGVsdGFNb2RlLkxpbmU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGUuZGVsdGFNb2RlID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhTW9kZSA9IFdoZWVsRGVsdGFNb2RlLlBhZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHdlID0gbmV3IFdoZWVsRXZlbnQodHJhbnNmb3JtZWRQb2ludC54LCB0cmFuc2Zvcm1lZFBvaW50LnksIGUucGFnZVgsIGUucGFnZVksIHgsIHksIDAsIGRlbHRhWCwgZGVsdGFZLCBkZWx0YVosIGRlbHRhTW9kZSwgZSk7XHJcbiAgICAgICAgICAgICAgICBldmVudEFyci5wdXNoKHdlKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmF0KDApLmV2ZW50RGlzcGF0Y2hlci5lbWl0KGV2ZW50TmFtZSwgd2UpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgaW5kZXggb2YgdGhlIHBvaW50ZXIgc3BlY2lmaWVkIGZvciB0aGUgZ2l2ZW4gcG9pbnRlciBJRCBvciBmaW5kcyB0aGUgbmV4dCBlbXB0eSBwb2ludGVyIHNsb3QgYXZhaWxhYmxlLlxyXG4gICAgICAgICAqIFRoaXMgaXMgcmVxdWlyZWQgYmVjYXVzZSBJRTEwLzExIHVzZXMgaW5jcmVtZW50aW5nIHBvaW50ZXIgSURzIHNvIHdlIG5lZWQgdG8gc3RvcmUgYSBtYXBwaW5nIG9mIElEID0+IGlkeFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBvaW50ZXJzLnByb3RvdHlwZS5fZ2V0UG9pbnRlckluZGV4ID0gZnVuY3Rpb24gKHBvaW50ZXJJZCkge1xyXG4gICAgICAgICAgICB2YXIgaWR4O1xyXG4gICAgICAgICAgICBpZiAoKGlkeCA9IHRoaXMuX2FjdGl2ZVBvaW50ZXJzLmluZGV4T2YocG9pbnRlcklkKSkgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkeDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2FjdGl2ZVBvaW50ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYWN0aXZlUG9pbnRlcnNbaV0gPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaWdub3JlIHBvaW50ZXIgYmVjYXVzZSBnYW1lIGlzbid0IHdhdGNoaW5nXHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFBvaW50ZXJzLnByb3RvdHlwZS5fc3RyaW5nVG9Qb2ludGVyVHlwZSA9IGZ1bmN0aW9uIChzKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAocykge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAndG91Y2gnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQb2ludGVyVHlwZS5Ub3VjaDtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ21vdXNlJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUG9pbnRlclR5cGUuTW91c2U7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdwZW4nOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQb2ludGVyVHlwZS5QZW47XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQb2ludGVyVHlwZS5Vbmtub3duO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gUG9pbnRlcnM7XHJcbiAgICB9KENsYXNzXzYuQ2xhc3MpKTtcclxuICAgIGV4cG9ydHMuUG9pbnRlcnMgPSBQb2ludGVycztcclxuICAgIC8qKlxyXG4gICAgICogQ2FwdHVyZXMgYW5kIGRpc3BhdGNoZXMgUG9pbnRlckV2ZW50c1xyXG4gICAgICovXHJcbiAgICB2YXIgUG9pbnRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFBvaW50ZXIsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gUG9pbnRlcigpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBsYXN0IHBvc2l0aW9uIG9uIHRoZSBkb2N1bWVudCB0aGlzIHBvaW50ZXIgd2FzIGF0LiBDYW4gYmUgYG51bGxgIGlmIHBvaW50ZXIgd2FzIG5ldmVyIGFjdGl2ZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmxhc3RQYWdlUG9zID0gbnVsbDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBsYXN0IHBvc2l0aW9uIG9uIHRoZSBzY3JlZW4gdGhpcyBwb2ludGVyIHdhcyBhdC4gQ2FuIGJlIGBudWxsYCBpZiBwb2ludGVyIHdhcyBuZXZlciBhY3RpdmUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5sYXN0U2NyZWVuUG9zID0gbnVsbDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBsYXN0IHBvc2l0aW9uIGluIHRoZSBnYW1lIHdvcmxkIGNvb3JkaW5hdGVzIHRoaXMgcG9pbnRlciB3YXMgYXQuIENhbiBiZSBgbnVsbGAgaWYgcG9pbnRlciB3YXMgbmV2ZXIgYWN0aXZlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMubGFzdFdvcmxkUG9zID0gbnVsbDtcclxuICAgICAgICAgICAgX3RoaXMub24oJ21vdmUnLCBfdGhpcy5fb25Qb2ludGVyTW92ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgUG9pbnRlci5wcm90b3R5cGUuX29uUG9pbnRlck1vdmUgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgdGhpcy5sYXN0V29ybGRQb3MgPSBuZXcgQWxnZWJyYV8yMC5WZWN0b3IoZXYueCwgZXYueSk7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdFBhZ2VQb3MgPSBuZXcgQWxnZWJyYV8yMC5WZWN0b3IoZXYucGFnZVgsIGV2LnBhZ2VZKTtcclxuICAgICAgICAgICAgdGhpcy5sYXN0U2NyZWVuUG9zID0gbmV3IEFsZ2VicmFfMjAuVmVjdG9yKGV2LnNjcmVlblgsIGV2LnNjcmVlblkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFBvaW50ZXI7XHJcbiAgICB9KENsYXNzXzYuQ2xhc3MpKTtcclxuICAgIGV4cG9ydHMuUG9pbnRlciA9IFBvaW50ZXI7XHJcbn0pO1xyXG5kZWZpbmUoXCJJbnB1dC9LZXlib2FyZFwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkNsYXNzXCIsIFwiRXZlbnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgQ2xhc3NfNywgRXZlbnRzXzEwKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogRW51bSByZXByZXNlbnRpbmcgaW5wdXQga2V5IGNvZGVzXHJcbiAgICAgKi9cclxuICAgIHZhciBLZXlzO1xyXG4gICAgKGZ1bmN0aW9uIChLZXlzKSB7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiTnVtMVwiXSA9IDk3XSA9IFwiTnVtMVwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIk51bTJcIl0gPSA5OF0gPSBcIk51bTJcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJOdW0zXCJdID0gOTldID0gXCJOdW0zXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiTnVtNFwiXSA9IDEwMF0gPSBcIk51bTRcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJOdW01XCJdID0gMTAxXSA9IFwiTnVtNVwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIk51bTZcIl0gPSAxMDJdID0gXCJOdW02XCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiTnVtN1wiXSA9IDEwM10gPSBcIk51bTdcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJOdW04XCJdID0gMTA0XSA9IFwiTnVtOFwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIk51bTlcIl0gPSAxMDVdID0gXCJOdW05XCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiTnVtMFwiXSA9IDk2XSA9IFwiTnVtMFwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIk51bWxvY2tcIl0gPSAxNDRdID0gXCJOdW1sb2NrXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiU2VtaWNvbG9uXCJdID0gMTg2XSA9IFwiU2VtaWNvbG9uXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiQVwiXSA9IDY1XSA9IFwiQVwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIkJcIl0gPSA2Nl0gPSBcIkJcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJDXCJdID0gNjddID0gXCJDXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiRFwiXSA9IDY4XSA9IFwiRFwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIkVcIl0gPSA2OV0gPSBcIkVcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJGXCJdID0gNzBdID0gXCJGXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiR1wiXSA9IDcxXSA9IFwiR1wiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIkhcIl0gPSA3Ml0gPSBcIkhcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJJXCJdID0gNzNdID0gXCJJXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiSlwiXSA9IDc0XSA9IFwiSlwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIktcIl0gPSA3NV0gPSBcIktcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJMXCJdID0gNzZdID0gXCJMXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiTVwiXSA9IDc3XSA9IFwiTVwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIk5cIl0gPSA3OF0gPSBcIk5cIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJPXCJdID0gNzldID0gXCJPXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiUFwiXSA9IDgwXSA9IFwiUFwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIlFcIl0gPSA4MV0gPSBcIlFcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJSXCJdID0gODJdID0gXCJSXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiU1wiXSA9IDgzXSA9IFwiU1wiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIlRcIl0gPSA4NF0gPSBcIlRcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJVXCJdID0gODVdID0gXCJVXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiVlwiXSA9IDg2XSA9IFwiVlwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIldcIl0gPSA4N10gPSBcIldcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJYXCJdID0gODhdID0gXCJYXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiWVwiXSA9IDg5XSA9IFwiWVwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIlpcIl0gPSA5MF0gPSBcIlpcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJTaGlmdFwiXSA9IDE2XSA9IFwiU2hpZnRcIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJBbHRcIl0gPSAxOF0gPSBcIkFsdFwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIlVwXCJdID0gMzhdID0gXCJVcFwiO1xyXG4gICAgICAgIEtleXNbS2V5c1tcIkRvd25cIl0gPSA0MF0gPSBcIkRvd25cIjtcclxuICAgICAgICBLZXlzW0tleXNbXCJMZWZ0XCJdID0gMzddID0gXCJMZWZ0XCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiUmlnaHRcIl0gPSAzOV0gPSBcIlJpZ2h0XCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiU3BhY2VcIl0gPSAzMl0gPSBcIlNwYWNlXCI7XHJcbiAgICAgICAgS2V5c1tLZXlzW1wiRXNjXCJdID0gMjddID0gXCJFc2NcIjtcclxuICAgIH0pKEtleXMgPSBleHBvcnRzLktleXMgfHwgKGV4cG9ydHMuS2V5cyA9IHt9KSk7XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEV2ZW50IHRocm93biBvbiBhIGdhbWUgb2JqZWN0IGZvciBhIGtleSBldmVudFxyXG4gICAgICovXHJcbiAgICB2YXIgS2V5RXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhLZXlFdmVudCwgX3N1cGVyKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0ga2V5ICBUaGUga2V5IHJlc3BvbnNpYmxlIGZvciB0aHJvd2luZyB0aGUgZXZlbnRcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBLZXlFdmVudChrZXkpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMua2V5ID0ga2V5O1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBLZXlFdmVudDtcclxuICAgIH0oRXZlbnRzXzEwLkdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5LZXlFdmVudCA9IEtleUV2ZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBQcm92aWRlcyBrZXlib2FyZCBzdXBwb3J0IGZvciBFeGNhbGlidXIuXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOktleWJvYXJkLm1kXV1cclxuICAgICAqL1xyXG4gICAgdmFyIEtleWJvYXJkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoS2V5Ym9hcmQsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gS2V5Ym9hcmQoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLl9rZXlzID0gW107XHJcbiAgICAgICAgICAgIF90aGlzLl9rZXlzVXAgPSBbXTtcclxuICAgICAgICAgICAgX3RoaXMuX2tleXNEb3duID0gW107XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgS2V5Ym9hcmQucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluaXRpYWxpemUgS2V5Ym9hcmQgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgS2V5Ym9hcmQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoZ2xvYmFsKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIGdsb2JhbCA9IGdsb2JhbCB8fCB3aW5kb3c7XHJcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2tleXMubGVuZ3RoID0gMDsgLy8gZW1wdGllcyBhcnJheSBlZmZpY2llbnRseVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8ga2V5IHVwIGlzIG9uIHdpbmRvdyBiZWNhdXNlIGNhbnZhcyBjYW5ub3QgaGF2ZSBmb2N1c1xyXG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb2RlID0gX3RoaXMuX25vcm1hbGl6ZUtleUNvZGUoZXYua2V5Q29kZSk7XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gX3RoaXMuX2tleXMuaW5kZXhPZihjb2RlKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9rZXlzLnNwbGljZShrZXksIDEpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2tleXNVcC5wdXNoKGNvZGUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleUV2ZW50ID0gbmV3IEtleUV2ZW50KGNvZGUpO1xyXG4gICAgICAgICAgICAgICAgLy8gYWxpYXMgdGhlIG9sZCBhcGksIHdlIG1heSB3YW50IHRvIGRlcHJlY2F0ZSB0aGlzIGluIHRoZSBmdXR1cmVcclxuICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50RGlzcGF0Y2hlci5lbWl0KCd1cCcsIGtleUV2ZW50KTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50RGlzcGF0Y2hlci5lbWl0KCdyZWxlYXNlJywga2V5RXZlbnQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8ga2V5IGRvd24gaXMgb24gd2luZG93IGJlY2F1c2UgY2FudmFzIGNhbm5vdCBoYXZlIGZvY3VzXHJcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29kZSA9IF90aGlzLl9ub3JtYWxpemVLZXlDb2RlKGV2LmtleUNvZGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl9rZXlzLmluZGV4T2YoY29kZSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2tleXMucHVzaChjb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fa2V5c0Rvd24ucHVzaChjb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIga2V5RXZlbnQgPSBuZXcgS2V5RXZlbnQoY29kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ2Rvd24nLCBrZXlFdmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ3ByZXNzJywga2V5RXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEtleWJvYXJkLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIFJlc2V0IGtleXNEb3duIGFuZCBrZXlzVXAgYWZ0ZXIgdXBkYXRlIGlzIGNvbXBsZXRlXHJcbiAgICAgICAgICAgIHRoaXMuX2tleXNEb3duLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2tleXNVcC5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAvLyBFbWl0IHN5bnRoZXRpYyBcImhvbGRcIiBldmVudFxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2tleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ2hvbGQnLCBuZXcgS2V5RXZlbnQodGhpcy5fa2V5c1tpXSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIGxpc3Qgb2Yga2V5cyBiZWluZyBwcmVzc2VkIGRvd25cclxuICAgICAgICAgKi9cclxuICAgICAgICBLZXlib2FyZC5wcm90b3R5cGUuZ2V0S2V5cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2tleXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZXN0cyBpZiBhIGNlcnRhaW4ga2V5IHdhcyBqdXN0IHByZXNzZWQgdGhpcyBmcmFtZS4gVGhpcyBpcyBjbGVhcmVkIGF0IHRoZSBlbmQgb2YgdGhlIHVwZGF0ZSBmcmFtZS5cclxuICAgICAgICAgKiBAcGFyYW0ga2V5IFRlc3Qgd2hldGhlciBhIGtleSB3YXMganVzdCBwcmVzc2VkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgS2V5Ym9hcmQucHJvdG90eXBlLndhc1ByZXNzZWQgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9rZXlzRG93bi5pbmRleE9mKGtleSkgPiAtMTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRlc3RzIGlmIGEgY2VydGFpbiBrZXkgaXMgaGVsZCBkb3duLiBUaGlzIGlzIHBlcnNpc3RlZCBiZXR3ZWVuIGZyYW1lcy5cclxuICAgICAgICAgKiBAcGFyYW0ga2V5ICBUZXN0IHdoZXRoZXIgYSBrZXkgaXMgaGVsZCBkb3duXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgS2V5Ym9hcmQucHJvdG90eXBlLmlzSGVsZCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2tleXMuaW5kZXhPZihrZXkpID4gLTE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZXN0cyBpZiBhIGNlcnRhaW4ga2V5IHdhcyBqdXN0IHJlbGVhc2VkIHRoaXMgZnJhbWUuIFRoaXMgaXMgY2xlYXJlZCBhdCB0aGUgZW5kIG9mIHRoZSB1cGRhdGUgZnJhbWUuXHJcbiAgICAgICAgICogQHBhcmFtIGtleSAgVGVzdCB3aGV0aGVyIGEga2V5IHdhcyBqdXN0IHJlbGVhc2VkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgS2V5Ym9hcmQucHJvdG90eXBlLndhc1JlbGVhc2VkID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fa2V5c1VwLmluZGV4T2Yoa2V5KSA+IC0xO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTm9ybWFsaXplcyBzb21lIGJyb3dzZXIgZXZlbnQga2V5IGNvZGVzIHRvIG1hcCB0byBzdGFuZGFyZCBFeGNhbGlidXIga2V5IGNvZGVzXHJcbiAgICAgICAgICogQHBhcmFtIGNvZGUgRXZlbnQga2V5Q29kZVxyXG4gICAgICAgICAqIEBzZWUgaHR0cDovL3VuaXhwYXBhLmNvbS9qcy9rZXkuaHRtbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEtleWJvYXJkLnByb3RvdHlwZS5fbm9ybWFsaXplS2V5Q29kZSA9IGZ1bmN0aW9uIChjb2RlKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gS2V5cy5TZW1pY29sb247XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gS2V5Ym9hcmQ7XHJcbiAgICB9KENsYXNzXzcuQ2xhc3MpKTtcclxuICAgIGV4cG9ydHMuS2V5Ym9hcmQgPSBLZXlib2FyZDtcclxufSk7XHJcbmRlZmluZShcIklucHV0L0lFbmdpbmVJbnB1dFwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG59KTtcclxuLyoqXHJcbiAqIFByb3ZpZGVzIHN1cHBvcnQgZm9yIG1pY2UsIGtleWJvYXJkcywgYW5kIGNvbnRyb2xsZXJzLlxyXG4gKlxyXG4gKiBbW2luY2x1ZGU6SW5wdXQubWRdXVxyXG4gKi9cclxuZGVmaW5lKFwiSW5wdXQvSW5kZXhcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJJbnB1dC9HYW1lcGFkXCIsIFwiSW5wdXQvUG9pbnRlclwiLCBcIklucHV0L0tleWJvYXJkXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgR2FtZXBhZF8xLCBQb2ludGVyXzEsIEtleWJvYXJkXzEpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogQHR5cGVkb2NcclxuICAgICAqL1xyXG4gICAgX19leHBvcnQoR2FtZXBhZF8xKTtcclxuICAgIF9fZXhwb3J0KFBvaW50ZXJfMSk7XHJcbiAgICBfX2V4cG9ydChLZXlib2FyZF8xKTtcclxufSk7XHJcbmRlZmluZShcIlV0aWwvSW5kZXhcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJVdGlsL1V0aWxcIiwgXCJVdGlsL0RyYXdVdGlsXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgVXRpbF8zLCBkcmF3VXRpbCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBmdW5jdGlvbiBfX2V4cG9ydChtKSB7XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgX19leHBvcnQoVXRpbF8zKTtcclxuICAgIGV4cG9ydHMuRHJhd1V0aWwgPSBkcmF3VXRpbDtcclxufSk7XHJcbmRlZmluZShcIlV0aWwvRGVjb3JhdG9yc1wiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIlV0aWwvTG9nXCIsIFwiVXRpbC9VdGlsXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgTG9nXzExLCBVdGlsKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogT2Jzb2xldGUgZGVjb3JhdG9yIGZvciBtYXJraW5nIEV4Y2FsaWJ1ciBtZXRob2RzIG9ic29sZXRlLCB5b3UgY2FuIG9wdGlvbmFsbHkgc3BlY2lmeSBhIGN1c3RvbSBtZXNzYWdlIGFuZC9vciBhbHRlcm5hdGUgcmVwbGFjZW1lbnRcclxuICAgICAqIG1ldGhvZCBkbyB0aGUgZGVwcmVjYXRlZCBvbmUuIEluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9qYXlwaGVscHMvY29yZS1kZWNvcmF0b3JzLmpzXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG9ic29sZXRlKG9wdGlvbnMpIHtcclxuICAgICAgICBvcHRpb25zID0gVXRpbC5leHRlbmQoe30sIHsgbWVzc2FnZTogJ1RoaXMgbWV0aG9kIHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgdmVyc2lvbnMgb2YgRXhjYWxpYnVyLicsIGFsdGVybmF0ZU1ldGhvZDogbnVsbCB9LCBvcHRpb25zKTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgcHJvcGVydHksIGRlc2NyaXB0b3IpIHtcclxuICAgICAgICAgICAgaWYgKCEodHlwZW9mIGRlc2NyaXB0b3IudmFsdWUgPT09ICdmdW5jdGlvbicgfHxcclxuICAgICAgICAgICAgICAgIHR5cGVvZiBkZXNjcmlwdG9yLmdldCA9PT0gJ2Z1bmN0aW9uJyB8fFxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIGRlc2NyaXB0b3Iuc2V0ID09PSAnZnVuY3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdPbmx5IGZ1bmN0aW9ucy9nZXR0ZXJzL3NldHRlcnMgY2FuIGJlIG1hcmtlZCBhcyBvYnNvbGV0ZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBtZXRob2RTaWduYXR1cmUgPSBcIlwiICsgKHRhcmdldC5uYW1lIHx8ICcnKSArICh0YXJnZXQubmFtZSA/ICcuJyA6ICcnKSArIHByb3BlcnR5O1xyXG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG1ldGhvZFNpZ25hdHVyZSArIFwiIGlzIG1hcmtlZCBvYnNvbGV0ZTogXCIgKyBvcHRpb25zLm1lc3NhZ2UgK1xyXG4gICAgICAgICAgICAgICAgKG9wdGlvbnMuYWx0ZXJuYXRlTWV0aG9kID8gXCIgVXNlIFwiICsgb3B0aW9ucy5hbHRlcm5hdGVNZXRob2QgKyBcIiBpbnN0ZWFkXCIgOiAnJyk7XHJcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBVdGlsLmV4dGVuZCh7fSwgZGVzY3JpcHRvcik7XHJcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBtZXRob2QudmFsdWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgTG9nXzExLkxvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4obWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3IudmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWV0aG9kO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yLmdldCkge1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kLmdldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBMb2dfMTEuTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybihtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvci5nZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3Iuc2V0KSB7XHJcbiAgICAgICAgICAgICAgICBtZXRob2Quc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIExvZ18xMS5Mb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdG9yLnNldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLm9ic29sZXRlID0gb2Jzb2xldGU7XHJcbn0pO1xyXG5kZWZpbmUoXCJVdGlsL0RldGVjdG9yXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiVXRpbC9Mb2dcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBMb2dfMTIpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGlzIHRoZSBsaXN0IG9mIGZlYXR1cmVzIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGxvZyB0aGUgc3VwcG9ydGVkXHJcbiAgICAgKiBmZWF0dXJlcyB0byB0aGUgY29uc29sZSB3aGVuIERldGVjdG9yLmxvZ0Jyb3dzZXJGZWF0dXJlcygpIGlzIGNhbGxlZC5cclxuICAgICAqL1xyXG4gICAgdmFyIFJFUE9SVEVEX0ZFQVRVUkVTID0ge1xyXG4gICAgICAgIHdlYmdsOiAnV2ViR0wnLFxyXG4gICAgICAgIHdlYmF1ZGlvOiAnV2ViQXVkaW8nLFxyXG4gICAgICAgIGdhbWVwYWRhcGk6ICdHYW1lcGFkIEFQSSdcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEV4Y2FsaWJ1ciBpbnRlcm5hbCBmZWF0dXJlIGRldGVjdGlvbiBoZWxwZXIgY2xhc3NcclxuICAgICAqL1xyXG4gICAgdmFyIERldGVjdG9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBEZXRlY3RvcigpIHtcclxuICAgICAgICAgICAgdGhpcy5fZmVhdHVyZXMgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmZhaWxlZFRlc3RzID0gW107XHJcbiAgICAgICAgICAgIC8vIGNyaXRpY2FsIGJyb3dzZXIgZmVhdHVyZXMgcmVxdWlyZWQgZm9yIGV4IHRvIHJ1blxyXG4gICAgICAgICAgICB0aGlzLl9jcml0aWNhbFRlc3RzID0ge1xyXG4gICAgICAgICAgICAgICAgLy8gVGVzdCBjYW52YXMvMmQgY29udGV4dCBzdXBwb3J0XHJcbiAgICAgICAgICAgICAgICBjYW52YXNTdXBwb3J0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gISEoZWxlbS5nZXRDb250ZXh0ICYmIGVsZW0uZ2V0Q29udGV4dCgnMmQnKSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgLy8gVGVzdCBhcnJheSBidWZmZXIgc3VwcG9ydCBleCB1c2VzIGZvciBkb3dubG9hZGluZyBiaW5hcnkgZGF0YVxyXG4gICAgICAgICAgICAgICAgYXJyYXlCdWZmZXJTdXBwb3J0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCAnLycpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4aHIucmVzcG9uc2VUeXBlID09PSAnYXJyYXlidWZmZXInO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC8vIFRlc3QgZGF0YSB1cmxzIGV4IHVzZXMgZm9yIHNwcml0ZXNcclxuICAgICAgICAgICAgICAgIGRhdGFVcmxTdXBwb3J0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYW52YXMudG9EYXRhVVJMKCdpbWFnZS9wbmcnKS5pbmRleE9mKCdkYXRhOmltYWdlL3BuZycpID09PSAwO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC8vIFRlc3Qgb2JqZWN0IHVybCBzdXBwb3J0IGZvciBsb2FkaW5nXHJcbiAgICAgICAgICAgICAgICBvYmplY3RVcmxTdXBwb3J0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgnVVJMJyBpbiB3aW5kb3cpICYmICgncmV2b2tlT2JqZWN0VVJMJyBpbiBVUkwpICYmICgnY3JlYXRlT2JqZWN0VVJMJyBpbiBVUkwpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC8vIFJHQkEgc3VwcG9ydCBmb3IgY29sb3JzXHJcbiAgICAgICAgICAgICAgICByZ2JhU3VwcG9ydDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKS5zdHlsZTtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZS5jc3NUZXh0ID0gJ2JhY2tncm91bmQtY29sb3I6cmdiYSgxNTAsMjU1LDE1MCwuNSknO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoJycgKyBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IpLmluZGV4T2YoJ3JnYmEnKSA+IC0xO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvLyB3YXJuaW5ncyBleGNhbGlidXIgcGVyZm9ybWFuY2Ugd2lsbCBiZSBkZWdyYWRlZFxyXG4gICAgICAgICAgICB0aGlzLl93YXJuaW5nVGVzdCA9IHtcclxuICAgICAgICAgICAgICAgIHdlYkF1ZGlvU3VwcG9ydDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhISh3aW5kb3cuQXVkaW9Db250ZXh0IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93Lm1vekF1ZGlvQ29udGV4dCB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cubXNBdWRpb0NvbnRleHQgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93Lm9BdWRpb0NvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHdlYmdsU3VwcG9ydDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhKGVsZW0uZ2V0Q29udGV4dCAmJiBlbGVtLmdldENvbnRleHQoJ3dlYmdsJykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLl9mZWF0dXJlcyA9IHRoaXMuX2xvYWRCcm93c2VyRmVhdHVyZXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIG1hcCBvZiBjdXJyZW50bHkgc3VwcG9ydGVkIGJyb3dzZXIgZmVhdHVyZXMuIFRoaXMgbWV0aG9kXHJcbiAgICAgICAgICogdHJlYXRzIHRoZSBmZWF0dXJlcyBhcyBhIHNpbmdsZXRvbiBhbmQgd2lsbCBvbmx5IGNhbGN1bGF0ZSBmZWF0dXJlXHJcbiAgICAgICAgICogc3VwcG9ydCBpZiBpdCBoYXMgbm90IHByZXZpb3VzbHkgYmVlbiBkb25lLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERldGVjdG9yLnByb3RvdHlwZS5nZXRCcm93c2VyRmVhdHVyZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9mZWF0dXJlcyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZmVhdHVyZXMgPSB0aGlzLl9sb2FkQnJvd3NlckZlYXR1cmVzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZlYXR1cmVzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVwb3J0IG9uIG5vbi1jcml0aWNhbCBicm93c2VyIHN1cHBvcnQgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy5cclxuICAgICAgICAgKiBVc2UgbmF0aXZlIGJyb3dzZXIgY29uc29sZSBjb2xvcnMgZm9yIHZpc2liaWxpdHkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRGV0ZWN0b3IucHJvdG90eXBlLmxvZ0Jyb3dzZXJGZWF0dXJlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG1zZyA9ICclY1NVUFBPUlRFRCBCUk9XU0VSIEZFQVRVUkVTXFxuPT09PT09PT09PT09PT09PT09PT09PT09PT0lY1xcbic7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gW1xyXG4gICAgICAgICAgICAgICAgJ2ZvbnQtd2VpZ2h0OiBib2xkOyBjb2xvcjogbmF2eScsXHJcbiAgICAgICAgICAgICAgICAnZm9udC13ZWlnaHQ6IG5vcm1hbDsgY29sb3I6IGluaGVyaXQnXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIHZhciBzdXBwb3J0ZWQgPSB0aGlzLmdldEJyb3dzZXJGZWF0dXJlcygpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmtleXMoUkVQT1JURURfRkVBVFVSRVMpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZlYXR1cmUgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydGVkW2ZlYXR1cmVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbXNnICs9ICcoJWNcXHUyNzEzJWMpJzsgLy8gKOKckylcclxuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goJ2ZvbnQtd2VpZ2h0OiBib2xkOyBjb2xvcjogZ3JlZW4nKTtcclxuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goJ2ZvbnQtd2VpZ2h0OiBub3JtYWw7IGNvbG9yOiBpbmhlcml0Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBtc2cgKz0gJyglY1xcdTI3MTclYyknOyAvLyAo4pyXKVxyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaCgnZm9udC13ZWlnaHQ6IGJvbGQ7IGNvbG9yOiByZWQnKTtcclxuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goJ2ZvbnQtd2VpZ2h0OiBub3JtYWw7IGNvbG9yOiBpbmhlcml0Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICA7XHJcbiAgICAgICAgICAgICAgICBtc2cgKz0gJyAnICsgUkVQT1JURURfRkVBVFVSRVNbZmVhdHVyZV0gKyAnXFxuJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhcmdzLnVuc2hpZnQobXNnKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJncyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFeGVjdXRlcyBzZXZlcmFsIElJRkUncyB0byBnZXQgYSBjb25zdGFudCByZWZlcmVuY2UgdG8gc3VwcG9ydGVkXHJcbiAgICAgICAgICogZmVhdHVyZXMgd2l0aGluIHRoZSBjdXJyZW50IGV4ZWN1dGlvbiBjb250ZXh0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERldGVjdG9yLnByb3RvdHlwZS5fbG9hZEJyb3dzZXJGZWF0dXJlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIC8vIElJRkUgdG8gY2hlY2sgY2FudmFzIHN1cHBvcnRcclxuICAgICAgICAgICAgICAgIGNhbnZhczogKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2NyaXRpY2FsVGVzdHMuY2FudmFzU3VwcG9ydCgpO1xyXG4gICAgICAgICAgICAgICAgfSkoKSxcclxuICAgICAgICAgICAgICAgIC8vIElJRkUgdG8gY2hlY2sgYXJyYXlidWZmZXIgc3VwcG9ydFxyXG4gICAgICAgICAgICAgICAgYXJyYXlidWZmZXI6IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9jcml0aWNhbFRlc3RzLmFycmF5QnVmZmVyU3VwcG9ydCgpO1xyXG4gICAgICAgICAgICAgICAgfSkoKSxcclxuICAgICAgICAgICAgICAgIC8vIElJRkUgdG8gY2hlY2sgZGF0YXVybCBzdXBwb3J0XHJcbiAgICAgICAgICAgICAgICBkYXRhdXJsOiAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fY3JpdGljYWxUZXN0cy5kYXRhVXJsU3VwcG9ydCgpO1xyXG4gICAgICAgICAgICAgICAgfSkoKSxcclxuICAgICAgICAgICAgICAgIC8vIElJRkUgdG8gY2hlY2sgb2JqZWN0dXJsIHN1cHBvcnRcclxuICAgICAgICAgICAgICAgIG9iamVjdHVybDogKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2NyaXRpY2FsVGVzdHMub2JqZWN0VXJsU3VwcG9ydCgpO1xyXG4gICAgICAgICAgICAgICAgfSkoKSxcclxuICAgICAgICAgICAgICAgIC8vIElJRkUgdG8gY2hlY2sgcmdiYSBzdXBwb3J0XHJcbiAgICAgICAgICAgICAgICByZ2JhOiAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fY3JpdGljYWxUZXN0cy5yZ2JhU3VwcG9ydCgpO1xyXG4gICAgICAgICAgICAgICAgfSkoKSxcclxuICAgICAgICAgICAgICAgIC8vIElJRkUgdG8gY2hlY2sgd2ViYXVkaW8gc3VwcG9ydFxyXG4gICAgICAgICAgICAgICAgd2ViYXVkaW86IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl93YXJuaW5nVGVzdC53ZWJBdWRpb1N1cHBvcnQoKTtcclxuICAgICAgICAgICAgICAgIH0pKCksXHJcbiAgICAgICAgICAgICAgICAvLyBJSUZFIHRvIGNoZWNrIHdlYmdsIHN1cHBvcnRcclxuICAgICAgICAgICAgICAgIHdlYmdsOiAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fd2FybmluZ1Rlc3Qud2ViZ2xTdXBwb3J0KCk7XHJcbiAgICAgICAgICAgICAgICB9KSgpLFxyXG4gICAgICAgICAgICAgICAgLy8gSUlGRSB0byBjaGVjayBnYW1lcGFkYXBpIHN1cHBvcnRcclxuICAgICAgICAgICAgICAgIGdhbWVwYWRhcGk6IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhbmF2aWdhdG9yLmdldEdhbWVwYWRzO1xyXG4gICAgICAgICAgICAgICAgfSkoKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRGV0ZWN0b3IucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIENyaXRpY2FsIHRlc3Qgd2lsbCBmb3IgZXggbm90IHRvIHJ1blxyXG4gICAgICAgICAgICB2YXIgZmFpbGVkQ3JpdGljYWwgPSBmYWxzZTtcclxuICAgICAgICAgICAgZm9yICh2YXIgdGVzdCBpbiB0aGlzLl9jcml0aWNhbFRlc3RzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2NyaXRpY2FsVGVzdHNbdGVzdF0uY2FsbCh0aGlzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmFpbGVkVGVzdHMucHVzaCh0ZXN0KTtcclxuICAgICAgICAgICAgICAgICAgICBMb2dfMTIuTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoJ0NyaXRpY2FsIGJyb3dzZXIgZmVhdHVyZSBtaXNzaW5nLCBFeGNhbGlidXIgcmVxdWlyZXM6JywgdGVzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZmFpbGVkQ3JpdGljYWwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmYWlsZWRDcml0aWNhbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFdhcm5pbmcgdGVzdHMgZG8gbm90IGZvciBleCB0byByZXR1cm4gZmFsc2UgdG8gY29tcGF0aWJpbGl0eVxyXG4gICAgICAgICAgICBmb3IgKHZhciB3YXJuaW5nIGluIHRoaXMuX3dhcm5pbmdUZXN0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3dhcm5pbmdUZXN0W3dhcm5pbmddKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBMb2dfMTIuTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybignV2FybmluZyBicm93c2VyIGZlYXR1cmUgbWlzc2luZywgRXhjYWxpYnVyIHdpbGwgaGF2ZSByZWR1Y2VkIHBlcmZvcm1hbmNlOicsIHdhcm5pbmcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIERldGVjdG9yO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuRGV0ZWN0b3IgPSBEZXRlY3RvcjtcclxufSk7XHJcbmRlZmluZShcIlV0aWwvU29ydGVkTGlzdFwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIHNvcnRlZCBsaXN0IGltcGxlbWVudGF0aW9uLiBOT1RFOiB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCBzZWxmLWJhbGFuY2luZ1xyXG4gICAgICovXHJcbiAgICB2YXIgU29ydGVkTGlzdCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gU29ydGVkTGlzdChnZXRDb21wYXJhYmxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dldENvbXBhcmFibGUgPSBnZXRDb21wYXJhYmxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBTb3J0ZWRMaXN0LnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmQodGhpcy5fcm9vdCwgZWxlbWVudCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTb3J0ZWRMaXN0LnByb3RvdHlwZS5fZmluZCA9IGZ1bmN0aW9uIChub2RlLCBlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9nZXRDb21wYXJhYmxlLmNhbGwoZWxlbWVudCkgPT09IG5vZGUuZ2V0S2V5KCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlLmdldERhdGEoKS5pbmRleE9mKGVsZW1lbnQpID4gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9nZXRDb21wYXJhYmxlLmNhbGwoZWxlbWVudCkgPCBub2RlLmdldEtleSgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmluZChub2RlLmdldExlZnQoKSwgZWxlbWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmluZChub2RlLmdldFJpZ2h0KCksIGVsZW1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyByZXR1cm5zIHRoZSBhcnJheSBvZiBlbGVtZW50cyBhdCBhIHNwZWNpZmljIGtleSB2YWx1ZVxyXG4gICAgICAgIFNvcnRlZExpc3QucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldCh0aGlzLl9yb290LCBrZXkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgU29ydGVkTGlzdC5wcm90b3R5cGUuX2dldCA9IGZ1bmN0aW9uIChub2RlLCBrZXkpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gbm9kZS5nZXRLZXkoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuZ2V0RGF0YSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA8IG5vZGUuZ2V0S2V5KCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXQobm9kZS5nZXRMZWZ0KCksIGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0KG5vZGUuZ2V0UmlnaHQoKSwga2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgU29ydGVkTGlzdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvb3QgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcm9vdCA9IG5ldyBCaW5hcnlUcmVlTm9kZSh0aGlzLl9nZXRDb21wYXJhYmxlLmNhbGwoZWxlbWVudCksIFtlbGVtZW50XSwgbnVsbCwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnNlcnQodGhpcy5fcm9vdCwgZWxlbWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFNvcnRlZExpc3QucHJvdG90eXBlLl9pbnNlcnQgPSBmdW5jdGlvbiAobm9kZSwgZWxlbWVudCkge1xyXG4gICAgICAgICAgICBpZiAobm9kZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZ2V0Q29tcGFyYWJsZS5jYWxsKGVsZW1lbnQpID09PSBub2RlLmdldEtleSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuZ2V0RGF0YSgpLmluZGV4T2YoZWxlbWVudCkgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIHRoZSBlbGVtZW50IHdlJ3JlIHRyeWluZyB0byBpbnNlcnQgYWxyZWFkeSBleGlzdHNcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZ2V0RGF0YSgpLnB1c2goZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2dldENvbXBhcmFibGUuY2FsbChlbGVtZW50KSA8IG5vZGUuZ2V0S2V5KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5nZXRMZWZ0KCkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnNldExlZnQobmV3IEJpbmFyeVRyZWVOb2RlKHRoaXMuX2dldENvbXBhcmFibGUuY2FsbChlbGVtZW50KSwgW2VsZW1lbnRdLCBudWxsLCBudWxsKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydChub2RlLmdldExlZnQoKSwgZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuZ2V0UmlnaHQoKSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0UmlnaHQobmV3IEJpbmFyeVRyZWVOb2RlKHRoaXMuX2dldENvbXBhcmFibGUuY2FsbChlbGVtZW50KSwgW2VsZW1lbnRdLCBudWxsLCBudWxsKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydChub2RlLmdldFJpZ2h0KCksIGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTb3J0ZWRMaXN0LnByb3RvdHlwZS5yZW1vdmVCeUNvbXBhcmFibGUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yb290ID0gdGhpcy5fcmVtb3ZlKHRoaXMuX3Jvb3QsIGVsZW1lbnQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgU29ydGVkTGlzdC5wcm90b3R5cGUuX3JlbW92ZSA9IGZ1bmN0aW9uIChub2RlLCBlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2dldENvbXBhcmFibGUuY2FsbChlbGVtZW50KSA9PT0gbm9kZS5nZXRLZXkoKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRJbmRleCA9IG5vZGUuZ2V0RGF0YSgpLmluZGV4T2YoZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgbm9kZSBjb250YWlucyB0aGUgZWxlbWVudCwgcmVtb3ZlIHRoZSBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudEluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLmdldERhdGEoKS5zcGxpY2UoZWxlbWVudEluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIHJlbW92ZWQgdGhlIGxhc3QgZWxlbWVudCBhdCB0aGlzIG5vZGUsIHJlbW92ZSB0aGUgbm9kZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmdldERhdGEoKS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIG5vZGUgaXMgYSBsZWFmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmdldExlZnQoKSA9PSBudWxsICYmIG5vZGUuZ2V0UmlnaHQoKSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlLmdldExlZnQoKSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5nZXRSaWdodCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUuZ2V0UmlnaHQoKSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5nZXRMZWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgbm9kZSBoYXMgMiBjaGlsZHJlblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IHRoaXMuX2ZpbmRNaW5Ob2RlKG5vZGUuZ2V0UmlnaHQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0S2V5KHRlbXAuZ2V0S2V5KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnNldERhdGEodGVtcC5nZXREYXRhKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnNldFJpZ2h0KHRoaXMuX2NsZWFudXAobm9kZS5nZXRSaWdodCgpLCB0ZW1wKSk7IC8vXCJjbGVhbnVwIG5vZGVzXCIgKG1vdmUgdGhlbSB1cCByZWN1cnNpdmVseSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHByZXZlbnRzIHRoZSBub2RlIGZyb20gYmVpbmcgcmVtb3ZlZCBzaW5jZSBpdCBzdGlsbCBjb250YWlucyBlbGVtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fZ2V0Q29tcGFyYWJsZS5jYWxsKGVsZW1lbnQpIDwgbm9kZS5nZXRLZXkoKSkge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5zZXRMZWZ0KHRoaXMuX3JlbW92ZShub2RlLmdldExlZnQoKSwgZWxlbWVudCkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLnNldFJpZ2h0KHRoaXMuX3JlbW92ZShub2RlLmdldFJpZ2h0KCksIGVsZW1lbnQpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gY2FsbGVkIG9uY2Ugd2UgaGF2ZSBzdWNjZXNzZnVsbHkgcmVtb3ZlZCB0aGUgZWxlbWVudCB3ZSB3YW50ZWQsIHJlY3Vyc2l2ZWx5IGNvcnJlY3RzIHRoZSBwYXJ0IG9mIHRoZSB0cmVlIGJlbG93IHRoZSByZW1vdmVkIG5vZGVcclxuICAgICAgICBTb3J0ZWRMaXN0LnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uIChub2RlLCBlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBjb21wYXJhYmxlID0gZWxlbWVudC5nZXRLZXkoKTtcclxuICAgICAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY29tcGFyYWJsZSA9PT0gbm9kZS5nZXRLZXkoKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIG5vZGUgaXMgYSBsZWFmXHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5nZXRMZWZ0KCkgPT0gbnVsbCAmJiBub2RlLmdldFJpZ2h0KCkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5nZXRMZWZ0KCkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmdldFJpZ2h0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlLmdldFJpZ2h0KCkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmdldExlZnQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGlmIG5vZGUgaGFzIDIgY2hpbGRyZW5cclxuICAgICAgICAgICAgICAgIHZhciB0ZW1wID0gdGhpcy5fZmluZE1pbk5vZGUobm9kZS5nZXRSaWdodCgpKTtcclxuICAgICAgICAgICAgICAgIG5vZGUuc2V0S2V5KHRlbXAuZ2V0S2V5KCkpO1xyXG4gICAgICAgICAgICAgICAgbm9kZS5zZXREYXRhKHRlbXAuZ2V0RGF0YSgpKTtcclxuICAgICAgICAgICAgICAgIG5vZGUuc2V0UmlnaHQodGhpcy5fY2xlYW51cChub2RlLmdldFJpZ2h0KCksIHRlbXApKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2dldENvbXBhcmFibGUuY2FsbChlbGVtZW50KSA8IG5vZGUuZ2V0S2V5KCkpIHtcclxuICAgICAgICAgICAgICAgIG5vZGUuc2V0TGVmdCh0aGlzLl9jbGVhbnVwKG5vZGUuZ2V0TGVmdCgpLCBlbGVtZW50KSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5vZGUuc2V0UmlnaHQodGhpcy5fY2xlYW51cChub2RlLmdldFJpZ2h0KCksIGVsZW1lbnQpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTb3J0ZWRMaXN0LnByb3RvdHlwZS5fZmluZE1pbk5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IG5vZGU7XHJcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50LmdldExlZnQoKSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5nZXRMZWZ0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTb3J0ZWRMaXN0LnByb3RvdHlwZS5saXN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9saXN0KHRoaXMuX3Jvb3QsIHJlc3VsdHMpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNvcnRlZExpc3QucHJvdG90eXBlLl9saXN0ID0gZnVuY3Rpb24gKHRyZWVOb2RlLCByZXN1bHRzKSB7XHJcbiAgICAgICAgICAgIGlmICh0cmVlTm9kZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0KHRyZWVOb2RlLmdldExlZnQoKSwgcmVzdWx0cyk7XHJcbiAgICAgICAgICAgICAgICB0cmVlTm9kZS5nZXREYXRhKCkuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdCh0cmVlTm9kZS5nZXRSaWdodCgpLCByZXN1bHRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFNvcnRlZExpc3Q7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5Tb3J0ZWRMaXN0ID0gU29ydGVkTGlzdDtcclxuICAgIC8qKlxyXG4gICAgICogQSB0cmVlIG5vZGUgcGFydCBvZiBbW1NvcnRlZExpc3RdXVxyXG4gICAgICovXHJcbiAgICB2YXIgQmluYXJ5VHJlZU5vZGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIEJpbmFyeVRyZWVOb2RlKGtleSwgZGF0YSwgbGVmdCwgcmlnaHQpIHtcclxuICAgICAgICAgICAgdGhpcy5fa2V5ID0ga2V5O1xyXG4gICAgICAgICAgICB0aGlzLl9kYXRhID0gZGF0YTtcclxuICAgICAgICAgICAgdGhpcy5fbGVmdCA9IGxlZnQ7XHJcbiAgICAgICAgICAgIHRoaXMuX3JpZ2h0ID0gcmlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEJpbmFyeVRyZWVOb2RlLnByb3RvdHlwZS5nZXRLZXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9rZXk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBCaW5hcnlUcmVlTm9kZS5wcm90b3R5cGUuc2V0S2V5ID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICB0aGlzLl9rZXkgPSBrZXk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBCaW5hcnlUcmVlTm9kZS5wcm90b3R5cGUuZ2V0RGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBCaW5hcnlUcmVlTm9kZS5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQmluYXJ5VHJlZU5vZGUucHJvdG90eXBlLmdldExlZnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZWZ0O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQmluYXJ5VHJlZU5vZGUucHJvdG90eXBlLnNldExlZnQgPSBmdW5jdGlvbiAobGVmdCkge1xyXG4gICAgICAgICAgICB0aGlzLl9sZWZ0ID0gbGVmdDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEJpbmFyeVRyZWVOb2RlLnByb3RvdHlwZS5nZXRSaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JpZ2h0O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQmluYXJ5VHJlZU5vZGUucHJvdG90eXBlLnNldFJpZ2h0ID0gZnVuY3Rpb24gKHJpZ2h0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JpZ2h0ID0gcmlnaHQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gQmluYXJ5VHJlZU5vZGU7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5CaW5hcnlUcmVlTm9kZSA9IEJpbmFyeVRyZWVOb2RlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBNb2NrIGVsZW1lbnQgZm9yIHRlc3RpbmdcclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgdmFyIE1vY2tlZEVsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIE1vY2tlZEVsZW1lbnQoa2V5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2tleSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2tleSA9IGtleTtcclxuICAgICAgICB9XHJcbiAgICAgICAgTW9ja2VkRWxlbWVudC5wcm90b3R5cGUuZ2V0VGhlS2V5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fa2V5O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgTW9ja2VkRWxlbWVudC5wcm90b3R5cGUuc2V0S2V5ID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICB0aGlzLl9rZXkgPSBrZXk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gTW9ja2VkRWxlbWVudDtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLk1vY2tlZEVsZW1lbnQgPSBNb2NrZWRFbGVtZW50O1xyXG59KTtcclxuZGVmaW5lKFwiSW5kZXhcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJBY3RvclwiLCBcIkFsZ2VicmFcIiwgXCJDYW1lcmFcIiwgXCJDbGFzc1wiLCBcIkNvbmZpZ3VyYWJsZVwiLCBcIkRlYnVnXCIsIFwiRW5naW5lXCIsIFwiRXZlbnREaXNwYXRjaGVyXCIsIFwiRXZlbnRzXCIsIFwiR3JvdXBcIiwgXCJMYWJlbFwiLCBcIkxvYWRlclwiLCBcIlBhcnRpY2xlc1wiLCBcIlBoeXNpY3NcIiwgXCJQcm9taXNlc1wiLCBcIlNjZW5lXCIsIFwiVGlsZU1hcFwiLCBcIlRpbWVyXCIsIFwiVHJpZ2dlclwiLCBcIlVJQWN0b3JcIiwgXCJBY3Rpb25zL0luZGV4XCIsIFwiQ29sbGlzaW9uL0luZGV4XCIsIFwiRHJhd2luZy9JbmRleFwiLCBcIk1hdGgvSW5kZXhcIiwgXCJQb3N0UHJvY2Vzc2luZy9JbmRleFwiLCBcIlJlc291cmNlcy9JbmRleFwiLCBcIkV2ZW50c1wiLCBcIklucHV0L0luZGV4XCIsIFwiVHJhaXRzL0luZGV4XCIsIFwiVXRpbC9JbmRleFwiLCBcIlV0aWwvRGVjb3JhdG9yc1wiLCBcIlV0aWwvRGV0ZWN0b3JcIiwgXCJVdGlsL0N1bGxpbmdCb3hcIiwgXCJVdGlsL0Vhc2luZ0Z1bmN0aW9uc1wiLCBcIlV0aWwvTG9nXCIsIFwiVXRpbC9Tb3J0ZWRMaXN0XCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgQWN0b3JfMTEsIEFsZ2VicmFfMjEsIENhbWVyYV8xLCBDbGFzc184LCBDb25maWd1cmFibGVfNywgRGVidWdfMSwgRW5naW5lXzMsIEV2ZW50RGlzcGF0Y2hlcl8yLCBFdmVudHNfMTEsIEdyb3VwXzEsIExhYmVsXzIsIExvYWRlcl8xLCBQYXJ0aWNsZXNfMSwgUGh5c2ljc18xMSwgUHJvbWlzZXNfNywgU2NlbmVfMSwgVGlsZU1hcF8xLCBUaW1lcl8xLCBUcmlnZ2VyXzEsIFVJQWN0b3JfMiwgSW5kZXhfMSwgSW5kZXhfMiwgSW5kZXhfMywgSW5kZXhfNCwgSW5kZXhfNSwgSW5kZXhfNiwgZXZlbnRzLCBpbnB1dCwgdHJhaXRzLCB1dGlsLCBEZWNvcmF0b3JzXzEsIERldGVjdG9yXzEsIEN1bGxpbmdCb3hfMiwgRWFzaW5nRnVuY3Rpb25zXzMsIExvZ18xMywgU29ydGVkTGlzdF8xKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIGZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcclxuICAgICAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjdXJyZW50IEV4Y2FsaWJ1ciB2ZXJzaW9uIHN0cmluZ1xyXG4gICAgICovXHJcbiAgICBleHBvcnRzLkVYX1ZFUlNJT04gPSAnMC4xNS4wJztcclxuICAgIGV4cG9ydHMuQWN0b3IgPSBBY3Rvcl8xMS5BY3RvcjtcclxuICAgIGV4cG9ydHMuQ29sbGlzaW9uVHlwZSA9IEFjdG9yXzExLkNvbGxpc2lvblR5cGU7XHJcbiAgICBfX2V4cG9ydChBbGdlYnJhXzIxKTtcclxuICAgIF9fZXhwb3J0KENhbWVyYV8xKTtcclxuICAgIF9fZXhwb3J0KENsYXNzXzgpO1xyXG4gICAgX19leHBvcnQoQ29uZmlndXJhYmxlXzcpO1xyXG4gICAgX19leHBvcnQoRGVidWdfMSk7XHJcbiAgICBfX2V4cG9ydChFbmdpbmVfMyk7XHJcbiAgICBfX2V4cG9ydChFdmVudERpc3BhdGNoZXJfMik7XHJcbiAgICBfX2V4cG9ydChFdmVudHNfMTEpO1xyXG4gICAgX19leHBvcnQoR3JvdXBfMSk7XHJcbiAgICBleHBvcnRzLkxhYmVsID0gTGFiZWxfMi5MYWJlbDtcclxuICAgIGV4cG9ydHMuRm9udFN0eWxlID0gTGFiZWxfMi5Gb250U3R5bGU7XHJcbiAgICBleHBvcnRzLkZvbnRVbml0ID0gTGFiZWxfMi5Gb250VW5pdDtcclxuICAgIGV4cG9ydHMuVGV4dEFsaWduID0gTGFiZWxfMi5UZXh0QWxpZ247XHJcbiAgICBleHBvcnRzLkJhc2VBbGlnbiA9IExhYmVsXzIuQmFzZUFsaWduO1xyXG4gICAgX19leHBvcnQoTG9hZGVyXzEpO1xyXG4gICAgZXhwb3J0cy5QYXJ0aWNsZSA9IFBhcnRpY2xlc18xLlBhcnRpY2xlO1xyXG4gICAgZXhwb3J0cy5QYXJ0aWNsZUVtaXR0ZXIgPSBQYXJ0aWNsZXNfMS5QYXJ0aWNsZUVtaXR0ZXI7XHJcbiAgICBleHBvcnRzLkVtaXR0ZXJUeXBlID0gUGFydGljbGVzXzEuRW1pdHRlclR5cGU7XHJcbiAgICBfX2V4cG9ydChQaHlzaWNzXzExKTtcclxuICAgIF9fZXhwb3J0KFByb21pc2VzXzcpO1xyXG4gICAgX19leHBvcnQoU2NlbmVfMSk7XHJcbiAgICBleHBvcnRzLlRpbGVNYXAgPSBUaWxlTWFwXzEuVGlsZU1hcDtcclxuICAgIGV4cG9ydHMuQ2VsbCA9IFRpbGVNYXBfMS5DZWxsO1xyXG4gICAgZXhwb3J0cy5UaWxlU3ByaXRlID0gVGlsZU1hcF8xLlRpbGVTcHJpdGU7XHJcbiAgICBfX2V4cG9ydChUaW1lcl8xKTtcclxuICAgIF9fZXhwb3J0KFRyaWdnZXJfMSk7XHJcbiAgICBfX2V4cG9ydChVSUFjdG9yXzIpO1xyXG4gICAgX19leHBvcnQoSW5kZXhfMSk7XHJcbiAgICBfX2V4cG9ydChJbmRleF8yKTtcclxuICAgIF9fZXhwb3J0KEluZGV4XzMpO1xyXG4gICAgX19leHBvcnQoSW5kZXhfNCk7XHJcbiAgICBfX2V4cG9ydChJbmRleF81KTtcclxuICAgIF9fZXhwb3J0KEluZGV4XzYpO1xyXG4gICAgZXhwb3J0cy5FdmVudHMgPSBldmVudHM7XHJcbiAgICBleHBvcnRzLklucHV0ID0gaW5wdXQ7XHJcbiAgICBleHBvcnRzLlRyYWl0cyA9IHRyYWl0cztcclxuICAgIGV4cG9ydHMuVXRpbCA9IHV0aWw7XHJcbiAgICBfX2V4cG9ydChEZWNvcmF0b3JzXzEpO1xyXG4gICAgX19leHBvcnQoRGV0ZWN0b3JfMSk7XHJcbiAgICBfX2V4cG9ydChDdWxsaW5nQm94XzIpO1xyXG4gICAgX19leHBvcnQoRWFzaW5nRnVuY3Rpb25zXzMpO1xyXG4gICAgX19leHBvcnQoTG9nXzEzKTtcclxuICAgIF9fZXhwb3J0KFNvcnRlZExpc3RfMSk7XHJcbn0pO1xyXG5kZWZpbmUoXCJFbmdpbmVcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJJbmRleFwiLCBcIlByb21pc2VzXCIsIFwiQWxnZWJyYVwiLCBcIlVJQWN0b3JcIiwgXCJBY3RvclwiLCBcIlRpbWVyXCIsIFwiVGlsZU1hcFwiLCBcIkxvYWRlclwiLCBcIlV0aWwvRGV0ZWN0b3JcIiwgXCJFdmVudHNcIiwgXCJVdGlsL0xvZ1wiLCBcIkRyYXdpbmcvQ29sb3JcIiwgXCJTY2VuZVwiLCBcIkRlYnVnXCIsIFwiQ2xhc3NcIiwgXCJJbnB1dC9JbmRleFwiLCBcIlV0aWwvVXRpbFwiLCBcIkNvbGxpc2lvbi9Cb3VuZGluZ0JveFwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIEluZGV4XzcsIFByb21pc2VzXzgsIEFsZ2VicmFfMjIsIFVJQWN0b3JfMywgQWN0b3JfMTIsIFRpbWVyXzIsIFRpbGVNYXBfMiwgTG9hZGVyXzIsIERldGVjdG9yXzIsIEV2ZW50c18xMiwgTG9nXzE0LCBDb2xvcl8xOSwgU2NlbmVfMiwgRGVidWdfMiwgQ2xhc3NfOSwgSW5wdXQsIFV0aWwsIEJvdW5kaW5nQm94XzcpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFbnVtIHJlcHJlc2VudGluZyB0aGUgZGlmZmVyZW50IGRpc3BsYXkgbW9kZXMgYXZhaWxhYmxlIHRvIEV4Y2FsaWJ1clxyXG4gICAgICovXHJcbiAgICB2YXIgRGlzcGxheU1vZGU7XHJcbiAgICAoZnVuY3Rpb24gKERpc3BsYXlNb2RlKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2hvdyB0aGUgZ2FtZSBhcyBmdWxsIHNjcmVlblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERpc3BsYXlNb2RlW0Rpc3BsYXlNb2RlW1wiRnVsbFNjcmVlblwiXSA9IDBdID0gXCJGdWxsU2NyZWVuXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2NhbGUgdGhlIGdhbWUgdG8gdGhlIHBhcmVudCBET00gY29udGFpbmVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRGlzcGxheU1vZGVbRGlzcGxheU1vZGVbXCJDb250YWluZXJcIl0gPSAxXSA9IFwiQ29udGFpbmVyXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2hvdyB0aGUgZ2FtZSBhcyBhIGZpeGVkIHNpemVcclxuICAgICAgICAgKi9cclxuICAgICAgICBEaXNwbGF5TW9kZVtEaXNwbGF5TW9kZVtcIkZpeGVkXCJdID0gMl0gPSBcIkZpeGVkXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWxsb3cgdGhlIGdhbWUgdG8gYmUgcG9zaXRpb25lZCB3aXRoIHRoZSBbW0lFbmdpbmVPcHRpb25zLnBvc2l0aW9uXV0gb3B0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRGlzcGxheU1vZGVbRGlzcGxheU1vZGVbXCJQb3NpdGlvblwiXSA9IDNdID0gXCJQb3NpdGlvblwiO1xyXG4gICAgfSkoRGlzcGxheU1vZGUgPSBleHBvcnRzLkRpc3BsYXlNb2RlIHx8IChleHBvcnRzLkRpc3BsYXlNb2RlID0ge30pKTtcclxuICAgIC8qKlxyXG4gICAgICogRW51bSByZXByZXNlbnRpbmcgdGhlIGRpZmZlcmVudCBtb3VzZXdoZWVsIGV2ZW50IGJ1YmJsZSBwcmV2ZW50aW9uXHJcbiAgICAgKi9cclxuICAgIHZhciBTY3JvbGxQcmV2ZW50aW9uTW9kZTtcclxuICAgIChmdW5jdGlvbiAoU2Nyb2xsUHJldmVudGlvbk1vZGUpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEbyBub3QgcHJldmVudCBhbnkgcGFnZSBzY3JvbGxpbmdcclxuICAgICAgICAgKi9cclxuICAgICAgICBTY3JvbGxQcmV2ZW50aW9uTW9kZVtTY3JvbGxQcmV2ZW50aW9uTW9kZVtcIk5vbmVcIl0gPSAwXSA9IFwiTm9uZVwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByZXZlbnQgcGFnZSBzY3JvbGwgaWYgbW91c2UgaXMgb3ZlciB0aGUgZ2FtZSBjYW52YXNcclxuICAgICAgICAgKi9cclxuICAgICAgICBTY3JvbGxQcmV2ZW50aW9uTW9kZVtTY3JvbGxQcmV2ZW50aW9uTW9kZVtcIkNhbnZhc1wiXSA9IDFdID0gXCJDYW52YXNcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcmV2ZW50IGFsbCBwYWdlIHNjcm9sbGluZyB2aWEgbW91c2Ugd2hlZWxcclxuICAgICAgICAgKi9cclxuICAgICAgICBTY3JvbGxQcmV2ZW50aW9uTW9kZVtTY3JvbGxQcmV2ZW50aW9uTW9kZVtcIkFsbFwiXSA9IDJdID0gXCJBbGxcIjtcclxuICAgIH0pKFNjcm9sbFByZXZlbnRpb25Nb2RlID0gZXhwb3J0cy5TY3JvbGxQcmV2ZW50aW9uTW9kZSB8fCAoZXhwb3J0cy5TY3JvbGxQcmV2ZW50aW9uTW9kZSA9IHt9KSk7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBFeGNhbGlidXIgRW5naW5lXHJcbiAgICAgKlxyXG4gICAgICogVGhlIFtbRW5naW5lXV0gaXMgdGhlIG1haW4gZHJpdmVyIGZvciBhIGdhbWUuIEl0IGlzIHJlc3BvbnNpYmxlIGZvclxyXG4gICAgICogc3RhcnRpbmcvc3RvcHBpbmcgdGhlIGdhbWUsIG1haW50YWluaW5nIHN0YXRlLCB0cmFuc21pdHRpbmcgZXZlbnRzLFxyXG4gICAgICogbG9hZGluZyByZXNvdXJjZXMsIGFuZCBtYW5hZ2luZyB0aGUgc2NlbmUuXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOkVuZ2luZS5tZF1dXHJcbiAgICAgKi9cclxuICAgIHZhciBFbmdpbmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhFbmdpbmUsIF9zdXBlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBnYW1lIHVzaW5nIHRoZSBnaXZlbiBbW0lFbmdpbmVPcHRpb25zXV0uIEJ5IGRlZmF1bHQsIGlmIG5vIG9wdGlvbnMgYXJlIHByb3ZpZGVkLFxyXG4gICAgICAgICAqIHRoZSBnYW1lIHdpbGwgYmUgcmVuZGVyZWQgZnVsbCBzY3JlZW4gKHRha2luZyB1cCBhbGwgYXZhaWxhYmxlIGJyb3dzZXIgd2luZG93IHNwYWNlKS5cclxuICAgICAgICAgKiBZb3UgY2FuIGN1c3RvbWl6ZSB0aGUgZ2FtZSByZW5kZXJpbmcgdGhyb3VnaCBbW0lFbmdpbmVPcHRpb25zXV0uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBFeGFtcGxlOlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogYGBganNcclxuICAgICAgICAgKiB2YXIgZ2FtZSA9IG5ldyBleC5FbmdpbmUoe1xyXG4gICAgICAgICAqICAgd2lkdGg6IDAsIC8vIHRoZSB3aWR0aCBvZiB0aGUgY2FudmFzXHJcbiAgICAgICAgICogICBoZWlnaHQ6IDAsIC8vIHRoZSBoZWlnaHQgb2YgdGhlIGNhbnZhc1xyXG4gICAgICAgICAqICAgY2FudmFzRWxlbWVudElkOiAnJywgLy8gdGhlIERPTSBjYW52YXMgZWxlbWVudCBJRCwgaWYgeW91IGFyZSBwcm92aWRpbmcgeW91ciBvd25cclxuICAgICAgICAgKiAgIGRpc3BsYXlNb2RlOiBleC5EaXNwbGF5TW9kZS5GdWxsU2NyZWVuLCAvLyB0aGUgZGlzcGxheSBtb2RlXHJcbiAgICAgICAgICogICBwb2ludGVyU2NvcGU6IGV4LklucHV0LlBvaW50ZXJTY29wZS5Eb2N1bWVudCwgLy8gdGhlIHNjb3BlIG9mIGNhcHR1cmluZyBwb2ludGVyIChtb3VzZS90b3VjaCkgZXZlbnRzXHJcbiAgICAgICAgICogICBiYWNrZ3JvdW5kQ29sb3I6IGV4LkNvbG9yLmZyb21IZXgoJyMyMTg1ZDAnKSAvLyBiYWNrZ3JvdW5kIGNvbG9yIG9mIHRoZSBlbmdpbmVcclxuICAgICAgICAgKiB9KTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIC8vIGNhbGwgZ2FtZS5zdGFydCwgd2hpY2ggaXMgYSBQcm9taXNlXHJcbiAgICAgICAgICogZ2FtZS5zdGFydCgpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAqICAgLy8gcmVhZHksIHNldCwgZ28hXHJcbiAgICAgICAgICogfSk7XHJcbiAgICAgICAgICogYGBgXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gRW5naW5lKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuX2hhc1N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFjY2VzcyBFeGNhbGlidXIgZGVidWdnaW5nIGZ1bmN0aW9uYWxpdHkuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5kZWJ1ZyA9IG5ldyBEZWJ1Z18yLkRlYnVnKCk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGxpc3Qgb2YgcG9zdCBwcm9jZXNzb3JzIHRvIGFwcGx5IGF0IHRoZSBlbmQgb2YgZHJhd2luZyBhIGZyYW1lIChzdWNoIGFzIFtbQ29sb3JCbGluZENvcnJlY3Rvcl1dKVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMucG9zdFByb2Nlc3NvcnMgPSBbXTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENvbnRhaW5zIGFsbCB0aGUgc2NlbmVzIGN1cnJlbnRseSByZWdpc3RlcmVkIHdpdGggRXhjYWxpYnVyXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5zY2VuZXMgPSB7fTtcclxuICAgICAgICAgICAgX3RoaXMuX2FuaW1hdGlvbnMgPSBbXTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBlbmdpbmUgaXMgc2V0IHRvIGZ1bGxzY3JlZW4gb3Igbm90XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5pc0Z1bGxzY3JlZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEluZGljYXRlcyB0aGUgY3VycmVudCBbW0Rpc3BsYXlNb2RlXV0gb2YgdGhlIGVuZ2luZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmRpc3BsYXlNb2RlID0gRGlzcGxheU1vZGUuRnVsbFNjcmVlbjtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIGF1ZGlvIHNob3VsZCBiZSBwYXVzZWQgd2hlbiB0aGUgZ2FtZSBpcyBubyBsb25nZXIgdmlzaWJsZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLnBhdXNlQXVkaW9XaGVuSGlkZGVuID0gdHJ1ZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBlbmdpbmUgc2hvdWxkIGRyYXcgd2l0aCBkZWJ1ZyBpbmZvcm1hdGlvblxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuaXNEZWJ1ZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBfdGhpcy5kZWJ1Z0NvbG9yID0gbmV3IENvbG9yXzE5LkNvbG9yKDI1NSwgMjU1LCAyNTUpO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGFjdGlvbiB0byB0YWtlIHdoZW4gYSBmYXRhbCBleGNlcHRpb24gaXMgdGhyb3duXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5vbkZhdGFsRXhjZXB0aW9uID0gZnVuY3Rpb24gKGUpIHsgTG9nXzE0LkxvZ2dlci5nZXRJbnN0YW5jZSgpLmZhdGFsKGUpOyB9O1xyXG4gICAgICAgICAgICBfdGhpcy5faXNTbW9vdGhpbmdFbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgX3RoaXMuX3RpbWVzY2FsZSA9IDEuMDtcclxuICAgICAgICAgICAgX3RoaXMuX2lzTG9hZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBvcHRpb25zID0gVXRpbC5leHRlbmQoe30sIEVuZ2luZS5fRGVmYXVsdEVuZ2luZU9wdGlvbnMsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAvLyBDaGVjayBjb21wYXRpYmlsaXR5IFxyXG4gICAgICAgICAgICB2YXIgZGV0ZWN0b3IgPSBuZXcgRGV0ZWN0b3JfMi5EZXRlY3RvcigpO1xyXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuc3VwcHJlc3NNaW5pbXVtQnJvd3NlckZlYXR1cmVEZXRlY3Rpb24gJiYgIShfdGhpcy5fY29tcGF0aWJsZSA9IGRldGVjdG9yLnRlc3QoKSkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmlubmVyVGV4dCA9ICdTb3JyeSwgeW91ciBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgYWxsIHRoZSBmZWF0dXJlcyBuZWVkZWQgZm9yIEV4Y2FsaWJ1cic7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgZGV0ZWN0b3IuZmFpbGVkVGVzdHMuZm9yRWFjaChmdW5jdGlvbiAodGVzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXN0TWVzc2FnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRlc3RNZXNzYWdlLmlubmVyVGV4dCA9ICdCcm93c2VyIGZlYXR1cmUgbWlzc2luZyAnICsgdGVzdDtcclxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRlc3RNZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2FudmFzRWxlbWVudElkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9wdGlvbnMuY2FudmFzRWxlbWVudElkKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FudmFzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhcy5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGNhbnZhcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2NvbXBhdGlibGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFVzZSBuYXRpdmUgY29uc29sZSBBUEkgZm9yIGNvbG9yIGZ1blxyXG4gICAgICAgICAgICBpZiAoY29uc29sZS5sb2cgJiYgIW9wdGlvbnMuc3VwcHJlc3NDb25zb2xlQm9vdE1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiJWNQb3dlcmVkIGJ5IEV4Y2FsaWJ1ci5qcyAodlwiICsgSW5kZXhfNy5FWF9WRVJTSU9OICsgXCIpXCIsICdiYWNrZ3JvdW5kOiAjMTc2QkFBOyBjb2xvcjogd2hpdGU7IGJvcmRlci1yYWRpdXM6IDVweDsgcGFkZGluZzogMTVweDsgZm9udC1zaXplOiAxLjVlbTsgbGluZS1oZWlnaHQ6IDgwcHg7Jyk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnXFxuXFxcclxuICAgICAgL3wgX19fX19fX19fX19fX19fX1xcblxcXHJcbk98PT09fCogPl9fX19fX19fX19fX19fX18+XFxuXFxcclxuICAgICAgXFxcXHwnKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdWaXNpdCcsICdodHRwOi8vZXhjYWxpYnVyanMuY29tJywgJ2ZvciBtb3JlIGluZm9ybWF0aW9uJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMuX2xvZ2dlciA9IExvZ18xNC5Mb2dnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgLy8gSWYgZGVidWcgaXMgZW5hYmxlZCwgbGV0J3MgbG9nIGJyb3dzZXIgZmVhdHVyZXMgdG8gdGhlIGNvbnNvbGUuXHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5fbG9nZ2VyLmRlZmF1bHRMZXZlbCA9PT0gTG9nXzE0LkxvZ0xldmVsLkRlYnVnKSB7XHJcbiAgICAgICAgICAgICAgICBkZXRlY3Rvci5sb2dCcm93c2VyRmVhdHVyZXMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmRlYnVnKCdCdWlsZGluZyBlbmdpbmUuLi4nKTtcclxuICAgICAgICAgICAgX3RoaXMuY2FudmFzRWxlbWVudElkID0gb3B0aW9ucy5jYW52YXNFbGVtZW50SWQ7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNhbnZhc0VsZW1lbnRJZCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci5kZWJ1ZygnVXNpbmcgQ2FudmFzIGVsZW1lbnQgc3BlY2lmaWVkOiAnICsgb3B0aW9ucy5jYW52YXNFbGVtZW50SWQpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQob3B0aW9ucy5jYW52YXNFbGVtZW50SWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci5kZWJ1ZygnVXNpbmcgZ2VuZXJhdGVkIGNhbnZhcyBlbGVtZW50Jyk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy53aWR0aCAmJiBvcHRpb25zLmhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGlzcGxheU1vZGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRpc3BsYXlNb2RlID0gRGlzcGxheU1vZGUuRml4ZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmRlYnVnKCdFbmdpbmUgdmlld3BvcnQgaXMgc2l6ZSAnICsgb3B0aW9ucy53aWR0aCArICcgeCAnICsgb3B0aW9ucy5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY2FudmFzLndpZHRoID0gb3B0aW9ucy53aWR0aDtcclxuICAgICAgICAgICAgICAgIF90aGlzLmNhbnZhcy5oZWlnaHQgPSBvcHRpb25zLmhlaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghb3B0aW9ucy5kaXNwbGF5TW9kZSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci5kZWJ1ZygnRW5naW5lIHZpZXdwb3J0IGlzIGZ1bGxzY3JlZW4nKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmRpc3BsYXlNb2RlID0gRGlzcGxheU1vZGUuRnVsbFNjcmVlbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmJhY2tncm91bmRDb2xvciA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLmNsb25lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMuX2xvYWRlciA9IG5ldyBMb2FkZXJfMi5Mb2FkZXIoKTtcclxuICAgICAgICAgICAgX3RoaXMuX2luaXRpYWxpemUob3B0aW9ucyk7XHJcbiAgICAgICAgICAgIF90aGlzLnJvb3RTY2VuZSA9IF90aGlzLmN1cnJlbnRTY2VuZSA9IG5ldyBTY2VuZV8yLlNjZW5lKF90aGlzKTtcclxuICAgICAgICAgICAgX3RoaXMuYWRkU2NlbmUoJ3Jvb3QnLCBfdGhpcy5yb290U2NlbmUpO1xyXG4gICAgICAgICAgICBfdGhpcy5nb1RvU2NlbmUoJ3Jvb3QnKTtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW5naW5lLnByb3RvdHlwZSwgXCJjYW52YXNXaWR0aFwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgd2lkdGggb2YgdGhlIGdhbWUgY2FudmFzIGluIHBpeGVscyAocGh5c2ljYWwgd2lkdGggY29tcG9uZW50IG9mIHRoZVxyXG4gICAgICAgICAgICAgKiByZXNvbHV0aW9uIG9mIHRoZSBjYW52YXMgZWxlbWVudClcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLndpZHRoO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW5naW5lLnByb3RvdHlwZSwgXCJoYWxmQ2FudmFzV2lkdGhcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmV0dXJucyBoYWxmIHdpZHRoIG9mIHRoZSBnYW1lIGNhbnZhcyBpbiBwaXhlbHMgKGhhbGYgcGh5c2ljYWwgd2lkdGggY29tcG9uZW50KVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYW52YXMud2lkdGggLyAyO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW5naW5lLnByb3RvdHlwZSwgXCJjYW52YXNIZWlnaHRcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGhlaWdodCBvZiB0aGUgZ2FtZSBjYW52YXMgaW4gcGl4ZWxzLCAocGh5c2ljYWwgaGVpZ2h0IGNvbXBvbmVudCBvZlxyXG4gICAgICAgICAgICAgKiB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgY2FudmFzIGVsZW1lbnQpXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy5oZWlnaHQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbmdpbmUucHJvdG90eXBlLCBcImhhbGZDYW52YXNIZWlnaHRcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmV0dXJucyBoYWxmIGhlaWdodCBvZiB0aGUgZ2FtZSBjYW52YXMgaW4gcGl4ZWxzIChoYWxmIHBoeXNpY2FsIGhlaWdodCBjb21wb25lbnQpXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy5oZWlnaHQgLyAyO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW5naW5lLnByb3RvdHlwZSwgXCJkcmF3V2lkdGhcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIGVuZ2luZSdzIHZpc2libGUgZHJhd2luZyBzdXJmYWNlIGluIHBpeGVscyBpbmNsdWRpbmcgem9vbSBhbmQgZGV2aWNlIHBpeGVsIHJhdGlvLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50U2NlbmUgJiYgdGhpcy5jdXJyZW50U2NlbmUuY2FtZXJhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmNhbnZhc1dpZHRoIC8gdGhpcy5jdXJyZW50U2NlbmUuY2FtZXJhLmdldFpvb20oKSkgLyB0aGlzLnBpeGVsUmF0aW87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYW52YXNXaWR0aCAvIHRoaXMucGl4ZWxSYXRpbztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVuZ2luZS5wcm90b3R5cGUsIFwiaGFsZkRyYXdXaWR0aFwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXR1cm5zIGhhbGYgdGhlIHdpZHRoIG9mIHRoZSBlbmdpbmUncyB2aXNpYmxlIGRyYXdpbmcgc3VyZmFjZSBpbiBwaXhlbHMgaW5jbHVkaW5nIHpvb20gYW5kIGRldmljZSBwaXhlbCByYXRpby5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZHJhd1dpZHRoIC8gMjtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVuZ2luZS5wcm90b3R5cGUsIFwiZHJhd0hlaWdodFwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBoZWlnaHQgb2YgdGhlIGVuZ2luZSdzIHZpc2libGUgZHJhd2luZyBzdXJmYWNlIGluIHBpeGVscyBpbmNsdWRpbmcgem9vbSBhbmQgZGV2aWNlIHBpeGVsIHJhdGlvLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50U2NlbmUgJiYgdGhpcy5jdXJyZW50U2NlbmUuY2FtZXJhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmNhbnZhc0hlaWdodCAvIHRoaXMuY3VycmVudFNjZW5lLmNhbWVyYS5nZXRab29tKCkpIC8gdGhpcy5waXhlbFJhdGlvO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzSGVpZ2h0IC8gdGhpcy5waXhlbFJhdGlvO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW5naW5lLnByb3RvdHlwZSwgXCJoYWxmRHJhd0hlaWdodFwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXR1cm5zIGhhbGYgdGhlIGhlaWdodCBvZiB0aGUgZW5naW5lJ3MgdmlzaWJsZSBkcmF3aW5nIHN1cmZhY2UgaW4gcGl4ZWxzIGluY2x1ZGluZyB6b29tIGFuZCBkZXZpY2UgcGl4ZWwgcmF0aW8uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRyYXdIZWlnaHQgLyAyO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW5naW5lLnByb3RvdHlwZSwgXCJpc0hpRHBpXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJldHVybnMgd2hldGhlciBleGNhbGlidXIgZGV0ZWN0cyB0aGUgY3VycmVudCBzY3JlZW4gdG8gYmUgSGlEUElcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGl4ZWxSYXRpbyAhPT0gMTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVuZ2luZS5wcm90b3R5cGUsIFwic3RhdHNcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQWNjZXNzIFtbc3RhdHNdXSB0aGF0IGhvbGRzIGZyYW1lIHN0YXRpc3RpY3MuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlYnVnLnN0YXRzO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW5naW5lLnByb3RvdHlwZSwgXCJwaXhlbFJhdGlvXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJldHVybnMgdGhlIGNhbGN1bGF0ZWQgcGl4ZWwgcmF0aW9uIGZvciB1c2UgaW4gcmVuZGVyaW5nXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkZXZpY2VQaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcclxuICAgICAgICAgICAgICAgIHZhciBwaXhlbFJhdGlvID0gZGV2aWNlUGl4ZWxSYXRpbztcclxuICAgICAgICAgICAgICAgIHJldHVybiBwaXhlbFJhdGlvO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBFbmdpbmUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBCb3VuZGluZ0JveCBvZiB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSBzY3JlZW5cclxuICAgICAgICAgKiBhbmQgdGhlIGJvdHRvbSByaWdodCBjb3JuZXIgb2YgdGhlIHNjcmVlbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBFbmdpbmUucHJvdG90eXBlLmdldFdvcmxkQm91bmRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbGVmdCA9IHRoaXMuc2NyZWVuVG9Xb3JsZENvb3JkaW5hdGVzKEFsZ2VicmFfMjIuVmVjdG9yLlplcm8pLng7XHJcbiAgICAgICAgICAgIHZhciB0b3AgPSB0aGlzLnNjcmVlblRvV29ybGRDb29yZGluYXRlcyhBbGdlYnJhXzIyLlZlY3Rvci5aZXJvKS55O1xyXG4gICAgICAgICAgICB2YXIgcmlnaHQgPSBsZWZ0ICsgdGhpcy5kcmF3V2lkdGg7XHJcbiAgICAgICAgICAgIHZhciBib3R0b20gPSB0b3AgKyB0aGlzLmRyYXdIZWlnaHQ7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3hfNy5Cb3VuZGluZ0JveChsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b20pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVuZ2luZS5wcm90b3R5cGUsIFwidGltZXNjYWxlXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIGN1cnJlbnQgZW5naW5lIHRpbWVzY2FsZSBmYWN0b3IgKGRlZmF1bHQgaXMgMS4wIHdoaWNoIGlzIDE6MSB0aW1lKVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGltZXNjYWxlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0cyB0aGUgY3VycmVudCBlbmdpbmUgdGltZXNjYWxlIGZhY3Rvci4gVXNlZnVsIGZvciBjcmVhdGluZyBzbG93LW1vdGlvbiBlZmZlY3RzIG9yIGZhc3QtZm9yd2FyZCBlZmZlY3RzXHJcbiAgICAgICAgICAgICAqIHdoZW4gdXNpbmcgdGltZS1iYXNlZCBtb3ZlbWVudC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIExvZ18xNC5Mb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcignQ2Fubm90IHNldCBlbmdpbmUudGltZXNjYWxlIHRvIGEgdmFsdWUgb2YgMCBvciBsZXNzIHRoYW4gMC4nKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90aW1lc2NhbGUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGxheXMgYSBzcHJpdGUgYW5pbWF0aW9uIG9uIHRoZSBzY3JlZW4gYXQgdGhlIHNwZWNpZmllZCBgeGAgYW5kIGB5YFxyXG4gICAgICAgICAqIChpbiBnYW1lIGNvb3JkaW5hdGVzLCBub3Qgc2NyZWVuIHBpeGVscykuIFRoZXNlIGFuaW1hdGlvbnMgcGxheVxyXG4gICAgICAgICAqIGluZGVwZW5kZW50IG9mIGFjdG9ycywgYW5kIHdpbGwgYmUgY2xlYW5lZCB1cCBpbnRlcm5hbGx5IGFzIHNvb25cclxuICAgICAgICAgKiBhcyB0aGV5IGFyZSBjb21wbGV0ZS4gTm90ZSBhbmltYXRpb25zIHRoYXQgbG9vcCB3aWxsIG5ldmVyIGJlXHJcbiAgICAgICAgICogY2xlYW5lZCB1cC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBhbmltYXRpb24gIEFuaW1hdGlvbiB0byBwbGF5XHJcbiAgICAgICAgICogQHBhcmFtIHggICAgICAgICAgeCBnYW1lIGNvb3JkaW5hdGUgdG8gcGxheSB0aGUgYW5pbWF0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHkgICAgICAgICAgeSBnYW1lIGNvb3JkaW5hdGUgdG8gcGxheSB0aGUgYW5pbWF0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5wbGF5QW5pbWF0aW9uID0gZnVuY3Rpb24gKGFuaW1hdGlvbiwgeCwgeSkge1xyXG4gICAgICAgICAgICB0aGlzLl9hbmltYXRpb25zLnB1c2gobmV3IEFuaW1hdGlvbk5vZGUoYW5pbWF0aW9uLCB4LCB5KSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgW1tUaWxlTWFwXV0gdG8gdGhlIFtbY3VycmVudFNjZW5lXV0sIG9uY2UgdGhpcyBpcyBkb25lIHRoZSBUaWxlTWFwXHJcbiAgICAgICAgICogd2lsbCBiZSBkcmF3biBhbmQgdXBkYXRlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBFbmdpbmUucHJvdG90eXBlLmFkZFRpbGVNYXAgPSBmdW5jdGlvbiAodGlsZU1hcCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5hZGRUaWxlTWFwKHRpbGVNYXApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlcyBhIFtbVGlsZU1hcF1dIGZyb20gdGhlIFtbY3VycmVudFNjZW5lXV0sIGl0IHdpbGwgbm8gbG9uZ2VyIGJlIGRyYXduIG9yIHVwZGF0ZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5yZW1vdmVUaWxlTWFwID0gZnVuY3Rpb24gKHRpbGVNYXApIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUucmVtb3ZlVGlsZU1hcCh0aWxlTWFwKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYSBbW1RpbWVyXV0gdG8gdGhlIFtbY3VycmVudFNjZW5lXV0uXHJcbiAgICAgICAgICogQHBhcmFtIHRpbWVyICBUaGUgdGltZXIgdG8gYWRkIHRvIHRoZSBbW2N1cnJlbnRTY2VuZV1dLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuYWRkVGltZXIgPSBmdW5jdGlvbiAodGltZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFNjZW5lLmFkZFRpbWVyKHRpbWVyKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgYSBbW1RpbWVyXV0gZnJvbSB0aGUgW1tjdXJyZW50U2NlbmVdXS5cclxuICAgICAgICAgKiBAcGFyYW0gdGltZXIgIFRoZSB0aW1lciB0byByZW1vdmUgdG8gdGhlIFtbY3VycmVudFNjZW5lXV0uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5yZW1vdmVUaW1lciA9IGZ1bmN0aW9uICh0aW1lcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50U2NlbmUucmVtb3ZlVGltZXIodGltZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhIFtbU2NlbmVdXSB0byB0aGUgZW5naW5lLCB0aGluayBvZiBzY2VuZXMgaW4gRXhjYWxpYnVyIGFzIHlvdVxyXG4gICAgICAgICAqIHdvdWxkIGxldmVscyBvciBtZW51cy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBrZXkgIFRoZSBuYW1lIG9mIHRoZSBzY2VuZSwgbXVzdCBiZSB1bmlxdWVcclxuICAgICAgICAgKiBAcGFyYW0gc2NlbmUgVGhlIHNjZW5lIHRvIGFkZCB0byB0aGUgZW5naW5lXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5hZGRTY2VuZSA9IGZ1bmN0aW9uIChrZXksIHNjZW5lKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNjZW5lc1trZXldKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIud2FybignU2NlbmUnLCBrZXksICdhbHJlYWR5IGV4aXN0cyBvdmVyd3JpdGluZycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc2NlbmVzW2tleV0gPSBzY2VuZTtcclxuICAgICAgICAgICAgc2NlbmUuZW5naW5lID0gdGhpcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUucmVtb3ZlU2NlbmUgPSBmdW5jdGlvbiAoZW50aXR5KSB7XHJcbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBTY2VuZV8yLlNjZW5lKSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgc2NlbmVcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLnNjZW5lcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjZW5lcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjZW5lc1trZXldID09PSBlbnRpdHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNjZW5lc1trZXldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW50aXR5ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHNjZW5lXHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zY2VuZXNbZW50aXR5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZW50aXR5KSB7XHJcbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBVSUFjdG9yXzMuVUlBY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUuYWRkVUlBY3RvcihlbnRpdHkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBBY3Rvcl8xMi5BY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkQ2hpbGQoZW50aXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgVGltZXJfMi5UaW1lcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRUaW1lcihlbnRpdHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBUaWxlTWFwXzIuVGlsZU1hcCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRUaWxlTWFwKGVudGl0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkU2NlbmUoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBFbmdpbmUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChlbnRpdHkpIHtcclxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIFVJQWN0b3JfMy5VSUFjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5yZW1vdmVVSUFjdG9yKGVudGl0eSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIEFjdG9yXzEyLkFjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVDaGlsZChlbnRpdHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBUaW1lcl8yLlRpbWVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVRpbWVyKGVudGl0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIFRpbGVNYXBfMi5UaWxlTWFwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVRpbGVNYXAoZW50aXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgU2NlbmVfMi5TY2VuZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVTY2VuZShlbnRpdHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW50aXR5ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVTY2VuZShlbnRpdHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGFuIGFjdG9yIHRvIHRoZSBbW2N1cnJlbnRTY2VuZV1dIG9mIHRoZSBnYW1lLiBUaGlzIGlzIHN5bm9ueW1vdXNcclxuICAgICAgICAgKiB0byBjYWxsaW5nIGBlbmdpbmUuY3VycmVudFNjZW5lLmFkZChhY3RvcilgLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQWN0b3JzIGNhbiBvbmx5IGJlIGRyYXduIGlmIHRoZXkgYXJlIGEgbWVtYmVyIG9mIGEgc2NlbmUsIGFuZCBvbmx5XHJcbiAgICAgICAgICogdGhlIFtbY3VycmVudFNjZW5lXV0gbWF5IGJlIGRyYXduIG9yIHVwZGF0ZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gYWN0b3IgIFRoZSBhY3RvciB0byBhZGQgdG8gdGhlIFtbY3VycmVudFNjZW5lXV1cclxuICAgICAgICAgKi9cclxuICAgICAgICBFbmdpbmUucHJvdG90eXBlLl9hZGRDaGlsZCA9IGZ1bmN0aW9uIChhY3Rvcikge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5hZGQoYWN0b3IpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlcyBhbiBhY3RvciBmcm9tIHRoZSBbW2N1cnJlbnRTY2VuZV1dIG9mIHRoZSBnYW1lLiBUaGlzIGlzIHN5bm9ueW1vdXNcclxuICAgICAgICAgKiB0byBjYWxsaW5nIGBlbmdpbmUuY3VycmVudFNjZW5lLnJlbW92ZShhY3RvcilgLlxyXG4gICAgICAgICAqIEFjdG9ycyB0aGF0IGFyZSByZW1vdmVkIGZyb20gYSBzY2VuZSB3aWxsIG5vIGxvbmdlciBiZSBkcmF3biBvciB1cGRhdGVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGFjdG9yICBUaGUgYWN0b3IgdG8gcmVtb3ZlIGZyb20gdGhlIFtbY3VycmVudFNjZW5lXV0uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5fcmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiAoYWN0b3IpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUucmVtb3ZlKGFjdG9yKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoYW5nZXMgdGhlIGN1cnJlbnRseSB1cGRhdGluZyBhbmQgZHJhd2luZyBzY2VuZSB0byBhIGRpZmZlcmVudCxcclxuICAgICAgICAgKiBuYW1lZCBzY2VuZS4gQ2FsbHMgdGhlIFtbU2NlbmVdXSBsaWZlY3ljbGUgZXZlbnRzLlxyXG4gICAgICAgICAqIEBwYXJhbSBrZXkgIFRoZSBrZXkgb2YgdGhlIHNjZW5lIHRvIHRyYW5zaXRpb24gdG8uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5nb1RvU2NlbmUgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNjZW5lc1trZXldKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2xkU2NlbmUgPSB0aGlzLmN1cnJlbnRTY2VuZTtcclxuICAgICAgICAgICAgICAgIHZhciBuZXdTY2VuZSA9IHRoaXMuc2NlbmVzW2tleV07XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoJ0dvaW5nIHRvIHNjZW5lOicsIGtleSk7XHJcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGRlYWN0aXZhdGUgd2hlbiBpbml0aWFsaXplZFxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFNjZW5lLmlzSW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5vbkRlYWN0aXZhdGUuY2FsbCh0aGlzLmN1cnJlbnRTY2VuZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ2RlYWN0aXZhdGUnLCBuZXcgRXZlbnRzXzEyLkRlYWN0aXZhdGVFdmVudChuZXdTY2VuZSwgdGhpcy5jdXJyZW50U2NlbmUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHNldCBjdXJyZW50IHNjZW5lIHRvIG5ldyBvbmVcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lID0gbmV3U2NlbmU7XHJcbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsaXplIHRoZSBjdXJyZW50IHNjZW5lIGlmIGhhcyBub3QgYmVlbiBhbHJlYWR5XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5faW5pdGlhbGl6ZSh0aGlzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLm9uQWN0aXZhdGUuY2FsbCh0aGlzLmN1cnJlbnRTY2VuZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5ldmVudERpc3BhdGNoZXIuZW1pdCgnYWN0aXZhdGUnLCBuZXcgRXZlbnRzXzEyLkFjdGl2YXRlRXZlbnQob2xkU2NlbmUsIHRoaXMuY3VycmVudFNjZW5lKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoJ1NjZW5lJywga2V5LCAnZG9lcyBub3QgZXhpc3QhJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRyYW5zZm9ybXMgdGhlIGN1cnJlbnQgeCwgeSBmcm9tIHNjcmVlbiBjb29yZGluYXRlcyB0byB3b3JsZCBjb29yZGluYXRlc1xyXG4gICAgICAgICAqIEBwYXJhbSBwb2ludCAgU2NyZWVuIGNvb3JkaW5hdGUgdG8gY29udmVydFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuc2NyZWVuVG9Xb3JsZENvb3JkaW5hdGVzID0gZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgICAgICAgICAgIHZhciBuZXdYID0gcG9pbnQueDtcclxuICAgICAgICAgICAgdmFyIG5ld1kgPSBwb2ludC55O1xyXG4gICAgICAgICAgICAvLyB0cmFuc2Zvcm0gYmFjayB0byB3b3JsZCBzcGFjZVxyXG4gICAgICAgICAgICBuZXdYID0gKG5ld1ggLyB0aGlzLmNhbnZhcy5jbGllbnRXaWR0aCkgKiB0aGlzLmRyYXdXaWR0aDtcclxuICAgICAgICAgICAgbmV3WSA9IChuZXdZIC8gdGhpcy5jYW52YXMuY2xpZW50SGVpZ2h0KSAqIHRoaXMuZHJhd0hlaWdodDtcclxuICAgICAgICAgICAgLy8gdHJhbnNmb3JtIGJhc2VkIG9uIHpvb21cclxuICAgICAgICAgICAgbmV3WCA9IG5ld1ggLSB0aGlzLmhhbGZEcmF3V2lkdGg7XHJcbiAgICAgICAgICAgIG5ld1kgPSBuZXdZIC0gdGhpcy5oYWxmRHJhd0hlaWdodDtcclxuICAgICAgICAgICAgLy8gc2hpZnQgYnkgZm9jdXNcclxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFNjZW5lICYmIHRoaXMuY3VycmVudFNjZW5lLmNhbWVyYSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZvY3VzID0gdGhpcy5jdXJyZW50U2NlbmUuY2FtZXJhLmdldEZvY3VzKCk7XHJcbiAgICAgICAgICAgICAgICBuZXdYICs9IGZvY3VzLng7XHJcbiAgICAgICAgICAgICAgICBuZXdZICs9IGZvY3VzLnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbGdlYnJhXzIyLlZlY3RvcihNYXRoLmZsb29yKG5ld1gpLCBNYXRoLmZsb29yKG5ld1kpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRyYW5zZm9ybXMgYSB3b3JsZCBjb29yZGluYXRlLCB0byBhIHNjcmVlbiBjb29yZGluYXRlXHJcbiAgICAgICAgICogQHBhcmFtIHBvaW50ICBXb3JsZCBjb29yZGluYXRlIHRvIGNvbnZlcnRcclxuICAgICAgICAgKi9cclxuICAgICAgICBFbmdpbmUucHJvdG90eXBlLndvcmxkVG9TY3JlZW5Db29yZGluYXRlcyA9IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gICAgICAgICAgICB2YXIgc2NyZWVuWCA9IHBvaW50Lng7XHJcbiAgICAgICAgICAgIHZhciBzY3JlZW5ZID0gcG9pbnQueTtcclxuICAgICAgICAgICAgLy8gc2hpZnQgYnkgZm9jdXNcclxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFNjZW5lICYmIHRoaXMuY3VycmVudFNjZW5lLmNhbWVyYSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZvY3VzID0gdGhpcy5jdXJyZW50U2NlbmUuY2FtZXJhLmdldEZvY3VzKCk7XHJcbiAgICAgICAgICAgICAgICBzY3JlZW5YIC09IGZvY3VzLng7XHJcbiAgICAgICAgICAgICAgICBzY3JlZW5ZIC09IGZvY3VzLnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdHJhbnNmb3JtIGJhY2sgb24gem9vbVxyXG4gICAgICAgICAgICBzY3JlZW5YID0gc2NyZWVuWCArIHRoaXMuaGFsZkRyYXdXaWR0aDtcclxuICAgICAgICAgICAgc2NyZWVuWSA9IHNjcmVlblkgKyB0aGlzLmhhbGZEcmF3SGVpZ2h0O1xyXG4gICAgICAgICAgICAvLyB0cmFuc2Zvcm0gYmFjayB0byBzY3JlZW4gc3BhY2VcclxuICAgICAgICAgICAgc2NyZWVuWCA9IChzY3JlZW5YICogdGhpcy5jYW52YXMuY2xpZW50V2lkdGgpIC8gdGhpcy5kcmF3V2lkdGg7XHJcbiAgICAgICAgICAgIHNjcmVlblkgPSAoc2NyZWVuWSAqIHRoaXMuY2FudmFzLmNsaWVudEhlaWdodCkgLyB0aGlzLmRyYXdIZWlnaHQ7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWxnZWJyYV8yMi5WZWN0b3IoTWF0aC5mbG9vcihzY3JlZW5YKSwgTWF0aC5mbG9vcihzY3JlZW5ZKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBpbnRlcm5hbCBjYW52YXMgaGVpZ2h0IGJhc2VkIG9uIHRoZSBzZWxlY3RlZCBkaXNwbGF5IG1vZGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5fc2V0SGVpZ2h0QnlEaXNwbGF5TW9kZSA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZGlzcGxheU1vZGUgPT09IERpc3BsYXlNb2RlLkNvbnRhaW5lcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSBwYXJlbnQuY2xpZW50V2lkdGg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSBwYXJlbnQuY2xpZW50SGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRpc3BsYXlNb2RlID09PSBEaXNwbGF5TW9kZS5GdWxsU2NyZWVuKSB7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm1hcmdpbiA9ICcwcHgnO1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSBwYXJlbnQuaW5uZXJXaWR0aDtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHBhcmVudC5pbm5lckhlaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgdGhlIGludGVybmFsIGNhbnZhcywgcmVuZGVyaW5nIGNvbnRleHQsIGRpc3BsYXltb2RlLCBhbmQgbmF0aXZlIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuX2luaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kaXNwbGF5TW9kZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5TW9kZSA9IG9wdGlvbnMuZGlzcGxheU1vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuZGlzcGxheU1vZGUgPT09IERpc3BsYXlNb2RlLkZ1bGxTY3JlZW4gfHwgdGhpcy5kaXNwbGF5TW9kZSA9PT0gRGlzcGxheU1vZGUuQ29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gKHRoaXMuZGlzcGxheU1vZGUgPT09IERpc3BsYXlNb2RlLkNvbnRhaW5lciA/XHJcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuY2FudmFzLnBhcmVudEVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keSkgOiB3aW5kb3cpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0SGVpZ2h0QnlEaXNwbGF5TW9kZShwYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmRlYnVnKCdWaWV3IHBvcnQgcmVzaXplZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9zZXRIZWlnaHRCeURpc3BsYXlNb2RlKHBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci5pbmZvKCdwYXJlbnQuY2xpZW50SGVpZ2h0ICcgKyBwYXJlbnQuY2xpZW50SGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRBbnRpYWxpYXNpbmcoX3RoaXMuX2lzU21vb3RoaW5nRW5hYmxlZCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmRpc3BsYXlNb2RlID09PSBEaXNwbGF5TW9kZS5Qb3NpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW50aWFsaXplRGlzcGxheU1vZGVQb3NpdGlvbihvcHRpb25zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpbml0aWFsaXplIGlucHV0c1xyXG4gICAgICAgICAgICB0aGlzLmlucHV0ID0ge1xyXG4gICAgICAgICAgICAgICAga2V5Ym9hcmQ6IG5ldyBJbnB1dC5LZXlib2FyZCgpLFxyXG4gICAgICAgICAgICAgICAgcG9pbnRlcnM6IG5ldyBJbnB1dC5Qb2ludGVycyh0aGlzKSxcclxuICAgICAgICAgICAgICAgIGdhbWVwYWRzOiBuZXcgSW5wdXQuR2FtZXBhZHMoKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmlucHV0LmtleWJvYXJkLmluaXQoKTtcclxuICAgICAgICAgICAgdGhpcy5pbnB1dC5wb2ludGVycy5pbml0KG9wdGlvbnMgJiYgb3B0aW9ucy5wb2ludGVyU2NvcGUgPT09IElucHV0LlBvaW50ZXJTY29wZS5Eb2N1bWVudCA/IGRvY3VtZW50IDogdGhpcy5jYW52YXMpO1xyXG4gICAgICAgICAgICB0aGlzLmlucHV0LmdhbWVwYWRzLmluaXQoKTtcclxuICAgICAgICAgICAgdGhpcy5wYWdlU2Nyb2xsUHJldmVudGlvbk1vZGUgPSBvcHRpb25zLnNjcm9sbFByZXZlbnRpb25Nb2RlO1xyXG4gICAgICAgICAgICAvLyBJc3N1ZSAjMzg1IG1ha2UgdXNlIG9mIHRoZSB2aXNpYmlsaXR5IGFwaVxyXG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9HdWlkZS9Vc2VyX2V4cGVyaWVuY2UvVXNpbmdfdGhlX1BhZ2VfVmlzaWJpbGl0eV9BUElcclxuICAgICAgICAgICAgdmFyIGhpZGRlbiwgdmlzaWJpbGl0eUNoYW5nZTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudC5oaWRkZW4gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBoaWRkZW4gPSAnaGlkZGVuJztcclxuICAgICAgICAgICAgICAgIHZpc2liaWxpdHlDaGFuZ2UgPSAndmlzaWJpbGl0eWNoYW5nZSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoJ21zSGlkZGVuJyBpbiBkb2N1bWVudCkge1xyXG4gICAgICAgICAgICAgICAgaGlkZGVuID0gJ21zSGlkZGVuJztcclxuICAgICAgICAgICAgICAgIHZpc2liaWxpdHlDaGFuZ2UgPSAnbXN2aXNpYmlsaXR5Y2hhbmdlJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgnd2Via2l0SGlkZGVuJyBpbiBkb2N1bWVudCkge1xyXG4gICAgICAgICAgICAgICAgaGlkZGVuID0gJ3dlYmtpdEhpZGRlbic7XHJcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5Q2hhbmdlID0gJ3dlYmtpdHZpc2liaWxpdHljaGFuZ2UnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIodmlzaWJpbGl0eUNoYW5nZSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50W2hpZGRlbl0pIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ldmVudERpc3BhdGNoZXIuZW1pdCgnaGlkZGVuJywgbmV3IEV2ZW50c18xMi5IaWRkZW5FdmVudChfdGhpcykpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuZGVidWcoJ1dpbmRvdyBoaWRkZW4nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50RGlzcGF0Y2hlci5lbWl0KCd2aXNpYmxlJywgbmV3IEV2ZW50c18xMi5WaXNpYmxlRXZlbnQoX3RoaXMpKTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmRlYnVnKCdXaW5kb3cgdmlzaWJsZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5jdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuc3VwcHJlc3NIaURQSVNjYWxpbmcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVIaURwaSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5jYW52YXNFbGVtZW50SWQpIHtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBFbmdpbmUucHJvdG90eXBlLl9pbnRpYWxpemVEaXNwbGF5TW9kZVBvc2l0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Rpc3BsYXlNb2RlIG9mIFBvc2l0aW9uIHdhcyBzZWxlY3RlZCBidXQgbm8gcG9zaXRpb24gb3B0aW9uIHdhcyBnaXZlbicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMucG9zaXRpb24gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNwZWNpZmllZFBvc2l0aW9uID0gb3B0aW9ucy5wb3NpdGlvbi5zcGxpdCgnICcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3BlY2lmaWVkUG9zaXRpb25bMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndG9wJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLnRvcCA9ICcwcHgnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5ib3R0b20gPSAnMHB4JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdtaWRkbGUnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUudG9wID0gJzUwJSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0WSA9IC10aGlzLmhhbGZEcmF3SGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUubWFyZ2luVG9wID0gb2Zmc2V0WS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUG9zaXRpb24gR2l2ZW4nKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwZWNpZmllZFBvc2l0aW9uWzFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3BlY2lmaWVkUG9zaXRpb25bMV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmxlZnQgPSAnMHB4JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5yaWdodCA9ICcwcHgnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5sZWZ0ID0gJzUwJSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldFggPSAtdGhpcy5oYWxmRHJhd1dpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLm1hcmdpbkxlZnQgPSBvZmZzZXRYLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBQb3NpdGlvbiBHaXZlbicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucG9zaXRpb24udG9wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBvcHRpb25zLnBvc2l0aW9uLnRvcCA9PT0gJ251bWJlcicgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUudG9wID0gb3B0aW9ucy5wb3NpdGlvbi50b3AudG9TdHJpbmcoKSArICdweCcgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUudG9wID0gb3B0aW9ucy5wb3NpdGlvbi50b3A7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnBvc2l0aW9uLnJpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBvcHRpb25zLnBvc2l0aW9uLnJpZ2h0ID09PSAnbnVtYmVyJyA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5yaWdodCA9IG9wdGlvbnMucG9zaXRpb24ucmlnaHQudG9TdHJpbmcoKSArICdweCcgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUucmlnaHQgPSBvcHRpb25zLnBvc2l0aW9uLnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5wb3NpdGlvbi5ib3R0b20pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIG9wdGlvbnMucG9zaXRpb24uYm90dG9tID09PSAnbnVtYmVyJyA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5ib3R0b20gPSBvcHRpb25zLnBvc2l0aW9uLmJvdHRvbS50b1N0cmluZygpICsgJ3B4JyA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5ib3R0b20gPSBvcHRpb25zLnBvc2l0aW9uLmJvdHRvbTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucG9zaXRpb24ubGVmdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygb3B0aW9ucy5wb3NpdGlvbi5sZWZ0ID09PSAnbnVtYmVyJyA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5sZWZ0ID0gb3B0aW9ucy5wb3NpdGlvbi5sZWZ0LnRvU3RyaW5nKCkgKyAncHgnIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmxlZnQgPSBvcHRpb25zLnBvc2l0aW9uLmxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBFbmdpbmUucHJvdG90eXBlLl9pbml0aWFsaXplSGlEcGkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIFNjYWxlIHRoZSBjYW52YXMgaWYgbmVlZGVkXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSGlEcGkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvbGRXaWR0aCA9IHRoaXMuY2FudmFzLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgdmFyIG9sZEhlaWdodCA9IHRoaXMuY2FudmFzLmhlaWdodDtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gb2xkV2lkdGggKiB0aGlzLnBpeGVsUmF0aW87XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSBvbGRIZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW87XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS53aWR0aCA9IG9sZFdpZHRoICsgJ3B4JztcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmhlaWdodCA9IG9sZEhlaWdodCArICdweCc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIud2FybihcIkhpIERQSSBzY3JlZW4gZGV0ZWN0ZWQsIHJlc2V0dGluZyBjYW52YXMgcmVzb2x1dGlvbiBmcm9tIFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiICsgb2xkV2lkdGggKyBcInhcIiArIG9sZEhlaWdodCArIFwiIHRvIFwiICsgdGhpcy5jYW52YXMud2lkdGggKyBcInhcIiArIHRoaXMuY2FudmFzLmhlaWdodCArIFwiIFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzcyBzaXplIHdpbGwgcmVtYWluIFwiICsgb2xkV2lkdGggKyBcInhcIiArIG9sZEhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN0eC5zY2FsZSh0aGlzLnBpeGVsUmF0aW8sIHRoaXMucGl4ZWxSYXRpbyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIud2FybihcIkNhbnZhcyBkcmF3aW5nIGNvbnRleHQgd2FzIHNjYWxlZCBieSBcIiArIHRoaXMucGl4ZWxSYXRpbyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIHN1cHBvcnRlZCBieSB0aGUgYnJvd3NlciwgdGhpcyB3aWxsIHNldCB0aGUgYW50aWFsaWFzaW5nIGZsYWcgb24gdGhlXHJcbiAgICAgICAgICogY2FudmFzLiBTZXQgdGhpcyB0byBgZmFsc2VgIGlmIHlvdSB3YW50IGEgJ2phZ2dlZCcgcGl4ZWwgYXJ0IGxvb2sgdG8geW91clxyXG4gICAgICAgICAqIGltYWdlIHJlc291cmNlcy5cclxuICAgICAgICAgKiBAcGFyYW0gaXNTbW9vdGggIFNldCBzbW9vdGhpbmcgdG8gdHJ1ZSBvciBmYWxzZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuc2V0QW50aWFsaWFzaW5nID0gZnVuY3Rpb24gKGlzU21vb3RoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzU21vb3RoaW5nRW5hYmxlZCA9IGlzU21vb3RoO1xyXG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XHJcbiAgICAgICAgICAgIGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBpc1Ntb290aDtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IFsnd2Via2l0SW1hZ2VTbW9vdGhpbmdFbmFibGVkJywgJ21vekltYWdlU21vb3RoaW5nRW5hYmxlZCcsICdtc0ltYWdlU21vb3RoaW5nRW5hYmxlZCddOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNtb290aGluZyA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgIGlmIChzbW9vdGhpbmcgaW4gY3R4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4W3Ntb290aGluZ10gPSBpc1Ntb290aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm4gdGhlIGN1cnJlbnQgc21vb3RoaW5nIHN0YXR1cyBvZiB0aGUgY2FudmFzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5nZXRBbnRpYWxpYXNpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgfHxcclxuICAgICAgICAgICAgICAgIHRoaXMuY3R4LndlYmtpdEltYWdlU21vb3RoaW5nRW5hYmxlZCB8fFxyXG4gICAgICAgICAgICAgICAgdGhpcy5jdHgubW96SW1hZ2VTbW9vdGhpbmdFbmFibGVkIHx8XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN0eC5tc0ltYWdlU21vb3RoaW5nRW5hYmxlZDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwZGF0ZXMgdGhlIGVudGlyZSBzdGF0ZSBvZiB0aGUgZ2FtZVxyXG4gICAgICAgICAqIEBwYXJhbSBkZWx0YSAgTnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHVwZGF0ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBFbmdpbmUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzTG9hZGluZykge1xyXG4gICAgICAgICAgICAgICAgLy8gc3VzcGVuZCB1cGRhdGVzIHVudGlsbCBsb2FkaW5nIGlzIGZpbmlzaGVkXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkZXIudXBkYXRlKHRoaXMsIGRlbHRhKTtcclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBpbnB1dCBsaXN0ZW5lcnNcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQua2V5Ym9hcmQudXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0LnBvaW50ZXJzLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dC5nYW1lcGFkcy51cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3ByZXVwZGF0ZScsIG5ldyBFdmVudHNfMTIuUHJlVXBkYXRlRXZlbnQodGhpcywgZGVsdGEsIHRoaXMpKTtcclxuICAgICAgICAgICAgLy8gcHJvY2VzcyBlbmdpbmUgbGV2ZWwgZXZlbnRzXHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLnVwZGF0ZSh0aGlzLCBkZWx0YSk7XHJcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBhbmltYXRpb25zXHJcbiAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbnMgPSB0aGlzLl9hbmltYXRpb25zLmZpbHRlcihmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICFhLmFuaW1hdGlvbi5pc0RvbmUoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBpbnB1dCBsaXN0ZW5lcnNcclxuICAgICAgICAgICAgdGhpcy5pbnB1dC5rZXlib2FyZC51cGRhdGUoKTtcclxuICAgICAgICAgICAgdGhpcy5pbnB1dC5wb2ludGVycy51cGRhdGUoKTtcclxuICAgICAgICAgICAgdGhpcy5pbnB1dC5nYW1lcGFkcy51cGRhdGUoKTtcclxuICAgICAgICAgICAgLy8gUHVibGlzaCB1cGRhdGUgZXZlbnRcclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdwb3N0dXBkYXRlJywgbmV3IEV2ZW50c18xMi5Qb3N0VXBkYXRlRXZlbnQodGhpcywgZGVsdGEsIHRoaXMpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERyYXdzIHRoZSBlbnRpcmUgZ2FtZVxyXG4gICAgICAgICAqIEBwYXJhbSBkZWx0YSAgTnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IGRyYXcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5fZHJhdyA9IGZ1bmN0aW9uIChkZWx0YSkge1xyXG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncHJlZHJhdycsIG5ldyBFdmVudHNfMTIuUHJlRHJhd0V2ZW50KGN0eCwgZGVsdGEsIHRoaXMpKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzTG9hZGluZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZGVyLmRyYXcoY3R4LCBkZWx0YSk7XHJcbiAgICAgICAgICAgICAgICAvLyBEcmF3aW5nIG5vdGhpbmcgZWxzZSB3aGlsZSBsb2FkaW5nXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmNhbnZhc1dpZHRoLCB0aGlzLmNhbnZhc0hlaWdodCk7XHJcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmJhY2tncm91bmRDb2xvci50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgdGhpcy5jYW52YXNXaWR0aCwgdGhpcy5jYW52YXNIZWlnaHQpO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5kcmF3KHRoaXMuY3R4LCBkZWx0YSk7XHJcbiAgICAgICAgICAgIC8vIHRvZG8gbmVlZHMgdG8gYmUgYSBiZXR0ZXIgd2F5IG9mIGRvaW5nIHRoaXNcclxuICAgICAgICAgICAgdmFyIGEgPSAwLCBsZW4gPSB0aGlzLl9hbmltYXRpb25zLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChhOyBhIDwgbGVuOyBhKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbnNbYV0uYW5pbWF0aW9uLmRyYXcoY3R4LCB0aGlzLl9hbmltYXRpb25zW2FdLngsIHRoaXMuX2FuaW1hdGlvbnNbYV0ueSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gRHJhdyBkZWJ1ZyBpbmZvcm1hdGlvblxyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0RlYnVnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN0eC5mb250ID0gJ0NvbnNvbGFzJztcclxuICAgICAgICAgICAgICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IHRoaXMuZGVidWdDb2xvci50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleXMgPSB0aGlzLmlucHV0LmtleWJvYXJkLmdldEtleXMoKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwga2V5cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3R4LmZpbGxUZXh0KGtleXNbal0udG9TdHJpbmcoKSArICcgOiAnICsgKElucHV0LktleXNba2V5c1tqXV0gPyBJbnB1dC5LZXlzW2tleXNbal1dIDogJ05vdCBNYXBwZWQnKSwgMTAwLCAxMCAqIGogKyAxMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN0eC5maWxsVGV4dCgnRlBTOicgKyB0aGlzLnN0YXRzLmN1cnJGcmFtZS5mcHMudG9GaXhlZCgyKS50b1N0cmluZygpLCAxMCwgMTApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFBvc3QgcHJvY2Vzc2luZ1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucG9zdFByb2Nlc3NvcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9zdFByb2Nlc3NvcnNbaV0ucHJvY2Vzcyh0aGlzLmN0eC5nZXRJbWFnZURhdGEoMCwgMCwgdGhpcy5jYW52YXNXaWR0aCwgdGhpcy5jYW52YXNIZWlnaHQpLCB0aGlzLmN0eCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdwb3N0ZHJhdycsIG5ldyBFdmVudHNfMTIuUG9zdERyYXdFdmVudChjdHgsIGRlbHRhLCB0aGlzKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTdGFydHMgdGhlIGludGVybmFsIGdhbWUgbG9vcCBmb3IgRXhjYWxpYnVyIGFmdGVyIGxvYWRpbmdcclxuICAgICAgICAgKiBhbnkgcHJvdmlkZWQgYXNzZXRzLlxyXG4gICAgICAgICAqIEBwYXJhbSBsb2FkZXIgIE9wdGlvbmFsIFtbSUxvYWRlcl1dIHRvIHVzZSB0byBsb2FkIHJlc291cmNlcy4gVGhlIGRlZmF1bHQgbG9hZGVyIGlzIFtbTG9hZGVyXV0sIG92ZXJyaWRlIHRvIHByb3ZpZGUgeW91ciBvd25cclxuICAgICAgICAgKiBjdXN0b20gbG9hZGVyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAobG9hZGVyKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fY29tcGF0aWJsZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZXNfOC5Qcm9taXNlKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZS5yZWplY3QoJ0V4Y2FsaWJ1ciBpcyBpbmNvbXBhdGlibGUgd2l0aCB5b3VyIGJyb3dzZXInKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbG9hZGluZ0NvbXBsZXRlO1xyXG4gICAgICAgICAgICBpZiAobG9hZGVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkZXIgPSBsb2FkZXI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkZXIud2lyZUVuZ2luZSh0aGlzKTtcclxuICAgICAgICAgICAgICAgIGxvYWRpbmdDb21wbGV0ZSA9IHRoaXMubG9hZCh0aGlzLl9sb2FkZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbG9hZGluZ0NvbXBsZXRlID0gUHJvbWlzZXNfOC5Qcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsb2FkaW5nQ29tcGxldGUudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KCdzdGFydCcsIG5ldyBFdmVudHNfMTIuR2FtZVN0YXJ0RXZlbnQoX3RoaXMpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5faGFzU3RhcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faGFzU3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoJ1N0YXJ0aW5nIGdhbWUuLi4nKTtcclxuICAgICAgICAgICAgICAgIEVuZ2luZS5jcmVhdGVNYWluTG9vcCh0aGlzLCB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBEYXRlLm5vdykoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZygnR2FtZSBzdGFydGVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBHYW1lIGFscmVhZHkgc3RhcnRlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbG9hZGluZ0NvbXBsZXRlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRW5naW5lLmNyZWF0ZU1haW5Mb29wID0gZnVuY3Rpb24gKGdhbWUsIHJhZiwgbm93Rm4pIHtcclxuICAgICAgICAgICAgdmFyIGxhc3RUaW1lID0gbm93Rm4oKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG1haW5sb29wKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFnYW1lLl9oYXNTdGFydGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBnYW1lLl9yZXF1ZXN0SWQgPSByYWYobWFpbmxvb3ApO1xyXG4gICAgICAgICAgICAgICAgICAgIGdhbWUuZW1pdCgncHJlZnJhbWUnLCBuZXcgRXZlbnRzXzEyLlByZUZyYW1lRXZlbnQoZ2FtZSwgZ2FtZS5zdGF0cy5wcmV2RnJhbWUpKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHRpbWUgdG8gY2FsY3VsYXRlIHRpbWUtZWxhcHNlZFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBub3cgPSBub3dGbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGFwc2VkID0gTWF0aC5mbG9vcihub3cgLSBsYXN0VGltZSkgfHwgMTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBSZXNvbHZlcyBpc3N1ZSAjMTM4IGlmIHRoZSBnYW1lIGhhcyBiZWVuIHBhdXNlZCwgb3IgYmx1cnJlZCBmb3IgXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbW9yZSB0aGFuIGEgMjAwIG1pbGxpc2Vjb25kcywgcmVzZXQgZWxhcHNlZCB0aW1lIHRvIDEuIFRoaXMgaW1wcm92ZXMgcmVsaWFiaWxpdHkgXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHByb3ZpZGVzIG1vcmUgZXhwZWN0ZWQgYmVoYXZpb3Igd2hlbiB0aGUgZW5naW5lIGNvbWVzIGJhY2tcclxuICAgICAgICAgICAgICAgICAgICAvLyBpbnRvIGZvY3VzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsYXBzZWQgPiAyMDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxhcHNlZCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YSA9IGVsYXBzZWQgKiBnYW1lLnRpbWVzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyByZXNldCBmcmFtZSBzdGF0cyAocmV1c2UgZXhpc3RpbmcgaW5zdGFuY2VzKVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZUlkID0gZ2FtZS5zdGF0cy5wcmV2RnJhbWUuaWQgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGdhbWUuc3RhdHMucHJldkZyYW1lLnJlc2V0KGdhbWUuc3RhdHMuY3VyckZyYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBnYW1lLnN0YXRzLmN1cnJGcmFtZS5yZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGdhbWUuc3RhdHMuY3VyckZyYW1lLmlkID0gZnJhbWVJZDtcclxuICAgICAgICAgICAgICAgICAgICBnYW1lLnN0YXRzLmN1cnJGcmFtZS5kZWx0YSA9IGRlbHRhO1xyXG4gICAgICAgICAgICAgICAgICAgIGdhbWUuc3RhdHMuY3VyckZyYW1lLmZwcyA9IDEuMCAvIChkZWx0YSAvIDEwMDApO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBiZWZvcmVVcGRhdGUgPSBub3dGbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGdhbWUuX3VwZGF0ZShkZWx0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFmdGVyVXBkYXRlID0gbm93Rm4oKTtcclxuICAgICAgICAgICAgICAgICAgICBnYW1lLl9kcmF3KGRlbHRhKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWZ0ZXJEcmF3ID0gbm93Rm4oKTtcclxuICAgICAgICAgICAgICAgICAgICBnYW1lLnN0YXRzLmN1cnJGcmFtZS5kdXJhdGlvbi51cGRhdGUgPSBhZnRlclVwZGF0ZSAtIGJlZm9yZVVwZGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICBnYW1lLnN0YXRzLmN1cnJGcmFtZS5kdXJhdGlvbi5kcmF3ID0gYWZ0ZXJEcmF3IC0gYWZ0ZXJVcGRhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRpbWUgPSBub3c7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2FtZS5lbWl0KCdwb3N0ZnJhbWUnLCBuZXcgRXZlbnRzXzEyLlBvc3RGcmFtZUV2ZW50KGdhbWUsIGdhbWUuc3RhdHMuY3VyckZyYW1lKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShnYW1lLl9yZXF1ZXN0SWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGdhbWUuc3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGdhbWUub25GYXRhbEV4Y2VwdGlvbihlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN0b3BzIEV4Y2FsaWJ1cidzIG1haW4gbG9vcCwgdXNlZnVsIGZvciBwYXVzaW5nIHRoZSBnYW1lLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2hhc1N0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RvcCcsIG5ldyBFdmVudHNfMTIuR2FtZVN0b3BFdmVudCh0aGlzKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9oYXNTdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoJ0dhbWUgc3RvcHBlZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBFbmdpbmUncyBSdW5uaW5nIHN0YXR1cywgVXNlZnVsIGZvciBjaGVja2luZyB3aGV0aGVyIGVuZ2luZSBpcyBydW5uaW5nIG9yIHBhdXNlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBFbmdpbmUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gISh0aGlzLl9oYXNTdGFydGVkKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRha2VzIGEgc2NyZWVuIHNob3Qgb2YgdGhlIGN1cnJlbnQgdmlld3BvcnQgYW5kIHJldHVybnMgaXQgYXMgYW5cclxuICAgICAgICAgKiBIVE1MIEltYWdlIEVsZW1lbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5zY3JlZW5zaG90ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgICAgIHZhciByYXcgPSB0aGlzLmNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycpO1xyXG4gICAgICAgICAgICByZXN1bHQuc3JjID0gcmF3O1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW5vdGhlciBvcHRpb24gYXZhaWxhYmxlIHRvIHlvdSB0byBsb2FkIHJlc291cmNlcyBpbnRvIHRoZSBnYW1lLlxyXG4gICAgICAgICAqIEltbWVkaWF0ZWx5IGFmdGVyIGNhbGxpbmcgdGhpcyB0aGUgZ2FtZSB3aWxsIHBhdXNlIGFuZCB0aGUgbG9hZGluZyBzY3JlZW5cclxuICAgICAgICAgKiB3aWxsIGFwcGVhci5cclxuICAgICAgICAgKiBAcGFyYW0gbG9hZGVyICBTb21lIFtbSUxvYWRhYmxlXV0gc3VjaCBhcyBhIFtbTG9hZGVyXV0gY29sbGVjdGlvbiwgW1tTb3VuZF1dLCBvciBbW1RleHR1cmVdXS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBFbmdpbmUucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAobG9hZGVyKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBjb21wbGV0ZSA9IG5ldyBQcm9taXNlc184LlByb21pc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5faXNMb2FkaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgbG9hZGVyLmxvYWQoKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9pc0xvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9LCA1MDApO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEVuZ2luZTtcclxuICAgIH0oQ2xhc3NfOS5DbGFzcykpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZhdWx0IFtbSUVuZ2luZU9wdGlvbnNdXVxyXG4gICAgICovXHJcbiAgICBFbmdpbmUuX0RlZmF1bHRFbmdpbmVPcHRpb25zID0ge1xyXG4gICAgICAgIHdpZHRoOiAwLFxyXG4gICAgICAgIGhlaWdodDogMCxcclxuICAgICAgICBjYW52YXNFbGVtZW50SWQ6ICcnLFxyXG4gICAgICAgIHBvaW50ZXJTY29wZTogSW5wdXQuUG9pbnRlclNjb3BlLkRvY3VtZW50LFxyXG4gICAgICAgIHN1cHByZXNzQ29uc29sZUJvb3RNZXNzYWdlOiBudWxsLFxyXG4gICAgICAgIHN1cHByZXNzTWluaW11bUJyb3dzZXJGZWF0dXJlRGV0ZWN0aW9uOiBudWxsLFxyXG4gICAgICAgIHN1cHByZXNzSGlEUElTY2FsaW5nOiBudWxsLFxyXG4gICAgICAgIHNjcm9sbFByZXZlbnRpb25Nb2RlOiBTY3JvbGxQcmV2ZW50aW9uTW9kZS5DYW52YXMsXHJcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBDb2xvcl8xOS5Db2xvci5mcm9tSGV4KCcjMjE4NWQwJykgLy8gRXhjYWxpYnVyIGJsdWVcclxuICAgIH07XHJcbiAgICBleHBvcnRzLkVuZ2luZSA9IEVuZ2luZTtcclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHZhciBBbmltYXRpb25Ob2RlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBBbmltYXRpb25Ob2RlKGFuaW1hdGlvbiwgeCwgeSkge1xyXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbiA9IGFuaW1hdGlvbjtcclxuICAgICAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEFuaW1hdGlvbk5vZGU7XHJcbiAgICB9KCkpO1xyXG59KTtcclxuZGVmaW5lKFwiVUlBY3RvclwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkFsZ2VicmFcIiwgXCJBY3RvclwiLCBcIlRyYWl0cy9JbmRleFwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIEFsZ2VicmFfMjMsIEFjdG9yXzEzLCBUcmFpdHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBIZWxwZXIgW1tBY3Rvcl1dIHByaW1pdGl2ZSBmb3IgZHJhd2luZyBVSSdzLCBvcHRpbWl6ZWQgZm9yIFVJIGRyYXdpbmcuIERvZXNcclxuICAgICAqIG5vdCBwYXJ0aWNpcGF0ZSBpbiBjb2xsaXNpb25zLiBEcmF3biBvbiB0b3Agb2YgYWxsIG90aGVyIGFjdG9ycy5cclxuICAgICAqL1xyXG4gICAgdmFyIFVJQWN0b3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhVSUFjdG9yLCBfc3VwZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB4ICAgICAgIFRoZSBzdGFydGluZyB4IGNvb3JkaW5hdGUgb2YgdGhlIGFjdG9yXHJcbiAgICAgICAgICogQHBhcmFtIHkgICAgICAgVGhlIHN0YXJ0aW5nIHkgY29vcmRpbmF0ZSBvZiB0aGUgYWN0b3JcclxuICAgICAgICAgKiBAcGFyYW0gd2lkdGggICBUaGUgc3RhcnRpbmcgd2lkdGggb2YgdGhlIGFjdG9yXHJcbiAgICAgICAgICogQHBhcmFtIGhlaWdodCAgVGhlIHN0YXJ0aW5nIGhlaWdodCBvZiB0aGUgYWN0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBVSUFjdG9yKHhPckNvbmZpZywgeSwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mICh4T3JDb25maWcgIT09ICdvYmplY3QnKSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB4T3JDb25maWcsIHksIHdpZHRoLCBoZWlnaHQpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHhPckNvbmZpZykgfHwgdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy50cmFpdHMgPSBbXTtcclxuICAgICAgICAgICAgX3RoaXMudHJhaXRzLnB1c2gobmV3IFRyYWl0cy5DYXB0dXJlUG9pbnRlcigpKTtcclxuICAgICAgICAgICAgX3RoaXMuYW5jaG9yLnNldFRvKDAsIDApO1xyXG4gICAgICAgICAgICBfdGhpcy5jb2xsaXNpb25UeXBlID0gQWN0b3JfMTMuQ29sbGlzaW9uVHlwZS5QcmV2ZW50Q29sbGlzaW9uO1xyXG4gICAgICAgICAgICBfdGhpcy5lbmFibGVDYXB0dXJlUG9pbnRlciA9IHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgVUlBY3Rvci5wcm90b3R5cGUub25Jbml0aWFsaXplID0gZnVuY3Rpb24gKGVuZ2luZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9lbmdpbmUgPSBlbmdpbmU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBVSUFjdG9yLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uICh4LCB5LCB1c2VXb3JsZCkge1xyXG4gICAgICAgICAgICBpZiAodXNlV29ybGQgPT09IHZvaWQgMCkgeyB1c2VXb3JsZCA9IHRydWU7IH1cclxuICAgICAgICAgICAgaWYgKHVzZVdvcmxkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5jb250YWlucy5jYWxsKHRoaXMsIHgsIHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjb29yZHMgPSB0aGlzLl9lbmdpbmUud29ybGRUb1NjcmVlbkNvb3JkaW5hdGVzKG5ldyBBbGdlYnJhXzIzLlZlY3Rvcih4LCB5KSk7XHJcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmNvbnRhaW5zLmNhbGwodGhpcywgY29vcmRzLngsIGNvb3Jkcy55KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBVSUFjdG9yO1xyXG4gICAgfShBY3Rvcl8xMy5BY3RvcikpO1xyXG4gICAgZXhwb3J0cy5VSUFjdG9yID0gVUlBY3RvcjtcclxufSk7XHJcbmRlZmluZShcIlV0aWwvQWN0b3JzXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiVUlBY3RvclwiLCBcIkxhYmVsXCIsIFwiVHJpZ2dlclwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIFVJQWN0b3JfNCwgTGFiZWxfMywgVHJpZ2dlcl8yKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIGZ1bmN0aW9uIGlzVmFuaWxsYUFjdG9yKGFjdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuICEoYWN0b3IgaW5zdGFuY2VvZiBVSUFjdG9yXzQuVUlBY3RvcikgJiZcclxuICAgICAgICAgICAgIShhY3RvciBpbnN0YW5jZW9mIFRyaWdnZXJfMi5UcmlnZ2VyKSAmJlxyXG4gICAgICAgICAgICAhKGFjdG9yIGluc3RhbmNlb2YgTGFiZWxfMy5MYWJlbCk7XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLmlzVmFuaWxsYUFjdG9yID0gaXNWYW5pbGxhQWN0b3I7XHJcbiAgICBmdW5jdGlvbiBpc1VJQWN0b3IoYWN0b3IpIHtcclxuICAgICAgICByZXR1cm4gYWN0b3IgaW5zdGFuY2VvZiBVSUFjdG9yXzQuVUlBY3RvcjtcclxuICAgIH1cclxuICAgIGV4cG9ydHMuaXNVSUFjdG9yID0gaXNVSUFjdG9yO1xyXG59KTtcclxuZGVmaW5lKFwiU2NlbmVcIiwgW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJVSUFjdG9yXCIsIFwiUGh5c2ljc1wiLCBcIkV2ZW50c1wiLCBcIlV0aWwvTG9nXCIsIFwiVGltZXJcIiwgXCJDb2xsaXNpb24vRHluYW1pY1RyZWVDb2xsaXNpb25Ccm9hZHBoYXNlXCIsIFwiVXRpbC9Tb3J0ZWRMaXN0XCIsIFwiR3JvdXBcIiwgXCJUaWxlTWFwXCIsIFwiQ2FtZXJhXCIsIFwiQWN0b3JcIiwgXCJDbGFzc1wiLCBcIlV0aWwvVXRpbFwiLCBcIlV0aWwvQWN0b3JzXCIsIFwiVHJpZ2dlclwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIFVJQWN0b3JfNSwgUGh5c2ljc18xMiwgRXZlbnRzXzEzLCBMb2dfMTUsIFRpbWVyXzMsIER5bmFtaWNUcmVlQ29sbGlzaW9uQnJvYWRwaGFzZV8yLCBTb3J0ZWRMaXN0XzIsIEdyb3VwXzIsIFRpbGVNYXBfMywgQ2FtZXJhXzIsIEFjdG9yXzE0LCBDbGFzc18xMCwgVXRpbCwgQWN0b3JVdGlscywgVHJpZ2dlcl8zKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogW1tBY3RvcnxBY3RvcnNdXSBhcmUgY29tcG9zZWQgdG9nZXRoZXIgaW50byBncm91cGluZ3MgY2FsbGVkIFNjZW5lcyBpblxyXG4gICAgICogRXhjYWxpYnVyLiBUaGUgbWV0YXBob3IgbW9kZWxzIHRoZSBzYW1lIGlkZWEgYmVoaW5kIHJlYWwgd29ybGRcclxuICAgICAqIGFjdG9ycyBpbiBhIHNjZW5lLiBPbmx5IGFjdG9ycyBpbiBzY2VuZXMgd2lsbCBiZSB1cGRhdGVkIGFuZCBkcmF3bi5cclxuICAgICAqXHJcbiAgICAgKiBUeXBpY2FsIHVzYWdlcyBvZiBhIHNjZW5lIGluY2x1ZGU6IGxldmVscywgbWVudXMsIGxvYWRpbmcgc2NyZWVucywgZXRjLlxyXG4gICAgICpcclxuICAgICAqIFtbaW5jbHVkZTpTY2VuZXMubWRdXVxyXG4gICAgICovXHJcbiAgICB2YXIgU2NlbmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhTY2VuZSwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBTY2VuZShlbmdpbmUpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBhY3RvcnMgaW4gdGhlIGN1cnJlbnQgc2NlbmVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmFjdG9ycyA9IFtdO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIHRyaWdnZXJzIGluIHRoZSBjdXJyZW50IHNjZW5lXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy50cmlnZ2VycyA9IFtdO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIFtbVGlsZU1hcF1dcyBpbiB0aGUgc2NlbmUsIGlmIGFueVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMudGlsZU1hcHMgPSBbXTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBbW0dyb3VwXV1zIGluIHRoZSBzY2VuZSwgaWYgYW55XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5ncm91cHMgPSB7fTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBbW1VJQWN0b3JdXXMgaW4gYSBzY2VuZSwgaWYgYW55OyB0aGVzZSBhcmUgZHJhd24gbGFzdFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMudWlBY3RvcnMgPSBbXTtcclxuICAgICAgICAgICAgX3RoaXMuX2lzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgX3RoaXMuX3NvcnRlZERyYXdpbmdUcmVlID0gbmV3IFNvcnRlZExpc3RfMi5Tb3J0ZWRMaXN0KEFjdG9yXzE0LkFjdG9yLnByb3RvdHlwZS5nZXRaSW5kZXgpO1xyXG4gICAgICAgICAgICBfdGhpcy5fYnJvYWRwaGFzZSA9IG5ldyBEeW5hbWljVHJlZUNvbGxpc2lvbkJyb2FkcGhhc2VfMi5EeW5hbWljVHJlZUNvbGxpc2lvbkJyb2FkcGhhc2UoKTtcclxuICAgICAgICAgICAgX3RoaXMuX2tpbGxRdWV1ZSA9IFtdO1xyXG4gICAgICAgICAgICBfdGhpcy5fdHJpZ2dlcktpbGxRdWV1ZSA9IFtdO1xyXG4gICAgICAgICAgICBfdGhpcy5fdGltZXJzID0gW107XHJcbiAgICAgICAgICAgIF90aGlzLl9jYW5jZWxRdWV1ZSA9IFtdO1xyXG4gICAgICAgICAgICBfdGhpcy5fbG9nZ2VyID0gTG9nXzE1LkxvZ2dlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgICAgICBfdGhpcy5jYW1lcmEgPSBuZXcgQ2FtZXJhXzIuQmFzZUNhbWVyYSgpO1xyXG4gICAgICAgICAgICBpZiAoZW5naW5lKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5jYW1lcmEueCA9IGVuZ2luZS5oYWxmRHJhd1dpZHRoO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY2FtZXJhLnkgPSBlbmdpbmUuaGFsZkRyYXdIZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBTY2VuZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBpcyBjYWxsZWQgYmVmb3JlIHRoZSBmaXJzdCB1cGRhdGUgb2YgdGhlIFtbU2NlbmVdXS4gSW5pdGlhbGl6ZXMgc2NlbmUgbWVtYmVycyBsaWtlIHRoZSBjYW1lcmEuIFRoaXMgbWV0aG9kIGlzIG1lYW50IHRvIGJlXHJcbiAgICAgICAgICogb3ZlcnJpZGRlbi4gVGhpcyBpcyB3aGVyZSBpbml0aWFsaXphdGlvbiBvZiBjaGlsZCBhY3RvcnMgc2hvdWxkIHRha2UgcGxhY2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2NlbmUucHJvdG90eXBlLm9uSW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChlbmdpbmUpIHtcclxuICAgICAgICAgICAgLy8gd2lsbCBiZSBvdmVycmlkZGVuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbWVyYSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYW1lcmEueCA9IGVuZ2luZS5oYWxmRHJhd1dpZHRoO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYW1lcmEueSA9IGVuZ2luZS5oYWxmRHJhd0hlaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoJ1NjZW5lLm9uSW5pdGlhbGl6ZScsIHRoaXMsIGVuZ2luZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoZSBzY2VuZSBpcyBtYWRlIGFjdGl2ZSBhbmQgc3RhcnRlZC4gSXQgaXMgbWVhbnQgdG8gYmUgb3ZlcnJpZGVuLFxyXG4gICAgICAgICAqIHRoaXMgaXMgd2hlcmUgeW91IHNob3VsZCBzZXR1cCBhbnkgRE9NIFVJIG9yIGV2ZW50IGhhbmRsZXJzIG5lZWRlZCBmb3IgdGhlIHNjZW5lLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5vbkFjdGl2YXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyB3aWxsIGJlIG92ZXJyaWRkZW5cclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCdTY2VuZS5vbkFjdGl2YXRlJywgdGhpcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoZSBzY2VuZSBpcyBtYWRlIHRyYW5zaXRpb25lZCBhd2F5IGZyb20gYW5kIHN0b3BwZWQuIEl0IGlzIG1lYW50IHRvIGJlIG92ZXJyaWRlbixcclxuICAgICAgICAgKiB0aGlzIGlzIHdoZXJlIHlvdSBzaG91bGQgY2xlYW51cCBhbnkgRE9NIFVJIG9yIGV2ZW50IGhhbmRsZXJzIG5lZWRlZCBmb3IgdGhlIHNjZW5lLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5vbkRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIHdpbGwgYmUgb3ZlcnJpZGRlblxyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoJ1NjZW5lLm9uRGVhY3RpdmF0ZScsIHRoaXMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgYWN0b3JzIGluIHRoZSBzY2VuZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5faW5pdGlhbGl6ZUNoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5hY3RvcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICBjaGlsZC5faW5pdGlhbGl6ZSh0aGlzLmVuZ2luZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2VuZS5wcm90b3R5cGUsIFwiaXNJbml0aWFsaXplZFwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHdoZXRoZXIgb3Igbm90IHRoZSBbW1NjZW5lXV0gaGFzIGJlZW4gaW5pdGlhbGl6ZWRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzSW5pdGlhbGl6ZWQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluaXRpYWxpemVzIHRoZSBzY2VuZSBiZWZvcmUgdGhlIGZpcnN0IHVwZGF0ZSwgbWVhbnQgdG8gYmUgY2FsbGVkIGJ5IGVuZ2luZSBub3QgYnkgdXNlcnMgb2ZcclxuICAgICAgICAgKiBFeGNhbGlidXJcclxuICAgICAgICAgKiBAaW50ZXJuYWxcclxuICAgICAgICAgKi9cclxuICAgICAgICBTY2VuZS5wcm90b3R5cGUuX2luaXRpYWxpemUgPSBmdW5jdGlvbiAoZW5naW5lKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0luaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uSW5pdGlhbGl6ZS5jYWxsKHRoaXMsIGVuZ2luZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5lbWl0KCdpbml0aWFsaXplJywgbmV3IEV2ZW50c18xMy5Jbml0aWFsaXplRXZlbnQoZW5naW5lLCB0aGlzKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplQ2hpbGRyZW4oKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGVzIGFsbCB0aGUgYWN0b3JzIGFuZCB0aW1lcnMgaW4gdGhlIHNjZW5lLiBDYWxsZWQgYnkgdGhlIFtbRW5naW5lXV0uXHJcbiAgICAgICAgICogQHBhcmFtIGVuZ2luZSAgUmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IEVuZ2luZVxyXG4gICAgICAgICAqIEBwYXJhbSBkZWx0YSAgIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBsYXN0IHVwZGF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZW5naW5lLCBkZWx0YSkge1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3ByZXVwZGF0ZScsIG5ldyBFdmVudHNfMTMuUHJlVXBkYXRlRXZlbnQoZW5naW5lLCBkZWx0YSwgdGhpcykpO1xyXG4gICAgICAgICAgICB2YXIgaSwgbGVuO1xyXG4gICAgICAgICAgICAvLyBSZW1vdmUgdGltZXJzIGluIHRoZSBjYW5jZWwgcXVldWUgYmVmb3JlIHVwZGF0aW5nIHRoZW1cclxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy5fY2FuY2VsUXVldWUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlVGltZXIodGhpcy5fY2FuY2VsUXVldWVbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbmNlbFF1ZXVlLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIC8vIEN5Y2xlIHRocm91Z2ggdGltZXJzIHVwZGF0aW5nIHRpbWVyc1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5fdGltZXJzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRpbWVyID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgdGltZXIudXBkYXRlKGRlbHRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA7XHJcbiAgICAgICAgICAgIC8vIEN5Y2xlIHRocm91Z2ggYWN0b3JzIHVwZGF0aW5nIFVJIGFjdG9yc1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLnVpQWN0b3JzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVpQWN0b3JzW2ldLnVwZGF0ZShlbmdpbmUsIGRlbHRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBDeWNsZSB0aHJvdWdoIGFjdG9ycyB1cGRhdGluZyB0aWxlIG1hcHNcclxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy50aWxlTWFwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50aWxlTWFwc1tpXS51cGRhdGUoZW5naW5lLCBkZWx0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQ3ljbGUgdGhyb3VnaCBhY3RvcnMgdXBkYXRpbmcgYWN0b3JzXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuYWN0b3JzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFjdG9yc1tpXS51cGRhdGUoZW5naW5lLCBkZWx0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQ3ljbGUgdGhyb3VnaCB0cmlnZ2VycyB1cGRhdGluZ1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLnRyaWdnZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJzW2ldLnVwZGF0ZShlbmdpbmUsIGRlbHRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9jb2xsZWN0QWN0b3JTdGF0cyhlbmdpbmUpO1xyXG4gICAgICAgICAgICAvLyBSdW4gdGhlIGJyb2FkcGhhc2UgYW5kIG5hcnJvd3BoYXNlXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9icm9hZHBoYXNlICYmIFBoeXNpY3NfMTIuUGh5c2ljcy5lbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYmVmb3JlQnJvYWRwaGFzZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9icm9hZHBoYXNlLnVwZGF0ZSh0aGlzLmFjdG9ycywgZGVsdGEpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhaXJzID0gdGhpcy5fYnJvYWRwaGFzZS5icm9hZHBoYXNlKHRoaXMuYWN0b3JzLCBkZWx0YSwgZW5naW5lLnN0YXRzLmN1cnJGcmFtZSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWZ0ZXJCcm9hZHBoYXNlID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgICAgIHZhciBiZWZvcmVOYXJyb3dwaGFzZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXRlciA9IFBoeXNpY3NfMTIuUGh5c2ljcy5jb2xsaXNpb25QYXNzZXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29sbGlzaW9uRGVsdGEgPSBkZWx0YSAvIGl0ZXI7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaXRlciA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBSdW4gdGhlIG5hcnJvd3BoYXNlXHJcbiAgICAgICAgICAgICAgICAgICAgcGFpcnMgPSB0aGlzLl9icm9hZHBoYXNlLm5hcnJvd3BoYXNlKHBhaXJzLCBlbmdpbmUuc3RhdHMuY3VyckZyYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBSdW4gY29sbGlzaW9uIHJlc29sdXRpb24gc3RyYXRlZ3lcclxuICAgICAgICAgICAgICAgICAgICBwYWlycyA9IHRoaXMuX2Jyb2FkcGhhc2UucmVzb2x2ZShwYWlycywgY29sbGlzaW9uRGVsdGEsIFBoeXNpY3NfMTIuUGh5c2ljcy5jb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Jyb2FkcGhhc2UucnVuQ29sbGlzaW9uU3RhcnRFbmQocGFpcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZXItLTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBhZnRlck5hcnJvd3BoYXNlID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgICAgIGVuZ2luZS5zdGF0cy5jdXJyRnJhbWUucGh5c2ljcy5icm9hZHBoYXNlID0gYWZ0ZXJCcm9hZHBoYXNlIC0gYmVmb3JlQnJvYWRwaGFzZTtcclxuICAgICAgICAgICAgICAgIGVuZ2luZS5zdGF0cy5jdXJyRnJhbWUucGh5c2ljcy5uYXJyb3dwaGFzZSA9IGFmdGVyTmFycm93cGhhc2UgLSBiZWZvcmVOYXJyb3dwaGFzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbmdpbmUuc3RhdHMuY3VyckZyYW1lLmFjdG9ycy5raWxsZWQgPSB0aGlzLl9raWxsUXVldWUubGVuZ3RoICsgdGhpcy5fdHJpZ2dlcktpbGxRdWV1ZS5sZW5ndGg7XHJcbiAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NLaWxsUXVldWUodGhpcy5fa2lsbFF1ZXVlLCB0aGlzLmFjdG9ycyk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NLaWxsUXVldWUodGhpcy5fdHJpZ2dlcktpbGxRdWV1ZSwgdGhpcy50cmlnZ2Vycyk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbWVyYSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYW1lcmEudXBkYXRlKGVuZ2luZSwgZGVsdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncG9zdHVwZGF0ZScsIG5ldyBFdmVudHNfMTMuUG9zdFVwZGF0ZUV2ZW50KGVuZ2luZSwgZGVsdGEsIHRoaXMpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5fcHJvY2Vzc0tpbGxRdWV1ZSA9IGZ1bmN0aW9uIChraWxsUXVldWUsIGNvbGxlY3Rpb24pIHtcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIGFjdG9ycyBmcm9tIHNjZW5lIGdyYXBoIGFmdGVyIGJlaW5nIGtpbGxlZFxyXG4gICAgICAgICAgICB2YXIgYWN0b3JJbmRleDtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBraWxsUXVldWVfMSA9IGtpbGxRdWV1ZTsgX2kgPCBraWxsUXVldWVfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBraWxsZWQgPSBraWxsUXVldWVfMVtfaV07XHJcbiAgICAgICAgICAgICAgICBhY3RvckluZGV4ID0gY29sbGVjdGlvbi5pbmRleE9mKGtpbGxlZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWN0b3JJbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc29ydGVkRHJhd2luZ1RyZWUucmVtb3ZlQnlDb21wYXJhYmxlKGtpbGxlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbi5zcGxpY2UoYWN0b3JJbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAga2lsbFF1ZXVlLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEcmF3cyBhbGwgdGhlIGFjdG9ycyBpbiB0aGUgU2NlbmUuIENhbGxlZCBieSB0aGUgW1tFbmdpbmVdXS5cclxuICAgICAgICAgKiBAcGFyYW0gY3R4ICAgIFRoZSBjdXJyZW50IHJlbmRlcmluZyBjb250ZXh0XHJcbiAgICAgICAgICogQHBhcmFtIGRlbHRhICBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgbGFzdCBkcmF3XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2NlbmUucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoY3R4LCBkZWx0YSkge1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3ByZWRyYXcnLCBuZXcgRXZlbnRzXzEzLlByZURyYXdFdmVudChjdHgsIGRlbHRhLCB0aGlzKSk7XHJcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbWVyYSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYW1lcmEuZHJhdyhjdHgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpLCBsZW47XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHRoaXMudGlsZU1hcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGlsZU1hcHNbaV0uZHJhdyhjdHgsIGRlbHRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc29ydGVkQ2hpbGRyZW4gPSB0aGlzLl9zb3J0ZWREcmF3aW5nVHJlZS5saXN0KCk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHNvcnRlZENoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGRyYXcgYWN0b3JzIHRoYXQgYXJlIHZpc2libGUgYW5kIG9uIHNjcmVlblxyXG4gICAgICAgICAgICAgICAgaWYgKHNvcnRlZENoaWxkcmVuW2ldLnZpc2libGUgJiYgIXNvcnRlZENoaWxkcmVuW2ldLmlzT2ZmU2NyZWVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc29ydGVkQ2hpbGRyZW5baV0uZHJhdyhjdHgsIGRlbHRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5lbmdpbmUgJiYgdGhpcy5lbmdpbmUuaXNEZWJ1Zykge1xyXG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ3llbGxvdyc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnRHJhdyhjdHgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHRoaXMudWlBY3RvcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIC8vIG9ubHkgZHJhdyB1aSBhY3RvcnMgdGhhdCBhcmUgdmlzaWJsZSBhbmQgb24gc2NyZWVuXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy51aUFjdG9yc1tpXS52aXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51aUFjdG9yc1tpXS5kcmF3KGN0eCwgZGVsdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVuZ2luZSAmJiB0aGlzLmVuZ2luZS5pc0RlYnVnKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLnVpQWN0b3JzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51aUFjdG9yc1tpXS5kZWJ1Z0RyYXcoY3R4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3Bvc3RkcmF3JywgbmV3IEV2ZW50c18xMy5Qb3N0RHJhd0V2ZW50KGN0eCwgZGVsdGEsIHRoaXMpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERyYXdzIGFsbCB0aGUgYWN0b3JzJyBkZWJ1ZyBpbmZvcm1hdGlvbiBpbiB0aGUgU2NlbmUuIENhbGxlZCBieSB0aGUgW1tFbmdpbmVdXS5cclxuICAgICAgICAgKiBAcGFyYW0gY3R4ICBUaGUgY3VycmVudCByZW5kZXJpbmcgY29udGV4dFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgU2NlbmUucHJvdG90eXBlLmRlYnVnRHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdwcmVkZWJ1Z2RyYXcnLCBuZXcgRXZlbnRzXzEzLlByZURlYnVnRHJhd0V2ZW50KGN0eCwgdGhpcykpO1xyXG4gICAgICAgICAgICB2YXIgaSwgbGVuO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLnRpbGVNYXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRpbGVNYXBzW2ldLmRlYnVnRHJhdyhjdHgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuYWN0b3JzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFjdG9yc1tpXS5kZWJ1Z0RyYXcoY3R4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLnRyaWdnZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJzW2ldLmRlYnVnRHJhdyhjdHgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2Jyb2FkcGhhc2UuZGVidWdEcmF3KGN0eCwgMjApO1xyXG4gICAgICAgICAgICB0aGlzLmNhbWVyYS5kZWJ1Z0RyYXcoY3R4KTtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdwb3N0ZGVidWdkcmF3JywgbmV3IEV2ZW50c18xMy5Qb3N0RGVidWdEcmF3RXZlbnQoY3R4LCB0aGlzKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGVja3Mgd2hldGhlciBhbiBhY3RvciBpcyBjb250YWluZWQgaW4gdGhpcyBzY2VuZSBvciBub3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBTY2VuZS5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAoYWN0b3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0b3JzLmluZGV4T2YoYWN0b3IpID4gLTE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTY2VuZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGVudGl0eSkge1xyXG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgQWN0b3JfMTQuQWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIGVudGl0eS51bmtpbGwoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgVUlBY3Rvcl81LlVJQWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIGlmICghVXRpbC5jb250YWlucyh0aGlzLnVpQWN0b3JzLCBlbnRpdHkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRVSUFjdG9yKGVudGl0eSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIEFjdG9yXzE0LkFjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIVV0aWwuY29udGFpbnModGhpcy5hY3RvcnMsIGVudGl0eSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRDaGlsZChlbnRpdHkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBUaW1lcl8zLlRpbWVyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIVV0aWwuY29udGFpbnModGhpcy5fdGltZXJzLCBlbnRpdHkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRUaW1lcihlbnRpdHkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBUaWxlTWFwXzMuVGlsZU1hcCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFVdGlsLmNvbnRhaW5zKHRoaXMudGlsZU1hcHMsIGVudGl0eSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFRpbGVNYXAoZW50aXR5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgU2NlbmUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChlbnRpdHkpIHtcclxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIFVJQWN0b3JfNS5VSUFjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVVJQWN0b3IoZW50aXR5KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgQWN0b3JfMTQuQWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Jyb2FkcGhhc2UudW50cmFjayhlbnRpdHkuYm9keSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVDaGlsZChlbnRpdHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBUaW1lcl8zLlRpbWVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVRpbWVyKGVudGl0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIFRpbGVNYXBfMy5UaWxlTWFwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVRpbGVNYXAoZW50aXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyAoYW55KSBhY3RvciB0byBhY3QgYXMgYSBwaWVjZSBvZiBVSSwgbWVhbmluZyBpdCBpcyBhbHdheXMgcG9zaXRpb25lZFxyXG4gICAgICAgICAqIGluIHNjcmVlbiBjb29yZGluYXRlcy4gVUkgYWN0b3JzIGRvIG5vdCBwYXJ0aWNpcGF0ZSBpbiBjb2xsaXNpb25zLlxyXG4gICAgICAgICAqIEB0b2RvIFNob3VsZCB0aGlzIGJlIGBVSUFjdG9yYCBvbmx5P1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5hZGRVSUFjdG9yID0gZnVuY3Rpb24gKGFjdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMudWlBY3RvcnMucHVzaChhY3Rvcik7XHJcbiAgICAgICAgICAgIGFjdG9yLnNjZW5lID0gdGhpcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgYW4gYWN0b3IgYXMgYSBwaWVjZSBvZiBVSVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5yZW1vdmVVSUFjdG9yID0gZnVuY3Rpb24gKGFjdG9yKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMudWlBY3RvcnMuaW5kZXhPZihhY3Rvcik7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVpQWN0b3JzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYW4gYWN0b3IgdG8gdGhlIHNjZW5lLCBvbmNlIHRoaXMgaXMgZG9uZSB0aGUgYWN0b3Igd2lsbCBiZSBkcmF3biBhbmQgdXBkYXRlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBTY2VuZS5wcm90b3R5cGUuX2FkZENoaWxkID0gZnVuY3Rpb24gKGFjdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Jyb2FkcGhhc2UudHJhY2soYWN0b3IuYm9keSk7XHJcbiAgICAgICAgICAgIGFjdG9yLnNjZW5lID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKGFjdG9yIGluc3RhbmNlb2YgVHJpZ2dlcl8zLlRyaWdnZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcnMucHVzaChhY3Rvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFjdG9ycy5wdXNoKGFjdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9zb3J0ZWREcmF3aW5nVHJlZS5hZGQoYWN0b3IpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhIFtbVGlsZU1hcF1dIHRvIHRoZSBzY2VuZSwgb25jZSB0aGlzIGlzIGRvbmUgdGhlIFRpbGVNYXAgd2lsbCBiZSBkcmF3biBhbmQgdXBkYXRlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBTY2VuZS5wcm90b3R5cGUuYWRkVGlsZU1hcCA9IGZ1bmN0aW9uICh0aWxlTWFwKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGlsZU1hcHMucHVzaCh0aWxlTWFwKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgYSBbW1RpbGVNYXBdXSBmcm9tIHRoZSBzY2VuZSwgaXQgd2lsbCBubyBsb25nZXIgYmUgZHJhd24gb3IgdXBkYXRlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBTY2VuZS5wcm90b3R5cGUucmVtb3ZlVGlsZU1hcCA9IGZ1bmN0aW9uICh0aWxlTWFwKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMudGlsZU1hcHMuaW5kZXhPZih0aWxlTWFwKTtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGlsZU1hcHMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlcyBhbiBhY3RvciBmcm9tIHRoZSBzY2VuZSwgaXQgd2lsbCBubyBsb25nZXIgYmUgZHJhd24gb3IgdXBkYXRlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBTY2VuZS5wcm90b3R5cGUuX3JlbW92ZUNoaWxkID0gZnVuY3Rpb24gKGFjdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Jyb2FkcGhhc2UudW50cmFjayhhY3Rvci5ib2R5KTtcclxuICAgICAgICAgICAgaWYgKGFjdG9yIGluc3RhbmNlb2YgVHJpZ2dlcl8zLlRyaWdnZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJLaWxsUXVldWUucHVzaChhY3Rvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9raWxsUXVldWUucHVzaChhY3Rvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYWN0b3IucGFyZW50ID0gbnVsbDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYSBbW1RpbWVyXV0gdG8gdGhlIHNjZW5lXHJcbiAgICAgICAgICogQHBhcmFtIHRpbWVyICBUaGUgdGltZXIgdG8gYWRkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2NlbmUucHJvdG90eXBlLmFkZFRpbWVyID0gZnVuY3Rpb24gKHRpbWVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RpbWVycy5wdXNoKHRpbWVyKTtcclxuICAgICAgICAgICAgdGltZXIuc2NlbmUgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gdGltZXI7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGEgW1tUaW1lcl1dIGZyb20gdGhlIHNjZW5lLlxyXG4gICAgICAgICAqIEB3YXJuaW5nIENhbiBiZSBkYW5nZXJvdXMsIHVzZSBbW2NhbmNlbFRpbWVyXV0gaW5zdGVhZFxyXG4gICAgICAgICAqIEBwYXJhbSB0aW1lciAgVGhlIHRpbWVyIHRvIHJlbW92ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5yZW1vdmVUaW1lciA9IGZ1bmN0aW9uICh0aW1lcikge1xyXG4gICAgICAgICAgICB2YXIgaSA9IHRoaXMuX3RpbWVycy5pbmRleE9mKHRpbWVyKTtcclxuICAgICAgICAgICAgaWYgKGkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90aW1lcnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aW1lcjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbmNlbHMgYSBbW1RpbWVyXV0sIHJlbW92aW5nIGl0IGZyb20gdGhlIHNjZW5lIG5pY2VseVxyXG4gICAgICAgICAqIEBwYXJhbSB0aW1lciAgVGhlIHRpbWVyIHRvIGNhbmNlbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5jYW5jZWxUaW1lciA9IGZ1bmN0aW9uICh0aW1lcikge1xyXG4gICAgICAgICAgICB0aGlzLl9jYW5jZWxRdWV1ZS5wdXNoKHRpbWVyKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRpbWVyO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVzdHMgd2hldGhlciBhIFtbVGltZXJdXSBpcyBhY3RpdmUgaW4gdGhlIHNjZW5lXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2NlbmUucHJvdG90eXBlLmlzVGltZXJBY3RpdmUgPSBmdW5jdGlvbiAodGltZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl90aW1lcnMuaW5kZXhPZih0aW1lcikgPiAtMSAmJiAhdGltZXIuY29tcGxldGUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhbmQgYWRkcyBhIFtbR3JvdXBdXSB0byB0aGUgc2NlbmUgd2l0aCBhIG5hbWVcclxuICAgICAgICAgKi9cclxuICAgICAgICBTY2VuZS5wcm90b3R5cGUuY3JlYXRlR3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEdyb3VwXzIuR3JvdXAobmFtZSwgdGhpcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgW1tHcm91cF1dIGJ5IG5hbWVcclxuICAgICAgICAgKi9cclxuICAgICAgICBTY2VuZS5wcm90b3R5cGUuZ2V0R3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ncm91cHNbbmFtZV07XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTY2VuZS5wcm90b3R5cGUucmVtb3ZlR3JvdXAgPSBmdW5jdGlvbiAoZ3JvdXApIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBncm91cCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmdyb3Vwc1tncm91cF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZ3JvdXAgaW5zdGFuY2VvZiBHcm91cF8yLkdyb3VwKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5ncm91cHNbZ3JvdXAubmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzIHRvIHJlbW92ZUdyb3VwJywgZ3JvdXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBhY3RvciBmcm9tIHRoZSBzb3J0ZWQgZHJhd2luZyB0cmVlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2NlbmUucHJvdG90eXBlLmNsZWFudXBEcmF3VHJlZSA9IGZ1bmN0aW9uIChhY3Rvcikge1xyXG4gICAgICAgICAgICB0aGlzLl9zb3J0ZWREcmF3aW5nVHJlZS5yZW1vdmVCeUNvbXBhcmFibGUoYWN0b3IpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXBkYXRlcyB0aGUgZ2l2ZW4gYWN0b3IncyBwb3NpdGlvbiBpbiB0aGUgc29ydGVkIGRyYXdpbmcgdHJlZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS51cGRhdGVEcmF3VHJlZSA9IGZ1bmN0aW9uIChhY3Rvcikge1xyXG4gICAgICAgICAgICB0aGlzLl9zb3J0ZWREcmF3aW5nVHJlZS5hZGQoYWN0b3IpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgU2NlbmUucHJvdG90eXBlLl9jb2xsZWN0QWN0b3JTdGF0cyA9IGZ1bmN0aW9uIChlbmdpbmUpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMudWlBY3RvcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3VpID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgZW5naW5lLnN0YXRzLmN1cnJGcmFtZS5hY3RvcnMudWkrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gdGhpcy5hY3RvcnM7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWN0b3IgPSBfY1tfYl07XHJcbiAgICAgICAgICAgICAgICBlbmdpbmUuc3RhdHMuY3VyckZyYW1lLmFjdG9ycy5hbGl2ZSsrO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSAwLCBfZSA9IGFjdG9yLmNoaWxkcmVuOyBfZCA8IF9lLmxlbmd0aDsgX2QrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IF9lW19kXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoQWN0b3JVdGlscy5pc1VJQWN0b3IoY2hpbGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZ2luZS5zdGF0cy5jdXJyRnJhbWUuYWN0b3JzLnVpKys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmdpbmUuc3RhdHMuY3VyckZyYW1lLmFjdG9ycy5hbGl2ZSsrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFNjZW5lO1xyXG4gICAgfShDbGFzc18xMC5DbGFzcykpO1xyXG4gICAgZXhwb3J0cy5TY2VuZSA9IFNjZW5lO1xyXG59KTtcclxuZGVmaW5lKFwiRXZlbnRzXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEJhc2UgZXZlbnQgdHlwZSBpbiBFeGNhbGlidXIgdGhhdCBhbGwgb3RoZXIgZXZlbnQgdHlwZXMgZGVyaXZlIGZyb20uIE5vdCBhbGwgZXZlbnQgdHlwZXMgYXJlIHRocm93biBvbiBhbGwgRXhjYWxpYnVyIGdhbWUgb2JqZWN0cyxcclxuICAgICAqIHNvbWUgZXZlbnRzIGFyZSB1bmlxdWUgdG8gYSB0eXBlLCBvdGhlcnMgYXJlIG5vdC5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIHZhciBHYW1lRXZlbnQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIEdhbWVFdmVudCgpIHtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEdhbWVFdmVudDtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkdhbWVFdmVudCA9IEdhbWVFdmVudDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlICdraWxsJyBldmVudCBpcyBlbWl0dGVkIG9uIGFjdG9ycyB3aGVuIGl0IGlzIGtpbGxlZC4gVGhlIHRhcmdldCBpcyB0aGUgYWN0b3IgdGhhdCB3YXMga2lsbGVkLlxyXG4gICAgICovXHJcbiAgICB2YXIgS2lsbEV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoS2lsbEV2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIEtpbGxFdmVudCh0YXJnZXQpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBLaWxsRXZlbnQ7XHJcbiAgICB9KEdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5LaWxsRXZlbnQgPSBLaWxsRXZlbnQ7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSAnc3RhcnQnIGV2ZW50IGlzIGVtaXR0ZWQgb24gZW5naW5lIHdoZW4gaGFzIHN0YXJ0ZWQgYW5kIGlzIHJlYWR5IGZvciBpbnRlcmFjdGlvbi5cclxuICAgICAqL1xyXG4gICAgdmFyIEdhbWVTdGFydEV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoR2FtZVN0YXJ0RXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gR2FtZVN0YXJ0RXZlbnQodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gR2FtZVN0YXJ0RXZlbnQ7XHJcbiAgICB9KEdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5HYW1lU3RhcnRFdmVudCA9IEdhbWVTdGFydEV2ZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgJ3N0b3AnIGV2ZW50IGlzIGVtaXR0ZWQgb24gZW5naW5lIHdoZW4gaGFzIGJlZW4gc3RvcHBlZCBhbmQgd2lsbCBubyBsb25nZXIgdGFrZSBpbnB1dCwgdXBkYXRlIG9yIGRyYXcuXHJcbiAgICAgKi9cclxuICAgIHZhciBHYW1lU3RvcEV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoR2FtZVN0b3BFdmVudCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBHYW1lU3RvcEV2ZW50KHRhcmdldCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEdhbWVTdG9wRXZlbnQ7XHJcbiAgICB9KEdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5HYW1lU3RvcEV2ZW50ID0gR2FtZVN0b3BFdmVudDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlICdwcmVkcmF3JyBldmVudCBpcyBlbWl0dGVkIG9uIGFjdG9ycywgc2NlbmVzLCBhbmQgZW5naW5lIGJlZm9yZSBkcmF3aW5nIHN0YXJ0cy4gQWN0b3JzJyBwcmVkcmF3IGhhcHBlbnMgaW5zaWRlIHRoZWlyIGdyYXBoaWNzXHJcbiAgICAgKiB0cmFuc2Zvcm0gc28gdGhhdCBhbGwgZHJhd2luZyB0YWtlcyBwbGFjZSB3aXRoIHRoZSBhY3RvciBhcyB0aGUgb3JpZ2luLlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgdmFyIFByZURyYXdFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFByZURyYXdFdmVudCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBQcmVEcmF3RXZlbnQoY3R4LCBkZWx0YSwgdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLmN0eCA9IGN0eDtcclxuICAgICAgICAgICAgX3RoaXMuZGVsdGEgPSBkZWx0YTtcclxuICAgICAgICAgICAgX3RoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQcmVEcmF3RXZlbnQ7XHJcbiAgICB9KEdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5QcmVEcmF3RXZlbnQgPSBQcmVEcmF3RXZlbnQ7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSAncG9zdGRyYXcnIGV2ZW50IGlzIGVtaXR0ZWQgb24gYWN0b3JzLCBzY2VuZXMsIGFuZCBlbmdpbmUgYWZ0ZXIgZHJhd2luZyBmaW5pc2hlcy4gQWN0b3JzJyBwb3N0ZHJhdyBoYXBwZW5zIGluc2lkZSB0aGVpciBncmFwaGljc1xyXG4gICAgICogdHJhbnNmb3JtIHNvIHRoYXQgYWxsIGRyYXdpbmcgdGFrZXMgcGxhY2Ugd2l0aCB0aGUgYWN0b3IgYXMgdGhlIG9yaWdpbi5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIHZhciBQb3N0RHJhd0V2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoUG9zdERyYXdFdmVudCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBQb3N0RHJhd0V2ZW50KGN0eCwgZGVsdGEsIHRhcmdldCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5jdHggPSBjdHg7XHJcbiAgICAgICAgICAgIF90aGlzLmRlbHRhID0gZGVsdGE7XHJcbiAgICAgICAgICAgIF90aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUG9zdERyYXdFdmVudDtcclxuICAgIH0oR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLlBvc3REcmF3RXZlbnQgPSBQb3N0RHJhd0V2ZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgJ3ByZWRlYnVnZHJhdycgZXZlbnQgaXMgZW1pdHRlZCBvbiBhY3RvcnMsIHNjZW5lcywgYW5kIGVuZ2luZSBiZWZvcmUgZGVidWcgZHJhd2luZyBzdGFydHMuXHJcbiAgICAgKi9cclxuICAgIHZhciBQcmVEZWJ1Z0RyYXdFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFByZURlYnVnRHJhd0V2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFByZURlYnVnRHJhd0V2ZW50KGN0eCwgdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLmN0eCA9IGN0eDtcclxuICAgICAgICAgICAgX3RoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQcmVEZWJ1Z0RyYXdFdmVudDtcclxuICAgIH0oR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLlByZURlYnVnRHJhd0V2ZW50ID0gUHJlRGVidWdEcmF3RXZlbnQ7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSAncG9zdGRlYnVnZHJhdycgZXZlbnQgaXMgZW1pdHRlZCBvbiBhY3RvcnMsIHNjZW5lcywgYW5kIGVuZ2luZSBhZnRlciBkZWJ1ZyBkcmF3aW5nIHN0YXJ0cy5cclxuICAgICAqL1xyXG4gICAgdmFyIFBvc3REZWJ1Z0RyYXdFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFBvc3REZWJ1Z0RyYXdFdmVudCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBQb3N0RGVidWdEcmF3RXZlbnQoY3R4LCB0YXJnZXQpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuY3R4ID0gY3R4O1xyXG4gICAgICAgICAgICBfdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFBvc3REZWJ1Z0RyYXdFdmVudDtcclxuICAgIH0oR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLlBvc3REZWJ1Z0RyYXdFdmVudCA9IFBvc3REZWJ1Z0RyYXdFdmVudDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlICdwcmV1cGRhdGUnIGV2ZW50IGlzIGVtaXR0ZWQgb24gYWN0b3JzLCBzY2VuZXMsIGFuZCBlbmdpbmUgYmVmb3JlIHRoZSB1cGRhdGUgc3RhcnRzLlxyXG4gICAgICovXHJcbiAgICB2YXIgUHJlVXBkYXRlRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhQcmVVcGRhdGVFdmVudCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBQcmVVcGRhdGVFdmVudChlbmdpbmUsIGRlbHRhLCB0YXJnZXQpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuZW5naW5lID0gZW5naW5lO1xyXG4gICAgICAgICAgICBfdGhpcy5kZWx0YSA9IGRlbHRhO1xyXG4gICAgICAgICAgICBfdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFByZVVwZGF0ZUV2ZW50O1xyXG4gICAgfShHYW1lRXZlbnQpKTtcclxuICAgIGV4cG9ydHMuUHJlVXBkYXRlRXZlbnQgPSBQcmVVcGRhdGVFdmVudDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlICdwb3N0dXBkYXRlJyBldmVudCBpcyBlbWl0dGVkIG9uIGFjdG9ycywgc2NlbmVzLCBhbmQgZW5naW5lIGFmdGVyIHRoZSB1cGRhdGUgZW5kcy5cclxuICAgICAqL1xyXG4gICAgdmFyIFBvc3RVcGRhdGVFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFBvc3RVcGRhdGVFdmVudCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBQb3N0VXBkYXRlRXZlbnQoZW5naW5lLCBkZWx0YSwgdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLmVuZ2luZSA9IGVuZ2luZTtcclxuICAgICAgICAgICAgX3RoaXMuZGVsdGEgPSBkZWx0YTtcclxuICAgICAgICAgICAgX3RoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQb3N0VXBkYXRlRXZlbnQ7XHJcbiAgICB9KEdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5Qb3N0VXBkYXRlRXZlbnQgPSBQb3N0VXBkYXRlRXZlbnQ7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSAncHJlZnJhbWUnIGV2ZW50IGlzIGVtaXR0ZWQgb24gdGhlIGVuZ2luZSwgYmVmb3JlIHRoZSBmcmFtZSBiZWdpbnMuXHJcbiAgICAgKi9cclxuICAgIHZhciBQcmVGcmFtZUV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoUHJlRnJhbWVFdmVudCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBQcmVGcmFtZUV2ZW50KGVuZ2luZSwgcHJldlN0YXRzKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLmVuZ2luZSA9IGVuZ2luZTtcclxuICAgICAgICAgICAgX3RoaXMucHJldlN0YXRzID0gcHJldlN0YXRzO1xyXG4gICAgICAgICAgICBfdGhpcy50YXJnZXQgPSBlbmdpbmU7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFByZUZyYW1lRXZlbnQ7XHJcbiAgICB9KEdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5QcmVGcmFtZUV2ZW50ID0gUHJlRnJhbWVFdmVudDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlICdwb3N0ZnJhbWUnIGV2ZW50IGlzIGVtaXR0ZWQgb24gdGhlIGVuZ2luZSwgYWZ0ZXIgYSBmcmFtZSBlbmRzLlxyXG4gICAgICovXHJcbiAgICB2YXIgUG9zdEZyYW1lRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhQb3N0RnJhbWVFdmVudCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBQb3N0RnJhbWVFdmVudChlbmdpbmUsIHN0YXRzKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLmVuZ2luZSA9IGVuZ2luZTtcclxuICAgICAgICAgICAgX3RoaXMuc3RhdHMgPSBzdGF0cztcclxuICAgICAgICAgICAgX3RoaXMudGFyZ2V0ID0gZW5naW5lO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQb3N0RnJhbWVFdmVudDtcclxuICAgIH0oR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLlBvc3RGcmFtZUV2ZW50ID0gUG9zdEZyYW1lRXZlbnQ7XHJcbiAgICAvKipcclxuICAgICAqIEV2ZW50IHJlY2VpdmVkIHdoZW4gYSBnYW1lcGFkIGlzIGNvbm5lY3RlZCB0byBFeGNhbGlidXIuIFtbR2FtZXBhZHNdXSByZWNlaXZlcyB0aGlzIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICB2YXIgR2FtZXBhZENvbm5lY3RFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKEdhbWVwYWRDb25uZWN0RXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gR2FtZXBhZENvbm5lY3RFdmVudChpbmRleCwgZ2FtZXBhZCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5pbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICBfdGhpcy5nYW1lcGFkID0gZ2FtZXBhZDtcclxuICAgICAgICAgICAgX3RoaXMudGFyZ2V0ID0gZ2FtZXBhZDtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gR2FtZXBhZENvbm5lY3RFdmVudDtcclxuICAgIH0oR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLkdhbWVwYWRDb25uZWN0RXZlbnQgPSBHYW1lcGFkQ29ubmVjdEV2ZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBFdmVudCByZWNlaXZlZCB3aGVuIGEgZ2FtZXBhZCBpcyBkaXNjb25uZWN0ZWQgZnJvbSBFeGNhbGlidXIuIFtbR2FtZXBhZHNdXSByZWNlaXZlcyB0aGlzIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICB2YXIgR2FtZXBhZERpc2Nvbm5lY3RFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKEdhbWVwYWREaXNjb25uZWN0RXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gR2FtZXBhZERpc2Nvbm5lY3RFdmVudChpbmRleCwgZ2FtZXBhZCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5pbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICBfdGhpcy5nYW1lcGFkID0gZ2FtZXBhZDtcclxuICAgICAgICAgICAgX3RoaXMudGFyZ2V0ID0gZ2FtZXBhZDtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gR2FtZXBhZERpc2Nvbm5lY3RFdmVudDtcclxuICAgIH0oR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLkdhbWVwYWREaXNjb25uZWN0RXZlbnQgPSBHYW1lcGFkRGlzY29ubmVjdEV2ZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHYW1lcGFkIGJ1dHRvbiBldmVudC4gU2VlIFtbR2FtZXBhZHNdXSBmb3IgaW5mb3JtYXRpb24gb24gcmVzcG9uZGluZyB0byBjb250cm9sbGVyIGlucHV0LiBbW0dhbWVwYWRdXSBpbnN0YW5jZXMgcmVjZWl2ZSB0aGlzIGV2ZW50O1xyXG4gICAgICovXHJcbiAgICB2YXIgR2FtZXBhZEJ1dHRvbkV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoR2FtZXBhZEJ1dHRvbkV2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBidXR0b24gIFRoZSBHYW1lcGFkIGJ1dHRvblxyXG4gICAgICAgICAqIEBwYXJhbSB2YWx1ZSAgIEEgbnVtZXJpYyB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDFcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBHYW1lcGFkQnV0dG9uRXZlbnQoYnV0dG9uLCB2YWx1ZSwgdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLmJ1dHRvbiA9IGJ1dHRvbjtcclxuICAgICAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgX3RoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBHYW1lcGFkQnV0dG9uRXZlbnQ7XHJcbiAgICB9KEdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5HYW1lcGFkQnV0dG9uRXZlbnQgPSBHYW1lcGFkQnV0dG9uRXZlbnQ7XHJcbiAgICAvKipcclxuICAgICAqIEdhbWVwYWQgYXhpcyBldmVudC4gU2VlIFtbR2FtZXBhZHNdXSBmb3IgaW5mb3JtYXRpb24gb24gcmVzcG9uZGluZyB0byBjb250cm9sbGVyIGlucHV0LiBbW0dhbWVwYWRdXSBpbnN0YW5jZXMgcmVjZWl2ZSB0aGlzIGV2ZW50O1xyXG4gICAgICovXHJcbiAgICB2YXIgR2FtZXBhZEF4aXNFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKEdhbWVwYWRBeGlzRXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIGF4aXMgIFRoZSBHYW1lcGFkIGF4aXNcclxuICAgICAgICAgKiBAcGFyYW0gdmFsdWUgQSBudW1lcmljIHZhbHVlIGJldHdlZW4gLTEgYW5kIDFcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBHYW1lcGFkQXhpc0V2ZW50KGF4aXMsIHZhbHVlLCB0YXJnZXQpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuYXhpcyA9IGF4aXM7XHJcbiAgICAgICAgICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIF90aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gR2FtZXBhZEF4aXNFdmVudDtcclxuICAgIH0oR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLkdhbWVwYWRBeGlzRXZlbnQgPSBHYW1lcGFkQXhpc0V2ZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJzY3JpYmUgZXZlbnQgdGhyb3duIHdoZW4gaGFuZGxlcnMgZm9yIGV2ZW50cyBvdGhlciB0aGFuIHN1YnNjcmliZSBhcmUgYWRkZWQuIE1ldGEgZXZlbnQgdGhhdCBpcyByZWNlaXZlZCBieVxyXG4gICAgICogW1tFdmVudERpc3BhdGNoZXJ8ZXZlbnQgZGlzcGF0Y2hlcnNdXS5cclxuICAgICAqL1xyXG4gICAgdmFyIFN1YnNjcmliZUV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoU3Vic2NyaWJlRXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gU3Vic2NyaWJlRXZlbnQodG9waWMsIGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMudG9waWMgPSB0b3BpYztcclxuICAgICAgICAgICAgX3RoaXMuaGFuZGxlciA9IGhhbmRsZXI7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFN1YnNjcmliZUV2ZW50O1xyXG4gICAgfShHYW1lRXZlbnQpKTtcclxuICAgIGV4cG9ydHMuU3Vic2NyaWJlRXZlbnQgPSBTdWJzY3JpYmVFdmVudDtcclxuICAgIC8qKlxyXG4gICAgICogVW5zdWJzY3JpYmUgZXZlbnQgdGhyb3duIHdoZW4gaGFuZGxlcnMgZm9yIGV2ZW50cyBvdGhlciB0aGFuIHVuc3Vic2NyaWJlIGFyZSByZW1vdmVkLiBNZXRhIGV2ZW50IHRoYXQgaXMgcmVjZWl2ZWQgYnlcclxuICAgICAqIFtbRXZlbnREaXNwYXRjaGVyfGV2ZW50IGRpc3BhdGNoZXJzXV0uXHJcbiAgICAgKi9cclxuICAgIHZhciBVbnN1YnNjcmliZUV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoVW5zdWJzY3JpYmVFdmVudCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBVbnN1YnNjcmliZUV2ZW50KHRvcGljLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLnRvcGljID0gdG9waWM7XHJcbiAgICAgICAgICAgIF90aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBVbnN1YnNjcmliZUV2ZW50O1xyXG4gICAgfShHYW1lRXZlbnQpKTtcclxuICAgIGV4cG9ydHMuVW5zdWJzY3JpYmVFdmVudCA9IFVuc3Vic2NyaWJlRXZlbnQ7XHJcbiAgICAvKipcclxuICAgICAqIEV2ZW50IHJlY2VpdmVkIGJ5IHRoZSBbW0VuZ2luZV1dIHdoZW4gdGhlIGJyb3dzZXIgd2luZG93IGlzIHZpc2libGUgb24gYSBzY3JlZW4uXHJcbiAgICAgKi9cclxuICAgIHZhciBWaXNpYmxlRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhWaXNpYmxlRXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gVmlzaWJsZUV2ZW50KHRhcmdldCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFZpc2libGVFdmVudDtcclxuICAgIH0oR2FtZUV2ZW50KSk7XHJcbiAgICBleHBvcnRzLlZpc2libGVFdmVudCA9IFZpc2libGVFdmVudDtcclxuICAgIC8qKlxyXG4gICAgICogRXZlbnQgcmVjZWl2ZWQgYnkgdGhlIFtbRW5naW5lXV0gd2hlbiB0aGUgYnJvd3NlciB3aW5kb3cgaXMgaGlkZGVuIGZyb20gYWxsIHNjcmVlbnMuXHJcbiAgICAgKi9cclxuICAgIHZhciBIaWRkZW5FdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKEhpZGRlbkV2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIEhpZGRlbkV2ZW50KHRhcmdldCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEhpZGRlbkV2ZW50O1xyXG4gICAgfShHYW1lRXZlbnQpKTtcclxuICAgIGV4cG9ydHMuSGlkZGVuRXZlbnQgPSBIaWRkZW5FdmVudDtcclxuICAgIC8qKlxyXG4gICAgICogRXZlbnQgdGhyb3duIG9uIGFuIFtbQWN0b3J8YWN0b3JdXSB3aGVuIGEgY29sbGlzaW9uIHdpbGwgb2NjdXIgdGhpcyBmcmFtZSBpZiBpdCByZXNvbHZlc1xyXG4gICAgICovXHJcbiAgICB2YXIgUHJlQ29sbGlzaW9uRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhQcmVDb2xsaXNpb25FdmVudCwgX3N1cGVyKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gYWN0b3IgICAgICAgICBUaGUgYWN0b3IgdGhlIGV2ZW50IHdhcyB0aHJvd24gb25cclxuICAgICAgICAgKiBAcGFyYW0gb3RoZXIgICAgICAgICBUaGUgYWN0b3IgdGhhdCB3aWxsIGNvbGxpZGVkIHdpdGggdGhlIGN1cnJlbnQgYWN0b3JcclxuICAgICAgICAgKiBAcGFyYW0gc2lkZSAgICAgICAgICBUaGUgc2lkZSB0aGF0IHdpbGwgYmUgY29sbGlkZWQgd2l0aCB0aGUgY3VycmVudCBhY3RvclxyXG4gICAgICAgICAqIEBwYXJhbSBpbnRlcnNlY3Rpb24gIEludGVyc2VjdGlvbiB2ZWN0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBQcmVDb2xsaXNpb25FdmVudChhY3Rvciwgb3RoZXIsIHNpZGUsIGludGVyc2VjdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5hY3RvciA9IGFjdG9yO1xyXG4gICAgICAgICAgICBfdGhpcy5vdGhlciA9IG90aGVyO1xyXG4gICAgICAgICAgICBfdGhpcy5zaWRlID0gc2lkZTtcclxuICAgICAgICAgICAgX3RoaXMuaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uO1xyXG4gICAgICAgICAgICBfdGhpcy50YXJnZXQgPSBhY3RvcjtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUHJlQ29sbGlzaW9uRXZlbnQ7XHJcbiAgICB9KEdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5QcmVDb2xsaXNpb25FdmVudCA9IFByZUNvbGxpc2lvbkV2ZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBFdmVudCB0aHJvd24gb24gYW4gW1tBY3RvcnxhY3Rvcl1dIHdoZW4gYSBjb2xsaXNpb24gaGFzIGJlZW4gcmVzb2x2ZWQgKGJvZHkgcmVhY3RlZCkgdGhpcyBmcmFtZVxyXG4gICAgICovXHJcbiAgICB2YXIgUG9zdENvbGxpc2lvbkV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoUG9zdENvbGxpc2lvbkV2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBhY3RvciAgICAgICAgIFRoZSBhY3RvciB0aGUgZXZlbnQgd2FzIHRocm93biBvblxyXG4gICAgICAgICAqIEBwYXJhbSBvdGhlciAgICAgICAgIFRoZSBhY3RvciB0aGF0IGRpZCBjb2xsaWRlIHdpdGggdGhlIGN1cnJlbnQgYWN0b3JcclxuICAgICAgICAgKiBAcGFyYW0gc2lkZSAgICAgICAgICBUaGUgc2lkZSB0aGF0IGRpZCBjb2xsaWRlIHdpdGggdGhlIGN1cnJlbnQgYWN0b3JcclxuICAgICAgICAgKiBAcGFyYW0gaW50ZXJzZWN0aW9uICBJbnRlcnNlY3Rpb24gdmVjdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gUG9zdENvbGxpc2lvbkV2ZW50KGFjdG9yLCBvdGhlciwgc2lkZSwgaW50ZXJzZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLmFjdG9yID0gYWN0b3I7XHJcbiAgICAgICAgICAgIF90aGlzLm90aGVyID0gb3RoZXI7XHJcbiAgICAgICAgICAgIF90aGlzLnNpZGUgPSBzaWRlO1xyXG4gICAgICAgICAgICBfdGhpcy5pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb247XHJcbiAgICAgICAgICAgIF90aGlzLnRhcmdldCA9IGFjdG9yO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQb3N0Q29sbGlzaW9uRXZlbnQ7XHJcbiAgICB9KEdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5Qb3N0Q29sbGlzaW9uRXZlbnQgPSBQb3N0Q29sbGlzaW9uRXZlbnQ7XHJcbiAgICAvKipcclxuICAgICAqIEV2ZW50IHRocm93biB0aGUgZmlyc3QgdGltZSBhbiBbW0FjdG9yfGFjdG9yXV0gY29sbGlkZXMgd2l0aCBhbm90aGVyLCBhZnRlciBhbiBhY3RvciBpcyBpbiBjb250YWN0IG5vcm1hbCBjb2xsaXNpb24gZXZlbnRzIGFyZSBmaXJlZC5cclxuICAgICAqL1xyXG4gICAgdmFyIENvbGxpc2lvblN0YXJ0RXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhDb2xsaXNpb25TdGFydEV2ZW50LCBfc3VwZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gQ29sbGlzaW9uU3RhcnRFdmVudChhY3Rvciwgb3RoZXIsIHBhaXIpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuYWN0b3IgPSBhY3RvcjtcclxuICAgICAgICAgICAgX3RoaXMub3RoZXIgPSBvdGhlcjtcclxuICAgICAgICAgICAgX3RoaXMucGFpciA9IHBhaXI7XHJcbiAgICAgICAgICAgIF90aGlzLnRhcmdldCA9IGFjdG9yO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBDb2xsaXNpb25TdGFydEV2ZW50O1xyXG4gICAgfShHYW1lRXZlbnQpKTtcclxuICAgIGV4cG9ydHMuQ29sbGlzaW9uU3RhcnRFdmVudCA9IENvbGxpc2lvblN0YXJ0RXZlbnQ7XHJcbiAgICAvKipcclxuICAgICAqIEV2ZW50IHRocm93biB3aGVuIHRoZSBbW0FjdG9yfGFjdG9yXV0gaXMgbm8gbG9uZ2VyIGNvbGxpZGluZyB3aXRoIGFub3RoZXJcclxuICAgICAqL1xyXG4gICAgdmFyIENvbGxpc2lvbkVuZEV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoQ29sbGlzaW9uRW5kRXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBDb2xsaXNpb25FbmRFdmVudChhY3Rvciwgb3RoZXIpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuYWN0b3IgPSBhY3RvcjtcclxuICAgICAgICAgICAgX3RoaXMub3RoZXIgPSBvdGhlcjtcclxuICAgICAgICAgICAgX3RoaXMudGFyZ2V0ID0gYWN0b3I7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIENvbGxpc2lvbkVuZEV2ZW50O1xyXG4gICAgfShHYW1lRXZlbnQpKTtcclxuICAgIGV4cG9ydHMuQ29sbGlzaW9uRW5kRXZlbnQgPSBDb2xsaXNpb25FbmRFdmVudDtcclxuICAgIC8qKlxyXG4gICAgICogRXZlbnQgdGhyb3duIG9uIGFuIFtbQWN0b3JdXSBhbmQgYSBbW1NjZW5lXV0gb25seSBvbmNlIGJlZm9yZSB0aGUgZmlyc3QgdXBkYXRlIGNhbGxcclxuICAgICAqL1xyXG4gICAgdmFyIEluaXRpYWxpemVFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKEluaXRpYWxpemVFdmVudCwgX3N1cGVyKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gZW5naW5lICBUaGUgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGVuZ2luZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIEluaXRpYWxpemVFdmVudChlbmdpbmUsIHRhcmdldCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5lbmdpbmUgPSBlbmdpbmU7XHJcbiAgICAgICAgICAgIF90aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gSW5pdGlhbGl6ZUV2ZW50O1xyXG4gICAgfShHYW1lRXZlbnQpKTtcclxuICAgIGV4cG9ydHMuSW5pdGlhbGl6ZUV2ZW50ID0gSW5pdGlhbGl6ZUV2ZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBFdmVudCB0aHJvd24gb24gYSBbW1NjZW5lXV0gb24gYWN0aXZhdGlvblxyXG4gICAgICovXHJcbiAgICB2YXIgQWN0aXZhdGVFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKEFjdGl2YXRlRXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIG9sZFNjZW5lICBUaGUgcmVmZXJlbmNlIHRvIHRoZSBvbGQgc2NlbmVcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBBY3RpdmF0ZUV2ZW50KG9sZFNjZW5lLCB0YXJnZXQpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMub2xkU2NlbmUgPSBvbGRTY2VuZTtcclxuICAgICAgICAgICAgX3RoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBBY3RpdmF0ZUV2ZW50O1xyXG4gICAgfShHYW1lRXZlbnQpKTtcclxuICAgIGV4cG9ydHMuQWN0aXZhdGVFdmVudCA9IEFjdGl2YXRlRXZlbnQ7XHJcbiAgICAvKipcclxuICAgICAqIEV2ZW50IHRocm93biBvbiBhIFtbU2NlbmVdXSBvbiBkZWFjdGl2YXRpb25cclxuICAgICAqL1xyXG4gICAgdmFyIERlYWN0aXZhdGVFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKERlYWN0aXZhdGVFdmVudCwgX3N1cGVyKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gbmV3U2NlbmUgIFRoZSByZWZlcmVuY2UgdG8gdGhlIG5ldyBzY2VuZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIERlYWN0aXZhdGVFdmVudChuZXdTY2VuZSwgdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLm5ld1NjZW5lID0gbmV3U2NlbmU7XHJcbiAgICAgICAgICAgIF90aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gRGVhY3RpdmF0ZUV2ZW50O1xyXG4gICAgfShHYW1lRXZlbnQpKTtcclxuICAgIGV4cG9ydHMuRGVhY3RpdmF0ZUV2ZW50ID0gRGVhY3RpdmF0ZUV2ZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBFdmVudCB0aHJvd24gb24gYW4gW1tBY3Rvcl1dIHdoZW4gaXQgY29tcGxldGVseSBsZWF2ZXMgdGhlIHNjcmVlbi5cclxuICAgICAqL1xyXG4gICAgdmFyIEV4aXRWaWV3UG9ydEV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoRXhpdFZpZXdQb3J0RXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gRXhpdFZpZXdQb3J0RXZlbnQodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gRXhpdFZpZXdQb3J0RXZlbnQ7XHJcbiAgICB9KEdhbWVFdmVudCkpO1xyXG4gICAgZXhwb3J0cy5FeGl0Vmlld1BvcnRFdmVudCA9IEV4aXRWaWV3UG9ydEV2ZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBFdmVudCB0aHJvd24gb24gYW4gW1tBY3Rvcl1dIHdoZW4gaXQgY29tcGxldGVseSBsZWF2ZXMgdGhlIHNjcmVlbi5cclxuICAgICAqL1xyXG4gICAgdmFyIEVudGVyVmlld1BvcnRFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKEVudGVyVmlld1BvcnRFdmVudCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBFbnRlclZpZXdQb3J0RXZlbnQodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gRW50ZXJWaWV3UG9ydEV2ZW50O1xyXG4gICAgfShHYW1lRXZlbnQpKTtcclxuICAgIGV4cG9ydHMuRW50ZXJWaWV3UG9ydEV2ZW50ID0gRW50ZXJWaWV3UG9ydEV2ZW50O1xyXG4gICAgdmFyIEVudGVyVHJpZ2dlckV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoRW50ZXJUcmlnZ2VyRXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gRW50ZXJUcmlnZ2VyRXZlbnQodGFyZ2V0LCBhY3Rvcikge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIF90aGlzLmFjdG9yID0gYWN0b3I7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEVudGVyVHJpZ2dlckV2ZW50O1xyXG4gICAgfShHYW1lRXZlbnQpKTtcclxuICAgIGV4cG9ydHMuRW50ZXJUcmlnZ2VyRXZlbnQgPSBFbnRlclRyaWdnZXJFdmVudDtcclxuICAgIHZhciBFeGl0VHJpZ2dlckV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoRXhpdFRyaWdnZXJFdmVudCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBFeGl0VHJpZ2dlckV2ZW50KHRhcmdldCwgYWN0b3IpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICBfdGhpcy5hY3RvciA9IGFjdG9yO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBFeGl0VHJpZ2dlckV2ZW50O1xyXG4gICAgfShHYW1lRXZlbnQpKTtcclxuICAgIGV4cG9ydHMuRXhpdFRyaWdnZXJFdmVudCA9IEV4aXRUcmlnZ2VyRXZlbnQ7XHJcbn0pO1xyXG5kZWZpbmUoXCJDbGFzc1wiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkV2ZW50RGlzcGF0Y2hlclwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIEV2ZW50RGlzcGF0Y2hlcl8zKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogRXhjYWxpYnVyIGJhc2UgY2xhc3MgdGhhdCBwcm92aWRlcyBiYXNpYyBmdW5jdGlvbmFsaXR5IHN1Y2ggYXMgW1tFdmVudERpc3BhdGNoZXJdXVxyXG4gICAgICogYW5kIGV4dGVuZGluZyBhYmlsaXRpZXMgZm9yIHZhbmlsbGEgSmF2YXNjcmlwdCBwcm9qZWN0c1xyXG4gICAgICovXHJcbiAgICB2YXIgQ2xhc3MgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIENsYXNzKCkge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlciA9IG5ldyBFdmVudERpc3BhdGNoZXJfMy5FdmVudERpc3BhdGNoZXIodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFsaWFzIGZvciBgYWRkRXZlbnRMaXN0ZW5lcmAuIFlvdSBjYW4gbGlzdGVuIGZvciBhIHZhcmlldHkgb2ZcclxuICAgICAgICAgKiBldmVudHMgb2ZmIG9mIHRoZSBlbmdpbmU7IHNlZSB0aGUgZXZlbnRzIHNlY3Rpb24gYmVsb3cgZm9yIGEgY29tcGxldGUgbGlzdC5cclxuICAgICAgICAgKiBAcGFyYW0gZXZlbnROYW1lICBOYW1lIG9mIHRoZSBldmVudCB0byBsaXN0ZW4gZm9yXHJcbiAgICAgICAgICogQHBhcmFtIGhhbmRsZXIgICAgRXZlbnQgaGFuZGxlciBmb3IgdGhlIHRocm93biBldmVudFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENsYXNzLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIub24oZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFsaWFzIGZvciBgcmVtb3ZlRXZlbnRMaXN0ZW5lcmAuIElmIG9ubHkgdGhlIGV2ZW50TmFtZSBpcyBzcGVjaWZpZWRcclxuICAgICAgICAgKiBpdCB3aWxsIHJlbW92ZSBhbGwgaGFuZGxlcnMgcmVnaXN0ZXJlZCBmb3IgdGhhdCBzcGVjaWZpYyBldmVudC4gSWYgdGhlIGV2ZW50TmFtZVxyXG4gICAgICAgICAqIGFuZCB0aGUgaGFuZGxlciBpbnN0YW5jZSBhcmUgc3BlY2lmaWVkIG9ubHkgdGhhdCBoYW5kbGVyIHdpbGwgYmUgcmVtb3ZlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBldmVudE5hbWUgIE5hbWUgb2YgdGhlIGV2ZW50IHRvIGxpc3RlbiBmb3JcclxuICAgICAgICAgKiBAcGFyYW0gaGFuZGxlciAgICBFdmVudCBoYW5kbGVyIGZvciB0aGUgdGhyb3duIGV2ZW50XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2xhc3MucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIub2ZmKGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbWl0cyBhIG5ldyBldmVudFxyXG4gICAgICAgICAqIEBwYXJhbSBldmVudE5hbWUgICBOYW1lIG9mIHRoZSBldmVudCB0byBlbWl0XHJcbiAgICAgICAgICogQHBhcmFtIGV2ZW50T2JqZWN0IERhdGEgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZXZlbnRcclxuICAgICAgICAgKi9cclxuICAgICAgICBDbGFzcy5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50T2JqZWN0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLmVtaXQoZXZlbnROYW1lLCBldmVudE9iamVjdCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBPbmNlIGxpc3RlbnMgdG8gYW4gZXZlbnQgb25lIHRpbWUsIHRoZW4gdW5zdWJzY3JpYmVzIGZyb20gdGhhdCBldmVudFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGV2ZW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gc3Vic2NyaWJlIHRvIG9uY2VcclxuICAgICAgICAgKiBAcGFyYW0gaGFuZGxlciAgIFRoZSBoYW5kbGVyIG9mIHRoZSBldmVudCB0aGF0IHdpbGwgYmUgYXV0byB1bnN1YnNjcmliZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBDbGFzcy5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIub25jZShldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogWW91IG1heSB3aXNoIHRvIGV4dGVuZCBuYXRpdmUgRXhjYWxpYnVyIGZ1bmN0aW9uYWxpdHkgaW4gdmFuaWxsYSBKYXZhc2NyaXB0LlxyXG4gICAgICAgICAqIEFueSBtZXRob2Qgb24gYSBjbGFzcyBpbmhlcml0aW5nIFtbQ2xhc3NdXSBtYXkgYmUgZXh0ZW5kZWQgdG8gc3VwcG9ydFxyXG4gICAgICAgICAqIGFkZGl0aW9uYWwgZnVuY3Rpb25hbGl0eS4gSW4gdGhlIGV4YW1wbGUgYmVsb3cgd2UgY3JlYXRlIGEgbmV3IHR5cGUgY2FsbGVkIGBNeUFjdG9yYC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogYGBganNcclxuICAgICAgICAgKiB2YXIgTXlBY3RvciA9IEFjdG9yLmV4dGVuZCh7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICogICAgICAgdGhpcy5uZXdwcm9wID0gJ3NvbWV0aGluZyc7XHJcbiAgICAgICAgICogICAgICAgQWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgKiAgICB9LFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgdXBkYXRlOiBmdW5jdGlvbihlbmdpbmUsIGRlbHRhKSB7XHJcbiAgICAgICAgICogICAgICAgLy8gSW1wbGVtZW50IGN1c3RvbSB1cGRhdGVcclxuICAgICAgICAgKiAgICAgICAvLyBDYWxsIHN1cGVyIGNvbnN0cnVjdG9yIHVwZGF0ZVxyXG4gICAgICAgICAqICAgICAgIEFjdG9yLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzLCBlbmdpbmUsIGRlbHRhKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAgIGNvbnNvbGUubG9nKFwiU29tZXRoaW5nIGNvb2whXCIpO1xyXG4gICAgICAgICAqICAgIH1cclxuICAgICAgICAgKiB9KTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIHZhciBteUFjdG9yID0gbmV3IE15QWN0b3IoMTAwLCAxMDAsIDEwMCwgMTAwLCBDb2xvci5BenVyZSk7XHJcbiAgICAgICAgICogYGBgXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBJbiBUeXBlU2NyaXB0LCB5b3Ugb25seSBuZWVkIHRvIHVzZSB0aGUgYGV4dGVuZHNgIHN5bnRheCwgeW91IGRvIG5vdCBuZWVkXHJcbiAgICAgICAgICogdG8gdXNlIHRoaXMgbWV0aG9kIG9mIGV4dGVuc2lvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBtZXRob2RzIEEgSlNPTiBvYmplY3QgY29udGFpbiBhbnkgbWV0aG9kcy9wcm9wZXJ0aWVzIHlvdSB3YW50IHRvIGV4dGVuZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENsYXNzLmV4dGVuZCA9IGZ1bmN0aW9uIChtZXRob2RzKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgY2hpbGQ7XHJcbiAgICAgICAgICAgIGlmIChtZXRob2RzICYmIG1ldGhvZHMuaGFzT3duUHJvcGVydHkoJ2NvbnN0cnVjdG9yJykpIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkID0gbWV0aG9kcy5jb25zdHJ1Y3RvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcGFyZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVXNpbmcgY29uc3RydWN0b3IgYWxsb3dzIEpTIHRvIGxhemlseSBpbnN0YW50aWF0ZSBzdXBlciBjbGFzc2VzXHJcbiAgICAgICAgICAgIHZhciBTdXBlciA9IGZ1bmN0aW9uICgpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9O1xyXG4gICAgICAgICAgICBTdXBlci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlO1xyXG4gICAgICAgICAgICBjaGlsZC5wcm90b3R5cGUgPSBuZXcgU3VwZXI7XHJcbiAgICAgICAgICAgIGlmIChtZXRob2RzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIG1ldGhvZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5wcm90b3R5cGVbcHJvcF0gPSBtZXRob2RzW3Byb3BdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBNYWtlIHN1YmNsYXNzZXMgZXh0ZW5kYWJsZVxyXG4gICAgICAgICAgICBjaGlsZC5leHRlbmQgPSBDbGFzcy5leHRlbmQ7XHJcbiAgICAgICAgICAgIHJldHVybiBjaGlsZDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBDbGFzcztcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkNsYXNzID0gQ2xhc3M7XHJcbn0pO1xyXG5kZWZpbmUoXCJBY3RvclwiLCBbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIlBoeXNpY3NcIiwgXCJDbGFzc1wiLCBcIkNvbGxpc2lvbi9Cb3VuZGluZ0JveFwiLCBcIlJlc291cmNlcy9UZXh0dXJlXCIsIFwiRXZlbnRzXCIsIFwiRHJhd2luZy9Db2xvclwiLCBcIkRyYXdpbmcvU3ByaXRlXCIsIFwiVXRpbC9Mb2dcIiwgXCJBY3Rpb25zL0FjdGlvbkNvbnRleHRcIiwgXCJBY3Rpb25zL0FjdGlvblwiLCBcIkFsZ2VicmFcIiwgXCJDb2xsaXNpb24vQm9keVwiLCBcIkNvbGxpc2lvbi9TaWRlXCIsIFwiQ29uZmlndXJhYmxlXCIsIFwiVHJhaXRzL0luZGV4XCIsIFwiRHJhd2luZy9TcHJpdGVFZmZlY3RzXCIsIFwiVXRpbC9VdGlsXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgUGh5c2ljc18xMywgQ2xhc3NfMTEsIEJvdW5kaW5nQm94XzgsIFRleHR1cmVfNCwgRXZlbnRzXzE0LCBDb2xvcl8yMCwgU3ByaXRlXzQsIExvZ18xNiwgQWN0aW9uQ29udGV4dF8zLCBBY3Rpb25fMiwgQWxnZWJyYV8yNCwgQm9keV8yLCBTaWRlXzQsIENvbmZpZ3VyYWJsZV84LCBUcmFpdHMsIEVmZmVjdHMsIFV0aWwpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaGlkZGVuXHJcbiAgICAgKi9cclxuICAgIHZhciBBY3RvckltcGwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhBY3RvckltcGwsIF9zdXBlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHggICAgICAgVGhlIHN0YXJ0aW5nIHggY29vcmRpbmF0ZSBvZiB0aGUgYWN0b3JcclxuICAgICAgICAgKiBAcGFyYW0geSAgICAgICBUaGUgc3RhcnRpbmcgeSBjb29yZGluYXRlIG9mIHRoZSBhY3RvclxyXG4gICAgICAgICAqIEBwYXJhbSB3aWR0aCAgIFRoZSBzdGFydGluZyB3aWR0aCBvZiB0aGUgYWN0b3JcclxuICAgICAgICAgKiBAcGFyYW0gaGVpZ2h0ICBUaGUgc3RhcnRpbmcgaGVpZ2h0IG9mIHRoZSBhY3RvclxyXG4gICAgICAgICAqIEBwYXJhbSBjb2xvciAgIFRoZSBzdGFydGluZyBjb2xvciBvZiB0aGUgYWN0b3IuIExlYXZlIG51bGwgdG8gZHJhdyBhIHRyYW5zcGFyZW50IGFjdG9yLiBUaGUgb3BhY2l0eSBvZiB0aGUgY29sb3Igd2lsbCBiZSB1c2VkIGFzIHRoZVxyXG4gICAgICAgICAqIGluaXRpYWwgW1tvcGFjaXR5XV0uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gQWN0b3JJbXBsKHhPckNvbmZpZywgeSwgd2lkdGgsIGhlaWdodCwgY29sb3IpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGFjdG9yXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5pZCA9IEFjdG9ySW1wbC5tYXhJZCsrO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIHBoeXNpY3MgYm9keSB0aGUgaXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgYWN0b3IuIFRoZSBib2R5IGlzIHRoZSBjb250YWluZXIgZm9yIGFsbCBwaHlzaWNhbCBwcm9wZXJ0aWVzLCBsaWtlIHBvc2l0aW9uLCB2ZWxvY2l0eSxcclxuICAgICAgICAgICAgICogYWNjZWxlcmF0aW9uLCBtYXNzLCBpbmVydGlhLCBldGMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5ib2R5ID0gbmV3IEJvZHlfMi5Cb2R5KF90aGlzKTtcclxuICAgICAgICAgICAgX3RoaXMuX2hlaWdodCA9IDA7XHJcbiAgICAgICAgICAgIF90aGlzLl93aWR0aCA9IDA7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgc2NhbGUgdmVjdG9yIG9mIHRoZSBhY3RvclxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuc2NhbGUgPSBuZXcgQWxnZWJyYV8yNC5WZWN0b3IoMSwgMSk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgeCBzY2FsYXIgdmVsb2NpdHkgb2YgdGhlIGFjdG9yIGluIHNjYWxlL3NlY29uZFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuc3ggPSAwOyAvL3NjYWxlL3NlY1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIHkgc2NhbGFyIHZlbG9jaXR5IG9mIHRoZSBhY3RvciBpbiBzY2FsZS9zZWNvbmRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLnN5ID0gMDsgLy9zY2FsZS9zZWNcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBhY3RvciBpcyBwaHlzaWNhbGx5IGluIHRoZSB2aWV3cG9ydFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuaXNPZmZTY3JlZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSB2aXNpYmlsaXR5IG9mIGFuIGFjdG9yXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBvcGFjaXR5IG9mIGFuIGFjdG9yLiBQYXNzaW5nIGluIGEgY29sb3IgaW4gdGhlIFtbY29uc3RydWN0b3JdXSB3aWxsIHVzZSB0aGVcclxuICAgICAgICAgICAgICogY29sb3IncyBvcGFjaXR5LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMub3BhY2l0eSA9IDE7XHJcbiAgICAgICAgICAgIF90aGlzLnByZXZpb3VzT3BhY2l0eSA9IDE7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDb252ZW5pZW5jZSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBsb2dnZXJcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmxvZ2dlciA9IExvZ18xNi5Mb2dnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBzY2VuZSB0aGF0IHRoZSBhY3RvciBpcyBpblxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuc2NlbmUgPSBudWxsO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIHBhcmVudCBvZiB0aGlzIGFjdG9yXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5wYXJlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBSZXBsYWNlIHRoaXMgd2l0aCB0aGUgbmV3IGFjdG9yIGNvbGxlY3Rpb24gb25jZSB6LWluZGV4aW5nIGlzIGJ1aWx0XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgY2hpbGRyZW4gb2YgdGhpcyBhY3RvclxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3RoaXMuY2hpbGRyZW4gPSBbXTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgY3VycmVudCBjb2xsaXNpb24gdHlwZSBvZiB0aGlzIGFjdG9yLiBCeVxyXG4gICAgICAgICAgICAgKiBkZWZhdWx0IGl0IGlzIChbW0NvbGxpc2lvblR5cGUuUHJldmVudENvbGxpc2lvbl1dKS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmNvbGxpc2lvblR5cGUgPSBDb2xsaXNpb25UeXBlLlByZXZlbnRDb2xsaXNpb247XHJcbiAgICAgICAgICAgIF90aGlzLmNvbGxpc2lvbkdyb3VwcyA9IFtdO1xyXG4gICAgICAgICAgICBfdGhpcy5fY29sbGlzaW9uSGFuZGxlcnMgPSB7fTtcclxuICAgICAgICAgICAgX3RoaXMuX2lzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgX3RoaXMuZnJhbWVzID0ge307XHJcbiAgICAgICAgICAgIF90aGlzLl9lZmZlY3RzRGlydHkgPSBmYWxzZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFjY2VzcyB0byB0aGUgY3VycmVudCBkcmF3aW5nIGZvciB0aGUgYWN0b3IsIHRoaXMgY2FuIGJlXHJcbiAgICAgICAgICAgICAqIGFuIFtbQW5pbWF0aW9uXV0sIFtbU3ByaXRlXV0sIG9yIFtbUG9seWdvbl1dLlxyXG4gICAgICAgICAgICAgKiBTZXQgZHJhd2luZ3Mgd2l0aCBbW3NldERyYXdpbmddXS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF90aGlzLmN1cnJlbnREcmF3aW5nID0gbnVsbDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE1vZGlmeSB0aGUgY3VycmVudCBhY3RvciB1cGRhdGUgcGlwZWxpbmUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy50cmFpdHMgPSBbXTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRvIGVuYWJsZSB0aGUgW1tDYXB0dXJlUG9pbnRlcl1dIHRyYWl0IHRoYXQgcHJvcGFnYXRlc1xyXG4gICAgICAgICAgICAgKiBwb2ludGVyIGV2ZW50cyB0byB0aGlzIGFjdG9yXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5lbmFibGVDYXB0dXJlUG9pbnRlciA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ29uZmlndXJhdGlvbiBmb3IgW1tDYXB0dXJlUG9pbnRlcl1dIHRyYWl0XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfdGhpcy5jYXB0dXJlUG9pbnRlciA9IHtcclxuICAgICAgICAgICAgICAgIGNhcHR1cmVNb3ZlRXZlbnRzOiBmYWxzZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBfdGhpcy5fekluZGV4ID0gMDtcclxuICAgICAgICAgICAgX3RoaXMuX2lzS2lsbGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIF90aGlzLl9vcGFjaXR5RnggPSBuZXcgRWZmZWN0cy5PcGFjaXR5KF90aGlzLm9wYWNpdHkpO1xyXG4gICAgICAgICAgICBpZiAoeE9yQ29uZmlnICYmIHR5cGVvZiB4T3JDb25maWcgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29uZmlnID0geE9yQ29uZmlnO1xyXG4gICAgICAgICAgICAgICAgeE9yQ29uZmlnID0gY29uZmlnLnBvcyA/IGNvbmZpZy5wb3MueCA6IGNvbmZpZy54O1xyXG4gICAgICAgICAgICAgICAgeSA9IGNvbmZpZy5wb3MgPyBjb25maWcucG9zLnkgOiBjb25maWcueTtcclxuICAgICAgICAgICAgICAgIHdpZHRoID0gY29uZmlnLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gY29uZmlnLmhlaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy5wb3MueCA9IHhPckNvbmZpZyB8fCAwO1xyXG4gICAgICAgICAgICBfdGhpcy5wb3MueSA9IHkgfHwgMDtcclxuICAgICAgICAgICAgX3RoaXMuX3dpZHRoID0gd2lkdGggfHwgMDtcclxuICAgICAgICAgICAgX3RoaXMuX2hlaWdodCA9IGhlaWdodCB8fCAwO1xyXG4gICAgICAgICAgICBpZiAoY29sb3IpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmNvbG9yID0gY29sb3I7XHJcbiAgICAgICAgICAgICAgICAvLyBzZXQgZGVmYXVsdCBvcGFjaXR5IG9mIGFuIGFjdG9yIHRvIHRoZSBjb2xvclxyXG4gICAgICAgICAgICAgICAgX3RoaXMub3BhY2l0eSA9IGNvbG9yLmE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQnVpbGQgZGVmYXVsdCBwaXBlbGluZVxyXG4gICAgICAgICAgICAvL3RoaXMudHJhaXRzLnB1c2gobmV3IGV4LlRyYWl0cy5FdWxlck1vdmVtZW50KCkpO1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBUaWxlTWFwcyBzaG91bGQgYmUgY29udmVydGVkIHRvIGEgY29sbGlzaW9uIGFyZWFcclxuICAgICAgICAgICAgX3RoaXMudHJhaXRzLnB1c2gobmV3IFRyYWl0cy5UaWxlTWFwQ29sbGlzaW9uRGV0ZWN0aW9uKCkpO1xyXG4gICAgICAgICAgICBfdGhpcy50cmFpdHMucHVzaChuZXcgVHJhaXRzLk9mZnNjcmVlbkN1bGxpbmcoKSk7XHJcbiAgICAgICAgICAgIF90aGlzLnRyYWl0cy5wdXNoKG5ldyBUcmFpdHMuQ2FwdHVyZVBvaW50ZXIoKSk7XHJcbiAgICAgICAgICAgIC8vIEJ1aWxkIHRoZSBhY3Rpb24gcXVldWVcclxuICAgICAgICAgICAgX3RoaXMuYWN0aW9uUXVldWUgPSBuZXcgQWN0aW9uXzIuQWN0aW9uUXVldWUoX3RoaXMpO1xyXG4gICAgICAgICAgICBfdGhpcy5hY3Rpb25zID0gbmV3IEFjdGlvbkNvbnRleHRfMy5BY3Rpb25Db250ZXh0KF90aGlzKTtcclxuICAgICAgICAgICAgLy8gZGVmYXVsdCBhbmNob3IgaXMgaW4gdGhlIG1pZGRsZVxyXG4gICAgICAgICAgICBfdGhpcy5hbmNob3IgPSBuZXcgQWxnZWJyYV8yNC5WZWN0b3IoLjUsIC41KTtcclxuICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSBkZWZhdWx0IGNvbGxpc2lvbiBhcmVhIHRvIGJlIGJveFxyXG4gICAgICAgICAgICBfdGhpcy5ib2R5LnVzZUJveENvbGxpc2lvbigpO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3RvckltcGwucHJvdG90eXBlLCBcImNvbGxpc2lvbkFyZWFcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgY29sbGlzaW9uIGFyZWEgc2hhcGUgdG8gdXNlIGZvciBjb2xsaXNpb24gcG9zc2libGUgb3B0aW9ucyBhcmUgW0NpcmNsZUFyZWF8Y2lyY2xlc10sIFtQb2x5Z29uQXJlYXxwb2x5Z29uc10sIGFuZFxyXG4gICAgICAgICAgICAgKiBbRWRnZUFyZWF8ZWRnZXNdLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5LmNvbGxpc2lvbkFyZWE7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBjb2xsaXNpb24gYXJlYSBzaGFwZSB0byB1c2UgZm9yIGNvbGxpc2lvbiBwb3NzaWJsZSBvcHRpb25zIGFyZSBbQ2lyY2xlQXJlYXxjaXJjbGVzXSwgW1BvbHlnb25BcmVhfHBvbHlnb25zXSwgYW5kXHJcbiAgICAgICAgICAgICAqIFtFZGdlQXJlYXxlZGdlc10uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChhcmVhKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvZHkuY29sbGlzaW9uQXJlYSA9IGFyZWE7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3RvckltcGwucHJvdG90eXBlLCBcInhcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgeCBwb3NpdGlvbiBvZiB0aGUgYWN0b3IgcmVsYXRpdmUgdG8gaXQncyBwYXJlbnQgKGlmIGFueSlcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5wb3MueDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHMgdGhlIHggcG9zaXRpb24gb2YgdGhlIGFjdG9yIHJlbGF0aXZlIHRvIGl0J3MgcGFyZW50IChpZiBhbnkpXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0aGVYKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvZHkucG9zLnggPSB0aGVYO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0b3JJbXBsLnByb3RvdHlwZSwgXCJ5XCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIHkgcG9zaXRpb24gb2YgdGhlIGFjdG9yIHJlbGF0aXZlIHRvIGl0J3MgcGFyZW50IChpZiBhbnkpXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJvZHkucG9zLnk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXRzIHRoZSB5IHBvc2l0aW9uIG9mIHRoZSBhY3RvciByZWxhdGl2ZSB0byBpdCdzIHBhcmVudCAoaWYgYW55KVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodGhlWSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5LnBvcy55ID0gdGhlWTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdG9ySW1wbC5wcm90b3R5cGUsIFwicG9zXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIHBvc2l0aW9uIHZlY3RvciBvZiB0aGUgYWN0b3IgaW4gcGl4ZWxzXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJvZHkucG9zO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0cyB0aGUgcG9zaXRpb24gdmVjdG9yIG9mIHRoZSBhY3RvciBpbiBwaXhlbHNcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHRoZVBvcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5LnBvcy5zZXRUbyh0aGVQb3MueCwgdGhlUG9zLnkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0b3JJbXBsLnByb3RvdHlwZSwgXCJvbGRQb3NcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgcG9zaXRpb24gdmVjdG9yIG9mIHRoZSBhY3RvciBmcm9tIHRoZSBsYXN0IGZyYW1lXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJvZHkub2xkUG9zO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0cyB0aGUgcG9zaXRpb24gdmVjdG9yIG9mIHRoZSBhY3RvciBpbiB0aGUgbGFzdCBmcmFtZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodGhlUG9zKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvZHkub2xkUG9zLnNldFRvKHRoZVBvcy54LCB0aGVQb3MueSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3RvckltcGwucHJvdG90eXBlLCBcInZlbFwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSB2ZWxvY2l0eSB2ZWN0b3Igb2YgdGhlIGFjdG9yIGluIHBpeGVscy9zZWNcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm9keS52ZWw7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXRzIHRoZSB2ZWxvY2l0eSB2ZWN0b3Igb2YgdGhlIGFjdG9yIGluIHBpeGVscy9zZWNcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHRoZVZlbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5LnZlbC5zZXRUbyh0aGVWZWwueCwgdGhlVmVsLnkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0b3JJbXBsLnByb3RvdHlwZSwgXCJvbGRWZWxcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgdmVsb2NpdHkgdmVjdG9yIG9mIHRoZSBhY3RvciBmcm9tIHRoZSBsYXN0IGZyYW1lXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJvZHkub2xkVmVsO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0cyB0aGUgdmVsb2NpdHkgdmVjdG9yIG9mIHRoZSBhY3RvciBmcm9tIHRoZSBsYXN0IGZyYW1lXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0aGVWZWwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYm9keS5vbGRWZWwuc2V0VG8odGhlVmVsLngsIHRoZVZlbC55KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdG9ySW1wbC5wcm90b3R5cGUsIFwiYWNjXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIGFjY2VsZXJhdGlvbiB2ZWN0b3Igb2YgdGhlIGFjdG9yIGluIHBpeGVscy9zZWNvbmQvc2Vjb25kLiBBbiBhY2NlbGVyYXRpb24gcG9pbnRpbmcgZG93biBzdWNoIGFzICgwLCAxMDApIG1heSBiZVxyXG4gICAgICAgICAgICAgKiB1c2VmdWwgdG8gc2ltdWxhdGUgYSBncmF2aXRhdGlvbmFsIGVmZmVjdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5hY2M7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXRzIHRoZSBhY2NlbGVyYXRpb24gdmVjdG9yIG9mIHRlaCBhY3RvciBpbiBwaXhlbHMvc2Vjb25kL3NlY29uZFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodGhlQWNjKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvZHkuYWNjLnNldFRvKHRoZUFjYy54LCB0aGVBY2MueSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3RvckltcGwucHJvdG90eXBlLCBcInJvdGF0aW9uXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIHJvdGF0aW9uIG9mIHRoZSBhY3RvciBpbiByYWRpYW5zLiAxIHJhZGlhbiA9IDE4MC9QSSBEZWdyZWVzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5LnJvdGF0aW9uO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0cyB0aGUgcm90YXRpb24gb2YgdGhlIGFjdG9yIGluIHJhZGlhbnMuIDEgcmFkaWFuID0gMTgwL1BJIERlZ3JlZXMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0aGVBbmdsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5LnJvdGF0aW9uID0gdGhlQW5nbGU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3RvckltcGwucHJvdG90eXBlLCBcInJ4XCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIHJvdGF0aW9uYWwgdmVsb2NpdHkgb2YgdGhlIGFjdG9yIGluIHJhZGlhbnMvc2Vjb25kXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJvZHkucng7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXRzIHRoZSByb3RhdGlvbmFsIHZlbG9jaXR5IG9mIHRoZSBhY3RvciBpbiByYWRpYW5zL3NlY1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoYW5ndWxhclZlbG9jaXR5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvZHkucnggPSBhbmd1bGFyVmVsb2NpdHk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3RvckltcGwucHJvdG90eXBlLCBcInRvcnF1ZVwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHRvcnF1ZSBhcHBsaWVkIHRvIHRoZSBhY3Rvci4gVG9ycXVlIGNhbiBiZSB0aG91Z2h0IG9mIGFzIHJvdGF0aW9uYWwgZm9yY2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm9keS50b3JxdWU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXRzIHRoZSBjdXJyZW50IHRvcnF1ZSBhcHBsaWVkIHRvIHRoZSBhY3Rvci4gVG9ycXVlIGNhbiBiZSB0aG91Z2h0IG9mIGFzIHJvdGF0aW9uYWwgZm9yY2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHRoZVRvcnF1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5LnRvcnF1ZSA9IHRoZVRvcnF1ZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdG9ySW1wbC5wcm90b3R5cGUsIFwibWFzc1wiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXQgdGhlIGN1cnJlbnQgbWFzcyBvZiB0aGUgYWN0b3IsIG1hc3MgY2FuIGJlIHRob3VnaHQgb2YgYXMgdGhlIHJlc2lzdGFuY2UgdG8gYWNjZWxlcmF0aW9uLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5Lm1hc3M7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXRzIHRoZSBtYXNzIG9mIHRoZSBhY3RvciwgbWFzcyBjYW4gYmUgdGhvdWdodCBvZiBhcyB0aGUgcmVzaXN0YW5jZSB0byBhY2NlbGVyYXRpb24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0aGVNYXNzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvZHkubWFzcyA9IHRoZU1hc3M7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3RvckltcGwucHJvdG90eXBlLCBcIm1vaVwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBjdXJyZW50IG1vbWVudCBvZiBpbmVydGlhLCBtb2kgY2FuIGJlIHRob3VnaHQgb2YgYXMgdGhlIHJlc2lzdGFuY2UgdG8gcm90YXRpb24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJvZHkubW9pO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0cyB0aGUgY3VycmVudCBtb21lbnQgb2YgaW5lcnRpYSwgbW9pIGNhbiBiZSB0aG91Z2h0IG9mIGFzIHRoZSByZXNpc3RhbmNlIHRvIHJvdGF0aW9uLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodGhlTW9pKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvZHkubW9pID0gdGhlTW9pO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0b3JJbXBsLnByb3RvdHlwZSwgXCJmcmljdGlvblwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBjb2VmZmljaWVudCBvZiBmcmljdGlvbiBvbiB0aGlzIGFjdG9yLCB0aGlzIGNhbiBiZSB0aG91Z2h0IG9mIGFzIGhvdyBzdGlja3kgb3Igc2xpcHBlcnkgYW4gb2JqZWN0IGlzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5LmZyaWN0aW9uO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0cyB0aGUgY29lZmZpY2llbnQgb2YgZnJpY3Rpb24gb2YgdGhpcyBhY3RvciwgdGhpcyBjYW4gdmUgdGhvdWdodCBvZiBhcyBob3cgc3RpY2sgb3Igc2xpcHBlcnkgYW4gb2JqZWN0IGlzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodGhlRnJpY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYm9keS5mcmljdGlvbiA9IHRoZUZyaWN0aW9uO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0b3JJbXBsLnByb3RvdHlwZSwgXCJyZXN0aXR1dGlvblwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBjb2VmZmljaWVudCBvZiByZXN0aXR1dGlvbiBvZiB0aGlzIGFjdG9yLCByZXByZXNlbnRzIHRoZSBhbW91bnQgb2YgZW5lcmd5IHByZXNlcnZlZCBhZnRlciBjb2xsaXNpb24uIFRoaW5rIG9mIHRoaXNcclxuICAgICAgICAgICAgICogYXMgYm91bmNpbmVzcy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5yZXN0aXR1dGlvbjtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHMgdGhlIGNvZWZmaWNpZW50IG9mIHJlc3RpdHV0aW9uIG9mIHRoaXMgYWN0b3IsIHJlcHJlc2VudHMgdGhlIGFtb3VudCBvZiBlbmVyZ3kgcHJlc2VydmVkIGFmdGVyIGNvbGxpc2lvbi4gVGhpbmsgb2YgdGhpc1xyXG4gICAgICAgICAgICAgKiBhcyBib3VuY2luZXNzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodGhlUmVzdGl0dXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYm9keS5yZXN0aXR1dGlvbiA9IHRoZVJlc3RpdHV0aW9uO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0b3JJbXBsLnByb3RvdHlwZSwgXCJjb2xvclwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXRzIHRoZSBjb2xvciBvZiB0aGUgYWN0b3IuIEEgcmVjdGFuZ2xlIG9mIHRoaXMgY29sb3Igd2lsbCBiZVxyXG4gICAgICAgICAgICAgKiBkcmF3biBpZiBubyBbW0lEcmF3YWJsZV1dIGlzIHNwZWNpZmllZCBhcyB0aGUgYWN0b3JzIGRyYXdpbmcuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIFRoZSBkZWZhdWx0IGlzIGBudWxsYCB3aGljaCBwcmV2ZW50cyBhIHJlY3RhbmdsZSBmcm9tIGJlaW5nIGRyYXduLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sb3I7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbG9yID0gdi5jbG9uZSgpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIGlzIGNhbGxlZCBiZWZvcmUgdGhlIGZpcnN0IHVwZGF0ZSBvZiB0aGUgYWN0b3IuIFRoaXMgbWV0aG9kIGlzIG1lYW50IHRvIGJlXHJcbiAgICAgICAgICogb3ZlcnJpZGRlbi4gVGhpcyBpcyB3aGVyZSBpbml0aWFsaXphdGlvbiBvZiBjaGlsZCBhY3RvcnMgc2hvdWxkIHRha2UgcGxhY2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS5vbkluaXRpYWxpemUgPSBmdW5jdGlvbiAoX2VuZ2luZSkge1xyXG4gICAgICAgICAgICAvLyBPdmVycmlkZSBtZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdG9ySW1wbC5wcm90b3R5cGUsIFwiaXNJbml0aWFsaXplZFwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHdldGhlciB0aGUgYWN0b3IgaXMgSW5pdGlhbGl6ZWRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzSW5pdGlhbGl6ZWQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluaXRpYWxpemVzIHRoaXMgYWN0b3IgYW5kIGFsbCBpdCdzIGNoaWxkIGFjdG9ycywgbWVhbnQgdG8gYmUgY2FsbGVkIGJ5IHRoZSBTY2VuZSBiZWZvcmUgZmlyc3QgdXBkYXRlIG5vdCBieSB1c2VycyBvZiBFeGNhbGlidXIuXHJcbiAgICAgICAgICogQGludGVybmFsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS5faW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChlbmdpbmUpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzSW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub25Jbml0aWFsaXplKGVuZ2luZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5lbWl0KCdpbml0aWFsaXplJywgbmV3IEV2ZW50c18xNC5Jbml0aWFsaXplRXZlbnQoZW5naW5lLCB0aGlzKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5jaGlsZHJlbjsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgIGNoaWxkLl9pbml0aWFsaXplKGVuZ2luZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUuX2NoZWNrRm9yUG9pbnRlck9wdEluID0gZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsaXplZCA9IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWQgPT09ICdwb2ludGVydXAnIHx8IG5vcm1hbGl6ZWQgPT09ICdwb2ludGVyZG93bicgfHwgbm9ybWFsaXplZCA9PT0gJ3BvaW50ZXJtb3ZlJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlQ2FwdHVyZVBvaW50ZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChub3JtYWxpemVkID09PSAncG9pbnRlcm1vdmUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FwdHVyZVBvaW50ZXIuY2FwdHVyZU1vdmVFdmVudHMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2hlY2tGb3JQb2ludGVyT3B0SW4oZXZlbnROYW1lKTtcclxuICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIub24oZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2hlY2tGb3JQb2ludGVyT3B0SW4oZXZlbnROYW1lKTtcclxuICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIub25jZShldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgdGhlIGN1cnJlbnQgYWN0b3IgaXMgYSBtZW1iZXIgb2YgdGhlIHNjZW5lLCB0aGlzIHdpbGwgcmVtb3ZlXHJcbiAgICAgICAgICogaXQgZnJvbSB0aGUgc2NlbmUgZ3JhcGguIEl0IHdpbGwgbm8gbG9uZ2VyIGJlIGRyYXduIG9yIHVwZGF0ZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS5raWxsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zY2VuZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdraWxsJywgbmV3IEV2ZW50c18xNC5LaWxsRXZlbnQodGhpcykpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZS5yZW1vdmUodGhpcyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0tpbGxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdDYW5ub3Qga2lsbCBhY3RvciwgaXQgd2FzIG5ldmVyIGFkZGVkIHRvIHRoZSBTY2VuZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiB0aGUgY3VycmVudCBhY3RvciBpcyBraWxsZWQsIGl0IHdpbGwgbm93IG5vdCBiZSBraWxsZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS51bmtpbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzS2lsbGVkID0gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2V0aGVyIHRoZSBhY3RvciBoYXMgYmVlbiBraWxsZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS5pc0tpbGxlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzS2lsbGVkO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhIGNoaWxkIGFjdG9yIHRvIHRoaXMgYWN0b3IuIEFsbCBtb3ZlbWVudCBvZiB0aGUgY2hpbGQgYWN0b3Igd2lsbCBiZVxyXG4gICAgICAgICAqIHJlbGF0aXZlIHRvIHRoZSBwYXJlbnQgYWN0b3IuIE1lYW5pbmcgaWYgdGhlIHBhcmVudCBtb3ZlcyB0aGUgY2hpbGQgd2lsbFxyXG4gICAgICAgICAqIG1vdmUgd2l0aCBpdC5cclxuICAgICAgICAgKiBAcGFyYW0gYWN0b3IgVGhlIGNoaWxkIGFjdG9yIHRvIGFkZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGFjdG9yKSB7XHJcbiAgICAgICAgICAgIGFjdG9yLmNvbGxpc2lvblR5cGUgPSBDb2xsaXNpb25UeXBlLlByZXZlbnRDb2xsaXNpb247XHJcbiAgICAgICAgICAgIGlmIChVdGlsLmFkZEl0ZW1Ub0FycmF5KGFjdG9yLCB0aGlzLmNoaWxkcmVuKSkge1xyXG4gICAgICAgICAgICAgICAgYWN0b3IucGFyZW50ID0gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlcyBhIGNoaWxkIGFjdG9yIGZyb20gdGhpcyBhY3Rvci5cclxuICAgICAgICAgKiBAcGFyYW0gYWN0b3IgVGhlIGNoaWxkIGFjdG9yIHRvIHJlbW92ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGFjdG9yKSB7XHJcbiAgICAgICAgICAgIGlmIChVdGlsLnJlbW92ZUl0ZW1Gcm9tQXJyYXkoYWN0b3IsIHRoaXMuY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgICAgICBhY3Rvci5wYXJlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLnNldERyYXdpbmcgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIGtleSA9IGtleS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50RHJhd2luZyAhPT0gdGhpcy5mcmFtZXNba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZnJhbWVzW2tleV0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzW2tleV0ucmVzZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnREcmF3aW5nID0gdGhpcy5mcmFtZXNba2V5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIExvZ18xNi5Mb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcigndGhlIHNwZWNpZmllZCBkcmF3aW5nIGtleSBcXCcnICsga2V5ICsgJ1xcJyBkb2VzIG5vdCBleGlzdCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLmFkZERyYXdpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lc1thcmd1bWVudHNbMF1dID0gYXJndW1lbnRzWzFdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnREcmF3aW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50RHJhd2luZyA9IGFyZ3VtZW50c1sxXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX2VmZmVjdHNEaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgU3ByaXRlXzQuU3ByaXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGREcmF3aW5nKCdkZWZhdWx0JywgYXJndW1lbnRzWzBdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBUZXh0dXJlXzQuVGV4dHVyZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRHJhd2luZygnZGVmYXVsdCcsIGFyZ3VtZW50c1swXS5hc1Nwcml0ZSgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdG9ySW1wbC5wcm90b3R5cGUsIFwielwiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0WkluZGV4KCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKG5ld1opIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0WkluZGV4KG5ld1opO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSB6LWluZGV4IG9mIGFuIGFjdG9yLiBUaGUgei1pbmRleCBkZXRlcm1pbmVzIHRoZSByZWxhdGl2ZSBvcmRlciBhbiBhY3RvciBpcyBkcmF3biBpbi5cclxuICAgICAgICAgKiBBY3RvcnMgd2l0aCBhIGhpZ2hlciB6LWluZGV4IGFyZSBkcmF3biBvbiB0b3Agb2YgYWN0b3JzIHdpdGggYSBsb3dlciB6LWluZGV4XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS5nZXRaSW5kZXggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl96SW5kZXg7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSB6LWluZGV4IG9mIGFuIGFjdG9yIGFuZCB1cGRhdGVzIGl0IGluIHRoZSBkcmF3aW5nIGxpc3QgZm9yIHRoZSBzY2VuZS5cclxuICAgICAgICAgKiBUaGUgei1pbmRleCBkZXRlcm1pbmVzIHRoZSByZWxhdGl2ZSBvcmRlciBhbiBhY3RvciBpcyBkcmF3biBpbi5cclxuICAgICAgICAgKiBBY3RvcnMgd2l0aCBhIGhpZ2hlciB6LWluZGV4IGFyZSBkcmF3biBvbiB0b3Agb2YgYWN0b3JzIHdpdGggYSBsb3dlciB6LWluZGV4XHJcbiAgICAgICAgICogQHBhcmFtIG5ld0luZGV4IG5ldyB6LWluZGV4IHRvIGFzc2lnblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUuc2V0WkluZGV4ID0gZnVuY3Rpb24gKG5ld0luZGV4KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2NlbmUuY2xlYW51cERyYXdUcmVlKHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLl96SW5kZXggPSBuZXdJbmRleDtcclxuICAgICAgICAgICAgdGhpcy5zY2VuZS51cGRhdGVEcmF3VHJlZSh0aGlzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYW4gYWN0b3IgdG8gYSBjb2xsaXNpb24gZ3JvdXAuIEFjdG9ycyB3aXRoIG5vIG5hbWVkIGNvbGxpc2lvbiBncm91cHMgYXJlXHJcbiAgICAgICAgICogY29uc2lkZXJlZCB0byBiZSBpbiBldmVyeSBjb2xsaXNpb24gZ3JvdXAuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBPbmNlIGluIGEgY29sbGlzaW9uIGdyb3VwKHMpIGFjdG9ycyB3aWxsIG9ubHkgY29sbGlkZSB3aXRoIG90aGVyIGFjdG9ycyBpblxyXG4gICAgICAgICAqIHRoYXQgZ3JvdXAuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgY29sbGlzaW9uIGdyb3VwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS5hZGRDb2xsaXNpb25Hcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uR3JvdXBzLnB1c2gobmFtZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGFuIGFjdG9yIGZyb20gYSBjb2xsaXNpb24gZ3JvdXAuXHJcbiAgICAgICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGNvbGxpc2lvbiBncm91cFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUucmVtb3ZlQ29sbGlzaW9uR3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmNvbGxpc2lvbkdyb3Vwcy5pbmRleE9mKG5hbWUpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbGxpc2lvbkdyb3Vwcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgdGhlIGNlbnRlciBwb2ludCBvZiBhbiBhY3RvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUuZ2V0Q2VudGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFsZ2VicmFfMjQuVmVjdG9yKHRoaXMucG9zLnggKyB0aGlzLmdldFdpZHRoKCkgLyAyIC0gdGhpcy5hbmNob3IueCAqIHRoaXMuZ2V0V2lkdGgoKSwgdGhpcy5wb3MueSArIHRoaXMuZ2V0SGVpZ2h0KCkgLyAyIC0gdGhpcy5hbmNob3IueSAqIHRoaXMuZ2V0SGVpZ2h0KCkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgY2FsY3VsYXRlZCB3aWR0aCBvZiBhbiBhY3RvciwgZmFjdG9yaW5nIGluIHNjYWxlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoICogdGhpcy5nZXRHbG9iYWxTY2FsZSgpLng7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSB3aWR0aCBvZiBhbiBhY3RvciwgZmFjdG9yaW5nIGluIHRoZSBjdXJyZW50IHNjYWxlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS5zZXRXaWR0aCA9IGZ1bmN0aW9uICh3aWR0aCkge1xyXG4gICAgICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoIC8gdGhpcy5zY2FsZS54O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgY2FsY3VsYXRlZCBoZWlnaHQgb2YgYW4gYWN0b3IsIGZhY3RvcmluZyBpbiBzY2FsZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faGVpZ2h0ICogdGhpcy5nZXRHbG9iYWxTY2FsZSgpLnk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBoZWlnaHQgb2YgYW4gYWN0b3IsIGZhY3RvcmluZyBpbiB0aGUgY3VycmVudCBzY2FsZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUuc2V0SGVpZ2h0ID0gZnVuY3Rpb24gKGhlaWdodCkge1xyXG4gICAgICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQgLyB0aGlzLnNjYWxlLnk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIGFjdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS5nZXRMZWZ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRCb3VuZHMoKS5sZWZ0O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgcmlnaHQgZWRnZSBvZiB0aGUgYWN0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLmdldFJpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRCb3VuZHMoKS5yaWdodDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIHRvcCBlZGdlIG9mIHRoZSBhY3RvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUuZ2V0VG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRCb3VuZHMoKS50b3A7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBib3R0b20gZWRnZSBvZiB0aGUgYWN0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLmdldEJvdHRvbSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Qm91bmRzKCkuYm90dG9tO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGlzIGFjdG9yJ3Mgcm90YXRpb24gdGFraW5nIGludG8gYWNjb3VudCBhbnkgcGFyZW50IHJlbGF0aW9uc2hpcHNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIFJvdGF0aW9uIGFuZ2xlIGluIHJhZGlhbnNcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLmdldFdvcmxkUm90YXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJvdGF0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvdGF0aW9uICsgdGhpcy5wYXJlbnQuZ2V0V29ybGRSb3RhdGlvbigpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBhbiBhY3RvcidzIHdvcmxkIHBvc2l0aW9uIHRha2luZyBpbnRvIGFjY291bnQgcGFyZW50IHJlbGF0aW9uc2hpcHMsIHNjYWxpbmcsIHJvdGF0aW9uLCBhbmQgdHJhbnNsYXRpb25cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIFBvc2l0aW9uIGluIHdvcmxkIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS5nZXRXb3JsZFBvcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zLmNsb25lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gY29sbGVjdCBwYXJlbnRzICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBwYXJlbnRzID0gW107XHJcbiAgICAgICAgICAgIHZhciByb290ID0gdGhpcztcclxuICAgICAgICAgICAgcGFyZW50cy5wdXNoKHRoaXMpO1xyXG4gICAgICAgICAgICAvLyBmaW5kIHBhcmVudHNcclxuICAgICAgICAgICAgd2hpbGUgKHJvb3QucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICByb290ID0gcm9vdC5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRzLnB1c2gocm9vdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHBvc2l0aW9uICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgeCA9IHBhcmVudHMucmVkdWNlUmlnaHQoZnVuY3Rpb24gKHB4LCBwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocC5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHggKyAocC5wb3MueCAqIHAuZ2V0R2xvYmFsU2NhbGUoKS54KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBweCArIHAucG9zLng7XHJcbiAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgICAgICB2YXIgeSA9IHBhcmVudHMucmVkdWNlUmlnaHQoZnVuY3Rpb24gKHB5LCBwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocC5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHkgKyAocC5wb3MueSAqIHAuZ2V0R2xvYmFsU2NhbGUoKS55KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBweSArIHAucG9zLnk7XHJcbiAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgICAgICAvLyByb3RhdGUgYXJvdW5kIHJvb3QgYW5jaG9yXHJcbiAgICAgICAgICAgIHZhciByYSA9IHJvb3QuZ2V0V29ybGRQb3MoKTsgLy8gMTAsIDEwXHJcbiAgICAgICAgICAgIHZhciByID0gdGhpcy5nZXRXb3JsZFJvdGF0aW9uKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWxnZWJyYV8yNC5WZWN0b3IoeCwgeSkucm90YXRlKHIsIHJhKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGdsb2JhbCBzY2FsZSBvZiB0aGUgQWN0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLmdldEdsb2JhbFNjYWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFsZ2VicmFfMjQuVmVjdG9yKHRoaXMuc2NhbGUueCwgdGhpcy5zY2FsZS55KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcGFyZW50U2NhbGUgPSB0aGlzLnBhcmVudC5nZXRHbG9iYWxTY2FsZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFsZ2VicmFfMjQuVmVjdG9yKHRoaXMuc2NhbGUueCAqIHBhcmVudFNjYWxlLngsIHRoaXMuc2NhbGUueSAqIHBhcmVudFNjYWxlLnkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgYWN0b3IncyBbW0JvdW5kaW5nQm94XV0gY2FsY3VsYXRlZCBmb3IgdGhpcyBpbnN0YW50IGluIHdvcmxkIHNwYWNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyB0b2RvIGNhY2hlIGJvdW5kaW5nIGJveFxyXG4gICAgICAgICAgICB2YXIgYW5jaG9yID0gdGhpcy5fZ2V0Q2FsY3VsYXRlZEFuY2hvcigpO1xyXG4gICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5nZXRXb3JsZFBvcygpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJvdW5kaW5nQm94XzguQm91bmRpbmdCb3gocG9zLnggLSBhbmNob3IueCwgcG9zLnkgLSBhbmNob3IueSwgcG9zLnggKyB0aGlzLmdldFdpZHRoKCkgLSBhbmNob3IueCwgcG9zLnkgKyB0aGlzLmdldEhlaWdodCgpIC0gYW5jaG9yLnkpLnJvdGF0ZSh0aGlzLnJvdGF0aW9uLCBwb3MpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgYWN0b3IncyBbW0JvdW5kaW5nQm94XV0gcmVsYXRpdmUgdG8gdGhlIGFjdG9ycyBwb3NpdGlvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLmdldFJlbGF0aXZlQm91bmRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyB0b2RvIGNhY2hlIGJvdW5kaW5nIGJveFxyXG4gICAgICAgICAgICB2YXIgYW5jaG9yID0gdGhpcy5fZ2V0Q2FsY3VsYXRlZEFuY2hvcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJvdW5kaW5nQm94XzguQm91bmRpbmdCb3goLWFuY2hvci54LCAtYW5jaG9yLnksIHRoaXMuZ2V0V2lkdGgoKSAtIGFuY2hvci54LCB0aGlzLmdldEhlaWdodCgpIC0gYW5jaG9yLnkpLnJvdGF0ZSh0aGlzLnJvdGF0aW9uKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRlc3RzIHdoZXRoZXIgdGhlIHgveSBzcGVjaWZpZWQgYXJlIGNvbnRhaW5lZCBpbiB0aGUgYWN0b3JcclxuICAgICAgICAgKiBAcGFyYW0geCAgWCBjb29yZGluYXRlIHRvIHRlc3QgKGluIHdvcmxkIGNvb3JkaW5hdGVzKVxyXG4gICAgICAgICAqIEBwYXJhbSB5ICBZIGNvb3JkaW5hdGUgdG8gdGVzdCAoaW4gd29ybGQgY29vcmRpbmF0ZXMpXHJcbiAgICAgICAgICogQHBhcmFtIHJlY3Vyc2UgY2hlY2tzIHdoZXRoZXIgdGhlIHgveSBhcmUgY29udGFpbmVkIGluIGFueSBjaGlsZCBhY3RvcnMgKGlmIHRoZXkgZXhpc3QpLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAoeCwgeSwgcmVjdXJzZSkge1xyXG4gICAgICAgICAgICBpZiAocmVjdXJzZSA9PT0gdm9pZCAwKSB7IHJlY3Vyc2UgPSBmYWxzZTsgfVxyXG4gICAgICAgICAgICB2YXIgY29udGFpbm1lbnQgPSB0aGlzLmdldEJvdW5kcygpLmNvbnRhaW5zKG5ldyBBbGdlYnJhXzI0LlZlY3Rvcih4LCB5KSk7XHJcbiAgICAgICAgICAgIGlmIChyZWN1cnNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGFpbm1lbnQgfHwgdGhpcy5jaGlsZHJlbi5zb21lKGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5jb250YWlucyh4LCB5LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjb250YWlubWVudDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIHNpZGUgb2YgdGhlIGNvbGxpc2lvbiBiYXNlZCBvbiB0aGUgaW50ZXJzZWN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIGludGVyc2VjdCBUaGUgZGlzcGxhY2VtZW50IHZlY3RvciByZXR1cm5lZCBieSBhIGNvbGxpc2lvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUuZ2V0U2lkZUZyb21JbnRlcnNlY3QgPSBmdW5jdGlvbiAoaW50ZXJzZWN0KSB7XHJcbiAgICAgICAgICAgIGlmIChpbnRlcnNlY3QpIHtcclxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhpbnRlcnNlY3QueCkgPiBNYXRoLmFicyhpbnRlcnNlY3QueSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW50ZXJzZWN0LnggPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBTaWRlXzQuU2lkZS5SaWdodDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNpZGVfNC5TaWRlLkxlZnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW50ZXJzZWN0LnkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBTaWRlXzQuU2lkZS5Cb3R0b207XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTaWRlXzQuU2lkZS5Ub3A7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFNpZGVfNC5TaWRlLk5vbmU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZXN0IHdoZXRoZXIgdGhlIGFjdG9yIGhhcyBjb2xsaWRlZCB3aXRoIGFub3RoZXIgYWN0b3IsIHJldHVybnMgdGhlIHNpZGUgb2YgdGhlIGN1cnJlbnQgYWN0b3IgdGhhdCBjb2xsaWRlZC5cclxuICAgICAgICAgKiBAcGFyYW0gYWN0b3IgVGhlIG90aGVyIGFjdG9yIHRvIHRlc3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLmNvbGxpZGVzV2l0aFNpZGUgPSBmdW5jdGlvbiAoYWN0b3IpIHtcclxuICAgICAgICAgICAgdmFyIHNlcGFyYXRpb25WZWN0b3IgPSB0aGlzLmNvbGxpZGVzKGFjdG9yKTtcclxuICAgICAgICAgICAgaWYgKCFzZXBhcmF0aW9uVmVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU2lkZV80LlNpZGUuTm9uZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoc2VwYXJhdGlvblZlY3Rvci54KSA+IE1hdGguYWJzKHNlcGFyYXRpb25WZWN0b3IueSkpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBvcy54IDwgYWN0b3IucG9zLngpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU2lkZV80LlNpZGUuUmlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU2lkZV80LlNpZGUuTGVmdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBvcy55IDwgYWN0b3IucG9zLnkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU2lkZV80LlNpZGUuQm90dG9tO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNpZGVfNC5TaWRlLlRvcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVzdCB3aGV0aGVyIHRoZSBhY3RvciBoYXMgY29sbGlkZWQgd2l0aCBhbm90aGVyIGFjdG9yLCByZXR1cm5zIHRoZSBpbnRlcnNlY3Rpb24gdmVjdG9yIG9uIGNvbGxpc2lvbi4gUmV0dXJuc1xyXG4gICAgICAgICAqIGBudWxsYCB3aGVuIHRoZXJlIGlzIG5vIGNvbGxpc2lvbjtcclxuICAgICAgICAgKiBAcGFyYW0gYWN0b3IgVGhlIG90aGVyIGFjdG9yIHRvIHRlc3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLmNvbGxpZGVzID0gZnVuY3Rpb24gKGFjdG9yKSB7XHJcbiAgICAgICAgICAgIHZhciBib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpO1xyXG4gICAgICAgICAgICB2YXIgb3RoZXJCb3VuZHMgPSBhY3Rvci5nZXRCb3VuZHMoKTtcclxuICAgICAgICAgICAgdmFyIGludGVyc2VjdCA9IGJvdW5kcy5jb2xsaWRlcyhvdGhlckJvdW5kcyk7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnRlcnNlY3Q7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWdpc3RlciBhIGhhbmRsZXIgdG8gZmlyZSB3aGVuIHRoaXMgYWN0b3IgY29sbGlkZXMgd2l0aCBhbm90aGVyIGluIGEgc3BlY2lmaWVkIGdyb3VwXHJcbiAgICAgICAgICogQHBhcmFtIGdyb3VwIFRoZSBncm91cCBuYW1lIHRvIGxpc3RlbiBmb3JcclxuICAgICAgICAgKiBAcGFyYW0gZnVuYyBUaGUgY2FsbGJhY2sgdG8gZmlyZSBvbiBjb2xsaXNpb24gd2l0aCBhbm90aGVyIGFjdG9yIGZyb20gdGhlIGdyb3VwLiBUaGUgY2FsbGJhY2sgaXMgcGFzc2VkIHRoZSBvdGhlciBhY3Rvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLm9uQ29sbGlkZXNXaXRoID0gZnVuY3Rpb24gKGdyb3VwLCBmdW5jKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fY29sbGlzaW9uSGFuZGxlcnNbZ3JvdXBdKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xsaXNpb25IYW5kbGVyc1tncm91cF0gPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9jb2xsaXNpb25IYW5kbGVyc1tncm91cF0ucHVzaChmdW5jKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUuZ2V0Q29sbGlzaW9uSGFuZGxlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2xsaXNpb25IYW5kbGVycztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgYWxsIGNvbGxpc2lvbiBoYW5kbGVycyBmb3IgdGhpcyBncm91cCBvbiB0aGlzIGFjdG9yXHJcbiAgICAgICAgICogQHBhcmFtIGdyb3VwIEdyb3VwIHRvIHJlbW92ZSBhbGwgaGFuZGxlcnMgZm9yIG9uIHRoaXMgYWN0b3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQWN0b3JJbXBsLnByb3RvdHlwZS5yZW1vdmVDb2xsaWRlc1dpdGggPSBmdW5jdGlvbiAoZ3JvdXApIHtcclxuICAgICAgICAgICAgdGhpcy5fY29sbGlzaW9uSGFuZGxlcnNbZ3JvdXBdID0gW107XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHR3byBhY3RvcnMgYXJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgZGlzdGFuY2Ugc3BlY2lmaWVkIGZyb20gZWFjaCBvdGhlclxyXG4gICAgICAgICAqIEBwYXJhbSBhY3RvciAgICAgQWN0b3IgdG8gdGVzdFxyXG4gICAgICAgICAqIEBwYXJhbSBkaXN0YW5jZSAgRGlzdGFuY2UgaW4gcGl4ZWxzIHRvIHRlc3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLndpdGhpbiA9IGZ1bmN0aW9uIChhY3RvciwgZGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh0aGlzLnBvcy54IC0gYWN0b3IucG9zLngsIDIpICsgTWF0aC5wb3codGhpcy5wb3MueSAtIGFjdG9yLnBvcy55LCAyKSkgPD0gZGlzdGFuY2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLl9nZXRDYWxjdWxhdGVkQW5jaG9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFsZ2VicmFfMjQuVmVjdG9yKHRoaXMuZ2V0V2lkdGgoKSAqIHRoaXMuYW5jaG9yLngsIHRoaXMuZ2V0SGVpZ2h0KCkgKiB0aGlzLmFuY2hvci55KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUuX3JlYXBwbHlFZmZlY3RzID0gZnVuY3Rpb24gKGRyYXdpbmcpIHtcclxuICAgICAgICAgICAgZHJhd2luZy5yZW1vdmVFZmZlY3QodGhpcy5fb3BhY2l0eUZ4KTtcclxuICAgICAgICAgICAgZHJhd2luZy5hZGRFZmZlY3QodGhpcy5fb3BhY2l0eUZ4KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBlcmZvcm0gZXVsZXIgaW50ZWdyYXRpb24gYXQgdGhlIHNwZWNpZmllZCB0aW1lIHN0ZXBcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLmludGVncmF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xyXG4gICAgICAgICAgICAvLyBVcGRhdGUgcGxhY2VtZW50cyBiYXNlZCBvbiBsaW5lYXIgYWxnZWJyYVxyXG4gICAgICAgICAgICB2YXIgc2Vjb25kcyA9IGRlbHRhIC8gMTAwMDtcclxuICAgICAgICAgICAgdmFyIHRvdGFsQWNjID0gdGhpcy5hY2MuY2xvbmUoKTtcclxuICAgICAgICAgICAgLy8gT25seSBhY3RpdmUgdmFuaWxsYSBhY3RvcnMgYXJlIGFmZmVjdGVkIGJ5IGdsb2JhbCBhY2NlbGVyYXRpb25cclxuICAgICAgICAgICAgaWYgKHRoaXMuY29sbGlzaW9uVHlwZSA9PT0gQ29sbGlzaW9uVHlwZS5BY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIHRvdGFsQWNjLmFkZEVxdWFsKFBoeXNpY3NfMTMuUGh5c2ljcy5hY2MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudmVsLmFkZEVxdWFsKHRvdGFsQWNjLnNjYWxlKHNlY29uZHMpKTtcclxuICAgICAgICAgICAgdGhpcy5wb3MuYWRkRXF1YWwodGhpcy52ZWwuc2NhbGUoc2Vjb25kcykpLmFkZEVxdWFsKHRvdGFsQWNjLnNjYWxlKDAuNSAqIHNlY29uZHMgKiBzZWNvbmRzKSk7XHJcbiAgICAgICAgICAgIHRoaXMucnggKz0gdGhpcy50b3JxdWUgKiAoMS4wIC8gdGhpcy5tb2kpICogc2Vjb25kcztcclxuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbiArPSB0aGlzLnJ4ICogc2Vjb25kcztcclxuICAgICAgICAgICAgdGhpcy5zY2FsZS54ICs9IHRoaXMuc3ggKiBkZWx0YSAvIDEwMDA7XHJcbiAgICAgICAgICAgIHRoaXMuc2NhbGUueSArPSB0aGlzLnN5ICogZGVsdGEgLyAxMDAwO1xyXG4gICAgICAgICAgICAvLyBVcGRhdGUgcGh5c2ljcyBib2R5XHJcbiAgICAgICAgICAgIHRoaXMuYm9keS51cGRhdGUoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGxlZCBieSB0aGUgRW5naW5lLCB1cGRhdGVzIHRoZSBzdGF0ZSBvZiB0aGUgYWN0b3JcclxuICAgICAgICAgKiBAcGFyYW0gZW5naW5lIFRoZSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZ2FtZSBlbmdpbmVcclxuICAgICAgICAgKiBAcGFyYW0gZGVsdGEgIFRoZSB0aW1lIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdXBkYXRlIGluIG1pbGxpc2Vjb25kc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFjdG9ySW1wbC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGVuZ2luZSwgZGVsdGEpIHtcclxuICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZShlbmdpbmUpO1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3ByZXVwZGF0ZScsIG5ldyBFdmVudHNfMTQuUHJlVXBkYXRlRXZlbnQoZW5naW5lLCBkZWx0YSwgdGhpcykpO1xyXG4gICAgICAgICAgICAvLyBVcGRhdGUgYWN0aW9uIHF1ZXVlXHJcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUudXBkYXRlKGRlbHRhKTtcclxuICAgICAgICAgICAgLy8gVXBkYXRlIGNvbG9yIG9ubHkgb3BhY2l0eVxyXG4gICAgICAgICAgICBpZiAodGhpcy5jb2xvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb2xvci5hID0gdGhpcy5vcGFjaXR5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBjaGFuZ2luZyBvcGFjaXR5XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXZpb3VzT3BhY2l0eSAhPT0gdGhpcy5vcGFjaXR5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzT3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX29wYWNpdHlGeC5vcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZWZmZWN0c0RpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBDYXB0dXJlIG9sZCB2YWx1ZXMgYmVmb3JlIGludGVncmF0aW9uIHN0ZXAgdXBkYXRlcyB0aGVtXHJcbiAgICAgICAgICAgIHRoaXMub2xkVmVsLnNldFRvKHRoaXMudmVsLngsIHRoaXMudmVsLnkpO1xyXG4gICAgICAgICAgICB0aGlzLm9sZFBvcy5zZXRUbyh0aGlzLnBvcy54LCB0aGlzLnBvcy55KTtcclxuICAgICAgICAgICAgLy8gUnVuIEV1bGVyIGludGVncmF0aW9uXHJcbiAgICAgICAgICAgIHRoaXMuaW50ZWdyYXRlKGRlbHRhKTtcclxuICAgICAgICAgICAgLy8gVXBkYXRlIGFjdG9yIHBpcGVsaW5lIChtb3ZlbWVudCwgY29sbGlzaW9uIGRldGVjdGlvbiwgZXZlbnQgcHJvcGFnYXRpb24sIG9mZnNjcmVlbiBjdWxsaW5nKVxyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy50cmFpdHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHJhaXQgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICB0cmFpdC51cGRhdGUodGhpcywgZW5naW5lLCBkZWx0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVXBkYXRlIGNoaWxkIGFjdG9yc1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0udXBkYXRlKGVuZ2luZSwgZGVsdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncG9zdHVwZGF0ZScsIG5ldyBFdmVudHNfMTQuUG9zdFVwZGF0ZUV2ZW50KGVuZ2luZSwgZGVsdGEsIHRoaXMpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGxlZCBieSB0aGUgRW5naW5lLCBkcmF3cyB0aGUgYWN0b3IgdG8gdGhlIHNjcmVlblxyXG4gICAgICAgICAqIEBwYXJhbSBjdHggICBUaGUgcmVuZGVyaW5nIGNvbnRleHRcclxuICAgICAgICAgKiBAcGFyYW0gZGVsdGEgVGhlIHRpbWUgc2luY2UgdGhlIGxhc3QgZHJhdyBpbiBtaWxsaXNlY29uZHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoY3R4LCBkZWx0YSkge1xyXG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKHRoaXMucG9zLngsIHRoaXMucG9zLnkpO1xyXG4gICAgICAgICAgICBjdHgucm90YXRlKHRoaXMucm90YXRpb24pO1xyXG4gICAgICAgICAgICBjdHguc2NhbGUodGhpcy5zY2FsZS54LCB0aGlzLnNjYWxlLnkpO1xyXG4gICAgICAgICAgICAvLyB0cmFuc2xhdGUgY2FudmFzIGJ5IGFuY2hvciBvZmZzZXRcclxuICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtKHRoaXMuX3dpZHRoICogdGhpcy5hbmNob3IueCksIC0odGhpcy5faGVpZ2h0ICogdGhpcy5hbmNob3IueSkpO1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3ByZWRyYXcnLCBuZXcgRXZlbnRzXzE0LlByZURyYXdFdmVudChjdHgsIGRlbHRhLCB0aGlzKSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnREcmF3aW5nKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZHJhd2luZyA9IHRoaXMuY3VycmVudERyYXdpbmc7XHJcbiAgICAgICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2V4Y2FsaWJ1cmpzL0V4Y2FsaWJ1ci9wdWxsLzYxOSBmb3IgZGlzY3Vzc2lvbiBvbiB0aGlzIGZvcm11bGEgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0WCA9ICh0aGlzLl93aWR0aCAtIGRyYXdpbmcubmF0dXJhbFdpZHRoICogZHJhd2luZy5zY2FsZS54KSAqIHRoaXMuYW5jaG9yLng7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0WSA9ICh0aGlzLl9oZWlnaHQgLSBkcmF3aW5nLm5hdHVyYWxIZWlnaHQgKiBkcmF3aW5nLnNjYWxlLnkpICogdGhpcy5hbmNob3IueTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lZmZlY3RzRGlydHkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWFwcGx5RWZmZWN0cyh0aGlzLmN1cnJlbnREcmF3aW5nKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lZmZlY3RzRGlydHkgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudERyYXdpbmcuZHJhdyhjdHgsIG9mZnNldFgsIG9mZnNldFkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29sb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5jb2xvci50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICAvLyBEcmF3IGNoaWxkIGFjdG9yc1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldLnZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLmRyYXcoY3R4LCBkZWx0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdwb3N0ZHJhdycsIG5ldyBFdmVudHNfMTQuUG9zdERyYXdFdmVudChjdHgsIGRlbHRhLCB0aGlzKSk7XHJcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxsZWQgYnkgdGhlIEVuZ2luZSwgZHJhd3MgdGhlIGFjdG9ycyBkZWJ1Z2dpbmcgdG8gdGhlIHNjcmVlblxyXG4gICAgICAgICAqIEBwYXJhbSBjdHggVGhlIHJlbmRlcmluZyBjb250ZXh0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBBY3RvckltcGwucHJvdG90eXBlLmRlYnVnRHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdwcmVkZWJ1Z2RyYXcnLCBuZXcgRXZlbnRzXzE0LlByZURlYnVnRHJhd0V2ZW50KGN0eCwgdGhpcykpO1xyXG4gICAgICAgICAgICB0aGlzLmJvZHkuZGVidWdEcmF3KGN0eCk7XHJcbiAgICAgICAgICAgIC8vIERyYXcgYWN0b3IgYm91bmRpbmcgYm94XHJcbiAgICAgICAgICAgIHZhciBiYiA9IHRoaXMuZ2V0Qm91bmRzKCk7XHJcbiAgICAgICAgICAgIGJiLmRlYnVnRHJhdyhjdHgpO1xyXG4gICAgICAgICAgICAvLyBEcmF3IGFjdG9yIElkXHJcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dCgnaWQ6ICcgKyB0aGlzLmlkLCBiYi5sZWZ0ICsgMywgYmIudG9wICsgMTApO1xyXG4gICAgICAgICAgICAvLyBEcmF3IGFjdG9yIGFuY2hvciBWZWN0b3JcclxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IENvbG9yXzIwLkNvbG9yLlllbGxvdy50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5hcmModGhpcy5nZXRXb3JsZFBvcygpLngsIHRoaXMuZ2V0V29ybGRQb3MoKS55LCAzLCAwLCBNYXRoLlBJICogMik7XHJcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgY3R4LmZpbGwoKTtcclxuICAgICAgICAgICAgLy8gQ3VsbGluZyBCb3ggZGVidWcgZHJhd1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMudHJhaXRzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFpdHNbal0gaW5zdGFuY2VvZiBUcmFpdHMuT2Zmc2NyZWVuQ3VsbGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhaXRzW2pdLmN1bGxpbmdCb3guZGVidWdEcmF3KGN0eCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVW5pdCBDaXJjbGUgZGVidWcgZHJhd1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBDb2xvcl8yMC5Db2xvci5ZZWxsb3cudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICB2YXIgcmFkaXVzID0gTWF0aC5taW4odGhpcy5nZXRXaWR0aCgpLCB0aGlzLmdldEhlaWdodCgpKTtcclxuICAgICAgICAgICAgY3R4LmFyYyh0aGlzLmdldFdvcmxkUG9zKCkueCwgdGhpcy5nZXRXb3JsZFBvcygpLnksIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xyXG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICAgICAgdmFyIHRpY2tzID0ge1xyXG4gICAgICAgICAgICAgICAgJzAgUGknOiAwLFxyXG4gICAgICAgICAgICAgICAgJ1BpLzInOiBNYXRoLlBJIC8gMixcclxuICAgICAgICAgICAgICAgICdQaSc6IE1hdGguUEksXHJcbiAgICAgICAgICAgICAgICAnMy8yIFBpJzogMyAqIE1hdGguUEkgLyAyXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciBvbGRGb250ID0gY3R4LmZvbnQ7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHRpY2sgaW4gdGlja3MpIHtcclxuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBDb2xvcl8yMC5Db2xvci5ZZWxsb3cudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIGN0eC5mb250ID0gJzE0cHgnO1xyXG4gICAgICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KHRpY2ssIHRoaXMuZ2V0V29ybGRQb3MoKS54ICsgTWF0aC5jb3ModGlja3NbdGlja10pICogKHJhZGl1cyArIDEwKSwgdGhpcy5nZXRXb3JsZFBvcygpLnkgKyBNYXRoLnNpbih0aWNrc1t0aWNrXSkgKiAocmFkaXVzICsgMTApKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdHguZm9udCA9IG9sZEZvbnQ7XHJcbiAgICAgICAgICAgIC8vIERyYXcgY2hpbGQgYWN0b3JzXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS5kZWJ1Z0RyYXcoY3R4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3Bvc3RkZWJ1Z2RyYXcnLCBuZXcgRXZlbnRzXzE0LlBvc3REZWJ1Z0RyYXdFdmVudChjdHgsIHRoaXMpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBBY3RvckltcGw7XHJcbiAgICB9KENsYXNzXzExLkNsYXNzKSk7XHJcbiAgICAvKipcclxuICAgICAqIEluZGljYXRlcyB0aGUgbmV4dCBpZCB0byBiZSBzZXRcclxuICAgICAqL1xyXG4gICAgQWN0b3JJbXBsLm1heElkID0gMDtcclxuICAgIGV4cG9ydHMuQWN0b3JJbXBsID0gQWN0b3JJbXBsO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbW9zdCBpbXBvcnRhbnQgcHJpbWl0aXZlIGluIEV4Y2FsaWJ1ciBpcyBhbiBgQWN0b3JgLiBBbnl0aGluZyB0aGF0XHJcbiAgICAgKiBjYW4gbW92ZSBvbiB0aGUgc2NyZWVuLCBjb2xsaWRlIHdpdGggYW5vdGhlciBgQWN0b3JgLCByZXNwb25kIHRvIGV2ZW50cyxcclxuICAgICAqIG9yIGludGVyYWN0IHdpdGggdGhlIGN1cnJlbnQgc2NlbmUsIG11c3QgYmUgYW4gYWN0b3IuIEFuIGBBY3RvcmAgKiptdXN0KipcclxuICAgICAqIGJlIHBhcnQgb2YgYSBbW1NjZW5lXV0gZm9yIGl0IHRvIGJlIGRyYXduIHRvIHRoZSBzY3JlZW4uXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOkFjdG9ycy5tZF1dXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIFtbaW5jbHVkZTpDb25zdHJ1Y3RvcnMubWRdXVxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgdmFyIEFjdG9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoQWN0b3IsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gQWN0b3IoeE9yQ29uZmlnLCB5LCB3aWR0aCwgaGVpZ2h0LCBjb2xvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgeE9yQ29uZmlnLCB5LCB3aWR0aCwgaGVpZ2h0LCBjb2xvcikgfHwgdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEFjdG9yO1xyXG4gICAgfShDb25maWd1cmFibGVfOC5Db25maWd1cmFibGUoQWN0b3JJbXBsKSkpO1xyXG4gICAgZXhwb3J0cy5BY3RvciA9IEFjdG9yO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBlbnVtIHRoYXQgZGVzY3JpYmVzIHRoZSB0eXBlcyBvZiBjb2xsaXNpb25zIGFjdG9ycyBjYW4gcGFydGljaXBhdGUgaW5cclxuICAgICAqL1xyXG4gICAgdmFyIENvbGxpc2lvblR5cGU7XHJcbiAgICAoZnVuY3Rpb24gKENvbGxpc2lvblR5cGUpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBY3RvcnMgd2l0aCB0aGUgYFByZXZlbnRDb2xsaXNpb25gIHNldHRpbmcgZG8gbm90IHBhcnRpY2lwYXRlIGluIGFueVxyXG4gICAgICAgICAqIGNvbGxpc2lvbnMgYW5kIGRvIG5vdCByYWlzZSBjb2xsaXNpb24gZXZlbnRzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbGxpc2lvblR5cGVbQ29sbGlzaW9uVHlwZVtcIlByZXZlbnRDb2xsaXNpb25cIl0gPSAwXSA9IFwiUHJldmVudENvbGxpc2lvblwiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFjdG9ycyB3aXRoIHRoZSBgUGFzc2l2ZWAgc2V0dGluZyBvbmx5IHJhaXNlIGNvbGxpc2lvbiBldmVudHMsIGJ1dCBhcmUgbm90XHJcbiAgICAgICAgICogaW5mbHVlbmNlZCBvciBtb3ZlZCBieSBvdGhlciBhY3RvcnMgYW5kIGRvIG5vdCBpbmZsdWVuY2Ugb3IgbW92ZSBvdGhlciBhY3RvcnMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29sbGlzaW9uVHlwZVtDb2xsaXNpb25UeXBlW1wiUGFzc2l2ZVwiXSA9IDFdID0gXCJQYXNzaXZlXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWN0b3JzIHdpdGggdGhlIGBBY3RpdmVgIHNldHRpbmcgcmFpc2UgY29sbGlzaW9uIGV2ZW50cyBhbmQgcGFydGljaXBhdGVcclxuICAgICAgICAgKiBpbiBjb2xsaXNpb25zIHdpdGggb3RoZXIgYWN0b3JzIGFuZCB3aWxsIGJlIHB1c2ggb3IgbW92ZWQgYnkgYWN0b3JzIHNoYXJpbmdcclxuICAgICAgICAgKiB0aGUgYEFjdGl2ZWAgb3IgYEZpeGVkYCBzZXR0aW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbGxpc2lvblR5cGVbQ29sbGlzaW9uVHlwZVtcIkFjdGl2ZVwiXSA9IDJdID0gXCJBY3RpdmVcIjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBY3RvcnMgd2l0aCB0aGUgYEZpeGVkYCBzZXR0aW5nIHJhaXNlIGNvbGxpc2lvbiBldmVudHMgYW5kIHBhcnRpY2lwYXRlIGluXHJcbiAgICAgICAgICogY29sbGlzaW9ucyB3aXRoIG90aGVyIGFjdG9ycy4gQWN0b3JzIHdpdGggdGhlIGBGaXhlZGAgc2V0dGluZyB3aWxsIG5vdCBiZVxyXG4gICAgICAgICAqIHB1c2hlZCBvciBtb3ZlZCBieSBvdGhlciBhY3RvcnMgc2hhcmluZyB0aGUgYEZpeGVkYC4gVGhpbmsgb2YgRml4ZWRcclxuICAgICAgICAgKiBhY3RvcnMgYXMgXCJpbW1vdmFibGUvb25zdG9wcGFibGVcIiBvYmplY3RzLiBJZiB0d28gYEZpeGVkYCBhY3RvcnMgbWVldCB0aGV5IHdpbGxcclxuICAgICAgICAgKiBub3QgYmUgcHVzaGVkIG9yIG1vdmVkIGJ5IGVhY2ggb3RoZXIsIHRoZXkgd2lsbCBub3QgaW50ZXJhY3QgZXhjZXB0IHRvIHRocm93XHJcbiAgICAgICAgICogY29sbGlzaW9uIGV2ZW50cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDb2xsaXNpb25UeXBlW0NvbGxpc2lvblR5cGVbXCJGaXhlZFwiXSA9IDNdID0gXCJGaXhlZFwiO1xyXG4gICAgfSkoQ29sbGlzaW9uVHlwZSA9IGV4cG9ydHMuQ29sbGlzaW9uVHlwZSB8fCAoZXhwb3J0cy5Db2xsaXNpb25UeXBlID0ge30pKTtcclxufSk7XHJcbmRlZmluZShcIkFjdGlvbnMvQWN0aW9uXCIsIFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiQWN0aW9ucy9Sb3RhdGlvblR5cGVcIiwgXCJBbGdlYnJhXCIsIFwiVXRpbC9Mb2dcIiwgXCJVdGlsL1V0aWxcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBSb3RhdGlvblR5cGVfMiwgQWxnZWJyYV8yNSwgTG9nXzE3LCBVdGlsKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIHZhciBFYXNlVG8gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIEVhc2VUbyhhY3RvciwgeCwgeSwgZHVyYXRpb24sIGVhc2luZ0Zjbikge1xyXG4gICAgICAgICAgICB0aGlzLmFjdG9yID0gYWN0b3I7XHJcbiAgICAgICAgICAgIHRoaXMuZWFzaW5nRmNuID0gZWFzaW5nRmNuO1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50TGVycFRpbWUgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9sZXJwRHVyYXRpb24gPSAxICogMTAwMDsgLy8gMSBzZWNvbmRcclxuICAgICAgICAgICAgdGhpcy5fbGVycFN0YXJ0ID0gbmV3IEFsZ2VicmFfMjUuVmVjdG9yKDAsIDApO1xyXG4gICAgICAgICAgICB0aGlzLl9sZXJwRW5kID0gbmV3IEFsZ2VicmFfMjUuVmVjdG9yKDAsIDApO1xyXG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fbGVycER1cmF0aW9uID0gZHVyYXRpb247XHJcbiAgICAgICAgICAgIHRoaXMuX2xlcnBFbmQgPSBuZXcgQWxnZWJyYV8yNS5WZWN0b3IoeCwgeSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEVhc2VUby5wcm90b3R5cGUuX2luaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xlcnBTdGFydCA9IG5ldyBBbGdlYnJhXzI1LlZlY3Rvcih0aGlzLmFjdG9yLnBvcy54LCB0aGlzLmFjdG9yLnBvcy55KTtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudExlcnBUaW1lID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9sZXJwU3RhcnQuZGlzdGFuY2UodGhpcy5fbGVycEVuZCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBFYXNlVG8ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG5ld1ggPSB0aGlzLmFjdG9yLnBvcy54O1xyXG4gICAgICAgICAgICB2YXIgbmV3WSA9IHRoaXMuYWN0b3IucG9zLnk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50TGVycFRpbWUgPCB0aGlzLl9sZXJwRHVyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sZXJwRW5kLnggPCB0aGlzLl9sZXJwU3RhcnQueCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1ggPSB0aGlzLl9sZXJwU3RhcnQueCAtICh0aGlzLmVhc2luZ0Zjbih0aGlzLl9jdXJyZW50TGVycFRpbWUsIHRoaXMuX2xlcnBFbmQueCwgdGhpcy5fbGVycFN0YXJ0LngsIHRoaXMuX2xlcnBEdXJhdGlvbikgLSB0aGlzLl9sZXJwRW5kLngpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3WCA9IHRoaXMuZWFzaW5nRmNuKHRoaXMuX2N1cnJlbnRMZXJwVGltZSwgdGhpcy5fbGVycFN0YXJ0LngsIHRoaXMuX2xlcnBFbmQueCwgdGhpcy5fbGVycER1cmF0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sZXJwRW5kLnkgPCB0aGlzLl9sZXJwU3RhcnQueSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1kgPSB0aGlzLl9sZXJwU3RhcnQueSAtICh0aGlzLmVhc2luZ0Zjbih0aGlzLl9jdXJyZW50TGVycFRpbWUsIHRoaXMuX2xlcnBFbmQueSwgdGhpcy5fbGVycFN0YXJ0LnksIHRoaXMuX2xlcnBEdXJhdGlvbikgLSB0aGlzLl9sZXJwRW5kLnkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3WSA9IHRoaXMuZWFzaW5nRmNuKHRoaXMuX2N1cnJlbnRMZXJwVGltZSwgdGhpcy5fbGVycFN0YXJ0LnksIHRoaXMuX2xlcnBFbmQueSwgdGhpcy5fbGVycER1cmF0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IucG9zLnggPSBuZXdYO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5wb3MueSA9IG5ld1k7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50TGVycFRpbWUgKz0gZGVsdGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnBvcy54ID0gdGhpcy5fbGVycEVuZC54O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5wb3MueSA9IHRoaXMuX2xlcnBFbmQueTtcclxuICAgICAgICAgICAgICAgIC8vdGhpcy5fbGVycFN0YXJ0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIC8vdGhpcy5fbGVycEVuZCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAvL3RoaXMuX2N1cnJlbnRMZXJwVGltZSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEVhc2VUby5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uIChhY3Rvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZCB8fCAobmV3IEFsZ2VicmFfMjUuVmVjdG9yKGFjdG9yLnBvcy54LCBhY3Rvci5wb3MueSkpLmRpc3RhbmNlKHRoaXMuX2xlcnBTdGFydCkgPj0gdGhpcy5fZGlzdGFuY2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBFYXNlVG8ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRWFzZVRvLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBFYXNlVG87XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5FYXNlVG8gPSBFYXNlVG87XHJcbiAgICB2YXIgTW92ZVRvID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBNb3ZlVG8oYWN0b3IsIGRlc3R4LCBkZXN0eSwgc3BlZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yID0gYWN0b3I7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZCA9IG5ldyBBbGdlYnJhXzI1LlZlY3RvcihkZXN0eCwgZGVzdHkpO1xyXG4gICAgICAgICAgICB0aGlzLl9zcGVlZCA9IHNwZWVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBNb3ZlVG8ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChfZGVsdGEpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ID0gbmV3IEFsZ2VicmFfMjUuVmVjdG9yKHRoaXMuX2FjdG9yLnBvcy54LCB0aGlzLl9hY3Rvci5wb3MueSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IHRoaXMuX3N0YXJ0LmRpc3RhbmNlKHRoaXMuX2VuZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXIgPSB0aGlzLl9lbmQuc3ViKHRoaXMuX3N0YXJ0KS5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbSA9IHRoaXMuX2Rpci5zY2FsZSh0aGlzLl9zcGVlZCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yLnZlbC54ID0gbS54O1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rvci52ZWwueSA9IG0ueTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSh0aGlzLl9hY3RvcikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnBvcy54ID0gdGhpcy5fZW5kLng7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci5wb3MueSA9IHRoaXMuX2VuZC55O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3IudmVsLnkgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3IudmVsLnggPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBNb3ZlVG8ucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoYWN0b3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgKG5ldyBBbGdlYnJhXzI1LlZlY3RvcihhY3Rvci5wb3MueCwgYWN0b3IucG9zLnkpKS5kaXN0YW5jZSh0aGlzLl9zdGFydCkgPj0gdGhpcy5fZGlzdGFuY2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBNb3ZlVG8ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yLnZlbC55ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IudmVsLnggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIE1vdmVUby5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBNb3ZlVG87XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5Nb3ZlVG8gPSBNb3ZlVG87XHJcbiAgICB2YXIgTW92ZUJ5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBNb3ZlQnkoYWN0b3IsIGRlc3R4LCBkZXN0eSwgdGltZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IgPSBhY3RvcjtcclxuICAgICAgICAgICAgdGhpcy5fZW5kID0gbmV3IEFsZ2VicmFfMjUuVmVjdG9yKGRlc3R4LCBkZXN0eSk7XHJcbiAgICAgICAgICAgIGlmICh0aW1lIDw9IDApIHtcclxuICAgICAgICAgICAgICAgIExvZ18xNy5Mb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcignQXR0ZW1wdGVkIHRvIG1vdmVCeSB0aW1lIGxlc3MgdGhhbiBvciBlcXVhbCB0byB6ZXJvIDogJyArIHRpbWUpO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgbW92ZSBpbiB0aW1lIDw9IDAnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl90aW1lID0gdGltZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgTW92ZUJ5LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoX2RlbHRhKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydCA9IG5ldyBBbGdlYnJhXzI1LlZlY3Rvcih0aGlzLl9hY3Rvci5wb3MueCwgdGhpcy5fYWN0b3IucG9zLnkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9zdGFydC5kaXN0YW5jZSh0aGlzLl9lbmQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlyID0gdGhpcy5fZW5kLnN1Yih0aGlzLl9zdGFydCkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGVlZCA9IHRoaXMuX2Rpc3RhbmNlIC8gKHRoaXMuX3RpbWUgLyAxMDAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbSA9IHRoaXMuX2Rpci5zY2FsZSh0aGlzLl9zcGVlZCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yLnZlbC54ID0gbS54O1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rvci52ZWwueSA9IG0ueTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSh0aGlzLl9hY3RvcikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnBvcy54ID0gdGhpcy5fZW5kLng7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci5wb3MueSA9IHRoaXMuX2VuZC55O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3IudmVsLnkgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3IudmVsLnggPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBNb3ZlQnkucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoYWN0b3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgKG5ldyBBbGdlYnJhXzI1LlZlY3RvcihhY3Rvci5wb3MueCwgYWN0b3IucG9zLnkpKS5kaXN0YW5jZSh0aGlzLl9zdGFydCkgPj0gdGhpcy5fZGlzdGFuY2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBNb3ZlQnkucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yLnZlbC55ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IudmVsLnggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIE1vdmVCeS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBNb3ZlQnk7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5Nb3ZlQnkgPSBNb3ZlQnk7XHJcbiAgICB2YXIgRm9sbG93ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBGb2xsb3coYWN0b3IsIGFjdG9yVG9Gb2xsb3csIGZvbGxvd0Rpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RvciA9IGFjdG9yO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RvclRvRm9sbG93ID0gYWN0b3JUb0ZvbGxvdztcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudCA9IG5ldyBBbGdlYnJhXzI1LlZlY3Rvcih0aGlzLl9hY3Rvci5wb3MueCwgdGhpcy5fYWN0b3IucG9zLnkpO1xyXG4gICAgICAgICAgICB0aGlzLl9lbmQgPSBuZXcgQWxnZWJyYV8yNS5WZWN0b3IoYWN0b3JUb0ZvbGxvdy5wb3MueCwgYWN0b3JUb0ZvbGxvdy5wb3MueSk7XHJcbiAgICAgICAgICAgIHRoaXMuX21heGltdW1EaXN0YW5jZSA9IChmb2xsb3dEaXN0YW5jZSAhPT0gdW5kZWZpbmVkKSA/IGZvbGxvd0Rpc3RhbmNlIDogdGhpcy5fY3VycmVudC5kaXN0YW5jZSh0aGlzLl9lbmQpO1xyXG4gICAgICAgICAgICB0aGlzLl9zcGVlZCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEZvbGxvdy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKF9kZWx0YSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2VCZXR3ZWVuID0gdGhpcy5fY3VycmVudC5kaXN0YW5jZSh0aGlzLl9lbmQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlyID0gdGhpcy5fZW5kLnN1Yih0aGlzLl9jdXJyZW50KS5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYWN0b3JUb0ZvbGxvd1NwZWVkID0gTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMuX2FjdG9yVG9Gb2xsb3cudmVsLngsIDIpICsgTWF0aC5wb3codGhpcy5fYWN0b3JUb0ZvbGxvdy52ZWwueSwgMikpO1xyXG4gICAgICAgICAgICBpZiAoYWN0b3JUb0ZvbGxvd1NwZWVkICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGVlZCA9IGFjdG9yVG9Gb2xsb3dTcGVlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50LnggPSB0aGlzLl9hY3Rvci5wb3MueDtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudC55ID0gdGhpcy5fYWN0b3IucG9zLnk7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZC54ID0gdGhpcy5fYWN0b3JUb0ZvbGxvdy5wb3MueDtcclxuICAgICAgICAgICAgdGhpcy5fZW5kLnkgPSB0aGlzLl9hY3RvclRvRm9sbG93LnBvcy55O1xyXG4gICAgICAgICAgICB0aGlzLl9kaXN0YW5jZUJldHdlZW4gPSB0aGlzLl9jdXJyZW50LmRpc3RhbmNlKHRoaXMuX2VuZCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2RpciA9IHRoaXMuX2VuZC5zdWIodGhpcy5fY3VycmVudCkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9kaXN0YW5jZUJldHdlZW4gPj0gdGhpcy5fbWF4aW11bURpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbSA9IHRoaXMuX2Rpci5zY2FsZSh0aGlzLl9zcGVlZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci52ZWwueCA9IG0ueDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnZlbC55ID0gbS55O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3IudmVsLnggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3IudmVsLnkgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ29tcGxldGUoKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyB0aGlzIHNob3VsZCBuZXZlciBvY2N1clxyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3IucG9zLnggPSB0aGlzLl9lbmQueDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnBvcy55ID0gdGhpcy5fZW5kLnk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci52ZWwueSA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci52ZWwueCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEZvbGxvdy5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IudmVsLnkgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rvci52ZWwueCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRm9sbG93LnByb3RvdHlwZS5pc0NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyB0aGUgYWN0b3IgZm9sbG93aW5nIHNob3VsZCBuZXZlciBzdG9wIHVubGVzcyBzcGVjaWZpZWQgdG8gZG8gc29cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBGb2xsb3cucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gRm9sbG93O1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuRm9sbG93ID0gRm9sbG93O1xyXG4gICAgdmFyIE1lZXQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIE1lZXQoYWN0b3IsIGFjdG9yVG9NZWV0LCBzcGVlZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fc3BlZWRXYXNTcGVjaWZpZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IgPSBhY3RvcjtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3JUb01lZXQgPSBhY3RvclRvTWVldDtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudCA9IG5ldyBBbGdlYnJhXzI1LlZlY3Rvcih0aGlzLl9hY3Rvci5wb3MueCwgdGhpcy5fYWN0b3IucG9zLnkpO1xyXG4gICAgICAgICAgICB0aGlzLl9lbmQgPSBuZXcgQWxnZWJyYV8yNS5WZWN0b3IoYWN0b3JUb01lZXQucG9zLngsIGFjdG9yVG9NZWV0LnBvcy55KTtcclxuICAgICAgICAgICAgdGhpcy5fc3BlZWQgPSBzcGVlZCB8fCAwO1xyXG4gICAgICAgICAgICBpZiAoc3BlZWQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3BlZWRXYXNTcGVjaWZpZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE1lZXQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChfZGVsdGEpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlQmV0d2VlbiA9IHRoaXMuX2N1cnJlbnQuZGlzdGFuY2UodGhpcy5fZW5kKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RpciA9IHRoaXMuX2VuZC5zdWIodGhpcy5fY3VycmVudCkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGFjdG9yVG9NZWV0U3BlZWQgPSBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy5fYWN0b3JUb01lZXQudmVsLngsIDIpICsgTWF0aC5wb3codGhpcy5fYWN0b3JUb01lZXQudmVsLnksIDIpKTtcclxuICAgICAgICAgICAgaWYgKChhY3RvclRvTWVldFNwZWVkICE9PSAwKSAmJiAoIXRoaXMuX3NwZWVkV2FzU3BlY2lmaWVkKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3BlZWQgPSBhY3RvclRvTWVldFNwZWVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQueCA9IHRoaXMuX2FjdG9yLnBvcy54O1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50LnkgPSB0aGlzLl9hY3Rvci5wb3MueTtcclxuICAgICAgICAgICAgdGhpcy5fZW5kLnggPSB0aGlzLl9hY3RvclRvTWVldC5wb3MueDtcclxuICAgICAgICAgICAgdGhpcy5fZW5kLnkgPSB0aGlzLl9hY3RvclRvTWVldC5wb3MueTtcclxuICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2VCZXR3ZWVuID0gdGhpcy5fY3VycmVudC5kaXN0YW5jZSh0aGlzLl9lbmQpO1xyXG4gICAgICAgICAgICB0aGlzLl9kaXIgPSB0aGlzLl9lbmQuc3ViKHRoaXMuX2N1cnJlbnQpLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICB2YXIgbSA9IHRoaXMuX2Rpci5zY2FsZSh0aGlzLl9zcGVlZCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yLnZlbC54ID0gbS54O1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rvci52ZWwueSA9IG0ueTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci5wb3MueCA9IHRoaXMuX2VuZC54O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3IucG9zLnkgPSB0aGlzLl9lbmQueTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnZlbC55ID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnZlbC54ID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgTWVldC5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgKHRoaXMuX2Rpc3RhbmNlQmV0d2VlbiA8PSAxKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIE1lZXQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yLnZlbC55ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IudmVsLnggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIE1lZXQucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gTWVldDtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLk1lZXQgPSBNZWV0O1xyXG4gICAgdmFyIFJvdGF0ZVRvID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBSb3RhdGVUbyhhY3RvciwgYW5nbGVSYWRpYW5zLCBzcGVlZCwgcm90YXRpb25UeXBlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RvciA9IGFjdG9yO1xyXG4gICAgICAgICAgICB0aGlzLl9lbmQgPSBhbmdsZVJhZGlhbnM7XHJcbiAgICAgICAgICAgIHRoaXMuX3NwZWVkID0gc3BlZWQ7XHJcbiAgICAgICAgICAgIHRoaXMuX3JvdGF0aW9uVHlwZSA9IHJvdGF0aW9uVHlwZSB8fCBSb3RhdGlvblR5cGVfMi5Sb3RhdGlvblR5cGUuU2hvcnRlc3RQYXRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBSb3RhdGVUby5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKF9kZWx0YSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnQgPSB0aGlzLl9hY3Rvci5yb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZTEgPSBNYXRoLmFicyh0aGlzLl9lbmQgLSB0aGlzLl9zdGFydCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UyID0gVXRpbC5Ud29QSSAtIGRpc3RhbmNlMTtcclxuICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZTEgPiBkaXN0YW5jZTIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydERpc3RhbmNlID0gZGlzdGFuY2UyO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdEaXN0YW5jZSA9IGRpc3RhbmNlMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0RGlzdGFuY2UgPSBkaXN0YW5jZTE7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9uZ0Rpc3RhbmNlID0gZGlzdGFuY2UyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRlc3RQYXRoSXNQb3NpdGl2ZSA9ICh0aGlzLl9zdGFydCAtIHRoaXMuX2VuZCArIFV0aWwuVHdvUEkpICUgVXRpbC5Ud29QSSA+PSBNYXRoLlBJO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9yb3RhdGlvblR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFJvdGF0aW9uVHlwZV8yLlJvdGF0aW9uVHlwZS5TaG9ydGVzdFBhdGg6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gdGhpcy5fc2hvcnREaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Nob3J0ZXN0UGF0aElzUG9zaXRpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFJvdGF0aW9uVHlwZV8yLlJvdGF0aW9uVHlwZS5Mb25nZXN0UGF0aDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9sb25nRGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zaG9ydGVzdFBhdGhJc1Bvc2l0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBSb3RhdGlvblR5cGVfMi5Sb3RhdGlvblR5cGUuQ2xvY2t3aXNlOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fc2hvcnRlc3RQYXRoSXNQb3NpdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9zaG9ydERpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9sb25nRGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBSb3RhdGlvblR5cGVfMi5Sb3RhdGlvblR5cGUuQ291bnRlckNsb2Nrd2lzZTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fc2hvcnRlc3RQYXRoSXNQb3NpdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9zaG9ydERpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9sb25nRGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IucnggPSB0aGlzLl9kaXJlY3Rpb24gKiB0aGlzLl9zcGVlZDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci5yb3RhdGlvbiA9IHRoaXMuX2VuZDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnJ4ID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBSb3RhdGVUby5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGRpc3RhbmNlVHJhdmVsbGVkID0gTWF0aC5hYnModGhpcy5fYWN0b3Iucm90YXRpb24gLSB0aGlzLl9zdGFydCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8IChkaXN0YW5jZVRyYXZlbGxlZCA+PSBNYXRoLmFicyh0aGlzLl9kaXN0YW5jZSkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUm90YXRlVG8ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yLnJ4ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBSb3RhdGVUby5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBSb3RhdGVUbztcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLlJvdGF0ZVRvID0gUm90YXRlVG87XHJcbiAgICB2YXIgUm90YXRlQnkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIFJvdGF0ZUJ5KGFjdG9yLCBhbmdsZVJhZGlhbnMsIHRpbWUsIHJvdGF0aW9uVHlwZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IgPSBhY3RvcjtcclxuICAgICAgICAgICAgdGhpcy5fZW5kID0gYW5nbGVSYWRpYW5zO1xyXG4gICAgICAgICAgICB0aGlzLl90aW1lID0gdGltZTtcclxuICAgICAgICAgICAgdGhpcy5fcm90YXRpb25UeXBlID0gcm90YXRpb25UeXBlIHx8IFJvdGF0aW9uVHlwZV8yLlJvdGF0aW9uVHlwZS5TaG9ydGVzdFBhdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFJvdGF0ZUJ5LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoX2RlbHRhKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydCA9IHRoaXMuX2FjdG9yLnJvdGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlMSA9IE1hdGguYWJzKHRoaXMuX2VuZCAtIHRoaXMuX3N0YXJ0KTtcclxuICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZTIgPSBVdGlsLlR3b1BJIC0gZGlzdGFuY2UxO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlMSA+IGRpc3RhbmNlMikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0RGlzdGFuY2UgPSBkaXN0YW5jZTI7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9uZ0Rpc3RhbmNlID0gZGlzdGFuY2UxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2hvcnREaXN0YW5jZSA9IGRpc3RhbmNlMTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb25nRGlzdGFuY2UgPSBkaXN0YW5jZTI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydGVzdFBhdGhJc1Bvc2l0aXZlID0gKHRoaXMuX3N0YXJ0IC0gdGhpcy5fZW5kICsgVXRpbC5Ud29QSSkgJSBVdGlsLlR3b1BJID49IE1hdGguUEk7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3JvdGF0aW9uVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUm90YXRpb25UeXBlXzIuUm90YXRpb25UeXBlLlNob3J0ZXN0UGF0aDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9zaG9ydERpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fc2hvcnRlc3RQYXRoSXNQb3NpdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUm90YXRpb25UeXBlXzIuUm90YXRpb25UeXBlLkxvbmdlc3RQYXRoOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IHRoaXMuX2xvbmdEaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Nob3J0ZXN0UGF0aElzUG9zaXRpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFJvdGF0aW9uVHlwZV8yLlJvdGF0aW9uVHlwZS5DbG9ja3dpc2U6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zaG9ydERpc3RhbmNlID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gdGhpcy5fc2hvcnREaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gdGhpcy5fbG9uZ0Rpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUm90YXRpb25UeXBlXzIuUm90YXRpb25UeXBlLkNvdW50ZXJDbG9ja3dpc2U6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fc2hvcnREaXN0YW5jZSA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IHRoaXMuX3Nob3J0RGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IHRoaXMuX2xvbmdEaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3NwZWVkID0gTWF0aC5hYnModGhpcy5fZGlzdGFuY2UgLyB0aGlzLl90aW1lICogMTAwMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IucnggPSB0aGlzLl9kaXJlY3Rpb24gKiB0aGlzLl9zcGVlZDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci5yb3RhdGlvbiA9IHRoaXMuX2VuZDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnJ4ID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBSb3RhdGVCeS5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGRpc3RhbmNlVHJhdmVsbGVkID0gTWF0aC5hYnModGhpcy5fYWN0b3Iucm90YXRpb24gLSB0aGlzLl9zdGFydCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8IChkaXN0YW5jZVRyYXZlbGxlZCA+PSBNYXRoLmFicyh0aGlzLl9kaXN0YW5jZSkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUm90YXRlQnkucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yLnJ4ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBSb3RhdGVCeS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBSb3RhdGVCeTtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLlJvdGF0ZUJ5ID0gUm90YXRlQnk7XHJcbiAgICB2YXIgU2NhbGVUbyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gU2NhbGVUbyhhY3Rvciwgc2NhbGVYLCBzY2FsZVksIHNwZWVkWCwgc3BlZWRZKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RvciA9IGFjdG9yO1xyXG4gICAgICAgICAgICB0aGlzLl9lbmRYID0gc2NhbGVYO1xyXG4gICAgICAgICAgICB0aGlzLl9lbmRZID0gc2NhbGVZO1xyXG4gICAgICAgICAgICB0aGlzLl9zcGVlZFggPSBzcGVlZFg7XHJcbiAgICAgICAgICAgIHRoaXMuX3NwZWVkWSA9IHNwZWVkWTtcclxuICAgICAgICB9XHJcbiAgICAgICAgU2NhbGVUby5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKF9kZWx0YSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRYID0gdGhpcy5fYWN0b3Iuc2NhbGUueDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0WSA9IHRoaXMuX2FjdG9yLnNjYWxlLnk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXN0YW5jZVggPSBNYXRoLmFicyh0aGlzLl9lbmRYIC0gdGhpcy5fc3RhcnRYKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlWSA9IE1hdGguYWJzKHRoaXMuX2VuZFkgLSB0aGlzLl9zdGFydFkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghKE1hdGguYWJzKHRoaXMuX2FjdG9yLnNjYWxlLnggLSB0aGlzLl9zdGFydFgpID49IHRoaXMuX2Rpc3RhbmNlWCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkaXJlY3Rpb25YID0gdGhpcy5fZW5kWSA8IHRoaXMuX3N0YXJ0WSA/IC0xIDogMTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnN4ID0gdGhpcy5fc3BlZWRYICogZGlyZWN0aW9uWDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnN4ID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIShNYXRoLmFicyh0aGlzLl9hY3Rvci5zY2FsZS55IC0gdGhpcy5fc3RhcnRZKSA+PSB0aGlzLl9kaXN0YW5jZVkpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9uWSA9IHRoaXMuX2VuZFkgPCB0aGlzLl9zdGFydFkgPyAtMSA6IDE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci5zeSA9IHRoaXMuX3NwZWVkWSAqIGRpcmVjdGlvblk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci5zeSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci5zY2FsZS54ID0gdGhpcy5fZW5kWDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnNjYWxlLnkgPSB0aGlzLl9lbmRZO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3Iuc3ggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3Iuc3kgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTY2FsZVRvLnByb3RvdHlwZS5pc0NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZCB8fCAoKE1hdGguYWJzKHRoaXMuX2FjdG9yLnNjYWxlLnkgLSB0aGlzLl9zdGFydFgpID49IHRoaXMuX2Rpc3RhbmNlWCkgJiZcclxuICAgICAgICAgICAgICAgIChNYXRoLmFicyh0aGlzLl9hY3Rvci5zY2FsZS55IC0gdGhpcy5fc3RhcnRZKSA+PSB0aGlzLl9kaXN0YW5jZVkpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNjYWxlVG8ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yLnN4ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3Iuc3kgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNjYWxlVG8ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gU2NhbGVUbztcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLlNjYWxlVG8gPSBTY2FsZVRvO1xyXG4gICAgdmFyIFNjYWxlQnkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIFNjYWxlQnkoYWN0b3IsIHNjYWxlWCwgc2NhbGVZLCB0aW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RvciA9IGFjdG9yO1xyXG4gICAgICAgICAgICB0aGlzLl9lbmRYID0gc2NhbGVYO1xyXG4gICAgICAgICAgICB0aGlzLl9lbmRZID0gc2NhbGVZO1xyXG4gICAgICAgICAgICB0aGlzLl9zcGVlZFggPSAodGhpcy5fZW5kWCAtIHRoaXMuX2FjdG9yLnNjYWxlLngpIC8gdGltZSAqIDEwMDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3NwZWVkWSA9ICh0aGlzLl9lbmRZIC0gdGhpcy5fYWN0b3Iuc2NhbGUueSkgLyB0aW1lICogMTAwMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgU2NhbGVCeS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKF9kZWx0YSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRYID0gdGhpcy5fYWN0b3Iuc2NhbGUueDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0WSA9IHRoaXMuX2FjdG9yLnNjYWxlLnk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXN0YW5jZVggPSBNYXRoLmFicyh0aGlzLl9lbmRYIC0gdGhpcy5fc3RhcnRYKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlWSA9IE1hdGguYWJzKHRoaXMuX2VuZFkgLSB0aGlzLl9zdGFydFkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBkaXJlY3Rpb25YID0gdGhpcy5fZW5kWCA8IHRoaXMuX3N0YXJ0WCA/IC0xIDogMTtcclxuICAgICAgICAgICAgdmFyIGRpcmVjdGlvblkgPSB0aGlzLl9lbmRZIDwgdGhpcy5fc3RhcnRZID8gLTEgOiAxO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rvci5zeCA9IHRoaXMuX3NwZWVkWCAqIGRpcmVjdGlvblg7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yLnN5ID0gdGhpcy5fc3BlZWRZICogZGlyZWN0aW9uWTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rvci5zY2FsZS54ID0gdGhpcy5fZW5kWDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnNjYWxlLnkgPSB0aGlzLl9lbmRZO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3Iuc3ggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3Iuc3kgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTY2FsZUJ5LnByb3RvdHlwZS5pc0NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZCB8fCAoKE1hdGguYWJzKHRoaXMuX2FjdG9yLnNjYWxlLnggLSB0aGlzLl9zdGFydFgpID49IHRoaXMuX2Rpc3RhbmNlWCkgJiZcclxuICAgICAgICAgICAgICAgIChNYXRoLmFicyh0aGlzLl9hY3Rvci5zY2FsZS55IC0gdGhpcy5fc3RhcnRZKSA+PSB0aGlzLl9kaXN0YW5jZVkpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNjYWxlQnkucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yLnN4ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3Iuc3kgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNjYWxlQnkucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gU2NhbGVCeTtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLlNjYWxlQnkgPSBTY2FsZUJ5O1xyXG4gICAgdmFyIERlbGF5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBEZWxheShhY3RvciwgZGVsYXkpIHtcclxuICAgICAgICAgICAgdGhpcy5fZWxhcHNlZFRpbWUgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IgPSBhY3RvcjtcclxuICAgICAgICAgICAgdGhpcy5fZGVsYXkgPSBkZWxheTtcclxuICAgICAgICB9XHJcbiAgICAgICAgRGVsYXkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMueCA9IHRoaXMuX2FjdG9yLnBvcy54O1xyXG4gICAgICAgICAgICB0aGlzLnkgPSB0aGlzLl9hY3Rvci5wb3MueTtcclxuICAgICAgICAgICAgdGhpcy5fZWxhcHNlZFRpbWUgKz0gZGVsdGE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBEZWxheS5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgKHRoaXMuX2VsYXBzZWRUaW1lID49IHRoaXMuX2RlbGF5KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIERlbGF5LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIERlbGF5LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fZWxhcHNlZFRpbWUgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gRGVsYXk7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5EZWxheSA9IERlbGF5O1xyXG4gICAgdmFyIEJsaW5rID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBCbGluayhhY3RvciwgdGltZVZpc2libGUsIHRpbWVOb3RWaXNpYmxlLCBudW1CbGlua3MpIHtcclxuICAgICAgICAgICAgaWYgKG51bUJsaW5rcyA9PT0gdm9pZCAwKSB7IG51bUJsaW5rcyA9IDE7IH1cclxuICAgICAgICAgICAgdGhpcy5fdGltZVZpc2libGUgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl90aW1lTm90VmlzaWJsZSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2VsYXBzZWRUaW1lID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fdG90YWxUaW1lID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yID0gYWN0b3I7XHJcbiAgICAgICAgICAgIHRoaXMuX3RpbWVWaXNpYmxlID0gdGltZVZpc2libGU7XHJcbiAgICAgICAgICAgIHRoaXMuX3RpbWVOb3RWaXNpYmxlID0gdGltZU5vdFZpc2libGU7XHJcbiAgICAgICAgICAgIHRoaXMuX2R1cmF0aW9uID0gKHRpbWVWaXNpYmxlICsgdGltZU5vdFZpc2libGUpICogbnVtQmxpbmtzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBCbGluay5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fZWxhcHNlZFRpbWUgKz0gZGVsdGE7XHJcbiAgICAgICAgICAgIHRoaXMuX3RvdGFsVGltZSArPSBkZWx0YTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2FjdG9yLnZpc2libGUgJiYgdGhpcy5fZWxhcHNlZFRpbWUgPj0gdGhpcy5fdGltZVZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VsYXBzZWRUaW1lID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2FjdG9yLnZpc2libGUgJiYgdGhpcy5fZWxhcHNlZFRpbWUgPj0gdGhpcy5fdGltZU5vdFZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZWxhcHNlZFRpbWUgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ29tcGxldGUoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3IudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEJsaW5rLnByb3RvdHlwZS5pc0NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZCB8fCAodGhpcy5fdG90YWxUaW1lID49IHRoaXMuX2R1cmF0aW9uKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEJsaW5rLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rvci52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBCbGluay5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fZWxhcHNlZFRpbWUgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl90b3RhbFRpbWUgPSAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEJsaW5rO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuQmxpbmsgPSBCbGluaztcclxuICAgIHZhciBGYWRlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBGYWRlKGFjdG9yLCBlbmRPcGFjaXR5LCBzcGVlZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9tdWx0aXBsaWVyID0gMTtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yID0gYWN0b3I7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZE9wYWNpdHkgPSBlbmRPcGFjaXR5O1xyXG4gICAgICAgICAgICB0aGlzLl9zcGVlZCA9IHNwZWVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBGYWRlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIC8vIGRldGVybWluZSBkaXJlY3Rpb24gd2hlbiB3ZSBzdGFydFxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2VuZE9wYWNpdHkgPCB0aGlzLl9hY3Rvci5vcGFjaXR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbXVsdGlwbGllciA9IC0xO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbXVsdGlwbGllciA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX3NwZWVkID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0b3Iub3BhY2l0eSArPSB0aGlzLl9tdWx0aXBsaWVyICogKE1hdGguYWJzKHRoaXMuX2FjdG9yLm9wYWNpdHkgLSB0aGlzLl9lbmRPcGFjaXR5KSAqIGRlbHRhKSAvIHRoaXMuX3NwZWVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3NwZWVkIC09IGRlbHRhO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0NvbXBsZXRlKCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yLm9wYWNpdHkgPSB0aGlzLl9lbmRPcGFjaXR5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIExvZ18xNy5Mb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnW0FjdGlvbiBmYWRlXSBBY3RvciBvcGFjaXR5OicsIHRoaXMuX2FjdG9yLm9wYWNpdHkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRmFkZS5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgKE1hdGguYWJzKHRoaXMuX2FjdG9yLm9wYWNpdHkgLSB0aGlzLl9lbmRPcGFjaXR5KSA8IDAuMDUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRmFkZS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBGYWRlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEZhZGU7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5GYWRlID0gRmFkZTtcclxuICAgIHZhciBEaWUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIERpZShhY3Rvcikge1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yID0gYWN0b3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIERpZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKF9kZWx0YSkge1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rvci5hY3Rpb25RdWV1ZS5jbGVhckFjdGlvbnMoKTtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3Iua2lsbCgpO1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIERpZS5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBEaWUucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7IHJldHVybjsgfTtcclxuICAgICAgICBEaWUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XHJcbiAgICAgICAgcmV0dXJuIERpZTtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkRpZSA9IERpZTtcclxuICAgIHZhciBDYWxsTWV0aG9kID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBDYWxsTWV0aG9kKGFjdG9yLCBtZXRob2QpIHtcclxuICAgICAgICAgICAgdGhpcy5fbWV0aG9kID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3IgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl9oYXNCZWVuQ2FsbGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yID0gYWN0b3I7XHJcbiAgICAgICAgICAgIHRoaXMuX21ldGhvZCA9IG1ldGhvZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgQ2FsbE1ldGhvZC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKF9kZWx0YSkge1xyXG4gICAgICAgICAgICB0aGlzLl9tZXRob2QuY2FsbCh0aGlzLl9hY3Rvcik7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhc0JlZW5DYWxsZWQgPSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQ2FsbE1ldGhvZC5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhc0JlZW5DYWxsZWQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDYWxsTWV0aG9kLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5faGFzQmVlbkNhbGxlZCA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQ2FsbE1ldGhvZC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5faGFzQmVlbkNhbGxlZCA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gQ2FsbE1ldGhvZDtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLkNhbGxNZXRob2QgPSBDYWxsTWV0aG9kO1xyXG4gICAgdmFyIFJlcGVhdCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gUmVwZWF0KGFjdG9yLCByZXBlYXQsIGFjdGlvbnMpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RvciA9IGFjdG9yO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25RdWV1ZSA9IG5ldyBBY3Rpb25RdWV1ZShhY3Rvcik7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcGVhdCA9IHJlcGVhdDtcclxuICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxSZXBlYXQgPSByZXBlYXQ7XHJcbiAgICAgICAgICAgIHZhciBpID0gMCwgbGVuID0gYWN0aW9ucy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhY3Rpb25zW2ldLnJlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rpb25RdWV1ZS5hZGQoYWN0aW9uc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgO1xyXG4gICAgICAgIH1cclxuICAgICAgICBSZXBlYXQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xyXG4gICAgICAgICAgICB0aGlzLnggPSB0aGlzLl9hY3Rvci5wb3MueDtcclxuICAgICAgICAgICAgdGhpcy55ID0gdGhpcy5fYWN0b3IucG9zLnk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fYWN0aW9uUXVldWUuaGFzTmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rpb25RdWV1ZS5yZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwZWF0LS07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fYWN0aW9uUXVldWUudXBkYXRlKGRlbHRhKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFJlcGVhdC5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgKHRoaXMuX3JlcGVhdCA8PSAwKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFJlcGVhdC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBSZXBlYXQucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZXBlYXQgPSB0aGlzLl9vcmlnaW5hbFJlcGVhdDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBSZXBlYXQ7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5SZXBlYXQgPSBSZXBlYXQ7XHJcbiAgICB2YXIgUmVwZWF0Rm9yZXZlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gUmVwZWF0Rm9yZXZlcihhY3RvciwgYWN0aW9ucykge1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yID0gYWN0b3I7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvblF1ZXVlID0gbmV3IEFjdGlvblF1ZXVlKGFjdG9yKTtcclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSBhY3Rpb25zLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGFjdGlvbnNbaV0ucmVzZXQoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGlvblF1ZXVlLmFkZChhY3Rpb25zW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFJlcGVhdEZvcmV2ZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xyXG4gICAgICAgICAgICB0aGlzLnggPSB0aGlzLl9hY3Rvci5wb3MueDtcclxuICAgICAgICAgICAgdGhpcy55ID0gdGhpcy5fYWN0b3IucG9zLnk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdG9wcGVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9hY3Rpb25RdWV1ZS5oYXNOZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGlvblF1ZXVlLnJlc2V0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fYWN0aW9uUXVldWUudXBkYXRlKGRlbHRhKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFJlcGVhdEZvcmV2ZXIucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUmVwZWF0Rm9yZXZlci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvblF1ZXVlLmNsZWFyQWN0aW9ucygpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUmVwZWF0Rm9yZXZlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybjsgfTtcclxuICAgICAgICByZXR1cm4gUmVwZWF0Rm9yZXZlcjtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLlJlcGVhdEZvcmV2ZXIgPSBSZXBlYXRGb3JldmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBY3Rpb24gUXVldWVzXHJcbiAgICAgKlxyXG4gICAgICogQWN0aW9uIHF1ZXVlcyBhcmUgcGFydCBvZiB0aGUgW1tBY3Rpb25Db250ZXh0fEFjdGlvbiBBUEldXSBhbmRcclxuICAgICAqIHN0b3JlIHRoZSBsaXN0IG9mIGFjdGlvbnMgdG8gYmUgZXhlY3V0ZWQgZm9yIGFuIFtbQWN0b3JdXS5cclxuICAgICAqXHJcbiAgICAgKiBBY3RvcnMgaW1wbGVtZW50IFtbQWN0b3IuYWN0aW9uc11dIHdoaWNoIGNhbiBiZSBtYW5pcHVsYXRlZCBieVxyXG4gICAgICogYWR2YW5jZWQgdXNlcnMgdG8gYWRqdXN0IHRoZSBhY3Rpb25zIGN1cnJlbnRseSBiZWluZyBleGVjdXRlZCBpbiB0aGVcclxuICAgICAqIHF1ZXVlLlxyXG4gICAgICovXHJcbiAgICB2YXIgQWN0aW9uUXVldWUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIEFjdGlvblF1ZXVlKGFjdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbnMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5fY29tcGxldGVkQWN0aW9ucyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RvciA9IGFjdG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBBY3Rpb25RdWV1ZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGFjdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25zLnB1c2goYWN0aW9uKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEFjdGlvblF1ZXVlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX2FjdGlvbnMuaW5kZXhPZihhY3Rpb24pO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25zLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBY3Rpb25RdWV1ZS5wcm90b3R5cGUuY2xlYXJBY3Rpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25zLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbXBsZXRlZEFjdGlvbnMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRBY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRBY3Rpb24uc3RvcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBY3Rpb25RdWV1ZS5wcm90b3R5cGUuZ2V0QWN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGlvbnMuY29uY2F0KHRoaXMuX2NvbXBsZXRlZEFjdGlvbnMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQWN0aW9uUXVldWUucHJvdG90eXBlLmhhc05leHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hY3Rpb25zLmxlbmd0aCA+IDA7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBY3Rpb25RdWV1ZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbnMgPSB0aGlzLmdldEFjdGlvbnMoKTtcclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9hY3Rpb25zLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGlvbnNbaV0ucmVzZXQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9jb21wbGV0ZWRBY3Rpb25zID0gW107XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBY3Rpb25RdWV1ZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9hY3Rpb25zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRBY3Rpb24gPSB0aGlzLl9hY3Rpb25zWzBdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudEFjdGlvbi51cGRhdGUoZGVsdGEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRBY3Rpb24uaXNDb21wbGV0ZSh0aGlzLl9hY3RvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb21wbGV0ZWRBY3Rpb25zLnB1c2godGhpcy5fYWN0aW9ucy5zaGlmdCgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEFjdGlvblF1ZXVlO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuQWN0aW9uUXVldWUgPSBBY3Rpb25RdWV1ZTtcclxufSk7XHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbmlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgd2luZG93ID0geyBhdWRpb0NvbnRleHQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuOyB9IH07XHJcbn1cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XHJcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID1cclxuICAgICAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XHJcbiAgICAgICAgICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGNhbGxiYWNrKSB7IHdpbmRvdy5zZXRJbnRlcnZhbChjYWxsYmFjaywgMTAwMCAvIDYwKTsgfTtcclxufVxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgIXdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSkge1xyXG4gICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID1cclxuICAgICAgICB3aW5kb3cud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHxcclxuICAgICAgICAgICAgd2luZG93Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuOyB9O1xyXG59XHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhd2luZG93LkF1ZGlvQ29udGV4dCkge1xyXG4gICAgd2luZG93LkF1ZGlvQ29udGV4dCA9IHdpbmRvdy5BdWRpb0NvbnRleHQgfHxcclxuICAgICAgICB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0IHx8XHJcbiAgICAgICAgd2luZG93Lm1vekF1ZGlvQ29udGV4dCB8fFxyXG4gICAgICAgIHdpbmRvdy5tc0F1ZGlvQ29udGV4dCB8fFxyXG4gICAgICAgIHdpbmRvdy5vQXVkaW9Db250ZXh0O1xyXG59XHJcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhd2luZG93LmRldmljZVBpeGVsUmF0aW8pIHtcclxuICAgIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcclxufVxyXG4vLyBQb2x5ZmlsbCBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZvckVhY2hcclxuLy8gUHJvZHVjdGlvbiBzdGVwcyBvZiBFQ01BLTI2MiwgRWRpdGlvbiA1LCAxNS40LjQuMThcclxuLy8gUmVmZXJlbmNlOiBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjQuNC4xOFxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5pZiAoIUFycmF5LnByb3RvdHlwZS5mb3JFYWNoKSB7XHJcbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc0FyZykge1xyXG4gICAgICAgIHZhciBULCBrO1xyXG4gICAgICAgIGlmICh0aGlzID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGhpcyBpcyBudWxsIG9yIG5vdCBkZWZpbmVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDEuIExldCBPIGJlIHRoZSByZXN1bHQgb2YgY2FsbGluZyBUb09iamVjdCBwYXNzaW5nIHRoZSB8dGhpc3wgdmFsdWUgYXMgdGhlIGFyZ3VtZW50LiBcclxuICAgICAgICB2YXIgTyA9IE9iamVjdCh0aGlzKTtcclxuICAgICAgICAvLyAyLiBMZXQgbGVuVmFsdWUgYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBHZXQgaW50ZXJuYWwgbWV0aG9kIG9mIE8gd2l0aCB0aGUgYXJndW1lbnQgXCJsZW5ndGhcIi5cclxuICAgICAgICAvLyAzLiBMZXQgbGVuIGJlIFRvVWludDMyKGxlblZhbHVlKS5cclxuICAgICAgICB2YXIgbGVuID0gTy5sZW5ndGggPj4+IDA7XHJcbiAgICAgICAgLy8gNC4gSWYgSXNDYWxsYWJsZShjYWxsYmFjaykgaXMgZmFsc2UsIHRocm93IGEgVHlwZUVycm9yIGV4Y2VwdGlvbi5cclxuICAgICAgICAvLyBTZWU6IGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDkuMTFcclxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY2FsbGJhY2sgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDUuIElmIHRoaXNBcmcgd2FzIHN1cHBsaWVkLCBsZXQgVCBiZSB0aGlzQXJnOyBlbHNlIGxldCBUIGJlIHVuZGVmaW5lZC5cclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgVCA9IHRoaXNBcmc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDYuIExldCBrIGJlIDBcclxuICAgICAgICBrID0gMDtcclxuICAgICAgICAvLyA3LiBSZXBlYXQsIHdoaWxlIGsgPCBsZW5cclxuICAgICAgICB3aGlsZSAoayA8IGxlbikge1xyXG4gICAgICAgICAgICB2YXIga1ZhbHVlO1xyXG4gICAgICAgICAgICAvLyBhLiBMZXQgUGsgYmUgVG9TdHJpbmcoaykuXHJcbiAgICAgICAgICAgIC8vICAgVGhpcyBpcyBpbXBsaWNpdCBmb3IgTEhTIG9wZXJhbmRzIG9mIHRoZSBpbiBvcGVyYXRvclxyXG4gICAgICAgICAgICAvLyBiLiBMZXQga1ByZXNlbnQgYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBIYXNQcm9wZXJ0eSBpbnRlcm5hbCBtZXRob2Qgb2YgTyB3aXRoIGFyZ3VtZW50IFBrLlxyXG4gICAgICAgICAgICAvLyAgIFRoaXMgc3RlcCBjYW4gYmUgY29tYmluZWQgd2l0aCBjXHJcbiAgICAgICAgICAgIC8vIGMuIElmIGtQcmVzZW50IGlzIHRydWUsIHRoZW5cclxuICAgICAgICAgICAgaWYgKGsgaW4gTykge1xyXG4gICAgICAgICAgICAgICAgLy8gaS4gTGV0IGtWYWx1ZSBiZSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIEdldCBpbnRlcm5hbCBtZXRob2Qgb2YgTyB3aXRoIGFyZ3VtZW50IFBrLlxyXG4gICAgICAgICAgICAgICAga1ZhbHVlID0gT1trXTtcclxuICAgICAgICAgICAgICAgIC8vIGlpLiBDYWxsIHRoZSBDYWxsIGludGVybmFsIG1ldGhvZCBvZiBjYWxsYmFjayB3aXRoIFQgYXMgdGhlIHRoaXMgdmFsdWUgYW5kXHJcbiAgICAgICAgICAgICAgICAvLyBhcmd1bWVudCBsaXN0IGNvbnRhaW5pbmcga1ZhbHVlLCBrLCBhbmQgTy5cclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoVCwga1ZhbHVlLCBrLCBPKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBkLiBJbmNyZWFzZSBrIGJ5IDEuXHJcbiAgICAgICAgICAgIGsrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gOC4gcmV0dXJuIHVuZGVmaW5lZFxyXG4gICAgfTtcclxufVxyXG4vLyBQb2x5ZmlsbCBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvbWVcclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuaWYgKCFBcnJheS5wcm90b3R5cGUuc29tZSkge1xyXG4gICAgQXJyYXkucHJvdG90eXBlLnNvbWUgPSBmdW5jdGlvbiAoZnVuIC8qLCB0aGlzQXJnICovKSB7XHJcbiAgICAgICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgICAgIGlmICh0aGlzID09PSB2b2lkIDAgfHwgdGhpcyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xyXG4gICAgICAgIHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcclxuICAgICAgICBpZiAodHlwZW9mIGZ1biAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0aGlzQXJnID0gYXJndW1lbnRzLmxlbmd0aCA+PSAyID8gYXJndW1lbnRzWzFdIDogdm9pZCAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGkgaW4gdCAmJiBmdW4uY2FsbCh0aGlzQXJnLCB0W2ldLCBpLCB0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxufVxyXG4vLyBQb2x5ZmlsbCBmcm9tICBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9iaW5kI1BvbHlmaWxsXHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbmlmICghRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQpIHtcclxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKG9UaGlzKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIC8vIGNsb3Nlc3QgdGhpbmcgcG9zc2libGUgdG8gdGhlIEVDTUFTY3JpcHQgNVxyXG4gICAgICAgICAgICAvLyBpbnRlcm5hbCBJc0NhbGxhYmxlIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIC0gd2hhdCBpcyB0cnlpbmcgdG8gYmUgYm91bmQgaXMgbm90IGNhbGxhYmxlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBhQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksIGZUb0JpbmQgPSB0aGlzLCBmTk9QID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH0sIGZCb3VuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZUb0JpbmQuYXBwbHkodGhpcyBpbnN0YW5jZW9mIGZOT1AgJiYgb1RoaXNcclxuICAgICAgICAgICAgICAgID8gdGhpc1xyXG4gICAgICAgICAgICAgICAgOiBvVGhpcywgYUFyZ3MuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGZOT1AucHJvdG90eXBlID0gdGhpcy5wcm90b3R5cGU7XHJcbiAgICAgICAgZkJvdW5kLnByb3RvdHlwZSA9IG5ldyBmTk9QKCk7XHJcbiAgICAgICAgcmV0dXJuIGZCb3VuZDtcclxuICAgIH07XHJcbn1cclxuICAgIC8vVGhlIG1vZHVsZXMgZm9yIHlvdXIgcHJvamVjdCB3aWxsIGJlIGlubGluZWQgYWJvdmVcclxuICAgIC8vdGhpcyBzbmlwcGV0LiBBc2sgYWxtb25kIHRvIHN5bmNocm9ub3VzbHkgcmVxdWlyZSB0aGVcclxuICAgIC8vbW9kdWxlIHZhbHVlIGZvciAnbWFpbicgaGVyZSBhbmQgcmV0dXJuIGl0IGFzIHRoZVxyXG4gICAgLy92YWx1ZSB0byB1c2UgZm9yIHRoZSBwdWJsaWMgQVBJIGZvciB0aGUgYnVpbHQgZmlsZS5cclxuICAgIHJldHVybiByZXF1aXJlKCdJbmRleCcpO1xyXG59KSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4Y2FsaWJ1ci5qcy5tYXAiLCJpbXBvcnQgKiBhcyBleCBmcm9tICdleGNhbGlidXInO1xyXG5pbXBvcnQgeyBSZXNvdXJjZSB9IGZyb20gJy4uLy4uL3Jlc291cmNlJztcclxuaW1wb3J0IHsgR2FtZVNldHRpbmdzIH0gZnJvbSAnLi4vLi4vZ2FtZXNldHRpbmdzJztcclxuaW1wb3J0IHsgR2FtZVNjZW5lIH0gZnJvbSAnLi4vLi4vc2NlbmVzL2dhbWVTY2VuZS9nYW1lc2NlbmUnO1xyXG5cclxuY29uc3QgcGVzdFNwcml0ZXMgPSBbUmVzb3VyY2UuUm5kcCwgUmVzb3VyY2UucGVzdGljaWRlMSwgUmVzb3VyY2UucGVzdGljaWRlMl07XHJcblxyXG5jbGFzcyBQZXN0aWNpZGUgZXh0ZW5kcyBleC5BY3RvciB7XHJcbiAgICBwcm90ZWN0ZWQgdG9wUGFydDogZXguQWN0b3I7XHJcbiAgICBwcm90ZWN0ZWQgYm90dG9tUGFydDogZXguQWN0b3I7XHJcbiAgICBwcm90ZWN0ZWQgZ2FtZVNjZW5lOiBHYW1lU2NlbmU7XHJcbiAgICBwcm90ZWN0ZWQgcGFzc2VkOiBib29sZWFuO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHhpOiBudW1iZXIsIHlpOiBudW1iZXIsIHlTcGFjZTogbnVtYmVyLCBzY2VuZTogR2FtZVNjZW5lKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy54ID0geGk7XHJcbiAgICAgICAgdGhpcy5zZXRXaWR0aChHYW1lU2V0dGluZ3MuUEVTVF9XSURUSCk7XHJcbiAgICAgICAgdGhpcy5zZXRIZWlnaHQoeVNwYWNlICsgMiAqIEdhbWVTZXR0aW5ncy5QRVNUX0hFSUdIVCk7XHJcblxyXG4gICAgICAgIHRoaXMudG9wUGFydCA9IG5ldyBleC5BY3RvcigpO1xyXG4gICAgICAgIHZhciB0b3BTcHJpdGUgPSBuZXcgZXguU3ByaXRlKHBlc3RTcHJpdGVzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBlc3RTcHJpdGVzLmxlbmd0aCldLCAwLCAwLCBHYW1lU2V0dGluZ3MuUEVTVF9XSURUSCwgR2FtZVNldHRpbmdzLlBFU1RfSEVJR0hUKTtcclxuICAgICAgICB0b3BTcHJpdGUuZmxpcFZlcnRpY2FsID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnRvcFBhcnQuYWRkRHJhd2luZyh0b3BTcHJpdGUpO1xyXG4gICAgICAgIHRoaXMudG9wUGFydC54ID0gMDtcclxuICAgICAgICB0aGlzLnRvcFBhcnQueSA9IHlpIC0gKEdhbWVTZXR0aW5ncy5QRVNUX0hFSUdIVCArIHlTcGFjZSkgLyAyO1xyXG4gICAgICAgIHRoaXMudG9wUGFydC5zZXRXaWR0aChHYW1lU2V0dGluZ3MuUEVTVF9XSURUSCk7XHJcbiAgICAgICAgdGhpcy50b3BQYXJ0LnNldEhlaWdodChHYW1lU2V0dGluZ3MuUEVTVF9IRUlHSFQpO1xyXG4gICAgICAgIHRoaXMuYWRkKHRoaXMudG9wUGFydCk7XHJcblxyXG4gICAgICAgIHRoaXMuYm90dG9tUGFydCA9IG5ldyBleC5BY3RvcigpO1xyXG4gICAgICAgIHZhciBib3R0b21TcHJpdGUgPSBuZXcgZXguU3ByaXRlKHBlc3RTcHJpdGVzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBlc3RTcHJpdGVzLmxlbmd0aCldLCAwLCAwLCBHYW1lU2V0dGluZ3MuUEVTVF9XSURUSCwgR2FtZVNldHRpbmdzLlBFU1RfSEVJR0hUKTtcclxuICAgICAgICAvL2JvdHRvbVNwcml0ZS5mbGlwVmVydGljYWwgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmJvdHRvbVBhcnQuYWRkRHJhd2luZyhib3R0b21TcHJpdGUpO1xyXG4gICAgICAgIHRoaXMuYm90dG9tUGFydC54ID0gMDtcclxuICAgICAgICB0aGlzLmJvdHRvbVBhcnQueSA9IHlpICsgKEdhbWVTZXR0aW5ncy5QRVNUX0hFSUdIVCArIHlTcGFjZSkgLyAyO1xyXG4gICAgICAgIHRoaXMuYm90dG9tUGFydC5zZXRXaWR0aChHYW1lU2V0dGluZ3MuUEVTVF9XSURUSCk7XHJcbiAgICAgICAgdGhpcy5ib3R0b21QYXJ0LnNldEhlaWdodChHYW1lU2V0dGluZ3MuUEVTVF9IRUlHSFQpO1xyXG4gICAgICAgIHRoaXMuYWRkKHRoaXMuYm90dG9tUGFydCk7XHJcblxyXG4gICAgICAgIHRoaXMuZ2FtZVNjZW5lID0gc2NlbmU7XHJcbiAgICAgICAgdGhpcy5wYXNzZWQgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25Jbml0aWFsaXplKGVuZ2luZTogZXguRW5naW5lKSB7XHJcbiAgICAgICAgLy8gZG8gc3R1ZmZcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdXBkYXRlKGVuZ2luZTogZXguRW5naW5lLCBkZWx0YTogbnVtYmVyKSB7XHJcbiAgICAgIHN1cGVyLnVwZGF0ZShlbmdpbmUsIGRlbHRhKTsgLy8gY2FsbCBiYXNlIHVwZGF0ZSBsb2dpY1xyXG5cclxuICAgICAgaWYodGhpcy5nYW1lU2NlbmUuZ2FtZU92ZXIgfHwgIXRoaXMuZ2FtZVNjZW5lLmdhbWVTdGFydGVkKVxyXG4gICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgdGhpcy54IC09IEdhbWVTZXR0aW5ncy5IU1BFRUQgKiBkZWx0YS8xMDAwO1xyXG5cclxuICAgICAgaWYodGhpcy50b3BQYXJ0LmNvbGxpZGVzKHRoaXMuZ2FtZVNjZW5lLnBsYXllcikgIT0gbnVsbCB8fCB0aGlzLmJvdHRvbVBhcnQuY29sbGlkZXModGhpcy5nYW1lU2NlbmUucGxheWVyKSAhPSBudWxsKVxyXG4gICAgICAgICB0aGlzLmdhbWVTY2VuZS5zZXRHYW1lT3ZlcigpO1xyXG5cclxuICAgICAgaWYodGhpcy54IDwgR2FtZVNldHRpbmdzLlBFU1RfV0lEVEgvMikge1xyXG4gICAgICAgICAgaWYoIXRoaXMucGFzc2VkKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5wYXNzZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgIHRoaXMuZ2FtZVNjZW5lLnNjb3JlKys7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYodGhpcy54IDwgLUdhbWVTZXR0aW5ncy5QRVNUX1dJRFRILzIpIHtcclxuICAgICAgICAgICAgICB0aGlzLmtpbGwoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICB9XHJcbn1cclxuXHJcbmV4cG9ydCB7IFBlc3RpY2lkZSB9OyIsImltcG9ydCAqIGFzIGV4IGZyb20gJ2V4Y2FsaWJ1cic7XHJcbmltcG9ydCB7IFJlc291cmNlIH0gZnJvbSAnLi4vLi4vcmVzb3VyY2UnO1xyXG5pbXBvcnQgeyBHYW1lU2V0dGluZ3MgfSBmcm9tICcuLi8uLi9nYW1lc2V0dGluZ3MnO1xyXG5pbXBvcnQgeyBHYW1lU2NlbmUgfSBmcm9tICcuLi8uLi9zY2VuZXMvZ2FtZVNjZW5lL2dhbWVzY2VuZSc7XHJcblxyXG5jbGFzcyBQbGF5ZXIgZXh0ZW5kcyBleC5BY3RvciB7XHJcbiAgICBwdWJsaWMgeXBvczogbnVtYmVyO1xyXG4gICAgcHVibGljIHlzcGVlZDogbnVtYmVyO1xyXG4gICAgcHVibGljIHlhY2M6IG51bWJlcjtcclxuICAgIHByb3RlY3RlZCBwcmVzc2VkOiBib29sZWFuO1xyXG4gICAgcHVibGljIGZsYXBBbmltYXRpb246IGV4LkFuaW1hdGlvbjtcclxuICAgIC8vcHJpdmF0ZSBnYW1lU3RhcnRlZDogYm9vbGVhbjtcclxuICAgIHByb3RlY3RlZCBnYW1lU2NlbmU6IEdhbWVTY2VuZTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihzY2VuZTogR2FtZVNjZW5lKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy5zZXRXaWR0aCg0OCk7XHJcbiAgICAgICAgdGhpcy5zZXRIZWlnaHQoMzIpO1xyXG4gICAgICAgIHRoaXMueCA9IDEwMDtcclxuXHJcbiAgICAgICAgdGhpcy55cG9zID0gR2FtZVNldHRpbmdzLkhFSUdIVC8yO1xyXG4gICAgICAgIHRoaXMueXNwZWVkID0gMDtcclxuICAgICAgICB0aGlzLnlhY2MgPSBHYW1lU2V0dGluZ3MuR1JBVklUWTtcclxuICAgICAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnkgPSB0aGlzLnlwb3M7XHJcblxyXG4gICAgICAgIC8vdGhpcy5nYW1lU3RhcnRlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICB0aGlzLmdhbWVTY2VuZSA9IHNjZW5lO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvbkluaXRpYWxpemUoZW5naW5lOiBleC5FbmdpbmUpIHtcclxuICAgICAgICB0aGlzLmFkZERyYXdpbmcoXCJpZGxlXCIsIG5ldyBleC5TcHJpdGUoUmVzb3VyY2UuVHhQbGF5ZXIsIDAsIDAsIDY0LCA2NCkpO1xyXG4gICAgICAgIHRoaXMuc2V0RHJhd2luZyhcImlkbGVcIik7XHJcblxyXG4gICAgICAgIGNvbnN0IHBsYXllcklkbGVTaGVldCA9IG5ldyBleC5TcHJpdGVTaGVldChSZXNvdXJjZS5UeFBsYXllciwgMTYsIDEsIDY0LCA2NCk7XHJcbiAgICAgICAgdGhpcy5mbGFwQW5pbWF0aW9uID0gcGxheWVySWRsZVNoZWV0LmdldEFuaW1hdGlvbkJldHdlZW4oZW5naW5lLCAxLCAxNiwgMyk7XHJcbiAgICAgICAgdGhpcy5mbGFwQW5pbWF0aW9uLmxvb3AgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmFkZERyYXdpbmcoXCJmbGFwXCIsIHRoaXMuZmxhcEFuaW1hdGlvbik7XHJcblxyXG4gICAgICAgIGVuZ2luZS5pbnB1dC5wb2ludGVycy5wcmltYXJ5Lm9uKFwiZG93blwiLCB0aGlzLm9uUHJlc3MpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvblByZXNzID0gKCkgPT4ge1xyXG4gICAgICAgIC8vdGhpcy5nYW1lU3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5wcmVzc2VkID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVzZXQgPSAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy55cG9zID0gR2FtZVNldHRpbmdzLkhFSUdIVC8yO1xyXG4gICAgICAgIHRoaXMueXNwZWVkID0gMDtcclxuICAgICAgICB0aGlzLnlhY2MgPSBHYW1lU2V0dGluZ3MuR1JBVklUWTtcclxuICAgICAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnkgPSB0aGlzLnlwb3M7XHJcbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IDA7XHJcblxyXG4gICAgICAgIC8vdGhpcy5nYW1lU3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB1cGRhdGUoZW5naW5lOiBleC5FbmdpbmUsIGRlbHRhOiBudW1iZXIpIHtcclxuICAgICAgc3VwZXIudXBkYXRlKGVuZ2luZSwgZGVsdGEpOyAvLyBjYWxsIGJhc2UgdXBkYXRlIGxvZ2ljXHJcblxyXG4gICAgICBpZih0aGlzLmdhbWVTY2VuZS5nYW1lT3ZlciB8fCAhdGhpcy5nYW1lU2NlbmUuZ2FtZVN0YXJ0ZWQpXHJcbiAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBpZih0aGlzLnByZXNzZWQpIHtcclxuICAgICAgICAgIHRoaXMueXNwZWVkID0gR2FtZVNldHRpbmdzLkZPUkNFO1xyXG4gICAgICAgICAgdGhpcy5zZXREcmF3aW5nKFwiZmxhcFwiKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlXHJcbiAgICAgICAgICB0aGlzLnlzcGVlZCA9IEdhbWVTZXR0aW5ncy5HUkFWSVRZICsgKHRoaXMueXNwZWVkIC0gR2FtZVNldHRpbmdzLkdSQVZJVFkpICogKE1hdGguZXhwKC1kZWx0YS8oMTAwMCpHYW1lU2V0dGluZ3MuSU5FUlRJQSkpKTtcclxuXHJcbiAgICAgIHRoaXMueXBvcyArPSB0aGlzLnlzcGVlZCAqIGRlbHRhLzEwMDA7XHJcbiAgICAgIHRoaXMueSA9IHRoaXMueXBvcztcclxuICAgICAgLy90aGlzLnJvdGF0aW9uID0gTWF0aC5tYXgoLTAuMywgTWF0aC5taW4oMC4zLCBNYXRoLmF0YW4yKHRoaXMueXNwZWVkLCBHYW1lU2V0dGluZ3MuSFNQRUVEKS8yKSk7XHJcbiAgICAgIHRoaXMucm90YXRpb24gPSB0aGlzLnlzcGVlZCA8IDMwMCA/IC0wLjMgOiAodGhpcy55c3BlZWQgPiA2MDAgPyAwLjMgOiAtMC45ICsgMC4wMDIgKiB0aGlzLnlzcGVlZCk7XHJcblxyXG4gICAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgIGlmKHRoaXMuZmxhcEFuaW1hdGlvbi5pc0RvbmUoKSlcclxuICAgICAgICAgIHRoaXMuc2V0RHJhd2luZyhcImlkbGVcIik7XHJcblxyXG5cclxuICAgICAgaWYodGhpcy5jb2xsaWRlcyh0aGlzLmdhbWVTY2VuZS5ncm91bmQpICE9IG51bGwpXHJcbiAgICAgICAgIHRoaXMuZ2FtZVNjZW5lLnNldEdhbWVPdmVyKCk7XHJcbiAgIH1cclxufVxyXG5cclxuZXhwb3J0IHsgUGxheWVyIH07IiwiZXhwb3J0IG5hbWVzcGFjZSBHYW1lU2V0dGluZ3Mge1xyXG4gICAgZXhwb3J0IGNvbnN0IFdJRFRIID0gODAwO1xyXG4gICAgZXhwb3J0IGNvbnN0IEhFSUdIVCA9IDYwMDtcclxuXHJcbiAgICBleHBvcnQgY29uc3QgR1JBVklUWSA9IDgwMDtcclxuICAgIGV4cG9ydCBjb25zdCBGT1JDRSA9IC04MDA7XHJcbiAgICBleHBvcnQgY29uc3QgSU5FUlRJQSA9IDAuMztcclxuICAgIGV4cG9ydCBjb25zdCBIU1BFRUQgPSAyMDA7XHJcblxyXG4gICAgZXhwb3J0IGNvbnN0IFRJTUVfSU5URVJWQUwgPSAxLjU7XHJcbiAgICBleHBvcnQgY29uc3QgVkFSSUFCSUxJVFkgPSAxMDA7XHJcbiAgICBleHBvcnQgY29uc3QgTUFYX1NQQUNFID0gMTYwO1xyXG4gICAgZXhwb3J0IGNvbnN0IE1JTl9TUEFDRSA9IDgwO1xyXG4gICAgZXhwb3J0IGNvbnN0IFNDT1JFX01BWF9ESUZGID0gMTAwO1xyXG4gICAgZXhwb3J0IGNvbnN0IFNUQVJUX1ZfTElNSVQgPSAwLjI7XHJcbiAgICBleHBvcnQgY29uc3QgRU5EX1ZfTElNSVQgPSAxO1xyXG5cclxuICAgIGV4cG9ydCBjb25zdCBHUk9VTkRfSEVJR0hUID0gNjQ7XHJcbiAgICBleHBvcnQgY29uc3QgUEVTVF9IRUlHSFQgPSA1MTI7XHJcbiAgICBleHBvcnQgY29uc3QgUEVTVF9XSURUSCA9IDY0O1xyXG59IiwiaW1wb3J0ICogYXMgZXggZnJvbSAnZXhjYWxpYnVyJztcclxuaW1wb3J0IHsgR2FtZVNjZW5lIH0gZnJvbSAnLi9zY2VuZXMvZ2FtZVNjZW5lL2dhbWVzY2VuZSc7XHJcbmltcG9ydCB7IFBsYXllciB9IGZyb20gJy4vYWN0b3JzL3BsYXllci9wbGF5ZXInO1xyXG5pbXBvcnQgeyBSZXNvdXJjZSB9IGZyb20gJy4vcmVzb3VyY2UnO1xyXG5pbXBvcnQgeyBHYW1lU2V0dGluZ3MgfSBmcm9tICcuL2dhbWVzZXR0aW5ncyc7XHJcblxyXG5jbGFzcyBHYW1lIGV4dGVuZHMgZXguRW5naW5lIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKHsgd2lkdGg6IEdhbWVTZXR0aW5ncy5XSURUSCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogR2FtZVNldHRpbmdzLkhFSUdIVCxcclxuICAgICAgICAgICAgICAgIGRpc3BsYXlNb2RlOiBleC5EaXNwbGF5TW9kZS5GaXhlZCxcclxuICAgICAgICAgICAgICAgIHBvaW50ZXJTY29wZTogZXguSW5wdXQuUG9pbnRlclNjb3BlLkNhbnZhcyB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhcnQobG9hZGVyPzogZXguSUxvYWRlcikge1xyXG4gICAgICAgIHJldHVybiBzdXBlci5zdGFydChsb2FkZXIpO1xyXG4gICAgfVxyXG59XHJcblxyXG52YXIgbG9hZGVyID0gbmV3IGV4LkxvYWRlcigpO1xyXG5mb3IodmFyIHJlc291cmNlIGluIFJlc291cmNlKXtcclxuICAgIGxvYWRlci5hZGRSZXNvdXJjZShSZXNvdXJjZVtyZXNvdXJjZV0pO1xyXG59XHJcblxyXG5jb25zdCBnYW1lID0gbmV3IEdhbWUoKTtcclxuY29uc3QgZ2FtZVNjZW5lID0gbmV3IEdhbWVTY2VuZSgpO1xyXG5cclxuZ2FtZS5hZGQoJ2dhbWVTY2VuZScsIGdhbWVTY2VuZSk7XHJcblxyXG5nYW1lLnN0YXJ0KGxvYWRlcikudGhlbigoKSA9PiB7XHJcbiAgICBnYW1lLmdvVG9TY2VuZSgnZ2FtZVNjZW5lJyk7XHJcbn0pO1xyXG4iLCJpbXBvcnQgKiBhcyBleCBmcm9tICdleGNhbGlidXInO1xyXG5cclxuLy8gSW1hZ2UgYW5kIHNvdW5kIHJlc291cmNlcyB0byBiZSBsb2FkZWRcclxudmFyIFJlc291cmNlID0ge1xyXG5cdFR4UGxheWVyOiBuZXcgZXguVGV4dHVyZShcImFzc2V0cy9iZWUucG5nXCIpLFxyXG5cdEdyb3VuZDogbmV3IGV4LlRleHR1cmUoXCJhc3NldHMvZ3JvdW5kLnBuZ1wiKSxcclxuXHJcblx0cGVzdGljaWRlMTogbmV3IGV4LlRleHR1cmUoXCJhc3NldHMvcGVzdGljaWRlMS5wbmdcIiksXHJcblx0cGVzdGljaWRlMjogbmV3IGV4LlRleHR1cmUoXCJhc3NldHMvcGVzdGljaWRlMi5wbmdcIiksXHJcblx0Um5kcDogbmV3IGV4LlRleHR1cmUoXCJhc3NldHMvcm5kcC5wbmdcIilcclxufVxyXG5cclxuZXhwb3J0IHsgUmVzb3VyY2UgfTsiLCJpbXBvcnQgKiBhcyBleCBmcm9tICdleGNhbGlidXInO1xyXG5pbXBvcnQgeyBSZXNvdXJjZSB9IGZyb20gJy4uLy4uL3Jlc291cmNlJztcclxuaW1wb3J0IHsgUGxheWVyIH0gZnJvbSAnLi4vLi4vYWN0b3JzL3BsYXllci9wbGF5ZXInO1xyXG5pbXBvcnQgeyBQZXN0aWNpZGUgfSBmcm9tICcuLi8uLi9hY3RvcnMvb2JzdGFjbGVzL3Blc3RpY2lkZSc7XHJcbmltcG9ydCB7IEdhbWVTZXR0aW5ncyB9IGZyb20gJy4uLy4uL2dhbWVzZXR0aW5ncyc7XHJcbi8vaW1wb3J0IHsgSW5wdXQgfSBmcm9tICdleGNhbGlidXInO1xyXG5cclxuXHJcbmNsYXNzIEdhbWVTY2VuZSBleHRlbmRzIGV4LlNjZW5lIHtcclxuICAgIHB1YmxpYyBzY29yZTogbnVtYmVyO1xyXG5cclxuICAgIHB1YmxpYyBwbGF5ZXI6IFBsYXllcjtcclxuICAgIHByb3RlY3RlZCBjZW50ZXJMYWJlbDogZXguTGFiZWw7XHJcbiAgICBwcm90ZWN0ZWQgcmVzdGFydExhYmVsOiBleC5MYWJlbDtcclxuICAgIHByb3RlY3RlZCBzY29yZUxhYmVsOiBleC5MYWJlbDtcclxuXHJcbiAgICBwcm90ZWN0ZWQgbGFzdE9ic3RhY2xlVGltZTogbnVtYmVyO1xyXG4gICAgcHJvdGVjdGVkIGxhc3RPYnN0YWNsZVk6IG51bWJlcjtcclxuXHJcbiAgICBwdWJsaWMgZ2FtZVN0YXJ0ZWQ6IGJvb2xlYW47XHJcbiAgICBwdWJsaWMgZ2FtZU92ZXI6IGJvb2xlYW47XHJcbiAgICBwdWJsaWMgcmVzZXRTY2VuZTogYm9vbGVhbjtcclxuICAgIHB1YmxpYyBjYW5SZXN0YXJ0OiBib29sZWFuO1xyXG5cclxuICAgIHB1YmxpYyBncm91bmQ6IGV4LkFjdG9yO1xyXG5cclxuICAgIHB1YmxpYyBvbkluaXRpYWxpemUoZW5naW5lOiBleC5FbmdpbmUpIHtcclxuICAgICAgICB0aGlzLnNjb3JlID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5wbGF5ZXIgPSBuZXcgUGxheWVyKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuYWRkKHRoaXMucGxheWVyKTtcclxuICAgICAgICB0aGlzLnBsYXllci56ID0gNztcclxuXHJcbiAgICAgICAgdGhpcy5sYXN0T2JzdGFjbGVUaW1lID0gR2FtZVNldHRpbmdzLlRJTUVfSU5URVJWQUw7XHJcbiAgICAgICAgdGhpcy5sYXN0T2JzdGFjbGVZID0gR2FtZVNldHRpbmdzLkhFSUdIVC8yO1xyXG5cclxuICAgICAgICB0aGlzLmNlbnRlckxhYmVsID0gbmV3IGV4LkxhYmVsKFwiQ2xpY2sgdG8gc3RhcnQgZmxhcHBpbmcuXCIsIEdhbWVTZXR0aW5ncy5XSURUSC8yLCBHYW1lU2V0dGluZ3MuSEVJR0hULzIsIFwiQXJpYWxcIik7XHJcbiAgICAgICAgdGhpcy5jZW50ZXJMYWJlbC50ZXh0QWxpZ24gPSBleC5UZXh0QWxpZ24uQ2VudGVyO1xyXG4gICAgICAgIHRoaXMuY2VudGVyTGFiZWwuYmFzZUFsaWduID0gZXguQmFzZUFsaWduLk1pZGRsZTtcclxuICAgICAgICB0aGlzLmNlbnRlckxhYmVsLmZvbnRTaXplID0gNDI7XHJcbiAgICAgICAgdGhpcy5jZW50ZXJMYWJlbC5jb2xvciA9IGV4LkNvbG9yLldoaXRlO1xyXG4gICAgICAgIHRoaXMuYWRkKHRoaXMuY2VudGVyTGFiZWwpO1xyXG4gICAgICAgIHRoaXMuY2VudGVyTGFiZWwueiA9IDEwO1xyXG5cclxuICAgICAgICB0aGlzLnJlc3RhcnRMYWJlbCA9IG5ldyBleC5MYWJlbChcImNsaWNrIHRvIHJlc3RhcnRcIiwgR2FtZVNldHRpbmdzLldJRFRILzIsIEdhbWVTZXR0aW5ncy5IRUlHSFQvMiArIDMyLCBcIkFyaWFsXCIpO1xyXG4gICAgICAgIHRoaXMucmVzdGFydExhYmVsLnRleHRBbGlnbiA9IGV4LlRleHRBbGlnbi5DZW50ZXI7XHJcbiAgICAgICAgdGhpcy5yZXN0YXJ0TGFiZWwuYmFzZUFsaWduID0gZXguQmFzZUFsaWduLlRvcDtcclxuICAgICAgICB0aGlzLnJlc3RhcnRMYWJlbC5mb250U2l6ZSA9IDI4O1xyXG4gICAgICAgIHRoaXMucmVzdGFydExhYmVsLmNvbG9yID0gZXguQ29sb3IuV2hpdGU7XHJcbiAgICAgICAgdGhpcy5hZGQodGhpcy5yZXN0YXJ0TGFiZWwpO1xyXG4gICAgICAgIHRoaXMucmVzdGFydExhYmVsLnogPSAxMDtcclxuICAgICAgICB0aGlzLnJlc3RhcnRMYWJlbC52aXNpYmxlID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHRoaXMuc2NvcmVMYWJlbCA9IG5ldyBleC5MYWJlbChcIjBcIiwgR2FtZVNldHRpbmdzLldJRFRILTMyLCAzMiwgXCJBcmlhbFwiKTtcclxuICAgICAgICB0aGlzLnNjb3JlTGFiZWwudGV4dEFsaWduID0gZXguVGV4dEFsaWduLlJpZ2h0O1xyXG4gICAgICAgIHRoaXMuc2NvcmVMYWJlbC5iYXNlQWxpZ24gPSBleC5CYXNlQWxpZ24uVG9wO1xyXG4gICAgICAgIHRoaXMuc2NvcmVMYWJlbC5mb250U2l6ZSA9IDQyO1xyXG4gICAgICAgIHRoaXMuc2NvcmVMYWJlbC5jb2xvciA9IGV4LkNvbG9yLldoaXRlO1xyXG4gICAgICAgIHRoaXMuYWRkKHRoaXMuc2NvcmVMYWJlbCk7XHJcbiAgICAgICAgdGhpcy5zY29yZUxhYmVsLnogPSAxMDtcclxuXHJcbiAgICAgICAgdGhpcy5nYW1lU3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZ2FtZU92ZXIgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnJlc2V0U2NlbmUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNhblJlc3RhcnQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdGhpcy5ncm91bmQgPSBuZXcgZXguQWN0b3IoKTtcclxuICAgICAgICB0aGlzLmdyb3VuZC5hZGREcmF3aW5nKFJlc291cmNlLkdyb3VuZC5hc1Nwcml0ZSgpKTtcclxuICAgICAgICB0aGlzLmdyb3VuZC54ID0gR2FtZVNldHRpbmdzLldJRFRILzI7XHJcbiAgICAgICAgdGhpcy5ncm91bmQueSA9IEdhbWVTZXR0aW5ncy5IRUlHSFQgLSBHYW1lU2V0dGluZ3MuR1JPVU5EX0hFSUdIVC8yO1xyXG4gICAgICAgIHRoaXMuZ3JvdW5kLnNldFdpZHRoKEdhbWVTZXR0aW5ncy5XSURUSCk7XHJcbiAgICAgICAgdGhpcy5ncm91bmQuc2V0SGVpZ2h0KEdhbWVTZXR0aW5ncy5HUk9VTkRfSEVJR0hUKTtcclxuICAgICAgICB0aGlzLmFkZCh0aGlzLmdyb3VuZCk7XHJcbiAgICAgICAgdGhpcy5ncm91bmQueiA9IDU7XHJcblxyXG4gICAgICAgIGVuZ2luZS5pbnB1dC5wb2ludGVycy5wcmltYXJ5Lm9uKFwiZG93blwiLCB0aGlzLm9uUHJlc3MpO1xyXG4gICAgICAgIC8vZW5naW5lLmlucHV0LmtleWJvYXJkLm9uKFwicHJlc3NcIiwgKGV2dDogSW5wdXQuS2V5RXZlbnQpID0+IHsgaWYoZXZ0LmtleSA9PSBJbnB1dC5LZXlzLlNwYWNlKSB0aGlzLm9uU3BhY2UoKSB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5jYW1lcmEucG9zID0gbmV3IGV4LlZlY3RvcihHYW1lU2V0dGluZ3MuV0lEVEgvMiwgR2FtZVNldHRpbmdzLkhFSUdIVC8yKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25QcmVzcyA9ICgpID0+IHtcclxuICAgICAgICBpZighdGhpcy5nYW1lU3RhcnRlZCkge1xyXG4gICAgICAgICAgICB0aGlzLmdhbWVTdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5jZW50ZXJMYWJlbC52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZih0aGlzLmdhbWVPdmVyICYmIHRoaXMuY2FuUmVzdGFydClcclxuICAgICAgICAgICAgdGhpcy5yZXNldFNjZW5lID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcHVibGljIHVwZGF0ZShlbmdpbmU6IGV4LkVuZ2luZSwgZGVsdGE6IG51bWJlcikge1xyXG4gICAgICAgIHN1cGVyLnVwZGF0ZShlbmdpbmUsIGRlbHRhKTtcclxuXHJcbiAgICAgICAgaWYodGhpcy5nYW1lT3ZlciAmJiAhdGhpcy5jYW5SZXN0YXJ0KSB7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdE9ic3RhY2xlVGltZSArPSBkZWx0YS8xMDAwO1xyXG4gICAgICAgICAgICBpZih0aGlzLmxhc3RPYnN0YWNsZVRpbWUgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhblJlc3RhcnQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXN0YXJ0TGFiZWwudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHRoaXMucmVzZXRTY2VuZSkge1xyXG4gICAgICAgICAgICBmb3IodmFyIGFjIGluIHRoaXMuYWN0b3JzKSB7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmFjdG9yc1thY10gaW5zdGFuY2VvZiBQZXN0aWNpZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yc1thY10ua2lsbCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnBsYXllci5yZXNldCgpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zY29yZSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMucmVzdGFydExhYmVsLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5jZW50ZXJMYWJlbC50ZXh0ID0gXCJDbGljayB0byBzdGFydCBmbGFwcGluZy5cIjtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZVN0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5nYW1lT3ZlciA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmNhblJlc3RhcnQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubGFzdE9ic3RhY2xlVGltZSA9IEdhbWVTZXR0aW5ncy5USU1FX0lOVEVSVkFMO1xyXG4gICAgICAgICAgICB0aGlzLmxhc3RPYnN0YWNsZVkgPSBHYW1lU2V0dGluZ3MuSEVJR0hULzI7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJlc2V0U2NlbmUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGVsc2UgaWYodGhpcy5nYW1lT3ZlciB8fCAhdGhpcy5nYW1lU3RhcnRlZClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIC8vc3VwZXIudXBkYXRlKGVuZ2luZSwgZGVsdGEpOyAvLyBjYWxsIGJhc2UgdXBkYXRlIGxvZ2ljXHJcblxyXG4gICAgICAgICAgICB0aGlzLmxhc3RPYnN0YWNsZVRpbWUgKz0gZGVsdGEvMTAwMDtcclxuXHJcbiAgICAgICAgICAgIGlmKHRoaXMubGFzdE9ic3RhY2xlVGltZSA+IEdhbWVTZXR0aW5ncy5USU1FX0lOVEVSVkFMKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9zeCA9IEdhbWVTZXR0aW5ncy5XSURUSCArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIEdhbWVTZXR0aW5ncy5WQVJJQUJJTElUWSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3BhY2VZID0gTWF0aC5mbG9vcihHYW1lU2V0dGluZ3MuTUFYX1NQQUNFIC0gKEdhbWVTZXR0aW5ncy5NQVhfU1BBQ0UgLSBHYW1lU2V0dGluZ3MuTUlOX1NQQUNFKSAvIEdhbWVTZXR0aW5ncy5TQ09SRV9NQVhfRElGRik7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9zeTtcclxuICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3N5ID0gTWF0aC5mbG9vcihzcGFjZVkgKyBNYXRoLnJhbmRvbSgpICogKEdhbWVTZXR0aW5ncy5IRUlHSFQgLSBHYW1lU2V0dGluZ3MuR1JPVU5EX0hFSUdIVCAtIDIqc3BhY2VZKSlcclxuICAgICAgICAgICAgICAgIH0gd2hpbGUoTWF0aC5hYnMocG9zeSAtIHRoaXMubGFzdE9ic3RhY2xlWSkgPiAoR2FtZVNldHRpbmdzLlNUQVJUX1ZfTElNSVQgKyAoR2FtZVNldHRpbmdzLkVORF9WX0xJTUlUIC0gR2FtZVNldHRpbmdzLlNUQVJUX1ZfTElNSVQpICogdGhpcy5zY29yZSAvIEdhbWVTZXR0aW5ncy5TQ09SRV9NQVhfRElGRikgKiBHYW1lU2V0dGluZ3MuSEVJR0hUKTtcclxuICAgICAgICAgICAgICAgIC8vYWxlcnQocG9zeCArIFwiIFwiICsgcG9zeSArIFwiIFwiICsgc3BhY2VZKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChuZXcgUGVzdGljaWRlKHBvc3gsIHBvc3ksIHNwYWNlWSwgdGhpcykpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0T2JzdGFjbGVZID0gcG9zeTtcclxuICAgICAgICAgICAgICAgIHRoaXMubGFzdE9ic3RhY2xlVGltZSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuc2NvcmVMYWJlbC50ZXh0ID0gdGhpcy5zY29yZS50b1N0cmluZygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0R2FtZU92ZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5nYW1lT3ZlciA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5jZW50ZXJMYWJlbC50ZXh0ID0gXCJHYW1lIE92ZXJcIlxyXG4gICAgICAgIHRoaXMuY2VudGVyTGFiZWwudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5sYXN0T2JzdGFjbGVUaW1lID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25BY3RpdmF0ZSgpIHt9XHJcbiAgICBwdWJsaWMgb25EZWFjdGl2YXRlKCkge31cclxufVxyXG5cclxuZXhwb3J0IHsgR2FtZVNjZW5lIH07Il0sInNvdXJjZVJvb3QiOiIifQ==